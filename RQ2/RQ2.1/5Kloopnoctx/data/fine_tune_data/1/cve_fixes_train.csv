,source,target
0,"<S2SV_StartBug> if ( ! nonce1 ) { <S2SV_EndBug> <S2SV_StartBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> <S2SV_StartBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> valid_hex ( nonce1 ) <S2SV_ModEnd> <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" <S2SV_ModEnd> <S2SV_ModStart> n2size < 2 || n2size > 16 <S2SV_ModEnd> <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" <S2SV_ModEnd> "
1,"<S2SV_StartBug> type = * ( tptr ) ; <S2SV_EndBug> <S2SV_StartBug> subtype = * ( tptr + 4 ) ; <S2SV_EndBug> <S2SV_StartBug> tok2str ( eap_type_values , ""unknown"" , * ( tptr + 4 ) ) , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" , <S2SV_EndBug> <S2SV_StartBug> case EAP_TYPE_TLS : <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , <S2SV_EndBug> ","<S2SV_ModStart> ND_TCHECK_8BITS ( tptr ) ; <S2SV_ModStart> ) ; ND_TCHECK_16BITS ( tptr + 2 <S2SV_ModStart> ND_TCHECK_8BITS ( tptr + 4 ) ; <S2SV_ModStart> subtype ) , subtype <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_8BITS ( tptr + count ) ; <S2SV_ModStart> case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ; if ( subtype == EAP_TYPE_TTLS ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> ND_TCHECK_8BITS ( tptr + 5 ) ; <S2SV_ModStart> ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> ND_TCHECK_8BITS ( tptr + 5 ) ; "
2,<S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug> ,<S2SV_ModStart> kfree_skb ( skb ) ; 
3,<S2SV_StartBug> yi . cfg . mask = 0xffffffff ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & yi , 0 , sizeof ( yi ) ) ; "
4,<S2SV_StartBug> if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) { <S2SV_EndBug> ,<S2SV_ModStart> skb -> mac_header <S2SV_ModEnd> 
5,"<S2SV_StartBug> int64_t time , offset ; <S2SV_EndBug> ",<S2SV_ModStart> if ( avio_feof ( f ) ) { index -> item_count = 0 ; av_freep ( & index -> items ) ; return AVERROR_INVALIDDATA ; } 
6,"<S2SV_StartBug> unsigned long tpgt ; <S2SV_EndBug> <S2SV_StartBug> if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) <S2SV_EndBug> ",<S2SV_ModStart> u16 <S2SV_ModEnd> <S2SV_ModStart> kstrtou16 <S2SV_ModEnd> <S2SV_ModStart> >= VHOST_SCSI_MAX_TARGET <S2SV_ModEnd> 
7,"<S2SV_StartBug> TrackWriter * writer = ( TrackWriter * ) gf_list_get ( writers , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stco ) ; gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stsc "
8,<S2SV_StartBug> u32 data ; <S2SV_EndBug> <S2SV_StartBug> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> kvm_read_guest_cached ( vcpu -> kvm , & <S2SV_ModEnd> <S2SV_ModStart> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> "
9,<S2SV_StartBug> * dst = * src ; <S2SV_EndBug> ,<S2SV_ModStart> __switch_to_tm ( src ) ; tm_recheckpoint_new_task ( src ) ; 
10,<S2SV_StartBug> cJSON * c = array -> child ; <S2SV_EndBug> <S2SV_StartBug> while ( c && item > 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> ? array -> child : 0 <S2SV_ModEnd> <S2SV_ModStart> item -- , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
11,"<S2SV_StartBug> ext3_msg ( sb , ""error:<S2SV_blank>invalid<S2SV_blank>sb<S2SV_blank>specification:<S2SV_blank>%s"" , <S2SV_EndBug> ","<S2SV_ModStart> KERN_ERR , "
12,<S2SV_StartBug> ipv6_select_ident ( fptr ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , ( struct rt6_info * ) skb_dst ( skb ) "
13,"<S2SV_StartBug> void __perf_sw_event ( u32 event_id , u64 nr , int nmi , <S2SV_EndBug> <S2SV_StartBug> do_perf_sw_event ( PERF_TYPE_SOFTWARE , event_id , nr , nmi , & data , regs ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
14,"<S2SV_StartBug> # ifndef _MSC_VER <S2SV_EndBug> <S2SV_StartBug> char buf [ EXT2_BLOCK_SIZE ( data ) ] ; <S2SV_EndBug> <S2SV_StartBug> grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> return fileblock + start ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! indir ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> if ( ! indir ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> ",<S2SV_ModStart> char * buf = grub_malloc ( <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( ! buf ) { return - 1 ; } <S2SV_ModEnd> <S2SV_ModStart> ) ; free ( buf <S2SV_ModStart> { free ( buf ) ; <S2SV_ModStart> } <S2SV_ModStart> free ( buf ) ; <S2SV_ModStart> free ( buf ) ; <S2SV_ModStart> free ( buf ) ; <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } 
15,"<S2SV_StartBug> static void fdct16 ( const int16_t in [ 16 ] , int16_t out [ 16 ] ) { <S2SV_EndBug> <S2SV_StartBug> int step1 [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int step2 [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int step3 [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int input [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int temp1 , temp2 ; <S2SV_EndBug> <S2SV_StartBug> int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; <S2SV_EndBug> <S2SV_StartBug> int t0 , t1 , t2 , t3 ; <S2SV_EndBug> <S2SV_StartBug> int x0 , x1 , x2 , x3 ; <S2SV_EndBug> <S2SV_StartBug> out [ 0 ] = fdct_round_shift ( t0 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 4 ] = fdct_round_shift ( t2 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 8 ] = fdct_round_shift ( t1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 12 ] = fdct_round_shift ( t3 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 2 ] = fdct_round_shift ( t0 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 6 ] = fdct_round_shift ( t2 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 10 ] = fdct_round_shift ( t1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 14 ] = fdct_round_shift ( t3 ) ; <S2SV_EndBug> <S2SV_StartBug> temp2 = step3 [ 2 ] * - cospi_24_64 - step3 [ 5 ] * cospi_8_64 ; <S2SV_EndBug> <S2SV_StartBug> temp1 = step3 [ 2 ] * - cospi_8_64 + step3 [ 5 ] * cospi_24_64 ; <S2SV_EndBug> <S2SV_StartBug> step1 [ 2 ] = step3 [ 3 ] - step2 [ 2 ] ; <S2SV_EndBug> <S2SV_StartBug> out [ 1 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 9 ] = fdct_round_shift ( temp2 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 5 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 13 ] = fdct_round_shift ( temp2 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 3 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 11 ] = fdct_round_shift ( temp2 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 7 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 15 ] = fdct_round_shift ( temp2 ) ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> cospi_24_64 + <S2SV_ModEnd> <S2SV_ModStart> cospi_8_64 - <S2SV_ModEnd> <S2SV_ModStart> + step2 [ 2 ] ; step1 [ 3 ] = step3 [ 3 ] - step2 [ 2 ] ; step1 [ 4 ] = step3 [ 4 ] - step2 [ 5 ] ; step1 [ 5 ] = step3 [ 4 ] + <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) 
16,<S2SV_StartBug> ret = convert_ctx_accesses ( env ) ; <S2SV_EndBug> ,<S2SV_ModStart> sanitize_dead_code ( env ) ; if ( ret == 0 ) 
17,<S2SV_StartBug> int i ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! config -> sample_rate ) { strcpy ( wpc -> error_message , ""sample<S2SV_blank>rate<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>zero!"" ) ; return FALSE ; } "
18,"<S2SV_StartBug> SDev = cd -> device ; <S2SV_EndBug> <S2SV_StartBug> ( unsigned char * ) cgc -> sense , & sshdr , <S2SV_EndBug> ","<S2SV_ModStart> unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ; <S2SV_ModStart> ; if ( cgc -> sense ) senseptr = sense_buffer <S2SV_ModStart> senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( cgc -> sense ) memcpy ( cgc -> sense , sense_buffer , sizeof ( * <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> "
19,<S2SV_StartBug> if ( get4 ( ) == 0x48454150 ) <S2SV_EndBug> <S2SV_StartBug> imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_FixedLens ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && ( save + hlen ) >= 0 && ( save + hlen ) <= ifp -> size ( ) # endif ) { # ifdef LIBRAW_LIBRARY_BUILD 
20,"<S2SV_StartBug> static void search_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi , <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> struct loopfilter * const lf = & cm -> lf ; <S2SV_EndBug> <S2SV_StartBug> int best_err ; <S2SV_EndBug> <S2SV_StartBug> int filt_direction = 0 ; <S2SV_EndBug> <S2SV_StartBug> int ss_err [ MAX_LOOP_FILTER + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ss_err , 0xFF , sizeof ( ss_err ) ) ; <S2SV_EndBug> <S2SV_StartBug> int filt_err ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> twopass . section_intra_rating < 20 ) <S2SV_EndBug> <S2SV_StartBug> bias = bias * cpi -> twopass . section_intra_rating / 20 ; <S2SV_EndBug> <S2SV_StartBug> filt_err = try_filter_frame ( sd , cpi , filt_low , partial_frame ) ; <S2SV_EndBug> <S2SV_StartBug> ss_err [ filt_low ] = filt_err ; <S2SV_EndBug> <S2SV_StartBug> if ( filt_err < best_err ) <S2SV_EndBug> <S2SV_StartBug> filt_err = try_filter_frame ( sd , cpi , filt_high , partial_frame ) ; <S2SV_EndBug> <S2SV_StartBug> ss_err [ filt_high ] = filt_err ; <S2SV_EndBug> <S2SV_StartBug> best_err = filt_err ; <S2SV_EndBug> <S2SV_StartBug> lf -> filter_level = filt_best ; <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> const <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; int64_t best_err ; int filt_best <S2SV_ModStart> int64_t <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> int64_t <S2SV_ModEnd> <S2SV_ModStart> ( ( cpi -> oxcf . pass == 2 ) && <S2SV_ModStart> ) bias = ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> ss_err [ filt_low ] <S2SV_ModEnd> <S2SV_ModStart> } if ( ( ss_err [ filt_low ] <S2SV_ModEnd> <S2SV_ModStart> ss_err [ filt_low ] < best_err ) best_err = ss_err [ filt_low ] <S2SV_ModEnd> <S2SV_ModStart> ss_err [ filt_high ] <S2SV_ModEnd> <S2SV_ModStart> } if ( ss_err [ filt_high ] <S2SV_ModEnd> <S2SV_ModStart> ss_err [ filt_high ] <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> 
21,"<S2SV_StartBug> lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ; <S2SV_EndBug> ","<S2SV_ModStart> luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_unpack_full"" ) ; "
22,"<S2SV_StartBug> static void encode_mv_component ( vp9_writer * w , int comp , <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , sign , mvcomp -> sign ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , hp , <S2SV_EndBug> ",<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> 
23,<S2SV_StartBug> return alg -> cra_rng . rng_make_random ? <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
24,<S2SV_StartBug> if ( sp -> sa_protocol != PX_PROTO_PPTP ) <S2SV_EndBug> ,<S2SV_ModStart> sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ; if ( 
25,<S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_16 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 32 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_32 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 64 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_64 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 128 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_128 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 256 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_256 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 512 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_512 ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_1024 ; <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = coapClientGetMaxBlockSize ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } 
26,"<S2SV_StartBug> char * fmtname ; <S2SV_EndBug> <S2SV_StartBug> while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> case OPT_INFILE : <S2SV_EndBug> <S2SV_StartBug> if ( infile ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ; int debug <S2SV_ModStart> debug = 0 ; <S2SV_ModStart> OPT_DEBUG : debug = atoi ( jas_optarg ) ; break ; case <S2SV_ModStart> jas_setdbglevel ( debug ) ; <S2SV_ModStart> jas_stream_close ( instream ) ; 
27,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> siginfo_t info ; void __user * pc = ( void __user * ) instruction_pointer ( regs ) ; <S2SV_ModStart> __show_regs ( regs ) ; info . si_signo = SIGILL ; info . si_errno = 0 ; info . si_code = ILL_ILLOPC ; info . si_addr = pc ; arm64_notify_die <S2SV_ModEnd> <S2SV_ModStart> & info , 0 <S2SV_ModEnd> "
28,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x,<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> ""Direction-#%u"" , * ( ( const u_char * ) ptr ++ ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( length > 5 ) { <S2SV_EndBug> <S2SV_StartBug> print_string ( ndo , ( const u_char * ) ptr , length - 5 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( length < 5 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModStart> dat <S2SV_ModEnd> <S2SV_ModStart> dat += 2 ; length -= 2 <S2SV_ModEnd> <S2SV_ModStart> dat <S2SV_ModEnd> <S2SV_ModStart> dat += 2 ; length -= 2 <S2SV_ModEnd> <S2SV_ModStart> EXTRACT_8BITS ( ptr <S2SV_ModEnd> <S2SV_ModStart> ptr ++ ; length -- ; <S2SV_ModStart> != 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
29,"<S2SV_StartBug> int alt ; <S2SV_EndBug> <S2SV_StartBug> if ( alt < 0 ) <S2SV_EndBug> <S2SV_StartBug> intf -> altsetting [ 0 ] . desc . bInterfaceNumber , alt ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct usb_host_interface * <S2SV_ModEnd> <S2SV_ModStart> ! alt ) return - ENODEV <S2SV_ModEnd> <S2SV_ModStart> alt -> <S2SV_ModEnd> <S2SV_ModStart> -> desc . bAlternateSetting 
30,"<S2SV_StartBug> static void udf_pc_to_char ( struct super_block * sb , unsigned char * from , <S2SV_EndBug> <S2SV_StartBug> int fromlen , unsigned char * to ) <S2SV_EndBug> <S2SV_StartBug> unsigned char * p = to ; <S2SV_EndBug> <S2SV_StartBug> p = to ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( p , ""./"" , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> p += udf_get_filename ( sb , pc -> componentIdent , p , <S2SV_EndBug> <S2SV_StartBug> * p ++ = '/' ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> , int tolen <S2SV_ModStart> int comp_len ; <S2SV_ModStart> ; tolen -- <S2SV_ModStart> if ( tolen == 0 ) return - ENAMETOOLONG ; <S2SV_ModStart> tolen -- ; break ; case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ; <S2SV_ModEnd> <S2SV_ModStart> tolen -= 3 ; <S2SV_ModStart> if ( tolen < 2 ) return - ENAMETOOLONG ; <S2SV_ModStart> tolen -= 2 ; <S2SV_ModStart> comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ; p += comp_len ; tolen -= comp_len ; if ( tolen == 0 ) return - ENAMETOOLONG <S2SV_ModEnd> <S2SV_ModStart> ; tolen -- <S2SV_ModStart> return 0 ; "
31,<S2SV_StartBug> if ( class == - 1 ) { <S2SV_EndBug> ,"<S2SV_ModStart> || class == CLIENT_TYPE_MASTER ) { err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class:<S2SV_blank>the<S2SV_blank>user<S2SV_blank>specified<S2SV_blank>"" ""an<S2SV_blank>invalid<S2SV_blank>one,<S2SV_blank>or<S2SV_blank>\'master\'<S2SV_blank>which<S2SV_blank>has<S2SV_blank>no<S2SV_blank>buffer<S2SV_blank>limits."" <S2SV_ModEnd> "
32,<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( qid > NVMET_NR_QUEUES ) return NULL 
33,"<S2SV_StartBug> usb_set_intfdata ( interface , dev ) ; <S2SV_EndBug> <S2SV_StartBug> exit : <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> usb_set_intfdata ( interface , dev ) ; retval = usb_register_dev ( interface , & tower_class ) ; if ( retval ) { dev_err ( idev , ""Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\n"" ) ; usb_set_intfdata ( interface , NULL ) ; goto error ; } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>"" ""%d<S2SV_blank>minor<S2SV_blank>%d\\n"" , ( dev -> minor - LEGO_USB_TOWER_MINOR_BASE ) , USB_MAJOR , dev -> minor ) ; "
34,<S2SV_StartBug> if ( vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux ) { <S2SV_EndBug> ,<S2SV_ModStart> vstart + vdaux < vstart <S2SV_ModEnd> 
35,"<S2SV_StartBug> static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <S2SV_EndBug> <S2SV_StartBug> kenter ( ""%p"" , dest_keyring ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int ret ; <S2SV_ModStart> bool do_perm_check = true ; <S2SV_ModStart> { do_perm_check = false ; break ; } <S2SV_ModEnd> <S2SV_ModStart> if ( dest_keyring && do_perm_check ) { ret = key_permission ( make_key_ref ( dest_keyring , 1 ) , KEY_NEED_WRITE ) ; if ( ret ) { key_put ( dest_keyring ) ; return ret ; } } <S2SV_ModStart> 0 "
36,<S2SV_StartBug> sc = create_spnego_ctx ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> 1 
37,"<S2SV_StartBug> if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) <S2SV_EndBug> <S2SV_StartBug> if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) <S2SV_EndBug> <S2SV_StartBug> if ( addr -> l2tp_family != AF_INET ) <S2SV_EndBug> <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ","<S2SV_ModStart> addr_len < sizeof ( struct sockaddr_l2tpip <S2SV_ModEnd> <S2SV_ModStart> addr -> l2tp_family != AF_INET <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out "
38,<S2SV_StartBug> static unsigned int stack_maxrandom_size ( void ) <S2SV_EndBug> <S2SV_StartBug> unsigned int max = 0 ; <S2SV_EndBug> <S2SV_StartBug> max = ( ( - 1U ) & STACK_RND_MASK ) << PAGE_SHIFT ; <S2SV_EndBug> ,<S2SV_ModStart> long <S2SV_ModEnd> <S2SV_ModStart> long <S2SV_ModEnd> <S2SV_ModStart> 1UL <S2SV_ModEnd> 
39,"<S2SV_StartBug> _ ( ""_Launch<S2SV_blank>Anyway"" ) , RESPONSE_RUN ) ; <S2SV_EndBug> <S2SV_StartBug> _ ( ""Mark<S2SV_blank>as<S2SV_blank>_Trusted"" ) , RESPONSE_MARK_TRUSTED ) ; <S2SV_EndBug> <S2SV_StartBug> gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , <S2SV_EndBug> ","<S2SV_ModStart> ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL <S2SV_ModEnd> <S2SV_ModStart> ""Trust<S2SV_blank>and<S2SV_blank>_Launch"" ) , GTK_RESPONSE_OK <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
40,<S2SV_StartBug> tm = localtime ( & t ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; if ( tm == NULL ) return g_strdup ( ""???"" "
41,"<S2SV_StartBug> memcpy ( hashed , password , strlen ( password ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> length <S2SV_ModEnd> 
42,"<S2SV_StartBug> static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * d ) <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> d -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ; <S2SV_EndBug> <S2SV_StartBug> if ( d -> fe_adap [ 0 ] . fe == NULL ) <S2SV_EndBug> <S2SV_StartBug> if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ) { <S2SV_EndBug> ","<S2SV_ModStart> adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
43,<S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> sock * sk = asoc -> base . sk ; struct <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
44,<S2SV_StartBug> if ( ! chart || ! * chart ) { <S2SV_EndBug> ,<S2SV_ModStart> fix_google_param ( google_out ) ; fix_google_param ( google_sig ) ; fix_google_param ( google_reqId ) ; fix_google_param ( google_version ) ; fix_google_param ( responseHandler ) ; fix_google_param ( outFileName ) ; 
45,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % stride ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horAcc8"" , ""%s"" , ""(cc%stride)!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; "
46,<S2SV_StartBug> inbuf = _TIFFmalloc ( scanlinesizein ) ; <S2SV_EndBug> ,"<S2SV_ModStart> uint16 bps = 0 ; ( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; if ( bps != 8 ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s"" , ""cpContig2SeparateByRow"" ) ; return 0 ; } "
47,<S2SV_StartBug> struct address_space * mapping ; <S2SV_EndBug> <S2SV_StartBug> if ( mapping ) <S2SV_EndBug> ,<S2SV_ModStart> hugepage_subpool * spool = ( struct hugepage_subpool <S2SV_ModEnd> <S2SV_ModStart> hugepage_subpool_put_pages ( spool <S2SV_ModEnd> 
48,<S2SV_StartBug> if ( pes_signal != 1 || pes_header_data_length == 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> avio_feof ( pb ) ) { return AVERROR_EOF ; } if ( 
49,<S2SV_StartBug> if ( ! e || e == p ) <S2SV_EndBug> ,<S2SV_ModStart> ) goto not_found ; if ( e - p > HOST_NAME_MAX - 1 
50,"<S2SV_StartBug> void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) <S2SV_EndBug> <S2SV_StartBug> get_page ( buf -> page ) ; <S2SV_EndBug> ",<S2SV_ModStart> bool <S2SV_ModEnd> <S2SV_ModStart> return try_get_page <S2SV_ModEnd> 
51,"<S2SV_StartBug> cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , <S2SV_EndBug> ","<S2SV_ModStart> ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart>  <S2SV_ModEnd> "
52,"<S2SV_StartBug> ! inode_capable ( inode , CAP_CHOWN ) ) <S2SV_EndBug> <S2SV_StartBug> ! inode_capable ( inode , CAP_CHOWN ) ) <S2SV_EndBug> <S2SV_StartBug> ! inode_capable ( inode , CAP_FSETID ) ) <S2SV_EndBug> ",<S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> <S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> <S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> 
53,"<S2SV_StartBug> select ( reader -> bytes_available_fd + 1 , & read_fds , NULL , NULL , & timeout ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
54,<S2SV_StartBug> fpm_globals . max_requests = wp -> config -> pm_max_requests ; <S2SV_EndBug> ,<S2SV_ModStart> ; fpm_globals . listening_socket = dup ( wp -> listening_socket ) 
55,"<S2SV_StartBug> static int detect_transition_to_still ( struct twopass_rc * twopass , <S2SV_EndBug> <S2SV_StartBug> int trans_to_still = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( frame_interval > MIN_GF_INTERVAL && <S2SV_EndBug> <S2SV_StartBug> const FIRSTPASS_STATS * position = twopass -> stats_in ; <S2SV_EndBug> <S2SV_StartBug> if ( EOF == input_stats ( twopass , & tmp_next_frame ) ) <S2SV_EndBug> <S2SV_StartBug> if ( tmp_next_frame . pcnt_inter - tmp_next_frame . pcnt_motion < 0.999 ) <S2SV_EndBug> <S2SV_StartBug> reset_fpf_position ( twopass , position ) ; <S2SV_EndBug> <S2SV_StartBug> if ( j == still_interval ) <S2SV_EndBug> <S2SV_StartBug> return trans_to_still ; <S2SV_EndBug> ",<S2SV_ModStart> VP9_COMP * cpi <S2SV_ModEnd> <S2SV_ModStart> TWO_PASS * const twopass = & cpi -> twopass ; RATE_CONTROL * const rc = & cpi -> rc <S2SV_ModEnd> <S2SV_ModStart> rc -> min_gf_interval <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const FIRSTPASS_STATS * stats = & twopass -> stats_in [ j ] ; if ( stats >= twopass -> stats_in_end <S2SV_ModEnd> <S2SV_ModStart> stats -> pcnt_inter - stats -> <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> 
56,<S2SV_StartBug> if ( ! handle -> h_transaction ) { <S2SV_EndBug> <S2SV_StartBug> err = jbd2_journal_stop ( handle ) ; <S2SV_EndBug> <S2SV_StartBug> return handle -> h_err ? handle -> h_err : err ; <S2SV_EndBug> <S2SV_StartBug> sb = handle -> h_transaction -> t_journal -> j_private ; <S2SV_EndBug> ,<S2SV_ModStart> err = handle -> h_err ; <S2SV_ModStart> rc <S2SV_ModEnd> <S2SV_ModStart> err ? err : rc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
57,<S2SV_StartBug> if ( offset + size <= i_size_read ( inode ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
58,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> args -> rmtvaluelen = args -> valuelen ; 
59,"<S2SV_StartBug> request_module ( ""%s"" , name ) ; <S2SV_EndBug> <S2SV_StartBug> request_module ( ""%s-all"" , name ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""crypto-%s"" <S2SV_ModEnd> <S2SV_ModStart> ""crypto-%s-all"" <S2SV_ModEnd> "
60,"<S2SV_StartBug> stlv_type = * ( tptr ++ ) ; <S2SV_EndBug> <S2SV_StartBug> len = len - 2 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> while ( tmp ) <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len ) <S2SV_ModStart> if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; <S2SV_ModStart> if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ; stlv_len = stlv_len <S2SV_ModStart> if ( stlv_len < 8 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> tptr += stlv_len ; len -= stlv_len ; "
61,"<S2SV_StartBug> return reply_msg ( c , MSG_JOB_TOO_BIG ) ; <S2SV_EndBug> ","<S2SV_ModStart> skip ( c , body_size + 2 <S2SV_ModEnd> "
62,<S2SV_StartBug> ddi . dinfo_nboards = dgnc_NumBoards ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & ddi , 0 , sizeof ( ddi ) ) ; "
63,<S2SV_StartBug> if ( ! ( opt_len == 12 && flags & TH_SYN ) && <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) 
64,"<S2SV_StartBug> int procfd = payload -> procfd ; <S2SV_EndBug> <S2SV_StartBug> uid_t new_uid ; <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0)"" ) ; <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1)"" ) ; <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>final<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(2)"" ) ; <S2SV_EndBug> <S2SV_StartBug> rexit ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ""gainable<S2SV_blank>privileges."" ) ; <S2SV_EndBug> <S2SV_StartBug> on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( lsm_set_label_at ( procfd , on_exec , init_ctx -> lsm_label ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> rexit ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> rexit ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> close ( procfd ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int lsm_labelfd ; <S2SV_ModStart> ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0):<S2SV_blank>%s."" , strerror ( errno ) <S2SV_ModEnd> <S2SV_ModStart> ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1):<S2SV_blank>%s."" , strerror ( errno ) <S2SV_ModEnd> <S2SV_ModStart> ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>message<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>"" ""that<S2SV_blank>it<S2SV_blank>is<S2SV_blank>done<S2SV_blank>pre-initializing<S2SV_blank>(2):<S2SV_blank>%s"" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModEnd> <S2SV_ModStart> shutdown ( ipc_socket , SHUT_RDWR ) ; <S2SV_ModStart> ) ; } status = 3 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>set<S2SV_blank>up<S2SV_blank>LSM<S2SV_blank>labels<S2SV_blank>(3):<S2SV_blank>%s."" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 <S2SV_ModStart> ret = lxc_abstract_unix_recv_fd ( ipc_socket , & lsm_labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s."" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> lsm_labelfd <S2SV_ModEnd> <S2SV_ModStart> SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label."" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; close ( lsm_labelfd ) ; rexit ( - 1 ) ; } close ( lsm_labelfd ) ; <S2SV_ModEnd> <S2SV_ModStart> shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
65,"<S2SV_StartBug> line += 3 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = strchr ( line , '<S2SV_blank>' ) ) ) <S2SV_EndBug> <S2SV_StartBug> line = ptr + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = strchr ( line , '\\n' ) ) ) <S2SV_EndBug> ","<S2SV_ModStart> if ( len < 3 ) goto out_err ; <S2SV_ModStart> len -= 3 ; <S2SV_ModStart> memchr <S2SV_ModEnd> <S2SV_ModStart> , len <S2SV_ModStart> if ( len < 1 ) goto out_err ; <S2SV_ModStart> len -= 1 ; <S2SV_ModStart> memchr <S2SV_ModEnd> <S2SV_ModStart> , len "
66,<S2SV_StartBug> if ( header -> biSize >= 40U ) { <S2SV_EndBug> ,"<S2SV_ModStart> biBitCount == 0 ) { fprintf ( stderr , ""Error,<S2SV_blank>invalid<S2SV_blank>biBitCount<S2SV_blank>%d\\n"" , 0 ) ; return OPJ_FALSE ; } if ( header -> "
67,"<S2SV_StartBug> SAS_DPRINTK ( ""DONE<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>result:%d\\n"" , port -> id , <S2SV_EndBug> ",<S2SV_ModStart> sas_probe_devices ( port ) ; 
68,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( image -> colors < tga_info . colormap_index ) image -> colors = tga_info . colormap_index ; 
69,<S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> ,<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> 
70,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & line , 0 , sizeof ( line ) ) ; "
71,"<S2SV_StartBug> return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> int ret ; ret = scsi_verify_blk_ioctl ( bd , cmd ) ; if ( ret < 0 ) return ret ; "
72,"<S2SV_StartBug> void nego_process_negotiation_request ( rdpNego * nego , wStream * s ) <S2SV_EndBug> <S2SV_StartBug> UINT16 length ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> ; if ( Stream_GetRemainingLength ( s ) < 7 ) return FALSE <S2SV_ModStart> return TRUE ; 
73,<S2SV_StartBug> int req_len ; <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned <S2SV_ModStart> ; if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) ) return - EINVAL 
74,<S2SV_StartBug> int m ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( n < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_pad"" ) ; } "
75,<S2SV_StartBug> int xd_size = 0 ; <S2SV_EndBug> <S2SV_StartBug> xd_size += len ; <S2SV_EndBug> <S2SV_StartBug> if ( delta > data_len [ j ] ) { <S2SV_EndBug> <S2SV_StartBug> offset += data_len [ j ] ; <S2SV_EndBug> ,"<S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> + 1 + len / 255 ; } ret = ff_alloc_extradata ( st -> codecpar , xd_size <S2SV_ModEnd> <S2SV_ModStart> av_assert0 ( delta <= xd_size - offset ) ; <S2SV_ModEnd> <S2SV_ModStart> av_assert0 ( data_len [ j ] <= xd_size - offset ) ; "
76,"<S2SV_StartBug> av_log ( mxf , AV_LOG_TRACE , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> -> fc 
77,"<S2SV_StartBug> return mount_entry_on_generic ( mntent , path ) ; <S2SV_EndBug> ","<S2SV_ModStart> , rootfs "
78,"<S2SV_StartBug> psf_binheader_readf ( psf , ""p"" , psf -> fileoffset ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ",<S2SV_ModStart> if ( psf -> fileoffset < psf -> filelength ) { <S2SV_ModStart> } ; 
79,<S2SV_StartBug> l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ; <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK_16BITS ( p + l2info -> cookie_len ) ; 
80,<S2SV_StartBug> return NF_ACCEPT ; <S2SV_EndBug> ,<S2SV_ModStart> err == 0 ? NF_ACCEPT : NF_DROP <S2SV_ModEnd> 
81,"<S2SV_StartBug> if ( ! rta ) <S2SV_EndBug> <S2SV_StartBug> p = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> pp = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> * replay_esn = p ; <S2SV_EndBug> ","<S2SV_ModStart> int klen , ulen ; <S2SV_ModStart> klen = <S2SV_ModEnd> <S2SV_ModStart> ; ulen = nla_len ( rta ) >= klen ? klen : sizeof ( * up ) ; p = kzalloc ( klen <S2SV_ModStart> kzalloc ( klen <S2SV_ModEnd> <S2SV_ModStart> memcpy ( p , up , ulen ) ; memcpy ( pp , up , ulen ) ; "
82,<S2SV_StartBug> io -> io_cleanup = mem_cleanup ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> io -> io_cleanup = mem_cleanup ; 
83,<S2SV_StartBug> result = ( MagickRealType ) ( ( size_t ) pixel & ( size_t ) ( value + 0.5 ) ) ; <S2SV_EndBug> <S2SV_StartBug> result = ( MagickRealType ) ( ( size_t ) pixel << ( size_t ) ( value + 0.5 ) ) ; <S2SV_EndBug> <S2SV_StartBug> result = ( MagickRealType ) ( ( size_t ) pixel | ( size_t ) ( value + 0.5 ) ) ; <S2SV_EndBug> <S2SV_StartBug> result = ( MagickRealType ) ( ( size_t ) pixel >> ( size_t ) ( value + 0.5 ) ) ; <S2SV_EndBug> <S2SV_StartBug> result = ( MagickRealType ) ( ( size_t ) pixel ^ ( size_t ) ( value + 0.5 ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ssize_t <S2SV_ModEnd> 
84,<S2SV_StartBug> btif_config_flush ( ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( is_restricted_mode ( ) ) { BTIF_TRACE_WARNING ( ""%s:<S2SV_blank>\'%s\'<S2SV_blank>pairing<S2SV_blank>will<S2SV_blank>be<S2SV_blank>removed<S2SV_blank>if<S2SV_blank>unrestricted"" , __func__ , bdstr ) ; btif_config_set_int ( bdstr , ""Restricted"" , 1 ) ; } "
85,"<S2SV_StartBug> if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { <S2SV_EndBug> ","<S2SV_ModStart> jas_alloc3 ( bufsize , numcols <S2SV_ModEnd> "
86,<S2SV_StartBug> vpx_codec_enc_cfg_map_t * map ; <S2SV_EndBug> <S2SV_StartBug> for ( map = iface -> enc . cfg_maps ; map -> usage >= 0 ; map ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> ; int i <S2SV_ModStart> i = 0 ; i < iface -> enc . cfg_map_count ; ++ i ) { <S2SV_ModStart> + i ; <S2SV_ModEnd> 
87,"<S2SV_StartBug> netdev_dbg ( vif -> dev , ""GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\n"" , gso -> u . gso . type ) ; <S2SV_EndBug> ",<S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif 
88,"<S2SV_StartBug> static void show_object ( struct object * object , struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , void * data ) <S2SV_EndBug> <S2SV_StartBug> if ( bitmap_pos < 0 ) { <S2SV_EndBug> <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
89,"<S2SV_StartBug> run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
90,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> snd_usb_mixer_disconnect ( mixer ) ; 
91,"<S2SV_StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! po -> running ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> return - EALREADY ; <S2SV_EndBug> <S2SV_StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! po -> rollover ) <S2SV_EndBug> <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & fanout_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> if ( err ) { <S2SV_EndBug> ",<S2SV_ModStart> packet_rollover * rollover = NULL ; struct <S2SV_ModStart> mutex_lock ( & fanout_mutex ) ; err = - EINVAL ; <S2SV_ModStart> goto out ; err = - EALREADY <S2SV_ModEnd> <S2SV_ModStart> goto out <S2SV_ModEnd> <S2SV_ModStart> err = - ENOMEM ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rollover ) goto out <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> po -> rollover = rollover ; } <S2SV_ModEnd> <S2SV_ModStart> if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } <S2SV_ModStart>  <S2SV_ModEnd> 
92,"<S2SV_StartBug> memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL 
93,<S2SV_StartBug> return NULL ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( table ) ; 
94,"<S2SV_StartBug> void show_progress ( int frame_in , int frame_out , uint64_t dx_time ) { <S2SV_EndBug> ",<S2SV_ModStart> static 
95,<S2SV_StartBug> buffer -> buffer = ( char * ) fbh -> data ; <S2SV_EndBug> ,<S2SV_ModStart> buffer = ( char * ) fbh -> data ; imp_sth -> stmt -> bind [ i ] . buffer_length = fbh -> length ; imp_sth -> stmt -> bind [ i ] . 
96,"<S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_TXIF | EIR_TXERIF ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXSTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDL , LSB ( ENC28J60_TX_BUFFER_START + length ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDH , MSB ( ENC28J60_TX_BUFFER_START + length ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRTS ) ; <S2SV_EndBug> ","<S2SV_ModStart> ENC28J60_ECON1 , ENC28J60_ECON1_TXRST <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ECON1 , ENC28J60_ECON1_TXRST <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIR , ENC28J60_EIR_TXIF | ENC28J60_EIR_TXERIF ) ; enc28j60WriteReg ( interface , ENC28J60_ETXSTL <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ETXSTH <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EWRPTL <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EWRPTH <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ETXNDL <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ETXNDH <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ECON1 , ENC28J60_ECON1_TXRTS <S2SV_ModEnd> "
97,<S2SV_StartBug> value = ast2obj_int ( o -> lineno ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ast2obj_string ( o -> type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = "
98,"<S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> <S2SV_StartBug> file_write ( page , wikitext ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> if ( page && ( unlink ( page ) > 0 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> ",<S2SV_ModStart> page_name_is_good ( page ) && <S2SV_ModStart> if ( page_name_is_good ( page ) ) { <S2SV_ModStart> } <S2SV_ModStart> page_name_is_good ( page ) && <S2SV_ModStart> && page_name_is_good ( page ) 
99,"<S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_PRE_IO ) { <S2SV_EndBug> <S2SV_StartBug> ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; <S2SV_EndBug> <S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_CONVERT ) { <S2SV_EndBug> ",<S2SV_ModStart> ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result <S2SV_ModStart> ( flags & EXT4_GET_BLOCKS_CONVERT ) <S2SV_ModEnd> 
100,"<S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 
101,"<S2SV_StartBug> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { <S2SV_EndBug> ","<S2SV_ModStart> caller_may_see_dir ( fc -> pid , controller , cgroup ) ) { ret = - ENOENT ; goto out ; } if ( ! "
102,"<S2SV_StartBug> int flag ) <S2SV_EndBug> <S2SV_StartBug> int mb_rows = source -> y_width >> 4 ; <S2SV_EndBug> <S2SV_StartBug> int mb_cols = source -> y_height >> 4 ; <S2SV_EndBug> <S2SV_StartBug> int mbr , mbc ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( limits , ( unsigned char ) ppl , 16 * mb_cols ) ; <S2SV_EndBug> <S2SV_StartBug> vp8_post_proc_down_and_across_mb_row ( <S2SV_EndBug> <S2SV_StartBug> source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int uvfilter ) { int mbr ; <S2SV_ModEnd> <S2SV_ModStart> cm -> mb_rows <S2SV_ModEnd> <S2SV_ModStart> cm -> mb_cols <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> if ( uvfilter == 1 ) { <S2SV_ModStart> 8 ) ; } <S2SV_ModEnd> "
103,"<S2SV_StartBug> ret = copy_to_user ( param , ptr , sizeof ( * ptr ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct floppy_raw_cmd cmd = * ptr ; cmd . next = NULL ; cmd . kernel_data = NULL ; <S2SV_ModStart> & cmd <S2SV_ModEnd> <S2SV_ModStart> cmd <S2SV_ModEnd> 
104,<S2SV_StartBug> if ( ( new -> euid != old -> uid || <S2SV_EndBug> ,"<S2SV_ModStart> ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) bprm -> per_clear |= PER_CLEAR_ON_SETID ; if ( "
105,"<S2SV_StartBug> ext4_xattr_cache_insert ( struct mb_cache * ext4_mb_cache , struct buffer_head * bh ) <S2SV_EndBug> <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ; <S2SV_EndBug> <S2SV_StartBug> error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_free ( ce ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error == - EBUSY ) { <S2SV_EndBug> <S2SV_StartBug> error = 0 ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> ","<S2SV_ModStart> mb2_cache <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> error = mb2_cache_entry_create <S2SV_ModEnd> <S2SV_ModStart> , hash , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
106,"<S2SV_StartBug> return r_socket_http_answer ( s , code , rlen ) ; <S2SV_EndBug> ","<S2SV_ModStart> socket_http_answer <S2SV_ModEnd> <S2SV_ModStart> , 0 "
107,"<S2SV_StartBug> tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p -> z , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
108,<S2SV_StartBug> int err ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL 
109,"<S2SV_StartBug> int ip_options_get_from_user ( struct net * net , struct ip_options * * optp , <S2SV_EndBug> <S2SV_StartBug> struct ip_options * opt = ip_options_get_alloc ( optlen ) ; <S2SV_EndBug> <S2SV_StartBug> if ( optlen && copy_from_user ( opt -> __data , data , optlen ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> opt . 
110,"<S2SV_StartBug> dl = kmalloc ( size , GFP_KERNEL ) ; <S2SV_EndBug> ",<S2SV_ModStart> kzalloc <S2SV_ModEnd> 
111,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , rpl_tstr <S2SV_ModEnd> "
112,"<S2SV_StartBug> static int <S2SV_EndBug> <S2SV_StartBug> rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , u_int indent ) <S2SV_EndBug> <S2SV_StartBug> pdu_header = ( const rpki_rtr_pdu * ) tptr ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_EndBug> <S2SV_StartBug> pdu_type , pdu_len ) ) ; <S2SV_EndBug> <S2SV_StartBug> case RPKI_RTR_END_OF_DATA_PDU : <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case RPKI_RTR_CACHE_RESPONSE_PDU : <S2SV_EndBug> <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_ipv4_prefix * ) tptr ; <S2SV_EndBug> <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_ipv6_prefix * ) tptr ; <S2SV_EndBug> <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_error_report * ) tptr ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , encapsulated_pdu_length ) ; <S2SV_EndBug> <S2SV_StartBug> tptr += sizeof ( * pdu ) ; <S2SV_EndBug> <S2SV_StartBug> if ( encapsulated_pdu_length && <S2SV_EndBug> <S2SV_StartBug> if ( rpki_rtr_pdu_print ( ndo , tptr , indent + 2 ) ) <S2SV_EndBug> <S2SV_StartBug> tlen -= encapsulated_pdu_length ; <S2SV_EndBug> <S2SV_StartBug> text_length = 0 ; <S2SV_EndBug> <S2SV_StartBug> text_length = EXTRACT_32BITS ( tptr ) ; <S2SV_EndBug> <S2SV_StartBug> tlen -= 4 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , text_length ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ","<S2SV_ModStart> u_int <S2SV_ModEnd> <S2SV_ModStart> const u_int len , const u_char recurse , const <S2SV_ModStart> ND_TCHECK_8BITS ( tptr ) ; if ( * tptr != 0 ) { ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u<S2SV_blank>(unknown)"" , indent_string ( 8 ) , * tptr ) ) ; return len ; } if ( len < sizeof ( rpki_rtr_pdu ) ) { ND_PRINT ( ( ndo , ""(%u<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>few<S2SV_blank>to<S2SV_blank>decode)"" , len ) ) ; goto invalid ; } ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( pdu_len < sizeof ( rpki_rtr_pdu ) || pdu_len > len ) goto invalid <S2SV_ModStart> if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModStart> if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModStart> if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 12 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 24 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> tlen = sizeof ( rpki_rtr_pdu ) ; if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) ; <S2SV_ModStart> tlen += 4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) { if ( pdu_len < tlen + encapsulated_pdu_length ) goto invalid ; if ( ! recurse ) { ND_TCHECK2 ( * tptr , tlen + encapsulated_pdu_length ) ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> + tlen , encapsulated_pdu_length , 0 <S2SV_ModStart> ; } tlen <S2SV_ModEnd> <S2SV_ModStart> } if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> + tlen ) ; tlen <S2SV_ModEnd> <S2SV_ModStart> if ( text_length ) { if ( pdu_len < tlen + text_length ) goto invalid ; ND_PRINT ( ( ndo , ""%sError<S2SV_blank>text:<S2SV_blank>"" , indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo , tptr + tlen , text_length , ndo -> ndo_snapend ) ) goto trunc ; } } break ; default : <S2SV_ModEnd> <S2SV_ModStart> pdu_len ) ; <S2SV_ModEnd> <S2SV_ModStart> pdu_len ; invalid : ND_PRINT ( ( ndo , ""%s"" , istr ) ) ; ND_TCHECK2 ( * tptr , len ) ; return len <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""\\n\\t%s"" , tstr ) ) ; return len <S2SV_ModEnd> "
113,"<S2SV_StartBug> int n , len ; <S2SV_EndBug> <S2SV_StartBug> memset ( & facilities , 0x00 , sizeof ( struct rose_facilities_struct ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! rose_parse_facilities ( skb -> data + len + 4 , & facilities ) ) { <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ROSE_CALL_REQ_FACILITIES_OFF , skb -> len - ROSE_CALL_REQ_FACILITIES_OFF , <S2SV_ModEnd> "
114,<S2SV_StartBug> addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> ,<S2SV_ModStart> INADDR_LOOPBACK <S2SV_ModEnd> 
115,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( ! gui_mch_set_rendering_options ( p_rop ) ) <S2SV_EndBug> ,<S2SV_ModStart> if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ; else <S2SV_ModStart> ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_AUTOCMD else if ( gvarp == & p_ft ) { if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_SYN_HL else if ( gvarp == & p_syn ) { if ( ! valid_filetype ( * varp 
116,"<S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & new_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode , & new_mode , & acl ) ; if ( ret ) goto out <S2SV_ModEnd> "
117,<S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> <S2SV_StartBug> ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ret ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> o2nm_unlock_subsystem ( ) ; 
118,"<S2SV_StartBug> isoclns_print ( ndo , p , length , caplen ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
119,<S2SV_StartBug> separator = * src ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>is<S2SV_blank>absolute"" ) ; return ( ARCHIVE_FAILED ) ; } separator = * src ++ ; } <S2SV_ModEnd> "
120,"<S2SV_StartBug> TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , <S2SV_EndBug> <S2SV_StartBug> TPM2B_DIGEST tmpResult ; <S2SV_EndBug> <S2SV_StartBug> TPM_RC rval ; <S2SV_EndBug> <S2SV_StartBug> while ( resultKey -> t . size < bytes ) <S2SV_EndBug> <S2SV_StartBug> i_Swizzled = string_bytes_endian_convert_32 ( i ) ; <S2SV_EndBug> <S2SV_StartBug> bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; <S2SV_EndBug> <S2SV_StartBug> rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rval != TPM_RC_SUCCESS ) <S2SV_EndBug> <S2SV_StartBug> return TSS2_SYS_RC_BAD_VALUE ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = TPM_RC_SUCCESS <S2SV_ModStart> const EVP_MD * md = tpm_algorithm_to_openssl_digest ( hashAlg ) ; if ( ! md ) { LOG_ERR ( ""Algorithm<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>hmac:<S2SV_blank>%x"" , hashAlg ) ; return TPM_RC_HASH ; } HMAC_CTX ctx ; HMAC_CTX_init ( & ctx ) ; int rc = HMAC_Init_ex ( & ctx , key -> buffer , key -> size , md , NULL ) ; if ( ! rc ) { LOG_ERR ( ""HMAC<S2SV_blank>Init<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ; return TPM_RC_MEMORY ; } <S2SV_ModStart> TPM2B_DIGEST tmpResult ; <S2SV_ModStart> ] = ( TPM2B_DIGEST * ) 0 ; int c ; for ( c = 0 ; c < j ; c ++ ) { TPM2B_DIGEST * digest = bufferList [ c ] ; int rc = HMAC_Update ( & ctx , digest -> b . buffer , digest -> b . size ) ; if ( ! rc ) { LOG_ERR ( ""HMAC<S2SV_blank>Update<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) <S2SV_ModEnd> <S2SV_ModStart> TPM_RC_MEMORY ; goto err ; } } unsigned size = sizeof ( tmpResult . t . buffer ) ; int rc = HMAC_Final ( & ctx , tmpResult . t . buffer , & size <S2SV_ModEnd> <S2SV_ModStart> ! rc ) { LOG_ERR ( ""HMAC<S2SV_blank>Final<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ; rval = TPM_RC_MEMORY ; goto err ; } tmpResult . t . size = size ; <S2SV_ModEnd> <S2SV_ModStart> rval = TSS2_SYS_RC_BAD_VALUE ; goto err ; } } resultKey -> t . size = bytes ; err : HMAC_CTX_cleanup ( & ctx ) ; return rval <S2SV_ModEnd> "
121,"<S2SV_StartBug> cmpt = 0 ; <S2SV_EndBug> <S2SV_StartBug> ! jas_safe_intfast32_add ( tly , height , 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! jas_safe_size_mul ( cmpt -> width_ , cmpt -> height_ , & size ) || <S2SV_EndBug> ","<S2SV_ModStart> JAS_DBGLOG ( 100 , ( ""jas_image_cmpt_create(%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%d,<S2SV_blank>%d,<S2SV_blank>%d)\\n"" , JAS_CAST ( long , tlx ) , JAS_CAST ( long , tly ) , JAS_CAST ( long , hstep ) , JAS_CAST ( long , vstep ) , JAS_CAST ( long , width ) , JAS_CAST ( long , height ) , JAS_CAST ( int , depth ) , sgnd , inmem ) ) ; <S2SV_ModStart> , 0 ) ) { goto error ; } if ( ! jas_safe_intfast32_mul3 ( width , height , depth <S2SV_ModStart> jas_safe_size_mul3 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
122,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( s == 0 ) return ( ( void * ) NULL ) ; 
123,<S2SV_StartBug> if ( count < sizeof ( cmd . type ) ) { <S2SV_EndBug> ,<S2SV_ModStart> WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if ( 
124,<S2SV_StartBug> MinVal = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; "
125,<S2SV_StartBug> get_net ( peer ) ; <S2SV_EndBug> ,<S2SV_ModStart> peer = maybe_get_net <S2SV_ModEnd> 
126,<S2SV_StartBug> while ( header_buf [ i ] == '\\r' || header_buf [ i ] == '\\n' ) <S2SV_EndBug> ,<S2SV_ModStart> ( i < ( int ) header_buf_used ) && ( <S2SV_ModStart> ) 
127,<S2SV_StartBug> assert ( proto != LLDP_MGMT_ADDR_NONE ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( proto == LLDP_MGMT_ADDR_NONE ) continue <S2SV_ModEnd> 
128,<S2SV_StartBug> dp == datalen ) { <S2SV_EndBug> ,<S2SV_ModStart> ( op & ASN1_OP_MATCH__SKIP && <S2SV_ModStart> ) 
129,"<S2SV_StartBug> list_add_tail ( & sp -> auto_asconf_list , <S2SV_EndBug> <S2SV_StartBug> sp -> do_auto_asconf = 1 ; <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> sp -> do_auto_asconf = 0 ; <S2SV_EndBug> ",<S2SV_ModStart> spin_lock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; <S2SV_ModStart> ; spin_unlock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) <S2SV_ModStart> { <S2SV_ModStart> } 
130,"<S2SV_StartBug> static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb ) <S2SV_EndBug> <S2SV_StartBug> s -> avctx -> level = get_bits ( gb , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( s -> avctx -> profile == 0 && s -> avctx -> level == 8 ) { <S2SV_EndBug> <S2SV_StartBug> s -> avctx -> level = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> , int * profile , int * level ) { * <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModEnd> "
131,"<S2SV_StartBug> spin_lock_irqsave ( & mpu -> input_lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> while ( readw ( mpu -> dev -> MIDQ + JQS_wTail ) != <S2SV_EndBug> <S2SV_StartBug> wTmp = readw ( mpu -> dev -> MIDQ + JQS_wHead ) + 1 ; <S2SV_EndBug> ","<S2SV_ModStart> u16 head , tail , size ; <S2SV_ModStart> head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ; tail = readw ( mpu -> dev -> MIDQ + JQS_wTail ) ; size = readw ( mpu -> dev -> MIDQ + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { unsigned char val = readw ( pwMIDQData + 2 * head ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , & val <S2SV_ModEnd> <S2SV_ModStart> if ( ++ head > size ) head = 0 ; writew ( head , <S2SV_ModEnd> <S2SV_ModStart> ; } out : <S2SV_ModEnd> "
132,<S2SV_StartBug> return result ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! entry -> lsm [ lsm_rule ] . rule ) return - EINVAL ; 
133,<S2SV_StartBug> file_sb_list_del ( file ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
134,<S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
135,"<S2SV_StartBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%s);\\n"" <S2SV_EndBug> <S2SV_StartBug> if ( s_poll_interval == NULL ) <S2SV_EndBug> <S2SV_StartBug> session_state , op_iframe_id , s_poll_interval , redirect_uri , <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%d);\\n"" <S2SV_ModEnd> <S2SV_ModStart> int poll_interval = s_poll_interval ? strtol ( s_poll_interval , NULL , 10 ) : 0 ; if ( ( poll_interval <= 0 ) || ( poll_interval > 3600 * 24 ) ) poll_interval = 3000 <S2SV_ModEnd> <S2SV_ModStart> poll_interval <S2SV_ModEnd> "
136,"<S2SV_StartBug> size_t * acl_len ) <S2SV_EndBug> <S2SV_StartBug> __be32 * savep ; <S2SV_EndBug> <S2SV_StartBug> * acl_len = 0 ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ; <S2SV_EndBug> <S2SV_StartBug> dprintk ( ""NFS:<S2SV_blank>server<S2SV_blank>cheating<S2SV_blank>in<S2SV_blank>getattr"" <S2SV_EndBug> <S2SV_StartBug> * acl_len = attrlen ; <S2SV_EndBug> ","<S2SV_ModStart> struct nfs_getaclres * res <S2SV_ModEnd> <S2SV_ModStart> , * bm_p <S2SV_ModStart> res -> <S2SV_ModEnd> <S2SV_ModStart> ; bm_p = xdr -> p <S2SV_ModStart> xdr -> p = bm_p ; res -> acl_data_offset = be32_to_cpup ( bm_p ) + 2 ; res -> acl_data_offset <<= 2 ; <S2SV_ModStart> ; attrlen += res -> acl_data_offset <S2SV_ModStart> if ( res -> acl_flags & NFS4_ACL_LEN_REQUEST ) { res -> acl_len = attrlen ; goto out ; } dprintk ( ""NFS:<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\n"" <S2SV_ModEnd> <S2SV_ModStart> res -> <S2SV_ModEnd> "
137,<S2SV_StartBug> nexthdr = * prevhdr ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ; 
138,<S2SV_StartBug> while ( ( tmpName [ i ] != 0 ) && ( i < to_read ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( i < to_read ) && <S2SV_ModStart>  <S2SV_ModEnd> 
139,"<S2SV_StartBug> long rem ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> ",<S2SV_ModStart> u32 <S2SV_ModEnd> <S2SV_ModStart> div_u64_rem <S2SV_ModEnd> 
140,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && in -> linesize [ plane ] 
141,"<S2SV_StartBug> strncpy ( szFileName , sizeof ( szFileName ) - 5 , pszFileName ) ; <S2SV_EndBug> ","<S2SV_ModStart> pszFileName , <S2SV_ModStart>  <S2SV_ModEnd> "
142,"<S2SV_StartBug> owner = stok ( auth , "":"" , & tok ) ; <S2SV_EndBug> <S2SV_StartBug> group = stok ( tok , "":"" , & perms ) ; <S2SV_EndBug> ",<S2SV_ModStart> ssplit <S2SV_ModEnd> <S2SV_ModStart> ssplit <S2SV_ModEnd> 
143,"<S2SV_StartBug> q = ( const uint8_t * ) ( const void * ) <S2SV_EndBug> <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ; <S2SV_EndBug> <S2SV_StartBug> DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , <S2SV_EndBug> <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <S2SV_ModStart> ofs <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> i , <S2SV_ModEnd> <S2SV_ModStart> offs <S2SV_ModEnd> "
144,<S2SV_StartBug> if ( inet -> opt && inet -> opt -> srr ) <S2SV_EndBug> ,"<S2SV_ModStart> struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . <S2SV_ModEnd> "
145,"<S2SV_StartBug> pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" <S2SV_EndBug> ",<S2SV_ModStart> pr_debug <S2SV_ModEnd> 
146,"<S2SV_StartBug> tlen = len - sizeof ( struct eigrp_common_header ) ; <S2SV_EndBug> <S2SV_StartBug> tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>holdtime:<S2SV_blank>%us,<S2SV_blank>k1<S2SV_blank>%u,<S2SV_blank>k2<S2SV_blank>%u,<S2SV_blank>k3<S2SV_blank>%u,<S2SV_blank>k4<S2SV_blank>%u,<S2SV_blank>k5<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IOS<S2SV_blank>version:<S2SV_blank>%u.%u,<S2SV_blank>EIGRP<S2SV_blank>version<S2SV_blank>%u.%u"" , <S2SV_EndBug> <S2SV_StartBug> bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ; <S2SV_EndBug> <S2SV_StartBug> bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-range:<S2SV_blank>%u-%u,<S2SV_blank>Router-ID<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" , <S2SV_EndBug> ","<S2SV_ModStart> if ( len < sizeof ( struct eigrp_common_header ) ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , tok2str ( eigrp_opcode_values , ""unknown<S2SV_blank>(%u)"" , eigrp_com_header -> opcode ) , len , ( u_int ) sizeof ( struct eigrp_common_header ) ) ) ; return ; } <S2SV_ModStart> if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) sizeof ( struct eigrp_tlv_header ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) ) ) ; break ; } "
147,<S2SV_StartBug> # if CONFIG_MEM_MANAGER <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart> addr = malloc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
148,"<S2SV_StartBug> int indexes = SQUASHFS_LOOKUP_BLOCKS ( sBlk . s . inodes ) ; <S2SV_EndBug> <S2SV_StartBug> long long export_index_table [ indexes ] ; <S2SV_EndBug> <S2SV_StartBug> res = read_fs_bytes ( fd , sBlk . s . lookup_table_start , <S2SV_EndBug> ","<S2SV_ModStart> ( long long ) sBlk . s . inodes ) ; int length = SQUASHFS_LOOKUP_BLOCK_BYTES ( ( long long ) <S2SV_ModStart> * export_index_table ; if ( length != ( * table_start - sBlk . s . lookup_table_start ) ) { ERROR ( ""parse_exports_table:<S2SV_blank>Bad<S2SV_blank>inode<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; return FALSE ; } export_index_table = alloc_index_table ( indexes ) <S2SV_ModEnd> <S2SV_ModStart> length , <S2SV_ModEnd> "
149,"<S2SV_StartBug> ptr = strchr ( ptr + 1 , '/' ) + 1 ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( ptr == NULL ) return ( ENOENT ) ; ptr ++ <S2SV_ModEnd> 
150,<S2SV_StartBug> flags |= EXT4_GET_BLOCKS_PRE_IO ; <S2SV_EndBug> ,<S2SV_ModStart> if ( flags & EXT4_GET_BLOCKS_CONVERT ) split_flag |= EXT4_EXT_DATA_VALID2 ; 
151,"<S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & new_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode , & new_mode , & acl ) ; if ( ret ) goto out <S2SV_ModEnd> "
152,"<S2SV_StartBug> else return apr_psprintf ( cmd -> pool , ""ModSecurity:<S2SV_blank>Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>SecRuleEngine:<S2SV_blank>%s"" , p1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""ModSecurity:<S2SV_blank>Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>SexHashEngine:<S2SV_blank>%s"" <S2SV_ModEnd> "
153,"<S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> ","<S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) , & final ) ; rcu_read_unlock ( <S2SV_ModEnd> "
154,"<S2SV_StartBug> uint16 nstrips = 0 , ntiles = 0 , planar = 0 ; <S2SV_EndBug> <S2SV_StartBug> read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ","<S2SV_ModStart> uint32 nstrips = 0 , ntiles = 0 ; uint16 <S2SV_ModEnd> <S2SV_ModStart> { if ( buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } <S2SV_ModStart> } <S2SV_ModStart> if ( buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } "
155,"<S2SV_StartBug> if ( 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( 0 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( arg_match ( & arg , & stereo_mode , argi ) ) { <S2SV_EndBug> <S2SV_StartBug> config -> stereo_fmt = arg_parse_enum_or_int ( & arg ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( arg_match ( & arg , & resize_up_thresh , argi ) ) { <S2SV_EndBug> <S2SV_StartBug> config -> cfg . kf_mode = VPX_KF_DISABLED ; <S2SV_EndBug> <S2SV_StartBug> if ( config -> arg_ctrls [ j ] [ 0 ] == ctrl_args_map [ i ] ) <S2SV_EndBug> <S2SV_StartBug> assert ( j < ARG_CTRL_CNT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> if ( j < ARG_CTRL_CNT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> return eos_mark_found ; <S2SV_EndBug> ","<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH int test_16bit_internal = 0 ; # endif <S2SV_ModStart> # if CONFIG_VP10_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp10"" ) == 0 ) { ctrl_args = vp10_args ; ctrl_args_map = vp10_arg_ctrl_map ; # endif <S2SV_ModStart> arg_match ( & arg , & outputfile , argi ) ) { config -> out_fn = arg . val ; } else if ( arg_match ( & arg , & fpf_name , argi ) ) { config -> stats_fn = arg . val ; # if CONFIG_FP_MB_STATS } else if ( arg_match ( & arg , & fpmbf_name , argi ) ) { config -> fpmb_stats_fn = arg . val ; # endif } else if ( arg_match ( & arg , & use_webm , argi ) ) { # if CONFIG_WEBM_IO config -> write_webm = 1 ; # else die ( ""Error:<S2SV_blank>--webm<S2SV_blank>specified<S2SV_blank>but<S2SV_blank>webm<S2SV_blank>is<S2SV_blank>disabled."" ) ; # endif } else if ( arg_match ( & arg , & use_ivf , argi ) ) { config -> write_webm = 0 <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH } else if ( arg_match ( & arg , & bitdeptharg , argi ) ) { config -> cfg . g_bit_depth = arg_parse_enum_or_int ( & arg ) ; } else if ( arg_match ( & arg , & inbitdeptharg , argi ) ) { config -> cfg . g_input_bit_depth = arg_parse_uint ( & arg ) ; # endif # if CONFIG_WEBM_IO <S2SV_ModStart> # endif <S2SV_ModStart> resize_width , argi ) ) { config -> cfg . rc_scaled_width = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & resize_height , argi ) ) { config -> cfg . rc_scaled_height = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH } else if ( arg_match ( & arg , & test16bitinternalarg , argi ) ) { if ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 || strcmp ( global -> codec -> name , ""vp10"" ) == 0 ) { test_16bit_internal = 1 ; } # endif <S2SV_ModStart> ctrl_args_map != NULL && <S2SV_ModStart> ( int ) <S2SV_ModStart> ctrl_args_map != NULL && j < ( int ) <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 || strcmp ( global -> codec -> name , ""vp10"" ) == 0 ) { config -> use_16bit_internal = test_16bit_internal | ( config -> cfg . g_profile > 1 ) ; } # endif "
156,<S2SV_StartBug> || no_port_forwarding_flag || options . disable_forwarding ) { <S2SV_EndBug> ,<S2SV_ModStart> || ! use_privsep 
157,<S2SV_StartBug> dev -> netdev_ops = & l2tp_eth_netdev_ops ; <S2SV_EndBug> ,<S2SV_ModStart> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> 
158,<S2SV_StartBug> for ( ; offset < ( MagickOffsetType ) cin . file . image_offset ; offset ++ ) <S2SV_EndBug> ,"<S2SV_ModStart> if ( ( ( MagickSizeType ) image -> columns * image -> rows ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; "
159,"<S2SV_StartBug> if ( ( gr -> gr_ctx . value = mem_alloc ( sizeof ( gss_union_ctx_id_desc ) ) ) == NULL ) { <S2SV_EndBug> <S2SV_StartBug> memcpy ( gr -> gr_ctx . value , gd -> ctx , sizeof ( gss_union_ctx_id_desc ) ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""xxxx"" ; <S2SV_ModEnd> <S2SV_ModStart> length = 4 <S2SV_ModEnd> "
160,"<S2SV_StartBug> if ( ext_depth ( inode ) ) <S2SV_EndBug> <S2SV_StartBug> memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data , <S2SV_EndBug> <S2SV_StartBug> sizeof ( EXT4_I ( inode ) -> i_data ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t ext_size = 0 ; <S2SV_ModStart> ext_size = sizeof ( EXT4_I ( inode ) -> i_data ) ; <S2SV_ModStart> ext_size ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size <S2SV_ModEnd> "
161,"<S2SV_StartBug> if ( verify_checks ( c , preverify_ok , callback_ctx ) ) { <S2SV_EndBug> <S2SV_StartBug> ( void * ) ( - 1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( c -> opt -> option . client || c -> opt -> protocol ) <S2SV_EndBug> <S2SV_StartBug> if ( c -> opt -> redirect_addr . names ) <S2SV_EndBug> ",<S2SV_ModStart> return 1 ; if ( c -> opt -> option . client || c -> opt -> protocol ) return 0 ; if ( c -> opt -> redirect_addr . names ) <S2SV_ModStart> NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
162,<S2SV_StartBug> int ret ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( current_chrooted ( ) ) return - EPERM 
163,"<S2SV_StartBug> if ( memcmp ( cmac , computed_cmac , AT91_AES_BLOCK_SIZE_BYTE ) ) <S2SV_EndBug> ",<S2SV_ModStart> ! consttime_memequal <S2SV_ModEnd> 
164,<S2SV_StartBug> if ( c -> nreslevels < s -> reduction_factor ) <S2SV_EndBug> <S2SV_StartBug> c -> nreslevels2decode = 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> <= <S2SV_ModEnd> <S2SV_ModStart> { av_log ( s -> avctx , AV_LOG_ERROR , ""reduction_factor<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>this<S2SV_blank>bitstream,<S2SV_blank>max<S2SV_blank>is<S2SV_blank>%d\\n"" , c -> nreslevels - 1 ) ; s -> reduction_factor = c -> nreslevels - 1 ; return AVERROR ( EINVAL ) ; } <S2SV_ModEnd> "
165,"<S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> ","<S2SV_ModStart> | CVAR_PROTECTED <S2SV_ModStart> if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; } "
166,<S2SV_StartBug> bool is_drop_n_account = false ; <S2SV_EndBug> <S2SV_StartBug> if ( po -> has_vnet_hdr ) <S2SV_EndBug> <S2SV_StartBug> macoff = netoff - maclen ; <S2SV_EndBug> <S2SV_StartBug> if ( ( int ) snaplen < 0 ) <S2SV_EndBug> <S2SV_StartBug> snaplen = 0 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( po -> has_vnet_hdr ) { <S2SV_EndBug> ,<S2SV_ModStart> = false ; bool do_vnet <S2SV_ModStart> { <S2SV_ModStart> do_vnet = true ; } <S2SV_ModStart> { <S2SV_ModStart> do_vnet = false ; } <S2SV_ModStart> do_vnet = false ; <S2SV_ModStart> do_vnet <S2SV_ModEnd> 
167,<S2SV_StartBug> sctp_auth_key_put ( asoc -> asoc_shared_key ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
168,<S2SV_StartBug> return true ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ndp_msg_type_info ( msg_type ) -> addrto_validate ) return ndp_msg_type_info ( msg_type ) -> addrto_validate ( & msg -> addrto ) ; else 
169,"<S2SV_StartBug> int lsm_set_label_at ( int procfd , int on_exec , char * lsm_label ) { <S2SV_EndBug> <S2SV_StartBug> int labelfd = - 1 ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> if ( on_exec ) { <S2SV_EndBug> <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( write ( labelfd , command , size + 1 ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label"" ) ; <S2SV_EndBug> <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( labelfd != - 1 ) <S2SV_EndBug> <S2SV_StartBug> close ( labelfd ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> static <S2SV_ModStart> lsm_labelfd <S2SV_ModEnd> <S2SV_ModStart> { int fret <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return 0 <S2SV_ModEnd> <S2SV_ModStart> return 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lsm_labelfd <S2SV_ModEnd> <S2SV_ModStart> ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label:<S2SV_blank>%s."" , command ) ; goto out ; } INFO ( ""Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s."" , command ) ; } else if ( strcmp ( name , ""SELinux"" ) == 0 ) { if ( write ( lsm_labelfd , lsm_label , strlen ( lsm_label ) + 1 ) < 0 ) { SYSERROR ( <S2SV_ModStart> goto out ; } INFO ( ""Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s."" , lsm_label ) ; } else <S2SV_ModEnd> <S2SV_ModStart> goto out ; } fret = 0 ; <S2SV_ModEnd> <S2SV_ModStart> lsm_labelfd <S2SV_ModEnd> <S2SV_ModStart> lsm_labelfd <S2SV_ModEnd> <S2SV_ModStart> fret <S2SV_ModEnd> "
170,<S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ,<S2SV_ModStart> rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if ( 
171,"<S2SV_StartBug> struct pt_regs * regs , int nmi ) <S2SV_EndBug> <S2SV_StartBug> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
172,"<S2SV_StartBug> # ifdef DISABLE_RC_LONG_TERM_MEM <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> common . frame_type == KEY_FRAME ) { <S2SV_EndBug> <S2SV_StartBug> cpi -> twopass . gf_group_bits -= bits_used ; <S2SV_EndBug> <S2SV_StartBug> cpi -> twopass . gf_group_bits = MAX ( cpi -> twopass . gf_group_bits , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> TWO_PASS * const twopass = & cpi -> twopass ; RATE_CONTROL * const rc = & cpi -> rc ; const int bits_used = rc -> base_frame_target ; rc -> vbr_bits_off_target += rc -> base_frame_target - rc -> projected_frame_size ; twopass -> bits_left = MAX ( twopass -> bits_left - bits_used , 0 ) ; if ( rc -> total_actual_bits ) { rc -> rate_error_estimate = ( int ) ( ( rc -> vbr_bits_off_target * 100 ) / rc -> total_actual_bits ) ; rc -> rate_error_estimate = clamp ( rc -> rate_error_estimate , - 100 , 100 ) ; } else { rc -> rate_error_estimate = 0 ; } <S2SV_ModEnd> <S2SV_ModStart> != KEY_FRAME && ! vp9_is_upper_layer_key_frame ( cpi ) ) { twopass -> <S2SV_ModEnd> <S2SV_ModStart> twopass -> last_kfgroup_zeromotion_pct = twopass -> kf_zeromotion_pct ; } twopass -> kf_group_bits <S2SV_ModEnd> <S2SV_ModStart> twopass -> kf_group_bits <S2SV_ModEnd> <S2SV_ModStart> ++ twopass -> gf_group . index ; if ( ( cpi -> oxcf . rc_mode != VPX_Q ) && ( cpi -> twopass . gf_zeromotion_pct < VLOW_MOTION_THRESHOLD ) && ! cpi -> rc . is_src_frame_alt_ref ) { const int maxq_adj_limit = rc -> worst_quality - twopass -> active_worst_quality ; const int minq_adj_limit = ( cpi -> oxcf . rc_mode == VPX_CQ ? MINQ_ADJ_LIMIT_CQ : MINQ_ADJ_LIMIT ) ; if ( rc -> rate_error_estimate > cpi -> oxcf . under_shoot_pct ) { -- twopass -> extend_maxq ; if ( rc -> rolling_target_bits >= rc -> rolling_actual_bits ) ++ twopass -> extend_minq ; } else if ( rc -> rate_error_estimate < - cpi -> oxcf . over_shoot_pct ) { -- twopass -> extend_minq ; if ( rc -> rolling_target_bits < rc -> rolling_actual_bits ) ++ twopass -> extend_maxq ; } else { if ( rc -> projected_frame_size > ( 2 * rc -> base_frame_target ) && rc -> projected_frame_size > ( 2 * rc -> avg_frame_bandwidth ) ) ++ twopass -> extend_maxq ; if ( rc -> rolling_target_bits < rc -> rolling_actual_bits ) -- twopass -> extend_minq ; else if ( rc -> rolling_target_bits > rc -> rolling_actual_bits ) -- twopass -> extend_maxq ; } twopass -> extend_minq = clamp ( twopass -> extend_minq , 0 , minq_adj_limit ) ; twopass -> extend_maxq = clamp ( twopass -> extend_maxq , 0 , maxq_adj_limit ) ; if ( ! frame_is_kf_gf_arf ( cpi ) && ! cpi -> rc . is_src_frame_alt_ref ) { int fast_extra_thresh = rc -> base_frame_target / HIGH_UNDERSHOOT_RATIO ; if ( rc -> projected_frame_size < fast_extra_thresh ) { rc -> vbr_bits_off_target_fast += fast_extra_thresh - rc -> projected_frame_size ; rc -> vbr_bits_off_target_fast = MIN ( rc -> vbr_bits_off_target_fast , ( 4 * rc -> avg_frame_bandwidth ) ) ; if ( rc -> avg_frame_bandwidth ) { twopass -> extend_minq_fast = ( int ) ( rc -> vbr_bits_off_target_fast * 8 / rc -> avg_frame_bandwidth ) ; } twopass -> extend_minq_fast = MIN ( twopass -> extend_minq_fast , minq_adj_limit - twopass -> extend_minq ) ; } else if ( rc -> vbr_bits_off_target_fast ) { twopass -> extend_minq_fast = MIN ( twopass -> extend_minq_fast , minq_adj_limit - twopass -> extend_minq ) ; } else { twopass -> extend_minq_fast = 0 ; } } } <S2SV_ModEnd> "
173,<S2SV_StartBug> num ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( num > MaxAllocSize / ITEMSIZE ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , num , ( int ) ( MaxAllocSize / ITEMSIZE ) ) ) ) "
174,"<S2SV_StartBug> struct mb_cache_entry * * pce ) <S2SV_EndBug> <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> again : <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev , <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( ce ) ) { <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_find_next ( ce , inode -> i_sb -> s_bdev , hash ) ; <S2SV_EndBug> ","<S2SV_ModStart> mb2_cache_entry <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_entry * ce ; struct mb2_cache <S2SV_ModEnd> <S2SV_ModStart> ce = mb2_cache_entry_find_first <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_entry_find_next ( ext4_mb_cache , ce <S2SV_ModEnd> "
175,"<S2SV_StartBug> gint64 offset ; <S2SV_EndBug> <S2SV_StartBug> pkt_len = parse_cosine_rec_hdr ( & wth -> phdr , line , err , err_info ) ; <S2SV_EndBug> <S2SV_StartBug> return parse_cosine_hex_dump ( wth -> fh , & wth -> phdr , pkt_len , <S2SV_EndBug> <S2SV_StartBug> wth -> frame_buffer , err , err_info ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return parse_cosine_packet <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , line "
176,<S2SV_StartBug> if ( pkt == NULL ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
177,<S2SV_StartBug> if ( left > 0 && n > left ) <S2SV_EndBug> ,<S2SV_ModStart> == 0 && extend ) return 0 ; if ( left 
178,"<S2SV_StartBug> # ifndef _MSC_VER <S2SV_EndBug> <S2SV_StartBug> char buf [ EXT2_BLOCK_SIZE ( data ) ] ; <S2SV_EndBug> <S2SV_StartBug> grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> return fileblock + start ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! indir ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> if ( ! indir ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> ",<S2SV_ModStart> char * buf = grub_malloc ( <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( ! buf ) { return - 1 ; } <S2SV_ModEnd> <S2SV_ModStart> ) ; free ( buf <S2SV_ModStart> { free ( buf ) ; <S2SV_ModStart> } <S2SV_ModStart> free ( buf ) ; <S2SV_ModStart> free ( buf ) ; <S2SV_ModStart> free ( buf ) ; <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } 
179,"<S2SV_StartBug> UnpackRaster : <S2SV_EndBug> <S2SV_StartBug> image -> rows = Bitmap2Header1 . Height ; <S2SV_EndBug> <S2SV_StartBug> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; <S2SV_EndBug> ","<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; <S2SV_ModStart> ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break <S2SV_ModStart>  <S2SV_ModEnd> "
180,"<S2SV_StartBug> if ( copy_from_user ( buf , ( void * ) arg , hdr . size_in ) ) { <S2SV_EndBug> ","<S2SV_ModStart> * ( ( struct vbg_ioctl_hdr * ) buf ) = hdr ; <S2SV_ModStart> + sizeof ( hdr ) <S2SV_ModStart> + sizeof ( hdr ) , hdr . size_in - sizeof ( hdr ) <S2SV_ModEnd> "
181,"<S2SV_StartBug> int hstartcol ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> hstartcol = ( numrows + 1 - parity ) >> 1 ; <S2SV_EndBug> <S2SV_StartBug> m = numrows - hstartcol ; <S2SV_EndBug> <S2SV_StartBug> dstptr = & a [ hstartcol * stride ] ; <S2SV_EndBug> ","<S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> jas_alloc3 <S2SV_ModEnd> <S2SV_ModStart> JPC_QMFB_COLGRPSIZE , <S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> hstartrow <S2SV_ModEnd> "
182,"<S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> <S2SV_StartBug> height ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""ImproperImageHeader"" <S2SV_ModEnd> <S2SV_ModStart> ""ImproperImageHeader"" <S2SV_ModEnd> <S2SV_ModStart> ""ImproperImageHeader"" <S2SV_ModEnd> <S2SV_ModStart> else { if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; } "
183,"<S2SV_StartBug> char <S2SV_EndBug> <S2SV_StartBug> count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; <S2SV_EndBug> <S2SV_StartBug> image -> page . x = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> image -> page . y = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> one = 1 ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> <S2SV_StartBug> colormap = ( unsigned char * ) NULL ; <S2SV_EndBug> <S2SV_StartBug> colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , <S2SV_EndBug> <S2SV_StartBug> if ( colormap == ( unsigned char * ) NULL ) <S2SV_EndBug> <S2SV_StartBug> ReadBlobLSBShort ( image ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> <S2SV_StartBug> do <S2SV_EndBug> <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> plane = ( unsigned char ) operand ; <S2SV_EndBug> <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> <S2SV_StartBug> } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; <S2SV_EndBug> <S2SV_StartBug> ValidateColormapValue ( image , * p & mask , & index , exception ) ; <S2SV_EndBug> <S2SV_StartBug> ValidateColormapValue ( image , ( size_t ) ( x * map_length + <S2SV_EndBug> <S2SV_StartBug> SetPixelIndex ( image , * p ++ , q ) ; <S2SV_EndBug> ","<S2SV_ModStart> # define ThrowRLEException ( exception , message ) \\\n{ if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; \\\n} <S2SV_ModStart> colormap = ( unsigned char * ) NULL ; pixel_info = ( MemoryInfo * ) NULL ; <S2SV_ModStart> ( ssize_t ) <S2SV_ModStart> ( ssize_t ) <S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> ThrowRLEException ( <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( number_colormaps != 0 ) { <S2SV_ModEnd> <S2SV_ModStart> AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == <S2SV_ModEnd> <S2SV_ModStart> NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) { * p ++ = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> ThrowRLEException ( <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> { <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> { <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> { <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } offset = ( ssize_t ) ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> ( offset + <S2SV_ModEnd> <S2SV_ModStart> ( ssize_t ) <S2SV_ModStart> == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> { <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> ( ssize_t ) ( <S2SV_ModStart> ) <S2SV_ModStart> ( offset + <S2SV_ModEnd> <S2SV_ModStart> ( ssize_t ) <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> ( ssize_t ) ( <S2SV_ModStart> ) <S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ( Quantum ) "
184,<S2SV_StartBug> ext2_xattr_put_super ( sb ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sbi -> s_mb_cache ) { ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } <S2SV_ModEnd> 
185,<S2SV_StartBug> endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( usbinterface -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & usbinterface -> dev , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n"" ) ; error = - EINVAL ; goto err_free_urb ; } "
186,<S2SV_StartBug> if ( ! cfg . shell ) <S2SV_EndBug> <S2SV_StartBug> arg [ 0 ] = cfg . shell ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""/bin/sh"" <S2SV_ModEnd> "
187,<S2SV_StartBug> return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( node -> nd_item . ci_parent ) <S2SV_ModStart> else return NULL ; 
188,"<S2SV_StartBug> static void nfs_set_open_stateid ( struct nfs4_state * state , nfs4_stateid * stateid , int open_flags ) <S2SV_EndBug> <S2SV_StartBug> nfs_set_open_stateid_locked ( state , stateid , open_flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> 
189,<S2SV_StartBug> uint32_t vsize = avio_rb32 ( pb ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA 
190,<S2SV_StartBug> if ( q > e ) { <S2SV_EndBug> ,<S2SV_ModStart> < p || q 
191,<S2SV_StartBug> # ifdef AUTOKEY <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
192,"<S2SV_StartBug> char * dir = ""/etc"" ; <S2SV_EndBug> <S2SV_StartBug> if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) { <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""/etc"" , "".vipw"" <S2SV_ModEnd> "
193,"<S2SV_StartBug> attach_shadowed ( mnt , parent , shadows ) ; <S2SV_EndBug> ",<S2SV_ModStart> n -> mounts += n -> pending_mounts ; n -> pending_mounts = 0 ; 
194,"<S2SV_StartBug> savesegment ( es , prev -> es ) ; <S2SV_EndBug> <S2SV_StartBug> loadsegment ( ds , next -> ds ) ; <S2SV_EndBug> ","<S2SV_ModStart> fs , fsindex ) ; savesegment ( gs , gsindex ) ; load_TLS ( next , cpu ) ; arch_end_context_switch ( next_p ) ; savesegment ( <S2SV_ModStart>  <S2SV_ModEnd> "
195,<S2SV_StartBug> problem_data_reload_from_dump_dir ( ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
196,"<S2SV_StartBug> BITS_PARSE ( ""entropy_coding_sync_enabled_flag"" , value , ps_bitstrm , 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ( ps_pps -> i1_tiles_enabled_flag ) && ( ps_sps -> i1_log2_ctb_size == 4 ) && ( ( ps_sps -> i2_pic_width_in_luma_samples >= 4096 ) || ( ps_sps -> i2_pic_height_in_luma_samples >= 4096 ) ) ) { return IHEVCD_INVALID_HEADER ; } 
197,<S2SV_StartBug> ( 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) | ( 1u << AC_VECTOR 
198,"<S2SV_StartBug> static char temp [ NFSX_V3FHMAX + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( temp , sfsname , NFSX_V3FHMAX ) ; <S2SV_EndBug> <S2SV_StartBug> temp [ sizeof ( temp ) - 1 ] = '\\0' ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> u_int stringlen ; stringlen = len ; if ( stringlen > NFSX_V3FHMAX ) stringlen = NFSX_V3FHMAX ; <S2SV_ModStart> stringlen <S2SV_ModEnd> <S2SV_ModStart> stringlen <S2SV_ModEnd> 
199,"<S2SV_StartBug> int transhdrlen , int mtu , unsigned int flags ) <S2SV_EndBug> <S2SV_StartBug> ipv6_select_ident ( & fhdr ) ; <S2SV_EndBug> ","<S2SV_ModStart> , struct rt6_info * rt <S2SV_ModStart> , rt "
200,<S2SV_StartBug> return res ; <S2SV_EndBug> <S2SV_StartBug> return res ; <S2SV_EndBug> ,<S2SV_ModStart> goto err_add_port <S2SV_ModEnd> <S2SV_ModStart> err_add_port : hsr_del_node ( & hsr -> self_node_db ) ; 
201,<S2SV_StartBug> ( void ) tls_init_new_session ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> flush_cmd ( ) ; 
202,"<S2SV_StartBug> void vp9_setup_dst_planes ( MACROBLOCKD * xd , <S2SV_EndBug> <S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> <S2SV_StartBug> struct macroblockd_plane * const pd = & xd -> plane [ i ] ; <S2SV_EndBug> ",<S2SV_ModStart> struct macroblockd_plane planes [ MAX_MB_PLANE ] <S2SV_ModEnd> <S2SV_ModStart> MAX_MB_PLANE <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> MAX_MB_PLANE <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> planes <S2SV_ModEnd> 
203,<S2SV_StartBug> len = args -> len = ntohl ( * p ++ ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0 
204,"<S2SV_StartBug> static inline void assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst ) <S2SV_EndBug> <S2SV_StartBug> switch ( ctxt -> op_bytes ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return assign_eip_far ( ctxt , dst , ctxt -> mode == X86EMUL_MODE_PROT64 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
205,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
206,"<S2SV_StartBug> remaining = tvb_captured_length_remaining ( tvb , offset ) ; <S2SV_EndBug> ",<S2SV_ModStart> tvb_reported_length_remaining <S2SV_ModEnd> 
207,<S2SV_StartBug> get_block = ocfs2_get_block ; <S2SV_EndBug> <S2SV_StartBug> get_block = ocfs2_dio_get_block ; <S2SV_EndBug> ,<S2SV_ModStart> ocfs2_lock_get_block <S2SV_ModEnd> <S2SV_ModStart> ocfs2_dio_wr_get_block <S2SV_ModEnd> 
208,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
209,"<S2SV_StartBug> if ( fscanf ( f , ""%79s<S2SV_blank>%[^\\n]\\n"" , def , strparm ) == 2 ) <S2SV_EndBug> ","<S2SV_ModStart> ""%79s<S2SV_blank>%99[^\\n]\\n"" <S2SV_ModEnd> "
210,<S2SV_StartBug> if ( ( int ) val < 0 ) <S2SV_EndBug> ,<S2SV_ModStart> pmc_overflow ( val ) <S2SV_ModEnd> 
211,"<S2SV_StartBug> len = get_line_size ( * b , * avail , nl ) ; <S2SV_EndBug> ","<S2SV_ModStart> + len , * avail - len <S2SV_ModEnd> "
212,"<S2SV_StartBug> int all_whitespace = 1 ; <S2SV_EndBug> <S2SV_StartBug> mod_ty mod ; <S2SV_EndBug> <S2SV_StartBug> PyObject * o , * fstring_name ; <S2SV_EndBug> <S2SV_StartBug> o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; <S2SV_EndBug> <S2SV_StartBug> PyMem_RawFree ( str ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> node * mod_n ; <S2SV_ModStart> Py_ssize_t len ; const char * s ; PyObject * fstring_name <S2SV_ModEnd> <S2SV_ModStart> for ( s = expr_start ; s != expr_end ; s ++ ) { char c = * s ; if ( ! ( c == '<S2SV_blank>' || c == '\\t' || c == '\\n' || c == '\\f' ) ) { break ; } } if ( s == expr_end ) { ast_error ( c , n , ""f-string:<S2SV_blank>empty<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>allowed"" ) ; return NULL ; } len = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { PyErr_NoMemory ( ) ; return NULL ; } <S2SV_ModEnd> <S2SV_ModStart> mod_n = PyParser_SimpleParseStringFlagsFilename ( str , ""<fstring>"" , Py_eval_input , 0 ) ; if ( ! mod_n ) { PyMem_RawFree ( str ) ; return NULL ; } str [ 0 ] = '{' ; str [ len + 1 ] = '}' ; fstring_fix_node_location ( n , mod_n , str ) ; <S2SV_ModStart> ) ; Ta3Node_Free ( mod_n "
213,"<S2SV_StartBug> void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name ) <S2SV_EndBug> ",<S2SV_ModStart> static 
214,<S2SV_StartBug> cJSON * c = object -> child ; <S2SV_EndBug> ,<S2SV_ModStart> ? object -> child : 0 <S2SV_ModEnd> 
215,"<S2SV_StartBug> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> mark_key_instantiated ( key , 0 <S2SV_ModEnd> "
216,<S2SV_StartBug> assert ( plen <= * len ) ; <S2SV_EndBug> ,<S2SV_ModStart> && plen > 0 
217,"<S2SV_StartBug> args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ; <S2SV_EndBug> ",<S2SV_ModStart> rmtvaluelen = valuelen ; args . 
218,"<S2SV_StartBug> if ( COMPAT_USE_64BIT_TIME ) <S2SV_EndBug> <S2SV_StartBug> if ( get_compat_timespec ( & ktspec , timeout ) ) <S2SV_EndBug> <S2SV_StartBug> if ( datagrams > 0 && put_compat_timespec ( & ktspec , timeout ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> compat_get_timespec <S2SV_ModEnd> <S2SV_ModStart> compat_put_timespec <S2SV_ModEnd> 
219,<S2SV_StartBug> image -> storage_class = PseudoClass ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> case RMT_NONE : <S2SV_EndBug> <S2SV_StartBug> * sun_colormap ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
220,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = hns_nic_net_xmit_hw ( ndev , skb , <S2SV_EndBug> <S2SV_StartBug> if ( ret == NETDEV_TX_OK ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
221,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
222,<S2SV_StartBug> if ( tcp_specified && settings . port != 0 && ! udp_specified ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
223,<S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> ,<S2SV_ModStart> = { 0 } 
224,<S2SV_StartBug> px -> ft -> data = px ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! px -> ft ) { return FALSE ; } 
225,"<S2SV_StartBug> int ret = 0 , found = 0 ; <S2SV_EndBug> <S2SV_StartBug> repo_config = perf_pathdup ( ""config"" ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
226,"<S2SV_StartBug> validate_event ( struct pmu_hw_events * hw_events , <S2SV_EndBug> <S2SV_StartBug> struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ; <S2SV_EndBug> <S2SV_StartBug> if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) <S2SV_EndBug> <S2SV_StartBug> return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ; <S2SV_EndBug> ","<S2SV_ModStart> struct pmu * pmu , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pmu ) return 0 ; if ( event -> pmu != <S2SV_ModStart> armpmu = to_arm_pmu ( event -> pmu ) ; "
227,"<S2SV_StartBug> static bool new_idmap_permitted ( struct user_namespace * ns , int cap_setid , <S2SV_EndBug> <S2SV_StartBug> if ( ns_capable ( ns -> parent , cap_setid ) ) <S2SV_EndBug> ","<S2SV_ModStart> const struct file * file , <S2SV_ModStart> && file_ns_capable ( file , ns -> parent , cap_setid ) "
228,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> return body ; <S2SV_EndBug> ,<S2SV_ModStart> { if ( a -> type == szMAPI_BINARY ) <S2SV_ModStart> } 
229,"<S2SV_StartBug> u8 reset ; <S2SV_EndBug> <S2SV_StartBug> hx = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ret = usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) ) != 1 ) <S2SV_EndBug> <S2SV_StartBug> kfree ( hx ) ; <S2SV_EndBug> <S2SV_StartBug> reset = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ret || usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) != 1 ) { <S2SV_EndBug> <S2SV_StartBug> kfree ( hx ) ; <S2SV_EndBug> ","<S2SV_ModStart> * buf <S2SV_ModEnd> <S2SV_ModStart> u16 cpu_cs_register = <S2SV_ModEnd> <S2SV_ModStart> ; buf = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; hx = ( struct hexline * ) buf ; buf [ 0 ] = 1 ; if ( usb_cypress_writemem ( udev , cpu_cs_register , buf , 1 <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> buf [ 0 ] = 0 ; if ( <S2SV_ModEnd> <S2SV_ModStart> cpu_cs_register , buf <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> "
230,"<S2SV_StartBug> l2tp_call_errors_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> <S2SV_StartBug> ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> ","<S2SV_ModStart> , u_int length <S2SV_ModStart> if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } ptr ++ ; length -= 2 ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> <S2SV_ModStart> if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> <S2SV_ModStart> if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> <S2SV_ModStart> if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> <S2SV_ModStart> if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> <S2SV_ModStart> if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } "
231,"<S2SV_StartBug> if ( strncmp ( handle -> params . realm , realm -> data , realm -> length ) == 0 <S2SV_EndBug> ","<S2SV_ModStart> success = data_eq_string ( * realm , <S2SV_ModEnd> <S2SV_ModStart> ) && data_eq_string ( * c1 , ""kadmin"" ) && ! data_eq_string ( * c2 , ""history"" ) ; <S2SV_ModEnd> "
232,<S2SV_StartBug> if ( uniforms_offset < shader_rec_offset || <S2SV_EndBug> ,<S2SV_ModStart> shader_rec_offset < args -> bin_cl_size || 
233,<S2SV_StartBug> # if HAVA_LZMA_H && HAVE_LIBLZMA <S2SV_EndBug> ,<S2SV_ModStart> HAVE_LZMA_H <S2SV_ModEnd> 
234,<S2SV_StartBug> file_update_time ( vma -> vm_file ) ; <S2SV_EndBug> <S2SV_StartBug> sb_end_pagefault ( inode -> i_sb ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; down_read ( & EXT4_I ( inode ) -> i_mmap_sem <S2SV_ModStart> up_read ( & EXT4_I ( inode ) -> i_mmap_sem ) ; 
235,<S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> ,<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> 
236,<S2SV_StartBug> switch ( * arg ) { <S2SV_EndBug> <S2SV_StartBug> case '\\n' : <S2SV_EndBug> <S2SV_StartBug> * b ++ = * arg ; <S2SV_EndBug> ,<S2SV_ModStart> char ch = * arg ; switch ( ch <S2SV_ModEnd> <S2SV_ModStart> '=' : case <S2SV_ModStart> ch <S2SV_ModEnd> 
237,"<S2SV_StartBug> if ( map && nmap ) { <S2SV_EndBug> <S2SV_StartBug> cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ep2 , map , nmap ) ; else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart>  <S2SV_ModEnd> "
238,<S2SV_StartBug> static gboolean <S2SV_EndBug> <S2SV_StartBug> ice_conn -> context = client ; <S2SV_EndBug> ,"<S2SV_ModStart> typedef struct { guint watch_id ; guint protocol_timeout ; } GsmIceConnectionWatch ; static void disconnect_ice_connection ( IceConn ice_conn ) { IceSetShutdownNegotiation ( ice_conn , FALSE ) ; IceCloseConnection <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
239,<S2SV_StartBug> if ( ( skb_headroom ( skb ) < frag_hdr_sz ) && <S2SV_EndBug> ,<S2SV_ModStart> skb_mac_header <S2SV_ModEnd> <S2SV_ModStart> skb -> head + 
240,<S2SV_StartBug> # ifdef GIT_WIN32 <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> test_checkout_fails ( ""refs/heads/git_tilde1"" , ""git~1/foobar"" ) ; <S2SV_ModEnd> "
241,"<S2SV_StartBug> v . val = test_bit ( SOCK_PASSCRED , & sock -> flags ) ? 1 : 0 ; <S2SV_EndBug> <S2SV_StartBug> v . val = test_bit ( SOCK_PASSSEC , & sock -> flags ) ? 1 : 0 ; <S2SV_EndBug> ",<S2SV_ModStart> ! ! <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ! ! <S2SV_ModStart>  <S2SV_ModEnd> 
242,<S2SV_StartBug> if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> ,<S2SV_ModStart> return 0 ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
243,<S2SV_StartBug> return in ; <S2SV_EndBug> ,<S2SV_ModStart> NULL <S2SV_ModEnd> 
244,"<S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> ",<S2SV_ModStart> MAX_MB_PLANE <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> MAX_MB_PLANE <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
245,"<S2SV_StartBug> char buf [ DN_BUF_LEN ] ; <S2SV_EndBug> <S2SV_StartBug> X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , buf , & bufsize , <S2SV_EndBug> <S2SV_StartBug> md -> subject_dn = strdup ( buf ) ; <S2SV_EndBug> <S2SV_StartBug> X509_NAME_oneline_ex ( X509_get_issuer_name ( cert ) , buf , & bufsize , <S2SV_EndBug> <S2SV_StartBug> md -> issuer_dn = strdup ( buf ) ; <S2SV_EndBug> ","<S2SV_ModStart> * md_out = NULL ; md = calloc ( 1 , sizeof ( <S2SV_ModEnd> <S2SV_ModStart> ret = rfc2253_name <S2SV_ModEnd> <S2SV_ModStart> & <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( ret ) goto cleanup ; ret = rfc2253_name <S2SV_ModEnd> <S2SV_ModStart> & <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( ret ) goto cleanup ; <S2SV_ModEnd> "
246,<S2SV_StartBug> if ( ! npages ) { <S2SV_EndBug> ,<S2SV_ModStart> || base_gfn != old . base_gfn 
247,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
248,<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
249,"<S2SV_StartBug> register u_int amt ; <S2SV_EndBug> <S2SV_StartBug> j = length / sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6 <S2SV_EndBug> <S2SV_StartBug> if ( j * sizeof ( * ni ) != length - 4 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d:"" , j ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> i -= sizeof ( * ni ) , ++ ni ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> j = length / sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> if ( j * sizeof ( * ni ) != length - 4 ) <S2SV_EndBug> <S2SV_StartBug> trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ; <S2SV_EndBug> <S2SV_StartBug> for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> i -= sizeof ( * ni ) , ++ ni ) { <S2SV_EndBug> <S2SV_StartBug> if ( trunc ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> unsigned int length_left ; u_int j ; ND_TCHECK ( rp -> rip6_cmd <S2SV_ModEnd> <S2SV_ModStart> length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> <S2SV_ModStart> ) { ND_TCHECK ( rp -> rip6_nets ) ; if ( <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u[%u]:"" , j , length <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank>ripng-req<S2SV_blank>%u:"" , j ) <S2SV_ModEnd> <S2SV_ModStart> length_left <S2SV_ModEnd> <S2SV_ModStart> length_left <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( * ni ) ; <S2SV_ModStart> if ( length_left != 0 ) goto trunc ; <S2SV_ModStart> length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> <S2SV_ModStart> length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> length_left <S2SV_ModEnd> <S2SV_ModStart> length_left <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( * ni ) ; <S2SV_ModStart> length_left != 0 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( rp -> rip6_vers ) ; <S2SV_ModStart> return ; trunc : ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ; return ; "
250,<S2SV_StartBug> if ( ret < 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> goto error ; <S2SV_ModEnd> 
251,"<S2SV_StartBug> vpx_memcpy ( sortlist , cpi -> mb_activity_map , <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> 
252,<S2SV_StartBug> bprm -> interp = iname ; <S2SV_EndBug> ,"<S2SV_ModStart> retval = bprm_change_interp ( iname , bprm ) ; if ( retval < 0 ) goto _error <S2SV_ModEnd> "
253,<S2SV_StartBug> int iSrc ; <S2SV_EndBug> <S2SV_StartBug> for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { <S2SV_EndBug> <S2SV_StartBug> dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ] . 
254,<S2SV_StartBug> _ipmi_destroy_user ( user ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
255,"<S2SV_StartBug> Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; return ; } if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) { Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".cfg\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" "
256,<S2SV_StartBug> int sl = strlen ( cursor -> ns ) + 1 ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> 
257,"<S2SV_StartBug> if ( mobj ) <S2SV_EndBug> <S2SV_StartBug> memset ( mobj_get_va ( mobj , 0 ) , 0 , size ) ; <S2SV_EndBug> ","<S2SV_ModStart> { size_t granularity = BIT ( tee_mm_sec_ddr . shift ) ; <S2SV_ModStart> ROUNDUP ( size , granularity ) ) ; } <S2SV_ModEnd> "
258,<S2SV_StartBug> timer -> it_overrun += 1 << i ; <S2SV_EndBug> ,<S2SV_ModStart> 1LL <S2SV_ModEnd> 
259,"<S2SV_StartBug> int is_async = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> for_ch = CHILD ( n , 1 + is_async ) ; <S2SV_EndBug> <S2SV_StartBug> expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( NCH ( n ) == ( 5 + is_async ) ) { <S2SV_EndBug> <S2SV_StartBug> n = CHILD ( n , 4 + is_async ) ; <S2SV_EndBug> ","<S2SV_ModStart> node * sync_n ; <S2SV_ModStart> NCH ( n ) == 2 <S2SV_ModEnd> <S2SV_ModStart> REQ ( CHILD ( n , 0 ) , NAME ) ; assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , ""async"" ) == 0 ) ; sync_n = CHILD ( n , 1 ) ; } else { sync_n = CHILD ( n , 0 ) ; } REQ ( sync_n , sync_comp_for ) ; <S2SV_ModEnd> <S2SV_ModStart> sync_n , 1 <S2SV_ModEnd> <S2SV_ModStart> sync_n , 3 <S2SV_ModEnd> <S2SV_ModStart> sync_n ) == 5 <S2SV_ModEnd> <S2SV_ModStart> sync_n , 4 <S2SV_ModEnd> "
260,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> dst_state -> speculative = src -> speculative ; 
261,"<S2SV_StartBug> static void write_mb_modes_kf ( const VP9_COMP * cpi , MODE_INFO * * mi_8x8 , <S2SV_EndBug> <S2SV_StartBug> vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> const MODE_INFO * const above_mi = mi_8x8 [ - xd -> mi_stride ] ; <S2SV_EndBug> <S2SV_StartBug> const MODE_INFO * const left_mi = xd -> left_available ? mi_8x8 [ - 1 ] : NULL ; <S2SV_EndBug> <S2SV_StartBug> write_skip ( cpi , mbmi -> segment_id , mi , w ) ; <S2SV_EndBug> <S2SV_StartBug> write_selected_tx_size ( cpi , mbmi -> tx_size , bsize , w ) ; <S2SV_EndBug> ","<S2SV_ModStart> VP9_COMMON * cm , const MACROBLOCKD * xd , <S2SV_ModEnd> <S2SV_ModStart> vpx_writer * w ) { <S2SV_ModEnd> <S2SV_ModStart> xd -> above_mi <S2SV_ModEnd> <S2SV_ModStart> left_mi <S2SV_ModEnd> <S2SV_ModStart> cm , xd <S2SV_ModEnd> <S2SV_ModStart> cm , xd <S2SV_ModEnd> "
262,<S2SV_StartBug> saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> ,<S2SV_ModStart> INADDR_LOOPBACK <S2SV_ModEnd> 
263,"<S2SV_StartBug> DPRINTF ( ""Data<S2SV_blank>ready<S2SV_blank>tag=0x%x<S2SV_blank>len=%zd\\n"" , r -> req . tag , r -> iov . iov_len ) ; <S2SV_EndBug> <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> <S2SV_StartBug> scsi_req_data ( & r -> req , r -> iov . iov_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> qiov . size <S2SV_ModEnd> <S2SV_ModStart> qiov . size <S2SV_ModEnd> <S2SV_ModStart> qiov . size <S2SV_ModEnd> 
264,<S2SV_StartBug> if ( cs > CQSPI_MAX_CHIPSELECT ) { <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> 
265,"<S2SV_StartBug> if ( n > maxn ) SWF_error ( ""Action<S2SV_blank>overflow!!"" ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( actions [ n ] . SWF_ACTIONRECORD . ActionCode ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> OpCode ( actions , n , maxn ) <S2SV_ModEnd> "
266,"<S2SV_StartBug> memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( l > ll ) l = ll ; 
267,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> } if ( free < 0 ) { err = - ENOMEM ; goto out ; 
268,<S2SV_StartBug> if ( len < sizeof ( * prep ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> || ! ND_TTEST ( * prep ) ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
269,<S2SV_StartBug> rq -> skip_clock_update = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
270,"<S2SV_StartBug> uint8_t value ; <S2SV_EndBug> <S2SV_StartBug> 0 , reg , & value , 1 , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> return ret >= 0 ? value : ret ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> * buffer ; uint8_t value ; buffer = kmalloc ( 1 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> buffer <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> ) { value = buffer [ 0 ] ; kfree ( buffer ) ; return value ; } else { kfree ( buffer ) ; return <S2SV_ModEnd> <S2SV_ModStart> } "
271,"<S2SV_StartBug> static void addModuleArgument ( sqlite3 * db , Table * pTable , char * zArg ) { <S2SV_EndBug> <S2SV_StartBug> int nBytes = sizeof ( char * ) * ( 2 + pTable -> nModuleArg ) ; <S2SV_EndBug> <S2SV_StartBug> char * * azModuleArg ; <S2SV_EndBug> ","<S2SV_ModStart> Parse * pParse <S2SV_ModEnd> <S2SV_ModStart> sqlite3_int64 <S2SV_ModEnd> <S2SV_ModStart> sqlite3 * db = pParse -> db ; if ( pTable -> nModuleArg + 3 >= db -> aLimit [ SQLITE_LIMIT_COLUMN ] ) { sqlite3ErrorMsg ( pParse , ""too<S2SV_blank>many<S2SV_blank>columns<S2SV_blank>on<S2SV_blank>%s"" , pTable -> zName ) ; } "
272,"<S2SV_StartBug> memcpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ; <S2SV_EndBug> ","<S2SV_ModStart> s -> append_char ( s , 0 ) ; strncpy <S2SV_ModEnd> "
273,<S2SV_StartBug> CurrentColorSpace = ColorSpaceOut ; <S2SV_EndBug> <S2SV_StartBug> cmsPipelineFree ( Lut ) ; <S2SV_EndBug> ,<S2SV_ModStart> Lut = NULL ; <S2SV_ModStart> if ( Lut != NULL ) 
274,<S2SV_StartBug> for ( i = 0 ; i < sec -> size ; i += 4 ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < sec -> size ; i += 8 ) { <S2SV_EndBug> ,<S2SV_ModStart> ( i + 3 ) <S2SV_ModEnd> <S2SV_ModStart> ( i + 7 ) <S2SV_ModEnd> 
275,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""%sBandwidth<S2SV_blank>Constraints<S2SV_blank>Model<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(%u)"" , <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , 4 ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( subl == 0 ) break ; <S2SV_ModStart>  <S2SV_ModEnd> 
276,"<S2SV_StartBug> if ( ixheaacd_cmplx_anal_fft != NULL ) <S2SV_EndBug> <S2SV_StartBug> ( * ixheaacd_cmplx_anal_fft ) ( u_in , u_out , anal_size * 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ( ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft ) ) <S2SV_ModEnd> 
277,"<S2SV_StartBug> while ( p < q ) p += enclen ( reg -> enc , p ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( q >= end ) return 0 ; 
278,"<S2SV_StartBug> static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) <S2SV_EndBug> <S2SV_StartBug> struct bfq_data * bfqd = bfqq -> bfqd ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & bfqd -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> struct bfq_data * bfqd , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> bfq_clear_bfqq_wait_request ( bfqq ) ; "
279,<S2SV_StartBug> if ( key_is_instantiated ( key ) && <S2SV_EndBug> ,<S2SV_ModStart> key_is_positive <S2SV_ModEnd> 
280,"<S2SV_StartBug> RING_FINAL_CHECK_FOR_REQUESTS ( & vif -> tx , work_to_do ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( work_to_do < 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( ret < 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , <S2SV_EndBug> <S2SV_StartBug> netbk_tx_err ( vif , & txreq , idx ) ; <S2SV_EndBug> <S2SV_StartBug> netbk_tx_err ( vif , & txreq , idx ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( vif -> tx . sring -> req_prod - vif -> tx . req_cons > XEN_NETIF_TX_RING_SIZE ) { netdev_err ( vif -> dev , ""Impossible<S2SV_blank>number<S2SV_blank>of<S2SV_blank>requests.<S2SV_blank>"" ""req_prod<S2SV_blank>%d,<S2SV_blank>req_cons<S2SV_blank>%d,<S2SV_blank>size<S2SV_blank>%ld\\n"" , vif -> tx . sring -> req_prod , vif -> tx . req_cons , XEN_NETIF_TX_RING_SIZE ) ; netbk_fatal_tx_err ( vif ) ; continue ; } <S2SV_ModStart> continue ; <S2SV_ModEnd> <S2SV_ModStart> continue ; <S2SV_ModEnd> <S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> netbk_fatal_tx_err ( vif <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
281,<S2SV_StartBug> ( void ) tls_init_new_session ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> flush_cmd ( ) ; 
282,<S2SV_StartBug> struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
283,<S2SV_StartBug> parse_input ( conn ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( <S2SV_ModStart> != 0 ) return 
284,"<S2SV_StartBug> struct pending_tx_info * pending_tx_info = netbk -> pending_tx_info ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( err ) ) { <S2SV_EndBug> <S2SV_StartBug> netbk -> pending_ring [ index ] = pending_idx ; <S2SV_EndBug> <S2SV_StartBug> pending_ring_idx_t index ; <S2SV_EndBug> <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> <S2SV_StartBug> txp = & netbk -> pending_tx_info [ pending_idx ] . req ; <S2SV_EndBug> <S2SV_StartBug> index = pending_index ( netbk -> pending_prod ++ ) ; <S2SV_EndBug> <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> xen_netbk_idx_release ( netbk , pending_idx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , XEN_NETIF_RSP_OKAY <S2SV_ModStart> xen_netbk_idx_release ( netbk , pending_idx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , XEN_NETIF_RSP_OKAY <S2SV_ModStart> , XEN_NETIF_RSP_OKAY "
285,"
","
"
286,"<S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> ",<S2SV_ModStart> { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> } <S2SV_ModStart> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> } <S2SV_ModStart> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; 
287,<S2SV_StartBug> if ( len < 0 || addr . nl_pid ) { <S2SV_EndBug> <S2SV_StartBug> incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( addr . nl_pid ) { syslog ( LOG_WARNING , ""Received<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>untrusted<S2SV_blank>pid:%u"" , addr . nl_pid ) ; continue ; } "
288,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
289,<S2SV_StartBug> if ( client -> ipc == NULL ) { <S2SV_EndBug> ,<S2SV_ModStart> && client -> session == NULL 
290,"<S2SV_StartBug> diffPtr + x > diffBlock + diffBlockLength || <S2SV_EndBug> <S2SV_StartBug> memcpy ( newData + newpos , diffPtr , x ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(overflow)"" ) ; return NULL ; } memcpy ( newData + newpos , diffPtr , x ) ; diffPtr += x ; for ( j = 0 ; j < x ; j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ; newpos += x ; oldpos += x ; if ( newpos + y > newDataLength <S2SV_ModStart>  <S2SV_ModEnd> "
291,"<S2SV_StartBug> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; <S2SV_EndBug> ","<S2SV_ModStart> lfi , fname , UDF_NAME_LEN <S2SV_ModEnd> "
292,"<S2SV_StartBug> __ip_vs_get_timeouts ( net , & t ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( & t , 0 , sizeof ( t ) ) ; "
293,"<S2SV_StartBug> err = ip6_xmit ( sk , skb , fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> ","<S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) , <S2SV_ModEnd> "
294,<S2SV_StartBug> ssize_t result ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES 
295,"<S2SV_StartBug> char * fpath = NULL , * path1 , * cgdir = NULL , * controller ; <S2SV_EndBug> <S2SV_StartBug> if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) { <S2SV_EndBug> <S2SV_StartBug> ret = - EACCES ; <S2SV_EndBug> <S2SV_StartBug> if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) { <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> , * next = NULL <S2SV_ModStart> caller_is_in_ancestor ( fc -> pid , controller , path1 , & next <S2SV_ModEnd> <S2SV_ModStart> if ( fpath && strcmp ( next , fpath ) == 0 ) ret = - EEXIST ; else ret = - ENOENT <S2SV_ModEnd> <S2SV_ModStart> fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) { ret = - EACCES ; goto out ; } if ( ! <S2SV_ModStart> free ( next ) ; "
296,<S2SV_StartBug> disk -> queue = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> put_disk ( disk ) ; 
297,"<S2SV_StartBug> void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <S2SV_EndBug> ",<S2SV_ModStart> static 
298,"<S2SV_StartBug> if ( CheckMemoryOverflow ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse ) <S2SV_EndBug> <S2SV_StartBug> if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) <S2SV_EndBug> ",<S2SV_ModStart> HeapOverflowSanityCheck <S2SV_ModEnd> <S2SV_ModStart> HeapOverflowSanityCheck <S2SV_ModEnd> 
299,"<S2SV_StartBug> int64_t index_pts = FFMAX ( av_rescale ( itime , i , 10000 ) - asf -> hdr . preroll , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( avio_feof ( s -> pb ) ) { ret = AVERROR_INVALIDDATA ; goto end ; } 
300,"<S2SV_StartBug> rinfo = kmalloc ( SZ_SG_REQ_INFO * SG_MAX_QUEUE , <S2SV_EndBug> ",<S2SV_ModStart> kzalloc <S2SV_ModEnd> 
301,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> install_keyword ( ""umask"" , & umask_handler ) ; "
302,<S2SV_StartBug> return encoder_common_init ( ctx ) ; <S2SV_EndBug> ,"<S2SV_ModStart> vpx_codec_err_t res = VPX_CODEC_OK ; ( void ) data ; if ( ctx -> priv == NULL ) { vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1 , sizeof ( * priv ) ) ; if ( priv == NULL ) return VPX_CODEC_MEM_ERROR ; ctx -> priv = ( vpx_codec_priv_t * ) priv ; ctx -> priv -> init_flags = ctx -> init_flags ; ctx -> priv -> enc . total_encoders = 1 ; priv -> buffer_pool = ( BufferPool * ) vpx_calloc ( 1 , sizeof ( BufferPool ) ) ; if ( priv -> buffer_pool == NULL ) return VPX_CODEC_MEM_ERROR ; # if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & priv -> buffer_pool -> pool_mutex , NULL ) ) { return VPX_CODEC_MEM_ERROR ; } # endif if ( ctx -> config . enc ) { priv -> cfg = * ctx -> config . enc ; ctx -> config . enc = & priv -> cfg ; } priv -> extra_cfg = default_extra_cfg ; once ( vp9_initialize_enc ) ; res = validate_config ( priv , & priv -> cfg , & priv -> extra_cfg ) ; if ( res == VPX_CODEC_OK ) { set_encoder_config ( & priv -> oxcf , & priv -> cfg , & priv -> extra_cfg ) ; # if CONFIG_VP9_HIGHBITDEPTH priv -> oxcf . use_highbitdepth = ( ctx -> init_flags & VPX_CODEC_USE_HIGHBITDEPTH ) ? 1 : 0 ; # endif priv -> cpi = vp9_create_compressor ( & priv -> oxcf , priv -> buffer_pool ) ; if ( priv -> cpi == NULL ) res = VPX_CODEC_MEM_ERROR ; else priv -> cpi -> output_pkt_list = & priv -> pkt_list . head ; } } return res <S2SV_ModEnd> "
303,<S2SV_StartBug> char * tmpptr = key + strlen ( key ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
304,"<S2SV_StartBug> touch_file ( t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> MODE_INVALID <S2SV_ModEnd> 
305,"<S2SV_StartBug> if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n"" , <S2SV_EndBug> <S2SV_StartBug> if ( box -> len == 1 ) { <S2SV_EndBug> ","<S2SV_ModStart> jp2_box_create0 ( ) ) ) { goto error ; } <S2SV_ModEnd> <S2SV_ModStart> ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>"" ""type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%"" PRIuFAST32 ""\\n"" <S2SV_ModEnd> <S2SV_ModStart> JAS_DBGLOG ( 10 , ( ""big<S2SV_blank>length\\n"" ) ) ; "
306,"<S2SV_StartBug> _Unpickler_ResizeMemoList ( UnpicklerObject * self , Py_ssize_t new_size ) <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> ",<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> 
307,"<S2SV_StartBug> int copylen ; <S2SV_EndBug> <S2SV_StartBug> if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) ) <S2SV_EndBug> <S2SV_StartBug> copylen = vnet_hdr . hdr_len ; <S2SV_EndBug> ","<S2SV_ModStart> = 0 <S2SV_ModStart> err = - EMSGSIZE ; if ( unlikely ( count > UIO_MAXIOV ) ) goto err ; <S2SV_ModStart> if ( count > MAX_SKB_FRAGS ) { copylen = iov_length ( iv , count - MAX_SKB_FRAGS ) ; if ( copylen < vnet_hdr_len ) copylen = 0 ; else copylen -= vnet_hdr_len ; } if ( copylen < vnet_hdr . hdr_len ) "
308,<S2SV_StartBug> u16 offset = sizeof ( struct ipv6hdr ) ; <S2SV_EndBug> <S2SV_StartBug> while ( offset + 1 <= packet_len ) { <S2SV_EndBug> <S2SV_StartBug> switch ( * * nexthdr ) { <S2SV_EndBug> <S2SV_StartBug> offset += ipv6_optlen ( exthdr ) ; <S2SV_EndBug> <S2SV_StartBug> exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> struct ipv6_opt_hdr * exthdr ; <S2SV_ModStart> if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <S2SV_ModStart> } return - EINVAL <S2SV_ModEnd> 
309,"<S2SV_StartBug> static void write_delta_q ( struct vp9_write_bit_buffer * wb , int delta_q ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , abs ( delta_q ) , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , delta_q < 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> 
310,<S2SV_StartBug> find = 1 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
311,"<S2SV_StartBug> put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ; <S2SV_EndBug> ",<S2SV_ModStart> aux . tp_padding = 0 ; 
312,<S2SV_StartBug> if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
313,"<S2SV_StartBug> pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" <S2SV_EndBug> ",<S2SV_ModStart> pr_debug <S2SV_ModEnd> 
314,<S2SV_StartBug> const int length ) { <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> 
315,"<S2SV_StartBug> sctp_addiphdr_t * hdr ; <S2SV_EndBug> <S2SV_StartBug> int all_param_pass = 1 ; <S2SV_EndBug> <S2SV_StartBug> while ( chunk_len > 0 ) { <S2SV_EndBug> <S2SV_StartBug> asconf_param ) ; <S2SV_EndBug> <S2SV_StartBug> all_param_pass = 0 ; <S2SV_EndBug> <S2SV_StartBug> asconf_param -> crr_id , err_code , <S2SV_EndBug> <S2SV_StartBug> length = ntohs ( asconf_param -> param_hdr . length ) ; <S2SV_EndBug> ","<S2SV_ModStart> sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) asconf -> chunk_hdr ; bool all_param_pass = true ; union sctp_params param ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sctp_walk_params ( param , addip , addip_hdr . params ) { if ( param . p -> type == SCTP_PARAM_IPV4_ADDRESS || param . p -> type == SCTP_PARAM_IPV6_ADDRESS ) continue ; <S2SV_ModEnd> <S2SV_ModStart> param . addip ) ; if ( err_code != SCTP_ERROR_NO_ERROR <S2SV_ModEnd> <S2SV_ModStart> false <S2SV_ModEnd> <S2SV_ModStart> param . addip <S2SV_ModEnd> <S2SV_ModStart> err_code , param . addip ) ; if ( err_code == SCTP_ERROR_RSRC_LOW <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
316,"<S2SV_StartBug> JAS_DBGLOG ( 101 , ( ""jas_realloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%x,%zu\\n"" , ptr , size ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""jas_realloc(%x,<S2SV_blank>%zu)\\n"" <S2SV_ModEnd> "
317,<S2SV_StartBug> m -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
318,<S2SV_StartBug> is_kvmppc_hv_enabled ( kvm ) ; <S2SV_EndBug> ,<S2SV_ModStart> hv_enabled <S2SV_ModEnd> 
319,"<S2SV_StartBug> pci_populate_msicap ( & msicap , msgnum , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> return <S2SV_ModStart> || <S2SV_ModEnd> 
320,"<S2SV_StartBug> keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . key ) ; <S2SV_EndBug> <S2SV_StartBug> valuelen = utf8s_to_utf16s ( value , strlen ( value ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . value ) ; <S2SV_EndBug> ","<S2SV_ModStart> UTF16_HOST_ENDIAN , <S2SV_ModStart> , HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2 <S2SV_ModStart> UTF16_HOST_ENDIAN , <S2SV_ModStart> , HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2 "
321,<S2SV_StartBug> ctx = d -> log_ctx ; <S2SV_EndBug> ,<S2SV_ModStart> d -> log_file = eventfp ; 
322,<S2SV_StartBug> img -> color_space = OPJ_CLRSPC_SRGB ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
323,<S2SV_StartBug> void * parg = NULL ; <S2SV_EndBug> <S2SV_StartBug> int is_ext_ctrl ; <S2SV_EndBug> <S2SV_StartBug> case _IOC_NONE : <S2SV_EndBug> <S2SV_StartBug> case _IOC_WRITE : <S2SV_EndBug> <S2SV_StartBug> if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> ( void * ) arg ; long err = - EINVAL ; bool has_array_args ; size_t array_size = 0 ; void __user * user_ptr = NULL ; void * * kernel_ptr = NULL ; if ( _IOC_DIR ( cmd ) != _IOC_NONE ) { if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) { parg = sbuf ; } else { mbuf = kmalloc ( _IOC_SIZE ( cmd ) , GFP_KERNEL ) ; if ( NULL == mbuf ) return - ENOMEM ; parg = mbuf ; } err = - EFAULT ; if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) { unsigned long n = cmd_input_size ( cmd ) ; if ( copy_from_user ( parg , ( void __user * ) arg , n ) ) goto out ; if ( n < _IOC_SIZE ( cmd ) ) memset ( ( u8 * ) parg + n , 0 , _IOC_SIZE ( cmd ) - n ) ; } else { memset ( parg , 0 , _IOC_SIZE ( cmd ) ) ; } } err = check_array_args ( cmd , parg , & array_size , & user_ptr , & kernel_ptr ) ; if ( err < 0 ) goto out ; has_array_args = err ; if ( has_array_args ) { mbuf = kmalloc ( array_size , GFP_KERNEL ) ; err = - ENOMEM ; if ( NULL == mbuf ) goto out_array_args ; err = - EFAULT ; if ( copy_from_user ( mbuf , user_ptr , array_size ) ) goto out_array_args ; * kernel_ptr = mbuf ; } err = func ( file , cmd , parg ) ; if ( err == - ENOIOCTLCMD ) <S2SV_ModEnd> <S2SV_ModStart> if ( has_array_args ) { * kernel_ptr = user_ptr ; if ( copy_to_user ( user_ptr , mbuf , array_size ) ) err = - EFAULT ; goto out_array_args ; } if ( err < 0 ) goto out ; out_array_args : <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
324,<S2SV_StartBug> if ( server . vm_enabled && server . vm_max_threads > 0 && <S2SV_EndBug> ,<S2SV_ModStart> ds_enabled && <S2SV_ModEnd> 
325,"<S2SV_StartBug> static int set_registers ( rtl8150_t * dev , u16 indx , u16 size , void * data ) <S2SV_EndBug> <S2SV_StartBug> return usb_control_msg ( dev -> udev , usb_sndctrlpipe ( dev -> udev , 0 ) , <S2SV_EndBug> <S2SV_StartBug> indx , 0 , data , size , 500 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> const <S2SV_ModStart> void * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> kfree ( buf ) ; return ret ; "
326,<S2SV_StartBug> endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( usbinterface -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & usbinterface -> dev , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n"" ) ; error = - EINVAL ; goto err_free_urb ; } "
327,<S2SV_StartBug> case RESPONSE_RUN : <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> GTK_RESPONSE_OK : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_set_metadata ( parameters -> file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL , ""yes"" ) ; nautilus_file_mark_desktop_file_executable ( file , parameters -> parent_window , TRUE , NULL , NULL ) ; nautilus_file_invalidate_all_attributes ( parameters -> file ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
328,<S2SV_StartBug> if ( edge_port -> lsr_event ) { <S2SV_EndBug> ,<S2SV_ModStart> urb -> actual_length > 0 && 
329,"<S2SV_StartBug> cifs_find_smb_ses ( struct TCP_Server_Info * server , char * username ) <S2SV_EndBug> <S2SV_StartBug> list_for_each ( tmp , & server -> smb_ses_list ) { <S2SV_EndBug> <S2SV_StartBug> if ( strncmp ( ses -> userName , username , MAX_USERNAME_SIZE ) ) <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> ","<S2SV_ModStart> struct smb_vol * vol ) { <S2SV_ModEnd> <S2SV_ModStart> list_for_each_entry ( ses <S2SV_ModEnd> <S2SV_ModStart> , smb_ses_list ) { switch ( server -> secType ) { case Kerberos : if ( vol -> linux_uid != ses -> linux_uid ) continue ; break ; default : <S2SV_ModEnd> <S2SV_ModStart> vol -> <S2SV_ModStart> if ( strlen ( vol -> username ) != 0 && strncmp ( ses -> password , vol -> password , MAX_PASSWORD_SIZE ) ) continue ; } "
330,"<S2SV_StartBug> if ( ( ( cfg -> g_w != ctx -> cfg . g_w ) || ( cfg -> g_h != ctx -> cfg . g_h ) ) <S2SV_EndBug> <S2SV_StartBug> && ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS ) ) <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> { if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ( ctx -> cpi -> initial_width && ( int ) cfg -> g_w > ctx -> cpi -> initial_width ) || ( ctx -> cpi -> initial_height && ( int ) cfg -> g_h > ctx -> cpi -> initial_height ) ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>their<S2SV_blank>initial<S2SV_blank>values"" ) ; } "
331,"<S2SV_StartBug> input ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ! r_fs_mount ( core -> fs , ptr , input , off ) ) <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = r_fs_name ( core -> fs , core -> offset ) ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( ! r_fs_mount ( core -> fs , ptr , input , core -> offset ) ) <S2SV_EndBug> <S2SV_StartBug> eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\n"" , input ) ; <S2SV_EndBug> ",<S2SV_ModStart> { input ++ ; } <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } 
332,"<S2SV_StartBug> if ( vm_flags & VM_NORESERVE ) <S2SV_EndBug> <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> hugepage_subpool_get_pages ( spool <S2SV_ModEnd> <S2SV_ModStart> hugepage_subpool_put_pages ( spool <S2SV_ModEnd> 
333,<S2SV_StartBug> struct key * keyring ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( new -> thread_keyring ) return 0 
334,<S2SV_StartBug> static size_t scanned ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
335,<S2SV_StartBug> fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ; <S2SV_EndBug> <S2SV_StartBug> fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ; <S2SV_EndBug> ,"<S2SV_ModStart> fptr_orig = io_get_open_fptr ( mrb , orig ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
336,"<S2SV_StartBug> . match_data . cmp = user_match , <S2SV_EndBug> ",<S2SV_ModStart> key_default_cmp <S2SV_ModEnd> 
337,"<S2SV_StartBug> cpi -> zbin_mode_boost = 0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> td . 
338,"<S2SV_StartBug> utee_param_to_param ( param , callee_params ) ; <S2SV_EndBug> ","<S2SV_ModStart> res = utee_param_to_param ( utc , <S2SV_ModEnd> <S2SV_ModStart> ; if ( res != TEE_SUCCESS ) return res "
339,"<S2SV_StartBug> old_cs = get_segment_selector ( ctxt , VCPU_SREG_CS ) ; <S2SV_EndBug> <S2SV_StartBug> if ( load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) ) <S2SV_EndBug> <S2SV_StartBug> ctxt -> _eip = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; int cpl = ctxt -> ops -> cpl ( ctxt ) ; old_eip = ctxt -> _eip ; ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rc = __load_segment_descriptor <S2SV_ModEnd> <S2SV_ModStart> , cpl , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE <S2SV_ModEnd> <S2SV_ModStart> rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_cs ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_eip ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; return rc ; fail : ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; return rc <S2SV_ModEnd> "
340,"<S2SV_StartBug> reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ; <S2SV_EndBug> <S2SV_StartBug> band -> prec = av_malloc_array ( reslevel -> num_precincts_x * <S2SV_EndBug> ",<S2SV_ModStart> av_calloc <S2SV_ModEnd> <S2SV_ModStart> av_calloc <S2SV_ModEnd> 
341,"<S2SV_StartBug> COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! COM_CompareExtension ( filename , "".txt"" ) ) { Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".txt\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" ) ; return ; } "
342,"<S2SV_StartBug> struct reloc_struct_t * got_table = calloc ( 1 , n_got * sizeof ( ut32 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct reloc_struct_t <S2SV_ModEnd> 
343,<S2SV_StartBug> if ( info -> si_code >= 0 ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug> ,<S2SV_ModStart> != SI_QUEUE ) { WARN_ON_ONCE ( info -> si_code < 0 ) ; <S2SV_ModEnd> <S2SV_ModStart> } 
344,"<S2SV_StartBug> * p_tx0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> tx0 + p * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x0 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x1 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y0 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ( OPJ_INT32 ) opj_uint_max <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ( OPJ_INT32 ) opj_uint_min <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ( OPJ_INT32 ) opj_uint_max <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ( OPJ_INT32 ) opj_uint_min <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> "
345,"<S2SV_StartBug> static char * create_output_name ( unsigned char * fname , unsigned char * dir , <S2SV_EndBug> <S2SV_StartBug> if ( utf8 ) x *= 3 ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""out<S2SV_blank>of<S2SV_blank>memory!\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> while ( * fname == sep ) fname ++ ; <S2SV_EndBug> <S2SV_StartBug> p = & name [ strlen ( ( char * ) name ) ] ; <S2SV_EndBug> <S2SV_StartBug> if ( fname >= fe ) { <S2SV_EndBug> <S2SV_StartBug> x = ( c & 0x1F ) << 6 ; <S2SV_EndBug> <S2SV_StartBug> } while ( x ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) { char * out , * p <S2SV_ModEnd> <S2SV_ModStart> ( out = malloc ( strlen ( fname ) + 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> '/' || * fname == '\\\\' <S2SV_ModEnd> <S2SV_ModStart> strcpy ( out , ( * fname ) ? fname : ""x"" ) ; for ( p = out ; * p ; p ++ ) <S2SV_ModEnd> <S2SV_ModStart> p [ 0 ] == '.' && p [ 1 ] == '.' && ( p [ 2 ] == '/' || p [ 2 ] == '\\\\' <S2SV_ModEnd> <S2SV_ModStart> p [ 0 ] = p [ 1 ] = 'x' <S2SV_ModEnd> <S2SV_ModStart> } return out <S2SV_ModEnd> "
346,"<S2SV_StartBug> zval * options = NULL , * classes = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { <S2SV_EndBug> <S2SV_StartBug> zval_ptr_dtor ( return_value ) ; <S2SV_EndBug> <S2SV_StartBug> var_push_dtor ( & var_hash , return_value ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; zval * retval <S2SV_ModStart> retval = var_tmp_var ( & var_hash ) ; <S2SV_ModStart> retval <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ZVAL_COPY ( return_value , retval <S2SV_ModEnd> "
347,<S2SV_StartBug> kfree ( tu -> queue ) ; <S2SV_EndBug> ,<S2SV_ModStart> tu -> qhead = tu -> qtail = tu -> qused = 0 ; 
348,<S2SV_StartBug> tmp_strsize = ( u32 ) ptr -> size - 8 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
349,<S2SV_StartBug> buf = ctx -> iface -> enc . get_glob_hdrs ( ctx -> priv -> alg_priv ) ; <S2SV_EndBug> ,<S2SV_ModStart> get_alg_priv ( ctx ) <S2SV_ModEnd> 
350,"<S2SV_StartBug> else if ( Ustrcmp ( argrest , ""Mr"" ) == 0 ) received_protocol = argv [ ++ i ] ; <S2SV_EndBug> <S2SV_StartBug> uschar * hn = Ustrchr ( argrest , ':' ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( received_protocol ) { fprintf ( stderr , ""received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\n"" ) ; exit ( EXIT_FAILURE ) ; } else <S2SV_ModStart> hn ; if ( received_protocol ) { fprintf ( stderr , ""received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\n"" ) ; exit ( EXIT_FAILURE ) ; } "
351,<S2SV_StartBug> if ( info -> si_code >= 0 ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug> ,<S2SV_ModStart> != SI_QUEUE ) { WARN_ON_ONCE ( info -> si_code < 0 ) ; <S2SV_ModEnd> <S2SV_ModStart> } 
352,"<S2SV_StartBug> s -> off = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> <S2SV_StartBug> s -> filesize = strtoll ( slash + 1 , NULL , 10 ) ; <S2SV_EndBug> ",<S2SV_ModStart> strtoull <S2SV_ModEnd> <S2SV_ModStart> strtoull <S2SV_ModEnd> 
353,"<S2SV_StartBug> unsigned int maxw , maxh , max ; <S2SV_EndBug> <S2SV_StartBug> unsigned int i , j ; <S2SV_EndBug> <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0U ; i < maxh ; ++ i ) <S2SV_EndBug> <S2SV_StartBug> for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> <S2SV_StartBug> if ( j < maxw ) { <S2SV_EndBug> <S2SV_StartBug> # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_EndBug> <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> <S2SV_StartBug> if ( g ) free ( g ) ; <S2SV_EndBug> <S2SV_StartBug> if ( b ) free ( b ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> , offx , loopmaxw <S2SV_ModStart> size_t i <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; <S2SV_ModStart> size_t j ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } <S2SV_ModStart> loopmaxw <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> loopmaxw <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> <S2SV_ModStart> dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
354,"<S2SV_StartBug> nfs4_state_set_mode_locked ( struct nfs4_state * state , mode_t mode ) <S2SV_EndBug> <S2SV_StartBug> if ( state -> state == mode ) <S2SV_EndBug> <S2SV_StartBug> if ( ( mode & FMODE_WRITE ) != ( state -> state & FMODE_WRITE ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( mode & FMODE_WRITE ) <S2SV_EndBug> <S2SV_StartBug> state -> state = mode ; <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> 
355,"<S2SV_StartBug> ptr = sshpkt_ptr ( ssh , & dlen ) ; <S2SV_EndBug> ","<S2SV_ModStart> ssh_dispatch_set ( ssh , SSH2_MSG_KEXINIT , NULL ) ; "
356,"<S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> ","<S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[256]<S2SV_blank>==<S2SV_blank>256<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\""baz\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""foo\\""]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""bar\\""]<S2SV_blank>==<S2SV_blank>\\""bar\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\""dummy\\"")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""foo\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""bar\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> "
357,<S2SV_StartBug> ( void ) CloseBlob ( pwp_image ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
358,"<S2SV_StartBug> char lbase [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char strbase [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char ltest [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char strtest [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> int nbase = sscanf ( lbase , ""%255[^\\r\\n]"" , strbase ) ; <S2SV_EndBug> <S2SV_StartBug> int ntest = sscanf ( ltest , ""%255[^\\r\\n]"" , strtest ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( nbase != 255 && ntest != 255 ) ; <S2SV_EndBug> ","<S2SV_ModStart> 512 <S2SV_ModEnd> <S2SV_ModStart> 512 <S2SV_ModEnd> <S2SV_ModStart> 512 <S2SV_ModEnd> <S2SV_ModStart> 512 <S2SV_ModEnd> <S2SV_ModStart> ""%511[^\\r\\n]"" <S2SV_ModEnd> <S2SV_ModStart> ""%511[^\\r\\n]"" <S2SV_ModEnd> <S2SV_ModStart> 511 <S2SV_ModEnd> <S2SV_ModStart> 511 <S2SV_ModEnd> "
359,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = cdc_ncm_bind_common ( dev , intf , CDC_NCM_DATA_ALTSETTING_NCM , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> usbnet_link_change ( dev , 0 , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
360,"<S2SV_StartBug> memcpy ( elem . in_sg [ 0 ] . iov_base , buf , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> iov_from_buf <S2SV_ModEnd> <S2SV_ModStart> , elem . in_num , 0 <S2SV_ModEnd> "
361,"<S2SV_StartBug> i , ( unsigned ) JPC_QCX_GETEXPN ( qcd -> compparms . stepsizes [ i ] ) , <S2SV_EndBug> <S2SV_StartBug> i , ( unsigned ) JPC_QCX_GETMANT ( qcd -> compparms . stepsizes [ i ] ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> JAS_CAST ( unsigned , <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> JAS_CAST ( unsigned , <S2SV_ModEnd> <S2SV_ModStart> ) "
362,"<S2SV_StartBug> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <S2SV_EndBug> ","<S2SV_ModStart> elems , e -> "
363,<S2SV_StartBug> } else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) { <S2SV_EndBug> ,<S2SV_ModStart> && c -> format != CHUNKY 
364,"<S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
365,<S2SV_StartBug> snd_seq_timer_stop ( q -> timer ) ; <S2SV_EndBug> <S2SV_StartBug> snd_seq_timer_close ( q ) ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & q -> timer_mutex ) ; <S2SV_ModStart> ) ; mutex_unlock ( & q -> timer_mutex 
366,"<S2SV_StartBug> u64 start = offset >> PAGE_CACHE_SHIFT ; <S2SV_EndBug> <S2SV_StartBug> u64 end = ( offset + len - 1 ) >> PAGE_CACHE_SHIFT ; <S2SV_EndBug> <S2SV_StartBug> ! ( mode & FALLOC_FL_KEEP_SIZE ) ) { <S2SV_EndBug> <S2SV_StartBug> i_size_write ( inode , offset + to ) ; <S2SV_EndBug> <S2SV_StartBug> mark_inode_dirty ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> return error ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned int nr_blks ; sector_t lblock <S2SV_ModEnd> <S2SV_ModStart> inode -> i_blkbits ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) return error ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } while ( len ) { struct buffer_head bh_map = { . b_state = 0 , . b_blocknr = 0 } ; bh_map . b_size = len ; set_buffer_zeronew ( & bh_map ) ; error = gfs2_block_map ( inode , lblock , & bh_map , 1 ) ; if ( unlikely ( error ) ) goto out ; len -= bh_map . b_size ; nr_blks = bh_map . b_size >> inode -> i_blkbits ; lblock += nr_blks ; if ( ! buffer_new ( & bh_map ) ) continue ; if ( unlikely ( ! buffer_zeronew ( & bh_map ) ) ) { error = - EIO ; goto out ; } } if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> len ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> brelse ( dibh ) ; "
367,<S2SV_StartBug> VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ; <S2SV_EndBug> <S2SV_StartBug> vips_image_pio_input ( load -> real ) ) <S2SV_EndBug> <S2SV_StartBug> return ( NULL ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; if ( load -> error ) return ( NULL <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> { vips_operation_invalidate ( VIPS_OPERATION ( load ) ) ; load -> error = TRUE ; return ( NULL ) ; } <S2SV_ModEnd> 
368,"<S2SV_StartBug> const char * name = fit_get_name ( fit , noffset , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( strchr ( name , '@' ) ) { err_msg = ""Node<S2SV_blank>name<S2SV_blank>contains<S2SV_blank>@"" ; goto error ; } "
369,<S2SV_StartBug> if ( retval ) <S2SV_EndBug> ,<S2SV_ModStart> ! retval ) <S2SV_ModEnd> 
370,"<S2SV_StartBug> if ( kfifo_alloc ( & state -> rx_kfifo , CX23888_IR_RX_KFIFO_SIZE , GFP_KERNEL ) ) <S2SV_EndBug> <S2SV_StartBug> state -> dev = dev ; <S2SV_EndBug> ",<S2SV_ModStart> { kfree ( state ) ; <S2SV_ModStart> } 
371,<S2SV_StartBug> size += service_name_tlv_length ; <S2SV_EndBug> <S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! service_name_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; } 
372,<S2SV_StartBug> struct ssh * ssh = active_state ; <S2SV_EndBug> <S2SV_StartBug> if ( options . compression ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
373,"<S2SV_StartBug> vpx_codec_dec_cfg_t * cfg , <S2SV_EndBug> <S2SV_StartBug> else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) <S2SV_EndBug> <S2SV_StartBug> res = VPX_CODEC_OK ; <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> priv ) <S2SV_EndBug> ",<S2SV_ModStart> const <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
374,<S2SV_StartBug> unsigned int channo ; <S2SV_EndBug> ,<S2SV_ModStart> ; cdef -> ents = 0 
375,<S2SV_StartBug> value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ ; <S2SV_EndBug> ,<S2SV_ModStart> TJA1100_CONFIG1_MII_MODE_RMII_25MHZ_XTAL <S2SV_ModEnd> 
376,"<S2SV_StartBug> if ( ip_options_echo ( & icmp_param . replyopts , skb_in ) ) <S2SV_EndBug> <S2SV_StartBug> ipc . opt = & icmp_param . replyopts ; <S2SV_EndBug> <S2SV_StartBug> room -= sizeof ( struct iphdr ) + icmp_param . replyopts . optlen ; <S2SV_EndBug> ",<S2SV_ModStart> . opt . opt <S2SV_ModStart> . opt <S2SV_ModStart> opt . opt . 
377,"<S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_32BITS <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
378,<S2SV_StartBug> skb_dst_drop ( skb ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( IPCB ( skb ) -> opt . optlen ) ) skb_dst_force ( skb ) ; else 
379,<S2SV_StartBug> crypto_free_skcipher ( private ) ; <S2SV_EndBug> ,<S2SV_ModStart> struct skcipher_tfm * tfm = private ; crypto_free_skcipher ( tfm -> skcipher ) ; kfree ( tfm <S2SV_ModEnd> 
380,<S2SV_StartBug> struct inode * inode = file_inode ( bprm -> file ) ; <S2SV_EndBug> <S2SV_StartBug> bprm -> cred -> euid = current_euid ( ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> bprm_fill_uid ( bprm ) ; <S2SV_ModEnd> 
381,<S2SV_StartBug> return headcount ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( datalen > 0 ) ) { r = UIO_MAXIOV + 1 ; goto err ; } 
382,<S2SV_StartBug> dlen -= 2 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( dlen < 2 ) break ; <S2SV_ModStart>  <S2SV_ModEnd> 
383,"<S2SV_StartBug> rq = blk_mq_tag_to_rq ( tags , off + bit ) ; <S2SV_EndBug> ",<S2SV_ModStart> tags -> rqs [ <S2SV_ModEnd> <S2SV_ModStart> ] <S2SV_ModEnd> 
384,<S2SV_StartBug> else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> priv ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
385,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
386,<S2SV_StartBug> if ( skb_is_nonlinear ( skb ) ) <S2SV_EndBug> ,<S2SV_ModStart> ) ) return 0 ; if ( skb -> len < sizeof ( struct nlattr 
387,"<S2SV_StartBug> encode_share_access ( xdr , arg -> open_flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode <S2SV_ModEnd> 
388,"<S2SV_StartBug> isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len <S2SV_ModStart>  <S2SV_ModEnd> "
389,<S2SV_StartBug> tilebuf = _TIFFmalloc ( tile_buffsize ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( tile_buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size."" ) ; exit ( - 1 ) ; } <S2SV_ModStart> + 3 <S2SV_ModStart> 0 ; tilebuf [ tile_buffsize ] = 0 ; tilebuf [ tile_buffsize + 1 ] = 0 ; tilebuf [ tile_buffsize + 2 ] = "
390,"<S2SV_StartBug> int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <S2SV_EndBug> ",<S2SV_ModStart> | O_NOFOLLOW 
391,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> assert ( error == 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModStart> return error <S2SV_ModEnd> 
392,<S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp && tmp == cluster -> cl_has_local && <S2SV_EndBug> <S2SV_StartBug> return - EBUSY ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp && ! cluster -> cl_has_local ) { <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> <S2SV_StartBug> return count ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { ret = - EINVAL ; goto out ; } <S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto out ; } <S2SV_ModStart> goto out <S2SV_ModEnd> <S2SV_ModStart> ret = count ; out : o2nm_unlock_subsystem ( ) ; return ret <S2SV_ModEnd> 
393,"<S2SV_StartBug> if ( fscanf ( fp , ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%s\\n"" , & n , typestr ) != 2 ) <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%127s\\n"" <S2SV_ModEnd> "
394,<S2SV_StartBug> if ( data [ 1 ] <= 127 ) <S2SV_EndBug> <S2SV_StartBug> else op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ; <S2SV_EndBug> <S2SV_StartBug> op -> fail = addr + op -> size ; <S2SV_EndBug> ,<S2SV_ModStart> len > 1 ) { if ( <S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> } } else { op -> jump = addr ; } 
395,<S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> sock * sk = asoc -> base . sk ; struct <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
396,"<S2SV_StartBug> s = strchr ( token , '?' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
397,<S2SV_StartBug> return - E_NOTHANDLED ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ninst == 0 ) return - E_INVALID 
398,<S2SV_StartBug> ND_TCHECK ( lshp -> ls_type ) ; <S2SV_EndBug> ,<S2SV_ModStart> ls_length <S2SV_ModEnd> 
399,"<S2SV_StartBug> static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val ) <S2SV_EndBug> ",<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> 
400,"<S2SV_StartBug> memcpy ( tim . bitmap , p + ( tim . length - 3 ) , <S2SV_EndBug> <S2SV_StartBug> ( tim . length - 3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> length -= tim . length - 3 ; <S2SV_EndBug> ","<S2SV_ModStart> offset + 3 , <S2SV_ModEnd> <S2SV_ModStart> ; offset += <S2SV_ModEnd> <S2SV_ModStart> ; length -= <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
401,"<S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> 
402,"<S2SV_StartBug> r_buf_set_bytes ( tbuf , buf , sz ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! tbuf ) { return NULL ; } 
403,"<S2SV_StartBug> mm_segment_t old_fs ; <S2SV_EndBug> <S2SV_StartBug> ret = sys_wait4 ( pid , ustatus , options , ( struct rusage __user * ) & r ) ; <S2SV_EndBug> <S2SV_StartBug> err |= __put_user ( r . ru_utime . tv_sec , & ur -> ru_utime . tv_sec ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned int status = 0 ; <S2SV_ModStart> ( unsigned int __user * ) & status <S2SV_ModEnd> <S2SV_ModStart> put_user ( status , ustatus ) ; err |= "
404,"<S2SV_StartBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys/net"" , ""%r/proc/net"" , NULL , MS_BIND , NULL } , <S2SV_EndBug> <S2SV_StartBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/net"" , ""%r/proc/sys/net"" , NULL , MS_MOVE , NULL } , <S2SV_EndBug> <S2SV_StartBug> r = mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%r/proc/tty"" <S2SV_ModEnd> <S2SV_ModStart> ""%r/proc/tty"" <S2SV_ModEnd> <S2SV_ModStart> safe_mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options , conf -> rootfs . path ? conf -> rootfs . mount : NULL <S2SV_ModEnd> "
405,<S2SV_StartBug> ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; <S2SV_EndBug> <S2SV_StartBug> libreswan_log ( <S2SV_EndBug> <S2SV_StartBug> return v2N_INVALID_KE_PAYLOAD ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! md -> chain [ ISAKMP_NEXT_v2KE ] ) { if ( md -> chain [ ISAKMP_NEXT_v2N ] ) { libreswan_log ( ""Received<S2SV_blank>Notify(%d):<S2SV_blank>%s"" , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type , enum_name ( & ikev2_notify_names , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type ) ) ; } libreswan_log ( ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>no<S2SV_blank>KE<S2SV_blank>payload<S2SV_blank>present"" , fromname , md -> sender_port ) ; return STF_FAIL + v2N_INVALID_KE_PAYLOAD ; } ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { libreswan_log ( <S2SV_ModEnd> <S2SV_ModStart> STF_FAIL + "
406,"<S2SV_StartBug> void nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride ) <S2SV_EndBug> <S2SV_StartBug> nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ; <S2SV_EndBug> <S2SV_StartBug> nsc_encode_subsampling ( context ) ; <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> if ( ! context || ! bmpdata || ( rowstride == 0 ) ) return FALSE ; if ( ! <S2SV_ModStart> ) return FALSE <S2SV_ModStart> if ( ! <S2SV_ModStart> ) return FALSE ; } return TRUE ; <S2SV_ModEnd> 
407,"<S2SV_StartBug> void vp9_tree_probs_from_distribution ( vp9_tree tree , <S2SV_EndBug> ",<S2SV_ModStart> vpx_tree <S2SV_ModEnd> 
408,<S2SV_StartBug> if ( stringset == ETH_SS_STATS ) <S2SV_EndBug> ,<S2SV_ModStart> || stringset == ETH_SS_PRIV_FLAGS 
409,<S2SV_StartBug> return ( ( image -> columns + 7 ) / 8 ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) * GetPSDPacketSize ( image ) 
410,"<S2SV_StartBug> p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> <S2SV_StartBug> p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
411,<S2SV_StartBug> alt = pcu -> ctrl_intf -> cur_altsetting ; <S2SV_EndBug> <S2SV_StartBug> alt = pcu -> data_intf -> cur_altsetting ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! pcu -> ctrl_intf ) return - EINVAL ; <S2SV_ModStart> if ( ! pcu -> data_intf ) return - EINVAL ; 
412,"<S2SV_StartBug> const char * name = d -> name ; <S2SV_EndBug> <S2SV_StartBug> struct device dev = d -> udev -> dev ; <S2SV_EndBug> <S2SV_StartBug> dev_info ( & dev , ""%s:<S2SV_blank>\'%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n"" , <S2SV_EndBug> <S2SV_StartBug> KBUILD_MODNAME , name ) ; <S2SV_EndBug> ","<S2SV_ModStart> devname = kstrdup ( dev_name ( & <S2SV_ModEnd> <S2SV_ModStart> ) , GFP_KERNEL ) ; const char * drvname = d -> name <S2SV_ModStart> pr_info ( ""%s:<S2SV_blank>\'%s:%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n"" <S2SV_ModEnd> <S2SV_ModStart> drvname , devname ) ; kfree ( devname <S2SV_ModEnd> "
413,<S2SV_StartBug> xstep = picomp -> hsamp * ( 1 << <S2SV_EndBug> <S2SV_StartBug> ystep = picomp -> vsamp * ( 1 << <S2SV_EndBug> <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || <S2SV_EndBug> <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || <S2SV_EndBug> ,"<S2SV_ModStart> if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> "
414,"<S2SV_StartBug> r = conv_encoding ( ci -> pattern_enc , ci -> target_enc , pattern , pattern_end , <S2SV_EndBug> ",<S2SV_ModStart> return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION <S2SV_ModEnd> 
415,"<S2SV_StartBug> static void InsertRow ( Image * image , ssize_t depth , unsigned char * p , ssize_t y , <S2SV_EndBug> <S2SV_StartBug> size_t bit ; ssize_t x ; <S2SV_EndBug> <S2SV_StartBug> register Quantum * q ; <S2SV_EndBug> <S2SV_StartBug> switch ( depth ) <S2SV_EndBug> <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ; <S2SV_EndBug> <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) <S2SV_EndBug> <S2SV_StartBug> index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ; <S2SV_EndBug> <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) SyncAuthenticPixels ( image , exception ) ; <S2SV_EndBug> <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> if ( q == ( Quantum * ) NULL ) <S2SV_EndBug> <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ; <S2SV_EndBug> <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> p ++ ; <S2SV_EndBug> <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> if ( q == ( Quantum * ) NULL ) <S2SV_EndBug> <S2SV_StartBug> index = ConstrainColormapIndex ( image , * p , exception ) ; <S2SV_EndBug> ","<S2SV_ModStart> MagickBooleanType <S2SV_ModEnd> <S2SV_ModStart> bpp <S2SV_ModEnd> <S2SV_ModStart> int bit ; Quantum index <S2SV_ModEnd> <S2SV_ModStart> * q ; ssize_t x ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) return ( MagickFalse ) <S2SV_ModEnd> <S2SV_ModStart> bpp <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> ssize_t ) ( <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> for ( x = 0 ; x < ( ( ssize_t ) <S2SV_ModEnd> <S2SV_ModStart> - 3 ) ; x += 4 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 <S2SV_ModEnd> <S2SV_ModStart> SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } break ; } case 4 : { <S2SV_ModEnd> <S2SV_ModStart> 4 ) & 0x0f <S2SV_ModEnd> <S2SV_ModStart> if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> ) & 0x0f <S2SV_ModEnd> <S2SV_ModStart> if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 0x0f <S2SV_ModEnd> <S2SV_ModStart> if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; <S2SV_ModStart> } <S2SV_ModEnd> <S2SV_ModStart> for ( x = 0 ; x < ( ssize_t ) <S2SV_ModEnd> <S2SV_ModStart> ; x ++ ) { index = ConstrainColormapIndex ( image , * p <S2SV_ModEnd> <S2SV_ModStart> SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } } break ; case 24 : <S2SV_ModEnd> <S2SV_ModStart> SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } if ( ! SyncAuthenticPixels ( image <S2SV_ModEnd> <S2SV_ModStart> ) return ( MagickFalse ) ; return ( MagickTrue ) ; <S2SV_ModEnd> "
416,"<S2SV_StartBug> register const u_char * tptr ) <S2SV_EndBug> <S2SV_StartBug> u_int hexdump = FALSE ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> , const u_int length ) { u_int network_addr_type ; u_int <S2SV_ModEnd> <S2SV_ModStart> if ( length < 1 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Network<S2SV_blank>Address<S2SV_blank>Type<S2SV_blank>(invalid,<S2SV_blank>no<S2SV_blank>data"" ) ) ; return hexdump ; } <S2SV_ModStart> if ( length != 1 + 4 ) { ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> if ( length != 1 + 16 ) { ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ; hexdump = TRUE ; break ; } "
417,"<S2SV_StartBug> u64 msr_data ; <S2SV_EndBug> <S2SV_StartBug> cs . dpl = 3 ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> ctxt -> _eip = reg_read ( ctxt , VCPU_REGS_RDX ) ; <S2SV_EndBug> <S2SV_StartBug> * reg_write ( ctxt , VCPU_REGS_RSP ) = reg_read ( ctxt , VCPU_REGS_RCX ) ; <S2SV_EndBug> ","<S2SV_ModStart> , rcx , rdx <S2SV_ModStart> rcx = reg_read ( ctxt , VCPU_REGS_RCX ) ; rdx = reg_read ( ctxt , VCPU_REGS_RDX ) ; <S2SV_ModStart> if ( is_noncanonical_address ( rcx ) || is_noncanonical_address ( rdx ) ) return emulate_gp ( ctxt , 0 ) ; <S2SV_ModStart> rdx <S2SV_ModEnd> <S2SV_ModStart> rcx <S2SV_ModEnd> "
418,"<S2SV_StartBug> return sprintf ( buf , ""%s\\n"" , pdev -> driver_override ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> ssize_t len ; device_lock ( dev ) ; len = <S2SV_ModEnd> <S2SV_ModStart> device_unlock ( dev ) ; return len ; 
419,<S2SV_StartBug> BIO * tmpout = NULL ; <S2SV_EndBug> <S2SV_StartBug> tmpout = BIO_new ( BIO_s_mem ( ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ; tmpout = cms_get_text_bio ( out , flags ) ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ; goto err ; } for ( ; ; ) { i = BIO_read ( in , buf , sizeof ( buf ) ) ; if ( i <= 0 ) { if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) { if ( ! BIO_get_cipher_status ( in ) ) goto err ; } if ( i < 0 ) goto err ; break ; } if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
420,"<S2SV_StartBug> rs . respond ( rs . arg , retval , NULL , NULL , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( retval == 0 ) rs . enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ; 
421,"<S2SV_StartBug> static void cost ( int * costs , vp9_tree tree , const vp9_prob * probs , <S2SV_EndBug> <S2SV_StartBug> const vp9_prob prob = probs [ i / 2 ] ; <S2SV_EndBug> <S2SV_StartBug> const vp9_tree_index ii = tree [ i + b ] ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_tree <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_index <S2SV_ModEnd> 
422,<S2SV_StartBug> create_option_search_table ( ) ; <S2SV_EndBug> ,"<S2SV_ModStart> # ifdef HAVE_MKDTEMP tmp_dir = mkdtemp ( Strnew_m_charp ( tmp_dir , ""/w3m-XXXXXX"" , NULL ) -> ptr ) ; if ( tmp_dir == NULL ) tmp_dir = rc_dir ; # endif "
423,"<S2SV_StartBug> switch ( af ) { <S2SV_EndBug> <S2SV_StartBug> strncpy ( addr_text , <S2SV_EndBug> <S2SV_StartBug> ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , <S2SV_EndBug> ","<S2SV_ModStart> size_t pathlen = 0 ; <S2SV_ModStart> pathlen = sizeof ( <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( MAXPATHLEN <= pathlen ) { pathlen = MAXPATHLEN - 1 ; } strncpy ( addr_text , ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , pathlen ) ; addr_text [ pathlen <S2SV_ModEnd> "
424,"<S2SV_StartBug> static INLINE void write_buffer_16x16 ( int16_t * output , __m128i * in0 , <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> 
425,"<S2SV_StartBug> err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf , p + 4 , c , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> + p <S2SV_ModEnd> 
426,"<S2SV_StartBug> struct hstate * h = hstate_vma ( vma ) ; <S2SV_EndBug> <S2SV_StartBug> struct page * page ; <S2SV_EndBug> <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug> <S2SV_StartBug> set_page_private ( page , ( unsigned long ) mapping ) ; <S2SV_EndBug> ",<S2SV_ModStart> hugepage_subpool * spool = subpool_vma ( vma ) ; struct <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> hugepage_subpool_get_pages ( spool <S2SV_ModEnd> <S2SV_ModStart> hugepage_subpool_put_pages ( spool <S2SV_ModEnd> <S2SV_ModStart> spool <S2SV_ModEnd> 
427,"<S2SV_StartBug> DPRINTF ( 4 , ( ""enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\'%s%s\'\\n"" , <S2SV_EndBug> <S2SV_StartBug> filegen_flag = filegen -> flag ; <S2SV_EndBug> ","<S2SV_ModStart> if ( NULL == filegen ) { msyslog ( LOG_ERR , ""stats<S2SV_blank>%s<S2SV_blank>unrecognized"" , filegen_string ) ; continue ; } <S2SV_ModStart> if ( NULL == filegen ) { msyslog ( LOG_ERR , ""filegen<S2SV_blank>category<S2SV_blank>\'%s\'<S2SV_blank>unrecognized"" , filegen_file ) ; continue ; } "
428,"<S2SV_StartBug> touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> MODE_INVALID <S2SV_ModEnd> 
429,"<S2SV_StartBug> static void fadst16 ( const int16_t * input , int16_t * output ) { <S2SV_EndBug> <S2SV_StartBug> int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8 , s9 , s10 , s11 , s12 , s13 , s14 , s15 ; <S2SV_EndBug> <S2SV_StartBug> int x0 = input [ 15 ] ; <S2SV_EndBug> <S2SV_StartBug> int x1 = input [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> int x2 = input [ 13 ] ; <S2SV_EndBug> <S2SV_StartBug> int x3 = input [ 2 ] ; <S2SV_EndBug> <S2SV_StartBug> int x4 = input [ 11 ] ; <S2SV_EndBug> <S2SV_StartBug> int x5 = input [ 4 ] ; <S2SV_EndBug> <S2SV_StartBug> int x6 = input [ 9 ] ; <S2SV_EndBug> <S2SV_StartBug> int x7 = input [ 6 ] ; <S2SV_EndBug> <S2SV_StartBug> int x8 = input [ 7 ] ; <S2SV_EndBug> <S2SV_StartBug> int x9 = input [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int x10 = input [ 5 ] ; <S2SV_EndBug> <S2SV_StartBug> int x11 = input [ 10 ] ; <S2SV_EndBug> <S2SV_StartBug> int x12 = input [ 3 ] ; <S2SV_EndBug> <S2SV_StartBug> int x13 = input [ 12 ] ; <S2SV_EndBug> <S2SV_StartBug> int x14 = input [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> int x15 = input [ 14 ] ; <S2SV_EndBug> <S2SV_StartBug> output [ 0 ] = x0 ; <S2SV_EndBug> <S2SV_StartBug> output [ 1 ] = - x8 ; <S2SV_EndBug> <S2SV_StartBug> output [ 2 ] = x12 ; <S2SV_EndBug> <S2SV_StartBug> output [ 3 ] = - x4 ; <S2SV_EndBug> <S2SV_StartBug> output [ 4 ] = x6 ; <S2SV_EndBug> <S2SV_StartBug> output [ 5 ] = x14 ; <S2SV_EndBug> <S2SV_StartBug> output [ 6 ] = x10 ; <S2SV_EndBug> <S2SV_StartBug> output [ 7 ] = x2 ; <S2SV_EndBug> <S2SV_StartBug> output [ 8 ] = x3 ; <S2SV_EndBug> <S2SV_StartBug> output [ 9 ] = x11 ; <S2SV_EndBug> <S2SV_StartBug> output [ 10 ] = x15 ; <S2SV_EndBug> <S2SV_StartBug> output [ 11 ] = x7 ; <S2SV_EndBug> <S2SV_StartBug> output [ 12 ] = x5 ; <S2SV_EndBug> <S2SV_StartBug> output [ 13 ] = - x13 ; <S2SV_EndBug> <S2SV_StartBug> output [ 14 ] = x9 ; <S2SV_EndBug> <S2SV_StartBug> output [ 15 ] = - x1 ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> ; tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) 
430,<S2SV_StartBug> # if HAVE_EDSP <S2SV_EndBug> <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> || HAVE_NEON_ASM 
431,"<S2SV_StartBug> MB_PREDICTION_MODE vp9_left_block_mode ( const MODE_INFO * cur_mi , <S2SV_EndBug> ",<S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> 
432,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> horAcc16 ( tif , cp0 , cc ) ; <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return 
433,<S2SV_StartBug> opt2 -> tot_len = tot_len ; <S2SV_EndBug> ,"<S2SV_ModStart> atomic_set ( & opt2 -> refcnt , 1 ) ; "
434,<S2SV_StartBug> for ( i = 0 ; i < st -> duration ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } 
435,<S2SV_StartBug> dp == datalen ) { <S2SV_EndBug> ,<S2SV_ModStart> ( op & ASN1_OP_MATCH__SKIP && <S2SV_ModStart> ) 
436,"<S2SV_StartBug> char * fpath = NULL , * cgdir = NULL , * controller ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""rmdir:<S2SV_blank>verifying<S2SV_blank>access<S2SV_blank>to<S2SV_blank>%s:%s<S2SV_blank>(req<S2SV_blank>path<S2SV_blank>%s)\\n"" , <S2SV_EndBug> <S2SV_StartBug> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! cgfs_remove ( controller , cgroup ) ) { <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> , * next = NULL <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> & next ) ) { if ( ! fpath || strcmp ( next , fpath ) == 0 ) ret = - EBUSY ; else ret = - ENOENT ; goto out ; } if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY <S2SV_ModEnd> <S2SV_ModStart> caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { ret = - EACCES ; goto out ; } if ( ! <S2SV_ModStart> free ( next ) ; "
437,<S2SV_StartBug> if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { mnt -> mnt . mnt_flags |= MNT_LOCK_ATIME ; if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mnt -> mnt . mnt_flags & MNT_NODEV ) mnt -> mnt . mnt_flags |= MNT_LOCK_NODEV ; if ( mnt -> mnt . mnt_flags & MNT_NOSUID ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOSUID ; if ( mnt -> mnt . mnt_flags & MNT_NOEXEC ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOEXEC ; } if ( 
438,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
439,<S2SV_StartBug> if ( * rsize >= 107 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 && <S2SV_EndBug> ,<S2SV_ModStart> 112 <S2SV_ModEnd> 
440,<S2SV_StartBug> if ( ( tot_len - offset - 4 ) < bodyLength ) { <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) ) 
441,<S2SV_StartBug> if ( likely ( port -> exists && ! filtered ) ) <S2SV_EndBug> ,<S2SV_ModStart> serio <S2SV_ModEnd> 
442,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> { ND_TCHECK ( <S2SV_ModEnd> <S2SV_ModStart> ; ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } <S2SV_ModEnd> "
443,"<S2SV_StartBug> static int udf_translate_to_linux ( uint8_t * newName , uint8_t * udfName , <S2SV_EndBug> <S2SV_StartBug> int udfLen , uint8_t * fidName , <S2SV_EndBug> <S2SV_StartBug> if ( newIndex < 256 ) <S2SV_EndBug> <S2SV_StartBug> maxFilenameLen = 250 - localExtIndex ; <S2SV_EndBug> <S2SV_StartBug> } else if ( newIndex > 250 ) <S2SV_EndBug> ","<S2SV_ModStart> int newLen , <S2SV_ModStart> int udfLen , <S2SV_ModEnd> <S2SV_ModStart> newLen <S2SV_ModEnd> <S2SV_ModStart> newLen - CRC_LEN <S2SV_ModEnd> <S2SV_ModStart> newLen - CRC_LEN ) newIndex = newLen - CRC_LEN <S2SV_ModEnd> "
444,"<S2SV_StartBug> static void count_segs_sb ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 , <S2SV_EndBug> <S2SV_StartBug> const VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> bw = num_8x8_blocks_wide_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ; <S2SV_EndBug> <S2SV_StartBug> bh = num_8x8_blocks_high_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ; <S2SV_EndBug> <S2SV_StartBug> count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count , <S2SV_EndBug> <S2SV_StartBug> count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count , <S2SV_EndBug> <S2SV_StartBug> count_segs ( cpi , tile , mi_8x8 + hbs * mis , no_pred_segcounts , <S2SV_EndBug> <S2SV_StartBug> count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count , <S2SV_EndBug> <S2SV_StartBug> count_segs ( cpi , tile , mi_8x8 + hbs , <S2SV_EndBug> <S2SV_StartBug> count_segs_sb ( cpi , tile , & mi_8x8 [ mi_dr * mis + mi_dc ] , <S2SV_EndBug> ","<S2SV_ModStart> const VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_ModEnd> <S2SV_ModStart> tile , <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> cm , xd , tile , mi <S2SV_ModEnd> <S2SV_ModStart> cm , xd , tile , mi <S2SV_ModEnd> <S2SV_ModStart> cm , xd , tile , mi <S2SV_ModEnd> <S2SV_ModStart> cm , xd , tile , mi <S2SV_ModEnd> <S2SV_ModStart> cm , xd , tile , mi <S2SV_ModEnd> <S2SV_ModStart> cm , xd <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> "
445,<S2SV_StartBug> if ( c -> flags & CLIENT_CLOSE_AFTER_REPLY ) break ; <S2SV_EndBug> ,<S2SV_ModStart> ( CLIENT_CLOSE_AFTER_REPLY | CLIENT_CLOSE_ASAP ) <S2SV_ModEnd> 
446,<S2SV_StartBug> get_blocks_flags = EXT4_GET_BLOCKS_CREATE ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ext4_should_dioread_nolock ( mpd -> inode ) ) get_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT 
447,"<S2SV_StartBug> int ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( d2i_DSA_SIG ( & s , & sigbuf , siglen ) == NULL ) goto err ; <S2SV_EndBug> <S2SV_StartBug> DSA_SIG_free ( s ) ; <S2SV_EndBug> ","<S2SV_ModStart> const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> p <S2SV_ModEnd> <S2SV_ModStart> goto err ; derlen = i2d_DSA_SIG ( s , & der ) ; if ( derlen != siglen || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; } "
448,"<S2SV_StartBug> gdImageGifCtx ( im , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! _gdImageGifCtx <S2SV_ModEnd> <S2SV_ModStart> ) { <S2SV_ModEnd> <S2SV_ModStart> } else { rv = NULL ; } 
449,<S2SV_StartBug> kfree ( bprm ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( bprm -> interp != bprm -> filename ) kfree ( bprm -> interp ) ; 
450,"<S2SV_StartBug> size_t canonnamelen = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( p = oe_calloc ( 1 , sizeof ( struct oe_addrinfo ) ) ) ) <S2SV_EndBug> <S2SV_StartBug> & p -> ai_flags , <S2SV_EndBug> <S2SV_StartBug> & p -> ai_family , <S2SV_EndBug> <S2SV_StartBug> & p -> ai_socktype , <S2SV_EndBug> <S2SV_StartBug> & p -> ai_protocol , <S2SV_EndBug> <S2SV_StartBug> & p -> ai_addrlen , <S2SV_EndBug> <S2SV_StartBug> canonnamelen , <S2SV_EndBug> <S2SV_StartBug> if ( p -> ai_addrlen && ! ( p -> ai_addr = oe_calloc ( 1 , p -> ai_addrlen ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( canonnamelen && ! ( p -> ai_canonname = oe_calloc ( 1 , canonnamelen ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( oe_syscall_getaddrinfo_read_ocall ( <S2SV_EndBug> <S2SV_StartBug> p -> ai_addrlen , <S2SV_EndBug> <S2SV_StartBug> canonnamelen , <S2SV_EndBug> <S2SV_StartBug> if ( tail ) <S2SV_EndBug> ","<S2SV_ModStart> canonnamelen_in <S2SV_ModEnd> <S2SV_ModStart> size_t canonnamelen_out = 0 ; struct oe_addrinfo p_out ; memset ( & p_out , 0 , sizeof ( struct oe_addrinfo ) ) ; <S2SV_ModEnd> <S2SV_ModStart> p_out . <S2SV_ModEnd> <S2SV_ModStart> p_out . <S2SV_ModEnd> <S2SV_ModStart> p_out . <S2SV_ModEnd> <S2SV_ModStart> p_out . ai_protocol , p_out . <S2SV_ModEnd> <S2SV_ModStart> p_out . <S2SV_ModEnd> <S2SV_ModStart> canonnamelen_in , & canonnamelen_out <S2SV_ModEnd> <S2SV_ModStart> switch ( p_out . ai_family ) { case OE_AF_INET : if ( p_out . ai_addrlen != sizeof ( struct oe_sockaddr ) ) { ret = OE_EAI_FAIL ; goto done ; } break ; case OE_AF_INET6 : case OE_AF_INET6_WIN : case OE_AF_UNSPEC : if ( p_out . ai_addrlen != sizeof ( struct oe_sockaddr_in6 ) ) { ret = OE_EAI_FAIL ; goto done ; } break ; default : ret = OE_EAI_FAIL ; goto done ; } if ( ! ( p = oe_calloc ( 1 , sizeof ( struct oe_addrinfo ) ) ) ) { ret = OE_EAI_MEMORY ; goto done ; } if ( p_out . <S2SV_ModEnd> <S2SV_ModStart> p_out . <S2SV_ModEnd> <S2SV_ModStart> canonnamelen_out <S2SV_ModEnd> <S2SV_ModStart> canonnamelen_out <S2SV_ModEnd> <S2SV_ModStart> canonnamelen_in = canonnamelen_out ; <S2SV_ModStart> p_out . <S2SV_ModEnd> <S2SV_ModStart> canonnamelen_in , & canonnamelen_out <S2SV_ModEnd> <S2SV_ModStart> ( p -> ai_flags != p_out . ai_flags ) || ( p -> ai_family != p_out . ai_family ) || ( p -> ai_socktype != p_out . ai_socktype ) || ( p -> ai_protocol != p_out . ai_protocol ) || ( p -> ai_addrlen != p_out . ai_addrlen ) || ( canonnamelen_out != canonnamelen_in ) || ( canonnamelen_out && p -> ai_canonname [ canonnamelen_out - 1 ] != '\\0' ) ) { ret = OE_EAI_FAIL ; goto done ; } if ( tail ) { tail -> ai_next = p ; tail = p ; } else { head = p ; tail = p ; } p = NULL ; } if ( handle ) { int retval = - 1 <S2SV_ModEnd> "
451,"<S2SV_StartBug> separator = strchr ( token , ':' ) ; <S2SV_EndBug> <S2SV_StartBug> separator = strchr ( token , '=' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> 
452,<S2SV_StartBug> rctx -> image_height = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 6 ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( rctx -> image_width < 1 || rctx -> image_height < 1 ) { iw_set_error ( rctx -> ctx , ""Invalid<S2SV_blank>image<S2SV_blank>dimensions"" ) ; goto done ; } "
453,"<S2SV_StartBug> vpx_memcpy ( pc -> fc . coef_probs , default_coef_probs , <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> 
454,"<S2SV_StartBug> static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data ) <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> indx , data , size , 100 ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> const <S2SV_ModStart> u8 * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> kfree ( buf ) ; "
455,"<S2SV_StartBug> Module ( asdl_seq * body , PyArena * arena ) <S2SV_EndBug> <S2SV_StartBug> return p ; <S2SV_EndBug> ","<S2SV_ModStart> , asdl_seq * type_ignores <S2SV_ModStart> p -> v . Module . type_ignores = type_ignores ; "
456,"<S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_DESTRUCT ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
457,"<S2SV_StartBug> int64_t ts_start , int64_t ts_end , unsigned int flags ) { <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> # if USE_PARTIAL_COPY <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> max_sz == 1 && active_map && ! flags ) { <S2SV_EndBug> <S2SV_StartBug> vp9_copy_and_extend_frame ( src , & buf -> img ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif <S2SV_ModStart> int width = src -> y_crop_width ; int height = src -> y_crop_height ; int uv_width = src -> uv_crop_width ; int uv_height = src -> uv_crop_height ; int subsampling_x = src -> subsampling_x ; int subsampling_y = src -> subsampling_y ; int larger_dimensions , new_dimensions ; <S2SV_ModStart> new_dimensions = width != buf -> img . y_crop_width || height != buf -> img . y_crop_height || uv_width != buf -> img . uv_crop_width || uv_height != buf -> img . uv_crop_height ; larger_dimensions = width > buf -> img . y_width || height > buf -> img . y_height || uv_width > buf -> img . uv_width || uv_height > buf -> img . uv_height ; assert ( ! larger_dimensions || new_dimensions ) ; <S2SV_ModStart> ! new_dimensions && <S2SV_ModStart> # endif if ( larger_dimensions ) { YV12_BUFFER_CONFIG new_img ; memset ( & new_img , 0 , sizeof ( new_img ) ) ; if ( vpx_alloc_frame_buffer ( & new_img , width , height , subsampling_x , subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , 0 ) ) return 1 ; vpx_free_frame_buffer ( & buf -> img ) ; buf -> img = new_img ; } else if ( new_dimensions ) { buf -> img . y_crop_width = src -> y_crop_width ; buf -> img . y_crop_height = src -> y_crop_height ; buf -> img . uv_crop_width = src -> uv_crop_width ; buf -> img . uv_crop_height = src -> uv_crop_height ; buf -> img . subsampling_x = src -> subsampling_x ; buf -> img . subsampling_y = src -> subsampling_y ; } <S2SV_ModStart> # if USE_PARTIAL_COPY } <S2SV_ModEnd> "
458,"<S2SV_StartBug> rc = fuse_dev_release ( inode , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> fuse_conn_put ( & cc -> fc ) ; 
459,<S2SV_StartBug> return code ; <S2SV_EndBug> ,"<S2SV_ModStart> { * status = ""DECODE_PA_S4U_X509_USER"" ; return code ; } <S2SV_ModEnd> "
460,"<S2SV_StartBug> static int scsi_disk_emulate_command ( SCSIDiskReq * r , uint8_t * outbuf ) <S2SV_EndBug> ","<S2SV_ModStart> ) { SCSIRequest * req = & r -> req ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; uint64_t nb_sectors ; <S2SV_ModEnd> <S2SV_ModStart> ; int buflen = 0 ; if ( ! r -> iov . iov_base ) { if ( req -> cmd . xfer > 65536 ) { goto illegal_request ; } r -> buflen = MAX ( 4096 , req -> cmd . xfer ) ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } outbuf = r -> iov . iov_base <S2SV_ModEnd> "
461,<S2SV_StartBug> s -> cur_pic . field_picture || <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
462,<S2SV_StartBug> if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) { <S2SV_EndBug> <S2SV_StartBug> return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ; <S2SV_EndBug> <S2SV_StartBug> return sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; <S2SV_EndBug> ,"<S2SV_ModStart> struct scatterlist * sgp = & rm -> data . op_sg [ sg ] ; int ret = sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; <S2SV_ModStart> ret = min_t ( int , ret , sgp -> length - conn -> c_xmit_data_off ) ; goto out <S2SV_ModEnd> <S2SV_ModStart> out : return ret <S2SV_ModEnd> "
463,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> { return 0 ; } <S2SV_ModEnd> 
464,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ret = key_read_state ( key ) ; if ( ret < 0 ) goto error2 ; <S2SV_ModEnd> 
465,"<S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bp [ hlen ] & 0xf0 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""K"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mh -> ip6m_data8 [ 1 ] & 0x80 ) <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 16 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( mh -> ip6m_data8 [ 1 ] <S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> <S2SV_ModStart> bp [ hlen ] , <S2SV_ModEnd> "
466,<S2SV_StartBug> dev -> netdev_ops = & ieee80211_dataif_ops ; <S2SV_EndBug> ,<S2SV_ModStart> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> 
467,"<S2SV_StartBug> uint16_t hmi_bpm = 0 ; <S2SV_EndBug> <S2SV_StartBug> } * note ; <S2SV_EndBug> <S2SV_StartBug> if ( hmi_data [ 0 ] == 0xfe ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( hmi_data [ 1 ] == 0x15 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , hmi_running_event [ i ] ) ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> note [ hmi_tmp ] . length = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( * hmi_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> } while ( * hmi_data > 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> hmi_data ++ ; <S2SV_EndBug> ","<S2SV_ModStart> uint32_t data_siz ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> hmi_track_offset [ i ] >= hmi_size ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } data_siz = hmi_size - hmi_track_offset [ i ] ; if ( <S2SV_ModStart> hmi_tmp += 4 ; <S2SV_ModStart> hmi_tmp = 8 ; } else { hmi_tmp = 4 ; } hmi_data <S2SV_ModEnd> <S2SV_ModStart> hmi_track_offset [ i ] += 4 ; if ( hmi_tmp > data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } data_siz -= hmi_tmp ; <S2SV_ModStart> , data_siz <S2SV_ModStart> data_siz -= setup_ret ; <S2SV_ModStart> data_siz && <S2SV_ModStart> if ( ! data_siz ) break ; <S2SV_ModStart> data_siz -- ; <S2SV_ModStart> ; } if ( ! data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end <S2SV_ModStart> data_siz -- ; <S2SV_ModStart> data_siz -= setup_ret ; } } if ( data_siz && <S2SV_ModEnd> <S2SV_ModStart> if ( ! data_siz ) break ; <S2SV_ModStart> data_siz -- ; <S2SV_ModStart> if ( ! data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } <S2SV_ModStart> ; data_siz -- "
468,<S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> haddr -> hci_channel = 0 ; 
469,<S2SV_StartBug> fh32 [ 2 ] = inode -> i_generation ; <S2SV_EndBug> ,<S2SV_ModStart> fh16 [ 3 ] = 0 ; 
470,"<S2SV_StartBug> if ( check_anon ( kdc_active_realm , request -> client , request -> server ) != 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> client . princ <S2SV_ModEnd> 
471,<S2SV_StartBug> if ( dst_reg -> smin_value < 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
472,"<S2SV_StartBug> if ( method == LPF_PICK_FROM_Q ) { <S2SV_EndBug> <S2SV_StartBug> const int q = vp9_ac_quant ( cm -> base_qindex , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> int filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ; <S2SV_EndBug> <S2SV_StartBug> search_filter_level ( sd , cpi , method == LPF_PICK_FROM_SUBIMAGE ) ; <S2SV_EndBug> ","<S2SV_ModStart> LPF_PICK_MINIMAL_LPF && lf -> filter_level ) { lf -> filter_level = 0 ; } else if ( method >= <S2SV_ModStart> , cm -> bit_depth ) ; # if CONFIG_VP9_HIGHBITDEPTH int filt_guess ; switch ( cm -> bit_depth ) { case VPX_BITS_8 : <S2SV_ModEnd> <S2SV_ModStart> break ; case VPX_BITS_10 : filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 4060632 , 20 ) ; break ; case VPX_BITS_12 : filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 16242526 , 22 ) ; break ; default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>"" ""or<S2SV_blank>VPX_BITS_12"" ) ; return ; } # else int filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ; # endif <S2SV_ModStart> lf -> filter_level = "
473,<S2SV_StartBug> usleep ( 100000 ) ; <S2SV_EndBug> ,<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
474,<S2SV_StartBug> quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; canvas_image = DestroyImage ( canvas_image 
475,"<S2SV_StartBug> int a = getnum ( fmt , MAXALIGN ) ; <S2SV_EndBug> ","<S2SV_ModStart> L , "
476,<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> ,<S2SV_ModStart> void 
477,"<S2SV_StartBug> if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> ",<S2SV_ModStart> 3 == <S2SV_ModStart> && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> 
478,<S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
479,"<S2SV_StartBug> long rem ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> ",<S2SV_ModStart> u32 <S2SV_ModEnd> <S2SV_ModStart> div_u64_rem <S2SV_ModEnd> 
480,"<S2SV_StartBug> if ( ! ctx || ( ! data && data_sz ) ) <S2SV_EndBug> <S2SV_StartBug> res = ctx -> iface -> dec . decode ( ctx -> priv -> alg_priv , data , data_sz , <S2SV_EndBug> ",<S2SV_ModStart> || ( data && ! data_sz ) <S2SV_ModStart> get_alg_priv ( ctx ) <S2SV_ModEnd> 
481,"<S2SV_StartBug> if ( value [ strlen ( value ) - 1 ] == ',' ) { <S2SV_EndBug> ",<S2SV_ModStart> * value == 0 || 
482,"<S2SV_StartBug> static int isofs_read_inode ( struct inode * inode ) <S2SV_EndBug> <S2SV_StartBug> parse_rock_ridge_inode ( de , inode ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int relocated <S2SV_ModStart> , relocated "
483,"<S2SV_StartBug> COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! COM_CompareExtension ( filename , "".txt"" ) ) { Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".txt\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" ) ; return ; } "
484,"<S2SV_StartBug> if ( netal == 0 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s"" , etheraddr_string ( ndo , snpa ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> snpal == 6 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , snpal , etheraddr_string ( ndo , snpa ) ) ) ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , snpal , linkaddr_string ( ndo , snpa , LINKADDR_OTHER , snpal ) ) ) ; if ( netal != <S2SV_ModEnd> <S2SV_ModStart> ""\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u)<S2SV_blank>%s"" , netal , <S2SV_ModEnd> "
485,"<S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>K"" , c , m , y , k ) ; <S2SV_EndBug> <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>k"" , c , m , y , k ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sendClean ( outputbuffer ) ; 
486,<S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> return false ; } } else if ( r -> CRn == 0 && r -> CRm == 9 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; <S2SV_ModEnd> <S2SV_ModStart> return false <S2SV_ModEnd> 
487,<S2SV_StartBug> convert_to_double_ex ( zval_affine_elem ) ; <S2SV_EndBug> <S2SV_StartBug> affine [ i ] = Z_DVAL_PP ( zval_affine_elem ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . x = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . y = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . width = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . height = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> ,<S2SV_ModStart> { zval dval ; dval = * * zval_affine_elem ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> <S2SV_ModStart> Z_DVAL ( dval ) ; } <S2SV_ModEnd> <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . x = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . y = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . width = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . height = <S2SV_ModStart> } 
488,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> PyObject_GC_UnTrack ( self ) ; 
489,<S2SV_StartBug> free ( szSepLine ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
490,"<S2SV_StartBug> r = copy_from_user ( data , ( void __user * ) addr + offset , len ) ; <S2SV_EndBug> ",<S2SV_ModStart> __copy_from_user <S2SV_ModEnd> 
491,"<S2SV_StartBug> char * p , * q , * r ; <S2SV_EndBug> <S2SV_StartBug> printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\n<S2SV_blank>This<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\n<S2SV_blank>There<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\n<S2SV_blank>particular<S2SV_blank>purpose.\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( p = line + 18 ; isspace ( * p ) ; p ++ ) <S2SV_EndBug> <S2SV_StartBug> lenIV = atoi ( line + 6 ) ; <S2SV_EndBug> <S2SV_StartBug> && strstr ( line , ""readstring"" ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( p = strstr ( line , ""/Subrs"" ) ) && isdigit ( p [ 7 ] ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( ( p = strstr ( line , ""/CharStrings"" ) ) && isdigit ( p [ 13 ] ) ) <S2SV_EndBug> <S2SV_StartBug> for ( q = p ; isspace ( * q ) && * q != '\\n' ; q ++ ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\nThis<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\nThere<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\nparticular<S2SV_blank>purpose.\\n"" <S2SV_ModEnd> <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> set_lenIV ( line <S2SV_ModEnd> <S2SV_ModStart> ) { set_cs_start ( line ) <S2SV_ModEnd> <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) "
492,<S2SV_StartBug> usb_autopm_put_interface ( serial -> interface ) ; <S2SV_EndBug> ,<S2SV_ModStart> info -> port = NULL ; 
493,<S2SV_StartBug> cpuctx -> ctx . type = cpu_context ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
494,<S2SV_StartBug> struct iovec * iovec ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> , struct iov_iter * iter ) { if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ; <S2SV_ModEnd> <S2SV_ModStart> iov_iter_init ( iter , rw , iovec , * nr_segs , len ) ; "
495,<S2SV_StartBug> int groups_per_flex = 0 ; <S2SV_EndBug> <S2SV_StartBug> groups_per_flex = 1 << sbi -> s_log_groups_per_flex ; <S2SV_EndBug> <S2SV_StartBug> if ( groups_per_flex < 2 ) { <S2SV_EndBug> ,<S2SV_ModStart> unsigned <S2SV_ModStart> if ( sbi -> s_log_groups_per_flex < 1 || sbi -> s_log_groups_per_flex > 31 ) { sbi -> s_log_groups_per_flex = 0 ; return 1 ; } <S2SV_ModStart>  <S2SV_ModEnd> 
496,<S2SV_StartBug> if ( unlikely ( chunk_length < required_length ) ) <S2SV_EndBug> ,<S2SV_ModStart> chunk -> pdiscard ) ) return 0 ; if ( unlikely ( 
497,<S2SV_StartBug> for ( i = 0 ; a && i < count ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! i ) <S2SV_EndBug> ,<S2SV_ModStart> i ++ <S2SV_ModEnd> <S2SV_ModStart> if ( ! n ) { cJSON_Delete ( a ) ; return 0 ; } 
498,<S2SV_StartBug> if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) <S2SV_EndBug> ,"<S2SV_ModStart> * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ; if ( <S2SV_ModStart> * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ; if ( "
499,<S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( int ) 
500,<S2SV_StartBug> match_length += callback_args -> forward_matches ; <S2SV_EndBug> ,<S2SV_ModStart> ; assert ( match_offset + match_length <= callback_args -> data_size ) 
501,<S2SV_StartBug> ! no_port_forwarding_flag && ! options . disable_forwarding ) { <S2SV_EndBug> ,<S2SV_ModStart> && use_privsep 
502,<S2SV_StartBug> if ( ! bitstream_read_bit ( bc ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> length > SMKTREE_DECODE_MAX_RECURSION ) { av_log ( NULL , AV_LOG_ERROR , ""Maximum<S2SV_blank>tree<S2SV_blank>recursion<S2SV_blank>level<S2SV_blank>exceeded.\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( "
503,<S2SV_StartBug> m -> msg_name = address ; <S2SV_EndBug> ,<S2SV_ModStart> if ( m -> msg_name ) 
504,"<S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> type_ignore_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( type_ignores , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_argtypes ) ) { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( argtypes , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_type_ignores , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> * out = Module ( body , type_ignores , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""returns\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { <S2SV_ModEnd> <S2SV_ModStart> ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
505,<S2SV_StartBug> int hstartcol ; <S2SV_EndBug> <S2SV_StartBug> hstartcol = ( numrows + 1 - parity ) >> 1 ; <S2SV_EndBug> <S2SV_StartBug> m = numrows - hstartcol ; <S2SV_EndBug> <S2SV_StartBug> dstptr = & a [ hstartcol * stride ] ; <S2SV_EndBug> ,<S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> hstartrow <S2SV_ModEnd> 
506,"<S2SV_StartBug> iwl_sta_ucode_activate ( priv , sta_id ) ; <S2SV_EndBug> ","<S2SV_ModStart> ret = iwl_sta_ucode_activate ( priv , sta_id ) <S2SV_ModEnd> "
507,"<S2SV_StartBug> log_file = fopen ( file_name , ""a"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> fopen_safe <S2SV_ModEnd> 
508,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> assert_regexp_syntax_error ( ""\\\\x0"" ) ; assert_regexp_syntax_error ( ""\\\\x"" ) ; assert_regexp_syntax_error ( ""\\\\xxy"" ) ; "
509,<S2SV_StartBug> if ( hashbin -> hb_type & HB_LOCK ) { <S2SV_EndBug> <S2SV_StartBug> queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> while ( queue ) { <S2SV_EndBug> <S2SV_StartBug> ( * free_func ) ( queue ) ; <S2SV_EndBug> <S2SV_StartBug> if ( hashbin -> hb_type & HB_LOCK ) { <S2SV_EndBug> <S2SV_StartBug> # ifdef CONFIG_LOCKDEP <S2SV_EndBug> ,"<S2SV_ModStart> spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; <S2SV_ModEnd> <S2SV_ModStart> while ( 1 ) { <S2SV_ModStart> if ( ! queue ) break ; <S2SV_ModEnd> <S2SV_ModStart> { if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ; free_func ( queue ) ; if ( hashbin -> hb_type & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
510,"<S2SV_StartBug> err = security_sb_remount ( sb , data ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NODEV ) && ! ( mnt_flags & MNT_NODEV ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOSUID ) && ! ( mnt_flags & MNT_NOSUID ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOEXEC ) && ! ( mnt_flags & MNT_NOEXEC ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_ATIME ) && ( ( mnt -> mnt . mnt_flags & MNT_ATIME_MASK ) != ( mnt_flags & MNT_ATIME_MASK ) ) ) { return - EPERM ; } 
511,"<S2SV_StartBug> int copied , err ; <S2SV_EndBug> <S2SV_StartBug> sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_EndBug> <S2SV_StartBug> if ( sock -> type == SOCK_PACKET ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> copied = skb -> len ; <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_name ) <S2SV_EndBug> <S2SV_StartBug> msg -> msg_namelen ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } else { struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_ModEnd> <S2SV_ModStart> } memcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } "
512,<S2SV_StartBug> uchar buf [ RAS_MAGICLEN ] ; <S2SV_EndBug> ,<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
513,<S2SV_StartBug> if ( serial -> num_ports < 2 ) <S2SV_EndBug> ,"<S2SV_ModStart> num_bulk_out <S2SV_ModEnd> <S2SV_ModStart> { dev_err ( & serial -> interface -> dev , ""missing<S2SV_blank>bulk<S2SV_blank>out<S2SV_blank>endpoints\\n"" ) ; return - ENODEV ; } <S2SV_ModEnd> "
514,"<S2SV_StartBug> int do_rf64 = 0 , write_junk = 1 ; <S2SV_EndBug> <S2SV_StartBug> DS64Chunk ds64_chunk ; <S2SV_EndBug> <S2SV_StartBug> if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ; <S2SV_EndBug> <S2SV_StartBug> ds64hdr . ckSize = sizeof ( ds64_chunk ) ; <S2SV_EndBug> <S2SV_StartBug> ds64_chunk . sampleCount64 = total_samples ; <S2SV_EndBug> <S2SV_StartBug> WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ; <S2SV_EndBug> <S2SV_StartBug> ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) || <S2SV_EndBug> ","<S2SV_ModStart> , table_length = 0 <S2SV_ModStart> ; CS64Chunk cs64_chunk <S2SV_ModStart> total_riff_bytes += table_length * sizeof ( CS64Chunk ) ; if ( write_junk ) total_riff_bytes += <S2SV_ModEnd> <S2SV_ModStart> + ( table_length * sizeof ( CS64Chunk ) ) <S2SV_ModStart> ; ds64_chunk . tableLength = table_length <S2SV_ModStart> if ( table_length ) { strncpy ( cs64_chunk . ckID , ""dmmy"" , sizeof ( cs64_chunk . ckID ) ) ; cs64_chunk . chunkSize64 = 12345678 ; WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ; } <S2SV_ModStart> ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } if ( <S2SV_ModEnd> "
515,<S2SV_StartBug> if ( MSG_CMSG_COMPAT & flags ) { <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> msg_sys -> msg_flags = flags & ( MSG_CMSG_CLOEXEC | MSG_CMSG_COMPAT ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; msg_sys -> msg_namelen = 0 
516,<S2SV_StartBug> struct buffer_head * dibh = mp -> mp_bh [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> const unsigned end_of_metadata = height - 1 ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> super_block * sb = sdp -> sd_vfs ; struct <S2SV_ModStart> ; int ret <S2SV_ModStart> if ( buffer_zeronew ( bh_map ) ) { ret = sb_issue_zeroout ( sb , dblock , dblks , GFP_NOFS ) ; if ( ret ) { fs_err ( sdp , ""Failed<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>data<S2SV_blank>buffers\\n"" ) ; clear_buffer_zeronew ( bh_map ) ; } } "
517,"<S2SV_StartBug> vpx_codec_iface_name ( global -> codec -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> input -> use_i420 ? ""I420"" : ""YV12"" ) ; <S2SV_EndBug> <S2SV_StartBug> SHOW ( g_timebase . num ) ; <S2SV_EndBug> <S2SV_StartBug> SHOW ( rc_resize_allowed ) ; <S2SV_EndBug> ","<S2SV_ModStart> codec_interface ( ) ) ) ; fprintf ( stderr , ""Source<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>File<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>Format:<S2SV_blank>%s\\n"" , <S2SV_ModEnd> <S2SV_ModStart> file_type_to_string ( input -> file_type ) , image_format_to_string ( input -> fmt ) <S2SV_ModEnd> <S2SV_ModStart> g_bit_depth ) ; SHOW ( g_input_bit_depth ) ; SHOW ( <S2SV_ModStart> ) ; SHOW ( rc_scaled_width ) ; SHOW ( rc_scaled_height "
518,<S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decompress_data ( context ) ; <S2SV_EndBug> <S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> <S2SV_StartBug> context -> decode ( context ) ; <S2SV_EndBug> <S2SV_StartBug> PROFILER_EXIT ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> ,<S2SV_ModStart> { BOOL rc ; <S2SV_ModStart> rc = <S2SV_ModStart> if ( ! rc ) return FALSE ; } { BOOL rc ; <S2SV_ModStart> rc = <S2SV_ModStart> if ( ! rc ) return FALSE ; } 
519,<S2SV_StartBug> ( target -> doc -> dict == ctxt -> dict ) ) <S2SV_EndBug> ,"<S2SV_ModStart> && xmlDictOwns ( ctxt -> dict , value ) "
520,"<S2SV_StartBug> if ( copy_file ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> <S2SV_ModStart> else { touch_file_as_user ( fname , u , g , 0644 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> <S2SV_ModStart> else { touch_file_as_user ( fname , u , g , 0644 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
521,"<S2SV_StartBug> size_t * acl_len ) <S2SV_EndBug> <S2SV_StartBug> __be32 * savep ; <S2SV_EndBug> <S2SV_StartBug> * acl_len = 0 ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ; <S2SV_EndBug> <S2SV_StartBug> dprintk ( ""NFS:<S2SV_blank>server<S2SV_blank>cheating<S2SV_blank>in<S2SV_blank>getattr"" <S2SV_EndBug> <S2SV_StartBug> * acl_len = attrlen ; <S2SV_EndBug> ","<S2SV_ModStart> struct nfs_getaclres * res <S2SV_ModEnd> <S2SV_ModStart> , * bm_p <S2SV_ModStart> res -> <S2SV_ModEnd> <S2SV_ModStart> ; bm_p = xdr -> p <S2SV_ModStart> xdr -> p = bm_p ; res -> acl_data_offset = be32_to_cpup ( bm_p ) + 2 ; res -> acl_data_offset <<= 2 ; <S2SV_ModStart> ; attrlen += res -> acl_data_offset <S2SV_ModStart> if ( res -> acl_flags & NFS4_ACL_LEN_REQUEST ) { res -> acl_len = attrlen ; goto out ; } dprintk ( ""NFS:<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\n"" <S2SV_ModEnd> <S2SV_ModStart> res -> <S2SV_ModEnd> "
522,<S2SV_StartBug> if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) { <S2SV_EndBug> ,<S2SV_ModStart> } else if ( warn_script_unsaved && fv -> script_unsaved && AskScriptChanged ( ) == 2 ) { return false ; 
523,<S2SV_StartBug> assert ( msix_tab_size % 4096 == 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
524,<S2SV_StartBug> when = timespec_to_ns ( new_setting -> it_value ) ; <S2SV_EndBug> <S2SV_StartBug> period = timespec_to_ns ( new_setting -> it_interval ) ; <S2SV_EndBug> <S2SV_StartBug> now = timespec_to_ns ( n ) ; <S2SV_EndBug> ,<S2SV_ModStart> & <S2SV_ModStart> & <S2SV_ModStart> & 
525,"<S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , 0 ) ) <S2SV_EndBug> ","<S2SV_ModStart> js_doregexec ( J , <S2SV_ModEnd> "
526,"<S2SV_StartBug> if ( Int_val ( Field ( ( value ) dest , 1 ) ) >= 0 ) <S2SV_EndBug> ",<S2SV_ModStart> Long_val <S2SV_ModEnd> 
527,"<S2SV_StartBug> struct range * range ; <S2SV_EndBug> <S2SV_StartBug> size_t content_length ; <S2SV_EndBug> <S2SV_StartBug> int code = 500 , fd = - 1 , i , nranges , ret ; <S2SV_EndBug> <S2SV_StartBug> if ( ( range = parse_range ( range_str , st -> st_size , & nranges ) ) == NULL ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( evb = evbuffer_new ( ) ) == NULL ) { <S2SV_EndBug> <S2SV_StartBug> ( void ) snprintf ( content_range , sizeof ( content_range ) , <S2SV_EndBug> <S2SV_StartBug> content_length = range -> end - range -> start + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( buffer_add_range ( fd , evb , range ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> content_length = 0 ; <S2SV_EndBug> <S2SV_StartBug> content_length += i ; <S2SV_EndBug> <S2SV_StartBug> range ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ( i = evbuffer_add_printf ( evb , ""\\r\\n--%ud--\\r\\n"" , <S2SV_EndBug> <S2SV_StartBug> content_length += i ; <S2SV_EndBug> <S2SV_StartBug> ""byteranges;<S2SV_blank>boundary=%ud"" , boundary ) ; <S2SV_EndBug> <S2SV_StartBug> close ( fd ) ; <S2SV_EndBug> <S2SV_StartBug> goto done ; <S2SV_EndBug> <S2SV_StartBug> if ( server_bufferevent_write_buffer ( clt , evb ) == - 1 ) <S2SV_EndBug> <S2SV_StartBug> bufferevent_enable ( clt -> clt_bev , EV_READ | EV_WRITE ) ; <S2SV_EndBug> <S2SV_StartBug> if ( clt -> clt_persist ) <S2SV_EndBug> <S2SV_StartBug> if ( evb != NULL ) <S2SV_EndBug> ","<S2SV_ModStart> range_data * r = & clt -> clt_ranges ; struct range * range <S2SV_ModEnd> <S2SV_ModStart> = 0 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> nranges = parse_ranges ( clt , <S2SV_ModEnd> <S2SV_ModStart> ) ) < 1 <S2SV_ModEnd> <S2SV_ModStart> r -> range_media = media ; <S2SV_ModEnd> <S2SV_ModStart> range = & r -> range [ 0 ] ; <S2SV_ModStart> range = & r -> range [ 0 ] ; content_length += <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> arc4random_buf ( & clt -> clt_boundary , sizeof ( clt -> clt_boundary ) ) ; for ( i = 0 ; i < nranges ; i ++ ) { range = & r -> range [ i ] ; if ( ( ret = snprintf ( NULL , 0 , ""\\r\\n--%llu\\r\\n"" ""Content-Type:<S2SV_blank>%s/%s\\r\\n"" ""Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\r\\n\\r\\n"" , clt -> clt_boundary , media -> media_type , media -> media_subtype , range -> start , range -> end , st -> st_size ) ) < 0 <S2SV_ModEnd> <S2SV_ModStart> ret + <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ret = snprintf ( NULL , 0 , ""\\r\\n--%llu--\\r\\n"" , clt -> clt_boundary ) ) < 0 <S2SV_ModEnd> <S2SV_ModStart> ret <S2SV_ModEnd> <S2SV_ModStart> ""byteranges;<S2SV_blank>boundary=%llu"" , clt -> clt_boundary <S2SV_ModEnd> <S2SV_ModStart> r -> range_toread = TOREAD_HTTP_RANGE <S2SV_ModEnd> <S2SV_ModStart> close ( fd ) ; <S2SV_ModStart> clt -> clt_fd = fd ; if ( clt -> clt_srvbev != NULL ) bufferevent_free ( clt -> clt_srvbev ) ; clt -> clt_srvbev_throttled = 0 ; clt -> clt_srvbev = bufferevent_new ( clt -> clt_fd , server_read_httprange , server_write , server_file_error , clt ) ; if ( clt -> clt_srvbev == NULL ) { errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer<S2SV_blank>event"" ; <S2SV_ModEnd> <S2SV_ModStart> } bufferevent_setwatermark ( clt -> clt_srvbev , EV_READ , 0 , clt -> clt_sndbufsiz ) ; bufferevent_settimeout ( clt -> clt_srvbev , srv_conf -> timeout . tv_sec , srv_conf -> timeout . tv_sec ) ; bufferevent_enable ( clt -> clt_srvbev , EV_READ ) ; bufferevent_disable ( clt -> clt_bev , EV_READ ) ; done : server_reset_http ( clt ) ; return ( 0 ) ; fail : bufferevent_disable <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
528,"<S2SV_StartBug> ier = ksz8851ReadReg ( interface , KSZ8851_REG_IER ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_IER , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> isr = ksz8851ReadReg ( interface , KSZ8851_REG_ISR ) ; <S2SV_EndBug> <S2SV_StartBug> ier &= ~ IER_LCIE ; <S2SV_EndBug> <S2SV_StartBug> if ( ( isr & ISR_TXIS ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_TXIS ) ; <S2SV_EndBug> <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ; <S2SV_EndBug> <S2SV_StartBug> if ( ( isr & ISR_RXIS ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> ier &= ~ IER_RXIE ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_IER , ier ) ; <S2SV_EndBug> ","<S2SV_ModStart> KSZ8851_IER <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_IER <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_ISR ) ; if ( ( isr & KSZ8851_ISR_LCIS <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_IER_LCIE <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_ISR_TXIS <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_ISR , KSZ8851_ISR_TXIS <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_ISR_RXIS <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_IER_RXIE <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_IER <S2SV_ModEnd> "
529,"<S2SV_StartBug> static void encode_quantization ( VP9_COMMON * cm , <S2SV_EndBug> <S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> base_qindex , QINDEX_BITS ) ; <S2SV_EndBug> ",<S2SV_ModStart> const VP9_COMMON * const <S2SV_ModEnd> <S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> 
530,<S2SV_StartBug> } else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) { <S2SV_EndBug> ,<S2SV_ModStart> && c -> format != CHUNKY 
531,"<S2SV_StartBug> if ( write ( uipc_main . ch [ ch_id ] . fd , p_buf , msglen ) < 0 ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
532,<S2SV_StartBug> return tmp ; <S2SV_EndBug> <S2SV_StartBug> return tmp ; <S2SV_EndBug> <S2SV_StartBug> return state -> ptr = tmp ; <S2SV_EndBug> ,<S2SV_ModStart> goto softfail <S2SV_ModEnd> <S2SV_ModStart> goto softfail <S2SV_ModEnd> <S2SV_ModStart> softfail : state -> offset = 0 ; 
533,<S2SV_StartBug> struct fb_vblank vblank ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & vblank , 0 , sizeof ( vblank ) ) "
534,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } else if ( ctx -> might_cancel ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> spin_lock ( & ctx -> cancel_lock ) ; <S2SV_ModStart> { __timerfd_remove_cancel <S2SV_ModEnd> <S2SV_ModStart> spin_unlock ( & ctx -> cancel_lock ) ; 
535,"<S2SV_StartBug> c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( c16 -> Curves [ i ] == NULL ) { for ( j = 0 ; j < i ; j ++ ) { _cmsFree ( ContextID , c16 -> Curves [ j ] ) ; } _cmsFree ( ContextID , c16 -> Curves ) ; _cmsFree ( ContextID , c16 ) ; return NULL ; } "
536,"<S2SV_StartBug> if ( kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ! dev_name || 
537,"<S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
538,"<S2SV_StartBug> if ( peekonly ) { <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , space_rem ) ; <S2SV_EndBug> <S2SV_StartBug> sizeof ( * msg ) - space_rem ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) - <S2SV_EndBug> <S2SV_StartBug> } else if ( space_rem == sizeof ( * msg ) ) { <S2SV_EndBug> ","<S2SV_ModStart> memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd> <S2SV_ModStart> sizeof ( * msg ) - space_rem , buf_size ) ; } else if ( space_rem == sizeof ( * msg ) ) { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd> <S2SV_ModStart> buf_size ) ; } else { if ( buf ) { <S2SV_ModEnd> <S2SV_ModStart> curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
539,"<S2SV_StartBug> RETVAL_STRINGL ( replaced , ( int ) new_len , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( new_len > INT_MAX ) { efree ( replaced ) ; RETURN_FALSE ; } 
540,"<S2SV_StartBug> if ( peerkey && ! EVP_PKEY_cmp ( peerkey , localkey ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> != 1 
541,"<S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> ","<S2SV_ModStart> alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE "
542,"<S2SV_StartBug> BLOCK_SIZE bsize , BLOCK_SIZE subsize ) { <S2SV_EndBug> <S2SV_StartBug> int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; <S2SV_EndBug> <S2SV_StartBug> PARTITION_TYPE partition = partition_lookup [ bsl ] [ subsize ] ; <S2SV_EndBug> <S2SV_StartBug> set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; <S2SV_EndBug> <S2SV_StartBug> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_EndBug> <S2SV_StartBug> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col + hbs , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; <S2SV_EndBug> <S2SV_StartBug> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_EndBug> <S2SV_StartBug> duplicate_mode_info_in_sb ( cm , xd , mi_row + hbs , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> * ( get_sb_partitioning ( x , subsize ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize , <S2SV_EndBug> <S2SV_StartBug> fill_mode_info_sb ( cm , x , mi_row + hbs , mi_col , subsize , <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ","<S2SV_ModStart> PC_TREE * pc_tree <S2SV_ModEnd> <S2SV_ModStart> b_width_log2_lookup [ bsize ] <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> partitioning ; BLOCK_SIZE subsize = get_subsize ( bsize , partition ) <S2SV_ModEnd> <S2SV_ModStart> set_mode_info_offsets ( cm , x <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> none . mic ; * ( x -> mbmi_ext ) = pc_tree -> none . mbmi_ext <S2SV_ModEnd> <S2SV_ModStart> set_mode_info_offsets ( cm , x <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> vertical [ 0 ] . mic ; * ( x -> mbmi_ext ) = pc_tree -> vertical [ 0 ] . mbmi_ext ; <S2SV_ModEnd> <S2SV_ModStart> subsize <S2SV_ModEnd> <S2SV_ModStart> set_mode_info_offsets ( cm , x , xd , mi_row , mi_col + hbs ) ; * ( xd -> mi [ 0 ] ) = pc_tree -> vertical [ 1 ] . mic ; * ( x -> mbmi_ext ) = pc_tree -> vertical [ 1 ] . mbmi_ext ; <S2SV_ModEnd> <S2SV_ModStart> subsize <S2SV_ModEnd> <S2SV_ModStart> set_mode_info_offsets ( cm , x <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> horizontal [ 0 ] . mic ; * ( x -> mbmi_ext ) = pc_tree -> horizontal [ 0 ] . mbmi_ext ; <S2SV_ModEnd> <S2SV_ModStart> subsize <S2SV_ModEnd> <S2SV_ModStart> set_mode_info_offsets ( cm , x , xd , mi_row + hbs , mi_col ) ; * ( xd -> mi [ 0 ] ) = pc_tree -> horizontal [ 1 ] . mic ; * ( x -> mbmi_ext ) = pc_tree -> horizontal [ 1 ] . mbmi_ext ; <S2SV_ModEnd> <S2SV_ModStart> subsize <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> split [ 0 ] ) ; fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize , pc_tree -> split [ 1 ] ) <S2SV_ModEnd> <S2SV_ModStart> + hbs , mi_col , subsize , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> <S2SV_ModStart> + hbs , subsize , pc_tree -> split [ 3 ] <S2SV_ModEnd> <S2SV_ModStart> } "
543,<S2SV_StartBug> free ( name ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! strcmp ( key , ""url"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , ""disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s"" , value ) ; "
544,<S2SV_StartBug> int pixel_ptr = 0 ; <S2SV_EndBug> <S2SV_StartBug> block_ptr = row_ptr + pixel_ptr ; <S2SV_EndBug> <S2SV_StartBug> ADVANCE_BLOCK ( ) ; <S2SV_EndBug> <S2SV_StartBug> block_ptr = row_ptr + pixel_ptr ; <S2SV_EndBug> <S2SV_StartBug> ADVANCE_BLOCK ( ) ; <S2SV_EndBug> <S2SV_StartBug> block_ptr = row_ptr + pixel_ptr ; <S2SV_EndBug> <S2SV_StartBug> ADVANCE_BLOCK ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> - 4 <S2SV_ModEnd> <S2SV_ModStart> ADVANCE_BLOCK ( ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ADVANCE_BLOCK ( ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ADVANCE_BLOCK ( ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
545,<S2SV_StartBug> int n ; <S2SV_EndBug> ,<S2SV_ModStart> ssize_t <S2SV_ModEnd> 
546,<S2SV_StartBug> __be16 type ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( NAPI_GRO_CB ( skb ) -> encap_mark ) goto out ; NAPI_GRO_CB ( skb ) -> encap_mark = 1 
547,<S2SV_StartBug> if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) { <S2SV_EndBug> ,<S2SV_ModStart> numrows < 0 || numcols < 0 ) { return 0 ; } if ( 
548,"<S2SV_StartBug> rval = tpm_kdfa ( sapi_context , session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
549,"<S2SV_StartBug> ret = key_permission ( key_ref , KEY_NEED_READ ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { ret = - ENOKEY ; goto error2 ; } "
550,<S2SV_StartBug> || ( ret == ERROR_UNAVAIL_MVBUF_T ) ) <S2SV_EndBug> <S2SV_StartBug> || ( ret == ERROR_UNAVAIL_MVBUF_T ) ) <S2SV_EndBug> ,<S2SV_ModStart> || ( ret == ERROR_INV_SPS_PPS_T ) ) { ps_dec -> u4_slice_start_code_found = 0 ; <S2SV_ModEnd> <S2SV_ModStart> || ( ret == ERROR_INV_SPS_PPS_T ) 
551,<S2SV_StartBug> dst_known = tnum_is_const ( dst_reg -> var_off ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } 
552,<S2SV_StartBug> if ( ( rc == 0 ) || ( rc == - ENOENT ) ) <S2SV_EndBug> ,"<S2SV_ModStart> switch ( rc ) { case 0 : if ( newInode && ! S_ISREG ( newInode -> i_mode ) ) { CIFSSMBClose ( xid , pTcon , fileHandle ) ; break ; } case - ENOENT : posix_open = true ; case - EOPNOTSUPP : break ; default : pTcon -> broken_posix_open = true ; } } if ( ! posix_open ) rc = cifs_get_inode_info_unix ( & newInode , full_path , parent_dir_inode -> i_sb , xid ) ; } else rc = cifs_get_inode_info ( & newInode , full_path , NULL , parent_dir_inode -> i_sb , xid , NULL ) ; <S2SV_ModStart> && ( newInode != NULL ) ) { d_add ( direntry , newInode ) ; if ( posix_open ) { filp = lookup_instantiate_filp ( nd , direntry , generic_file_open ) ; if ( IS_ERR ( filp ) ) { rc = PTR_ERR ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; goto lookup_out ; } cfile = cifs_new_fileinfo ( fileHandle , filp , tlink , oplock ) ; if ( cfile == NULL ) { fput ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; rc = - ENOMEM ; goto lookup_out ; } } renew_parental_timestamps ( direntry ) ; } else if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
553,<S2SV_StartBug> u8 * data = NULL ; <S2SV_EndBug> <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> hdr . flags & ~ ( VFIO_IRQ_SET_DATA_TYPE_MASK | <S2SV_EndBug> <S2SV_StartBug> if ( ! ( hdr . flags & VFIO_IRQ_SET_DATA_NONE ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( hdr . flags & VFIO_IRQ_SET_DATA_BOOL ) <S2SV_EndBug> <S2SV_StartBug> hdr . start >= max || hdr . start + hdr . count > max ) <S2SV_EndBug> ,"<S2SV_ModStart> size_t size ; <S2SV_ModStart> max , <S2SV_ModStart> count >= ( U32_MAX - hdr . start ) || hdr . <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) return - EINVAL ; switch ( hdr . flags & VFIO_IRQ_SET_DATA_TYPE_MASK ) { case VFIO_IRQ_SET_DATA_NONE : size = 0 ; break ; case VFIO_IRQ_SET_DATA_BOOL : size = sizeof ( uint8_t ) ; break ; case VFIO_IRQ_SET_DATA_EVENTFD : size = sizeof ( int32_t ) ; break ; default : return - EINVAL ; } if ( size ) { if ( hdr . argsz - minsz < hdr . count * size "
554,"<S2SV_StartBug> if ( ext4_test_inode_state ( inode , EXT4_STATE_ORDERED_MODE ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
555,<S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> ,<S2SV_ModStart> UINT64_MAX <S2SV_ModEnd> 
556,"<S2SV_StartBug> int opt_size = sizeof ( struct ip_options ) + opt -> optlen ; <S2SV_EndBug> <S2SV_StartBug> if ( ireq -> opt != NULL && ip_options_echo ( ireq -> opt , skb ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> & ireq -> opt <S2SV_ModEnd> 
557,"<S2SV_StartBug> int mutt_b64_decode ( char * out , const char * in ) <S2SV_EndBug> <S2SV_StartBug> * out ++ = ( base64val ( digit1 ) << 2 ) | ( base64val ( digit2 ) >> 4 ) ; <S2SV_EndBug> <S2SV_StartBug> * out ++ = ( ( base64val ( digit2 ) << 4 ) & 0xf0 ) | ( base64val ( digit3 ) >> 2 ) ; <S2SV_EndBug> <S2SV_StartBug> * out ++ = ( ( base64val ( digit3 ) << 6 ) & 0xc0 ) | base64val ( digit4 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , size_t olen <S2SV_ModStart> if ( len == olen ) return len ; <S2SV_ModStart> if ( len == olen ) return len ; <S2SV_ModStart> if ( len == olen ) return len ; "
558,<S2SV_StartBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
559,"<S2SV_StartBug> size_t copied , len , cur_len ; <S2SV_EndBug> <S2SV_StartBug> copied = min_t ( const size_t , cur_len , PAGE_SIZE ) ; <S2SV_EndBug> <S2SV_StartBug> 0 , copied ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> cur_len = save_len - cur_len ; <S2SV_EndBug> ","<S2SV_ModStart> bytes , <S2SV_ModStart> bytes <S2SV_ModEnd> <S2SV_ModStart> bytes <S2SV_ModEnd> <S2SV_ModStart> if ( copied < bytes ) break ; <S2SV_ModStart> ; if ( ! cur_len ) { for ( i = 0 ; i < nr_pages ; i ++ ) put_page ( wdata -> pages [ i ] ) ; kfree ( wdata ) ; rc = - EFAULT ; break ; } for ( ; nr_pages > i + 1 ; nr_pages -- ) put_page ( wdata -> pages [ nr_pages - 1 ] ) "
560,<S2SV_StartBug> if ( ! ( quirks & CP_RDESC_SWAPPED_MIN_MAX ) ) <S2SV_EndBug> ,<S2SV_ModStart> ) return rdesc ; if ( * rsize < 4 
561,"<S2SV_StartBug> int number_of_frames , number_of_keyframes , encode_frame_count ; <S2SV_EndBug> <S2SV_StartBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <S2SV_EndBug> <S2SV_StartBug> encode_frame_count = si -> encode_frame_count ; <S2SV_EndBug> <S2SV_StartBug> if ( si -> encode_frame_count <= 0 ) return vpx_svc_get_message ( svc_ctx ) ; <S2SV_EndBug> <S2SV_StartBug> number_of_keyframes = encode_frame_count / si -> kf_dist + 1 ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < si -> layers ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> number_of_frames = encode_frame_count ; <S2SV_EndBug> <S2SV_StartBug> si -> encode_frame_count = 0 ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> <S2SV_ModStart> number_of_frames = si -> psnr_pkt_received <S2SV_ModEnd> <S2SV_ModStart> number_of_frames <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> svc_ctx -> spatial_layers <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> psnr_pkt_received <S2SV_ModEnd> 
562,"<S2SV_StartBug> static void nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 originalSize ) <S2SV_EndBug> <S2SV_StartBug> * out ++ = value ; <S2SV_EndBug> <S2SV_StartBug> FillMemory ( out , len , value ) ; <S2SV_EndBug> <S2SV_StartBug> * out ++ = value ; <S2SV_EndBug> ","<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> , UINT32 outSize <S2SV_ModStart> if ( outSize < 1 ) return FALSE ; outSize -- ; <S2SV_ModStart> if ( outSize < len ) return FALSE ; outSize -= len ; <S2SV_ModStart> if ( outSize < 1 ) return FALSE ; outSize -- ; * out ++ = value ; left -- ; } } if ( ( outSize < 4 ) || ( left < 4 ) ) return FALSE ; memcpy ( out , in , 4 ) ; return TRUE <S2SV_ModEnd> "
563,<S2SV_StartBug> if ( screen -> sb_buffer ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
564,"<S2SV_StartBug> const char * literal_start = * str ; <S2SV_EndBug> <S2SV_StartBug> for ( ; * str < end ; ( * str ) ++ ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && <S2SV_EndBug> <S2SV_StartBug> in_named_escape = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( * str + 1 < end && * ( * str + 1 ) == ch ) { <S2SV_EndBug> <S2SV_StartBug> ast_error ( c , n , ""f-string:<S2SV_blank>single<S2SV_blank>\'}\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed"" ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> literal_end = * str ; <S2SV_EndBug> <S2SV_StartBug> assert ( * str <= end ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( * str == end || * * str == '{' || * * str == '}' ) ; <S2SV_EndBug> <S2SV_StartBug> if ( literal_start != literal_end ) { <S2SV_EndBug> <S2SV_StartBug> literal_end - literal_start , <S2SV_EndBug> <S2SV_StartBug> literal_end - literal_start ) ; <S2SV_EndBug> ","<S2SV_ModStart> s = * str ; const char * literal_start = s <S2SV_ModEnd> <S2SV_ModStart> while ( s < end ) { char ch = * s ++ <S2SV_ModEnd> <S2SV_ModStart> raw && ch == '\\\\' && s < end ) { ch = * s ++ ; if ( ch == 'N' ) { if ( s < end && * s ++ == '{' ) { while ( s < end && * s ++ != <S2SV_ModEnd> <S2SV_ModStart> } continue ; } break ; } if ( ch == '{' && warn_invalid_escape_sequence ( c , n , ch ) < 0 ) { return - 1 ; } } <S2SV_ModEnd> <S2SV_ModStart> s < end && * s == ch ) { * str = s + 1 <S2SV_ModEnd> <S2SV_ModStart> * str = s - 1 ; <S2SV_ModStart> s -- ; <S2SV_ModStart> * str = s <S2SV_ModEnd> <S2SV_ModStart> s <S2SV_ModEnd> <S2SV_ModStart> s <S2SV_ModEnd> <S2SV_ModStart> s <S2SV_ModEnd> <S2SV_ModStart> s <S2SV_ModEnd> <S2SV_ModStart> s <S2SV_ModEnd> <S2SV_ModStart> s <S2SV_ModEnd> <S2SV_ModStart> s <S2SV_ModEnd> "
565,"<S2SV_StartBug> static int mem_resize ( jas_stream_memobj_t * m , int bufsize ) <S2SV_EndBug> <S2SV_StartBug> assert ( bufsize >= 0 ) ; <S2SV_EndBug> <S2SV_StartBug> JAS_DBGLOG ( 100 , ( ""mem_resize(%p,<S2SV_blank>%d)\\n"" , m , bufsize ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""mem_resize(%p,<S2SV_blank>%zu)\\n"" <S2SV_ModEnd> <S2SV_ModStart> if ( ! bufsize ) { jas_eprintf ( ""mem_resize<S2SV_blank>was<S2SV_blank>not<S2SV_blank>really<S2SV_blank>designed<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>a<S2SV_blank>buffer<S2SV_blank>of<S2SV_blank>size<S2SV_blank>0\\n"" ""This<S2SV_blank>may<S2SV_blank>not<S2SV_blank>work.\\n"" ) ; } "
566,"<S2SV_StartBug> struct dump_dir * dd = create_dump_dir_from_problem_data ( pd , g_settings_dump_location ) ; <S2SV_EndBug> ","<S2SV_ModStart> dd = NULL ; if ( g_settings_privatereports ) dd = create_dump_dir_from_problem_data_ext ( pd , g_settings_dump_location , 0 ) ; else "
567,"<S2SV_StartBug> if ( ! LookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) ) { <S2SV_EndBug> ",<S2SV_ModStart> || ! expr -> action . args 
568,<S2SV_StartBug> static void pcrypt_free ( struct crypto_instance * inst ) <S2SV_EndBug> <S2SV_StartBug> struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ; <S2SV_EndBug> ,<S2SV_ModStart> aead_instance <S2SV_ModEnd> <S2SV_ModStart> aead_instance_ctx <S2SV_ModEnd> 
569,<S2SV_StartBug> pixel_value += ( srcptr2 [ z ] << ( 8 * z ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( unsigned long ) 
570,<S2SV_StartBug> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) <S2SV_EndBug> ,"<S2SV_ModStart> EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( "
571,<S2SV_StartBug> in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( <S2SV_ModStart> < <S2SV_ModEnd> <S2SV_ModStart> ) { in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ; } else { ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>Got<S2SV_blank>route<S2SV_blank>advertisement<S2SV_blank>with<S2SV_blank>lower<S2SV_blank>hop_limit<S2SV_blank>than<S2SV_blank>current\\n"" ) ; } <S2SV_ModEnd> "
572,"<S2SV_StartBug> l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> <S2SV_StartBug> const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_EndBug> ","<S2SV_ModStart> , u_int length <S2SV_ModStart> if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } "
573,<S2SV_StartBug> if ( ! replay_esn || ! rp ) <S2SV_EndBug> <S2SV_StartBug> if ( xfrm_replay_state_esn_len ( replay_esn ) != <S2SV_EndBug> <S2SV_StartBug> xfrm_replay_state_esn_len ( up ) ) <S2SV_EndBug> ,<S2SV_ModStart> int ulen ; <S2SV_ModStart> ulen = xfrm_replay_state_esn_len ( up ) ; if ( nla_len ( rp ) < ulen || <S2SV_ModEnd> <S2SV_ModStart> ulen <S2SV_ModEnd> 
574,"<S2SV_StartBug> int ret = proc_dointvec ( table , write , buffer , lenp , ppos ) ; <S2SV_EndBug> ",<S2SV_ModStart> proc_dointvec_minmax <S2SV_ModEnd> 
575,"<S2SV_StartBug> in_what_stride , UINT_MAX ) <S2SV_EndBug> <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
576,"<S2SV_StartBug> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if <S2SV_EndBug> ",<S2SV_ModStart> 00 ; if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) { l_current_pi -> include = <S2SV_ModStart> } 
577,"<S2SV_StartBug> return try_then_request_module ( __crypto_lookup_template ( name ) , ""%s"" , <S2SV_EndBug> ","<S2SV_ModStart> ""crypto-%s"" <S2SV_ModEnd> "
578,"<S2SV_StartBug> int start = 0 ; <S2SV_EndBug> <S2SV_StartBug> kvm_pit_load_count ( kvm , 0 , kvm -> arch . vpit -> pit_state . channels [ 0 ] . count , start ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; int i <S2SV_ModStart> for ( i = 0 ; i < 3 ; i ++ ) <S2SV_ModStart> i <S2SV_ModEnd> <S2SV_ModStart> i <S2SV_ModEnd> 
579,"<S2SV_StartBug> static void encode_nonrd_sb_row ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( mi_col = tile -> mi_col_start ; mi_col < tile -> mi_col_end ; <S2SV_EndBug> <S2SV_StartBug> int dummy_rate = 0 ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + idx_str ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * prev_mi_8x8 = cm -> prev_mi_grid_visible + idx_str ; <S2SV_EndBug> <S2SV_StartBug> BLOCK_SIZE bsize ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( cpi -> mb . pred_mv ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( cpi -> sf . partition_search_type ) { <S2SV_EndBug> <S2SV_StartBug> choose_partitioning ( cpi , tile , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_EndBug> <S2SV_StartBug> 1 , & dummy_rate , & dummy_dist ) ; <S2SV_EndBug> <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; <S2SV_EndBug> <S2SV_StartBug> set_source_var_based_partition ( cpi , tile , mi_8x8 , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_EndBug> <S2SV_StartBug> 1 , & dummy_rate , & dummy_dist ) ; <S2SV_EndBug> <S2SV_StartBug> case VAR_BASED_FIXED_PARTITION : <S2SV_EndBug> <S2SV_StartBug> bsize = cpi -> sf . partition_search_type == FIXED_PARTITION ? <S2SV_EndBug> <S2SV_StartBug> set_fixed_partitioning ( cpi , tile , mi_8x8 , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_EndBug> <S2SV_StartBug> 1 , & dummy_rate , & dummy_dist ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . partition_check || sb_has_motion ( cm , prev_mi_8x8 ) ) { <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_partition ( cpi , tile , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_EndBug> <S2SV_StartBug> & dummy_rate , & dummy_dist , 1 , INT64_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> copy_partitioning ( cm , mi_8x8 , prev_mi_8x8 ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> BLOCK_64X64 , 1 , & dummy_rate , & dummy_dist ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , TileDataEnc * tile_data , int mi_row , TOKENEXTRA * * tp ) { SPEED_FEATURES * const sf = & cpi -> sf ; VP9_COMMON * const cm = & cpi -> common ; <S2SV_ModEnd> <S2SV_ModStart> tile_info = & tile_data -> tile_info ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; int mi_col ; memset ( & xd -> left_context , 0 , sizeof ( <S2SV_ModEnd> <S2SV_ModStart> ) ) ; memset ( xd -> left_seg_context <S2SV_ModStart> left_seg_context <S2SV_ModEnd> <S2SV_ModStart> tile_info <S2SV_ModEnd> <S2SV_ModStart> tile_info <S2SV_ModEnd> <S2SV_ModStart> const struct segmentation * const seg = & cm -> seg ; RD_COST dummy_rdc <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> PARTITION_SEARCH_TYPE partition_search_type = sf -> partition_search_type <S2SV_ModEnd> <S2SV_ModStart> = BLOCK_64X64 ; int seg_skip = 0 ; x -> <S2SV_ModEnd> <S2SV_ModStart> x -> <S2SV_ModEnd> <S2SV_ModStart> vp9_rd_cost_init ( & dummy_rdc ) ; x -> color_sensitivity [ 0 ] = 0 ; x -> color_sensitivity [ 1 ] = 0 ; if ( seg -> enabled ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; int segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ; seg_skip = segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ; if ( seg_skip ) { partition_search_type = FIXED_PARTITION ; } } switch ( <S2SV_ModEnd> <S2SV_ModStart> tile_info , x <S2SV_ModEnd> <S2SV_ModStart> td , tile_data , mi <S2SV_ModEnd> <S2SV_ModStart> BLOCK_64X64 , <S2SV_ModEnd> <S2SV_ModStart> dummy_rdc , td -> pc_root <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tile_info , x , mi <S2SV_ModEnd> <S2SV_ModStart> td , tile_data , mi <S2SV_ModEnd> <S2SV_ModStart> BLOCK_64X64 , <S2SV_ModEnd> <S2SV_ModStart> dummy_rdc , td -> pc_root <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! seg_skip ) bsize = sf -> always_this_block_size <S2SV_ModEnd> <S2SV_ModStart> tile_info , mi <S2SV_ModEnd> <S2SV_ModStart> td , tile_data , mi <S2SV_ModEnd> <S2SV_ModStart> BLOCK_64X64 , <S2SV_ModEnd> <S2SV_ModStart> dummy_rdc , td -> pc_root <S2SV_ModEnd> <S2SV_ModStart> set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; <S2SV_ModStart> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled && xd -> mi [ 0 ] -> mbmi . segment_id ) { if ( cm -> width <= 352 && cm -> height <= 288 ) x -> max_partition_size = BLOCK_32X32 ; else x -> max_partition_size = BLOCK_64X64 ; x -> min_partition_size = BLOCK_8X8 ; <S2SV_ModEnd> <S2SV_ModStart> td , tile_data <S2SV_ModEnd> <S2SV_ModStart> BLOCK_64X64 , & dummy_rdc <S2SV_ModEnd> <S2SV_ModStart> , td -> pc_root <S2SV_ModStart> choose_partitioning ( cpi , tile_info , x , mi_row , mi_col ) ; if ( cm -> frame_type == KEY_FRAME ) <S2SV_ModEnd> <S2SV_ModStart> td , tile_data , mi <S2SV_ModEnd> <S2SV_ModStart> dummy_rdc , td -> pc_root ) ; else nonrd_select_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rdc , td -> pc_root <S2SV_ModEnd> <S2SV_ModStart> break ; "
580,"<S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> 
581,"<S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> ",<S2SV_ModStart> _dh <S2SV_ModEnd> 
582,"<S2SV_StartBug> Fp = fopen ( filename , ""wb"" ) ; <S2SV_EndBug> <S2SV_StartBug> return HTTP_UNAUTHORIZED ; <S2SV_EndBug> ",<S2SV_ModStart> # ifdef UPNP_ENABLE_POST_WRITE <S2SV_ModStart> # else return HTTP_NOT_FOUND ; # endif 
583,"<S2SV_StartBug> char * dir = ""/etc"" ; <S2SV_EndBug> <S2SV_StartBug> if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) { <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""/etc"" , "".vipw"" <S2SV_ModEnd> "
584,<S2SV_StartBug> if ( IS_ERR ( blkg ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
585,<S2SV_StartBug> if ( pixdepth == 1 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( pixdepth == 8 ) { <S2SV_EndBug> ,<S2SV_ModStart> bpp == 1 && <S2SV_ModStart> bpp == 8 && 
586,"<S2SV_StartBug> krb5_data rspac ; <S2SV_EndBug> <S2SV_StartBug> krbtgt_out , <S2SV_EndBug> ","<S2SV_ModStart> ; const char * tgt_realm = krb5_principal_get_realm ( context , krbtgt -> entry . principal ) <S2SV_ModStart> tgt_realm , "
587,"<S2SV_StartBug> cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ; <S2SV_EndBug> ",<S2SV_ModStart> nd -> last_type = LAST_BIND ; 
588,"<S2SV_StartBug> struct usbdevfs_connectinfo ci = { <S2SV_EndBug> <S2SV_StartBug> . devnum = ps -> dev -> devnum , <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> ","<S2SV_ModStart> ; memset ( & ci , 0 , sizeof ( ci ) ) ; ci <S2SV_ModEnd> <S2SV_ModStart> ; ci <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
589,"<S2SV_StartBug> static int ip_options_get_finish ( struct net * net , struct ip_options * * optp , <S2SV_EndBug> <S2SV_StartBug> struct ip_options * opt , int optlen ) <S2SV_EndBug> <S2SV_StartBug> opt -> __data [ optlen ++ ] = IPOPT_END ; <S2SV_EndBug> <S2SV_StartBug> opt -> optlen = optlen ; <S2SV_EndBug> <S2SV_StartBug> if ( optlen && ip_options_compile ( net , opt , NULL ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> & opt -> 
590,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( args -> rmtblkno ) { <S2SV_EndBug> ,<S2SV_ModStart> args -> rmtvaluelen2 = args -> rmtvaluelen ; args -> rmtblkno = 0 ; args -> rmtblkcnt = 0 ; args -> rmtvaluelen = 0 ; <S2SV_ModStart> args -> rmtvaluelen = args -> rmtvaluelen2 ; 
591,"<S2SV_StartBug> byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> offset . QuadPart = 0 ; <S2SV_EndBug> <S2SV_StartBug> sizeof ( readBuffer ) , <S2SV_EndBug> <S2SV_StartBug> if ( NT_SUCCESS ( ntStatus ) ) <S2SV_EndBug> <S2SV_StartBug> Irp -> IoStatus . Status = ntStatus ; <S2SV_EndBug> <S2SV_StartBug> Irp -> IoStatus . Information = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> size_t devicePathLen = 0 <S2SV_ModEnd> <S2SV_ModStart> if ( ! NT_SUCCESS ( RtlUnalignedStringCchLengthW ( request -> DevicePath , TC_MAX_PATH , & devicePathLen ) ) || ( devicePathLen < 28 ) || ( devicePathLen > 30 ) || ( memcmp ( request -> DevicePath , L""\\\\Device\\\\Harddisk"" , 16 * sizeof ( WCHAR ) ) ) || ( memcmp ( & request -> DevicePath [ devicePathLen - 11 ] , L""\\\\Partition0"" , 11 * sizeof ( WCHAR ) ) ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } <S2SV_ModStart> byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } else { <S2SV_ModStart> TC_MAX_VOLUME_SECTOR_SIZE <S2SV_ModEnd> <S2SV_ModStart> ) { if ( IoStatus . Information >= TC_SECTOR_SIZE_BIOS <S2SV_ModStart> STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } else { Irp -> IoStatus . Status = <S2SV_ModStart> ; } TCfree ( readBuffer ) "
592,<S2SV_StartBug> if ( connection == NULL ) <S2SV_EndBug> ,<S2SV_ModStart> || strlen ( connection ) > UT_WS_SVR_MAX_HEADER_SIZE 
593,"<S2SV_StartBug> uint16 nif = 0 ; <S2SV_EndBug> <S2SV_StartBug> for ( d = alldevs ; d != NULL ; d = d -> next ) <S2SV_EndBug> <S2SV_StartBug> plen += strlen ( d -> description ) ; <S2SV_EndBug> <S2SV_StartBug> plen += strlen ( d -> name ) ; <S2SV_EndBug> <S2SV_StartBug> plen += sizeof ( struct rpcap_findalldevs_if ) ; <S2SV_EndBug> <S2SV_StartBug> plen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ; <S2SV_EndBug> <S2SV_StartBug> RPCAP_MSG_FINDALLIF_REPLY , nif , plen ) ; <S2SV_EndBug> ",<S2SV_ModStart> uint32 replylen ; <S2SV_ModStart> replylen = 0 ; <S2SV_ModStart> replylen <S2SV_ModEnd> <S2SV_ModStart> replylen <S2SV_ModEnd> <S2SV_ModStart> replylen <S2SV_ModEnd> <S2SV_ModStart> replylen <S2SV_ModEnd> <S2SV_ModStart> replylen <S2SV_ModEnd> 
594,"<S2SV_StartBug> struct dump_dir * dd = dd_create ( path , client_uid , DEFAULT_DUMP_DIR_MODE ) ; <S2SV_EndBug> ",<S2SV_ModStart> g_settings_privatereports ? 0 : 
595,<S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) <S2SV_EndBug> ,<S2SV_ModStart> 4 <S2SV_ModEnd> 
596,"<S2SV_StartBug> BN_ULONG t1 , t2 ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
597,<S2SV_StartBug> int tstype ) <S2SV_EndBug> <S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> serr -> ee . ee_info = tstype ; <S2SV_EndBug> ,"<S2SV_ModStart> , bool opt_stats <S2SV_ModStart> ; BUILD_BUG_ON ( sizeof ( struct sock_exterr_skb ) > sizeof ( skb -> cb ) ) <S2SV_ModStart> ; serr -> opt_stats = opt_stats "
598,"<S2SV_StartBug> if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue ) <S2SV_EndBug> ","<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
599,"<S2SV_StartBug> if ( in_cksum ( vec , 1 ) ) <S2SV_EndBug> <S2SV_StartBug> EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> { ND_TCHECK_16BITS ( & bp [ 6 ] ) ; <S2SV_ModStart> } 
600,"<S2SV_StartBug> run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%2f?"" ) , CONST_STR_LEN ( ""/?"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2f?"" ) , CONST_STR_LEN ( ""//?"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "
601,"<S2SV_StartBug> if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) { <S2SV_EndBug> ",<S2SV_ModStart> dumpable != SUID_DUMP_USER && <S2SV_ModEnd> 
602,<S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( int ) 
603,<S2SV_StartBug> if ( flags & __GFP_ZERO ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
604,<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> int rowstep ; <S2SV_EndBug> ,<S2SV_ModStart> jas_matind_t i ; jas_matind_t <S2SV_ModEnd> <S2SV_ModStart> jas_matind_t <S2SV_ModEnd> 
605,"<S2SV_StartBug> ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , <S2SV_EndBug> <S2SV_StartBug> u4_payload_size ) ; <S2SV_EndBug> <S2SV_StartBug> ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , <S2SV_EndBug> <S2SV_StartBug> u4_payload_size ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) { for ( i = 0 ; i < u4_payload_size / 4 ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ; } ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ; } else { <S2SV_ModStart> } <S2SV_ModStart> if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) { for ( i = 0 ; i < u4_payload_size / 4 ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ; } ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ; } else { <S2SV_ModStart> } "
606,"<S2SV_StartBug> priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! port -> interrupt_out_urb || ! port -> interrupt_in_urb ) { dev_err ( & port -> dev , ""required<S2SV_blank>endpoint<S2SV_blank>is<S2SV_blank>missing\\n"" ) ; return - ENODEV ; } "
607,<S2SV_StartBug> if ( ret < 0 ) <S2SV_EndBug> <S2SV_StartBug> dd -> sdma_rht = tmp_sdma_rht ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree ( tmp_sdma_rht ) ; <S2SV_ModStart> } 
608,<S2SV_StartBug> put_device ( & dev -> dev ) ; <S2SV_EndBug> ,<S2SV_ModStart> cancel_autoload_drivers ( ) ; 
609,"<S2SV_StartBug> const char * name , int rep_quick ) <S2SV_EndBug> <S2SV_StartBug> mysql_file_close ( new_file , MYF ( 0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( param -> testflag & T_BACKUP_DATA ? <S2SV_EndBug> ","<S2SV_ModStart> , my_bool no_copy_stat <S2SV_ModStart> myf flags = 0 ; if ( param -> testflag & T_BACKUP_DATA ) flags |= MY_REDEL_MAKE_BACKUP ; if ( no_copy_stat ) flags |= MY_REDEL_NO_COPY_STAT ; <S2SV_ModStart> flags <S2SV_ModEnd> "
610,<S2SV_StartBug> if ( p == q || size < 16 || size > 256 ) <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) || ( <S2SV_ModEnd> <S2SV_ModStart> ) || ( <S2SV_ModEnd> <S2SV_ModStart> ) 
611,"<S2SV_StartBug> uint dblocks = XFS_B_TO_FSB ( mp , valuelen ) ; <S2SV_EndBug> ",<S2SV_ModStart> xfs_attr3_rmt_blocks <S2SV_ModEnd> 
612,<S2SV_StartBug> pairs = palloc ( pcount * sizeof ( Pairs ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( pcount < 0 || pcount > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , pcount , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ; "
613,"<S2SV_StartBug> ruleaddvar ( r , var , val ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( ! val ) continue 
614,<S2SV_StartBug> if ( text [ 1 ] == EOF ) <S2SV_EndBug> <S2SV_StartBug> if ( text [ 2 ] == EOF ) <S2SV_EndBug> <S2SV_StartBug> if ( text [ 3 ] == EOF ) <S2SV_EndBug> ,<S2SV_ModStart> || text [ 1 ] == 0 <S2SV_ModStart> ! isxdigit ( <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> ! isxdigit ( <S2SV_ModStart> ) <S2SV_ModEnd> 
615,<S2SV_StartBug> c -> req -> path . start = c -> req -> msg + ( path . start - c -> buf ) ; <S2SV_EndBug> ,"<S2SV_ModStart> memcpy ( c -> req -> remote , c -> remote , sizeof ( c -> remote ) ) ; "
616,"<S2SV_StartBug> void vp9_fht16x16_c ( const int16_t * input , int16_t * output , <S2SV_EndBug> <S2SV_StartBug> vp9_fdct16x16_c ( input , output , stride ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t out [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = & out [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t temp_in [ 16 ] , temp_out [ 16 ] ; <S2SV_EndBug> <S2SV_StartBug> outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_fdct16x16_c <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> 
617,"<S2SV_StartBug> g_print ( _ ( ""Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\n"" ) , arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> { flatpak_fail_error ( error , FLATPAK_ERROR_EXPORT_FAILED , _ ( ""Invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s"" <S2SV_ModEnd> <S2SV_ModStart> goto out ; } "
618,"<S2SV_StartBug> if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> goto out_errno ; <S2SV_EndBug> <S2SV_StartBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_default , <S2SV_EndBug> ","<S2SV_ModStart> error = fh_want_write ( fh ) ; if ( error ) <S2SV_ModEnd> <S2SV_ModStart> fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access <S2SV_ModEnd> <S2SV_ModStart> out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT <S2SV_ModEnd> <S2SV_ModStart> ) ; out_drop_lock : fh_unlock ( fh ) ; <S2SV_ModEnd> "
619,<S2SV_StartBug> BUG_IF ( tree_root == NULL ) ; <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> return 0 
620,"<S2SV_StartBug> char * temp_filename = osi_calloc ( strlen ( filename ) + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! temp_filename ) { <S2SV_EndBug> <S2SV_StartBug> fprintf ( fp , ""[%s]\\n"" , section -> name ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( fp , ""%s<S2SV_blank>=<S2SV_blank>%s\\n"" , entry -> key , entry -> value ) ; <S2SV_EndBug> <S2SV_StartBug> fputc ( '\\n' , fp ) ; <S2SV_EndBug> <S2SV_StartBug> fclose ( fp ) ; <S2SV_EndBug> <S2SV_StartBug> osi_free ( temp_filename ) ; <S2SV_EndBug> <S2SV_StartBug> error : ; <S2SV_EndBug> <S2SV_StartBug> osi_free ( temp_filename ) ; <S2SV_EndBug> ","<S2SV_ModStart> int dir_fd = - 1 ; FILE * fp = NULL ; static const char * temp_file_ext = "".new"" ; const int filename_len = strlen ( filename ) ; const int temp_filename_len = filename_len + strlen ( temp_file_ext ) + 1 ; char * <S2SV_ModEnd> <S2SV_ModStart> temp_filename_len ) ; snprintf ( temp_filename , temp_filename_len , ""%s%s"" , filename , temp_file_ext ) ; char * temp_dirname = osi_strdup ( filename ) ; const char * directoryname = dirname ( temp_dirname <S2SV_ModEnd> <S2SV_ModStart> directoryname ) { LOG_ERROR ( ""%s<S2SV_blank>error<S2SV_blank>extracting<S2SV_blank>directory<S2SV_blank>from<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , filename , strerror ( errno ) ) ; goto error ; } dir_fd = TEMP_FAILURE_RETRY ( open ( directoryname , O_RDONLY ) ) ; if ( dir_fd < 0 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModStart> < 0 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModStart> < 0 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> <S2SV_ModStart> { if ( <S2SV_ModStart> == EOF ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } } } if ( fsync ( fileno ( fp ) ) < 0 ) { LOG_WARN ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>fsync<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; } if ( <S2SV_ModEnd> <S2SV_ModStart> == EOF ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>close<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } fp = NULL <S2SV_ModStart> if ( fsync ( dir_fd ) < 0 ) { LOG_WARN ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>fsync<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ; } if ( close ( dir_fd ) < 0 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>close<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ; goto error ; } <S2SV_ModStart> ) ; osi_free ( temp_dirname <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( fp ) fclose ( fp ) ; if ( dir_fd != - 1 ) close ( dir_fd ) ; <S2SV_ModStart> ) ; osi_free ( temp_dirname "
621,<S2SV_StartBug> switch ( pc -> componentType ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case 5 : <S2SV_EndBug> <S2SV_StartBug> elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ; <S2SV_EndBug> ,<S2SV_ModStart> elen += sizeof ( struct pathComponent ) ; <S2SV_ModStart> { elen += pc -> lengthComponentIdent ; break ; } <S2SV_ModEnd> <S2SV_ModStart> elen += pc -> lengthComponentIdent ; if ( elen > fromlen ) return - EIO ; <S2SV_ModStart>  <S2SV_ModEnd> 
622,<S2SV_StartBug> ND_TCHECK ( dp [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> dp += 3 ; <S2SV_EndBug> ,"<S2SV_ModStart> 4 <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 3 ] <S2SV_ModEnd> "
623,"<S2SV_StartBug> ND_TCHECK ( * vtp_vlan ) ; <S2SV_EndBug> <S2SV_StartBug> fn_printzp ( ndo , tptr + VTP_VLAN_INFO_OFFSET , vtp_vlan -> name_len , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; <S2SV_EndBug> <S2SV_StartBug> tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; <S2SV_EndBug> <S2SV_StartBug> type = * tptr ; <S2SV_EndBug> <S2SV_StartBug> if ( type == 0 || tlv_len == 0 ) { <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> len -= 2 + tlv_len * 2 ; <S2SV_EndBug> ","<S2SV_ModStart> if ( len < VTP_VLAN_INFO_FIXED_PART_LEN ) goto trunc ; <S2SV_ModStart> len -= VTP_VLAN_INFO_FIXED_PART_LEN ; tptr += VTP_VLAN_INFO_FIXED_PART_LEN ; if ( len < 4 * ( ( <S2SV_ModEnd> <S2SV_ModStart> + 3 ) / 4 ) ) goto trunc ; ND_TCHECK2 ( * tptr , <S2SV_ModEnd> <S2SV_ModStart> ) ; fn_printzp ( ndo , tptr , <S2SV_ModEnd> <S2SV_ModStart> , NULL ) ; len -= 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; tptr += 4 * ( ( vtp_vlan -> name_len <S2SV_ModStart> if ( len < 2 ) goto trunc ; ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> len < tlv_len * 2 + 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(TLV<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>packet)"" ) ) ; <S2SV_ModEnd> <S2SV_ModStart> if ( tlv_len != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>TLV<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>1)"" , tlv_len ) ) ; return ; } else { <S2SV_ModStart> } "
624,"<S2SV_StartBug> target , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> ctxt -> instate = state ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ctxt -> instate != XML_PARSER_EOF ) <S2SV_ModStart> if ( <S2SV_ModStart> != XML_PARSER_EOF ) ctxt -> instate 
625,<S2SV_StartBug> bool slow ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * addr_len = sizeof ( * sin ) ; 
626,"<S2SV_StartBug> u_int tlen , pdu_type , pdu_len ; <S2SV_EndBug> <S2SV_StartBug> while ( tlen >= sizeof ( rpki_rtr_pdu ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( rpki_rtr_pdu_print ( ndo , tptr , 8 ) ) <S2SV_EndBug> <S2SV_StartBug> tptr += pdu_len ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> len ) { u_int pdu_len = <S2SV_ModEnd> <S2SV_ModStart> pptr , len , 1 <S2SV_ModEnd> <S2SV_ModStart> ; len <S2SV_ModEnd> <S2SV_ModStart> pptr <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
627,"<S2SV_StartBug> s = tcp_recv ( NULL , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ber_in_header ( s , & tagval , & length ) || <S2SV_EndBug> <S2SV_StartBug> in_uint8s ( s , length ) ; <S2SV_EndBug> <S2SV_StartBug> token -> end = token -> p = token -> data ; <S2SV_EndBug> ","<S2SV_ModStart> struct stream packet ; <S2SV_ModStart> packet = * s ; <S2SV_ModStart> if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>version<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } <S2SV_ModStart> if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>token<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } s_realloc ( token , length ) ; s_reset ( token ) <S2SV_ModEnd> "
628,<S2SV_StartBug> int chars_processed ; <S2SV_EndBug> <S2SV_StartBug> int data_size = ndo -> ndo_snapend - bp ; <S2SV_EndBug> <S2SV_StartBug> chars_processed = 1 ; <S2SV_EndBug> <S2SV_StartBug> cp = bp + ( ( ( i << 8 ) | * cp ) & 0x3fff ) ; <S2SV_EndBug> <S2SV_StartBug> chars_processed ++ ; <S2SV_EndBug> <S2SV_StartBug> chars_processed += l ; <S2SV_EndBug> <S2SV_StartBug> chars_processed ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> elt ; u_int offset , max_offset ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; max_offset = ( u_int ) ( cp - bp ) ; if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) { compress = 0 ; rp = cp + l ; } if ( i != 0 ) while ( i && cp < <S2SV_ModEnd> <S2SV_ModStart> ) { if ( ( i & INDIR_MASK ) == INDIR_MASK ) { if ( ! compress ) { rp = cp + 1 ; compress = 1 ; } <S2SV_ModEnd> <S2SV_ModStart> offset = ( ( ( i << 8 ) | * cp ) & 0x3fff ) ; if ( offset >= max_offset ) { ND_PRINT ( ( ndo , ""<BAD<S2SV_blank>PTR>"" ) ) ; return ( NULL ) ; } max_offset = offset ; cp = bp + offset ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
629,"<S2SV_StartBug> blkcnt = xfs_attr3_rmt_blocks ( mp , args -> valuelen ) ; <S2SV_EndBug> <S2SV_StartBug> valuelen = args -> valuelen ; <S2SV_EndBug> ",<S2SV_ModStart> rmtvaluelen <S2SV_ModEnd> <S2SV_ModStart> rmtvaluelen <S2SV_ModEnd> 
630,"<S2SV_StartBug> int rv = Socket_print ( S , <S2SV_EndBug> <S2SV_StartBug> ""Content-Length:<S2SV_blank>%d\\r\\n"" <S2SV_EndBug> <S2SV_StartBug> request , <S2SV_EndBug> ","<S2SV_ModStart> MD_T token ; StringBuffer_append ( data , ""%ssecuritytoken=%s"" , StringBuffer_length ( data ) > 0 ? ""&"" : """" , Util_getToken ( token ) ) ; <S2SV_ModStart> ""Cookie:<S2SV_blank>securitytoken=%s\\r\\n"" <S2SV_ModStart> , token "
631,"<S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> <S2SV_StartBug> int rv = copy_file ( src , dest ) ; <S2SV_EndBug> <S2SV_StartBug> if ( chown ( dest , getuid ( ) , getgid ( ) ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( chmod ( dest , S_IRUSR | S_IWUSR ) < 0 ) <S2SV_EndBug> ","<S2SV_ModStart> copy_file_as_user <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; fs_logger2 ( ""clone"" , dest <S2SV_ModEnd> "
632,<S2SV_StartBug> if ( rc != BFA_STATUS_OK ) <S2SV_EndBug> <S2SV_StartBug> wait_for_completion ( & fcomp . comp ) ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree ( fcstats ) ; <S2SV_ModStart> } 
633,"<S2SV_StartBug> value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> MagickMax <S2SV_ModEnd> <S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> MagickMax <S2SV_ModEnd> <S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> MagickMax <S2SV_ModEnd> 
634,<S2SV_StartBug> * head = NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> giterr_set_str ( GITERR_NET , ""Invalid<S2SV_blank>empty<S2SV_blank>packet"" ) ; return GIT_ERROR <S2SV_ModEnd> "
635,"<S2SV_StartBug> if ( check_stack_guard_page ( vma , address ) < 0 ) <S2SV_EndBug> ",<S2SV_ModStart> vma -> vm_flags & VM_SHARED ) return VM_FAULT_SIGBUS ; if ( 
636,<S2SV_StartBug> rec -> sasl_username = src -> sasl_username ; <S2SV_EndBug> <S2SV_StartBug> rec -> sasl_password = src -> sasl_password ; <S2SV_EndBug> ,<S2SV_ModStart> g_strdup ( <S2SV_ModStart> ) <S2SV_ModStart> g_strdup ( <S2SV_ModStart> ) 
637,"<S2SV_StartBug> struct bpf_insn_aux_data * new_data , * old_data = env -> insn_aux_data ; <S2SV_EndBug> <S2SV_StartBug> env -> insn_aux_data = new_data ; <S2SV_EndBug> ",<S2SV_ModStart> ; int i <S2SV_ModStart> for ( i = off ; i < off + cnt - 1 ; i ++ ) new_data [ i ] . seen = true ; 
638,<S2SV_StartBug> ND_TCHECK ( dp -> ip6f_offlg ) ; <S2SV_EndBug> ,<S2SV_ModStart> * dp <S2SV_ModEnd> 
639,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>%u)"" , <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; 
640,"<S2SV_StartBug> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> 
641,"<S2SV_StartBug> assert ( ( occ0 % rowsize ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> ( * sp -> decodepfunc ) ( tif , op0 , rowsize ) ; <S2SV_EndBug> ","<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""PredictorDecodeTile"" , ""%s"" , ""occ0%rowsize<S2SV_blank>!=<S2SV_blank>0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> if ( ! <S2SV_ModStart> ) return 0 "
642,"<S2SV_StartBug> size_t i , tcount , o , datao ; <S2SV_EndBug> <S2SV_StartBug> ++ tcount ; <S2SV_EndBug> ","<S2SV_ModStart> ; long failsafe_size = 0 <S2SV_ModStart> failsafe_size += mnote_canon_entry_count_values ( & n -> entries [ tcount ] ) ; if ( failsafe_size > FAILSAFE_SIZE_MAX ) { exif_mem_free ( ne -> mem , n -> entries [ tcount ] . data ) ; exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Failsafe<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>(%lu<S2SV_blank>><S2SV_blank>%ld)"" , failsafe_size , FAILSAFE_SIZE_MAX ) ; break ; } "
643,<S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug> ,<S2SV_ModStart> ctx -> terminated || 
644,<S2SV_StartBug> kfree ( sbi ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sbi -> spool ) hugepage_put_subpool ( sbi -> spool ) ; 
645,"<S2SV_StartBug> error = mi_repair_by_sort ( param , info , filename , rep_quick ) ; <S2SV_EndBug> <S2SV_StartBug> error = mi_repair_parallel ( param , info , filename , rep_quick ) ; <S2SV_EndBug> <S2SV_StartBug> error = mi_repair ( param , info , filename , rep_quick ) ; <S2SV_EndBug> <S2SV_StartBug> error = mi_repair_by_sort ( param , info , filename , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> error = mi_sort_index ( param , info , filename ) ; <S2SV_EndBug> ","<S2SV_ModStart> , FALSE <S2SV_ModStart> , FALSE <S2SV_ModStart> , FALSE <S2SV_ModStart> , FALSE <S2SV_ModStart> , FALSE "
646,"<S2SV_StartBug> int alloc = ( length ? length : ( int ) strlen ( string ) ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> CURLcode res ; <S2SV_EndBug> <S2SV_StartBug> res = Curl_convert_from_network ( handle , & in , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( res ) { <S2SV_EndBug> <S2SV_StartBug> * olen = strindex ; <S2SV_EndBug> ","<S2SV_ModStart> char * str = NULL ; size_t inputlen = length ; size_t outputlen <S2SV_ModEnd> <S2SV_ModStart> = Curl_urldecode <S2SV_ModEnd> <S2SV_ModStart> string , inputlen , & str , & outputlen , FALSE <S2SV_ModEnd> <S2SV_ModStart> return NULL <S2SV_ModEnd> <S2SV_ModStart> curlx_uztosi ( outputlen ) ; return str <S2SV_ModEnd> "
647,<S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> ,<S2SV_ModStart> = { 0 } 
648,"<S2SV_StartBug> if ( unlikely ( copied == 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> iov_iter_advance ( i , copied ) ; <S2SV_EndBug> ","<S2SV_ModStart> iov_iter_advance ( i , copied ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
649,<S2SV_StartBug> if ( unlikely ( len > ring -> rx_buffersize ) ) { <S2SV_EndBug> ,<S2SV_ModStart> + ring -> frameoffset 
650,<S2SV_StartBug> def -> pdu_free_state_ref = usm_free_usmStateReference ; <S2SV_EndBug> ,<S2SV_ModStart> pdu_clone = usm_clone ; def -> 
651,"<S2SV_StartBug> show_object ( obj , NULL , name , data ) ; <S2SV_EndBug> <S2SV_StartBug> NULL , path , data ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> & base <S2SV_ModEnd> 
652,"<S2SV_StartBug> return ! match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , 0 "
653,<S2SV_StartBug> if ( src_end - src < zsize ) <S2SV_EndBug> <S2SV_StartBug> bitbuf = * src ++ ; <S2SV_EndBug> ,<S2SV_ModStart> + ( sub_type != 2 ) <S2SV_ModStart> if ( src >= src_end ) return AVERROR_INVALIDDATA ; 
654,<S2SV_StartBug> drop_futex_key_refs ( & q -> key ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
655,<S2SV_StartBug> # ifndef NETSNMP_NO_WRITE_SUPPORT <S2SV_EndBug> ,<S2SV_ModStart> if ! defined ( NETSNMP_NO_WRITE_SUPPORT ) && ENABLE_EXTEND_WRITE_ACCESS <S2SV_ModEnd> 
656,<S2SV_StartBug> switch ( depth ) <S2SV_EndBug> <S2SV_StartBug> CheckNumberCompactPixels ; <S2SV_EndBug> ,<S2SV_ModStart> CheckNumberCompactPixels ; <S2SV_ModStart>  <S2SV_ModEnd> 
657,"<S2SV_StartBug> list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , <S2SV_EndBug> <S2SV_StartBug> spin_lock_irq ( & slave_active_lock ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irq ( & slave_active_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> spin_lock_irq ( & slave_active_lock ) ; spin_lock ( & timer -> lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> list_del_init ( & slave -> ack_list ) ; list_del_init ( & slave -> active_list ) ; } spin_unlock ( & timer -> lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
658,"<S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK ( p [ 2 ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> 
659,"<S2SV_StartBug> const char * arch = info -> arch ; <S2SV_EndBug> <S2SV_StartBug> if ( info -> cpu && * info -> cpu ) { <S2SV_EndBug> <S2SV_StartBug> r_config_set ( r -> config , ""anal.cpu"" , info -> cpu ) ; <S2SV_EndBug> <S2SV_StartBug> r_core_bin_set_cur ( r , binfile ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strdup ( info -> arch ) ; char * cpu = info -> cpu ? strdup ( info -> cpu ) : NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; free ( cpu ) ; free ( arch 
660,"<S2SV_StartBug> static void sas_probe_devices ( struct work_struct * work ) <S2SV_EndBug> <S2SV_StartBug> struct domain_device * dev , * n ; <S2SV_EndBug> ",<S2SV_ModStart> asd_sas_port * port <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
661,<S2SV_StartBug> ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( <S2SV_EndBug> ,<S2SV_ModStart> { i_temp = ih264d_read_mmco_commands ( ps_dec ) ; if ( i_temp < 0 ) { return ERROR_DBP_MANAGER_T ; } <S2SV_ModStart> i_temp ; } <S2SV_ModEnd> 
662,"<S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> char line [ NETSCREEN_LINE_LENGTH ] ; <S2SV_EndBug> <S2SV_StartBug> pkt_len = parse_netscreen_rec_hdr ( & wth -> phdr , line , cap_int , & cap_dir , <S2SV_EndBug> <S2SV_StartBug> if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int , <S2SV_EndBug> <S2SV_StartBug> cap_dst , & wth -> phdr , wth -> frame_buffer , err , err_info ) ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> parse_netscreen_packet <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , line "
663,"<S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> processed_rcds ) , <S2SV_EndBug> <S2SV_StartBug> s -> s3 -> rrec . seq_num ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( <S2SV_ModStart> < 0 ) return - 1 
664,<S2SV_StartBug> int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ; <S2SV_EndBug> <S2SV_StartBug> const uint_fast32_t newRasterSize = gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( newRasterSize == 0 ) { free ( info -> rasterBits ) ; info -> rasterBits = NULL ; info -> rasterSize = newRasterSize ; return ; } const int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ; const int_fast32_t heightOverflow = gifFilePtr -> Image . Height - info -> originalHeight 
665,"<S2SV_StartBug> ret = key_validate ( key ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( key -> type -> read ) { <S2SV_EndBug> <S2SV_StartBug> ret = key -> type -> read ( key , buffer , buflen ) ; <S2SV_EndBug> ","<S2SV_ModStart> - EOPNOTSUPP ; if ( key -> type -> read ) { down_read ( & key -> sem ) ; ret = <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> ( key , buffer , buflen ) ; up_read <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
666,<S2SV_StartBug> cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <S2SV_EndBug> ,<S2SV_ModStart> || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) 
667,"<S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> != c ) break 
668,"<S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> <S2SV_StartBug> * val = ( tmp & 0x80000000 ) ? ( - JAS_CAST ( longlong , ( ( ( ~ tmp ) & <S2SV_EndBug> <S2SV_StartBug> 0x7fffffff ) + 1 ) ) ) : JAS_CAST ( longlong , tmp ) ; <S2SV_EndBug> ",<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> <S2SV_ModStart> jas_longlong <S2SV_ModEnd> <S2SV_ModStart> jas_longlong <S2SV_ModEnd> 
669,<S2SV_StartBug> kfree ( rm -> atomic . op_notifier ) ; <S2SV_EndBug> ,<S2SV_ModStart> rm -> atomic . op_active = 0 ; 
670,<S2SV_StartBug> assert ( bi != NULL ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( bi == NULL ) { pr_err ( ""%s:<S2SV_blank>pci<S2SV_blank>[%s]<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>bus<S2SV_blank>%d<S2SV_blank>info!\\n"" , __func__ , dev -> name , dev -> bus ) ; return ; } <S2SV_ModEnd> "
671,"<S2SV_StartBug> rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , size , msg_flags , timeo ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
672,"<S2SV_StartBug> if ( snprintf ( spath , sizeof ( spath ) , var , iface ) >= sizeof ( spath ) ) <S2SV_EndBug> ","<S2SV_ModStart> ) ) return - 1 ; if ( strstr ( name , "".."" ) || strchr ( name , '/' "
673,<S2SV_StartBug> for ( s += 9 ; isspace ( * s ) ; s ++ ) ; <S2SV_EndBug> <S2SV_StartBug> while ( * t && ! isspace ( * t ) ) t ++ ; <S2SV_EndBug> ,<S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) 
674,"<S2SV_StartBug> mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <S2SV_EndBug> ",<S2SV_ModStart> cache_id ( <S2SV_ModStart> ) 
675,<S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> * objp = NULL ; 
676,"<S2SV_StartBug> result = select ( uipc_main . max_fd + 1 , & uipc_main . read_set , NULL , NULL , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
677,<S2SV_StartBug> goto discard ; <S2SV_EndBug> ,<S2SV_ModStart> consume_skb ( skb ) ; return 0 <S2SV_ModEnd> 
678,"<S2SV_StartBug> assert ( msgnum >= 1 && msgnum <= MAX_MSIX_TABLE_ENTRIES ) ; <S2SV_EndBug> <S2SV_StartBug> pci_msix_table_init ( dev , msgnum ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( msgnum > MAX_MSIX_TABLE_ENTRIES ) { pr_err ( ""%s:<S2SV_blank>Too<S2SV_blank>many<S2SV_blank>entries!\\n"" , __func__ ) ; return - 1 ; } <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModStart> != 0 ) return - 1 "
679,<S2SV_StartBug> upperdentry = ovl_dentry_upper ( dentry ) ; <S2SV_EndBug> <S2SV_StartBug> if ( upperdentry ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ,<S2SV_ModStart> err = ovl_copy_up ( dentry ) ; if ( ! err ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
680,<S2SV_StartBug> while ( isspace ( * p ) ) <S2SV_EndBug> ,<S2SV_ModStart> ( unsigned char ) 
681,<S2SV_StartBug> if ( ! authctxt -> valid ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( b = sshbuf_new ( ) ) == NULL ) <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; goto done ; } if ( "
682,"<S2SV_StartBug> static int decode_unsigned_max ( struct vp9_read_bit_buffer * rb , int max ) { <S2SV_EndBug> <S2SV_StartBug> const int data = vp9_rb_read_literal ( rb , get_unsigned_bits ( max ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_read_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_rb_read_literal <S2SV_ModEnd> 
683,<S2SV_StartBug> for ( i = 0 ; i < ctx -> msgcount ; i ++ ) <S2SV_EndBug> ,<S2SV_ModStart> if ( strlen ( line ) == 0 ) return - 1 ; 
684,<S2SV_StartBug> goto cleanup ; <S2SV_EndBug> <S2SV_StartBug> cleanup : <S2SV_EndBug> ,<S2SV_ModStart> return retval <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
685,<S2SV_StartBug> Jpeg2000Prec * prec = band -> prec + precno ; <S2SV_EndBug> <S2SV_StartBug> av_freep ( & band -> prec ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( band -> prec ) { <S2SV_ModStart> } 
686,"<S2SV_StartBug> if ( xmlPushInput ( ctxt , input ) < 0 ) <S2SV_EndBug> ",<S2SV_ModStart> { xmlFreeInputStream ( input ) ; return ; } <S2SV_ModEnd> 
687,"<S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> err = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> ","<S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) <S2SV_ModStart> ) ; rcu_read_unlock ( <S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) , <S2SV_ModEnd> <S2SV_ModStart> ) ; rcu_read_unlock ( "
688,<S2SV_StartBug> static TX_MODE select_tx_mode ( const VP9_COMP * cpi ) { <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . lossless ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> common . current_video_frame == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . tx_size_search_method == USE_LARGESTALL ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> sf . tx_size_search_method == USE_FULL_RD ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> , MACROBLOCKD * const xd <S2SV_ModStart> xd -> lossless ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> frame_type == KEY_FRAME && cpi -> sf . use_nonrd_pick_mode ) return ALLOW_16X16 ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> || cpi -> sf . tx_size_search_method == USE_TX_8X8 ) return TX_MODE_SELECT ; else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
689,<S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) <S2SV_EndBug> <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; } <S2SV_ModEnd> <S2SV_ModStart> * num "
690,<S2SV_StartBug> } else if ( bad_format ( im -> gdes [ i ] . format ) ) { <S2SV_EndBug> <S2SV_StartBug> rrd_set_error <S2SV_EndBug> <S2SV_StartBug> if ( bad_format ( im -> gdes [ i ] . format ) ) { <S2SV_EndBug> <S2SV_StartBug> rrd_set_error <S2SV_EndBug> ,<S2SV_ModStart> bad_format_print <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> bad_format_print <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
691,<S2SV_StartBug> if ( shdr -> sh_size < 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> || shdr -> sh_size > SIZE_MAX 
692,<S2SV_StartBug> if ( buf1 -> size < buf2 -> size ) { <S2SV_EndBug> ,<S2SV_ModStart> return ( int ) ( buf2 -> size - <S2SV_ModEnd> <S2SV_ModStart> ) ; } <S2SV_ModEnd> 
693,<S2SV_StartBug> root_storage -> d_storage_uuid ) ) < 0 ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
694,<S2SV_StartBug> size_t sz = sizeof ( * info ) + size ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( sz < sizeof ( * info ) ) return NULL 
695,<S2SV_StartBug> if ( ! eof ) { <S2SV_EndBug> ,<S2SV_ModStart> && vars -> str . c != vars -> ptr 
696,"<S2SV_StartBug> if ( ! net_eq ( net , & init_net ) ) <S2SV_EndBug> ",<S2SV_ModStart> protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if ( 
697,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
698,<S2SV_StartBug> ctxt -> _eip = ctxt -> src . val ; <S2SV_EndBug> <S2SV_StartBug> ctxt -> _eip = ctxt -> src . val ; <S2SV_EndBug> ,"<S2SV_ModStart> rc = assign_eip_near ( ctxt , <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( rc != X86EMUL_CONTINUE ) break <S2SV_ModStart> rc = assign_eip_near ( ctxt , <S2SV_ModEnd> <S2SV_ModStart> ) "
699,"<S2SV_StartBug> imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ; <S2SV_EndBug> ","<S2SV_ModStart> , true "
700,"<S2SV_StartBug> void * * p , void * end , <S2SV_EndBug> <S2SV_StartBug> void * dp , * dend ; <S2SV_EndBug> <S2SV_StartBug> struct ceph_crypto_key old_key ; <S2SV_EndBug> <S2SV_StartBug> dlen = ceph_x_decrypt ( secret , p , end , dbuf , <S2SV_EndBug> <S2SV_StartBug> tp = ticket_buf ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ceph_decode_need ( p , end , dlen , bad ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dbuf = NULL ; void * <S2SV_ModStart> ; void * ticket_buf = NULL <S2SV_ModStart> & dbuf , 0 <S2SV_ModEnd> <S2SV_ModStart> if ( is_enc ) { dout ( ""<S2SV_blank>encrypted<S2SV_blank>ticket\\n"" ) ; dlen = ceph_x_decrypt ( & old_key , p , end , & ticket_buf , 0 <S2SV_ModEnd> <S2SV_ModStart> tp = ticket_buf ; <S2SV_ModStart> ticket_buf = kmalloc ( dlen , GFP_NOFS ) ; if ( ! ticket_buf ) { ret = - ENOMEM ; goto out ; } tp = ticket_buf ; <S2SV_ModStart> kfree ( ticket_buf ) ; kfree ( dbuf ) ; "
701,<S2SV_StartBug> pairs = palloc ( count * sizeof ( Pairs ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ; "
702,<S2SV_StartBug> rq -> skip_clock_update = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
703,"<S2SV_StartBug> n2l ( p , s -> session -> tlsext_tick_lifetime_hint ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( s -> session -> session_id_length > 0 ) { int i = s -> session_ctx -> session_cache_mode ; SSL_SESSION * new_sess ; if ( i & SSL_SESS_CACHE_CLIENT ) { if ( i & SSL_SESS_CACHE_NO_INTERNAL_STORE ) { if ( s -> session_ctx -> remove_session_cb != NULL ) s -> session_ctx -> remove_session_cb ( s -> session_ctx , s -> session ) ; } else { SSL_CTX_remove_session ( s -> session_ctx , s -> session ) ; } } if ( ( new_sess = ssl_session_dup ( s -> session , 0 ) ) == 0 ) { al = SSL_AD_INTERNAL_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , ERR_R_MALLOC_FAILURE ) ; goto f_err ; } SSL_SESSION_free ( s -> session ) ; s -> session = new_sess ; } "
704,"<S2SV_StartBug> r = sd_event_add_io ( b -> manager -> event , & b -> io_event_source , b -> fd , EPOLLIN , button_dispatch , b ) ; <S2SV_EndBug> ",<S2SV_ModStart> b -> io_event_source = sd_event_source_unref ( b -> io_event_source ) ; 
705,<S2SV_StartBug> if ( errors ) <S2SV_EndBug> ,<S2SV_ModStart> errors += test_float_formatting ( ) ; 
706,<S2SV_StartBug> return true ; <S2SV_EndBug> <S2SV_StartBug> return true ; <S2SV_EndBug> ,<S2SV_ModStart> ( * elem_rtrn != NULL && * field_rtrn != NULL ) <S2SV_ModEnd> <S2SV_ModStart> if ( expr -> array_ref . element != XKB_ATOM_NONE && * elem_rtrn == NULL ) return false ; if ( * field_rtrn == NULL ) return false ; 
707,<S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> ,<S2SV_ModStart> sas_eh_finish_cmd <S2SV_ModEnd> 
708,"<S2SV_StartBug> REQ ( n , funcdef ) ; <S2SV_EndBug> <S2SV_StartBug> body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( is_async ) <S2SV_EndBug> <S2SV_StartBug> return AsyncFunctionDef ( name , args , body , decorator_seq , returns , <S2SV_EndBug> <S2SV_StartBug> return FunctionDef ( name , args , body , decorator_seq , returns , <S2SV_EndBug> ","<S2SV_ModStart> node * tc ; string type_comment = NULL ; <S2SV_ModStart> if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; if ( ! type_comment ) return NULL ; name_i += 1 ; } <S2SV_ModStart> NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) { if ( type_comment != NULL ) { ast_error ( c , n , ""Cannot<S2SV_blank>have<S2SV_blank>two<S2SV_blank>type<S2SV_blank>comments<S2SV_blank>on<S2SV_blank>def"" ) ; return NULL ; } type_comment = NEW_TYPE_COMMENT ( tc ) ; if ( ! type_comment ) return NULL ; } } if ( <S2SV_ModStart> , type_comment <S2SV_ModStart> type_comment , "
709,<S2SV_StartBug> int err = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( ! net_eq ( current -> nsproxy -> net_ns , sock_net ( sk ) ) ) return - EINVAL "
710,<S2SV_StartBug> if ( likely ( walk . nbytes == nbytes ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
711,<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> msg -> msg_namelen = 0 ; 
712,"<S2SV_StartBug> if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> ",<S2SV_ModStart> 3 == <S2SV_ModStart> && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> 
713,<S2SV_StartBug> image -> columns = image -> rows = 0 ; <S2SV_EndBug> <S2SV_StartBug> BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ; <S2SV_EndBug> ,<S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
714,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> ",<S2SV_ModStart> int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> rc = <S2SV_ModStart> rc <S2SV_ModEnd> 
715,"
","
"
716,"<S2SV_StartBug> freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! res ) return - EINVAL ; 
717,"<S2SV_StartBug> if ( position > SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> <S2SV_StartBug> if ( position > psf -> headend ) <S2SV_EndBug> <S2SV_StartBug> psf -> headend += psf_fread ( psf -> header + psf -> headend , 1 , position - psf -> headend , psf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( psf -> headindex + position < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( psf -> headindex >= SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> <S2SV_StartBug> if ( psf -> headindex + position <= psf -> headend ) <S2SV_EndBug> <S2SV_StartBug> if ( psf -> headindex + position > SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> <S2SV_StartBug> psf -> headindex = psf -> headend ; <S2SV_EndBug> <S2SV_StartBug> psf -> headend += psf_fread ( psf -> header + psf -> headend , 1 , position - ( psf -> headend - psf -> headindex ) , psf ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex = psf -> headend ; <S2SV_EndBug> ","<S2SV_ModStart> psf -> header . indx + position >= psf -> header . len ) psf_bump_header_allocation ( psf , position ) ; if ( position > psf -> header . len <S2SV_ModEnd> <S2SV_ModStart> header . end ) psf -> header . end <S2SV_ModEnd> <S2SV_ModStart> . ptr + psf -> header . end <S2SV_ModEnd> <S2SV_ModStart> header . end , psf ) ; psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . indx + position >= psf -> header . len ) psf_bump_header_allocation ( psf , position ) ; if ( psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . indx >= psf -> header . len <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . end ) { psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> psf -> header . len ) { psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . end <S2SV_ModEnd> <S2SV_ModStart> header . end <S2SV_ModEnd> <S2SV_ModStart> . ptr + psf -> header . end <S2SV_ModEnd> <S2SV_ModStart> header . end <S2SV_ModEnd> <S2SV_ModStart> header . indx ) , psf ) ; psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . end <S2SV_ModEnd> "
718,"<S2SV_StartBug> truncate_pagecache ( inode , ioffset ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> goto out_dio ; <S2SV_EndBug> <S2SV_StartBug> out_dio : <S2SV_EndBug> ",<S2SV_ModStart> ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> out_mmap <S2SV_ModEnd> <S2SV_ModStart> out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModEnd> 
719,"<S2SV_StartBug> uint32_t track_size ; <S2SV_EndBug> <S2SV_StartBug> track_delta = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_EndBug> <S2SV_StartBug> track_size = * midi_data ++ << 24 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ << 16 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ << 8 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( midi_size < track_size ) { <S2SV_EndBug> <S2SV_StartBug> if ( track_size < 3 ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( midi_data [ track_size - 3 ] != 0xFF ) <S2SV_EndBug> <S2SV_StartBug> || ( midi_data [ track_size - 2 ] != 0x2F ) <S2SV_EndBug> <S2SV_StartBug> || ( midi_data [ track_size - 1 ] != 0x00 ) ) { <S2SV_EndBug> <S2SV_StartBug> midi_data += track_size ; <S2SV_EndBug> <S2SV_StartBug> midi_size -= track_size ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> goto NEXT_TRACK ; <S2SV_EndBug> <S2SV_StartBug> if ( * tracks [ i ] > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( * tracks [ i ] > 0x7f ) ; <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( * tracks [ i ] > 0x7f ) ; <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( mdi -> reverb ) return ( mdi ) ; <S2SV_EndBug> ","<S2SV_ModStart> uint8_t * * tracks ; uint32_t * track_size <S2SV_ModEnd> <S2SV_ModStart> track_size = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> track_size [ i ] = tmp_val ; midi_data += tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> track_size [ i ] -- ; <S2SV_ModStart> ; track_size [ i ] -- <S2SV_ModStart> track_size [ i ] , <S2SV_ModStart> track_size [ i ] -= 3 ; <S2SV_ModStart> track_size [ i ] -= setup_ret ; <S2SV_ModStart> if ( ! track_size [ i ] ) break ; <S2SV_ModStart> track_size [ i ] -- ; <S2SV_ModStart> if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_ModStart> ; track_size [ i ] -- <S2SV_ModStart> track_size [ i ] , <S2SV_ModStart> track_size [ i ] -= setup_ret ; <S2SV_ModStart> if ( ! track_size [ i ] ) break ; <S2SV_ModStart> track_size [ i ] -- ; <S2SV_ModStart> if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_ModStart> ; track_size [ i ] -- <S2SV_ModStart> free ( track_size ) ; "
720,"<S2SV_StartBug> sk -> sk_sndbuf = max_t ( u32 , val * 2 , SOCK_MIN_SNDBUF ) ; <S2SV_EndBug> <S2SV_StartBug> sk -> sk_rcvbuf = max_t ( u32 , val * 2 , SOCK_MIN_RCVBUF ) ; <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int <S2SV_ModEnd> 
721,<S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> lvd = ( struct logicalVolDesc * ) bh -> b_data ; <S2SV_EndBug> <S2SV_StartBug> i < sbi -> s_partitions && offset < le32_to_cpu ( lvd -> mapTableLength ) ; <S2SV_EndBug> ,"<S2SV_ModStart> unsigned int table_len ; <S2SV_ModStart> table_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) { udf_err ( sb , ""error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>"" ""Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\n"" , table_len , sb -> s_blocksize - sizeof ( * lvd ) ) ; goto out_bh ; } <S2SV_ModStart> table_len <S2SV_ModEnd> "
722,"<S2SV_StartBug> if ( optstr ) { <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" <S2SV_EndBug> <S2SV_StartBug> ""mincolors<S2SV_blank>%d\\n"" , info -> len , info -> width , info -> height , info -> numplanes , <S2SV_EndBug> <S2SV_StartBug> info -> depth , info -> enctype , info -> siz , info -> hres , info -> vres , <S2SV_EndBug> <S2SV_StartBug> info -> numcolors , info -> mincolors ) ) ; <S2SV_EndBug> <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> <S2SV_StartBug> jas_image_destroy ( image ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> ","<S2SV_ModStart> image = 0 ; info = 0 ; <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%ld;<S2SV_blank>width<S2SV_blank>%ld;<S2SV_blank>height<S2SV_blank>%ld;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%ld;<S2SV_blank>siz<S2SV_blank>%ld;<S2SV_blank>hres<S2SV_blank>%ld;<S2SV_blank>vres<S2SV_blank>%ld;<S2SV_blank>numcolors<S2SV_blank>%ld;<S2SV_blank>"" ""mincolors<S2SV_blank>%ld\\n"" , JAS_CAST ( long <S2SV_ModEnd> <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long , <S2SV_ModEnd> <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long , <S2SV_ModEnd> <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) ; if ( info -> width < 0 || info -> height < 0 || info -> numplanes < 0 || info -> depth < 0 || info -> siz < 0 || info -> hres < 0 || info -> vres < 0 ) { jas_eprintf ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\n"" ) ; goto error ; } <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error ; } <S2SV_ModStart> return image ; error : if ( info ) { bmp_info_destroy ( info ) ; } if ( image ) { <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> "
723,"<S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> <S2SV_StartBug> dev_name ( & qedi -> pdev -> dev ) , nfunc , line , <S2SV_EndBug> <S2SV_StartBug> pr_notice ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> 
724,<S2SV_StartBug> return ( ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ps_cabac -> u4_ofst >= ps_cabac -> u4_range ) { return ( ( IHEVCD_ERROR_T ) IHEVCD_FAIL ) ; } 
725,"<S2SV_StartBug> save_text_from_text_view ( g_tv_comment , FILENAME_COMMENT ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; problem_data_reload_from_dump_dir ( ) ; update_gui_state_from_problem_data ( 0 
726,"<S2SV_StartBug> media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ; <S2SV_EndBug> <S2SV_StartBug> media_device_kpad_to_upad ( entity -> links [ l ] . source , <S2SV_EndBug> ","<S2SV_ModStart> memset ( & pad , 0 , sizeof ( pad ) ) ; <S2SV_ModStart> memset ( & link , 0 , sizeof ( link ) ) ; "
727,"<S2SV_StartBug> && ( CH ( off ) == _T ( '=' ) || CH ( off ) == _T ( '-' ) ) <S2SV_EndBug> <S2SV_StartBug> if ( line -> indent < ctx -> code_indent_offset && ISANYOF ( off , _T ( ""-_*"" ) ) && off >= hr_killer ) { <S2SV_EndBug> <S2SV_StartBug> ( container . ch == _T ( '.' ) || container . ch == _T ( ')' ) ) && container . start != 1 ) <S2SV_EndBug> <S2SV_StartBug> if ( line -> indent < ctx -> code_indent_offset && CH ( off ) == _T ( '#' ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( CH ( off ) == _T ( '`' ) || CH ( off ) == _T ( '~' ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( ctx -> parser . flags & MD_FLAG_TABLES ) && pivot_line -> type == MD_LINE_TEXT && <S2SV_EndBug> <S2SV_StartBug> ( CH ( off ) == _T ( '|' ) || CH ( off ) == _T ( '-' ) || CH ( off ) == _T ( ':' ) ) && <S2SV_EndBug> ","<S2SV_ModStart> off < ctx -> size && ISANYOF2 ( off , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> && off < ctx -> size <S2SV_ModEnd> <S2SV_ModStart> && ISANYOF ( off , _T ( ""-_*"" ) ) ) <S2SV_ModEnd> <S2SV_ModStart> ISANYOF2_ <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> off < ctx -> size && <S2SV_ModStart> off < ctx -> size && ISANYOF2 ( off , _T ( '`' ) , _T ( '~' ) ) ) { if ( md_is_opening_code_fence ( ctx , off , & off ) ) { line -> type = MD_LINE_FENCEDCODE ; line -> data = 1 ; break ; } } if ( off < ctx -> size && <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && off < ctx -> size && ISANYOF3 ( off , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> "
728,"<S2SV_StartBug> height , <S2SV_EndBug> <S2SV_StartBug> if ( bytes_per_line == 0 ) <S2SV_EndBug> <S2SV_StartBug> bytes_per_line = image -> columns ; <S2SV_EndBug> <S2SV_StartBug> length = image -> rows * ( image -> columns + image -> columns % 2 ) ; <S2SV_EndBug> <S2SV_StartBug> SetPixelIndex ( image , * p ++ , q ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( image -> columns % 2 ) != 0 ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , <S2SV_ModEnd> <S2SV_ModStart> , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) <S2SV_ModEnd> <S2SV_ModStart> ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( <S2SV_ModEnd> <S2SV_ModStart> != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns <S2SV_ModEnd> <S2SV_ModStart> if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } <S2SV_ModStart>  <S2SV_ModEnd> "
729,"<S2SV_StartBug> krb5_principal client_principal , <S2SV_EndBug> <S2SV_StartBug> krb5_principal_get_realm ( context , krbtgt -> entry . principal ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> , const char * tgt_realm <S2SV_ModStart> tgt_realm <S2SV_ModEnd> "
730,<S2SV_StartBug> if ( bmp_info . number_colors > GetBlobSize ( image ) ) <S2SV_EndBug> <S2SV_StartBug> * magick = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> if ( bmp_info . ba_offset != 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( offset < 0 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> ( MagickSizeType ) <S2SV_ModStart> offset = ( MagickOffsetType ) <S2SV_ModEnd> <S2SV_ModStart> ; if ( offset <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) <S2SV_ModEnd> <S2SV_ModStart> * magick = '\\0' ; <S2SV_ModEnd> "
731,<S2SV_StartBug> newinet -> opt = ireq -> opt ; <S2SV_EndBug> ,<S2SV_ModStart> inet_opt <S2SV_ModEnd> 
732,<S2SV_StartBug> data -> l_head = NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> "
733,"<S2SV_StartBug> if ( offset != 0 ) <S2SV_EndBug> <S2SV_StartBug> csum_partial ( skb_transport_header ( skb ) + tlen , <S2SV_EndBug> <S2SV_StartBug> offset , 0 ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> { int tend_off = skb_transport_offset ( skb ) + tlen ; <S2SV_ModStart> skb_checksum ( skb , tend_off , <S2SV_ModEnd> <S2SV_ModStart> } "
734,"<S2SV_StartBug> goto unmap_pages ; <S2SV_EndBug> <S2SV_StartBug> kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn ) ; <S2SV_EndBug> ","<S2SV_ModStart> kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_ModStart> - slot -> base_gfn "
735,"<S2SV_StartBug> memcpy ( & b [ 4 ] , cmd -> msg , cmd -> msg_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( cmd -> msg_len > sizeof ( b ) - 4 ) return - EINVAL ; 
736,<S2SV_StartBug> struct perf_event_context * ctx = event -> ctx ; <S2SV_EndBug> <S2SV_StartBug> event -> state = PERF_EVENT_STATE_OFF ; <S2SV_EndBug> ,"<S2SV_ModStart> ; ctx = perf_event_ctx_lock <S2SV_ModEnd> <S2SV_ModStart> _perf_event_disable ( event ) ; perf_event_ctx_unlock ( event , ctx <S2SV_ModEnd> "
737,<S2SV_StartBug> value = ( unsigned int ) ( ( buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) | <S2SV_EndBug> <S2SV_StartBug> ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned int ) ( value & 0xffffffff ) ) ; <S2SV_EndBug> <S2SV_StartBug> value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ) | ( buffer [ 1 ] << 16 ) | <S2SV_EndBug> <S2SV_StartBug> ( buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned int ) ( value & 0xffffffff ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
738,<S2SV_StartBug> struct free_nid * i ; <S2SV_EndBug> <S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> if ( build ) { <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> ,"<S2SV_ModStart> , * e <S2SV_ModStart> = - EINVAL ; bool ret = false <S2SV_ModStart> i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) goto err ; spin_lock ( & nm_i -> nid_list_lock ) ; <S2SV_ModStart> goto err_out ; e = __lookup_free_nid_list ( nm_i , nid ) ; if ( e ) { if ( e -> state == NID_NEW ) ret = true ; goto err_out ; } } ret = true ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; err_out : spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; err : if ( err ) kmem_cache_free ( free_nid_slab , i ) ; return ret <S2SV_ModEnd> "
739,<S2SV_StartBug> # if CONFIG_POSTPROC_VISUALIZER <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_POSTPROC_VISUALIZER <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
740,"<S2SV_StartBug> netdev_dbg ( vif -> dev , ""Missing<S2SV_blank>extra<S2SV_blank>info\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , <S2SV_EndBug> <S2SV_StartBug> ""Invalid<S2SV_blank>extra<S2SV_blank>type:<S2SV_blank>%d\\n"" , extra . type ) ; <S2SV_EndBug> ",<S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif 
741,"<S2SV_StartBug> pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; <S2SV_EndBug> ",<S2SV_ModStart> hdr -> sadb_msg_reserved = 0 ; 
742,<S2SV_StartBug> r1 . event = event ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & r1 , 0 , sizeof ( r1 ) ) ; "
743,"<S2SV_StartBug> defaultoptions ( & h ) ; <S2SV_EndBug> <S2SV_StartBug> luaL_checkstack ( L , 1 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pushnumber ( L , res ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pushnumber ( L , f ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pushnumber ( L , d ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! lua_isnumber ( L , - 1 ) ) <S2SV_EndBug> <S2SV_StartBug> luaL_error ( L , ""format<S2SV_blank>`c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pop ( L , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pushlstring ( L , data + pos , size ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pushlstring ( L , data + pos , size - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> return lua_gettop ( L ) - 2 ; <S2SV_EndBug> ","<S2SV_ModStart> int n = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 2 <S2SV_ModEnd> <S2SV_ModStart> n ++ ; <S2SV_ModStart> n ++ ; <S2SV_ModStart> n ++ ; <S2SV_ModStart> n == 0 || <S2SV_ModStart> ""format<S2SV_blank>\'c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" <S2SV_ModEnd> <S2SV_ModStart> n -- ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && pos <= ld - size , <S2SV_ModEnd> <S2SV_ModStart> ; n ++ <S2SV_ModStart> n ++ ; <S2SV_ModStart> n + 1 <S2SV_ModEnd> "
744,"<S2SV_StartBug> ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> u_int name_entries = EXTRACT_16BITS ( msg_data + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> u_int addr_size = 4 ; <S2SV_EndBug> <S2SV_StartBug> int name_entries_valid = 0 ; <S2SV_EndBug> <S2SV_StartBug> name_entries_valid = 1 ; <S2SV_EndBug> ","<S2SV_ModStart> if ( is_ipv6 ) { <S2SV_ModStart> olsr_msg6 ) ) ; <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_ModStart> ; u_int addr_size ; int name_entries_valid ; u_int i ; if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entries <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( is_ipv6 ) addr_size = 16 ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
745,<S2SV_StartBug> int n ; <S2SV_EndBug> <S2SV_StartBug> if ( ! body -> unit_size ) <S2SV_EndBug> <S2SV_StartBug> n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) <S2SV_EndBug> ,<S2SV_ModStart> unsigned <S2SV_ModStart> || len < sizeof ( struct oz_multiple_fixed ) - 1 <S2SV_ModStart> ( <S2SV_ModStart> - 1 ) <S2SV_ModEnd> 
746,<S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
747,"<S2SV_StartBug> fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> int rv = copy_file ( src , dest ) ; <S2SV_EndBug> <S2SV_StartBug> if ( chown ( dest , getuid ( ) , getgid ( ) ) == - 1 ) <S2SV_EndBug> ","<S2SV_ModStart> ""Warning:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\n"" ) ; return 0 ; } copy_file_as_user <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , 0600 ) ; fs_logger2 ( ""clone"" , dest <S2SV_ModEnd> "
748,<S2SV_StartBug> idata -> status = IMAP_FATAL ; <S2SV_EndBug> ,"<S2SV_ModStart> ; return ; } if ( strlen ( idata -> buf ) < litlen ) { mutt_debug ( 1 , ""Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>mailbox\\n"" ) "
749,"<S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_PROBE ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
750,"<S2SV_StartBug> if ( unlikely ( path [ depth ] . p_ext > EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) ) { <S2SV_EndBug> <S2SV_StartBug> ext4_extent_block_csum_set ( inode , neh ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_extent_block_csum_set ( inode , neh ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t ext_size = 0 ; <S2SV_ModStart> ext_size = sizeof ( struct ext4_extent_header ) + sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ; <S2SV_ModStart> ext_size = sizeof ( struct ext4_extent_header ) + ( sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ; "
751,<S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p3 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p3 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } 
752,<S2SV_StartBug> cmap_len = get_ushort ( & tga [ 5 ] ) ; <S2SV_EndBug> <S2SV_StartBug> x_origin = get_ushort ( & tga [ 8 ] ) ; <S2SV_EndBug> <S2SV_StartBug> y_origin = get_ushort ( & tga [ 10 ] ) ; <S2SV_EndBug> <S2SV_StartBug> image_w = get_ushort ( & tga [ 12 ] ) ; <S2SV_EndBug> <S2SV_StartBug> image_h = get_ushort ( & tga [ 14 ] ) ; <S2SV_EndBug> ,<S2SV_ModStart> get_tga_ushort <S2SV_ModEnd> <S2SV_ModStart> get_tga_ushort <S2SV_ModEnd> <S2SV_ModStart> get_tga_ushort <S2SV_ModEnd> <S2SV_ModStart> get_tga_ushort <S2SV_ModEnd> <S2SV_ModStart> get_tga_ushort <S2SV_ModEnd> 
753,<S2SV_StartBug> ssize_t ret ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES 
754,"<S2SV_StartBug> if ( CPUCLOCK_WHICH ( which_clock ) == CPUCLOCK_SCHED ) { <S2SV_EndBug> <S2SV_StartBug> tp -> tv_sec = div_long_long_rem ( cpu . sched , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> * tp = ns_to_timespec <S2SV_ModEnd> <S2SV_ModStart> ) ; else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
755,<S2SV_StartBug> uint32 nstrips ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
756,"<S2SV_StartBug> rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , size , msg_flags , timeo ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
757,"<S2SV_StartBug> const lua_authz_provider_spec * prov_spec = parsed_require_line ; <S2SV_EndBug> <S2SV_StartBug> if ( prov_spec -> args ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! lua_checkstack ( L , prov_spec -> args -> nelts ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < prov_spec -> args -> nelts ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> const char * arg = APR_ARRAY_IDX ( prov_spec -> args , i , const char * ) ; <S2SV_EndBug> <S2SV_StartBug> nargs = prov_spec -> args -> nelts ; <S2SV_EndBug> ",<S2SV_ModStart> lua_authz_provider_func * prov_func = parsed_require_line ; const <S2SV_ModStart> prov_func -> spec <S2SV_ModEnd> <S2SV_ModStart> prov_func <S2SV_ModEnd> <S2SV_ModStart> prov_func <S2SV_ModEnd> <S2SV_ModStart> prov_func <S2SV_ModEnd> <S2SV_ModStart> prov_func <S2SV_ModEnd> <S2SV_ModStart> prov_func <S2SV_ModEnd> 
758,<S2SV_StartBug> int error ; <S2SV_EndBug> <S2SV_StartBug> error = security_mmap_addr ( address ) ; <S2SV_EndBug> ,<S2SV_ModStart> = 0 <S2SV_ModStart> if ( address < mmap_min_addr ) return - EPERM <S2SV_ModEnd> 
759,"<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
760,"<S2SV_StartBug> const char * data , int optional ) <S2SV_EndBug> <S2SV_StartBug> if ( mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data ) ) { <S2SV_EndBug> <S2SV_StartBug> mountflags | MS_REMOUNT , data ) ) { <S2SV_EndBug> ","<S2SV_ModStart> , const char * rootfs <S2SV_ModStart> safe_mount <S2SV_ModEnd> <S2SV_ModStart> , rootfs <S2SV_ModStart> < 0 "
761,<S2SV_StartBug> return ( GetFirstImageInList ( image ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList "
762,<S2SV_StartBug> timr -> it_overrun = - 1 ; <S2SV_EndBug> <S2SV_StartBug> info -> si_overrun += timr -> it_overrun_last ; <S2SV_EndBug> ,"<S2SV_ModStart> 1LL <S2SV_ModEnd> <S2SV_ModStart> = timer_overrun_to_int ( timr , info -> si_overrun ) <S2SV_ModEnd> "
763,<S2SV_StartBug> if ( ! proto_end ) <S2SV_EndBug> ,"<S2SV_ModStart> { if ( ! quiet ) warning ( _ ( ""url<S2SV_blank>has<S2SV_blank>no<S2SV_blank>scheme:<S2SV_blank>%s"" ) , url ) ; return - 1 ; } <S2SV_ModEnd> "
764,<S2SV_StartBug> struct static_key * done_key ) <S2SV_EndBug> <S2SV_StartBug> __net_random_once_disable_jump ( done_key ) ; <S2SV_EndBug> ,<S2SV_ModStart> once_key <S2SV_ModEnd> <S2SV_ModStart> once_key <S2SV_ModEnd> 
765,"<S2SV_StartBug> if ( io_data -> read && ret > 0 ) { <S2SV_EndBug> <S2SV_StartBug> ! ( io_data -> kiocb -> ki_flags & IOCB_EVENTFD ) ) <S2SV_EndBug> <S2SV_StartBug> usb_ep_free_request ( io_data -> ep , io_data -> req ) ; <S2SV_EndBug> ","<S2SV_ModStart> bool kiocb_has_eventfd = <S2SV_ModEnd> <S2SV_ModStart> ; if ( io_data -> read && ret > 0 ) { use_mm ( io_data -> mm ) ; ret = copy_to_iter ( io_data -> buf , ret , & io_data -> data ) ; if ( iov_iter_count ( & io_data -> data ) ) ret = - EFAULT ; unuse_mm ( io_data -> mm ) ; } io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ; if ( io_data -> ffs -> ffs_eventfd && ! kiocb_has_eventfd <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
766,<S2SV_StartBug> if ( rt -> rt_flags & RTCF_DOREDIRECT && ! opt -> srr && ! skb_sec_path ( skb ) ) <S2SV_EndBug> ,<S2SV_ModStart> IPCB ( skb ) -> flags & IPSKB_DOREDIRECT <S2SV_ModEnd> 
767,<S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
768,<S2SV_StartBug> struct trusted_key_payload * p = key -> payload . data [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> struct trusted_key_payload * new_p ; <S2SV_EndBug> ,"<S2SV_ModStart> p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY ; <S2SV_ModStart>  <S2SV_ModEnd> "
769,<S2SV_StartBug> v |= ( c << 24 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> JAS_CAST ( uint_fast32_t , c ) <S2SV_ModEnd> "
770,<S2SV_StartBug> while ( ( skb = skb_dequeue ( & loopback_queue ) ) != NULL ) { <S2SV_EndBug> <S2SV_StartBug> dest = ( rose_address * ) ( skb -> data + 4 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( skb -> len < ROSE_MIN_LEN ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> if ( frametype == ROSE_CALL_REQUEST && ( skb -> len <= ROSE_CALL_REQ_FACILITIES_OFF || skb -> data [ ROSE_CALL_REQ_ADDR_LEN_OFF ] != ROSE_CALL_REQ_ADDR_LEN_VAL ) ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> ROSE_CALL_REQ_DEST_ADDR_OFF <S2SV_ModEnd> 
771,"<S2SV_StartBug> kvm_arch_flush_shadow_memslot ( kvm , slot ) ; <S2SV_EndBug> <S2SV_StartBug> goto out_free ; <S2SV_EndBug> <S2SV_StartBug> if ( ! npages ) { <S2SV_EndBug> <S2SV_StartBug> out_free : <S2SV_EndBug> ","<S2SV_ModStart> kvm_iommu_unmap_pages ( kvm , & old ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_slots ; } if ( <S2SV_ModStart> out_slots : kfree ( slots ) ; "
772,<S2SV_StartBug> if ( indev != NULL ) { <S2SV_EndBug> ,<S2SV_ModStart> && indev -> ifa_list <S2SV_ModEnd> 
773,"<S2SV_StartBug> end = path ; <S2SV_EndBug> <S2SV_StartBug> switch ( tag ) { <S2SV_EndBug> <S2SV_StartBug> name = fdt_get_name ( fdt , offset , & len ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ",<S2SV_ModStart> bool expect_end = false ; <S2SV_ModStart> if ( expect_end && tag != FDT_END ) return - FDT_ERR_BADLAYOUT ; <S2SV_ModStart> ; if ( ! depth && * name ) return - FDT_ERR_BADLAYOUT <S2SV_ModStart> if ( depth == - 1 ) expect_end = true ; 
774,<S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff "
775,<S2SV_StartBug> if ( md_sk != NULL ) { <S2SV_EndBug> <S2SV_StartBug> if ( PKCS7_is_detached ( p7 ) || ( in_bio != NULL ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> data_body == NULL && in_bio == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; goto err ; } if ( <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
776,<S2SV_StartBug> if ( vmCanSwapOut ( ) ) { <S2SV_EndBug> <S2SV_StartBug> while ( server . vm_enabled && zmalloc_used_memory ( ) > <S2SV_EndBug> <S2SV_StartBug> server . vm_max_memory ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ds_enabled <S2SV_ModEnd> <S2SV_ModStart> cache_max_memory ) { cacheFreeOneEntry ( ) ; <S2SV_ModEnd> 
777,<S2SV_StartBug> if ( ( options -> flags & UV_PROCESS_SETGID ) && setgid ( options -> gid ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> options -> flags & ( UV_PROCESS_SETUID | UV_PROCESS_SETGID ) ) { SAVE_ERRNO ( setgroups ( 0 , NULL ) ) ; } if ( "
778,"<S2SV_StartBug> int ret , wo ; <S2SV_EndBug> <S2SV_StartBug> wo = ( rbuf == NULL || rlen == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( wo ) <S2SV_EndBug> <S2SV_StartBug> rbuf , rlen , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( rlen > MAX_XFER_SIZE ) { warn ( ""i2c<S2SV_blank>rd:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\n"" , rlen ) ; return - EOPNOTSUPP ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> st -> data <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( ! ret && rbuf && rlen ) memcpy ( rbuf , st -> data , rlen "
779,"<S2SV_StartBug> client -> priv -> protocol_timeout = g_timeout_add_seconds ( 5 , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
780,<S2SV_StartBug> for ( j = 0 ; j < book -> dim ; j ++ ) <S2SV_EndBug> ,<S2SV_ModStart> && i < n 
781,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> char * outpos = outputbuffer ; <S2SV_ModStart> sendClean ( outputbuffer ) ; 
782,<S2SV_StartBug> BUG_ON ( ret == - EEXIST ) ; <S2SV_EndBug> ,<S2SV_ModStart> || ret == - EOVERFLOW 
783,<S2SV_StartBug> if ( s ) { <S2SV_EndBug> <S2SV_StartBug> struct unix_sock * u = unix_sk ( s ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock ( & unix_gc_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> spin_lock ( & unix_gc_lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } fp -> f_cred -> user -> unix_inflight -- ; <S2SV_ModStart>  <S2SV_ModEnd> 
784,<S2SV_StartBug> { size_t chanmap_size = psf -> sf . channels * sizeof ( psf -> channel_map [ 0 ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> SF_MIN ( <S2SV_ModStart> , layout_tag & 0xffff ) "
785,"<S2SV_StartBug> if ( ! check_scale_factors ( other_w , other_h , this_w , this_h ) ) { <S2SV_EndBug> <S2SV_StartBug> sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve_copy ; <S2SV_EndBug> <S2SV_StartBug> sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve8_vert ; <S2SV_EndBug> <S2SV_StartBug> sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve8_horiz ; <S2SV_EndBug> <S2SV_StartBug> sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve8 ; <S2SV_EndBug> ",<S2SV_ModStart> # endif <S2SV_ModStart> valid_ref_frame_size <S2SV_ModEnd> <S2SV_ModStart> vpx_convolve_copy ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_convolve_avg ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_convolve8_vert ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_convolve8_avg_vert ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_convolve8_horiz ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_convolve8_avg_horiz <S2SV_ModEnd> <S2SV_ModStart> vpx_scaled_vert ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_vert ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_vert ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_vert ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d <S2SV_ModEnd> <S2SV_ModStart> vpx_scaled_horiz ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_horiz ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_horiz ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_horiz <S2SV_ModEnd> <S2SV_ModStart> vpx_scaled_2d ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d ; } } if ( ( sf -> x_step_q4 != 16 ) || ( sf -> y_step_q4 != 16 ) ) { sf -> predict [ 1 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; } else { sf -> predict [ 1 ] [ 1 ] [ 0 ] = vpx_convolve8 ; sf -> predict [ 1 ] [ 1 ] [ 1 ] = vpx_convolve8_avg ; } # if CONFIG_VP9_HIGHBITDEPTH if ( use_highbd ) { if ( sf -> x_step_q4 == 16 ) { if ( sf -> y_step_q4 == 16 ) { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve_copy ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve_avg ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; } else { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; } } else { if ( sf -> y_step_q4 == 16 ) { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; } else { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; } } sf -> highbd_predict [ 1 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; } # endif <S2SV_ModEnd> 
786,<S2SV_StartBug> int32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ; <S2SV_EndBug> ,<S2SV_ModStart> uint32_t <S2SV_ModEnd> <S2SV_ModStart> uint32_t <S2SV_ModEnd> 
787,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
788,<S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ip6t_entry ) && <S2SV_EndBug> <S2SV_StartBug> t -> verdict < 0 && <S2SV_EndBug> ,<S2SV_ModStart> unconditional ( e <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
789,"<S2SV_StartBug> pdf -> xrefs = calloc ( 1 , sizeof ( xref_t ) * pdf -> n_xrefs ) ; <S2SV_EndBug> ",<S2SV_ModStart> safe_calloc ( <S2SV_ModEnd> 
790,<S2SV_StartBug> if ( ! sock || ( count && ! buf ) ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ,<S2SV_ModStart> || count > OE_SSIZE_MAX <S2SV_ModStart> if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } 
791,"<S2SV_StartBug> opt = xchg ( & np -> opt , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt ) <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ( __force struct ipv6_txoptions * * ) <S2SV_ModStart> { atomic_sub ( <S2SV_ModEnd> <S2SV_ModStart> , & sk -> sk_omem_alloc ) ; txopt_put ( opt <S2SV_ModStart> } "
792,"<S2SV_StartBug> BIO * cmsbio = NULL , * tmpin = NULL ; <S2SV_EndBug> <S2SV_StartBug> cmsbio = CMS_dataInit ( cms , tmpin ) ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( dcont && ( tmpin == dcont ) ) <S2SV_EndBug> <S2SV_StartBug> if ( cms_certs ) <S2SV_EndBug> ","<S2SV_ModStart> = NULL , * tmpout <S2SV_ModStart> if ( ! ( flags & SMIME_BINARY ) && dcont ) { tmpout = cms_get_text_bio ( out , flags ) ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } <S2SV_ModStart> tmpout ) ; if ( ! cmsbio ) goto err ; SMIME_crlf_copy ( dcont , cmsbio , flags & ~ SMIME_TEXT ) ; if ( flags & CMS_TEXT ) { if ( ! SMIME_text ( tmpout , out ) ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SMIME_TEXT_ERROR ) ; goto err ; } } } else { cmsbio = CMS_dataInit ( cms , <S2SV_ModStart> } <S2SV_ModStart> ! ( flags & SMIME_BINARY ) && dcont ) { do_free_upto ( cmsbio , tmpout ) ; if ( tmpin != dcont ) BIO_free ( tmpin ) ; } else { if ( <S2SV_ModStart> } if ( tmpout && out != tmpout ) BIO_free_all ( tmpout ) ; "
793,"<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> len = ipv6_getsockopt_sticky ( sk , np -> opt , <S2SV_EndBug> ","<S2SV_ModStart> struct ipv6_txoptions * opt ; <S2SV_ModStart> opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
794,<S2SV_StartBug> unregister_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> <S2SV_StartBug> sctp_v4_protosw_exit ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> sctp_ctrlsock_ops <S2SV_ModEnd> <S2SV_ModStart> ) ; unregister_pernet_subsys ( & sctp_defaults_ops 
795,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> add_bool_conf_item ( ""ANOPE_FLAGS_COMPAT"" , & chansvs . me -> conf_table , 0 , & anope_flags_compat , true ) ; hook_add_event ( ""nick_can_register"" ) ; hook_add_nick_can_register ( check_registration_keywords ) ; hook_add_event ( ""user_can_register"" ) ; hook_add_user_can_register ( check_registration_keywords ) ; "
796,"<S2SV_StartBug> struct net_device * dev = ( ( struct in_ifaddr * ) ptr ) -> ifa_dev -> dev ; <S2SV_EndBug> <S2SV_StartBug> netdev_notifier_info_init ( & info , dev ) ; <S2SV_EndBug> ",<S2SV_ModStart> in_device * idev <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( idev -> dead ) return NOTIFY_DONE ; <S2SV_ModStart> idev -> 
797,<S2SV_StartBug> if ( current -> active_mm != mm ) <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> ,<S2SV_ModStart> { smp_mb ( ) ; <S2SV_ModStart> } <S2SV_ModStart> smp_mb ( ) ; 
798,"<S2SV_StartBug> static void show_psnr ( struct stream_state * stream ) { <S2SV_EndBug> <S2SV_StartBug> ovpsnr = sse_to_psnr ( ( double ) stream -> psnr_samples_total , 255.0 , <S2SV_EndBug> ","<S2SV_ModStart> , double peak <S2SV_ModStart> peak <S2SV_ModEnd> "
799,<S2SV_StartBug> char temp [ 500 ] ; <S2SV_EndBug> <S2SV_StartBug> temp [ i ] = fgetc ( fp ) ; <S2SV_EndBug> ,"<S2SV_ModStart> int temp_size = 500 ; char * temp = malloc ( temp_size ) <S2SV_ModEnd> <S2SV_ModStart> if ( i >= temp_size ) { temp_size *= 2 ; temp = realloc ( temp , temp_size ) ; } "
800,<S2SV_StartBug> if ( ! del_timer ( & task -> slow_task -> timer ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
801,<S2SV_StartBug> dst_name = malloc ( strlen ( name ) * 2 + 16 ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
802,"<S2SV_StartBug> assert ( errno == ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> ""for<S2SV_blank>management<S2SV_blank>address"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; else log_warn ( ""lldp"" , ""too<S2SV_blank>large<S2SV_blank>management<S2SV_blank>address<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname "
803,<S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> <S2SV_StartBug> if ( * object + size * 2 > bplist -> offset_table ) { <S2SV_EndBug> <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> ,"<S2SV_ModStart> < * object || * object + size <S2SV_ModStart> * object + size < * object || <S2SV_ModStart> < * object || * object + size * 2 <S2SV_ModStart> < * object || * object + size <S2SV_ModStart> < * object || * object + size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DICT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" <S2SV_ModEnd> "
804,"<S2SV_StartBug> TRACE_DEBUG ( ""CIDER=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_CIDER ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""PHY1ILR=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_PHY1ILR ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""PHY1IHR=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_PHY1IHR ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ksz8851ReadReg ( interface , KSZ8851_REG_CIDER ) != KSZ8851_REV_A3_ID ) <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MARH , htons ( interface -> macAddr . w [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MARM , htons ( interface -> macAddr . w [ 1 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MARL , htons ( interface -> macAddr . w [ 2 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_TXCR , TXCR_TXFCE | TXCR_TXPE | TXCR_TXCE ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851ClearBit ( interface , KSZ8851_REG_P1CR , P1CR_FORCE_DUPLEX ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_P1CR , P1CR_RESTART_AN ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_ISR , ISR_LCIS | ISR_TXIS | <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_IER , IER_LCIE | IER_TXIE | IER_RXIE ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_TXCR , TXCR_TXE ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXCR1 , RXCR1_RXE ) ; <S2SV_EndBug> ","<S2SV_ModStart> KSZ8851_CIDER <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_PHY1ILR <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_PHY1IHR <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_CIDER ) != ( KSZ8851_CIDER_FAMILY_ID_DEFAULT | KSZ8851_CIDER_CHIP_ID_DEFAULT | KSZ8851_CIDER_REV_ID_A3 ) <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_MARH <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_MARM <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_MARL <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_TXCR , KSZ8851_TXCR_TXFCE | KSZ8851_TXCR_TXPE | KSZ8851_TXCR_TXCE ) ; ksz8851WriteReg ( interface , KSZ8851_TXFDPR , KSZ8851_TXFDPR_TXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_RXCR1 , KSZ8851_RXCR1_RXPAFMA | KSZ8851_RXCR1_RXFCE | KSZ8851_RXCR1_RXBE | KSZ8851_RXCR1_RXME | KSZ8851_RXCR1_RXUE ) ; ksz8851WriteReg ( interface , KSZ8851_RXCR2 , KSZ8851_RXCR2_SRDBL_SINGLE_FRAME | KSZ8851_RXCR2_IUFFP | KSZ8851_RXCR2_RXIUFCEZ ) ; ksz8851WriteReg ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_RXFCTE | KSZ8851_RXQCR_ADRFE ) ; ksz8851WriteReg ( interface , KSZ8851_RXFDPR , KSZ8851_RXFDPR_RXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_RXFCTR <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_P1CR , KSZ8851_P1CR_FORCE_DUPLEX <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_P1CR , KSZ8851_P1CR_RESTART_AN <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_ISR , KSZ8851_ISR_LCIS | KSZ8851_ISR_TXIS | KSZ8851_ISR_RXIS | KSZ8851_ISR_RXOIS | KSZ8851_ISR_TXPSIS | KSZ8851_ISR_RXPSIS | KSZ8851_ISR_TXSAIS | KSZ8851_ISR_RXWFDIS | KSZ8851_ISR_RXMPDIS | KSZ8851_ISR_LDIS | KSZ8851_ISR_EDIS | KSZ8851_ISR_SPIBEIS <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_IER , KSZ8851_IER_LCIE | KSZ8851_IER_TXIE | KSZ8851_IER_RXIE <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_TXCR , KSZ8851_TXCR_TXE <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXCR1 , KSZ8851_RXCR1_RXE <S2SV_ModEnd> "
805,<S2SV_StartBug> pch -> file . dead = 1 ; <S2SV_EndBug> ,<S2SV_ModStart> put_net ( pch -> chan_net ) ; pch -> chan_net = NULL ; 
806,"<S2SV_StartBug> struct btrfs_dir_item * di ; <S2SV_EndBug> <S2SV_StartBug> if ( flags & XATTR_REPLACE ) { <S2SV_EndBug> <S2SV_StartBug> di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , <S2SV_EndBug> <S2SV_StartBug> } else if ( ! di ) { <S2SV_EndBug> <S2SV_StartBug> ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ; <S2SV_EndBug> <S2SV_StartBug> btrfs_release_path ( path ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( flags & XATTR_CREATE ) <S2SV_EndBug> <S2SV_StartBug> btrfs_release_path ( path ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( ! di ) { <S2SV_EndBug> <S2SV_StartBug> if ( value ) { <S2SV_EndBug> ","<S2SV_ModStart> = NULL <S2SV_ModStart> path -> skip_release_on_error = 1 ; if ( ! value ) { di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ; if ( ! di && <S2SV_ModEnd> <S2SV_ModStart> ) ret = - ENODATA ; else if ( di ) ret = btrfs_delete_one_dir_name <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( flags & XATTR_REPLACE ) { ASSERT ( mutex_is_locked ( & inode -> i_mutex ) ) ; di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ; <S2SV_ModEnd> <S2SV_ModStart> btrfs_release_path ( path ) ; di = NULL ; } ret = btrfs_insert_xattr_item <S2SV_ModEnd> <S2SV_ModStart> btrfs_ino ( inode ) , name , name_len , value , size ) ; if ( ret == - EOVERFLOW ) { ret = 0 ; btrfs_assert_tree_locked ( path -> nodes [ 0 ] ) ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; if ( ! di && ! ( flags & XATTR_REPLACE ) ) { ret = - ENOSPC ; <S2SV_ModEnd> <S2SV_ModStart> } } else if ( ret == - EEXIST ) { ret = 0 ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; ASSERT ( di ) ; } else if ( ret ) { <S2SV_ModEnd> <S2SV_ModStart> if ( di && <S2SV_ModEnd> <S2SV_ModStart> ) { ret = - EEXIST ; <S2SV_ModStart> } if ( di ) { const int slot = path -> slots [ 0 ] ; struct extent_buffer * leaf = path -> nodes [ 0 ] ; const u16 old_data_len = btrfs_dir_data_len ( leaf , di ) ; const u32 item_size = btrfs_item_size_nr ( leaf , slot ) ; const u32 data_size = sizeof ( * di ) + name_len + size ; struct btrfs_item * item ; unsigned long data_ptr ; char * ptr ; if ( size > old_data_len ) { if ( btrfs_leaf_free_space ( root , leaf ) < ( size - old_data_len ) ) { ret = - ENOSPC <S2SV_ModEnd> <S2SV_ModStart> } if ( old_data_len + name_len + sizeof ( * di ) == item_size ) { if ( size > old_data_len ) btrfs_extend_item ( root , path , size - old_data_len ) ; <S2SV_ModStart> size < old_data_len ) btrfs_truncate_item ( root , path , data_size , 1 ) ; } else { <S2SV_ModEnd> <S2SV_ModStart> btrfs_extend_item ( root , path , data_size ) ; } item = btrfs_item_nr ( slot ) ; ptr = btrfs_item_ptr ( leaf , slot , char ) ; ptr += btrfs_item_size ( leaf , item ) - data_size ; di = ( struct btrfs_dir_item * ) ptr ; btrfs_set_dir_data_len ( leaf , di , size ) ; data_ptr = ( ( unsigned long ) ( di + 1 ) ) + name_len ; write_extent_buffer ( leaf , value , data_ptr , size ) ; btrfs_mark_buffer_dirty ( leaf ) ; } else { <S2SV_ModEnd> "
807,"<S2SV_StartBug> if ( op -> op > 0xbf ) return 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( n > 0 && n < buf_len ) ) goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) ) goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( op -> len + n <= buf_len ) ) goto beach ; <S2SV_EndBug> <S2SV_StartBug> op -> len += n ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( n > 0 && n + op -> len < buf_len ) ) goto beach ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < count && strlen ( op -> txt ) < R_ASM_BUFSIZE ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d<S2SV_blank>"" , table [ i ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> + 10 <S2SV_ModStart> int optxtlen = strlen ( op -> txt ) ; <S2SV_ModStart> optxtlen , R_ASM_BUFSIZE - optxtlen <S2SV_ModEnd> "
808,<S2SV_StartBug> g_clear_object ( & client -> proxy ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; g_byte_array_free ( client -> auth_buffer , TRUE "
809,"<S2SV_StartBug> vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , encode_block_intra , <S2SV_EndBug> ",<S2SV_ModStart> vp9_encode_block_intra <S2SV_ModEnd> 
810,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> ",<S2SV_ModStart> key_is_negative ( key <S2SV_ModEnd> 
811,<S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( t + 3 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( 2 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( 2 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( 2 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( likely ( HAVE_OP ( t + 15 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( HAVE_IP ( 6 ) ) { <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> <S2SV_StartBug> if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( t + 3 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , 0 <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , 0 <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , 0 "
812,"<S2SV_StartBug> if ( fit_check_format ( fit , IMAGE_SIZE_INVAL ) ) { <S2SV_EndBug> <S2SV_StartBug> printf ( ""Bad<S2SV_blank>FIT<S2SV_blank>%s<S2SV_blank>image<S2SV_blank>format!\\n"" , prop_name ) ; <S2SV_EndBug> <S2SV_StartBug> return - ENOEXEC ; <S2SV_EndBug> ","<S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> ; if ( ret <S2SV_ModStart> ""Bad<S2SV_blank>FIT<S2SV_blank>%s<S2SV_blank>image<S2SV_blank>format!<S2SV_blank>(err=%d)\\n"" , prop_name , ret ) ; if ( CONFIG_IS_ENABLED ( FIT_SIGNATURE ) && ret == - EADDRNOTAVAIL ) printf ( ""Signature<S2SV_blank>checking<S2SV_blank>prevents<S2SV_blank>use<S2SV_blank>of<S2SV_blank>unit<S2SV_blank>addresses<S2SV_blank>(@)<S2SV_blank>in<S2SV_blank>nodes\\n"" <S2SV_ModEnd> <S2SV_ModStart> ret <S2SV_ModEnd> "
813,<S2SV_StartBug> vpn_packet_t outpkt ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( len > sizeof outpkt . data ) return 
814,<S2SV_StartBug> if ( enable_apicv ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
815,"<S2SV_StartBug> for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> <S2SV_StartBug> if ( vdaux < 1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> ",<S2SV_ModStart> end - <S2SV_ModStart> > i <S2SV_ModEnd> <S2SV_ModStart> || ( char * ) UINTPTR_MAX - vstart < vdaux <S2SV_ModStart> end - vstart < <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> end - vstart < <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
816,"<S2SV_StartBug> ioctl ( uinput_fd , UI_DEV_DESTROY ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
817,<S2SV_StartBug> ( rc -> av_per_frame_bandwidth * rc -> baseline_gf_interval * af_ratio ) / <S2SV_EndBug> <S2SV_StartBug> ( rc -> av_per_frame_bandwidth * rc -> baseline_gf_interval ) / <S2SV_EndBug> <S2SV_StartBug> target = rc -> av_per_frame_bandwidth ; <S2SV_EndBug> ,<S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> 
818,"<S2SV_StartBug> if ( strcmp ( argv [ i ] , ""--allow-untrusted"" ) == 0 ) <S2SV_EndBug> ",<S2SV_ModStart> check_option ( argv [ i ] <S2SV_ModEnd> 
819,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> 
820,<S2SV_StartBug> offset = tbl -> indent ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( tbl -> indent < 0 ) tbl -> indent = 0 ; <S2SV_ModStart> if ( offset < 0 ) offset = 0 ; 
821,"<S2SV_StartBug> ( void ) & line ; <S2SV_EndBug> <S2SV_StartBug> if ( e >= b && ( size_t ) ( e - b ) <= CDF_SEC_SIZE ( h ) * sst -> sst_len ) <S2SV_EndBug> <S2SV_StartBug> CDF_SEC_SIZE ( h ) * sst -> sst_len , CDF_SEC_SIZE ( h ) , sst -> sst_len ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> size_t ss = sst -> sst_dirlen < h -> h_min_size_standard_stream ? CDF_SHORT_SEC_SIZE ( h ) : CDF_SEC_SIZE ( h ) ; <S2SV_ModStart> ss <S2SV_ModEnd> <S2SV_ModStart> ss <S2SV_ModEnd> <S2SV_ModStart> ss <S2SV_ModEnd> 
822,"<S2SV_StartBug> # line 106 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1330 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 115 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1338 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 119 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1351 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 128 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ; <S2SV_EndBug> <S2SV_StartBug> # line 1413 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 190 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1421 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 194 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1434 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 207 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1442 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 211 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1451 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 220 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1468 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 233 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1476 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 237 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1485 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 246 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1512 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 269 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1548 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 301 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1574 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 323 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1594 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 343 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1602 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 347 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; <S2SV_EndBug> <S2SV_StartBug> # line 1617 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 361 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1629 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 369 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1653 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1657 ""hex_grammar.c"" <S2SV_EndBug> ","<S2SV_ModStart> 113 <S2SV_ModEnd> <S2SV_ModStart> 1337 <S2SV_ModEnd> <S2SV_ModStart> 122 <S2SV_ModEnd> <S2SV_ModStart> 1345 <S2SV_ModEnd> <S2SV_ModStart> 126 ""hex_grammar.y"" { incr_ast_levels ( ) ; <S2SV_ModEnd> <S2SV_ModStart> 1360 <S2SV_ModEnd> <S2SV_ModStart> 137 <S2SV_ModEnd> <S2SV_ModStart> ) ; incr_ast_levels ( <S2SV_ModStart> 1424 <S2SV_ModEnd> <S2SV_ModStart> 201 <S2SV_ModEnd> <S2SV_ModStart> 1432 <S2SV_ModEnd> <S2SV_ModStart> 205 ""hex_grammar.y"" { incr_ast_levels ( ) ; <S2SV_ModEnd> <S2SV_ModStart> 1447 <S2SV_ModEnd> <S2SV_ModStart> 220 <S2SV_ModEnd> <S2SV_ModStart> 1455 <S2SV_ModEnd> <S2SV_ModStart> 224 <S2SV_ModEnd> <S2SV_ModStart> 1464 <S2SV_ModEnd> <S2SV_ModStart> 233 <S2SV_ModEnd> <S2SV_ModStart> 1481 <S2SV_ModEnd> <S2SV_ModStart> 246 <S2SV_ModEnd> <S2SV_ModStart> 1489 <S2SV_ModEnd> <S2SV_ModStart> 250 <S2SV_ModEnd> <S2SV_ModStart> 1498 <S2SV_ModEnd> <S2SV_ModStart> 259 <S2SV_ModEnd> <S2SV_ModStart> 1525 <S2SV_ModEnd> <S2SV_ModStart> 282 <S2SV_ModEnd> <S2SV_ModStart> 1561 <S2SV_ModEnd> <S2SV_ModStart> 314 <S2SV_ModEnd> <S2SV_ModStart> 1587 <S2SV_ModEnd> <S2SV_ModStart> 336 <S2SV_ModEnd> <S2SV_ModStart> 1607 <S2SV_ModEnd> <S2SV_ModStart> 356 <S2SV_ModEnd> <S2SV_ModStart> 1615 <S2SV_ModEnd> <S2SV_ModStart> 360 <S2SV_ModEnd> <S2SV_ModStart> incr_ast_levels ( ) ; <S2SV_ModStart> 1631 <S2SV_ModEnd> <S2SV_ModStart> 375 <S2SV_ModEnd> <S2SV_ModStart> 1643 <S2SV_ModEnd> <S2SV_ModStart> 383 <S2SV_ModEnd> <S2SV_ModStart> 1667 <S2SV_ModEnd> <S2SV_ModStart> 1671 <S2SV_ModEnd> "
823,<S2SV_StartBug> # if 0 <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
824,"<S2SV_StartBug> strncpy ( buff , opt_basedir , sizeof ( buff ) - 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( buff , 0 , sizeof ( buff ) ) ; "
825,"<S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> ",<S2SV_ModStart> key_is_positive ( key <S2SV_ModEnd> 
826,<S2SV_StartBug> struct hci_filter * f = & hci_pi ( sk ) -> filter ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & uf , 0 , sizeof ( uf ) ) "
827,"<S2SV_StartBug> int n = ( int ) ( data_end - data ) ; <S2SV_EndBug> <S2SV_StartBug> clear += 7 ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & xd -> pre , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & xd -> dst , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & pc -> lfc , & pc -> fc , sizeof ( pc -> fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pc -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) * pc -> mb_cols ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & pc -> fc , & pc -> lfc , sizeof ( pc -> fc ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> MIN ( sizeof ( clear_buffer ) , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> "
828,"<S2SV_StartBug> gss_buffer_desc client_name , service_name ; <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> <S2SV_StartBug> exit_func : <S2SV_EndBug> ",<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : <S2SV_ModStart>  <S2SV_ModEnd> 
829,<S2SV_StartBug> asoc -> peer . i = new -> peer . i ; <S2SV_EndBug> ,<S2SV_ModStart> auth_capable = new -> peer . auth_capable ; asoc -> peer . 
830,<S2SV_StartBug> if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( <S2SV_ModStart> ) 
831,<S2SV_StartBug> assert ( ( cc0 % rowsize ) == 0 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""PredictorEncodeTile"" , ""%s"" , ""(cc0%rowsize)!=0"" ) ; return 0 ; } <S2SV_ModEnd> "
832,<S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> sock * sk = asoc -> base . sk ; struct <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
833,"<S2SV_StartBug> size_t input_size , <S2SV_EndBug> <S2SV_StartBug> # define prolog if ( bytes_matched >= max_bytes_matched ) { action = ACTION_KILL ; break ; } <S2SV_EndBug> <S2SV_StartBug> # define fail_if_error ( e ) switch ( e ) { case ERROR_INSUFFICIENT_MEMORY : return - 2 ; case ERROR_TOO_MANY_RE_FIBERS : return - 4 ; } <S2SV_EndBug> <S2SV_StartBug> input -= character_size ; <S2SV_EndBug> <S2SV_StartBug> max_bytes_matched = ( int ) yr_min ( input_size , RE_SCAN_LIMIT ) ; <S2SV_EndBug> <S2SV_StartBug> match = IS_WORD_CHAR ( * input ) ; <S2SV_EndBug> <S2SV_StartBug> match = ! IS_WORD_CHAR ( * input ) ; <S2SV_EndBug> <S2SV_StartBug> ! ( flags & RE_FLAGS_NOT_AT_START ) && <S2SV_EndBug> <S2SV_StartBug> match = TRUE ; <S2SV_EndBug> <S2SV_StartBug> match = TRUE ; <S2SV_EndBug> <S2SV_StartBug> else if ( IS_WORD_CHAR ( * ( input - input_incr ) ) != IS_WORD_CHAR ( * input ) ) <S2SV_EndBug> <S2SV_StartBug> kill = input_size > ( size_t ) bytes_matched ; <S2SV_EndBug> <S2SV_StartBug> kill = ( flags & RE_FLAGS_NOT_AT_START ) || ( bytes_matched != 0 ) ; <S2SV_EndBug> <S2SV_StartBug> input_size > ( size_t ) bytes_matched ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> <S2SV_ModStart> { if ( <S2SV_ModEnd> <S2SV_ModStart> || ( character_size == 2 && * ( input + 1 ) != 0 ) ) { action = ACTION_KILL ; break ; } <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> max_bytes_matched = ( int ) yr_min ( input_backwards_size , RE_SCAN_LIMIT ) ; <S2SV_ModStart> else { <S2SV_ModStart> input_forwards_size <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> <S2SV_ModStart> _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> <S2SV_ModStart> input_backwards_size < character_size ) { <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } else { assert ( input < input_data + input_forwards_size ) ; assert ( input >= input_data - input_backwards_size ) ; assert <S2SV_ModEnd> <S2SV_ModStart> < input_data + input_forwards_size ) ; assert ( input - input_incr >= input_data - input_backwards_size ) ; match = _yr_re_is_word_char ( input , character_size ) != _yr_re_is_word_char ( input - input_incr , character_size ) ; } <S2SV_ModEnd> <S2SV_ModStart> input_backwards_size <S2SV_ModEnd> <S2SV_ModStart> input_backwards_size > 0 <S2SV_ModEnd> <S2SV_ModStart> input_forwards_size <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
834,"<S2SV_StartBug> int * returndistortion , int * returnintra ) <S2SV_EndBug> <S2SV_StartBug> unsigned int zero_mv_sse = INT_MAX , best_sse = INT_MAX , <S2SV_EndBug> <S2SV_StartBug> best_rd_sse = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( & best_mode . mbmode , 0 , sizeof ( best_mode . mbmode ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( & best_mode . bmodes , 0 , sizeof ( best_mode . bmodes ) ) ; <S2SV_EndBug> <S2SV_StartBug> mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; <S2SV_EndBug> <S2SV_StartBug> if ( x -> best_sse_inter_mode == DC_PRED ) <S2SV_EndBug> <S2SV_StartBug> recon_yoffset , recon_uvoffset ) ; <S2SV_EndBug> <S2SV_StartBug> best_mode_index = mode_index ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mode . mbmode , sizeof ( MB_MODE_INFO ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( x -> partition_info , & best_mode . partition , sizeof ( PARTITION_INFO ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int mb_row , int mb_col <S2SV_ModStart> UINT_MAX <S2SV_ModEnd> <S2SV_ModStart> UINT_MAX <S2SV_ModEnd> <S2SV_ModStart> UINT_MAX <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int block_index = mb_row * cpi -> common . mb_cols + mb_col ; <S2SV_ModStart> , & cpi -> common . lf_info , mb_row , mb_col , block_index <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> "
835,"<S2SV_StartBug> set_exception_intercept ( svm , MC_VECTOR ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; set_exception_intercept ( svm , AC_VECTOR "
836,<S2SV_StartBug> h -> size = statbuf . st_size ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( h -> size < 0x2000 ) { SET_ERRNO ( EINVAL , ""%s:<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file"" , filename ) ; goto error ; } "
837,"<S2SV_StartBug> const cdf_stream_t * sst , const uint64_t clsid [ 2 ] ) <S2SV_EndBug> <S2SV_StartBug> str = cdf_clsid_to_mime ( clsid , clsid2desc ) ; <S2SV_EndBug> <S2SV_StartBug> return - 2 ; <S2SV_EndBug> <S2SV_StartBug> m = cdf_file_property_info ( ms , info , count , clsid ) ; <S2SV_EndBug> ",<S2SV_ModStart> cdf_directory_t * root_storage <S2SV_ModEnd> <S2SV_ModStart> if ( root_storage ) { <S2SV_ModStart> root_storage -> d_storage_uuid <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> root_storage <S2SV_ModEnd> 
838,"<S2SV_StartBug> UWORD8 u1_profile_idc , u1_level_idc , u1_seq_parameter_set_id ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ps_seq -> u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; <S2SV_EndBug> ","<S2SV_ModStart> , u1_mb_aff_flag = 0 <S2SV_ModStart> u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_mb_aff_flag != u1_mb_aff_flag ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ! u1_frm ) <S2SV_ModStart> u1_mb_aff_flag <S2SV_ModEnd> "
839,"<S2SV_StartBug> err |= get_user ( length , & up -> length ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( err ) return - EFAULT 
840,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vpx_svc_parameters_t * const params = va_arg ( args , vpx_svc_parameters_t * ) ; <S2SV_EndBug> <S2SV_StartBug> if ( params == NULL ) <S2SV_EndBug> <S2SV_StartBug> cpi -> svc . spatial_layer_id = params -> spatial_layer ; <S2SV_EndBug> <S2SV_StartBug> cpi -> svc . temporal_layer_id = params -> temporal_layer ; <S2SV_EndBug> <S2SV_StartBug> cpi -> lst_fb_idx = params -> lst_fb_idx ; <S2SV_EndBug> <S2SV_StartBug> cpi -> gld_fb_idx = params -> gld_fb_idx ; <S2SV_EndBug> <S2SV_StartBug> cpi -> alt_fb_idx = params -> alt_fb_idx ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_svc_extra_cfg_t <S2SV_ModEnd> <S2SV_ModStart> vpx_svc_extra_cfg_t <S2SV_ModEnd> <S2SV_ModStart> int sl , tl ; for ( sl = 0 ; sl < <S2SV_ModEnd> <S2SV_ModStart> number_spatial_layers ; ++ sl ) { for ( tl = 0 ; tl < <S2SV_ModEnd> <S2SV_ModStart> number_temporal_layers ; ++ tl ) { const int layer = LAYER_IDS_TO_IDX ( sl , tl , cpi -> svc . number_temporal_layers ) ; LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ; lc -> max_q <S2SV_ModEnd> <S2SV_ModStart> max_quantizers [ sl ] ; lc -> min_q <S2SV_ModEnd> <S2SV_ModStart> min_quantizers [ sl ] ; lc -> scaling_factor_num <S2SV_ModEnd> <S2SV_ModStart> scaling_factor_num [ sl ] ; lc -> scaling_factor_den <S2SV_ModEnd> <S2SV_ModStart> scaling_factor_den [ sl ] ; } } <S2SV_ModEnd> "
841,<S2SV_StartBug> if ( prev ) { <S2SV_EndBug> <S2SV_StartBug> int i = ( FRAG6_CB ( prev ) -> offset + prev -> len ) - offset ; <S2SV_EndBug> <S2SV_StartBug> if ( i > 0 ) { <S2SV_EndBug> <S2SV_StartBug> while ( next && FRAG6_CB ( next ) -> offset < end ) { <S2SV_EndBug> <S2SV_StartBug> err : <S2SV_EndBug> ,<S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> goto discard_fq ; if <S2SV_ModEnd> <S2SV_ModStart> goto discard_fq ; <S2SV_ModEnd> <S2SV_ModStart> discard_fq : fq_kill ( fq ) ; 
842,"<S2SV_StartBug> uint16 bitspersample , samplesperpixel ; <S2SV_EndBug> <S2SV_StartBug> uint16 input_compression , input_photometric ; <S2SV_EndBug> ",<S2SV_ModStart> = 1 <S2SV_ModStart> = PHOTOMETRIC_MINISBLACK 
843,"<S2SV_StartBug> # if ! defined ( HAVE_LSTAT ) <S2SV_EndBug> <S2SV_StartBug> r = lstat ( a -> name , & st ) ; <S2SV_EndBug> <S2SV_StartBug> if ( r != 0 ) { <S2SV_EndBug> <S2SV_StartBug> archive_set_error ( & a -> archive , errno , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! S_ISLNK ( a -> mode ) ) { <S2SV_EndBug> ","<S2SV_ModStart> struct archive_string error_string ; int error_number ; int rc ; archive_string_init ( & error_string ) ; rc = check_symlinks_fsobj <S2SV_ModEnd> <S2SV_ModStart> error_number , & error_string , a -> flags <S2SV_ModEnd> <S2SV_ModStart> rc != ARCHIVE_OK <S2SV_ModEnd> <S2SV_ModStart> error_number , ""%s"" , error_string . s <S2SV_ModEnd> <S2SV_ModStart> archive_string_free ( & error_string ) ; <S2SV_ModStart> return rc ; } <S2SV_ModEnd> "
844,"<S2SV_StartBug> if ( mount ( hostpath , path , 0 , MS_BIND , NULL ) != 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> safe_mount ( hostpath , path , 0 , MS_BIND , NULL , rootfs -> path ? rootfs -> mount : <S2SV_ModEnd> "
845,"<S2SV_StartBug> unsigned int link_count ; <S2SV_EndBug> <S2SV_StartBug> struct buffer_head * nbh = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ie -> indirectICB . extLength && <S2SV_EndBug> <S2SV_StartBug> ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 , <S2SV_EndBug> <S2SV_StartBug> brelse ( nbh ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned int indirections = 0 ; reread : <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) { brelse ( bh ) ; brelse ( ibh ) ; memcpy ( & iinfo -> i_location <S2SV_ModEnd> <S2SV_ModStart> sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > UDF_MAX_ICB_NESTING ) { udf_err ( inode -> i_sb , ""too<S2SV_blank>many<S2SV_blank>ICBs<S2SV_blank>in<S2SV_blank>ICB<S2SV_blank>hierarchy"" ""<S2SV_blank>(max<S2SV_blank>%d<S2SV_blank>supported)\\n"" , UDF_MAX_ICB_NESTING ) ; make_bad_inode <S2SV_ModEnd> <S2SV_ModStart> goto reread <S2SV_ModEnd> "
846,"<S2SV_StartBug> const TX_SIZE tx_size_uv = get_uv_tx_size ( mbmi ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( & lfm -> lfl_y [ index ] , filter_level , w ) ; <S2SV_EndBug> <S2SV_StartBug> * int_4x4_y |= ( size_mask [ block_size ] & 0xffffffffffffffff ) << shift_y ; <S2SV_EndBug> ","<S2SV_ModStart> get_uv_tx_size_impl ( tx_size_y , block_size , 1 , 1 <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> 0xffffffffffffffffULL <S2SV_ModEnd> "
847,"<S2SV_StartBug> int namelen = strlen ( name ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> <S2SV_StartBug> data ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ! size ) <S2SV_EndBug> <S2SV_StartBug> if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { <S2SV_EndBug> <S2SV_StartBug> snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> GetByteContext gb <S2SV_ModEnd> <S2SV_ModStart> data >= data_end <S2SV_ModEnd> <S2SV_ModStart> bytestream2_init ( & gb , data , data_end - <S2SV_ModEnd> <S2SV_ModStart> return amf_get_field_value2 ( & gb <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> "
848,"<S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> ","<S2SV_ModStart> alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE "
849,"<S2SV_StartBug> spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> ) ; hctx = q -> mq_ops -> map_queue ( q , flush_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , flush_rq -> tag , fq -> orig_rq "
850,"<S2SV_StartBug> k -> get_config ( vdev , vdev -> config ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; } <S2SV_ModStart>  <S2SV_ModEnd> 
851,"<S2SV_StartBug> return ! match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , 0 "
852,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> horDiff16 ( tif , cp0 , cc ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( ! <S2SV_ModStart> ) return 0 <S2SV_ModStart> return 1 ; 
853,"<S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ",<S2SV_ModStart> ssplit <S2SV_ModEnd> 
854,<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> daddr = inet -> inet_daddr ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt && inet -> opt -> srr ) <S2SV_EndBug> ,<S2SV_ModStart> struct ip_options_rcu * inet_opt ; <S2SV_ModStart> rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; <S2SV_ModStart> inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ; rcu_read_unlock ( ) <S2SV_ModEnd> 
855,"<S2SV_StartBug> void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) <S2SV_EndBug> ",<S2SV_ModStart> static 
856,"<S2SV_StartBug> pid_t pid ; <S2SV_EndBug> <S2SV_StartBug> memset ( c_path , 0 , sizeof ( c_path ) ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( c_path , ""%s%s%d_C_%lu"" , HSM_FM_SCK_PREFIX , mgr_prefix , <S2SV_EndBug> <S2SV_StartBug> hdl -> instance , ( long unsigned ) pid ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""%s%s%d_C_XXXXXX"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
857,<S2SV_StartBug> * replySize < ( int ) sizeof ( effect_param_t ) ) { <S2SV_EndBug> ,<S2SV_ModStart> sizeof ( effect_param_t ) || ( ( effect_param_t * ) pCmdData ) -> psize > * replySize - 
858,"<S2SV_StartBug> ""InvalidGeometry"" , ""`%s\'"" , option ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; page_geometry = DestroyString ( page_geometry 
859,"<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> len = ipv6_getsockopt_sticky ( sk , np -> opt , <S2SV_EndBug> ","<S2SV_ModStart> struct ipv6_txoptions * opt ; <S2SV_ModStart> opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
860,<S2SV_StartBug> currkvno = key_data [ i ] . key_data_kvno ; <S2SV_EndBug> ,<S2SV_ModStart> if ( i < n_key_data - 1 ) <S2SV_ModStart> + 1 
861,"<S2SV_StartBug> L3 = emitjump ( J , F , OP_JUMP ) ; <S2SV_EndBug> ","<S2SV_ModStart> emit ( J , F , OP_ENDTRY ) ; "
862,"<S2SV_StartBug> if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> <S2SV_StartBug> l_row -- ; <S2SV_EndBug> ",<S2SV_ModStart> 3 == <S2SV_ModStart> && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> <S2SV_ModStart> LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ; 
863,"<S2SV_StartBug> memcpy ( sbuf + 1 , crgram , crgram_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( sizeof sbuf - 1 < crgram_len ) return SC_ERROR_INVALID_ARGUMENTS ; 
864,"<S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> STREAM s ; <S2SV_EndBug> <S2SV_StartBug> ber_parse_header ( s , MCS_CONNECT_RESPONSE , & length ) ; <S2SV_EndBug> <S2SV_StartBug> mcs_parse_domain_params ( s ) ; <S2SV_EndBug> ","<S2SV_ModStart> uint32 <S2SV_ModEnd> <S2SV_ModStart> ; struct stream packet <S2SV_ModStart> packet = * s ; <S2SV_ModStart> if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""mcs_recv_connect_response(),<S2SV_blank>consume<S2SV_blank>connect<S2SV_blank>id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } "
865,<S2SV_StartBug> assert ( status != NULL ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( status == NULL ) status = ""UNKNOWN_REASON"" <S2SV_ModEnd> "
866,"<S2SV_StartBug> if ( c == 0 ) { <S2SV_EndBug> <S2SV_StartBug> xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , ""Name"" ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; return ( NULL ) ; } if ( ctxt -> input -> cur - ctxt -> input -> base < len ) { xmlFatalErr ( ctxt , XML_ERR_INTERNAL_ERROR , ""unexpected<S2SV_blank>change<S2SV_blank>of<S2SV_blank>input<S2SV_blank>buffer"" "
867,<S2SV_StartBug> goto err_free ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( ch ) ; 
868,<S2SV_StartBug> if ( * rsize >= 17 && rdesc [ 11 ] == 0x3c && rdesc [ 12 ] == 0x02 ) { <S2SV_EndBug> ,<S2SV_ModStart> 18 <S2SV_ModEnd> 
869,"<S2SV_StartBug> if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) <S2SV_EndBug> <S2SV_StartBug> if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ; 
870,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> return - 1 ; 
871,<S2SV_StartBug> smb_ofile_t * of = NULL ; <S2SV_EndBug> <S2SV_StartBug> of = sr -> fid_ofile ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> smb_ofile_flush ( sr , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
872,<S2SV_StartBug> uchar * dataptr ; <S2SV_EndBug> ,<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
873,"<S2SV_StartBug> vpx_memset ( xd -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> xd -> pre . y_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 0 ] + recon_yoffset ; <S2SV_EndBug> <S2SV_StartBug> xd -> pre . u_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 1 ] + recon_uvoffset ; <S2SV_EndBug> <S2SV_StartBug> xd -> pre . v_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 2 ] + recon_uvoffset ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> if ( xd -> mode_info_context -> mbmi . ref_frame >= LAST_FRAME ) { const MV_REFERENCE_FRAME ref = xd -> mode_info_context -> mbmi . ref_frame ; <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> } else { xd -> pre . y_buffer = 0 ; xd -> pre . u_buffer = 0 ; xd -> pre . v_buffer = 0 ; } 
874,<S2SV_StartBug> addr -> addrtype = TIPC_ADDR_ID ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & addr -> addr , 0 , sizeof ( addr -> addr ) ) "
875,<S2SV_StartBug> if ( user_alloc && ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) ) <S2SV_EndBug> ,"<S2SV_ModStart> ( <S2SV_ModStart> ) ) || ! access_ok ( VERIFY_WRITE , mem -> userspace_addr , mem -> memory_size "
876,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_EndBug> ,<S2SV_ModStart> quantum_info = ( QuantumInfo * ) NULL ; <S2SV_ModStart> if ( quantum_info != ( QuantumInfo * ) NULL ) 
877,"<S2SV_StartBug> if ( tmp_line [ tmp_line_len - 1 ] == '\\n' ) { <S2SV_EndBug> <S2SV_StartBug> if ( tmp_line [ tmp_line_len - 1 ] == '\\r' ) { <S2SV_EndBug> <S2SV_StartBug> # define CHECK_FOR_CNTRL_CHARS ( val ) { if ( val ) { unsigned char * s , * e ; int l ; l = php_url_decode ( val , strlen ( val ) ) ; s = ( unsigned char * ) val ; e = s + l ; while ( s < e ) { if ( iscntrl ( * s ) ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s"" , new_path ) ; goto out ; } s ++ ; } } } <S2SV_EndBug> ",<S2SV_ModStart> tmp_line_len >= 1 && <S2SV_ModStart> tmp_line_len >= 1 && <S2SV_ModStart> \\\n} <S2SV_ModEnd> 
878,"<S2SV_StartBug> PyObject * u ; <S2SV_EndBug> <S2SV_StartBug> const char * end ; <S2SV_EndBug> <S2SV_StartBug> if ( * s & 0x80 ) { <S2SV_EndBug> <S2SV_StartBug> p += 5 ; <S2SV_EndBug> <S2SV_StartBug> assert ( p - buf <= Py_SIZE ( u ) ) ; <S2SV_EndBug> <S2SV_StartBug> return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> v , * <S2SV_ModStart> ; const char * first_invalid_escape <S2SV_ModStart> s >= end || <S2SV_ModStart> ; if ( s >= end ) break <S2SV_ModStart> PyBytes_GET_SIZE <S2SV_ModEnd> <S2SV_ModStart> v = _PyUnicode_DecodeUnicodeEscape ( s , len , NULL , & first_invalid_escape ) ; if ( v != NULL && first_invalid_escape != NULL ) { if ( warn_invalid_escape_sequence ( c , n , * first_invalid_escape ) < 0 ) { Py_XDECREF ( u ) ; Py_DECREF ( v ) ; return NULL ; } } Py_XDECREF ( u ) ; return v <S2SV_ModEnd> "
879,"<S2SV_StartBug> if ( libfvalue_value_type_initialize ( <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> # if defined ( HAVE_DEBUG_OUTPUT ) <S2SV_EndBug> <S2SV_StartBug> & ( record_data [ data_offset ] ) , <S2SV_EndBug> ","<S2SV_ModStart> user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( <S2SV_ModStart> if ( strings_size > ( ( record_data_size - 4 ) - strings_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } <S2SV_ModStart> if ( data_size > ( ( record_data_size - 4 ) - record_data_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } <S2SV_ModStart> record_data_offset <S2SV_ModEnd> "
880,"<S2SV_StartBug> uint32_t bcount ; <S2SV_EndBug> <S2SV_StartBug> int supported = TRUE , format ; <S2SV_EndBug> ","<S2SV_ModStart> int format_chunk = 0 ; <S2SV_ModStart> if ( format_chunk ++ ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } "
881,<S2SV_StartBug> uint32_t sampleRate ; <S2SV_EndBug> <S2SV_StartBug> if ( ! config -> num_channels ) { <S2SV_EndBug> ,<S2SV_ModStart> = 0 <S2SV_ModStart> || ! config -> sample_rate 
882,"<S2SV_StartBug> ND_TCHECK ( * vtp_vlan ) ; <S2SV_EndBug> <S2SV_StartBug> fn_printzp ( ndo , tptr + VTP_VLAN_INFO_OFFSET , vtp_vlan -> name_len , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; <S2SV_EndBug> <S2SV_StartBug> tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; <S2SV_EndBug> <S2SV_StartBug> type = * tptr ; <S2SV_EndBug> <S2SV_StartBug> if ( type == 0 || tlv_len == 0 ) { <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> len -= 2 + tlv_len * 2 ; <S2SV_EndBug> ","<S2SV_ModStart> if ( len < VTP_VLAN_INFO_FIXED_PART_LEN ) goto trunc ; <S2SV_ModStart> len -= VTP_VLAN_INFO_FIXED_PART_LEN ; tptr += VTP_VLAN_INFO_FIXED_PART_LEN ; if ( len < 4 * ( ( <S2SV_ModEnd> <S2SV_ModStart> + 3 ) / 4 ) ) goto trunc ; ND_TCHECK2 ( * tptr , <S2SV_ModEnd> <S2SV_ModStart> ) ; fn_printzp ( ndo , tptr , <S2SV_ModEnd> <S2SV_ModStart> , NULL ) ; len -= 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; tptr += 4 * ( ( vtp_vlan -> name_len <S2SV_ModStart> if ( len < 2 ) goto trunc ; ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> len < tlv_len * 2 + 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(TLV<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>packet)"" ) ) ; <S2SV_ModEnd> <S2SV_ModStart> if ( tlv_len != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>TLV<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>1)"" , tlv_len ) ) ; return ; } else { <S2SV_ModStart> } "
883,"<S2SV_StartBug> spin_unlock_irqrestore ( & slave_active_lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> list_del_init ( & timeri -> ack_list ) ; list_del_init ( & timeri -> active_list ) ; 
884,"<S2SV_StartBug> struct stat stb ; <S2SV_EndBug> <S2SV_StartBug> int setimes , targisdir , wrerrno = 0 ; <S2SV_EndBug> <S2SV_StartBug> wrerr = NO ; <S2SV_EndBug> <S2SV_StartBug> if ( wrerr == NO ) { <S2SV_EndBug> <S2SV_StartBug> wrerr = YES ; <S2SV_EndBug> <S2SV_StartBug> if ( count != 0 && wrerr == NO && <S2SV_EndBug> <S2SV_StartBug> wrerr = YES ; <S2SV_EndBug> <S2SV_StartBug> ftruncate ( ofd , size ) != 0 ) { <S2SV_EndBug> <S2SV_StartBug> wrerr = DISPLAYED ; <S2SV_EndBug> <S2SV_StartBug> run_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> np , strerror ( errno ) ) ; <S2SV_EndBug> <S2SV_StartBug> run_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> np , strerror ( errno ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( close ( ofd ) == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( setimes && wrerr == NO ) { <S2SV_EndBug> <S2SV_StartBug> run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> wrerr = DISPLAYED ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> wrerr <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> ! wrerr <S2SV_ModEnd> <S2SV_ModStart> note_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = 1 <S2SV_ModEnd> <S2SV_ModStart> ! wrerr <S2SV_ModEnd> <S2SV_ModStart> note_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = 1 ; } if ( ! wrerr <S2SV_ModEnd> <S2SV_ModStart> note_err <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> note_err <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> note_err <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> note_err ( np , ""%s:<S2SV_blank>close:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; <S2SV_ModEnd> <S2SV_ModStart> ! wrerr <S2SV_ModEnd> <S2SV_ModStart> note_err <S2SV_ModEnd> <S2SV_ModStart> } } if ( note_err ( NULL ) == 0 ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
885,"<S2SV_StartBug> else if ( ! strcasecmp ( target , ""LIST"" ) && myentity_find_ext ( target ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> else if ( ! strcasecmp ( target , ""CLEAR"" ) && myentity_find_ext ( target ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> else if ( ! strcasecmp ( target , ""MODIFY"" ) && myentity_find_ext ( target ) == NULL ) <S2SV_EndBug> ",<S2SV_ModStart> anope_flags_compat && <S2SV_ModStart> anope_flags_compat && <S2SV_ModStart> anope_flags_compat && 
886,"<S2SV_StartBug> ghash_flush ( ctx , dctx ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! ctx -> gf128 ) return - ENOKEY ; 
887,<S2SV_StartBug> if ( ! ( ast -> sub_ctx = avformat_alloc_context ( ) ) ) <S2SV_EndBug> ,"<S2SV_ModStart> strcmp ( sub_demuxer -> name , ""srt"" ) && strcmp ( sub_demuxer -> name , ""ass"" ) ) goto error ; if ( "
888,"<S2SV_StartBug> int need_error_free = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( inbuf . data , sendauth_version ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( appl_version && strcmp ( inbuf . data , appl_version ) ) { <S2SV_EndBug> ","<S2SV_ModStart> krb5_data d ; <S2SV_ModStart> d = make_data ( ( char * ) sendauth_version , strlen ( sendauth_version ) + 1 ) ; if ( ! data_eq ( inbuf , d <S2SV_ModEnd> <S2SV_ModStart> != NULL && ! problem ) { d = make_data ( appl_version , strlen ( appl_version ) + 1 ) ; if ( ! data_eq ( inbuf , d ) <S2SV_ModEnd> "
889,"<S2SV_StartBug> static INLINE int write_bit_gte ( vp9_writer * w , int word , int test ) { <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , word >= test , 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> vpx_write_literal <S2SV_ModEnd> 
890,"<S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( ret ) return ret <S2SV_ModEnd> "
891,<S2SV_StartBug> * dptr ++ = 0xAA ; <S2SV_EndBug> ,<S2SV_ModStart> ROSE_CALL_REQ_ADDR_LEN_VAL <S2SV_ModEnd> 
892,<S2SV_StartBug> if ( new_fs ) { <S2SV_EndBug> ,<S2SV_ModStart> new_ns -> mounts ++ ; 
893,"<S2SV_StartBug> vpx_memset ( & oci -> postproc_state , 0 , sizeof ( oci -> postproc_state ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( oci -> post_proc_buffer . buffer_alloc , 128 , <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
894,<S2SV_StartBug> zip_object_handlers . get_properties = php_zip_get_properties ; <S2SV_EndBug> ,<S2SV_ModStart> get_gc = php_zip_get_gc ; zip_object_handlers . 
895,<S2SV_StartBug> return ( ( iova < mem -> iova ) || <S2SV_EndBug> <S2SV_StartBug> ( ( iova + length ) > ( mem -> iova + mem -> length ) ) ) ? <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> || length > mem -> length || iova > <S2SV_ModEnd> <S2SV_ModStart> - length ) return - EFAULT ; return <S2SV_ModEnd> 
896,<S2SV_StartBug> ni6 = ( const struct icmp6_nodeinfo * ) dp ; <S2SV_EndBug> <S2SV_StartBug> cp = ( const u_char * ) ( ni6 + 1 ) + 4 ; <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; <S2SV_ModStart> ; ND_TCHECK ( cp [ 0 ] ) "
897,"<S2SV_StartBug> struct strbuf * path , const char * name , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
898,<S2SV_StartBug> * sent = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
899,"<S2SV_StartBug> static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , <S2SV_EndBug> <S2SV_StartBug> ref -> ref ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> bool <S2SV_ModEnd> <S2SV_ModStart> if ( ref -> ref > INT_MAX / 2 ) return false ; <S2SV_ModStart> return true ; 
900,<S2SV_StartBug> if ( cluster != fs -> clusters - 1 ) <S2SV_EndBug> ,<S2SV_ModStart> + <S2SV_ModEnd> 
901,"<S2SV_StartBug> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
902,<S2SV_StartBug> sock_put ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> sk_nulls_node_init ( & sk -> sk_nulls_node ) ; 
903,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ; 
904,<S2SV_StartBug> if ( ! mm ) <S2SV_EndBug> ,<S2SV_ModStart> || ! mm -> env_end 
905,"<S2SV_StartBug> int parse_rock_ridge_inode ( struct iso_directory_record * de , struct inode * inode ) <S2SV_EndBug> <S2SV_StartBug> int result = parse_rock_ridge_inode_internal ( de , inode , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> result = parse_rock_ridge_inode_internal ( de , inode , 14 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int relocated ) { int flags = relocated ? RR_RELOC_DE : 0 ; <S2SV_ModEnd> <S2SV_ModStart> flags <S2SV_ModEnd> <S2SV_ModStart> flags | RR_REGARD_XA <S2SV_ModEnd> "
906,"<S2SV_StartBug> static struct fsnotify_group * inotify_new_group ( struct user_struct * user , unsigned int max_events ) <S2SV_EndBug> <S2SV_StartBug> group -> inotify_data . user = user ; <S2SV_EndBug> <S2SV_StartBug> group -> inotify_data . fa = NULL ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> fa = NULL <S2SV_ModEnd> <S2SV_ModStart> user = get_current_user ( ) ; if ( atomic_inc_return ( & group -> inotify_data . user -> inotify_devs ) > inotify_max_user_instances ) { fsnotify_put_group ( group ) ; return ERR_PTR ( - EMFILE ) ; } <S2SV_ModEnd> 
907,<S2SV_StartBug> for ( p = 0 ; p < 4 && in -> data [ p ] ; p ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && in -> linesize [ p ] 
908,<S2SV_StartBug> pairs = palloc ( pcount * sizeof ( Pairs ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( pcount < 0 || pcount > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , pcount , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ; "
909,<S2SV_StartBug> if ( screen -> buffers [ 1 ] ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
910,<S2SV_StartBug> regs [ value_regno ] . var_off = <S2SV_EndBug> ,"<S2SV_ModStart> coerce_reg_to_size ( & <S2SV_ModStart> , size <S2SV_ModEnd> "
911,"<S2SV_StartBug> uint16 strip , nstrips = TIFFNumberOfStrips ( in ) ; <S2SV_EndBug> ",<S2SV_ModStart> uint32 <S2SV_ModEnd> 
912,<S2SV_StartBug> const char need_to_append_dot = base_name [ base_len - 1 ] == '.' ? 0 : 1 ; <S2SV_EndBug> <S2SV_StartBug> struct search_domain * dom ; <S2SV_EndBug> ,<S2SV_ModStart> char need_to_append_dot ; struct search_domain * dom ; if ( ! base_len ) return NULL ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
913,"<S2SV_StartBug> err = nanosleep ( & delay , & delay ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
914,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
915,"<S2SV_StartBug> offset , <S2SV_EndBug> <S2SV_StartBug> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) <S2SV_EndBug> <S2SV_StartBug> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) <S2SV_EndBug> ","<S2SV_ModStart> pixel_info_length ; ssize_t count , offset <S2SV_ModEnd> <S2SV_ModStart> ( offset < 0 ) || ( <S2SV_ModStart> ) <S2SV_ModStart> ( offset < 0 ) || ( <S2SV_ModStart> ) "
916,"<S2SV_StartBug> static void nsc_rle_decompress_data ( NSC_CONTEXT * context ) <S2SV_EndBug> <S2SV_StartBug> rle = context -> Planes ; <S2SV_EndBug> <S2SV_StartBug> FillMemory ( context -> priv -> PlaneBuffers [ i ] , originalSize , 0xFF ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( planeSize < originalSize ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decode ( rle , context -> priv -> PlaneBuffers [ i ] , originalSize ) ; <S2SV_EndBug> <S2SV_StartBug> rle += planeSize ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> if ( ! context ) return FALSE ; <S2SV_ModStart> { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModStart> } <S2SV_ModStart> { if ( ! <S2SV_ModStart> context -> priv -> PlaneBuffersLength , originalSize ) ) return FALSE ; } else { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> return TRUE ; "
917,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( ! inode_owner_or_capable ( inode ) ) return - EACCES ; 
918,"<S2SV_StartBug> httpSetHostName ( state -> host , stok ( sclone ( value ) , ""<S2SV_blank>\\t,"" , NULL ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ssplit <S2SV_ModEnd> 
919,"<S2SV_StartBug> . match_data . cmp = type -> match , <S2SV_EndBug> ",<S2SV_ModStart> key_default_cmp <S2SV_ModEnd> 
920,<S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug> <S2SV_StartBug> IP6CB ( skb ) -> iif ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; * addr_len = sizeof ( * sin6 
921,<S2SV_StartBug> if ( ! job_id || ! prev_hash || ! coinbase1 || ! coinbase2 || ! bbversion || ! nbit || ! ntime ) { <S2SV_EndBug> <S2SV_StartBug> if ( job_id ) <S2SV_EndBug> ,<S2SV_ModStart> valid_hex ( job_id ) || ! valid_hex ( prev_hash ) || ! valid_hex ( coinbase1 ) || ! valid_hex ( coinbase2 ) || ! valid_hex ( bbversion ) || ! valid_hex ( nbit ) || ! valid_hex ( ntime ) ) { free <S2SV_ModEnd> <S2SV_ModStart> ; free ( coinbase1 ) ; <S2SV_ModEnd> 
922,"<S2SV_StartBug> ssize_t ret = write ( fd , data + transmitted_length , length ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
923,"<S2SV_StartBug> void * ptr = malloc ( num * size ) ; <S2SV_EndBug> <S2SV_StartBug> memset ( ptr , '\\0' , ( num * size ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; void * ptr ; <S2SV_ModEnd> <S2SV_ModStart> res <S2SV_ModEnd> <S2SV_ModStart> res <S2SV_ModEnd> "
924,<S2SV_StartBug> put_io_context ( ioc ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> 
925,"<S2SV_StartBug> PyObject * res ; <S2SV_EndBug> <S2SV_StartBug> PyObject * dict = _PyObject_GetAttrId ( self , & PyId___dict__ ) ; <S2SV_EndBug> <S2SV_StartBug> res = Py_BuildValue ( ""O()O"" , Py_TYPE ( self ) , dict ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & dict ) < 0 ) { <S2SV_ModEnd> <S2SV_ModStart> return Py_BuildValue ( ""O()N"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
926,"<S2SV_StartBug> USB_DT_OTG , ( void * * ) & desc ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( * desc ) "
927,"<S2SV_StartBug> void ( * func ) ( struct perf_event * ) ; <S2SV_EndBug> <S2SV_StartBug> case PERF_EVENT_IOC_PERIOD : <S2SV_EndBug> <S2SV_StartBug> return perf_event_period ( event , ( u64 __user * ) arg ) ; <S2SV_EndBug> <S2SV_StartBug> case PERF_EVENT_IOC_SET_FILTER : <S2SV_EndBug> ","<S2SV_ModStart> struct perf_event_context * ctx ; long ret ; ctx = perf_event_ctx_lock ( event ) ; ret = _perf_ioctl ( event , cmd <S2SV_ModEnd> <S2SV_ModStart> perf_event_ctx_unlock <S2SV_ModEnd> <S2SV_ModStart> ctx ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
928,<S2SV_StartBug> tp -> prr_delivered += newly_acked_sacked ; <S2SV_EndBug> ,<S2SV_ModStart> if ( newly_acked_sacked <= 0 || WARN_ON_ONCE ( ! tp -> prior_cwnd ) ) return ; 
929,"<S2SV_StartBug> static MB_PREDICTION_MODE read_intra_mode_uv ( VP9_COMMON * cm , vp9_reader * r , <S2SV_EndBug> <S2SV_StartBug> MB_PREDICTION_MODE y_mode ) { <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE uv_mode = read_intra_mode ( r , <S2SV_EndBug> <S2SV_StartBug> cm -> fc . uv_mode_prob [ y_mode ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ","<S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> MACROBLOCKD * xd , vpx_reader <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> "
930,"<S2SV_StartBug> return crypto_alloc_skcipher ( name , type , mask ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> struct skcipher_tfm * tfm ; struct crypto_skcipher * skcipher ; tfm = kzalloc ( sizeof ( * tfm ) , GFP_KERNEL ) ; if ( ! tfm ) return ERR_PTR ( - ENOMEM ) ; skcipher = <S2SV_ModEnd> <S2SV_ModStart> if ( IS_ERR ( skcipher ) ) { kfree ( tfm ) ; return ERR_CAST ( skcipher ) ; } tfm -> skcipher = skcipher ; return tfm ; "
931,<S2SV_StartBug> ret = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> goto e_ctx ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( hmac_buf ) ; <S2SV_ModStart> e_data <S2SV_ModEnd> 
932,"<S2SV_StartBug> c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * 3 
933,<S2SV_StartBug> return Qnil ; <S2SV_EndBug> ,"<S2SV_ModStart> rb_ivar_set ( self , id_key_set , Qtrue ) ; "
934,"
","
"
935,"<S2SV_StartBug> register_savevm ( dev , ""stellaris_enet"" , - 1 , 1 , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
936,"<S2SV_StartBug> register u_int length = h -> len ; <S2SV_EndBug> <S2SV_StartBug> return ( chdlc_print ( ndo , p , length ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart> h -> len <S2SV_ModEnd> 
937,<S2SV_StartBug> if ( ! rc && cifs_sb -> prepathlen && tcon ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
938,<S2SV_StartBug> ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <S2SV_EndBug> ,<S2SV_ModStart> SKB_EXT_ERR ( skb ) -> opt_stats <S2SV_ModEnd> 
939,<S2SV_StartBug> if ( rdf_parser -> uri_filter ) <S2SV_EndBug> ,"<S2SV_ModStart> raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ; "
940,<S2SV_StartBug> if ( ( rsa = RSA_new ( ) ) == NULL ) <S2SV_EndBug> ,"<S2SV_ModStart> ! SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_SERVER_CERTIFICATE , SSL_R_UNEXPECTED_MESSAGE ) ; goto f_err ; } if ( "
941,<S2SV_StartBug> return SECURE_ELEMENT_ERROR_NPE ; <S2SV_EndBug> ,<S2SV_ModStart> ; } if ( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE ) { return SECURE_ELEMENT_ERROR_BUF_SIZE 
942,<S2SV_StartBug> iframe -> state = NGHTTP2_IB_READ_SETTINGS ; <S2SV_EndBug> ,<S2SV_ModStart> if ( session -> obq_flood_counter_ >= session -> max_outbound_ack && ! ( iframe -> frame . hd . flags & NGHTTP2_FLAG_ACK ) ) { return NGHTTP2_ERR_FLOODED ; } 
943,<S2SV_StartBug> return new_ns ; <S2SV_EndBug> ,<S2SV_ModStart> new_ns -> mounts = 0 ; new_ns -> pending_mounts = 0 ; 
944,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> atomic_set ( & opt2 -> refcnt , 1 ) ; "
945,<S2SV_StartBug> x86_pmu . extra_regs = intel_snb_extra_regs ; <S2SV_EndBug> <S2SV_StartBug> x86_pmu . pebs_aliases = intel_pebs_aliases_snb ; <S2SV_EndBug> ,<S2SV_ModStart> if ( boot_cpu_data . x86_model == 45 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else <S2SV_ModStart> if ( boot_cpu_data . x86_model == 62 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else 
946,<S2SV_StartBug> int n_read = r -> end - r -> begin ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned int actual_size = rtype == 2 ? n * 2 : n ; unsigned int limit_r_begin = ( r -> begin < actual_size ? r -> begin : actual_size ) ; unsigned int limit_r_end = ( r -> end < actual_size ? r -> end : actual_size ) ; <S2SV_ModStart> limit_r_end - limit_r_begin <S2SV_ModEnd> 
947,<S2SV_StartBug> u32 now ; <S2SV_EndBug> <S2SV_StartBug> challenge_timestamp = now ; <S2SV_EndBug> <S2SV_StartBug> challenge_count = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> count , <S2SV_ModStart> u32 half = ( sysctl_tcp_challenge_ack_limit + 1 ) >> 1 ; <S2SV_ModStart> WRITE_ONCE ( challenge_count , half + prandom_u32_max ( sysctl_tcp_challenge_ack_limit ) ) ; } count = READ_ONCE ( challenge_count ) ; if ( count > 0 ) { WRITE_ONCE ( challenge_count , count - 1 ) ; <S2SV_ModEnd> "
948,<S2SV_StartBug> struct llc_pktinfo info ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & info , 0 , sizeof ( info ) ) "
949,"<S2SV_StartBug> static void pack_mb_tokens ( vp9_writer * w , <S2SV_EndBug> <S2SV_StartBug> TOKENEXTRA * * tp , const TOKENEXTRA * stop ) { <S2SV_EndBug> <S2SV_StartBug> const vp9_extra_bit * const b = & vp9_extra_bits [ t ] ; <S2SV_EndBug> <S2SV_StartBug> int i = 0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , bb , pb [ i >> 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_bit ( w , e & 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> const stop , vpx_bit_depth_t bit_depth <S2SV_ModEnd> <S2SV_ModStart> int i = 0 ; int v = a -> value ; int n = a -> len ; # if CONFIG_VP9_HIGHBITDEPTH <S2SV_ModStart> b ; if ( bit_depth == VPX_BITS_12 ) b = & vp9_extra_bits_high12 [ t ] ; else if ( bit_depth == VPX_BITS_10 ) b = & vp9_extra_bits_high10 [ t ] ; else <S2SV_ModEnd> <S2SV_ModStart> # else const vp9_extra_bit * const b = & vp9_extra_bits [ t ] ; ( void ) bit_depth ; # endif <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write_bit <S2SV_ModEnd> "
950,"<S2SV_StartBug> struct vp9_write_bit_buffer wb = { data , 0 } ; <S2SV_EndBug> <S2SV_StartBug> struct vp9_write_bit_buffer saved_wb ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( & wb , 0 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> uncompressed_hdr_size = vp9_rb_bytes_written ( & wb ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_compute_update_table ( ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( & saved_wb , ( int ) first_part_size , 16 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_bytes_written <S2SV_ModEnd> <S2SV_ModStart> vpx_clear_system_state <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> 
951,"<S2SV_StartBug> static int dev_get_valid_name ( struct net * net , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
952,"<S2SV_StartBug> int ret , n ; <S2SV_EndBug> <S2SV_StartBug> hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; <S2SV_EndBug> <S2SV_StartBug> hid -> country = hdesc -> bCountryCode ; <S2SV_EndBug> <S2SV_StartBug> for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) <S2SV_EndBug> ","<S2SV_ModStart> ; int num_descriptors ; size_t offset = offsetof ( struct hid_descriptor , desc ) <S2SV_ModStart> if ( hdesc -> bLength < sizeof ( struct hid_descriptor ) ) { dbg_hid ( ""hid<S2SV_blank>descriptor<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\\n"" ) ; return - EINVAL ; } <S2SV_ModStart> ; num_descriptors = min_t ( int , hdesc -> bNumDescriptors , ( hdesc -> bLength - offset ) / sizeof ( struct hid_class_descriptor ) ) <S2SV_ModStart> num_descriptors <S2SV_ModEnd> "
953,<S2SV_StartBug> struct ikev2_id id ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> ,<S2SV_ModStart> const struct ikev2_id * idp ; <S2SV_ModStart> idp = ( const struct ikev2_id * ) ext ; <S2SV_ModStart> idp <S2SV_ModEnd> 
954,<S2SV_StartBug> # ifdef CONFIG_FUTEX <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( tsk -> robust_list ) ) <S2SV_EndBug> ,"<S2SV_ModStart> if ( group_dead ) tty_audit_exit ( ) ; if ( unlikely ( tsk -> audit_context ) ) audit_free ( tsk ) ; tsk -> exit_code = code ; taskstats_exit ( tsk , group_dead ) ; exit_mm ( tsk ) ; if ( group_dead ) acct_process ( ) ; trace_sched_process_exit ( tsk ) ; exit_sem ( tsk ) ; exit_files ( tsk ) ; exit_fs ( tsk ) ; check_stack_usage ( ) ; exit_thread ( ) ; cgroup_exit ( tsk , 1 ) ; exit_keys ( tsk ) ; if ( group_dead && tsk -> signal -> leader ) disassociate_ctty ( 1 ) ; module_put ( task_thread_info ( tsk ) -> exec_domain -> module ) ; if ( tsk -> binfmt ) module_put ( tsk -> binfmt -> module ) ; proc_exit_connector ( tsk ) ; exit_notify ( tsk , group_dead ) ; # ifdef CONFIG_NUMA mpol_put ( tsk -> mempolicy ) ; tsk -> mempolicy = NULL ; # endif <S2SV_ModStart>  <S2SV_ModEnd> "
955,"<S2SV_StartBug> struct strbuf * path , const char * last , <S2SV_EndBug> <S2SV_StartBug> char * name = path_name ( path , last ) ; <S2SV_EndBug> <S2SV_StartBug> free ( ( char * ) name ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
956,<S2SV_StartBug> jas_tvparser_destroy ( tvp ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> jas_tvparser_destroy ( tvp ) ; 
957,<S2SV_StartBug> ret = - EINVAL ; <S2SV_EndBug> ,<S2SV_ModStart> usb_free_urb ( urb ) ; 
958,"<S2SV_StartBug> WORD32 xt0_0 , yt0_0 , xt1_0 , yt1_0 , xt2_0 , yt2_0 ; <S2SV_EndBug> <S2SV_StartBug> WORD32 xh0_0 , xh1_0 , xh20_0 , xh21_0 , xl0_0 , xl1_0 , xl20_0 , xl21_0 ; <S2SV_EndBug> <S2SV_StartBug> xh0_0 = x_0 + x_l1_0 ; <S2SV_EndBug> <S2SV_StartBug> xl0_0 = x_0 - x_l1_0 ; <S2SV_EndBug> <S2SV_StartBug> xh20_0 = x_h2_0 + x_l2_0 ; <S2SV_EndBug> <S2SV_StartBug> xl20_0 = x_h2_0 - x_l2_0 ; <S2SV_EndBug> <S2SV_StartBug> x [ 0 ] = xh0_0 + xh20_0 ; <S2SV_EndBug> <S2SV_StartBug> xt0_0 = xh0_0 - xh20_0 ; <S2SV_EndBug> <S2SV_StartBug> xh1_0 = x_1 + x_l1_1 ; <S2SV_EndBug> <S2SV_StartBug> xl1_0 = x_1 - x_l1_1 ; <S2SV_EndBug> <S2SV_StartBug> xh21_0 = x_h2_1 + x_l2_1 ; <S2SV_EndBug> <S2SV_StartBug> xl21_0 = x_h2_1 - x_l2_1 ; <S2SV_EndBug> <S2SV_StartBug> x [ 1 ] = xh1_0 + xh21_0 ; <S2SV_EndBug> <S2SV_StartBug> yt0_0 = xh1_0 - xh21_0 ; <S2SV_EndBug> <S2SV_StartBug> xt1_0 = xl0_0 + xl21_0 ; <S2SV_EndBug> <S2SV_StartBug> xt2_0 = xl0_0 - xl21_0 ; <S2SV_EndBug> <S2SV_StartBug> yt2_0 = xl1_0 + xl20_0 ; <S2SV_EndBug> <S2SV_StartBug> yt1_0 = xl1_0 - xl20_0 ; <S2SV_EndBug> ","<S2SV_ModStart> WORD64 <S2SV_ModEnd> <S2SV_ModStart> WORD64 <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) x_0 + ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) x_0 - ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) x_h2_0 + ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) x_h2_0 - ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD32 ) ixheaacd_add64_sat ( xh0_0 , xh20_0 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) xh0_0 - ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) x_1 + ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) x_1 - ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) x_h2_1 + ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) x_h2_1 - ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD32 ) ixheaacd_add64_sat ( xh1_0 , xh21_0 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) xh1_0 - ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) xl0_0 + ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) xl0_0 - ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) xl1_0 + ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) xl1_0 - ( WORD64 ) <S2SV_ModEnd> "
959,<S2SV_StartBug> if ( tag == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( len <= 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( n > sizeof ( size_t ) - 1 ) ) <S2SV_EndBug> <S2SV_StartBug> for ( len = 0 ; n > 0 ; n -- ) { <S2SV_EndBug> <S2SV_StartBug> dp += len ; <S2SV_EndBug> ,<S2SV_ModStart> ASN1_EOC <S2SV_ModEnd> <S2SV_ModStart> goto check_length ; <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> len = 0 ; for ( <S2SV_ModEnd> <S2SV_ModStart> check_length : if ( len > datalen - dp ) goto data_overrun_error ; 
960,<S2SV_StartBug> if ( flags & __GFP_ZERO ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
961,"<S2SV_StartBug> return mount_entry_on_generic ( mntent , mntent -> mnt_dir ) ; <S2SV_EndBug> ","<S2SV_ModStart> , NULL "
962,"<S2SV_StartBug> PHP_SHA512Init ( & context ) ; <S2SV_EndBug> <S2SV_StartBug> PHP_SHA256Init ( & context ) ; <S2SV_EndBug> <S2SV_StartBug> PHP_SHA1Init ( & context ) ; <S2SV_EndBug> <S2SV_StartBug> PHP_MD5Init ( & context ) ; <S2SV_EndBug> <S2SV_StartBug> * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } <S2SV_ModStart> if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } <S2SV_ModStart> if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } <S2SV_ModStart> if ( sig_len < sizeof ( digest <S2SV_ModEnd> <S2SV_ModStart> PHP_MD5Init ( & context ) ; read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_MD5Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_MD5Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } "
963,<S2SV_StartBug> value [ n ] >= min && value [ n ] <= max && <S2SV_EndBug> <S2SV_StartBug> && field -> usage [ field -> value [ n ] - min ] . hid <S2SV_EndBug> <S2SV_StartBug> && field -> usage [ value [ n ] - min ] . hid <S2SV_EndBug> ,<S2SV_ModStart> && value [ n ] - min < field -> maxusage <S2SV_ModStart> value [ n ] - min < field -> maxusage && field -> <S2SV_ModStart> value [ n ] - min < field -> maxusage && 
964,"<S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , scaling_active ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> display_width - 1 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> display_height - 1 , 16 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> 
965,<S2SV_StartBug> if ( argReg >= regsz ) { <S2SV_EndBug> ,<S2SV_ModStart> > <S2SV_ModEnd> <S2SV_ModStart> return ; 
966,"<S2SV_StartBug> rb_hash_aset ( env , server_name_val , req_server_name ( req ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> remote_addr_val , req_remote_addr ( req ) ) ; rb_hash_aset ( env , server_port_val , req_server_port ( req ) ) ; rb_hash_aset ( env , <S2SV_ModStart>  <S2SV_ModEnd> "
967,<S2SV_StartBug> valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; <S2SV_EndBug> <S2SV_StartBug> valuelen ) ; <S2SV_EndBug> <S2SV_StartBug> args -> valuelen = valuelen ; <S2SV_EndBug> <S2SV_StartBug> if ( args -> valuelen < valuelen ) { <S2SV_EndBug> <S2SV_StartBug> args -> valuelen = valuelen ; <S2SV_EndBug> ,<S2SV_ModStart> args -> rmtvaluelen <S2SV_ModEnd> <S2SV_ModStart> args -> rmtvaluelen <S2SV_ModEnd> <S2SV_ModStart> args -> rmtvaluelen <S2SV_ModEnd> <S2SV_ModStart> args -> rmtvaluelen ) { args -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> <S2SV_ModStart> args -> rmtvaluelen <S2SV_ModEnd> 
968,<S2SV_StartBug> size_t sz = sizeof ( * info ) + size ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( sz < sizeof ( * info ) ) return NULL 
969,"<S2SV_StartBug> int col_type , prepare_retval ; <S2SV_EndBug> <S2SV_StartBug> ""ERROR:<S2SV_blank>Trying<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>new<S2SV_blank>stmt<S2SV_blank>while<S2SV_blank>we<S2SV_blank>have<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>already<S2SV_blank>not<S2SV_blank>closed<S2SV_blank>one<S2SV_blank>\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> ""\\t\\tERROR:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>return<S2SV_blank>MYSQL_STMT<S2SV_blank>structure<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>from<S2SV_blank>mysql_stmt_init():<S2SV_blank>ERROR<S2SV_blank>NO:<S2SV_blank>%d<S2SV_blank>ERROR<S2SV_blank>MSG:%s\\n"" , <S2SV_EndBug> <S2SV_StartBug> int has_statement_fields = imp_sth -> stmt -> fields != 0 ; <S2SV_EndBug> <S2SV_StartBug> col_type = ( has_statement_fields ? <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""ERROR:<S2SV_blank>Trying<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>new<S2SV_blank>stmt<S2SV_blank>while<S2SV_blank>we<S2SV_blank>have<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>already<S2SV_blank>not<S2SV_blank>closed<S2SV_blank>one<S2SV_blank>\\n"" <S2SV_ModEnd> <S2SV_ModStart> ""\\t\\tERROR:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>return<S2SV_blank>MYSQL_STMT<S2SV_blank>structure<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>from<S2SV_blank>mysql_stmt_init():<S2SV_blank>ERROR<S2SV_blank>NO:<S2SV_blank>%d<S2SV_blank>ERROR<S2SV_blank>MSG:%s\\n"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> bind -> buffer_type = MYSQL_TYPE_STRING <S2SV_ModEnd> "
970,<S2SV_StartBug> if ( key -> type -> destroy ) <S2SV_EndBug> ,"<S2SV_ModStart> test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && "
971,"<S2SV_StartBug> commonlen = COMPUTESIZE ( state . num , state . sumlen ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( LTXTQUERY_TOO_BIG ( state . num , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""ltxtquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ; "
972,"<S2SV_StartBug> int need = 0 ; <S2SV_EndBug> <S2SV_StartBug> need *= 4 ; <S2SV_EndBug> <S2SV_StartBug> TRACE ( ( ""Salted<S2SV_blank>TEXT:%u:%s\\n"" , ( unsigned ) ( lp - line ) , <S2SV_EndBug> <S2SV_StartBug> visibleChars ( line , ( unsigned ) ( lp - line ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> scp -> data_length = ( size_t ) ( lp - line ) ; <S2SV_EndBug> ","<S2SV_ModStart> = 0 ; size_t have <S2SV_ModStart> if ( need > 0 ) { if ( screen -> max_combining > 0 ) need += screen -> max_combining ; need *= 6 ; } <S2SV_ModEnd> <S2SV_ModStart> have = ( size_t ) ( lp - line ) ; if ( ( have * 2 ) < ( size_t ) need ) { scp -> data_limit = have + 1 ; line = realloc ( line , scp -> data_limit ) ; } <S2SV_ModStart> have <S2SV_ModEnd> <S2SV_ModStart> have <S2SV_ModEnd> <S2SV_ModStart> have <S2SV_ModEnd> "
973,<S2SV_StartBug> if ( handle && ! ext4_handle_valid ( handle ) ) <S2SV_EndBug> <S2SV_StartBug> if ( sbi -> s_journal && ! handle ) <S2SV_EndBug> ,<S2SV_ModStart> ! EXT4_SB ( inode -> i_sb ) -> s_journal <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
974,"<S2SV_StartBug> void ftoa_bounded_extra ( JsVarFloat val , char * str , size_t len , int radix , int fractionalDigits ) { <S2SV_EndBug> <S2SV_StartBug> if ( isnan ( val ) ) strncpy ( str , ""NaN"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( val < 0 ) strncpy ( str , ""-Infinity"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> else strncpy ( str , ""Infinity"" , len ) ; <S2SV_EndBug> ",<S2SV_ModStart> assert ( len > 9 ) ; <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
975,"<S2SV_StartBug> if ( fscanf ( f , ""PG%[<S2SV_blank>\\t]%c%c%[<S2SV_blank>\\t+-]%d%[<S2SV_blank>\\t]%d%[<S2SV_blank>\\t]%d"" , temp , & endian1 , <S2SV_EndBug> ","<S2SV_ModStart> ""PG%31[<S2SV_blank>\\t]%c%c%31[<S2SV_blank>\\t+-]%d%31[<S2SV_blank>\\t]%d%31[<S2SV_blank>\\t]%d"" <S2SV_ModEnd> "
976,<S2SV_StartBug> if ( size < 6 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> 5 + 1 <S2SV_ModEnd> <S2SV_ModStart> for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , ""DEADBEEF"" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , ""%2.0f"" , 1.6314159265358979e+125 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , ""163141592653589790215729350939528493057529598899734151772468186268423257777068536614838678161083520756952076273094236944990208"" ) == 0 ) ; ASSERT ( length == 126 ) ; if ( size < 126 + 1 ) ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & ""DEADBEEF"" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; } "
977,<S2SV_StartBug> if ( unlikely ( crng_init == 0 ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> this_cpu_add ( net_rand_state . s1 , fast_pool -> pool [ cycles & 3 ] ) ; "
978,"<S2SV_StartBug> strncpy ( str , ""ID:"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( str , jslGetTokenValueAsString ( ) , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( str , ""String:\'"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( str , jslGetTokenValueAsString ( ) , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> espruino_snprintf <S2SV_ModEnd> <S2SV_ModStart> len , ""ID:%s"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> espruino_snprintf <S2SV_ModEnd> <S2SV_ModStart> len , ""String:\'%s\'"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
979,"<S2SV_StartBug> char * to , * repl ; <S2SV_EndBug> <S2SV_StartBug> if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { <S2SV_EndBug> <S2SV_StartBug> to = g . hname ; <S2SV_EndBug> <S2SV_StartBug> len = strlen ( g . hname ) ; <S2SV_EndBug> <S2SV_StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; <S2SV_EndBug> <S2SV_StartBug> g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( g . outf , to , len ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <S2SV_EndBug> ","<S2SV_ModStart> = g . inf , * sufx = """" ; size_t pre = 0 <S2SV_ModEnd> <S2SV_ModStart> ) { if ( <S2SV_ModEnd> <S2SV_ModStart> pre = justname ( g . inf ) - g . inf ; to = justname ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> to ) ; } else if ( <S2SV_ModEnd> <S2SV_ModStart> == 0 ) sufx = "".tar"" ; } else sufx = g . sufx ; <S2SV_ModEnd> <S2SV_ModStart> pre + len + strlen ( sufx ) <S2SV_ModEnd> <S2SV_ModStart> g . inf , pre ) ; memcpy <S2SV_ModEnd> <S2SV_ModStart> pre , to , len ) ; strcpy ( g . outf + pre + len , <S2SV_ModEnd> "
980,"
","
"
981,"<S2SV_StartBug> int <S2SV_EndBug> <S2SV_StartBug> for ( i = 2 ; i < ( ssize_t ) ( argc - 1 ) ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> ( void ) fputc ( ( char ) c , output ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) fclose ( input ) ; <S2SV_EndBug> <S2SV_StartBug> return ( MagickTrue ) ; <S2SV_EndBug> ","<S2SV_ModStart> MagickBooleanType status ; <S2SV_ModStart> status = MagickTrue ; <S2SV_ModStart> { <S2SV_ModEnd> <S2SV_ModStart> if ( fputc ( ( char ) c , output ) != c ) status = MagickFalse ; <S2SV_ModStart> fclose ( input <S2SV_ModEnd> <S2SV_ModStart> remove_utf8 ( argv [ i ] ) ; } ( void ) fclose ( <S2SV_ModEnd> <S2SV_ModStart> status <S2SV_ModEnd> "
982,<S2SV_StartBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <S2SV_EndBug> ,<S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> 
983,"<S2SV_StartBug> ext3_msg ( sb , ""error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>journal<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%ld"" , <S2SV_EndBug> ","<S2SV_ModStart> KERN_ERR , "
984,"<S2SV_StartBug> int setpwnam ( struct passwd * pwd ) <S2SV_EndBug> <S2SV_StartBug> char * atomic_dir = ""/etc"" ; <S2SV_EndBug> <S2SV_StartBug> if ( ( fp = xfmkstemp ( & tmpname , atomic_dir ) ) == NULL ) <S2SV_EndBug> ","<S2SV_ModStart> , const char * prefix <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""/etc"" , prefix <S2SV_ModEnd> "
985,"<S2SV_StartBug> static unsigned int convert_distribution ( unsigned int i , vp9_tree tree , <S2SV_EndBug> ",<S2SV_ModStart> vpx_tree <S2SV_ModEnd> 
986,"<S2SV_StartBug> return pure_memcmp ( s1 , s2 , strlen ( s1 ) + 1U ) ; <S2SV_EndBug> ",<S2SV_ModStart> const size_t s1_len = strlen ( s1 ) ; const size_t s2_len = strlen ( s2 ) ; const size_t len = ( s1_len < s2_len ) ? s1_len : s2_len ; <S2SV_ModStart> len + 1 <S2SV_ModEnd> 
987,<S2SV_StartBug> const gchar * to = xmpp_stanza_get_to ( message ) ; <S2SV_EndBug> <S2SV_StartBug> Jid * jid_to = jid_create ( to ) ; <S2SV_EndBug> ,"<S2SV_ModStart> Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ; const char * const stanza_from = xmpp_stanza_get_from ( stanza ) ; Jid * msg_jid = jid_create ( stanza_from ) ; if ( g_strcmp0 ( my_jid -> barejid , msg_jid -> barejid ) != 0 ) { log_warning ( ""Invalid<S2SV_blank>carbon<S2SV_blank>received,<S2SV_blank>from:<S2SV_blank>%s"" , stanza_from ) ; return TRUE ; } <S2SV_ModStart>  <S2SV_ModEnd> "
988,<S2SV_StartBug> if ( getClientTypeByName ( v [ j ] ) == - 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> int class = <S2SV_ModEnd> <S2SV_ModStart> ; if ( class <S2SV_ModStart> || class == CLIENT_TYPE_MASTER 
989,"<S2SV_StartBug> static int dev_get_valid_name ( struct net * net , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
990,"<S2SV_StartBug> parse_global_option ( CMD_PRINT_HELP , NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> parse_global_option ( CMD_PRINT_DEFAULTS , NULL , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> , NULL <S2SV_ModStart> , NULL "
991,<S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
992,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> 
993,<S2SV_StartBug> st -> st_state -> name ) ; <S2SV_EndBug> ,<S2SV_ModStart> finite_states [ smc -> state ] <S2SV_ModEnd> 
994,<S2SV_StartBug> ps_dec -> u2_header_done = 1 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ps_dec -> u2_horizontal_size ; } 
995,"<S2SV_StartBug> int x , y , i ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( tilemap = malloc ( x_size * y_size * sizeof ( struct map_tile ) ) ) ) <S2SV_EndBug> ",<S2SV_ModStart> size_t tilemap_size ; <S2SV_ModStart> tilemap_size = <S2SV_ModEnd> <S2SV_ModStart> ; if ( x_size == 0 || tilemap_size / x_size / sizeof ( struct map_tile ) != y_size || ! ( tilemap = malloc ( tilemap_size 
996,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , length ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ipaddr_string ( ndo , & cp [ len ] ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> ( 0 ) <S2SV_ModStart> ) ; ND_TCHECK ( cp [ 2 ] <S2SV_ModStart> ND_TCHECK2 ( cp [ len ] , 4 ) ; <S2SV_ModStart> return ( 0 ) ; trunc : return ( - 1 ) ; "
997,<S2SV_StartBug> static char * print_string ( cJSON * item ) <S2SV_EndBug> <S2SV_StartBug> return print_string_ptr ( item -> valuestring ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , printbuffer * p <S2SV_ModStart> , p "
998,"<S2SV_StartBug> res = ctx -> iface -> enc . encode ( ctx -> priv -> alg_priv , img , pts , <S2SV_EndBug> <S2SV_StartBug> if ( ( res = ctx -> iface -> enc . encode ( ctx -> priv -> alg_priv , img , pts , <S2SV_EndBug> ",<S2SV_ModStart> get_alg_priv ( ctx ) <S2SV_ModEnd> <S2SV_ModStart> get_alg_priv ( ctx ) <S2SV_ModEnd> 
999,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> ret = sscanf ( argv [ i ] + 1 , ""prestring=%s"" , buf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( len = strlen ( buf ) ) > L_BUF_SIZE - 3 ) { <S2SV_EndBug> <S2SV_StartBug> ret = sscanf ( argv [ i ] + 1 , ""protos=%s"" , buf ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""cpp<S2SV_blank>-ansi<S2SV_blank>-DNO_PROTOS<S2SV_blank>%s<S2SV_blank>%s"" , <S2SV_EndBug> ","<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> ""prestring=%490s"" <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> ""protos=%490s"" <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> "
1000,<S2SV_StartBug> if ( chunk_num > chm -> num_chunks ) return NULL ; <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> 
1001,"<S2SV_StartBug> if ( ! validate_event ( & fake_pmu , leader ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! validate_event ( & fake_pmu , sibling ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! validate_event ( & fake_pmu , event ) ) <S2SV_EndBug> ","<S2SV_ModStart> event -> pmu , <S2SV_ModStart> event -> pmu , <S2SV_ModStart> event -> pmu , "
1002,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> win_maximise ( arg1 ? 2 : 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> usleep ( 1000 ) ; <S2SV_ModStart> ) ; usleep ( 1000 
1003,<S2SV_StartBug> av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1004,<S2SV_StartBug> if ( nsops < 1 ) <S2SV_EndBug> ,<S2SV_ModStart> || nsops > SEMOPM 
1005,<S2SV_StartBug> for ( i = cols ; i < cols + 17 ; i ++ ) <S2SV_EndBug> ,<S2SV_ModStart> 0 ; i < 17 ; i ++ ) s [ i + cols <S2SV_ModEnd> 
1006,<S2SV_StartBug> if ( fileblock < INDIRECT_BLOCKS ) <S2SV_EndBug> <S2SV_StartBug> else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } 
1007,"<S2SV_StartBug> WritePixel ( i , & context , casspecial ) ; npix -- ; <S2SV_EndBug> <S2SV_StartBug> WritePixels ( i , & context , stackp , stack_top - stackp ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( npix > 0 ) <S2SV_ModStart> if ( npix >= ( <S2SV_ModEnd> <S2SV_ModStart> ) { WritePixels ( i , & context , stackp , stack_top - stackp ) ; } else if ( npix > 0 ) { WritePixels ( i , & context , stackp , npix ) ; } <S2SV_ModEnd> "
1008,"<S2SV_StartBug> size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> tail = <S2SV_ModEnd> <S2SV_ModStart> ; if ( cdf_check_stream_offset ( sst , h , p , tail * sizeof ( uint32_t ) , __LINE__ ) == - 1 ) goto out ; size_t ofs = CDF_GETUINT32 ( p , tail "
1009,<S2SV_StartBug> next_input = input + i * input_incr ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> ip = next_opcode ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; next_input = input + i * input_incr <S2SV_ModStart> bytes_matched = yr_min ( bytes_matched , max_bytes_matched ) ; "
1010,"<S2SV_StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <S2SV_EndBug> <S2SV_StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED<S2SV_blank>STRING"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED<S2SV_blank>REGEX"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED<S2SV_blank>COMMENT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( len >= 10 ) ; <S2SV_EndBug> ",<S2SV_ModStart> assert ( len > 28 ) ; <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1011,<S2SV_StartBug> unlock_mount_hash ( ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( unlikely ( ! list_empty ( & mnt -> mnt_mounts ) ) ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { umount_mnt ( p ) ; } } "
1012,"<S2SV_StartBug> static void encode_term_subexp ( vp9_writer * w , int word ) { <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , word , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , word - 16 , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , word - 32 , 5 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> vpx_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_write_literal <S2SV_ModEnd> 
1013,"
","
"
1014,<S2SV_StartBug> if ( ! e || e == p ) <S2SV_EndBug> ,<S2SV_ModStart> ) goto not_found ; if ( e - p > HOST_NAME_MAX - 1 
1015,<S2SV_StartBug> int err = - EIO ; <S2SV_EndBug> <S2SV_StartBug> uint32_t pos ; <S2SV_EndBug> <S2SV_StartBug> if ( ! bh ) <S2SV_EndBug> <S2SV_StartBug> out : <S2SV_EndBug> <S2SV_StartBug> kunmap ( page ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( inode -> i_size > inode -> i_sb -> s_blocksize ) { err = - ENAMETOOLONG ; goto out_unmap ; } <S2SV_ModStart> { err = - EIO ; goto out_unlock_inode ; } <S2SV_ModEnd> <S2SV_ModStart> out_unlock_inode <S2SV_ModEnd> <S2SV_ModStart> out_unmap : 
1016,<S2SV_StartBug> else if ( vcpu -> arch . apic_base & X2APIC_ENABLE ) { <S2SV_EndBug> ,<S2SV_ModStart> cpu_has_secondary_exec_ctrls ( ) && ( vmcs_read32 ( SECONDARY_VM_EXEC_CONTROL ) & SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE ) <S2SV_ModEnd> 
1017,<S2SV_StartBug> if ( ent != NULL ) { <S2SV_EndBug> <S2SV_StartBug> cleanup : <S2SV_EndBug> ,"<S2SV_ModStart> == NULL ) { st = KRB5_KDB_NOENTRY ; <S2SV_ModEnd> <S2SV_ModStart> st = populate_policy ( context , ld , ent , pol_name , * policy ) ; "
1018,"<S2SV_StartBug> UEV_PARSE ( ""num_tile_columns_minus1"" , value , ps_bitstrm ) ; <S2SV_EndBug> <S2SV_StartBug> ( ps_pps -> i1_num_tile_columns > ps_sps -> i2_pic_wd_in_ctb ) || <S2SV_EndBug> <S2SV_StartBug> ( ps_pps -> i1_num_tile_rows > ps_sps -> i2_pic_ht_in_ctb ) ) <S2SV_EndBug> ",<S2SV_ModStart> WORD32 wd = ALIGN64 ( ps_codec -> i4_wd ) ; WORD32 ht = ALIGN64 ( ps_codec -> i4_ht ) ; WORD32 max_tile_cols = ( wd + MIN_TILE_WD - 1 ) / MIN_TILE_WD ; WORD32 max_tile_rows = ( ht + MIN_TILE_HT - 1 ) / MIN_TILE_HT ; <S2SV_ModStart> max_tile_cols <S2SV_ModEnd> <S2SV_ModStart> max_tile_rows <S2SV_ModEnd> 
1019,<S2SV_StartBug> struct buffer_head * dibh = mp -> mp_bh [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> const unsigned end_of_metadata = height - 1 ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> super_block * sb = sdp -> sd_vfs ; struct <S2SV_ModStart> ; int ret <S2SV_ModStart> if ( buffer_zeronew ( bh_map ) ) { ret = sb_issue_zeroout ( sb , dblock , dblks , GFP_NOFS ) ; if ( ret ) { fs_err ( sdp , ""Failed<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>data<S2SV_blank>buffers\\n"" ) ; clear_buffer_zeronew ( bh_map ) ; } } "
1020,"<S2SV_StartBug> { switch ( c ) <S2SV_EndBug> <S2SV_StartBug> float32_be_write ( floatdata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> <S2SV_StartBug> float32_le_write ( floatdata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> <S2SV_StartBug> double64_be_write ( doubledata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> <S2SV_StartBug> double64_le_write ( doubledata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> <S2SV_StartBug> size += ( size & 1 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex - 1 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( psf -> rwf_endian == SF_ENDIAN_BIG ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> header_put_byte ( psf , size ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> <S2SV_StartBug> if ( psf -> headindex + size < sizeof ( psf -> header ) ) <S2SV_EndBug> <S2SV_StartBug> { memcpy ( & ( psf -> header [ psf -> headindex ] ) , bindata , size ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex ++ ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , bindata , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += 16 ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> <S2SV_StartBug> if ( size < sizeof ( psf -> header ) ) <S2SV_EndBug> ","<S2SV_ModStart> if ( psf -> header . indx + 16 >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count ; <S2SV_ModStart> . ptr + psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr + psf -> header . indx ) ; psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr + psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr + psf -> header . indx ) ; psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> ; if ( psf -> header . indx + ( sf_count_t ) size >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . indx += size ; psf -> header . ptr <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; if ( psf -> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . indx += size ; psf -> header . ptr <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> if ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; memcpy ( & ( psf -> header . ptr [ psf -> header . indx ] ) , bindata , size ) ; psf -> header . indx += size ; count += size ; break ; case 'z' : size = va_arg ( argptr , size_t ) ; if ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; count += size ; while ( size ) { psf -> header . ptr <S2SV_ModEnd> <S2SV_ModStart> header . indx ] <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> if ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> ( sf_count_t ) size >= psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; psf -> header . indx = size <S2SV_ModEnd> "
1021,<S2SV_StartBug> if ( debug ) { <S2SV_EndBug> <S2SV_StartBug> if ( d -> msg_len > ( CX24116_ARGLEN - CX24116_DISEQC_MSGOFS ) ) <S2SV_EndBug> ,<S2SV_ModStart> d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ; if ( <S2SV_ModStart>  <S2SV_ModEnd> 
1022,<S2SV_StartBug> cinfo . hci_handle = sco_pi ( sk ) -> conn -> hcon -> handle ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & cinfo , 0 , sizeof ( cinfo ) ) ; "
1023,<S2SV_StartBug> if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && <S2SV_EndBug> <S2SV_StartBug> ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) <S2SV_EndBug> <S2SV_StartBug> length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( ( number_pixels * <S2SV_ModEnd> <S2SV_ModStart> ) > ( 8 * <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> bytes_per_line <S2SV_ModEnd> 
1024,"<S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rv ) <S2SV_EndBug> <S2SV_StartBug> fs_logger2 ( ""clone"" , dest ) ; <S2SV_EndBug> ",<S2SV_ModStart> copy_file_as_user <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1025,"<S2SV_StartBug> guint pkt_len ; <S2SV_EndBug> <S2SV_StartBug> num_items_scanned = sscanf ( line + 64 , ""LEN=%9u"" , & pkt_len ) ; <S2SV_EndBug> <S2SV_StartBug> * err_info = g_strdup ( ""toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> int pkt_len , <S2SV_ModEnd> <S2SV_ModStart> ""LEN=%9d"" <S2SV_ModEnd> <S2SV_ModStart> ) ; return FALSE ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" "
1026,<S2SV_StartBug> int err = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> = 0 ; msg -> msg_namelen 
1027,"<S2SV_StartBug> if ( zend_symtable_find ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P ( key ) + 1 , ( void * * ) & old_data ) == SUCCESS ) { <S2SV_EndBug> ",<S2SV_ModStart> zend_hash_find <S2SV_ModEnd> 
1028,"<S2SV_StartBug> strcpy ( link_info . str , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> nla_strlcpy <S2SV_ModEnd> <S2SV_ModStart> , TIPC_MAX_LINK_NAME "
1029,<S2SV_StartBug> io -> io_cleanup = mem_cleanup ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> io -> io_cleanup = mem_cleanup ; 
1030,"<S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> 
1031,<S2SV_StartBug> if ( p -> tokenpos == p -> tokenlen ) { <S2SV_EndBug> ,<S2SV_ModStart> >= ( <S2SV_ModEnd> <S2SV_ModStart> - 1 ) 
1032,<S2SV_StartBug> static vp9_variance_fn_t get_block_variance_fn ( BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> return vp9_mse8x8 ; <S2SV_EndBug> <S2SV_StartBug> return vp9_mse16x8 ; <S2SV_EndBug> <S2SV_StartBug> return vp9_mse8x16 ; <S2SV_EndBug> <S2SV_StartBug> return vp9_mse16x16 ; <S2SV_EndBug> ,<S2SV_ModStart> vpx_variance_fn_t <S2SV_ModEnd> <S2SV_ModStart> vpx_mse8x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_mse16x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_mse8x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_mse16x16 <S2SV_ModEnd> 
1033,<S2SV_StartBug> dev -> header_ops = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> 
1034,<S2SV_StartBug> for ( i = 0 ; i < frame_count ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> chunk_size [ i ] = avio_rl32 ( pb ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < frame_count ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> chunk_offset [ i ] = avio_rl32 ( pb ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < frame_count ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < frame_count ; i ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } <S2SV_ModStart> { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } <S2SV_ModStart> { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } 
1035,<S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ,<S2SV_ModStart> rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if ( 
1036,<S2SV_StartBug> if ( rep -> u . dh_Info . kdfID ) { <S2SV_EndBug> <S2SV_StartBug> secret . data = server_key ; <S2SV_EndBug> ,<S2SV_ModStart> != NULL && rep <S2SV_ModStart> ( char * ) 
1037,"<S2SV_StartBug> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <S2SV_EndBug> ",<S2SV_ModStart> HeapOverflowSanityCheck <S2SV_ModEnd> 
1038,"<S2SV_StartBug> sprintf ( address , ""%s:%s"" , url , port ) ; <S2SV_EndBug> ","<S2SV_ModStart> snprintf ( address , 254 <S2SV_ModEnd> "
1039,"<S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> <S2SV_StartBug> file_write ( page , wikitext ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> if ( page && ( unlink ( page ) > 0 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> ",<S2SV_ModStart> page_name_is_good ( page ) && <S2SV_ModStart> if ( page_name_is_good ( page ) ) { <S2SV_ModStart> } <S2SV_ModStart> page_name_is_good ( page ) && <S2SV_ModStart> && page_name_is_good ( page ) 
1040,<S2SV_StartBug> int n_read = r -> end - r -> begin ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned int actual_size = f -> blocksize_1 / 2 ; unsigned int limit_r_begin = r -> begin < actual_size ? r -> begin : actual_size ; unsigned int limit_r_end = r -> end < actual_size ? r -> end : actual_size ; <S2SV_ModStart> limit_r_end - limit_r_begin <S2SV_ModEnd> 
1041,<S2SV_StartBug> hdr = ( void * ) p - head -> iov_base ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( hdr > head -> iov_len ) return 0 
1042,<S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> <S2SV_StartBug> write_lock ( & cluster -> cl_nodes_lock ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> o2nm_unlock_subsystem ( ) ; 
1043,<S2SV_StartBug> v4l2_buf = to_vb2_v4l2_buffer ( & vb -> vb . vb2_buf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vb ) { <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! vb ) { dev_dbg ( & dev -> pci -> dev , ""vb<S2SV_blank>is<S2SV_blank>empty,<S2SV_blank>dropping<S2SV_blank>frame\\n"" ) ; return ; } <S2SV_ModStart>  <S2SV_ModEnd> "
1044,<S2SV_StartBug> void * zcalloc ( size_t size ) { <S2SV_EndBug> ,<S2SV_ModStart> ASSERT_NO_SIZE_OVERFLOW ( size ) ; 
1045,<S2SV_StartBug> ssize_t count ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( bytes == 0 || items == 0 ) return 0 
1046,<S2SV_StartBug> rxent -> serviceId == EXTRACT_32BITS ( & rxh -> serviceId ) && <S2SV_EndBug> ,<S2SV_ModStart> EXTRACT_16BITS <S2SV_ModEnd> 
1047,"<S2SV_StartBug> ret = key_permission ( key_ref , KEY_NEED_READ ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { ret = - ENOKEY ; goto error2 ; } "
1048,"<S2SV_StartBug> memset ( adhoc_start -> ssid , 0 , IEEE80211_MAX_SSID_LEN ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( req_ssid -> ssid_len > IEEE80211_MAX_SSID_LEN ) req_ssid -> ssid_len = IEEE80211_MAX_SSID_LEN 
1049,<S2SV_StartBug> if ( error ) <S2SV_EndBug> <S2SV_StartBug> if ( context -> seen_enough ) <S2SV_EndBug> ,<S2SV_ModStart> { kmem_free ( sbuf ) ; <S2SV_ModStart> } 
1050,<S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ; "
1051,<S2SV_StartBug> hrtimer_cancel ( & stime -> hrt ) ; <S2SV_EndBug> ,<S2SV_ModStart> hrtimer_try_to_cancel <S2SV_ModEnd> 
1052,"<S2SV_StartBug> while ( p < q ) p += enclen ( reg -> enc , p ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( q >= end ) return 0 ; 
1053,<S2SV_StartBug> struct l2cap_conf_rfc rfc = { . mode = L2CAP_MODE_BASIC } ; <S2SV_EndBug> <S2SV_StartBug> switch ( pi -> mode ) { <S2SV_EndBug> <S2SV_StartBug> rfc . txwin_size = L2CAP_DEFAULT_RX_WINDOW ; <S2SV_EndBug> <S2SV_StartBug> rfc . retrans_timeout = cpu_to_le16 ( L2CAP_DEFAULT_RETRANS_TO ) ; <S2SV_EndBug> <S2SV_StartBug> rfc . monitor_timeout = cpu_to_le16 ( L2CAP_DEFAULT_MONITOR_TO ) ; <S2SV_EndBug> ,"<S2SV_ModStart> L2CAP_MODE_ERTM <S2SV_ModEnd> <S2SV_ModStart> if ( pi -> num_conf_req || pi -> num_conf_rsp ) goto done ; switch ( pi -> mode ) { case L2CAP_MODE_STREAMING : case L2CAP_MODE_ERTM : pi -> conf_state |= L2CAP_CONF_STATE2_DEVICE ; if ( ! l2cap_mode_supported ( pi -> mode , pi -> conn -> feat_mask ) ) { struct l2cap_disconn_req req ; req . dcid = cpu_to_le16 ( pi -> dcid ) ; req . scid = cpu_to_le16 ( pi -> scid ) ; l2cap_send_cmd ( pi -> conn , l2cap_get_ident ( pi -> conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & req ) ; } break ; default : pi -> mode = l2cap_select_mode ( rfc . mode , pi -> conn -> feat_mask ) ; break ; } done : <S2SV_ModStart> L2CAP_DEFAULT_TX_WINDOW <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> 0 ; rfc . max_pdu_size = cpu_to_le16 ( L2CAP_DEFAULT_MAX_RX_APDU ) ; l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; break ; case L2CAP_MODE_STREAMING : rfc . mode = L2CAP_MODE_STREAMING ; rfc . txwin_size = 0 ; rfc . max_transmit = 0 ; rfc . retrans_timeout = 0 ; rfc . monitor_timeout = 0 <S2SV_ModEnd> "
1054,"<S2SV_StartBug> do ret = recv ( sock_fd , buf , r , MSG_WAITALL ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1055,<S2SV_StartBug> s -> chunksize = - 1 ; <S2SV_EndBug> ,<S2SV_ModStart> UINT64_MAX <S2SV_ModEnd> 
1056,<S2SV_StartBug> if ( ( ps_dec -> u4_first_slice_in_pic != 0 ) && <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1057,<S2SV_StartBug> while ( pair != 0 ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1058,"<S2SV_StartBug> err = tfm -> seed ( tfm , seed , slen ) ; <S2SV_EndBug> ",<S2SV_ModStart> crypto_rng_alg ( tfm ) <S2SV_ModEnd> 
1059,"<S2SV_StartBug> atomic_set ( & new -> count , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! atomic_add_unless ( & ucounts -> count , 1 , INT_MAX ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> == INT_MAX ) ucounts = NULL ; else ucounts -> count += 1 <S2SV_ModEnd> 
1060,<S2SV_StartBug> out_put : <S2SV_EndBug> <S2SV_StartBug> return datagrams ; <S2SV_EndBug> <S2SV_StartBug> return datagrams ; <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( err == 0 ) goto out_put ; if ( datagrams <S2SV_ModEnd> <S2SV_ModStart> { datagrams = err ; goto out_put ; } <S2SV_ModEnd> <S2SV_ModStart> out_put : fput_light ( sock -> file , fput_needed ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
1061,<S2SV_StartBug> void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> ,<S2SV_ModStart> static 
1062,"<S2SV_StartBug> static void prefetch_table ( const volatile byte * tab , size_t len ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < len ; i += 8 * 32 ) <S2SV_EndBug> <S2SV_StartBug> ( void ) tab [ len - 1 ] ; <S2SV_EndBug> ",<S2SV_ModStart> inline <S2SV_ModStart> len - i >= 8 * 32 <S2SV_ModEnd> <S2SV_ModStart> for ( ; i < len ; i += 32 ) { ( void ) tab [ i ] ; } 
1063,<S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_PRE_IO ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) <S2SV_ModEnd> <S2SV_ModStart> if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result ) ; 
1064,"<S2SV_StartBug> static int update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , nfs4_stateid * delegation , int open_flags ) <S2SV_EndBug> <S2SV_StartBug> open_flags &= ( FMODE_READ | FMODE_WRITE ) ; <S2SV_EndBug> <S2SV_StartBug> ( deleg_cur -> type & open_flags ) != open_flags ) <S2SV_EndBug> <S2SV_StartBug> __update_open_stateid ( state , open_stateid , & deleg_cur -> stateid , open_flags ) ; <S2SV_EndBug> <S2SV_StartBug> __update_open_stateid ( state , open_stateid , NULL , open_flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode ) != fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> 
1065,"<S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; ( void ) ResetMagickMemory ( global_colormap , 0 , 3 * MagickMax ( global_colors , 256 ) * sizeof ( * global_colormap ) "
1066,"<S2SV_StartBug> return send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1067,<S2SV_StartBug> static void oidc_scrub_headers ( request_rec * r ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1068,"<S2SV_StartBug> int * out_rate_sum , int64_t * out_dist_sum ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> ( void ) cpi -> fn_ptr [ bs ] . vf ( p -> src . buf , p -> src . stride , <S2SV_EndBug> <S2SV_StartBug> pd -> dst . buf , pd -> dst . stride , & sse ) ; <S2SV_EndBug> <S2SV_StartBug> if ( i == 0 ) <S2SV_EndBug> <S2SV_StartBug> x -> pred_sse [ ref ] = sse ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> speed > 4 ) { <S2SV_EndBug> <S2SV_StartBug> int64_t dist ; <S2SV_EndBug> <S2SV_StartBug> int64_t square_error = sse ; <S2SV_EndBug> <S2SV_StartBug> int quantizer = ( pd -> dequant [ 1 ] >> 3 ) ; <S2SV_EndBug> <S2SV_StartBug> int rate ; <S2SV_EndBug> <S2SV_StartBug> * out_rate_sum = ( int ) rate_sum ; <S2SV_EndBug> ","<S2SV_ModStart> , int * skip_txfm_sb , int64_t * skip_sse_sb <S2SV_ModStart> unsigned int var = 0 ; unsigned int sum_sse = 0 ; int64_t total_sse = 0 ; int skip_flag = 1 ; const int shift = 6 ; int rate ; int64_t dist ; const int dequant_shift = # if CONFIG_VP9_HIGHBITDEPTH ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) ? xd -> bd - 5 : # endif 3 ; x -> pred_sse [ ref ] = 0 ; <S2SV_ModStart> const TX_SIZE max_tx_size = max_txsize_lookup <S2SV_ModEnd> <S2SV_ModStart> ; const BLOCK_SIZE unit_size = txsize_to_bsize [ max_tx_size ] ; const int64_t dc_thr = p -> quant_thred [ 0 ] >> shift ; const int64_t ac_thr = p -> quant_thred [ 1 ] >> shift ; const int64_t low_dc_thr = MIN ( 50 , dc_thr >> 2 ) ; const int64_t low_ac_thr = MIN ( 80 , ac_thr >> 2 ) ; int bw = 1 << ( b_width_log2_lookup [ bs ] - b_width_log2_lookup [ unit_size ] ) ; int bh = 1 << ( b_height_log2_lookup [ bs ] - b_width_log2_lookup [ unit_size ] ) ; int idx , idy ; int lw = b_width_log2_lookup [ unit_size ] + 2 ; int lh = b_height_log2_lookup [ unit_size ] + 2 ; sum_sse = 0 ; for ( idy = 0 ; idy < bh ; ++ idy ) { for ( idx = 0 ; idx < bw ; ++ idx ) { uint8_t * src = <S2SV_ModEnd> <S2SV_ModStart> + ( idy * <S2SV_ModEnd> <S2SV_ModStart> << lh ) + ( idx << lw ) ; uint8_t * dst = <S2SV_ModEnd> <S2SV_ModStart> + ( idy * <S2SV_ModEnd> <S2SV_ModStart> << lh ) + ( idx << lh ) ; int block_idx = ( idy << 1 ) + idx ; int low_err_skip = 0 ; var = cpi -> fn_ptr [ unit_size ] . vf ( src , p -> src . stride , dst , pd -> dst . stride <S2SV_ModStart> x -> bsse [ ( i << 2 ) + block_idx ] = sse ; sum_sse += sse ; x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_NONE ; if ( ! x -> select_tx_size ) { if ( var < ac_thr || var <S2SV_ModEnd> <S2SV_ModStart> { x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_AC_ONLY ; if ( sse - var < dc_thr || sse == var ) { x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_AC_DC ; if ( ! sse || ( var < low_ac_thr && sse - var < low_dc_thr ) ) low_err_skip = 1 ; } } } if ( skip_flag && ! low_err_skip ) skip_flag = 0 ; if ( i == 0 ) x -> <S2SV_ModEnd> <S2SV_ModStart> += sse ; } } total_sse += sum_sse ; <S2SV_ModEnd> <S2SV_ModStart> sf . simple_model_rd_from_var <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModEnd> <S2SV_ModStart> sum_sse <S2SV_ModEnd> <S2SV_ModStart> dequant_shift <S2SV_ModEnd> <S2SV_ModStart> vp9_model_rd_from_var_lapndz ( sum_sse , num_pels_log2_lookup [ bs ] , pd -> dequant [ 1 ] >> dequant_shift , <S2SV_ModEnd> <S2SV_ModStart> skip_txfm_sb = skip_flag ; * skip_sse_sb = total_sse << 4 ; * "
1069,<S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> ,<S2SV_ModStart> pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> 
1070,<S2SV_StartBug> ND_TCHECK ( * pptr ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ,"<S2SV_ModStart> tptr <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""[|esis]"" ) ) <S2SV_ModEnd> "
1071,"<S2SV_StartBug> if ( ( * ptr == '<S2SV_blank>' ) || ( * ptr == '\\t' ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( * ret_username = malloc ( index + 1 ) ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> ( void ) strcpy ( * ret_username , username ) ; <S2SV_EndBug> ",<S2SV_ModStart> || ( index >= PAM_MAX_RESP_SIZE ) ) { break ; } <S2SV_ModEnd> <S2SV_ModStart> index >= PAM_MAX_RESP_SIZE || <S2SV_ModStart> strdup ( username <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1072,"<S2SV_StartBug> static int read_segment_id ( vp9_reader * r , const struct segmentation * seg ) { <S2SV_EndBug> <S2SV_StartBug> return vp9_read_tree ( r , vp9_segment_tree , seg -> tree_probs ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_read_tree <S2SV_ModEnd> 
1073,<S2SV_StartBug> uint32_t backup_handle ; <S2SV_EndBug> <S2SV_StartBug> if ( ret == 0 && res -> backup -> base . num_pages * PAGE_SIZE < <S2SV_EndBug> <S2SV_StartBug> goto out_unlock ; <S2SV_EndBug> ,<S2SV_ModStart> = 0 <S2SV_ModStart> ) { if ( <S2SV_ModEnd> <S2SV_ModStart> } else { backup_handle = req -> buffer_handle ; } 
1074,<S2SV_StartBug> static struct desc_struct * get_desc ( unsigned short sel ) <S2SV_EndBug> <S2SV_StartBug> struct desc_struct * desc = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ldt && sel < ldt -> nr_entries ) <S2SV_EndBug> <S2SV_StartBug> desc = & ldt -> entries [ sel ] ; <S2SV_EndBug> <S2SV_StartBug> return desc ; <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> bool get_desc ( <S2SV_ModStart> out , <S2SV_ModEnd> <S2SV_ModStart> bool success = false <S2SV_ModEnd> <S2SV_ModStart> { * out = <S2SV_ModEnd> <S2SV_ModStart> success = true ; } <S2SV_ModStart> success <S2SV_ModEnd> <S2SV_ModStart> false ; * out = * <S2SV_ModEnd> <S2SV_ModStart> return true ; "
1075,"<S2SV_StartBug> vpx_memset ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst_ptr1 , src_ptr1 , linesize ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst_ptr2 , src_ptr2 , linesize ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
1076,"<S2SV_StartBug> struct sctp_sockaddr_entry * laddr ; <S2SV_EndBug> <S2SV_StartBug> __u8 matchlen = 0 ; <S2SV_EndBug> <S2SV_StartBug> dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ; <S2SV_EndBug> <S2SV_StartBug> dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ; <S2SV_EndBug> ","<S2SV_ModStart> ipv6_pinfo * np = inet6_sk ( sk ) ; struct <S2SV_ModStart> struct in6_addr * final_p , final ; <S2SV_ModStart> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_ModStart> final_p <S2SV_ModEnd> <S2SV_ModStart> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_ModStart> final_p <S2SV_ModEnd> "
1077,"<S2SV_StartBug> static void kgdb_hw_overflow_handler ( struct perf_event * event , int nmi , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1078,"<S2SV_StartBug> buf2 = smb_fdata ( ndo , buf , fmt , maxbuf , unicodestr ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( depth == 10 ) ND_PRINT ( ( ndo , ""(too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>levels,<S2SV_blank>not<S2SV_blank>recursing)"" ) ) ; else "
1079,<S2SV_StartBug> if ( client -> priv -> protocol_timeout ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1080,<S2SV_StartBug> while ( -- n >= 0 && ! ND_TTEST ( * ps ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( ie = io + ps -> nid ; io < ie && ! ND_TTEST ( * io ) ; ++ io ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1081,"<S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ; <S2SV_EndBug> <S2SV_StartBug> header . controlWord = htole16 ( TX_CTRL_TXIC | ( context -> frameId ++ & TX_CTRL_TXFID ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851ClearBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_TXQCR , TXQCR_METFE ) ; <S2SV_EndBug> <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ; <S2SV_EndBug> ","<S2SV_ModStart> KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_TX_CTRL_TXIC <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_TX_CTRL_TXFID <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_TXQCR , KSZ8851_TXQCR_METFE <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> "
1082,<S2SV_StartBug> return key ; <S2SV_EndBug> ,"<S2SV_ModStart> rb_ivar_set ( self , id_key_set , Qtrue ) ; "
1083,<S2SV_StartBug> goto present_leaves_cluster_but_not_new_leaf ; <S2SV_EndBug> <S2SV_StartBug> present_leaves_cluster_but_not_new_leaf : <S2SV_EndBug> ,"<S2SV_ModStart> pr_devel ( ""present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n"" ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1084,<S2SV_StartBug> settings . udpport = 11211 ; <S2SV_EndBug> ,<S2SV_ModStart> 0 <S2SV_ModEnd> 
1085,<S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart> reference_queue_proccess_all ( ) ; 
1086,"<S2SV_StartBug> WORD32 x_8 , x_9 , x_a , x_b , x_c , x_d , x_e , x_f ; <S2SV_EndBug> <S2SV_StartBug> n00 = x_0 + x_2 ; <S2SV_EndBug> <S2SV_StartBug> y1 [ h2 ] = n10 ; <S2SV_EndBug> <S2SV_StartBug> y1 [ h2 + 1 ] = n11 ; <S2SV_EndBug> <S2SV_StartBug> y3 [ h2 ] = n30 ; <S2SV_EndBug> <S2SV_StartBug> y3 [ h2 + 1 ] = n31 ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> y0 [ h2 ] = ixheaacd_add32_sat ( x_0 , x_2 ) ; y0 [ h2 + 1 ] = ixheaacd_add32_sat ( x_1 , x_3 ) ; y1 [ h2 ] = ixheaacd_add32_sat ( x_4 , x_6 ) ; y1 [ h2 + 1 ] = ixheaacd_add32_sat ( x_5 , x_7 ) ; y2 [ h2 ] = ixheaacd_sub32_sat ( x_0 , x_2 ) ; y2 [ h2 + 1 ] = ixheaacd_sub32_sat ( x_1 , x_3 ) ; y3 [ h2 ] = ixheaacd_sub32_sat ( x_4 , x_6 ) ; y3 [ h2 + 1 ] = ixheaacd_sub32_sat ( x_5 , x_7 ) ; x_8 = * x2 ++ ; x_9 = * x2 ++ ; x_a = * x2 ++ ; x_b = * x2 ++ ; x_c = * x2 ++ ; x_d = * x2 ++ ; x_e = * x2 ++ ; x_f = * x2 ++ ; y0 [ h2 + 2 ] = ixheaacd_add32_sat ( x_8 , x_a ) ; y0 [ h2 + 3 ] = ixheaacd_add32_sat ( x_9 , x_b ) <S2SV_ModEnd> <S2SV_ModStart> + 2 ] = ixheaacd_add32_sat ( x_c , x_e ) <S2SV_ModEnd> <S2SV_ModStart> 3 ] = ixheaacd_add32_sat ( x_d , x_f ) ; y2 [ h2 + 2 ] = ixheaacd_sub32_sat ( x_8 , x_a ) ; y2 [ h2 + 3 ] = ixheaacd_sub32_sat ( x_9 , x_b ) <S2SV_ModEnd> <S2SV_ModStart> + 2 ] = ixheaacd_sub32_sat ( x_c , x_e ) <S2SV_ModEnd> <S2SV_ModStart> 3 ] = ixheaacd_sub32_sat ( x_d , x_f ) <S2SV_ModEnd> "
1087,"<S2SV_StartBug> clips = kzalloc ( num_clips * sizeof ( * clips ) , GFP_KERNEL ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS ) { ret = - EINVAL ; goto out_err1 ; } 
1088,<S2SV_StartBug> if ( unlikely ( pmd_trans_huge ( * pmd ) ) ) <S2SV_EndBug> ,<S2SV_ModStart> pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> 
1089,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1090,"<S2SV_StartBug> for ( j = 0 ; j < size ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> r_cons_printf ( ""%02x"" , buf [ j + idx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( op . val != UT64_MAX ) <S2SV_EndBug> <S2SV_StartBug> if ( op . ptr != UT64_MAX ) <S2SV_EndBug> <S2SV_StartBug> printline ( ""ptr"" , ""0x%08"" PFMT64x ""\\n"" , op . ptr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( op . refptr != - 1 ) <S2SV_EndBug> <S2SV_StartBug> printline ( ""refptr"" , ""%d\\n"" , op . refptr ) ; <S2SV_EndBug> ","<S2SV_ModStart> int minsz = R_MIN ( len , size ) ; minsz = R_MAX ( minsz , 0 ) ; <S2SV_ModStart> minsz <S2SV_ModEnd> <S2SV_ModStart> ut8 ch = ( ( j + idx - 1 ) > minsz ) ? 0xff : <S2SV_ModEnd> <S2SV_ModStart> ; r_cons_printf ( ""%02x"" , ch <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } "
1091,"<S2SV_StartBug> int width , height , target_width , target_height ; <S2SV_EndBug> <S2SV_StartBug> usage ( argv [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> usage ( argv [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> usage ( argv [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> usage ( argv [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> usage ( argv [ 0 ] ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; exec_name = argv [ 0 ] <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1092,<S2SV_StartBug> while ( readw ( chip -> DSPQ + JQS_wTail ) != readw ( chip -> DSPQ + JQS_wHead ) ) { <S2SV_EndBug> <S2SV_StartBug> wTmp = readw ( chip -> DSPQ + JQS_wHead ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( wTmp > readw ( chip -> DSPQ + JQS_wSize ) ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> u16 head , tail , size ; head <S2SV_ModEnd> <S2SV_ModStart> ; tail = readw ( chip -> DSPQ + JQS_wTail ) ; size = <S2SV_ModEnd> <S2SV_ModStart> ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * head ) ) ; if ( ++ head > size ) head = 0 ; writew ( head <S2SV_ModEnd> <S2SV_ModStart> out : "
1093,<S2SV_StartBug> OPCODE_DESC * opcode_desc ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 2 ) { return NULL ; } 
1094,<S2SV_StartBug> ACPI_FUNCTION_TRACE ( ns_terminate ) ; <S2SV_EndBug> <S2SV_StartBug> union acpi_operand_object * next ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; ACPI_FUNCTION_TRACE ( ns_terminate ) <S2SV_ModStart>  <S2SV_ModEnd> 
1095,<S2SV_StartBug> data -> l_head = NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> "
1096,"<S2SV_StartBug> strcpy ( the_url , url_arg ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! e ) strcpy ( the_url , gf_dm_sess_get_cache_name ( sess ) ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( the_url , ""MP4Client<S2SV_blank>"" GPAC_FULL_VERSION ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { fprintf ( stderr , ""Input<S2SV_blank>url<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>truncating<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>chars.\\n"" , url_arg , ( int ) ( sizeof ( the_url ) - 1 ) ) ; strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; } else { <S2SV_ModStart> } <S2SV_ModStart> { strncpy <S2SV_ModEnd> <S2SV_ModStart> , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; } <S2SV_ModEnd> <S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <S2SV_ModEnd> "
1097,"<S2SV_StartBug> int i , result ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1098,"<S2SV_StartBug> . match_data . cmp = type -> match , <S2SV_EndBug> ",<S2SV_ModStart> key_default_cmp <S2SV_ModEnd> 
1099,"<S2SV_StartBug> struct vpx_codec_alg_priv * priv ; <S2SV_EndBug> <S2SV_StartBug> priv = calloc ( 1 , sizeof ( struct vpx_codec_alg_priv ) ) ; <S2SV_EndBug> <S2SV_StartBug> ctx -> priv = & priv -> base ; <S2SV_EndBug> <S2SV_StartBug> ctx -> priv -> alg_priv -> cfg = * ctx -> config . enc ; <S2SV_EndBug> <S2SV_StartBug> ctx -> config . enc = & ctx -> priv -> alg_priv -> cfg ; <S2SV_EndBug> <S2SV_StartBug> priv -> vp8_cfg = extracfg_map [ i ] . cfg ; <S2SV_EndBug> <S2SV_StartBug> set_vp8e_config ( & ctx -> priv -> alg_priv -> oxcf , <S2SV_EndBug> <S2SV_StartBug> ctx -> priv -> alg_priv -> cfg , <S2SV_EndBug> <S2SV_StartBug> optr = vp8_create_compressor ( & ctx -> priv -> alg_priv -> oxcf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! optr ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> ","<S2SV_ModStart> vp8_rtcd ( ) ; vpx_dsp_rtcd ( ) ; vpx_scale_rtcd ( ) ; if ( ! ctx -> priv ) { <S2SV_ModStart> = <S2SV_ModEnd> <S2SV_ModStart> * ) vpx_calloc ( 1 , sizeof ( * priv <S2SV_ModStart> ( vpx_codec_priv_t * ) <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart> priv -> cfg ; } <S2SV_ModEnd> <S2SV_ModStart> default_extracfg <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart> priv -> cfg , priv <S2SV_ModEnd> <S2SV_ModStart> priv -> cpi <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart> priv -> cpi <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1100,"<S2SV_StartBug> error = xfs_da_shrink_inode ( args , 0 , bp ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( bp && ( <S2SV_ModEnd> <S2SV_ModStart> != 0 ) <S2SV_ModEnd> 
1101,"<S2SV_StartBug> if ( ( ret = s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ) < 0 ) <S2SV_EndBug> ",<S2SV_ModStart> x >= 16 || c >= 256 ) { return AVERROR_INVALIDDATA ; } if ( 
1102,"<S2SV_StartBug> list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , <S2SV_EndBug> <S2SV_StartBug> spin_lock_irq ( & slave_active_lock ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irq ( & slave_active_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> spin_lock_irq ( & slave_active_lock ) ; spin_lock ( & timer -> lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> list_del_init ( & slave -> ack_list ) ; list_del_init ( & slave -> active_list ) ; } spin_unlock ( & timer -> lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
1103,"<S2SV_StartBug> err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX , <S2SV_EndBug> <S2SV_StartBug> attrs [ TIPC_NLA_SOCK ] , <S2SV_EndBug> <S2SV_StartBug> tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ; <S2SV_EndBug> <S2SV_StartBug> lock_sock ( & tsk -> sk ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX , attrs [ TIPC_NLA_SOCK ] , tipc_nl_sock_policy ) ; if ( err ) return err ; if ( ! sock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ; } if ( done ) return 0 ; tsk = tipc_sk_lookup ( net , tsk_portid ) ; if ( ! tsk ) return - EINVAL ; "
1104,"<S2SV_StartBug> vpx_memset ( ( void * ) ctx -> fragments . ptrs , 0 , sizeof ( ctx -> fragments . ptrs ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ctx -> fragments . sizes , 0 , sizeof ( ctx -> fragments . sizes ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ctx -> fragments . enabled ) <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> && ( data == NULL && data_sz == 0 ) ) { return 0 ; } if ( ! ctx -> fragments . enabled 
1105,"<S2SV_StartBug> vma_stop ( priv , vma ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! IS_ERR ( vma ) ) 
1106,<S2SV_StartBug> length = cap -> bLength ; <S2SV_EndBug> ,<S2SV_ModStart> if ( total_len < sizeof ( * cap ) || total_len < <S2SV_ModEnd> <S2SV_ModStart> ) { dev -> bos -> desc -> bNumDeviceCaps = i ; break ; } length = cap -> bLength <S2SV_ModEnd> 
1107,<S2SV_StartBug> struct task_struct * task = current ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1108,<S2SV_StartBug> switch ( fe -> icbTag . fileType ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ; if ( inode -> i_size > inode -> i_sb -> s_blocksize - udf_file_entry_alloc_offset ( inode ) ) goto out ; } 
1109,"<S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIREGADR , address & REG_ADDR_MASK ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIWRL , LSB ( data ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIWRH , MSB ( data ) ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc28j60ReadReg ( interface , ENC28J60_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) <S2SV_EndBug> ",<S2SV_ModStart> ENC28J60_MIREGADR <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MIWRL <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MIWRH <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MISTAT ) & ENC28J60_MISTAT_BUSY <S2SV_ModEnd> 
1110,<S2SV_StartBug> static int bad_format_imginfo ( <S2SV_EndBug> <S2SV_StartBug> char * ptr ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return bad_format_check ( ""^"" SAFE_STRING ""%s"" SAFE_STRING ""%lu"" SAFE_STRING ""%lu"" SAFE_STRING ""$"" , fmt <S2SV_ModEnd> "
1111,<S2SV_StartBug> kfree ( inet -> opt ) ; <S2SV_EndBug> ,"<S2SV_ModStart> rcu_dereference_protected ( inet -> inet_opt , 1 ) <S2SV_ModEnd> "
1112,<S2SV_StartBug> if ( likely ( walk . nbytes == nbytes ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1113,<S2SV_StartBug> if ( ! saw_digit ) <S2SV_EndBug> <S2SV_StartBug> goto invalid ; <S2SV_EndBug> <S2SV_StartBug> if ( * bp != '\\r' ) <S2SV_EndBug> <S2SV_StartBug> goto invalid ; <S2SV_EndBug> <S2SV_StartBug> if ( * bp != '\\n' ) <S2SV_EndBug> <S2SV_StartBug> goto invalid ; <S2SV_EndBug> <S2SV_StartBug> return ( - 2 ) ; <S2SV_EndBug> <S2SV_StartBug> return ( - 5 ) ; <S2SV_EndBug> ,<S2SV_ModStart> { bp ++ ; <S2SV_ModStart> } <S2SV_ModStart> { bp ++ ; <S2SV_ModStart> } <S2SV_ModStart> { bp ++ ; <S2SV_ModStart> } <S2SV_ModStart> * endp = bp ; <S2SV_ModStart> * endp = bp ; 
1114,<S2SV_StartBug> args -> valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; <S2SV_EndBug> <S2SV_StartBug> args -> valuelen ) ; <S2SV_EndBug> ,<S2SV_ModStart> rmtvaluelen = be32_to_cpu ( name_rmt -> valuelen ) ; args -> rmtblkno <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rmtvaluelen <S2SV_ModEnd> 
1115,<S2SV_StartBug> # endif <S2SV_EndBug> ,"<S2SV_ModStart> UtRegisterTest ( ""DefragTestBadProto"" , DefragTestBadProto ) ; "
1116,<S2SV_StartBug> if ( object_data ) { <S2SV_EndBug> ,"<S2SV_ModStart> coolkey_find_object_by_id ( & priv -> objects_list , object_id ) != NULL ) { return SC_ERROR_INTERNAL ; } if ( "
1117,<S2SV_StartBug> char key [ 32 ] = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> if ( vdaux < 1 || vstart + vdaux < vstart ) { <S2SV_EndBug> <S2SV_StartBug> vstart += vdaux ; <S2SV_EndBug> <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> ,<S2SV_ModStart> size_t vstart_off = i ; <S2SV_ModStart> shdr -> sh_size - vstart_off < vdaux <S2SV_ModEnd> <S2SV_ModStart> += vdaux ; vstart_off <S2SV_ModStart> vstart_off += aux . vda_next ; 
1118,"<S2SV_StartBug> separator = strchr ( token , '=' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
1119,"<S2SV_StartBug> if ( j >= length ) return - 1 ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( cp , packet + j , label_len ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( j + label_len > length ) return - 1 ; 
1120,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % ( bps * stride ) ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""fpAcc"" , ""%s"" , ""cc%(bps*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModStart> return 1 ; "
1121,"<S2SV_StartBug> if ( vma -> vm_ops ) { <S2SV_EndBug> <S2SV_StartBug> pmd , flags , entry ) ; <S2SV_EndBug> <S2SV_StartBug> pte , pmd , flags ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pmd , flags , entry ) ; <S2SV_ModEnd> <S2SV_ModStart> pte , pmd , <S2SV_ModEnd> "
1122,"<S2SV_StartBug> char * r = pool_alloc ( strlen ( s ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( r , s ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t len = strlen ( s ) + 1 ; <S2SV_ModStart> len ) ; memcpy <S2SV_ModEnd> <S2SV_ModStart> , len "
1123,<S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> ,<S2SV_ModStart> key_is_positive <S2SV_ModEnd> 
1124,"<S2SV_StartBug> if ( ! new_idmap_permitted ( ns , cap_setid , & new_map ) ) <S2SV_EndBug> ","<S2SV_ModStart> file , "
1125,"<S2SV_StartBug> sdb_set ( s , ""DW_AT_comp_dir"" , name , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> if ( name > 1024 ) { <S2SV_ModStart> else { eprintf ( ""Invalid<S2SV_blank>string<S2SV_blank>pointer<S2SV_blank>at<S2SV_blank>%p\\n"" , name ) ; } } "
1126,<S2SV_StartBug> p_enc -> fmt_out . p_extra = malloc ( len + sizeof ( eos ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len > UINT32_MAX - sizeof ( eos ) ) return NULL ; 
1127,"<S2SV_StartBug> char * fname = talloc_size ( mf , strlen ( filename ) + 32 ) ; <S2SV_EndBug> <S2SV_StartBug> mp_info ( log , ""search<S2SV_blank>expr:<S2SV_blank>%s\\n"" , filename ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( fname , filename , count ++ ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t fname_avail = <S2SV_ModEnd> <S2SV_ModStart> ; char * fname = talloc_size ( mf , fname_avail <S2SV_ModStart> const char * f = filename ; int MAXDIGS = 3 , nspec = 0 , bad_spec = 0 , c ; while ( nspec < 2 && ( c = * f ++ ) ) { if ( c != '%' ) continue ; if ( * f != '%' ) { nspec ++ ; if ( * f == '.' ) f ++ ; for ( int ndig = 0 ; mp_isdigit ( * f ) && ndig < MAXDIGS ; ndig ++ , f ++ ) ; if ( * f != 'd' ) { bad_spec ++ ; break ; } } f ++ ; } if ( bad_spec || nspec != 1 ) { mp_err ( log , ""unsupported<S2SV_blank>expr<S2SV_blank>format:<S2SV_blank>\'%s\'\\n"" , filename ) ; goto exit_mf ; } <S2SV_ModStart> if ( snprintf ( fname , fname_avail <S2SV_ModEnd> <S2SV_ModStart> >= fname_avail ) { mp_err ( log , ""format<S2SV_blank>result<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>\'%s\'\\n"" , filename ) ; goto exit_mf ; } <S2SV_ModEnd> "
1128,"<S2SV_StartBug> cp += advance ; <S2SV_EndBug> <S2SV_StartBug> nh = * cp ; <S2SV_EndBug> <S2SV_StartBug> advance = rt6_print ( ndo , cp , ( const u_char * ) ip6 ) ; <S2SV_EndBug> <S2SV_StartBug> nh = * cp ; <S2SV_EndBug> <S2SV_StartBug> advance = ah_print ( ndo , cp ) ; <S2SV_EndBug> <S2SV_StartBug> nh = enh & 0xff ; <S2SV_EndBug> ",<S2SV_ModStart> if ( len < ( u_int ) advance ) goto trunc ; <S2SV_ModStart> if ( advance < 0 ) return ; <S2SV_ModStart> ND_TCHECK ( * cp ) ; <S2SV_ModStart> if ( advance < 0 ) return ; <S2SV_ModStart> ; if ( advance < 0 ) return <S2SV_ModStart> if ( advance < 0 ) return ; 
1129,"<S2SV_StartBug> uint32 num_properties = GETINT32 ( buf + idx ) ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < ( a -> names [ i ] . len >> 1 ) ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( a -> type == szMAPI_UNICODE_STRING ) <S2SV_EndBug> <S2SV_StartBug> v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; assert ( ( num_properties + 1 ) != 0 <S2SV_ModStart> assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ; <S2SV_ModStart> assert ( v -> len + idx <= len ) ; <S2SV_ModStart> assert ( v -> len != 0 ) ; 
1130,<S2SV_StartBug> switch ( fe -> icbTag . fileType ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ; if ( inode -> i_size > inode -> i_sb -> s_blocksize - udf_file_entry_alloc_offset ( inode ) ) goto out ; } 
1131,"<S2SV_StartBug> vma = find_vma_prev ( mm , start , & prev ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! mmget_still_valid ( mm ) ) goto out_unlock ; 
1132,"<S2SV_StartBug> act = vp8_variance16x16 ( x -> src . y_buffer , <S2SV_EndBug> ",<S2SV_ModStart> ( void ) cpi ; act = vpx_variance16x16 <S2SV_ModEnd> 
1133,"<S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> ","<S2SV_ModStart> alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE "
1134,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> if ( data ) { <S2SV_EndBug> <S2SV_StartBug> vp9_get_reference_dec ( ctx -> pbi , data -> idx , & fb ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ctx -> frame_parallel_decode ) { set_error_detail ( ctx , ""Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode"" ) ; return VPX_CODEC_INCAPABLE ; } if ( <S2SV_ModStart> VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; fb = get_ref_frame ( & frame_worker_data -> pbi -> common <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( fb == NULL ) return VPX_CODEC_ERROR <S2SV_ModEnd> "
1135,"<S2SV_StartBug> ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; <S2SV_EndBug> <S2SV_StartBug> setup_syscalls_segments ( ctxt , & cs , & ss ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! ( em_syscall_is_enabled ( ctxt ) ) ) return emulate_ud ( ctxt ) ; <S2SV_ModStart> ) ; if ( ! ( efer & EFER_SCE ) ) return emulate_ud ( ctxt 
1136,<S2SV_StartBug> data_ref = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> if ( length > end - start ) return AVERROR_INVALIDDATA ; 
1137,"<S2SV_StartBug> if ( NCH ( n ) == 1 ) { <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> REQ ( CHILD ( n , 1 ) , EQUAL ) ; <S2SV_EndBug> <S2SV_StartBug> targets = _Py_asdl_seq_new ( NCH ( n ) / 2 , c -> c_arena ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < NCH ( n ) - 2 ; i += 2 ) { <S2SV_EndBug> <S2SV_StartBug> value = CHILD ( n , NCH ( n ) - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> return Assign ( targets , expression , LINENO ( n ) , n -> n_col_offset , <S2SV_EndBug> ","<S2SV_ModStart> int num = <S2SV_ModEnd> <S2SV_ModStart> ; if ( num <S2SV_ModStart> , nch_minus_type , has_type_comment <S2SV_ModStart> string type_comment ; <S2SV_ModStart> has_type_comment = TYPE ( CHILD ( n , num - 1 ) ) == TYPE_COMMENT ; nch_minus_type = num - has_type_comment ; <S2SV_ModStart> nch_minus_type <S2SV_ModEnd> <S2SV_ModStart> nch_minus_type <S2SV_ModEnd> <S2SV_ModStart> nch_minus_type <S2SV_ModEnd> <S2SV_ModStart> if ( has_type_comment ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , nch_minus_type ) ) ; if ( ! type_comment ) return NULL ; } else type_comment = NULL ; <S2SV_ModStart> type_comment , "
1138,"<S2SV_StartBug> int vp8_denoiser_filter_c ( YV12_BUFFER_CONFIG * mc_running_avg , <S2SV_EndBug> <S2SV_StartBug> unsigned char * mc_running_avg_y = mc_running_avg -> y_buffer + y_offset ; <S2SV_EndBug> <S2SV_StartBug> unsigned char * running_avg_y = running_avg -> y_buffer + y_offset ; <S2SV_EndBug> <S2SV_StartBug> int r , c , i ; <S2SV_EndBug> <S2SV_StartBug> int adj_val [ 3 ] = { 3 , 4 , 6 } ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 3 ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( absdiff <= 3 ) <S2SV_EndBug> <S2SV_StartBug> sum_diff += diff ; <S2SV_EndBug> <S2SV_StartBug> if ( absdiff >= 4 && absdiff <= 7 ) <S2SV_EndBug> <S2SV_StartBug> sum_diff += adjustment ; <S2SV_EndBug> <S2SV_StartBug> running_avg_y [ c ] = sig [ c ] - adjustment ; <S2SV_EndBug> <S2SV_StartBug> if ( abs ( sum_diff ) > SUM_DIFF_THRESHOLD ) <S2SV_EndBug> <S2SV_StartBug> vp8_copy_mem16x16 ( running_avg -> y_buffer + y_offset , avg_y_stride , <S2SV_EndBug> <S2SV_StartBug> signal -> thismb , sig_stride ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , int mc_avg_y_stride , <S2SV_ModEnd> <S2SV_ModStart> , int avg_y_stride , unsigned char * sig , int sig_stride , unsigned int motion_magnitude , int increase_denoising ) { unsigned char * running_avg_y_start = running_avg_y ; unsigned char * sig_start = sig ; int sum_diff_thresh <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } ; int shift_inc1 = 0 ; int shift_inc2 = 1 ; int col_sum [ 16 ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 <S2SV_ModStart> if ( increase_denoising ) { shift_inc1 = 1 ; shift_inc2 = 2 ; } adj_val [ 0 ] += shift_inc2 ; adj_val [ 1 ] += shift_inc2 ; adj_val [ 2 ] += shift_inc2 <S2SV_ModEnd> <S2SV_ModStart> + shift_inc1 <S2SV_ModStart> col_sum [ c ] <S2SV_ModEnd> <S2SV_ModStart> + shift_inc1 <S2SV_ModStart> col_sum [ c ] += adjustment ; } else { if ( ( sig [ c ] - adjustment ) < 0 ) running_avg_y [ c ] = 0 ; else running_avg_y [ c ] = sig [ c ] - adjustment ; col_sum [ c ] -= adjustment ; } } } sig += sig_stride ; mc_running_avg_y += mc_avg_y_stride ; running_avg_y += avg_y_stride ; } for ( c = 0 ; c < 16 ; ++ c ) { if ( col_sum [ c ] >= 128 ) { col_sum [ c ] = 127 ; } sum_diff += col_sum [ c ] ; } sum_diff_thresh = SUM_DIFF_THRESHOLD ; if ( increase_denoising ) sum_diff_thresh = SUM_DIFF_THRESHOLD_HIGH ; if ( abs ( sum_diff ) > sum_diff_thresh ) { int delta = ( ( abs ( sum_diff ) - sum_diff_thresh ) >> 8 ) + 1 ; if ( delta < 4 ) { sig -= sig_stride * 16 ; mc_running_avg_y -= mc_avg_y_stride * 16 ; running_avg_y -= avg_y_stride * 16 ; for ( r = 0 ; r < 16 ; ++ r ) { for ( c = 0 ; c < 16 ; ++ c ) { int diff = mc_running_avg_y <S2SV_ModEnd> <S2SV_ModStart> sig [ c ] ; int adjustment = abs ( diff ) ; if ( adjustment > delta ) adjustment = delta ; if ( diff > 0 ) { if ( running_avg_y [ c ] - adjustment < 0 ) running_avg_y [ c ] = 0 ; else running_avg_y [ c ] = running_avg_y [ c ] - adjustment ; col_sum [ c ] -= adjustment ; } else if ( diff < 0 ) { if ( running_avg_y [ c ] + adjustment > 255 ) running_avg_y [ c ] = 255 ; else running_avg_y [ c ] = running_avg_y [ c ] + adjustment ; col_sum [ c ] += adjustment ; } } sig += sig_stride ; mc_running_avg_y += mc_avg_y_stride ; running_avg_y += avg_y_stride ; } sum_diff = 0 ; for ( c = 0 ; c < 16 ; ++ c ) { if ( col_sum [ c ] >= 128 ) { col_sum [ c ] = 127 ; } sum_diff += col_sum [ c ] <S2SV_ModEnd> <S2SV_ModStart> sum_diff_thresh <S2SV_ModEnd> <S2SV_ModStart> } else { return COPY_BLOCK ; } } vp8_copy_mem16x16 ( running_avg_y_start <S2SV_ModEnd> <S2SV_ModStart> sig_start <S2SV_ModEnd> "
1139,"<S2SV_StartBug> Ns_Log ( Dev , ""===<S2SV_blank>length<S2SV_blank><<S2SV_blank>avail<S2SV_blank>(length<S2SV_blank>%"" PRIuz <S2SV_EndBug> <S2SV_StartBug> bool complete ; <S2SV_EndBug> <S2SV_StartBug> complete = ChunkedDecode ( reqPtr , NS_TRUE ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ! complete ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> Debug <S2SV_ModEnd> <S2SV_ModStart> SockState chunkState <S2SV_ModEnd> <S2SV_ModStart> chunkState <S2SV_ModEnd> <S2SV_ModStart> chunkState == SOCK_MORE <S2SV_ModEnd> <S2SV_ModStart> else if ( chunkState != SOCK_READY ) { return chunkState ; } 
1140,<S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( ! access_ok ( VERIFY_READ , uregs , sizeof ( elf_xtregs_t ) ) ) return - EFAULT "
1141,<S2SV_StartBug> message -> srcIpAddr = queueItem -> srcIpAddr ; <S2SV_EndBug> ,<S2SV_ModStart> interface = queueItem -> interface ; message -> 
1142,<S2SV_StartBug> struct se_device * remote_dev ; <S2SV_EndBug> <S2SV_StartBug> remote_dev = xop -> dst_dev ; <S2SV_EndBug> <S2SV_StartBug> remote_dev = xop -> src_dev ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pr_debug ( ""putting<S2SV_blank>dst<S2SV_blank>lun_ref<S2SV_blank>for<S2SV_blank>%p\\n"" , <S2SV_ModEnd> <S2SV_ModStart> ) ; else pr_debug ( ""putting<S2SV_blank>src<S2SV_blank>lun_ref<S2SV_blank>for<S2SV_blank>%p\\n"" , <S2SV_ModEnd> <S2SV_ModStart> ) ; percpu_ref_put ( xop -> remote_lun_ref <S2SV_ModEnd> "
1143,"<S2SV_StartBug> err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS."" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; err = - errno ; goto close_sock ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVHOPLIMIT , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVHOPLIMIT,."" "
1144,<S2SV_StartBug> if ( header ) { <S2SV_EndBug> <S2SV_StartBug> ext2_xattr_cache_insert ( new_bh ) ; <S2SV_EndBug> <S2SV_StartBug> ext2_xattr_cache_insert ( new_bh ) ; <S2SV_EndBug> <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> ,"<S2SV_ModStart> struct mb2_cache * ext2_mb_cache = EXT2_SB ( sb ) -> s_mb_cache ; <S2SV_ModStart> ext2_mb_cache , <S2SV_ModStart> ext2_mb_cache , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> __u32 hash = le32_to_cpu ( HDR ( old_bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( ext2_mb_cache , hash , old_bh -> b_blocknr <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1145,"<S2SV_StartBug> snprintf ( rcomp . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""compression"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> ""compression"" , sizeof ( rcomp . type ) <S2SV_ModEnd> "
1146,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_set_active_map ( ctx -> cpi , map -> active_map , map -> rows , map -> cols ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( int ) <S2SV_ModStart> ( int ) 
1147,"<S2SV_StartBug> rc = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> return rc ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( rc ) return rc ; inode -> i_ctime = CURRENT_TIME ; mark_inode_dirty ( inode ) ; } break ; case ACL_TYPE_DEFAULT : ea_name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) return - ENOMEM ; rc = posix_acl_to_xattr ( & init_user_ns , acl , value , size <S2SV_ModStart>  <S2SV_ModEnd> "
1148,<S2SV_StartBug> DestroyImage ( RemoveFirstImageFromList ( & image ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( GetNextImageInList ( image ) != ( Image * ) NULL ) 
1149,"<S2SV_StartBug> task_event -> event_id . header . size , 0 , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1150,<S2SV_StartBug> size_t maxlen = 3 * len ; <S2SV_EndBug> ,<S2SV_ModStart> + 8 
1151,<S2SV_StartBug> SEPARATE_ZVAL ( ( var ) ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_long ( * var ) ; <S2SV_EndBug> <S2SV_StartBug> points [ i ] . x = Z_LVAL_PP ( var ) ; <S2SV_EndBug> <S2SV_StartBug> SEPARATE_ZVAL ( var ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_long ( * var ) ; <S2SV_EndBug> <S2SV_StartBug> points [ i ] . y = Z_LVAL_PP ( var ) ; <S2SV_EndBug> <S2SV_StartBug> if ( filled ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( Z_TYPE_PP ( var ) != IS_LONG ) { zval lval ; lval = * * var ; zval_copy_ctor ( & lval <S2SV_ModEnd> <S2SV_ModStart> & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { points [ i ] . x = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( var ) != IS_LONG ) { zval lval ; lval = * * var ; zval_copy_ctor ( & lval <S2SV_ModEnd> <S2SV_ModStart> & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { points [ i ] . y = <S2SV_ModStart> } 
1152,<S2SV_StartBug> sig_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1153,"<S2SV_StartBug> imbuf = ( unsigned char * ) AcquireQuantumMemory ( imsx * imsy , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) ResetMagickMemory ( imbuf , background_color_index , imsx * imsy ) ; <S2SV_EndBug> <S2SV_StartBug> dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) ResetMagickMemory ( dmbuf , background_color_index , dmsx * dmsy ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) CopyMagickMemory ( dmbuf + dmsx * y , imbuf + imsx * y , imsx ) ; <S2SV_EndBug> <S2SV_StartBug> dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) ResetMagickMemory ( dmbuf , background_color_index , dmsx * dmsy ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) CopyMagickMemory ( dmbuf + dmsx * y , imbuf + imsx * y , imsx ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) ResetMagickMemory ( imbuf + imsx * y + posision_x , color_index , repeat_count ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ) == NULL ) { <S2SV_EndBug> ","<S2SV_ModStart> , imsy <S2SV_ModEnd> <S2SV_ModStart> ( size_t ) <S2SV_ModStart> , dmsy <S2SV_ModEnd> <S2SV_ModStart> ( size_t ) <S2SV_ModStart> ( size_t ) <S2SV_ModStart> , dmsy <S2SV_ModEnd> <S2SV_ModStart> ( size_t ) <S2SV_ModStart> ( size_t ) <S2SV_ModStart> ( size_t ) <S2SV_ModStart> , dmsy <S2SV_ModEnd> "
1154,"<S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> ","<S2SV_ModStart> alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE "
1155,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ; <S2SV_EndBug> <S2SV_StartBug> image2yuvconfig ( & frame -> img , & sd ) ; <S2SV_EndBug> <S2SV_StartBug> return vp9_copy_reference_dec ( ctx -> pbi , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx , ""Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode"" ) ; return VPX_CODEC_INCAPABLE ; } <S2SV_ModStart> VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; <S2SV_ModStart> frame_worker_data <S2SV_ModEnd> "
1156,"<S2SV_StartBug> pop3c -> mailbox = curl_easy_unescape ( data , path , 0 , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! pop3c -> mailbox ) <S2SV_EndBug> ","<S2SV_ModStart> return Curl_urldecode <S2SV_ModEnd> <S2SV_ModStart> & <S2SV_ModEnd> <S2SV_ModStart> , NULL , TRUE ) <S2SV_ModEnd> "
1157,<S2SV_StartBug> facilities_len -= len + 1 ; <S2SV_EndBug> <S2SV_StartBug> facilities_len -= len + 1 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 0 ) return 0 ; <S2SV_ModStart> if ( len < 0 ) return 0 ; 
1158,<S2SV_StartBug> sh -> first_slice_in_pic_flag = get_bits1 ( gb ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( s -> ref && sh -> first_slice_in_pic_flag ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\n"" ) ; return 1 ; } "
1159,<S2SV_StartBug> ps_dec -> ps_cur_slice -> u1_bottom_field_flag = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1160,<S2SV_StartBug> UWORD32 u4_x_dst_offset = 0 ; <S2SV_EndBug> <S2SV_StartBug> impeg2d_dec_pnb_mb_params ( ps_dec ) ; <S2SV_EndBug> <S2SV_StartBug> impeg2d_dec_p_mb_params ( ps_dec ) ; <S2SV_EndBug> ,<S2SV_ModStart> WORD32 ret ; <S2SV_ModStart> ret = <S2SV_ModStart> ret = <S2SV_ModStart> ; if ( ret ) return IMPEG2D_MB_TEX_DECODE_ERR 
1161,<S2SV_StartBug> const YV12_BUFFER_CONFIG * const cfg = <S2SV_EndBug> <S2SV_StartBug> & cm -> frame_bufs [ cm -> ref_frame_map [ 0 ] ] . buf ; <S2SV_EndBug> ,"<S2SV_ModStart> get_ref_frame ( cm , 0 ) ; if ( cfg == NULL ) { vpx_internal_error ( <S2SV_ModStart> error , VPX_CODEC_ERROR , ""No<S2SV_blank>\'last\'<S2SV_blank>reference<S2SV_blank>frame"" ) ; return VPX_CODEC_ERROR ; } <S2SV_ModEnd> "
1162,<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> int rowstep ; <S2SV_EndBug> ,<S2SV_ModStart> jas_matind_t i ; jas_matind_t <S2SV_ModEnd> <S2SV_ModStart> jas_matind_t <S2SV_ModEnd> 
1163,<S2SV_StartBug> const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi ) <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> if ( xd -> mb_to_right_edge < 0 || xd -> mb_to_bottom_edge < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( xd -> mb_to_bottom_edge < 0 ) <S2SV_EndBug> <S2SV_StartBug> i = 0 ; <S2SV_EndBug> <S2SV_StartBug> for ( r = 0 ; r < num_4x4_h ; r += ( 1 << tx_size ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( r < max_blocks_high && c < max_blocks_wide ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> , pd <S2SV_ModStart> = 0 , r , c ; const int max_blocks_wide = num_4x4_w + <S2SV_ModEnd> <S2SV_ModStart> >= 0 ? 0 : <S2SV_ModEnd> <S2SV_ModStart> const int max_blocks_high = num_4x4_h + <S2SV_ModEnd> <S2SV_ModStart> >= 0 ? 0 : <S2SV_ModEnd> <S2SV_ModStart> const int extra_step = ( ( num_4x4_w - max_blocks_wide ) >> tx_size ) * step <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; r += ( 1 << tx_size ) ) { for ( c = 0 ; <S2SV_ModEnd> <S2SV_ModStart> ; c += ( 1 << tx_size ) ) { <S2SV_ModEnd> <S2SV_ModStart> i += extra_step <S2SV_ModEnd> "
1164,<S2SV_StartBug> mm -> mmap_legacy_base = mmap_legacy_base ( random_factor ) ; <S2SV_EndBug> ,<S2SV_ModStart> TASK_UNMAPPED_BASE + random_factor <S2SV_ModEnd> 
1165,<S2SV_StartBug> # if ! ( CONFIG_FAST_UNALIGNED ) <S2SV_EndBug> ,"<S2SV_ModStart> memcpy ( dst , src , 8 ) ; <S2SV_ModEnd> "
1166,"<S2SV_StartBug> case 'c' : return getnum ( L , fmt , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> int sz = getnum ( L , fmt , sizeof ( int ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1167,"<S2SV_StartBug> rowstoread = rowsperstrip - ( row + img -> row_offset ) % rowsperstrip ; <S2SV_EndBug> <S2SV_StartBug> if ( buf == NULL ) <S2SV_EndBug> <S2SV_StartBug> ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> <S2SV_StartBug> p0 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> <S2SV_StartBug> p1 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> <S2SV_StartBug> p2 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> <S2SV_StartBug> pa , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> ","<S2SV_ModStart> uint32 temp ; <S2SV_ModStart> temp = ( row + img -> row_offset ) % rowsperstrip + nrow ; if ( scanline > 0 && temp > ( size_t ) ( TIFF_TMSIZE_T_MAX / scanline ) ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , ""Integer<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>gtStripSeparate"" ) ; return 0 ; } <S2SV_ModStart> temp <S2SV_ModEnd> <S2SV_ModStart> temp <S2SV_ModEnd> <S2SV_ModStart> temp <S2SV_ModEnd> <S2SV_ModStart> temp <S2SV_ModEnd> <S2SV_ModStart> temp <S2SV_ModEnd> "
1168,<S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> abort ( ) <S2SV_ModEnd> 
1169,<S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 2 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> . ptr [ <S2SV_ModEnd> <S2SV_ModStart> . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1170,<S2SV_StartBug> if ( upid == - 1 ) <S2SV_EndBug> ,<S2SV_ModStart> INT_MIN ) return - ESRCH ; if ( upid == 
1171,"<S2SV_StartBug> err = scm_send ( sock , msg , siocb -> scm ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false "
1172,<S2SV_StartBug> if ( num & ( 1 << ( number - 1 ) ) ) <S2SV_EndBug> ,<S2SV_ModStart> number && 
1173,"<S2SV_StartBug> const int w = vpx_img_plane_width ( img , plane ) ; <S2SV_EndBug> <S2SV_StartBug> if ( fread ( buf , 1 , w , file ) != w ) <S2SV_EndBug> ",<S2SV_ModStart> * ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) <S2SV_ModStart> ( size_t ) 
1174,"<S2SV_StartBug> uint16_t attr_len ; <S2SV_EndBug> <S2SV_StartBug> if ( avp -> length < sizeof ( struct l2tp_avp_t ) + 2 ) { <S2SV_EndBug> <S2SV_StartBug> ntohs ( avp -> type ) , avp -> length ) ; <S2SV_EndBug> <S2SV_StartBug> attr_len = avp -> length - sizeof ( struct l2tp_avp_t ) ; <S2SV_EndBug> ",<S2SV_ModStart> avp_len ; uint16_t <S2SV_ModStart> avp_len = avp -> flags & L2TP_AVP_LEN_MASK ; if ( avp_len <S2SV_ModEnd> <S2SV_ModStart> avp_len <S2SV_ModEnd> <S2SV_ModStart> avp_len <S2SV_ModEnd> 
1175,"<S2SV_StartBug> return __blkdev_driver_ioctl ( lc -> dev -> bdev , lc -> dev -> mode , cmd , arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct dm_dev * dev = lc -> dev ; int r = 0 ; if <S2SV_ModEnd> <S2SV_ModStart> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( <S2SV_ModStart>  <S2SV_ModEnd> "
1176,<S2SV_StartBug> len -= POLY1305_BLOCK_SIZE ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len < POLY1305_BLOCK_SIZE ) return 0 ; 
1177,"<S2SV_StartBug> request_module ( ""%s"" , name ) ; <S2SV_EndBug> <S2SV_StartBug> request_module ( ""%s-all"" , name ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""crypto-%s"" <S2SV_ModEnd> <S2SV_ModStart> ""crypto-%s-all"" <S2SV_ModEnd> "
1178,"<S2SV_StartBug> comm_event -> event_id . header . size , 0 , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1179,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> unlink ( RUN_LIB_FILE ) ; 
1180,<S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> ,<S2SV_ModStart> key_is_positive <S2SV_ModEnd> 
1181,"<S2SV_StartBug> BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; memset ( sa , 0 , sizeof ( * sa ) "
1182,"<S2SV_StartBug> memcpy ( pass_salt , cpkt . data , cpkt . length ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( cpkt . length != 16 ) { fprintf ( stderr , _ ( ""Invalid<S2SV_blank>salt<S2SV_blank>length:<S2SV_blank>%d<S2SV_blank>(instead<S2SV_blank>of<S2SV_blank>16)<S2SV_blank>received<S2SV_blank>from<S2SV_blank>server<S2SV_blank>%s\\n"" ) , cpkt . length , ether_ntoa ( ( struct ether_addr * ) dstmac ) ) ; } <S2SV_ModStart> 16 <S2SV_ModEnd> "
1183,<S2SV_StartBug> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ; <S2SV_EndBug> <S2SV_StartBug> if ( ses -> server -> sign ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> | NTLMSSP_NEGOTIATE_SEAL <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1184,<S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> <S2SV_StartBug> # ifdef USE_SSL <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart> bail <S2SV_ModEnd> <S2SV_ModStart> bail <S2SV_ModEnd> <S2SV_ModStart> bail <S2SV_ModEnd> <S2SV_ModStart> bail <S2SV_ModEnd> <S2SV_ModStart> bail <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1185,"<S2SV_StartBug> strlcpy ( rkpp . type , ""kpp"" , sizeof ( rkpp . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> 
1186,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % stride ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horDiff8"" , ""%s"" , ""(cc%stride)!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; "
1187,<S2SV_StartBug> g -> head <= 0 || <S2SV_EndBug> ,<S2SV_ModStart> 0 || ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 
1188,"<S2SV_StartBug> if ( recv ( gpsd_sock , line + pos , sizeof ( line ) - 1 , 0 ) <= 0 ) <S2SV_EndBug> ",<S2SV_ModStart> pos - 
1189,"<S2SV_StartBug> & clen , & remainder , & rlen ) ; <S2SV_EndBug> ","<S2SV_ModStart> , 0 "
1190,"<S2SV_StartBug> read_userfile ( ) ; <S2SV_EndBug> <S2SV_StartBug> md5data [ 0 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( md5data + 1 , user -> password , 82 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( md5data + 1 + strlen ( user -> password ) , curconn -> pass_salt , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> md5_append ( & state , ( const md5_byte_t * ) md5data , strlen ( user -> password ) + 17 ) ; <S2SV_EndBug> ",<S2SV_ModStart> int act_pass_len ; <S2SV_ModStart> act_pass_len = strlen ( user -> password ) ; act_pass_len = act_pass_len <= 82 ? act_pass_len : 82 ; <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> act_pass_len <S2SV_ModEnd> <S2SV_ModStart> act_pass_len <S2SV_ModEnd> <S2SV_ModStart> 1 + act_pass_len + 16 <S2SV_ModEnd> 
1191,"<S2SV_StartBug> return mount_entry_on_generic ( mntent , path ) ; <S2SV_EndBug> ","<S2SV_ModStart> , rootfs -> mount "
1192,"<S2SV_StartBug> if ( PyUnicode_CompareWithASCIIString ( name , ""__debug__"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( PyUnicode_CompareWithASCIIString ( name , * p ) == 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> _PyUnicode_EqualToASCIIString <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> _PyUnicode_EqualToASCIIString <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1193,<S2SV_StartBug> if ( len <= 0 ) <S2SV_EndBug> <S2SV_StartBug> len -= bytes ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned short prev_bi_vcnt = bio -> bi_vcnt ; <S2SV_ModStart> if ( bio -> bi_vcnt == prev_bi_vcnt ) put_page ( pages [ j ] ) ; 
1194,<S2SV_StartBug> assert ( numcolors <= RAS_CMAP_MAXSIZ ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( numcolors > RAS_CMAP_MAXSIZ ) { return - 1 ; } <S2SV_ModEnd> 
1195,"<S2SV_StartBug> const char * path = conn -> data -> state . path ; <S2SV_EndBug> <S2SV_StartBug> smtpc -> domain = curl_easy_unescape ( conn -> data , path , 0 , & len ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> result = Curl_urldecode ( conn -> data , path , 0 , & <S2SV_ModStart> , NULL , TRUE ) ; if ( result ) return result <S2SV_ModEnd> "
1196,"<S2SV_StartBug> strncpy ( str , ""ID:"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( str , jslGetTokenValueAsString ( ) , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( str , ""String:\'"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( str , jslGetTokenValueAsString ( ) , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> espruino_snprintf <S2SV_ModEnd> <S2SV_ModStart> len , ""ID:%s"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> espruino_snprintf <S2SV_ModEnd> <S2SV_ModStart> len , ""String:\'%s\'"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1197,"<S2SV_StartBug> for ( i = j = 0 ; i < sizeof ( buf ) - 1 && str [ i ] ; i ++ , j ++ ) { <S2SV_EndBug> ",<S2SV_ModStart> j <S2SV_ModEnd> 
1198,<S2SV_StartBug> uchar buf [ 2 ] ; <S2SV_EndBug> ,<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
1199,<S2SV_StartBug> return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ; <S2SV_EndBug> ,"<S2SV_ModStart> scat = & rm -> data . op_sg [ sg ] ; ret = <S2SV_ModEnd> <S2SV_ModStart> ; ret = min_t ( int , ret , scat -> length - conn -> c_xmit_data_off ) ; return ret "
1200,"<S2SV_StartBug> priv -> base = devm_ioremap ( & pdev -> dev , r -> start , resource_size ( r ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! r ) return - EINVAL ; 
1201,<S2SV_StartBug> return FALSE ; <S2SV_EndBug> ,<S2SV_ModStart> transport -> credssp = NULL ; 
1202,"
","
"
1203,"<S2SV_StartBug> r_cons_printf ( ""k<S2SV_blank>bin/pe/%s/%d=%s.%s\\n"" , <S2SV_EndBug> <S2SV_StartBug> r_cons_printf ( ""k<S2SV_blank>bin/pe/%s/%d=%s\\n"" , <S2SV_EndBug> ","<S2SV_ModStart> ""\\""k<S2SV_blank>bin/pe/%s/%d=%s.%s\\""\\n"" <S2SV_ModEnd> <S2SV_ModStart> ""\\""k<S2SV_blank>bin/pe/%s/%d=%s\\""\\n"" <S2SV_ModEnd> "
1204,"<S2SV_StartBug> status = decode_getacl ( xdr , rqstp , & res -> acl_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> res <S2SV_ModEnd> 
1205,"<S2SV_StartBug> return mount_entry_on_generic ( mntent , mntent -> mnt_dir ) ; <S2SV_EndBug> ","<S2SV_ModStart> , NULL "
1206,<S2SV_StartBug> return Qnil ; <S2SV_EndBug> ,"<S2SV_ModStart> rb_ivar_set ( self , id_key_set , Qtrue ) ; "
1207,<S2SV_StartBug> return KRB5KDC_ERR_BADOPTION ; <S2SV_EndBug> <S2SV_StartBug> server_princ ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> * status = ""INVALID_S4U2PROXY_OPTIONS"" ; <S2SV_ModStart> * status = ""EVIDENCE_TICKET_MISMATCH"" ; "
1208,<S2SV_StartBug> thread -> tp_value = childregs -> ARM_r3 ; <S2SV_EndBug> ,<S2SV_ModStart> [ 0 ] <S2SV_ModStart> ; thread -> tp_value [ 1 ] = get_tpuser ( ) 
1209,<S2SV_StartBug> jas_stream_t * stream ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( stream = jas_stream_create ( ) ) ) { <S2SV_EndBug> <S2SV_StartBug> obj -> bufsize_ = 1024 ; <S2SV_EndBug> <S2SV_StartBug> obj -> bufsize_ = bufsize ; <S2SV_EndBug> <S2SV_StartBug> obj -> growable_ = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> char * new_buf ; size_t new_bufsize <S2SV_ModEnd> <S2SV_ModStart> bufsize < 0 ) { jas_deprecated ( ""negative<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>for<S2SV_blank>jas_stream_memopen"" ) ; } if ( buf && bufsize <= 0 ) { jas_eprintf ( ""Invalid<S2SV_blank>use<S2SV_blank>of<S2SV_blank>jas_stream_memopen<S2SV_blank>detected.\\n"" ) ; jas_deprecated ( ""A<S2SV_blank>user-provided<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>"" ""jas_stream_memopen<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>growable.\\n"" ) ; } <S2SV_ModEnd> <S2SV_ModStart> new_bufsize = 0 ; new_buf = 0 <S2SV_ModEnd> <S2SV_ModStart> new_bufsize <S2SV_ModEnd> <S2SV_ModStart> new_buf = buf ; } return jas_stream_memopen2 ( new_buf , new_bufsize ) <S2SV_ModEnd> "
1210,"<S2SV_StartBug> struct sshbuf * b ; <S2SV_EndBug> <S2SV_StartBug> char * pkalg , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ; <S2SV_EndBug> <S2SV_StartBug> u_char * pkblob , * sig , have_sig ; <S2SV_EndBug> <S2SV_StartBug> if ( ! authctxt -> valid ) { <S2SV_EndBug> <S2SV_StartBug> __func__ , ssh_err ( r ) ) ; <S2SV_EndBug> <S2SV_StartBug> free ( sig ) ; <S2SV_EndBug> <S2SV_StartBug> fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; <S2SV_EndBug> <S2SV_StartBug> return authenticated ; <S2SV_EndBug> ","<S2SV_ModStart> = NULL <S2SV_ModStart> = NULL <S2SV_ModStart> = NULL <S2SV_ModStart> = NULL <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; } if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; goto done <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; goto done ; } <S2SV_ModStart> free ( sig ) ; "
1211,<S2SV_StartBug> uint32_t bcount ; <S2SV_EndBug> ,<S2SV_ModStart> ; CLEAR ( WaveHeader ) 
1212,<S2SV_StartBug> get_block = ocfs2_get_block ; <S2SV_EndBug> <S2SV_StartBug> get_block = ocfs2_dio_get_block ; <S2SV_EndBug> ,<S2SV_ModStart> ocfs2_lock_get_block <S2SV_ModEnd> <S2SV_ModStart> ocfs2_dio_wr_get_block <S2SV_ModEnd> 
1213,"<S2SV_StartBug> if ( ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) ) { <S2SV_EndBug> ","<S2SV_ModStart> || ( ctx -> cb ) ( sx_sasl_cb_CHECK_MECH , ( void * ) mech , NULL , s , ctx -> cbarg ) != sx_sasl_ret_OK "
1214,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> return - EACCES ; 
1215,"<S2SV_StartBug> if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { <S2SV_EndBug> ","<S2SV_ModStart> memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteFujiEntry ) ) ; "
1216,<S2SV_StartBug> sb -> s_op = & ext2_sops ; <S2SV_EndBug> <S2SV_StartBug> percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ; <S2SV_EndBug> ,"<S2SV_ModStart> # ifdef CONFIG_EXT2_FS_XATTR sbi -> s_mb_cache = ext2_xattr_create_cache ( ) ; if ( ! sbi -> s_mb_cache ) { ext2_msg ( sb , KERN_ERR , ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>an<S2SV_blank>mb_cache"" ) ; goto failed_mount3 ; } # endif <S2SV_ModStart> if ( sbi -> s_mb_cache ) ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ; "
1217,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( is_restricted_mode ( ) && ! btif_storage_is_restricted_device ( bd_addr ) ) return BT_STATUS_SUCCESS ; 
1218,<S2SV_StartBug> if ( len < tcp_hdrlen ) <S2SV_EndBug> <S2SV_StartBug> if ( skb_tailroom ( skb ) < TCPOLEN_MSS ) { <S2SV_EndBug> ,<S2SV_ModStart> || tcp_hdrlen < sizeof ( struct tcphdr ) <S2SV_ModStart> tcp_hdrlen >= 15 * 4 ) return 0 ; if ( 
1219,<S2SV_StartBug> if ( numrows < 0 || numcols < 0 ) { <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> matrix -> datasize_ = numrows * numcols ; <S2SV_EndBug> <S2SV_StartBug> jas_matrix_destroy ( matrix ) ; <S2SV_EndBug> <S2SV_StartBug> jas_matrix_destroy ( matrix ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> size_t size ; matrix = 0 ; <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> 0 ; if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) { goto error ; } matrix -> datasize_ = size <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> error : if ( matrix ) { jas_matrix_destroy ( matrix ) ; } return 0 ; "
1220,<S2SV_StartBug> ipv6_select_ident ( fh ) ; <S2SV_EndBug> <S2SV_StartBug> ipv6_select_ident ( fh ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , rt <S2SV_ModStart> , rt "
1221,"<S2SV_StartBug> ext4_xattr_cache_insert ( struct mb_cache * ext4_mb_cache , struct buffer_head * bh ) <S2SV_EndBug> <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ; <S2SV_EndBug> <S2SV_StartBug> error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_free ( ce ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error == - EBUSY ) { <S2SV_EndBug> <S2SV_StartBug> error = 0 ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> ","<S2SV_ModStart> mb2_cache <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> error = mb2_cache_entry_create <S2SV_ModEnd> <S2SV_ModStart> , hash , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1222,"<S2SV_StartBug> SCSIDiskReq * r ; <S2SV_EndBug> <S2SV_StartBug> r = DO_UPCAST ( SCSIDiskReq , req , req ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1223,<S2SV_StartBug> int avail ; <S2SV_EndBug> <S2SV_StartBug> avail = buf -> len - buf -> cursor ; <S2SV_EndBug> <S2SV_StartBug> if ( nxip < 0 || nxip > avail || expect > avail ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> TXID_SNAPSHOT_MAX_NXIP <S2SV_ModEnd> 
1224,<S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> . ptr [ <S2SV_ModEnd> <S2SV_ModStart> . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1225,<S2SV_StartBug> if ( ret || cm_id -> device -> node_type != RDMA_NODE_IB_CA ) <S2SV_EndBug> ,<S2SV_ModStart> ! cm_id -> device || 
1226,<S2SV_StartBug> struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> struct xfrm_dump_info info ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cb -> args [ 0 ] ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1227,"<S2SV_StartBug> epoll_t * epoll = _cast_epoll ( epoll_ ) ; <S2SV_EndBug> <S2SV_StartBug> if ( oe_syscall_write_ocall ( & ret , epoll -> host_fd , buf , count ) != OE_OK ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ",<S2SV_ModStart> file <S2SV_ModEnd> <S2SV_ModStart> ! file || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( <S2SV_ModStart> file <S2SV_ModEnd> <S2SV_ModStart> if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } 
1228,<S2SV_StartBug> struct dentry * upper = ovl_dentry_upper ( dentry ) ; <S2SV_EndBug> <S2SV_StartBug> err = - ESTALE ; <S2SV_EndBug> <S2SV_StartBug> if ( upper -> d_parent == upperdir ) { <S2SV_EndBug> <S2SV_StartBug> dput ( upper ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> inode_unlock ( dir ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> upper = lookup_one_len ( dentry -> d_name . name , upperdir , dentry -> d_name . len ) ; err = PTR_ERR ( upper ) ; if ( IS_ERR ( upper ) ) goto out_unlock ; <S2SV_ModStart> == ovl_dentry_upper ( dentry ) ) { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dput ( upper ) ; <S2SV_ModStart> out_unlock : "
1229,"<S2SV_StartBug> errstr = parse_global_option ( CMD_INITIALIZE , NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * section_ptr == & new_service_options ) <S2SV_EndBug> ","<S2SV_ModStart> & new_global_options , <S2SV_ModStart>  <S2SV_ModEnd> "
1230,<S2SV_StartBug> if ( ! * ptrptr && ! ( nmemb && size ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1231,<S2SV_StartBug> if ( a -> name == MAPI_BODY_HTML ) <S2SV_EndBug> <S2SV_StartBug> else if ( a -> name == MAPI_RTF_COMPRESSED ) <S2SV_EndBug> ,<S2SV_ModStart> type == szMAPI_BINARY && a -> <S2SV_ModStart> a -> type == szMAPI_BINARY && 
1232,"<S2SV_StartBug> WritePixel ( i , & context , casspecial ) ; npix -- ; <S2SV_EndBug> <S2SV_StartBug> WritePixels ( i , & context , stackp , stack_top - stackp ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( npix > 0 ) <S2SV_ModStart> if ( npix >= ( <S2SV_ModEnd> <S2SV_ModStart> ) { WritePixels ( i , & context , stackp , stack_top - stackp ) ; } else if ( npix > 0 ) { WritePixels ( i , & context , stackp , npix ) ; } <S2SV_ModEnd> "
1233,<S2SV_StartBug> default : <S2SV_EndBug> ,<S2SV_ModStart> case MAGIC_PARAM_ELF_NOTES_MAX : * ( size_t * ) val = ms -> elf_notes_max ; return 0 ; 
1234,"<S2SV_StartBug> jas_eprintf ( ""box<S2SV_blank>type<S2SV_blank>%s\\n"" , box -> info -> name ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""got<S2SV_blank>box<S2SV_blank>type<S2SV_blank>%s\\n"" <S2SV_ModEnd> "
1235,"
","
"
1236,"<S2SV_StartBug> err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf , p + 4 , c , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> + p <S2SV_ModEnd> 
1237,<S2SV_StartBug> journal_t * journal = EXT4_JOURNAL ( page -> mapping -> host ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; if ( ext4_should_dioread_nolock ( page -> mapping -> host ) ) ext4_invalidatepage_free_endio ( page , offset "
1238,"<S2SV_StartBug> trak = gf_isom_get_track ( movie -> moov , i + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> GF_SAFEALLOC ( writer , TrackWriter ) ; <S2SV_EndBug> ",<S2SV_ModStart> GF_SampleTableBox * stbl ; <S2SV_ModStart> stbl = ( trak -> Media && trak -> Media -> information ) ? trak -> Media -> information -> sampleTable : NULL ; if ( ! stbl || ! stbl -> SampleSize || ! stbl -> ChunkOffset || ! stbl -> SampleToChunk ) { return GF_ISOM_INVALID_FILE ; } 
1239,"<S2SV_StartBug> static UINT32 nsc_rle_encode ( BYTE * in , BYTE * out , UINT32 originalSize ) <S2SV_EndBug> ",<S2SV_ModStart> const 
1240,"<S2SV_StartBug> int plen ; <S2SV_EndBug> <S2SV_StartBug> md5data [ 0 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( md5data + 1 , password , 82 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( md5data + 1 + strlen ( password ) , pass_salt , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> md5_append ( & state , ( const md5_byte_t * ) md5data , strlen ( password ) + 17 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , act_pass_len <S2SV_ModStart> act_pass_len = strnlen ( password , 82 ) ; <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> act_pass_len ) <S2SV_ModEnd> <S2SV_ModStart> act_pass_len <S2SV_ModEnd> <S2SV_ModStart> 1 + act_pass_len + 16 <S2SV_ModEnd> "
1241,<S2SV_StartBug> void * dllhandle ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( COM_CompareExtension ( name , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , name ) ; return NULL ; } "
1242,<S2SV_StartBug> if ( _mibindexes ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1243,"<S2SV_StartBug> # define PCDGetBits ( n ) { sum = ( sum << n ) & 0xffffffff ; bits -= n ; while ( bits <= 24 ) { if ( p >= ( buffer + 0x800 ) ) { count = ReadBlob ( image , 0x800 , buffer ) ; p = buffer ; } sum |= ( ( unsigned int ) ( * p ) << ( 24 - bits ) ) ; bits += 8 ; p ++ ; } } <S2SV_EndBug> <S2SV_StartBug> ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , <S2SV_EndBug> <S2SV_StartBug> buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> for ( j = 0 ; j < i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ; <S2SV_ModStart> ) ; for ( j = 0 ; j <= i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] 
1244,"<S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> ",<S2SV_ModStart> i < NCH ( n ) && 
1245,<S2SV_StartBug> g_hash_table_destroy ( headers ) ; <S2SV_EndBug> ,"<S2SV_ModStart> g_hash_table_remove_all ( headers ) ; g_hash_table_insert ( headers , g_strdup ( ""Cookie"" ) , g_strdup ( ""cockpit=d"" ) ) ; if ( cockpit_auth_check_cookie ( test -> auth , ""/cockpit"" , headers ) ) g_assert_not_reached ( ) ; "
1246,"<S2SV_StartBug> char * p ; <S2SV_EndBug> <S2SV_StartBug> p = memchr ( str + 1 , ']' , str_len - 2 ) ; <S2SV_EndBug> <S2SV_StartBug> * portno = atoi ( p + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> * portno = atoi ( colon + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> return host ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> char * <S2SV_ModStart> , * e = NULL <S2SV_ModStart> strtol <S2SV_ModEnd> <S2SV_ModStart> , & e , 10 ) ; if ( e && * e ) { if ( get_err ) { * err = strpprintf ( 0 , ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>address<S2SV_blank>\\""%s\\"""" , str ) ; } return NULL ; } <S2SV_ModEnd> <S2SV_ModStart> char * e = NULL ; <S2SV_ModStart> strtol ( colon + 1 , & e , 10 ) ; if ( ! e || ! * e ) { return <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1247,"<S2SV_StartBug> i , ( unsigned ) JPC_QCX_GETEXPN ( qcd -> compparms . stepsizes [ i ] ) , <S2SV_EndBug> <S2SV_StartBug> i , ( unsigned ) JPC_QCX_GETMANT ( qcd -> compparms . stepsizes [ i ] ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> JAS_CAST ( unsigned , <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> JAS_CAST ( unsigned , <S2SV_ModEnd> <S2SV_ModStart> ) "
1248,"<S2SV_StartBug> for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst , src , src_ybc -> y_width ) ; <S2SV_EndBug> ","<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( src_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) { const uint16_t * src16 = CONVERT_TO_SHORTPTR ( src ) ; uint16_t * dst16 = CONVERT_TO_SHORTPTR ( dst ) ; <S2SV_ModStart> memcpy ( dst16 , src16 , src_ybc -> y_width * sizeof ( uint16_t ) ) ; src16 += src_ybc -> y_stride ; dst16 += dst_ybc -> y_stride ; } return ; } # endif for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) { memcpy <S2SV_ModEnd> "
1249,<S2SV_StartBug> c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , ""cblk<S2SV_blank>size<S2SV_blank>><S2SV_blank>64"" ) ; return AVERROR_PATCHWELCOME ; } "
1250,<S2SV_StartBug> if ( '%' == * ptr ) { <S2SV_EndBug> ,<S2SV_ModStart> && ptr [ 1 ] 
1251,"<S2SV_StartBug> static void encode_rd_sb_row ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( mi_col = tile -> mi_col_start ; mi_col < tile -> mi_col_end ; <S2SV_EndBug> <S2SV_StartBug> int dummy_rate ; <S2SV_EndBug> <S2SV_StartBug> BLOCK_SIZE i ; <S2SV_EndBug> <S2SV_StartBug> for ( i = BLOCK_4X4 ; i < BLOCK_8X8 ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( sf -> partition_search_type == SEARCH_PARTITION && <S2SV_EndBug> <S2SV_StartBug> sf -> partition_search_type == VAR_BASED_PARTITION || <S2SV_EndBug> <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; <S2SV_EndBug> <S2SV_StartBug> & dummy_rate , & dummy_dist , 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , TileDataEnc * tile_data , int mi_row , TOKENEXTRA * * tp ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_ModEnd> <S2SV_ModStart> tile_info = & tile_data -> tile_info ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; SPEED_FEATURES * const sf = & cpi -> sf ; int mi_col ; memset ( & xd -> left_context , 0 , sizeof ( <S2SV_ModEnd> <S2SV_ModStart> ) ) ; memset ( xd -> left_seg_context <S2SV_ModStart> left_seg_context <S2SV_ModEnd> <S2SV_ModStart> tile_info <S2SV_ModEnd> <S2SV_ModStart> tile_info <S2SV_ModEnd> <S2SV_ModStart> const struct segmentation * const seg = & cm -> seg ; <S2SV_ModStart> RD_COST dummy_rdc ; int i ; int seg_skip = 0 ; const int idx_str = cm -> mi_stride * mi_row + mi_col ; MODE_INFO * * mi = cm -> mi_grid_visible + idx_str <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> 64 <S2SV_ModEnd> <S2SV_ModStart> td -> leaf_tree [ i ] . pred_interp_filter = SWITCHABLE ; for ( i = 0 ; i < 64 ; ++ i ) { td -> pc_tree [ i ] . vertical [ 0 ] . pred_interp_filter = SWITCHABLE ; td -> pc_tree [ i ] . vertical [ 1 ] . pred_interp_filter = SWITCHABLE ; td -> pc_tree [ i ] . horizontal [ 0 ] . pred_interp_filter = SWITCHABLE ; td -> pc_tree [ i ] . horizontal [ 1 ] . pred_interp_filter = SWITCHABLE ; } } vp9_zero ( x -> pred_mv ) ; td -> pc_root -> index = 0 ; if ( seg -> enabled ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; int segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ; seg_skip = segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ; } x -> source_variance = UINT_MAX <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> seg_skip ) { const BLOCK_SIZE bsize = seg_skip ? BLOCK_64X64 : sf -> always_this_block_size ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; set_fixed_partitioning ( cpi , tile_info , mi , mi_row , mi_col , bsize ) ; rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; } else if ( cpi -> partition_search_skippable_frame ) { BLOCK_SIZE bsize ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; bsize = get_rd_var_based_fixed_partition ( cpi , x , mi_row , mi_col ) ; set_fixed_partitioning ( cpi , tile_info , mi , mi_row , mi_col , bsize ) ; rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; } else if ( <S2SV_ModStart> && cm -> frame_type != KEY_FRAME ) { choose_partitioning ( cpi , tile_info , x , mi_row , mi_col ) ; rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; } else { if ( sf -> auto_min_max_partition_size <S2SV_ModEnd> <S2SV_ModStart> tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; rd_auto_partition_range ( cpi , tile_info , xd , mi_row , mi_col , & x -> min_partition_size , & x -> max_partition_size ) ; } rd_pick_partition ( cpi , td , tile_data <S2SV_ModEnd> <S2SV_ModStart> dummy_rdc , INT64_MAX , td -> pc_root <S2SV_ModEnd> "
1252,"<S2SV_StartBug> int hexdump ; <S2SV_EndBug> <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) <S2SV_EndBug> ","<S2SV_ModStart> , ret <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE "
1253,"<S2SV_StartBug> static void inc_mvs ( const MB_MODE_INFO * mbmi , const int_mv mvs [ 2 ] , <S2SV_EndBug> <S2SV_StartBug> const MV * ref = & mbmi -> ref_mvs [ mbmi -> ref_frame [ i ] ] [ 0 ] . as_mv ; <S2SV_EndBug> ","<S2SV_ModStart> const MB_MODE_INFO_EXT * mbmi_ext , <S2SV_ModStart> mbmi_ext <S2SV_ModEnd> "
1254,"<S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) ) <S2SV_EndBug> <S2SV_StartBug> encode_frame ( & codec , NULL , - 1 , writer ) ; <S2SV_EndBug> ",<S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> while ( <S2SV_ModStart> ) { } <S2SV_ModEnd> 
1255,"<S2SV_StartBug> if ( pskb_expand_head ( skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> skb_out <S2SV_ModEnd> 
1256,<S2SV_StartBug> spin_lock_init ( & sta -> lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; spin_lock_init ( & sta -> ps_lock 
1257,<S2SV_StartBug> perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) ) <S2SV_EndBug> ,<S2SV_ModStart> perf_paranoid_tracepoint_raw <S2SV_ModEnd> 
1258,<S2SV_StartBug> unregister_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> <S2SV_StartBug> sctp_v4_protosw_exit ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> sctp_ctrlsock_ops <S2SV_ModEnd> <S2SV_ModStart> ) ; unregister_pernet_subsys ( & sctp_defaults_ops 
1259,"<S2SV_StartBug> control_interface = usb_ifnum_to_if ( usb_dev , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( ! data_interface || ! control_interface ) return - ENODEV 
1260,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1261,"<S2SV_StartBug> netsnmp_mibindex_load ( ) ; <S2SV_EndBug> <S2SV_StartBug> add_mibfile ( entry , NULL , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1262,<S2SV_StartBug> struct list_head tmplist ; <S2SV_EndBug> <S2SV_StartBug> if ( oldsp -> do_auto_asconf ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sctp_copy_descendant <S2SV_ModEnd> 
1263,"<S2SV_StartBug> fd = open ( uinput_dev_path [ x ] , O_RDWR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( write ( fd , & dev , sizeof ( dev ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> ioctl ( fd , UI_SET_EVBIT , EV_KEY ) ; <S2SV_EndBug> <S2SV_StartBug> ioctl ( fd , UI_SET_EVBIT , EV_REL ) ; <S2SV_EndBug> <S2SV_StartBug> ioctl ( fd , UI_SET_EVBIT , EV_SYN ) ; <S2SV_EndBug> <S2SV_StartBug> ioctl ( fd , UI_SET_KEYBIT , key_map [ x ] . mapped_id ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ioctl ( fd , UI_DEV_CREATE , NULL ) < 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ; TEMP_FAILURE_RETRY ( <S2SV_ModEnd> <S2SV_ModStart> ) ; TEMP_FAILURE_RETRY ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ; if ( TEMP_FAILURE_RETRY <S2SV_ModEnd> <S2SV_ModStart> ) 
1264,<S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ( desc -> type & BIT ( 3 ) ) ) <S2SV_EndBug> <S2SV_StartBug> switch ( ( desc -> l << 1 ) | desc -> d ) { <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_desc ( & desc , sel ) <S2SV_ModEnd> <S2SV_ModStart> . <S2SV_ModEnd> <S2SV_ModStart> . <S2SV_ModEnd> <S2SV_ModStart> . <S2SV_ModEnd> "
1265,<S2SV_StartBug> vp9_free_frame_buffer ( & ctx -> buf [ i ] . img ) ; <S2SV_EndBug> ,<S2SV_ModStart> vpx_free_frame_buffer <S2SV_ModEnd> 
1266,"<S2SV_StartBug> vp9_lpf_vertical_16 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_lpf_vertical_16 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_8 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } if ( mask_4x4_int & 1 ) vpx_lpf_vertical_4 <S2SV_ModEnd> "
1267,<S2SV_StartBug> atomic_dec ( & user -> inotify_devs ) ; <S2SV_EndBug> ,<S2SV_ModStart> fsnotify_put_group ( group ) ; 
1268,<S2SV_StartBug> iakerb_alloc_context ( iakerb_ctx_id_t * pctx ) <S2SV_EndBug> <S2SV_StartBug> code = krb5_gss_init_context ( & ctx -> k5c ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , int initiate <S2SV_ModStart> ctx -> initiate = initiate ; ctx -> established = 0 ; "
1269,<S2SV_StartBug> dst_known = tnum_is_const ( dst_reg -> var_off ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } 
1270,"<S2SV_StartBug> status = SetImageExtent ( screen , screen -> columns , screen -> rows ) ; <S2SV_EndBug> <S2SV_StartBug> if ( image == ( Image * ) NULL ) <S2SV_EndBug> ","<S2SV_ModStart> if ( image == ( Image * ) NULL ) image = screen ; else AppendImageToList ( & image , screen ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
1271,"<S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) <S2SV_EndBug> ",<S2SV_ModStart> ( <S2SV_ModStart> ) && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) 
1272,<S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> ,<S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto out ; } 
1273,"<S2SV_StartBug> return mono_method_get_object ( mono_object_domain ( rmethod ) , inflated , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! mono_verifier_is_method_valid_generic_instantiation ( inflated ) ) mono_raise_exception ( mono_get_exception_argument ( ""typeArguments"" , ""Invalid<S2SV_blank>generic<S2SV_blank>arguments"" ) ) ; "
1274,"<S2SV_StartBug> int tmp ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( buf , buffer , count ) ) <S2SV_EndBug> ","<S2SV_ModStart> size_t size ; int tmp ; size = min ( count , sizeof ( buf ) ) <S2SV_ModEnd> <S2SV_ModStart> size <S2SV_ModEnd> "
1275,"<S2SV_StartBug> ""Pushing<S2SV_blank>input<S2SV_blank>%d<S2SV_blank>:<S2SV_blank>%.30s\\n"" , ctxt -> inputNr + 1 , input -> cur ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; } if ( ( ( ctxt -> inputNr > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> inputNr > 1024 ) ) { xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ; while ( ctxt -> inputNr > 1 ) xmlFreeInputStream ( inputPop ( ctxt ) ) ; return ( - 1 "
1276,"<S2SV_StartBug> if ( sanity_check_area_boundary ( sbi , bh ) ) <S2SV_EndBug> ","<S2SV_ModStart> le32_to_cpu ( raw_super -> segment_count ) > F2FS_MAX_SEGMENT ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>segment<S2SV_blank>count<S2SV_blank>(%u)"" , le32_to_cpu ( raw_super -> segment_count ) ) ; return 1 ; } if ( "
1277,"<S2SV_StartBug> char * last_elem , * wp ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( ( strncmp ( & name [ 1 ] , ""ORIGIN"" , 6 ) == 0 && ( len = 7 ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> || ( strncmp ( & name [ 1 ] , ""PLATFORM"" , 8 ) == 0 && ( len = 9 ) != 0 ) ) <S2SV_EndBug> <S2SV_StartBug> ? ( __libc_enable_secure ? NULL : l -> l_origin ) <S2SV_EndBug> ","<S2SV_ModStart> const char * const start = name ; <S2SV_ModStart> ""ORIGIN}"" <S2SV_ModEnd> <S2SV_ModStart> ""PLATFORM}"" <S2SV_ModEnd> <S2SV_ModStart> && ( ( name [ len ] != '\\0' && ( ! is_path || name [ len ] != ':' ) ) || ( name != start && ( ! is_path || name [ - 1 ] != ':' ) ) ) "
1278,<S2SV_StartBug> pDecCont = ( decContainer_t * ) H264SwDecMalloc ( sizeof ( decContainer_t ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , 1 "
1279,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> opt = np -> opt ; <S2SV_EndBug> <S2SV_StartBug> return err < 0 ? err : len ; <S2SV_EndBug> ,<S2SV_ModStart> struct ipv6_txoptions * opt_to_free = NULL ; <S2SV_ModStart> { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> <S2SV_ModStart> txopt_put ( opt_to_free ) ; 
1280,<S2SV_StartBug> if ( iph -> ihl == 5 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1281,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> "
1282,"<S2SV_StartBug> err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , <S2SV_EndBug> <S2SV_StartBug> rcu_read_unlock ( ) ; <S2SV_EndBug> ","<S2SV_ModStart> { if ( ! res . fi ) { err = fib_props [ res . type ] . error ; if ( ! err ) err = - EHOSTUNREACH ; <S2SV_ModEnd> <S2SV_ModStart> } err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ; } else { err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ; } if ( err < 0 ) goto errout_free ; "
1283,"<S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> ","<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
1284,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> int limit = ( info -> type == 2 ? vi -> channels : 1 ) * ci -> blocksizes [ 1 ] / 2 ; if ( info -> begin > info -> end || info -> end > limit ) { goto errout ; } 
1285,"<S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , 0 ) ) <S2SV_EndBug> ","<S2SV_ModStart> js_doregexec ( J , <S2SV_ModEnd> "
1286,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> tcp_rcv_space_adjust ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } tp -> copied_seq = seq ; 
1287,<S2SV_StartBug> krb5_key_data * key_data ; <S2SV_EndBug> <S2SV_StartBug> if ( key_data_in == NULL ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i <= num_versions ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( ret [ i ] != NULL ) <S2SV_EndBug> ,<S2SV_ModStart> = NULL ; if ( n_key_data < <S2SV_ModEnd> <S2SV_ModStart> key_data <S2SV_ModEnd> <S2SV_ModStart> ret [ i ] != NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1288,"<S2SV_StartBug> _Unpickler_MemoPut ( UnpicklerObject * self , Py_ssize_t idx , PyObject * value ) <S2SV_EndBug> ",<S2SV_ModStart> size_t <S2SV_ModEnd> 
1289,<S2SV_StartBug> pCsr -> zInput = sqlite3_malloc ( nByte + 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart> sqlite3_malloc64 <S2SV_ModEnd> 
1290,<S2SV_StartBug> sock_release ( SOCKET_I ( inode ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> __sock_release <S2SV_ModEnd> <S2SV_ModStart> , inode "
1291,"<S2SV_StartBug> AsyncFor ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , int <S2SV_EndBug> <S2SV_StartBug> p -> v . AsyncFor . orelse = orelse ; <S2SV_EndBug> ","<S2SV_ModStart> string type_comment , int <S2SV_ModEnd> <S2SV_ModStart> ; p -> v . AsyncFor . type_comment = type_comment "
1292,"<S2SV_StartBug> int mi_sort_index ( MI_CHECK * param , register MI_INFO * info , char * name ) <S2SV_EndBug> <S2SV_StartBug> MYF ( 0 ) ) || <S2SV_EndBug> ","<S2SV_ModStart> , my_bool no_copy_stat <S2SV_ModStart> no_copy_stat ? MYF ( MY_REDEL_NO_COPY_STAT ) : "
1293,"<S2SV_StartBug> opt = xchg ( & inet6_sk ( sk ) -> opt , opt ) ; <S2SV_EndBug> ",<S2SV_ModStart> ( __force struct ipv6_txoptions * * ) 
1294,<S2SV_StartBug> case DB_VECTOR : <S2SV_EndBug> ,"<S2SV_ModStart> AC_VECTOR : kvm_queue_exception_e ( vcpu , AC_VECTOR , error_code ) ; return 1 ; case "
1295,<S2SV_StartBug> default : <S2SV_EndBug> ,"<S2SV_ModStart> case NGHTTP2_ERR_TOO_MANY_SETTINGS : return ""SETTINGS<S2SV_blank>frame<S2SV_blank>contained<S2SV_blank>more<S2SV_blank>than<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>entries"" ; "
1296,"<S2SV_StartBug> Stream_Read_UINT16 ( s , eventId ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( Stream_GetRemainingLength ( s ) < 6 ) return ERROR_INVALID_DATA ; 
1297,"<S2SV_StartBug> if ( - 1 == zsocket_bind ( pData -> socket , ( char * ) pData -> description ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( - 1 == zsocket_connect ( pData -> socket , ( char * ) pData -> description ) ) { <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , <S2SV_ModStart> ""%s"" , "
1298,"<S2SV_StartBug> return chg ; <S2SV_EndBug> <S2SV_StartBug> return - ENOSPC ; <S2SV_EndBug> <S2SV_StartBug> ret = hugetlb_acct_memory ( h , chg ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> { ret = chg ; goto out_err ; } <S2SV_ModEnd> <S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto out_err ; } <S2SV_ModStart> goto out_err <S2SV_ModEnd> <S2SV_ModStart> out_err : resv_map_put ( vma ) ; return ret ; 
1299,"<S2SV_StartBug> struct flowi6 fl6 ; <S2SV_EndBug> <S2SV_StartBug> skb -> len , & fl6 . saddr , & fl6 . daddr ) ; <S2SV_EndBug> <S2SV_StartBug> SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ; <S2SV_EndBug> <S2SV_StartBug> return ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> ","<S2SV_ModStart> * fl6 = & transport -> fl . u . ip6 ; <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> IP6_ECN_flow_xmit ( sk , fl6 -> flowlabel <S2SV_ModEnd> <S2SV_ModStart> SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
1300,"<S2SV_StartBug> inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ; <S2SV_EndBug> ","<S2SV_ModStart> s -> s_stack_depth = path . dentry -> d_sb -> s_stack_depth + 1 ; rc = - EINVAL ; if ( s -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( ""eCryptfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n"" ) ; goto out_free ; } "
1301,"<S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1302,<S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; "
1303,"<S2SV_StartBug> void nego_process_negotiation_failure ( rdpNego * nego , wStream * s ) <S2SV_EndBug> <S2SV_StartBug> WLog_DBG ( TAG , ""RDP_NEG_FAILURE"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> ; if ( Stream_GetRemainingLength ( s ) < 7 ) return FALSE <S2SV_ModStart> return TRUE ; 
1304,"<S2SV_StartBug> int ret , last_pwd ; <S2SV_EndBug> <S2SV_StartBug> ret = decrypt_key_data ( handle -> context , <S2SV_EndBug> <S2SV_StartBug> kdb -> n_key_data , kdb -> key_data , <S2SV_EndBug> ","<S2SV_ModStart> , n_new_keys <S2SV_ModStart> n_new_keys = count_new_keys ( kdb -> n_key_data , kdb -> key_data ) ; <S2SV_ModStart> n_new_keys <S2SV_ModEnd> "
1305,"<S2SV_StartBug> int len , result = RLC_OK ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( ! bn_is_zero ( t ) ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> <S2SV_StartBug> if ( pad != RSA_PUB ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( ! bn_is_zero ( t ) ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> <S2SV_StartBug> if ( pad != RSA_PRV ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> <S2SV_StartBug> } while ( pad != 0 && m_len > 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( m_len == 0 ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> ","<S2SV_ModStart> RLC_ERR <S2SV_ModEnd> <S2SV_ModStart> result = RLC_OK ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> == <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> result = ( m_len > <S2SV_ModEnd> <S2SV_ModStart> } } break ; case RSA_SIG : id = hash_id ( MD_MAP , & len ) ; bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PRV ) ; * p_len = k_len - 3 - m_len - len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , 8 * len ) ; bn_read_bin ( t , id , len ) ; bn_add ( m , m , t ) ; bn_lsh ( m , m , m_len * 8 ) ; result = RLC_OK ; break ; case RSA_SIG_HASH : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PRV ) ; * p_len = k_len - 3 - m_len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , m_len * 8 ) ; result = RLC_OK ; break ; case RSA_VER : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ; if ( bn_is_zero ( t ) ) { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; if ( pad == RSA_PRV ) { int counter = 0 ; do { counter ++ ; m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; } while ( pad == RSA_PAD && m_len > 0 ) ; id = hash_id ( MD_MAP , & len ) ; m_len -= len ; bn_rsh ( t , m , m_len * 8 ) ; int r = 0 ; for ( int i = 0 ; i < len ; i ++ ) { pad = ( uint8_t ) t -> dp [ 0 ] ; r |= pad ^ id [ len - i - 1 ] ; bn_rsh ( t , t , 8 ) ; } * p_len = k_len - m_len ; bn_mod_2b ( m , m , m_len * 8 ) ; if ( r && m_len > 0 && counter >= 8 ) { result = RLC_OK ; } } } <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> == <S2SV_ModEnd> <S2SV_ModStart> int counter = 0 ; do { counter ++ ; <S2SV_ModEnd> <S2SV_ModStart> == RSA_PAD <S2SV_ModEnd> <S2SV_ModStart> * p_len = k_len - m_len ; bn_mod_2b ( m , m , m_len * 8 ) ; <S2SV_ModStart> > 0 && counter >= 8 <S2SV_ModEnd> <S2SV_ModStart> RLC_OK ; } } } <S2SV_ModEnd> "
1306,"<S2SV_StartBug> r2 . re -> flags | RE_FLAGS_SCAN , <S2SV_EndBug> ","<S2SV_ModStart> 0 , "
1307,"<S2SV_StartBug> static vpx_codec_err_t vp8_get_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1308,"<S2SV_StartBug> rq = blk_mq_tag_to_rq ( hctx -> tags , off + bit ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> -> rqs [ <S2SV_ModEnd> <S2SV_ModStart> ] <S2SV_ModEnd> 
1309,"<S2SV_StartBug> if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL ) <S2SV_EndBug> ",<S2SV_ModStart> psf_allocate ( <S2SV_ModEnd> 
1310,<S2SV_StartBug> static void fix_interp_filter ( VP9_COMMON * cm ) { <S2SV_EndBug> <S2SV_StartBug> count [ i ] += cm -> counts . switchable_interp [ j ] [ i ] ; <S2SV_EndBug> ,"<S2SV_ModStart> , FRAME_COUNTS * counts <S2SV_ModStart> counts -> <S2SV_ModEnd> "
1311,<S2SV_StartBug> token ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> ; } if ( operand >= MAX_OPERANDS ) { eprintf ( ""Too<S2SV_blank>many<S2SV_blank>operands\\n"" ) ; return false "
1312,"<S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> x -> act_zbin_adj = 0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_setup_src_planes ( x , cpi -> Source , 0 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> xd -> mi [ 0 ] -> mbmi . mode = DC_PRED ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> above_seg_context , 0 , <S2SV_EndBug> ",<S2SV_ModStart> td . <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
1313,<S2SV_StartBug> dst_name = malloc ( strlen ( name ) * 2 + 16 ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
1314,"<S2SV_StartBug> retval = htc_request_check_host_hdr ( hp ) ; <S2SV_EndBug> <S2SV_StartBug> WSP ( sp , SLT_Error , ""Duplicated<S2SV_blank>Host<S2SV_blank>header"" ) ; <S2SV_EndBug> <S2SV_StartBug> return ( retval ) ; <S2SV_EndBug> ",<S2SV_ModStart> htc_request_check_hdrs <S2SV_ModEnd> <S2SV_ModStart> hp <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1315,"<S2SV_StartBug> char <S2SV_EndBug> <S2SV_StartBug> count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; <S2SV_EndBug> <S2SV_StartBug> image -> page . x = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> image -> page . y = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> one = 1 ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum ( <S2SV_EndBug> <S2SV_StartBug> ReadBlobLSBShort ( image ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> <S2SV_StartBug> do <S2SV_EndBug> <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> plane = ( unsigned char ) operand ; <S2SV_EndBug> <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> <S2SV_StartBug> } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) == <S2SV_EndBug> <S2SV_StartBug> if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length + <S2SV_EndBug> <S2SV_StartBug> if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == <S2SV_EndBug> <S2SV_StartBug> if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == <S2SV_EndBug> <S2SV_StartBug> if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == <S2SV_EndBug> ","<S2SV_ModStart> # define ThrowRLEException ( exception , message ) \\\n{ if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; \\\n} <S2SV_ModStart> colormap = ( unsigned char * ) NULL ; pixel_info = ( MemoryInfo * ) NULL ; <S2SV_ModStart> ( ssize_t ) <S2SV_ModStart> ( ssize_t ) <S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> ThrowRLEException ( <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> ThrowRLEException ( <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> { <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> { <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> { <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } offset = ( ssize_t ) ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> ( offset + <S2SV_ModEnd> <S2SV_ModStart> ( ssize_t ) <S2SV_ModStart> == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> { <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> ( ssize_t ) ( <S2SV_ModStart> ) <S2SV_ModStart> ( offset + <S2SV_ModEnd> <S2SV_ModStart> ( ssize_t ) <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> ( ssize_t ) ( <S2SV_ModStart> ) <S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ( ssize_t ) <S2SV_ModStart> ( ssize_t ) <S2SV_ModStart> ( ssize_t ) "
1316,<S2SV_StartBug> INIT_LIST_HEAD ( & card -> controls ) ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_init ( & card -> user_ctl_lock ) ; 
1317,<S2SV_StartBug> s += padlen + 3 ; <S2SV_EndBug> <S2SV_StartBug> ( * psig ) = s ; <S2SV_EndBug> ,"<S2SV_ModStart> ( * psig ) = s + <S2SV_ModEnd> <S2SV_ModStart> { const u_char * p ; size_t cnt_ffs = 0 ; for ( p = s + 2 ; p < s + padlen + 2 ; p ++ ) if ( * p == 0xFF ) cnt_ffs ++ ; if ( cnt_ffs != padlen ) return ""4"" ""invalid<S2SV_blank>Padding<S2SV_blank>String"" ; } <S2SV_ModEnd> "
1318,"<S2SV_StartBug> int ret = write ( tap_fd , packet , len + sizeof ( tETH_HDR ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1319,<S2SV_StartBug> if ( ps_dec -> u1_first_slice_in_stream ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1320,<S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> - 1 <S2SV_ModEnd> <S2SV_ModStart> if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> - 1 <S2SV_ModEnd> 
1321,"<S2SV_StartBug> struct flowi6 fl6 ; <S2SV_EndBug> <S2SV_StartBug> skb -> len , & fl6 . saddr , & fl6 . daddr ) ; <S2SV_EndBug> <S2SV_StartBug> SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ; <S2SV_EndBug> <S2SV_StartBug> return ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> ","<S2SV_ModStart> * fl6 = & transport -> fl . u . ip6 ; <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> IP6_ECN_flow_xmit ( sk , fl6 -> flowlabel <S2SV_ModEnd> <S2SV_ModStart> SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
1322,<S2SV_StartBug> if ( args -> buffer_count < 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> || args -> buffer_count > UINT_MAX / sizeof ( * exec2_list ) 
1323,"<S2SV_StartBug> mptctl_getiocinfo ( unsigned long arg , unsigned int data_size ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> struct pci_dev * pdev ; <S2SV_EndBug> <S2SV_StartBug> return PTR_ERR ( karg ) ; <S2SV_EndBug> ","<S2SV_ModStart> MPT_ADAPTER * ioc , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1324,"<S2SV_StartBug> lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ; <S2SV_EndBug> ","<S2SV_ModStart> luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_unpack_full"" ) ; "
1325,"<S2SV_StartBug> const char * path ) <S2SV_EndBug> <S2SV_StartBug> mntflags , mntdata , optional ) ; <S2SV_EndBug> ","<S2SV_ModStart> , const char * rootfs <S2SV_ModStart> , rootfs "
1326,"<S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 3 * <S2SV_EndBug> ","<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
1327,"<S2SV_StartBug> int i , len ; <S2SV_EndBug> <S2SV_StartBug> const char __user * p ; <S2SV_EndBug> <S2SV_StartBug> audit_log_format ( * ab , ""argc=%d"" , context -> execve . argc ) ; <S2SV_EndBug> <S2SV_StartBug> buf = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! buf ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < context -> execve . argc ; i ++ ) { <S2SV_EndBug> ","<S2SV_ModStart> long len_max ; long len_rem ; long len_full ; long len_buf ; long len_abuf ; long len_tmp ; bool require_data ; bool encode ; unsigned int iter ; unsigned int arg ; char * buf_head ; char * buf <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> char abuf [ 96 ] ; WARN_ON_ONCE ( MAX_EXECVE_AUDIT_LEN > 7500 ) ; len_max = MAX_EXECVE_AUDIT_LEN ; buf_head = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ; if ( ! buf_head ) { audit_panic ( ""out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>argv<S2SV_blank>string"" ) ; return ; } buf = buf_head ; <S2SV_ModStart> len_rem = len_max ; len_buf = 0 ; len_full = 0 ; require_data = true ; encode = false ; iter = 0 ; arg = 0 ; do { if ( len_full == 0 ) len_full = strnlen_user ( p , MAX_ARG_STRLEN ) - 1 ; if ( require_data ) { if ( buf != buf_head ) { memmove ( buf_head , buf , len_buf ) ; buf = buf_head ; } len_tmp = strncpy_from_user ( & buf_head [ len_buf ] , p , len_max - len_buf ) ; if ( len_tmp == - EFAULT ) { send_sig ( SIGKILL , current , 0 ) ; goto out ; } else if ( len_tmp == ( len_max - len_buf ) ) { require_data = true ; encode = true ; len_full = len_full * 2 ; p += len_tmp ; } else { require_data = false ; if ( ! encode ) encode = audit_string_contains_control ( buf , len_tmp ) ; if ( len_full < len_max ) len_full = ( encode ? len_tmp * 2 : len_tmp ) ; p += len_tmp + 1 ; } len_buf += len_tmp ; buf_head [ len_buf ] = '\\0' ; len_abuf = ( encode ? len_buf * 2 : len_buf + 2 ) ; } if ( len_buf > 0 ) { if ( ( sizeof ( abuf ) + 8 ) > len_rem ) { len_rem = len_max ; audit_log_end ( * ab ) ; * ab = audit_log_start ( context , GFP_KERNEL , AUDIT_EXECVE <S2SV_ModEnd> <S2SV_ModStart> * ab ) goto out ; } len_tmp = 0 ; if ( require_data || ( iter > 0 ) || ( ( len_abuf + sizeof ( abuf ) ) > len_rem ) ) { if ( iter == 0 ) { len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d_len=%lu"" , arg , len_full ) ; } len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d[%d]="" , arg , iter ++ ) ; } else len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d="" , arg ) ; WARN_ON ( len_tmp >= sizeof ( abuf ) ) ; abuf [ sizeof ( abuf ) - 1 ] = '\\0' ; audit_log_format ( * ab , ""%s"" , abuf ) ; len_rem -= len_tmp ; len_tmp = len_buf ; if ( encode ) { if ( len_abuf > len_rem ) len_tmp = len_rem / 2 ; audit_log_n_hex ( * ab , buf , len_tmp ) ; len_rem -= len_tmp * 2 ; len_abuf -= len_tmp * 2 ; } else { if ( len_abuf > len_rem ) len_tmp = len_rem - 2 ; audit_log_n_string ( * ab , buf , len_tmp ) ; len_rem -= len_tmp + 2 ; len_abuf -= len_tmp ; } len_buf -= len_tmp ; buf += len_tmp ; } if ( ( len_buf == 0 ) && ! require_data ) { arg ++ ; iter = 0 ; len_full = 0 ; require_data = true ; encode = false ; } } while ( arg <S2SV_ModEnd> <S2SV_ModStart> ) ; out : kfree ( buf_head <S2SV_ModEnd> "
1328,"<S2SV_StartBug> fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , mode > 0 ? mode : 0644 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ( mode == 0 || mode == MODE_INVALID ) ? 0644 : mode <S2SV_ModEnd> 
1329,"<S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> char line [ NETSCREEN_LINE_LENGTH ] ; <S2SV_EndBug> <S2SV_StartBug> pkt_len = parse_netscreen_rec_hdr ( phdr , line , cap_int , & cap_dir , <S2SV_EndBug> <S2SV_StartBug> if ( pkt_len == - 1 ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return parse_netscreen_packet ( wth -> random_fh , phdr , buf <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1330,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> u64 irq_time ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( rq -> skip_clock_update ) return <S2SV_ModStart>  <S2SV_ModEnd> 
1331,<S2SV_StartBug> switch ( depth ) <S2SV_EndBug> <S2SV_StartBug> CheckNumberCompactPixels ; <S2SV_EndBug> ,<S2SV_ModStart> CheckNumberCompactPixels ; <S2SV_ModStart>  <S2SV_ModEnd> 
1332,"<S2SV_StartBug> raw_printf ( ""Unknown<S2SV_blank>option:<S2SV_blank>%s"" , * argv ) ; <S2SV_EndBug> <S2SV_StartBug> raw_printf ( ""Unknown<S2SV_blank>option:<S2SV_blank>%s"" , * argv ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""Unknown<S2SV_blank>option:<S2SV_blank>%.60s"" <S2SV_ModEnd> <S2SV_ModStart> ""Unknown<S2SV_blank>option:<S2SV_blank>%.60s"" <S2SV_ModEnd> "
1333,"<S2SV_StartBug> struct blkif_response resp ; <S2SV_EndBug> <S2SV_StartBug> resp . id = id ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) , <S2SV_EndBug> <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) , <S2SV_EndBug> <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> * <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> resp = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> resp = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> resp = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> resp -> id = id ; resp -> operation = op ; resp -> status = st ; 
1334,<S2SV_StartBug> if ( ! ( mask & KADM5_ATTRIBUTES ) || <S2SV_EndBug> ,<S2SV_ModStart> password == NULL || 
1335,"<S2SV_StartBug> if ( ( datao + 12 < datao ) || ( datao + 12 < 12 ) || ( datao + 12 > buf_size ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) || <S2SV_EndBug> <S2SV_StartBug> if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) { <S2SV_EndBug> <S2SV_StartBug> ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) || <S2SV_EndBug> ","<S2SV_ModStart> CHECKOVERFLOW ( datao , buf_size , 12 <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( datao , buf_size , 2 <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components <S2SV_ModEnd> <S2SV_ModStart> ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( <S2SV_ModEnd> <S2SV_ModStart> ) , <S2SV_ModEnd> <S2SV_ModStart> ) ; continue ; } <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs <S2SV_ModEnd> "
1336,"<S2SV_StartBug> sprintf ( charbuf , ""%s/%s.html"" , dirout , rootname ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( charbuf , ""%s/%s-links.html"" , dirout , rootname ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( charbuf , ""%s_thumb_%03d"" , rootname , index ) ; <S2SV_EndBug> ","<S2SV_ModStart> snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> "
1337,<S2SV_StartBug> snapend_save = ndo -> ndo_snapend ; <S2SV_EndBug> ,<S2SV_ModStart> ; ND_TCHECK_16BITS ( & ip -> ip_len ) 
1338,<S2SV_StartBug> struct dentry * dir ; <S2SV_EndBug> <S2SV_StartBug> ci = d_inode ( dir ) -> i_crypt_info ; <S2SV_EndBug> <S2SV_StartBug> dir_has_key = ( ci != NULL ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> d_inode ( dir ) -> i_crypt_info <S2SV_ModEnd> 
1339,<S2SV_StartBug> void unbind_ports ( void ) { <S2SV_EndBug> <S2SV_StartBug> CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_SECTIONS ] ) ; <S2SV_EndBug> <S2SV_StartBug> service_options . next = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( opt -> ctx ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> NOEXPORT <S2SV_ModStart> for ( <S2SV_ModEnd> <S2SV_ModStart> opt ; opt = opt -> next <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } } <S2SV_ModEnd> 
1340,<S2SV_StartBug> numbers [ argc ++ ] = ( unsigned long ) mtree_atol ( & p ) ; <S2SV_EndBug> <S2SV_StartBug> if ( argc > MAX_PACK_ARGS ) { <S2SV_EndBug> ,"<S2SV_ModStart> if ( argc >= MAX_PACK_ARGS ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Too<S2SV_blank>many<S2SV_blank>arguments"" ) ; return ARCHIVE_WARN ; } <S2SV_ModStart>  <S2SV_ModEnd> "
1341,<S2SV_StartBug> context . Xtogo = i -> width ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\n"" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\n"" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\n"" ) ; # endif i -> posY = i -> parent -> height - i -> height ; } "
1342,<S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> ,<S2SV_ModStart> l > ( unsigned ) ( <S2SV_ModEnd> <S2SV_ModStart> - p ) <S2SV_ModStart> l > ( unsigned ) ( <S2SV_ModEnd> <S2SV_ModStart> - p ) <S2SV_ModStart> l > ( unsigned ) ( <S2SV_ModEnd> <S2SV_ModStart> - p ) <S2SV_ModStart> l > ( unsigned ) ( <S2SV_ModEnd> <S2SV_ModStart> - p ) 
1343,<S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> ,<S2SV_ModStart> = { 0 } 
1344,"<S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> if ( tag == 0xFFFEE0DD ) <S2SV_EndBug> ","<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( "
1345,<S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! recovery_started ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , ""Not<S2SV_blank>in<S2SV_blank>Recovery<S2SV_blank>mode"" ) ; layoutHome ( ) ; return ; } "
1346,"<S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT1 , hashTable [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , hashTable [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , hashTable [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT4<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT4 ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ENC624J600_EHT1 , hashTable [ 0 ] ) ; enc624j600WriteReg ( interface , ENC624J600_EHT2 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EHT3 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EHT4 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EHT1 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EHT2 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EHT3 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EHT4 <S2SV_ModEnd> "
1347,"<S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 256UL , image -> rows * <S2SV_EndBug> ",<S2SV_ModStart> 257UL <S2SV_ModEnd> 
1348,"<S2SV_StartBug> if ( containsForbiddenChars ( p , l ) ) { <S2SV_EndBug> ","<S2SV_ModStart> memset ( newserv , 0 , sizeof ( struct service ) ) ; "
1349,"<S2SV_StartBug> WORD32 i ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < BUF_MGR_MAX_CNT ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , i , BUF_MGR_REF ) ; <S2SV_EndBug> ","<S2SV_ModStart> , j <S2SV_ModStart> j = 0 ; j < ps_codec -> i4_max_dpb_size ; j <S2SV_ModEnd> <S2SV_ModStart> j <S2SV_ModEnd> "
1350,"<S2SV_StartBug> ret = put_user ( task_thread_info ( child ) -> tp_value , <S2SV_EndBug> ",<S2SV_ModStart> [ 0 ] 
1351,<S2SV_StartBug> goto fail ; <S2SV_EndBug> ,<S2SV_ModStart> ret = - EINVAL ; 
1352,"<S2SV_StartBug> static char * print_object ( cJSON * item , int depth , int fmt ) <S2SV_EndBug> <S2SV_StartBug> while ( child ) { <S2SV_EndBug> <S2SV_StartBug> names [ i ] = str = print_string_ptr ( child -> string ) ; <S2SV_EndBug> <S2SV_StartBug> entries [ i ++ ] = ret = print_value ( child , depth , fmt ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! fail ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < numentries ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> if ( fmt ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < numentries ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < depth ; ++ j ) <S2SV_EndBug> <S2SV_StartBug> strcpy ( ptr , names [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> ptr += strlen ( names [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( fmt ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < depth - 1 ; ++ i ) <S2SV_EndBug> <S2SV_StartBug> * ptr ++ = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> , printbuffer * p <S2SV_ModStart> size_t tmplen = 0 ; <S2SV_ModStart> numentries ++ , child = child -> next ; if ( ! numentries ) { if ( p ) out = ensure ( p , fmt ? depth + 4 : 3 ) ; else out = ( char * ) cJSON_malloc ( fmt ? depth + 4 : 3 ) ; if ( ! out ) return 0 ; ptr = out ; * ptr ++ = '{' ; if ( fmt ) { * ptr ++ = '\\n' ; for ( i = 0 ; i < depth ; i ++ ) * ptr ++ = '\\t' ; } * ptr ++ = '}' ; * ptr ++ = 0 ; return out ; } if ( p ) { i = p -> offset ; len = fmt ? 2 : 1 ; ptr = ensure ( p , len + 1 ) ; if ( ! ptr ) return 0 ; * ptr ++ = '{' ; if ( fmt ) * ptr ++ = '\\n' ; * ptr = 0 ; p -> offset += len ; child = item -> child ; depth ++ ; while ( child ) { if ( fmt ) { ptr = ensure ( p , depth ) ; if ( ! ptr ) return 0 ; for ( j = 0 ; j < depth ; j ++ ) * ptr ++ = '\\t' ; p -> offset += depth ; } print_string_ptr ( child -> string , p ) ; p -> offset = update ( p ) ; len = fmt ? 2 : 1 ; ptr = ensure ( p , len ) ; if ( ! ptr ) return 0 ; * ptr ++ = ':' ; if ( fmt ) * ptr ++ = '\\t' ; p -> offset += len ; print_value ( child , depth , fmt , p ) ; p -> offset = update ( p ) ; len = ( fmt ? 1 : 0 ) + ( child -> next ? 1 : 0 ) ; ptr = ensure ( p , len + 1 ) ; if ( ! ptr ) return 0 ; if ( child -> next ) * ptr ++ = ',' ; if ( fmt ) * ptr ++ = '\\n' ; * ptr = 0 ; p -> offset += len ; child = child -> next ; } ptr = ensure ( p , fmt ? ( depth + 1 ) : 2 ) ; if ( ! ptr ) return 0 ; if ( fmt ) for ( i = 0 ; i < depth - 1 ; i ++ ) * ptr ++ = '\\t' ; * ptr ++ = '}' ; * ptr = 0 ; out = ( p -> buffer ) + i ; } else { entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ; if ( ! entries ) return 0 ; names = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ; if ( ! names ) { cJSON_free ( entries ) ; return 0 ; } memset ( entries , 0 , sizeof ( char * ) * numentries ) ; memset ( names , 0 , sizeof ( char * ) * numentries ) ; child = item -> child ; depth ++ ; if ( fmt ) len += depth ; while ( child && ! fail ) <S2SV_ModEnd> <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> i ++ <S2SV_ModEnd> <S2SV_ModStart> if ( fmt ) <S2SV_ModEnd> <S2SV_ModStart> i ++ ) <S2SV_ModEnd> <S2SV_ModStart> j ++ ) <S2SV_ModEnd> <S2SV_ModStart> tmplen = strlen ( <S2SV_ModEnd> <S2SV_ModStart> memcpy ( ptr , <S2SV_ModEnd> <S2SV_ModStart> , tmplen ) ; ptr += tmplen <S2SV_ModEnd> <S2SV_ModStart> if ( fmt ) <S2SV_ModEnd> <S2SV_ModStart> i ++ ) <S2SV_ModEnd> <S2SV_ModStart> * ptr ++ = 0 ; } <S2SV_ModEnd> "
1353,<S2SV_StartBug> struct ikev2_id id ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> ,<S2SV_ModStart> const struct ikev2_id * idp ; <S2SV_ModStart> idp = ( const struct ikev2_id * ) ext ; <S2SV_ModStart> idp <S2SV_ModEnd> 
1354,"<S2SV_StartBug> ber_parse_header ( STREAM s , int tagval , int * length ) <S2SV_EndBug> ",<S2SV_ModStart> uint32 <S2SV_ModEnd> 
1355,<S2SV_StartBug> other = unix_peer_get ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unix_peer ( other ) != sk ) { <S2SV_EndBug> <S2SV_StartBug> if ( unix_recvq_full ( other ) ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( writable ) { unix_state_lock ( sk ) ; other = unix_peer ( sk ) ; if ( other && unix_peer ( <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> && unix_dgram_peer_wake_me ( sk , other ) <S2SV_ModStart> unix_state_unlock ( sk <S2SV_ModEnd> "
1356,<S2SV_StartBug> size_t <S2SV_EndBug> <S2SV_StartBug> value = ( size_t ) ( buffer [ 0 ] << 24 ) ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 1 ] << 16 ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 2 ] << 8 ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 3 ] ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffffffff ) ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned int <S2SV_ModEnd> <S2SV_ModStart> unsigned int ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( unsigned int ) <S2SV_ModStart> ( unsigned int ) <S2SV_ModStart> ( unsigned int ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1357,"<S2SV_StartBug> outpos += sprintf ( outpos , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>re"" , x , y , w , h ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sendClean ( outputbuffer ) ; 
1358,"<S2SV_StartBug> if ( pskb_expand_head ( skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> skb_out <S2SV_ModEnd> 
1359,<S2SV_StartBug> void exit_io_context ( void ) <S2SV_EndBug> <S2SV_StartBug> task_lock ( current ) ; <S2SV_EndBug> <S2SV_StartBug> ioc = current -> io_context ; <S2SV_EndBug> <S2SV_StartBug> current -> io_context = NULL ; <S2SV_EndBug> <S2SV_StartBug> task_unlock ( current ) ; <S2SV_EndBug> ,<S2SV_ModStart> struct task_struct * task <S2SV_ModEnd> <S2SV_ModStart> task <S2SV_ModEnd> <S2SV_ModStart> task <S2SV_ModEnd> <S2SV_ModStart> task <S2SV_ModEnd> <S2SV_ModStart> task <S2SV_ModEnd> 
1360,<S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( ! access_ok ( VERIFY_READ , uregs , sizeof ( elf_xtregs_t ) ) ) return - EFAULT "
1361,<S2SV_StartBug> * minor_status = ( OM_uint32 ) KRB5_BAD_MSIZE ; <S2SV_EndBug> <S2SV_StartBug> if ( header -> buffer . length < token_wrapper_len + 14 ) { <S2SV_EndBug> ,<S2SV_ModStart> ; return GSS_S_DEFECTIVE_TOKEN ; } if ( ctx -> seq == NULL ) { * minor_status = 0 <S2SV_ModStart> 22 <S2SV_ModEnd> 
1362,"<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> ret = xen_pcibk_read_config_word ( dev , offset , value , data ) ; <S2SV_EndBug> <S2SV_StartBug> * value |= PCI_COMMAND_IO ; <S2SV_EndBug> ",<S2SV_ModStart> ret = pci_read_config_word <S2SV_ModEnd> <S2SV_ModStart> ) ; const struct pci_cmd_info * cmd = data ; * value &= PCI_COMMAND_GUEST ; <S2SV_ModEnd> <S2SV_ModStart> cmd -> val & ~ PCI_COMMAND_GUEST ; <S2SV_ModEnd> 
1363,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vp9_ref_frame_t * frame = va_arg ( args , vp9_ref_frame_t * ) ; <S2SV_EndBug> <S2SV_StartBug> YV12_BUFFER_CONFIG * fb ; <S2SV_EndBug> <S2SV_StartBug> vp9_get_reference_enc ( ctx -> cpi , frame -> idx , & fb ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> = get_ref_frame ( & <S2SV_ModEnd> <S2SV_ModStart> -> common <S2SV_ModStart> ) ; if ( fb == NULL ) return VPX_CODEC_ERROR <S2SV_ModEnd> 
1364,<S2SV_StartBug> kfree ( fpl ) ; <S2SV_EndBug> ,<S2SV_ModStart> free_uid ( fpl -> user ) ; 
1365,<S2SV_StartBug> kiocb_batch_free ( & batch ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ctx , "
1366,<S2SV_StartBug> req -> started = false ; <S2SV_EndBug> <S2SV_StartBug> if ( dep -> number > 1 ) <S2SV_EndBug> ,"<S2SV_ModStart> dwc3_gadget_del_and_unmap_request ( dep , req , status <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1367,"<S2SV_StartBug> char prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> char * type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( prefix != '+' && prefix != '-' && prefix != '=' ) { <S2SV_EndBug> <S2SV_StartBug> YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ; <S2SV_EndBug> <S2SV_StartBug> { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } <S2SV_EndBug> <S2SV_StartBug> { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; } <S2SV_EndBug> <S2SV_StartBug> case 237 : <S2SV_EndBug> <S2SV_StartBug> # line 1082 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1090 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1091 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1095 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1106 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1120 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1124 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1125 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1129 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1130 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1134 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1135 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1140 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1144 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1148 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1152 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1153 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1158 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1162 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1163 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1168 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1170 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1172 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1174 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1176 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3826 ""ntp_parser.c"" <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; switch ( <S2SV_ModEnd> <S2SV_ModStart> [ 0 ] ) { case '+' : case '-' : case '=' : prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ; type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) <S2SV_ModStart> break ; default : prefix = '=' ; type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ; } ( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ; YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ; } break ; case 216 : # line 1022 ""ntp_parser.y"" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 217 : # line 1027 ""ntp_parser.y"" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 227 : # line 1058 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 228 : # line 1059 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; } break ; case 229 : # line 1064 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 230 : # line 1066 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 231 : # line 1071 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( 'i' , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 233 : # line 1077 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_shorts ( '-' , ( yyvsp [ ( 2 ) - ( 5 ) ] . Integer ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Integer ) ) ; } break ; case 234 : # line 1081 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 <S2SV_ModEnd> <S2SV_ModStart> ) ; } break ; case 235 : # line 1082 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ; } break ; case 236 : # line 1086 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] <S2SV_ModEnd> <S2SV_ModStart> , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; } break ; case 237 : # line 1087 ""ntp_parser.y"" { ( yyval <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( yyvsp [ ( 1 ) - ( 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 1092 <S2SV_ModEnd> <S2SV_ModStart> 1100 <S2SV_ModEnd> <S2SV_ModStart> 1101 <S2SV_ModEnd> <S2SV_ModStart> 1105 <S2SV_ModEnd> <S2SV_ModStart> 1116 <S2SV_ModEnd> <S2SV_ModStart> 1130 <S2SV_ModEnd> <S2SV_ModStart> 1134 <S2SV_ModEnd> <S2SV_ModStart> 1135 <S2SV_ModEnd> <S2SV_ModStart> 1139 <S2SV_ModEnd> <S2SV_ModStart> 1140 <S2SV_ModEnd> <S2SV_ModStart> 1144 <S2SV_ModEnd> <S2SV_ModStart> 1145 <S2SV_ModEnd> <S2SV_ModStart> 1150 <S2SV_ModEnd> <S2SV_ModStart> 1154 <S2SV_ModEnd> <S2SV_ModStart> 1158 <S2SV_ModEnd> <S2SV_ModStart> 1162 <S2SV_ModEnd> <S2SV_ModStart> 1163 <S2SV_ModEnd> <S2SV_ModStart> 1168 <S2SV_ModEnd> <S2SV_ModStart> 1172 <S2SV_ModEnd> <S2SV_ModStart> 1173 <S2SV_ModEnd> <S2SV_ModStart> 1178 <S2SV_ModEnd> <S2SV_ModStart> 1180 <S2SV_ModEnd> <S2SV_ModStart> 1182 <S2SV_ModEnd> <S2SV_ModStart> 1184 <S2SV_ModEnd> <S2SV_ModStart> 1186 <S2SV_ModEnd> <S2SV_ModStart> 3836 <S2SV_ModEnd> "
1368,"<S2SV_StartBug> [ DISCE_PROBE ] = sas_probe_devices , <S2SV_EndBug> <S2SV_StartBug> [ DISCE_RESUME ] = sas_resume_devices , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1369,"<S2SV_StartBug> const char * name , int rep_quick ) <S2SV_EndBug> <S2SV_StartBug> mysql_file_close ( new_file , MYF ( 0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( param -> testflag & T_BACKUP_DATA ? <S2SV_EndBug> ","<S2SV_ModStart> , my_bool no_copy_stat <S2SV_ModStart> myf flags = 0 ; if ( param -> testflag & T_BACKUP_DATA ) flags |= MY_REDEL_MAKE_BACKUP ; if ( no_copy_stat ) flags |= MY_REDEL_NO_COPY_STAT ; <S2SV_ModStart> flags <S2SV_ModEnd> "
1370,"<S2SV_StartBug> # if uECC_VLI_NATIVE_LITTLE_ENDIAN <S2SV_EndBug> <S2SV_StartBug> EccPoint_mult ( p , curve -> G , k2 [ ! carry ] , 0 , num_n_bits + 1 , curve ) ; <S2SV_EndBug> ","<S2SV_ModStart> uECC_word_t * initial_Z = 0 ; <S2SV_ModStart> if ( g_rng_function ) { if ( ! uECC_generate_random_int ( k2 [ carry ] , curve -> p , num_words ) ) { return 0 ; } initial_Z = k2 [ carry ] ; } <S2SV_ModStart> initial_Z <S2SV_ModEnd> "
1371,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-truncated]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , rpl_tstr <S2SV_ModEnd> "
1372,<S2SV_StartBug> int family = sk -> sk_family ; <S2SV_EndBug> <S2SV_StartBug> if ( addr_len ) { <S2SV_EndBug> <S2SV_StartBug> sin = ( struct sockaddr_in * ) msg -> msg_name ; <S2SV_EndBug> <S2SV_StartBug> if ( isk -> cmsg_flags ) <S2SV_EndBug> <S2SV_StartBug> sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ; <S2SV_EndBug> <S2SV_StartBug> IP6CB ( skb ) -> iif ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> struct sockaddr_in * <S2SV_ModStart> * addr_len = sizeof ( * sin ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sin6 = ( struct sockaddr_in6 * <S2SV_ModStart> ) ; * addr_len = sizeof ( * sin6 
1373,<S2SV_StartBug> flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT | <S2SV_EndBug> <S2SV_StartBug> if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & inode -> i_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> if ( max_blocks > 0 ) { <S2SV_EndBug> ,"<S2SV_ModStart> mutex_lock ( & inode -> i_mutex ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! <S2SV_ModEnd> <S2SV_ModStart> && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; } flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ; if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_ModStart> if ( partial_begin || partial_end ) { ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ; if ( ret ) goto out_mutex <S2SV_ModEnd> <S2SV_ModStart> flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ; "
1374,<S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( pool -> free_total < NW_BUF_POOL_MAX_SIZE ) <S2SV_ModStart> else { free ( buf ) ; } 
1375,"<S2SV_StartBug> bpf_map_inc ( map , true ) ; <S2SV_EndBug> ",<S2SV_ModStart> map = 
1376,"<S2SV_StartBug> while ( * cp ) { <S2SV_EndBug> <S2SV_StartBug> NEARDATA const char hex [ ] = ""00112233445566778899aAbBcCdDeEfF"" ; <S2SV_EndBug> <S2SV_StartBug> int dcount = 0 ; <S2SV_EndBug> <S2SV_StartBug> cp ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( * cp == 'x' || * cp == 'X' ) <S2SV_EndBug> <S2SV_StartBug> for ( ++ cp ; * cp && ( dp = index ( hex , * cp ) ) && ( dcount ++ < 2 ) ; cp ++ ) <S2SV_EndBug> <S2SV_StartBug> else if ( * cp == 'o' || * cp == 'O' ) <S2SV_EndBug> <S2SV_StartBug> cp ++ ; <S2SV_EndBug> <S2SV_StartBug> * tp ++ = cval ; <S2SV_EndBug> ","<S2SV_ModStart> static <S2SV_ModEnd> <S2SV_ModStart> oct [ ] = ""01234567"" , dec [ ] = ""0123456789"" , <S2SV_ModStart> cval , meta , dcount ; while ( * cp ) { meta = ( * cp == '\\\\' && ( cp [ 1 ] == 'm' || cp [ 1 ] == 'M' ) && cp [ 2 ] ) ; if ( meta ) cp += 2 ; cval = dcount <S2SV_ModEnd> <S2SV_ModStart> if ( ( * cp != '\\\\' && * cp != '^' ) || ! cp [ 1 ] ) { cval = * cp ++ ; } else if ( * cp == '^' ) { cval = ( * ++ cp & 0x1f ) ; ++ cp ; } else if ( index ( dec , cp [ 1 ] ) ) { ++ cp ; do { cval = ( cval * 10 ) + ( * cp - '0' ) ; } while ( * ++ cp && index ( dec , * cp ) && ++ dcount < 3 ) ; } else if ( ( cp [ 1 ] == 'o' || cp [ 1 ] == 'O' ) && cp [ 2 ] && index ( oct , cp [ 2 ] ) ) { cp += 2 ; do { cval = ( cval * 8 ) + ( * cp - '0' ) ; } while ( * ++ cp && index ( oct , * cp ) && ++ dcount < 3 ) ; } else if ( ( cp [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> cp [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> && cp [ 2 ] <S2SV_ModEnd> <S2SV_ModStart> cp [ 2 ] ) ) != 0 ) { cp += 2 ; do { <S2SV_ModEnd> <S2SV_ModStart> } while ( * ++ cp && ( dp = index ( hex , * cp ) ) != 0 && ++ dcount < 2 ) ; } else <S2SV_ModEnd> <S2SV_ModStart> ++ cp ; } <S2SV_ModEnd> <S2SV_ModStart> ( char ) "
1377,<S2SV_StartBug> int file_is_y4m ( const char detect [ 4 ] ) { <S2SV_EndBug> ,<S2SV_ModStart> static 
1378,<S2SV_StartBug> if ( size_left && size_left < 4 ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1379,"<S2SV_StartBug> PIX * pixc , * pixm , * pixg , * pixd ; <S2SV_EndBug> <S2SV_StartBug> if ( ( pixc = pixFewColorsOctcubeQuant1 ( pixs , level ) ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> return ( PIX * ) ERROR_PTR ( ""too<S2SV_blank>many<S2SV_blank>colors"" , procName , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> * pix1 , <S2SV_ModStart> pix1 <S2SV_ModEnd> <S2SV_ModStart> ) ; pixc = pixConvertTo8 ( pix1 , 1 ) ; pixDestroy ( & pix1 "
1380,"<S2SV_StartBug> int i , ubits = BN_num_bits ( u ) , vbits = BN_num_bits ( v ) , <S2SV_EndBug> <S2SV_StartBug> if ( ubits <= BN_BITS2 && udp [ 0 ] == 1 ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ",<S2SV_ModStart> ; int <S2SV_ModEnd> <S2SV_ModStart> ; int <S2SV_ModEnd> <S2SV_ModStart> ; int <S2SV_ModEnd> <S2SV_ModStart> ) { if ( <S2SV_ModEnd> <S2SV_ModStart> 0 ) goto err ; if ( udp [ 0 ] == <S2SV_ModStart> } 
1381,<S2SV_StartBug> v_fn_ptr . vf = vp8_mse16x16 ; <S2SV_EndBug> ,<S2SV_ModStart> vpx_mse16x16 <S2SV_ModEnd> 
1382,"<S2SV_StartBug> strlcpy ( rkpp . type , ""kpp"" , sizeof ( rkpp . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> 
1383,<S2SV_StartBug> int strindex = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> 
1384,"<S2SV_StartBug> value = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( msg -> oob ) { <S2SV_EndBug> <S2SV_StartBug> nbits = bits & 7 ; <S2SV_EndBug> <S2SV_StartBug> Huff_offsetReceive ( msgHuff . decompressor . tree , & get , msg -> data , & msg -> bit ) ; <S2SV_EndBug> <S2SV_StartBug> value |= ( get << ( i + nbits ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( msg -> readcount > msg -> cursize ) { return 0 ; } <S2SV_ModStart> if ( msg -> readcount + ( bits >> 3 ) > msg -> cursize ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <S2SV_ModStart> if ( msg -> bit + nbits > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <S2SV_ModStart> , msg -> cursize << 3 <S2SV_ModStart> if ( msg -> bit > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } "
1385,"<S2SV_StartBug> int err = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> up_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> for ( idx = 0 ; idx < kcontrol -> count ; idx ++ , id . index ++ , id . numid ++ ) <S2SV_EndBug> ",<S2SV_ModStart> unsigned int count ; <S2SV_ModStart> count = kcontrol -> count ; <S2SV_ModStart>  <S2SV_ModEnd> 
1386,<S2SV_StartBug> free_netdev ( net ) ; <S2SV_EndBug> ,<S2SV_ModStart> cancel_work_sync ( & dev -> kevent ) ; del_timer_sync ( & dev -> delay ) ; 
1387,<S2SV_StartBug> int overhead = 16 + 4 + strlen ( ns ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> int size = overhead ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> 
1388,"<S2SV_StartBug> save_text_from_text_view ( GTK_TEXT_VIEW ( textview ) , item_name ) ; <S2SV_EndBug> ",<S2SV_ModStart> { <S2SV_ModStart> problem_data_reload_from_dump_dir ( ) ; update_gui_state_from_problem_data ( 0 ) ; } 
1389,<S2SV_StartBug> last_id = ntohs ( * pid ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( plen < 0 ) return 0 ; 
1390,<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> else { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> struct iattr iattr ; retval = posix_acl_update_mode ( inode , & iattr . ia_mode , & acl ) ; if ( retval <S2SV_ModEnd> <S2SV_ModStart> if ( ! acl ) { value = NULL ; size = 0 ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1391,<S2SV_StartBug> if ( bin -> methods [ i ] . class_id > bin -> header . types_size - 1 ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1392,<S2SV_StartBug> case NPPVformValue : <S2SV_EndBug> <S2SV_StartBug> type = RPC_TYPE_BOOLEAN ; <S2SV_EndBug> ,<S2SV_ModStart> : case NPPVpluginNativeAccessibleAtkPlugId <S2SV_ModStart> case NPPVpluginUrlRequestsDisplayedBool : case NPPVpluginWantsAllNetworkStreams : case NPPVpluginCancelSrcStream : case NPPVSupportsAdvancedKeyHandling : 
1393,"<S2SV_StartBug> int alloc = ( length ? length : ( int ) strlen ( string ) ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> CURLcode res ; <S2SV_EndBug> <S2SV_StartBug> res = Curl_convert_from_network ( handle , & in , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( res ) { <S2SV_EndBug> <S2SV_StartBug> * olen = strindex ; <S2SV_EndBug> ","<S2SV_ModStart> char * str = NULL ; size_t inputlen = length ; size_t outputlen <S2SV_ModEnd> <S2SV_ModStart> = Curl_urldecode <S2SV_ModEnd> <S2SV_ModStart> string , inputlen , & str , & outputlen , FALSE <S2SV_ModEnd> <S2SV_ModStart> return NULL <S2SV_ModEnd> <S2SV_ModStart> curlx_uztosi ( outputlen ) ; return str <S2SV_ModEnd> "
1394,"<S2SV_StartBug> void nego_process_negotiation_response ( rdpNego * nego , wStream * s ) <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> FALSE <S2SV_ModStart> return TRUE ; 
1395,"<S2SV_StartBug> int i , target_bits_per_mb ; <S2SV_EndBug> <S2SV_StartBug> const int bits_per_mb_at_this_q = ( int ) vp9_rc_bits_per_mb ( cm -> frame_type , i , <S2SV_EndBug> <S2SV_StartBug> correction_factor ) ; <S2SV_EndBug> <S2SV_StartBug> return q ; <S2SV_EndBug> ","<S2SV_ModStart> , bits_per_mb_at_this_q <S2SV_ModStart> if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled && cpi -> svc . temporal_layer_id == 0 && cpi -> svc . spatial_layer_id == 0 ) { bits_per_mb_at_this_q = ( int ) vp9_cyclic_refresh_rc_bits_per_mb ( cpi , i , correction_factor ) ; } else { <S2SV_ModEnd> <S2SV_ModStart> , cm -> bit_depth ) ; } <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> oxcf . rc_mode == VPX_CBR && ( cpi -> rc . rc_1_frame * cpi -> rc . rc_2_frame == - 1 ) && cpi -> rc . q_1_frame != cpi -> rc . q_2_frame ) { q = clamp ( q , MIN ( cpi -> rc . q_1_frame , cpi -> rc . q_2_frame ) , MAX ( cpi -> rc . q_1_frame , cpi -> rc . q_2_frame ) ) ; } "
1396,<S2SV_StartBug> value |= TJA1101_CONFIG1_MII_MODE_RMII_25MHZ ; <S2SV_EndBug> ,<S2SV_ModStart> TJA1101_CONFIG1_MII_MODE_RMII_50MHZ_REF_CLK_OUT <S2SV_ModEnd> 
1397,"<S2SV_StartBug> strlcpy ( rcipher . type , ""cipher"" , sizeof ( rcipher . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> 
1398,<S2SV_StartBug> if ( len < sizeof ( * prep ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> || ! ND_TTEST ( * prep ) ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1399,"<S2SV_StartBug> mark_object ( & c -> object , NULL , NULL , data ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1400,"<S2SV_StartBug> freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! res ) return - EINVAL ; 
1401,"<S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> ",<S2SV_ModStart> i < NCH ( n ) && 
1402,"<S2SV_StartBug> MB_PREDICTION_MODE mode , TX_SIZE tx_size , <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , left_col , 64 ) ; <S2SV_EndBug> <S2SV_StartBug> once ( init_intra_pred_fn_ptrs ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( left_col , 129 , 64 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( x0 + 2 * bs <= frame_width ) { <S2SV_EndBug> <S2SV_StartBug> if ( right_available && bs == 4 ) { <S2SV_EndBug> <S2SV_StartBug> if ( right_available && bs == 4 ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( above_row , above_ref , bs ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bs == 4 && right_available ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> above_row [ - 1 ] = 127 ; <S2SV_EndBug> ","<S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> DECLARE_ALIGNED <S2SV_ModEnd> <S2SV_ModStart> [ 32 ] ) ; DECLARE_ALIGNED ( 16 , uint8_t , above_data [ 64 + 16 ] <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( extend_modes [ mode ] & NEED_LEFT ) { <S2SV_ModEnd> <S2SV_ModStart> else { memset ( left_col , 129 , bs ) ; } } if ( extend_modes [ mode ] & NEED_ABOVE ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memcpy ( above_row , above_ref , bs ) ; } else if ( x0 <S2SV_ModEnd> <S2SV_ModStart> memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + bs - frame_width ) ; } <S2SV_ModEnd> <S2SV_ModStart> memcpy ( above_row , above_ref , bs ) ; } } above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } else { memset ( above_row , 127 , bs ) ; above_row [ - 1 ] = 127 ; } } if ( extend_modes [ mode ] & NEED_ABOVERIGHT ) { if ( up_available ) { const uint8_t * above_ref = ref - ref_stride ; if ( xd -> mb_to_right_edge < 0 ) { if ( x0 + 2 * bs <= frame_width ) { if ( right_available && bs == 4 ) { memcpy ( above_row , above_ref , 2 * bs ) ; } else { memcpy ( above_row , above_ref , bs ) ; memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 + bs <= frame_width ) { const int r = frame_width - x0 ; if ( right_available && bs == 4 ) { memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { memcpy ( above_row , above_ref , bs ) ; memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 <= frame_width ) { const int r = frame_width - x0 ; memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } } else { <S2SV_ModEnd> <S2SV_ModStart> && left_available ) { const_above_row = above_ref ; } else { memcpy ( above_row , above_ref , bs ) ; if ( bs == 4 && right_available ) memcpy ( above_row + bs , above_ref + bs , bs ) ; else memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } <S2SV_ModEnd> <S2SV_ModStart> else { memset <S2SV_ModEnd> <S2SV_ModStart> } "
1403,<S2SV_StartBug> end ++ ; <S2SV_EndBug> ,<S2SV_ModStart> if ( pattern [ end ] == 0 ) break ; 
1404,"<S2SV_StartBug> void ftoa_bounded_extra ( JsVarFloat val , char * str , size_t len , int radix , int fractionalDigits ) { <S2SV_EndBug> <S2SV_StartBug> if ( isnan ( val ) ) strncpy ( str , ""NaN"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( val < 0 ) strncpy ( str , ""-Infinity"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> else strncpy ( str , ""Infinity"" , len ) ; <S2SV_EndBug> ",<S2SV_ModStart> assert ( len > 9 ) ; <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1405,"<S2SV_StartBug> jas_iccprof_t * jas_iccprof_createfrombuf ( uchar * buf , int len ) <S2SV_EndBug> ",<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
1406,<S2SV_StartBug> ei -> cur_aio_dio = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> spin_lock_init ( & ei -> i_completed_io_lock ) ; 
1407,<S2SV_StartBug> BUG_ON ( ! thresholds ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & memcg -> thresholds_lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! thresholds -> primary ) goto unlock <S2SV_ModStart> unlock : 
1408,"<S2SV_StartBug> static struct ion_handle * ion_handle_get_by_id ( struct ion_client * client , <S2SV_EndBug> <S2SV_StartBug> handle = idr_find ( & client -> idr , id ) ; <S2SV_EndBug> <S2SV_StartBug> return handle ? handle : ERR_PTR ( - EINVAL ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ion_handle_get_by_id_nolock ( client , id <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1409,"<S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_FRAME_MARKER , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> frame_type ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> show_frame ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> error_resilient_mode ) ; <S2SV_EndBug> <S2SV_StartBug> const COLOR_SPACE cs = UNKNOWN ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> profile > PROFILE_1 ) { <S2SV_EndBug> <S2SV_StartBug> assert ( cm -> profile == PROFILE_1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , get_ref_frame_idx ( cpi , ref_frame ) , <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> ref_frame_sign_bias [ ref_frame ] ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> allow_high_precision_mv ) ; <S2SV_EndBug> <S2SV_StartBug> fix_interp_filter ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> refresh_frame_context ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> frame_parallel_decoding_mode ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> frame_context_idx , FRAME_CONTEXTS_LOG2 ) ; <S2SV_EndBug> <S2SV_StartBug> encode_segmentation ( cpi , wb ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> MACROBLOCKD * const xd = & cpi -> td . mb . e_mbd ; vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> write_sync_code ( wb ) ; write_bitdepth_colorspace_sampling ( cm , wb ) ; write_frame_size ( cm , wb ) ; } else { if ( ! cm -> show_frame ) vpx_wb_write_bit ( wb , cm -> intra_only ) ; if ( ! cm -> error_resilient_mode ) vpx_wb_write_literal ( wb , cm -> reset_frame_context , 2 ) ; if ( cm -> intra_only ) { <S2SV_ModEnd> <S2SV_ModStart> PROFILE_0 ) { write_bitdepth_colorspace_sampling ( cm , wb ) ; } vpx_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ; write_frame_size ( cm , wb ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> assert ( get_ref_frame_map_idx ( cpi , ref_frame ) != INVALID_IDX ) ; vpx_wb_write_literal ( wb , get_ref_frame_map_idx <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> , cpi -> td . counts <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> cm , xd <S2SV_ModEnd> "
1410,<S2SV_StartBug> if ( bad_format ( optarg ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( bad_format ( optarg ) ) { <S2SV_EndBug> ,<S2SV_ModStart> bad_format_axis ( optarg ) ) { <S2SV_ModEnd> <S2SV_ModStart> bad_format_axis ( optarg ) ) { <S2SV_ModEnd> 
1411,"<S2SV_StartBug> p = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> <S2SV_StartBug> q = strchr ( p + 1 , '<S2SV_blank>' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> 
1412,"<S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> ",<S2SV_ModStart> i < NCH ( n ) && 
1413,"<S2SV_StartBug> vpx_memcpy ( pc -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> ref_lf_deltas , 0 , sizeof ( xd -> ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> mode_lf_deltas , 0 , sizeof ( xd -> mode_lf_deltas ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
1414,"<S2SV_StartBug> uint16_t n ; <S2SV_EndBug> <S2SV_StartBug> Enc624j600Context * context ; <S2SV_EndBug> <S2SV_StartBug> if ( enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_PKTCNT ) <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXRDPT , context -> nextPacket ) ; <S2SV_EndBug> <S2SV_StartBug> ( uint8_t * ) & context -> nextPacket , sizeof ( uint16_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & RSV_RECEIVED_OK ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> n = MIN ( n , ETH_MAX_FRAME_SIZE ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , context -> rxBuffer , n ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , context -> nextPacket - 2 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_PKTDEC ) ; <S2SV_EndBug> <S2SV_StartBug> nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ; <S2SV_EndBug> ","<S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> uint8_t header [ 8 ] ; <S2SV_ModStart> ENC624J600_ESTAT ) & ENC624J600_ESTAT_PKTCNT <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ERXRDPT <S2SV_ModEnd> <S2SV_ModStart> header <S2SV_ModEnd> <S2SV_ModStart> header ) ) ; context -> nextPacket = LOAD16LE ( header ) ; length = LOAD16LE ( header + 2 ) ; status = LOAD32LE ( header + 4 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_RSV_RECEIVED_OK <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ERXTAIL , <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ERXTAIL , <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ECON1 , ENC624J600_ECON1_PKTDEC <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> "
1415,<S2SV_StartBug> while ( ibuf [ ind ] == 0x01 ) { <S2SV_EndBug> ,<S2SV_ModStart> && i < gemsafe_cert_max 
1416,"<S2SV_StartBug> if ( vmx_set_msr ( vcpu , & msr ) != 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> kvm_set_msr <S2SV_ModEnd> 
1417,"<S2SV_StartBug> static VALUE read_memory ( VALUE klass , VALUE content ) <S2SV_EndBug> <S2SV_StartBug> xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt ( <S2SV_EndBug> <S2SV_StartBug> ) ; <S2SV_EndBug> <S2SV_StartBug> return rb_schema ; <S2SV_EndBug> ","<S2SV_ModStart> int argc , VALUE * argv , VALUE klass ) { VALUE content ; VALUE parse_options ; int parse_options_int ; xmlSchemaParserCtxtPtr ctx ; <S2SV_ModEnd> <S2SV_ModStart> VALUE errors ; VALUE rb_schema ; int scanned_args = 0 ; scanned_args = rb_scan_args ( argc , argv , ""11"" , & content , & parse_options ) ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( ""ParseOptions"" ) ) , rb_intern ( ""DEFAULT_SCHEMA"" ) ) ; } parse_options_int = ( int ) NUM2INT ( rb_funcall ( parse_options , rb_intern ( ""to_i"" ) , 0 ) ) ; <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart> rb_iv_set ( rb_schema , ""@parse_options"" , parse_options ) ; "
1418,"<S2SV_StartBug> unsigned int len ; <S2SV_EndBug> <S2SV_StartBug> struct au1200fb_device * fbdev = info -> par ; <S2SV_EndBug> <S2SV_StartBug> return io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vm_iomap_memory <S2SV_ModEnd> <S2SV_ModStart> fbdev -> fb_phys , fbdev -> fb_len <S2SV_ModEnd> "
1419,"<S2SV_StartBug> errstr = parse_global_option ( CMD_SET_VALUE , config_opt , config_arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> & new_global_options , "
1420,<S2SV_StartBug> out += 4 ; <S2SV_EndBug> <S2SV_StartBug> out += 4 ; <S2SV_EndBug> ,<S2SV_ModStart> 3 <S2SV_ModEnd> <S2SV_ModStart> 3 <S2SV_ModEnd> 
1421,"<S2SV_StartBug> if ( perf_event_overflow ( event , 1 , & data , regs ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1422,<S2SV_StartBug> if ( ( unsigned int ) arg >= cdi -> capacity ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1423,<S2SV_StartBug> err = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> if ( match -> type == type && <S2SV_EndBug> <S2SV_StartBug> out : <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> spin_lock ( & po -> bind_lock ) ; if ( po -> running && <S2SV_ModEnd> <S2SV_ModStart> spin_unlock ( & po -> bind_lock ) ; if ( err && ! refcount_read ( & match -> sk_ref ) ) { list_del ( & match -> list ) ; kfree ( match ) ; } 
1424,<S2SV_StartBug> if ( handle -> nmi ) { <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1425,"<S2SV_StartBug> int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs ) <S2SV_EndBug> <S2SV_StartBug> while ( * s && len > 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( u >= PLANE_SIZE ) { <S2SV_EndBug> <S2SV_StartBug> u -= PLANE_SIZE ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = ( wchar_t ) ( SURROGATE_PAIR | <S2SV_EndBug> <S2SV_StartBug> ( ( u >> 10 ) & SURROGATE_BITS ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( u & SURROGATE_BITS ) ) ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = ( wchar_t ) u ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = * s ++ ; <S2SV_EndBug> ","<S2SV_ModStart> enum utf16_endian endian , <S2SV_ModStart> , int maxlen <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && maxlen > 0 && * s <S2SV_ModStart> s += size ; len -= size ; <S2SV_ModStart> if ( maxlen < 2 ) break ; <S2SV_ModStart> put_utf16 ( op ++ , <S2SV_ModEnd> <S2SV_ModStart> , endian ) ; put_utf16 ( op ++ , <S2SV_ModEnd> <S2SV_ModStart> , endian ) ; maxlen -= 2 <S2SV_ModEnd> <S2SV_ModStart> put_utf16 ( op ++ , u , endian ) ; maxlen -- ; } <S2SV_ModEnd> <S2SV_ModStart> put_utf16 ( op ++ , * s ++ , endian ) ; len -- ; maxlen <S2SV_ModEnd> "
1426,"<S2SV_StartBug> int v , i ; <S2SV_EndBug> <S2SV_StartBug> ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) ) <S2SV_EndBug> ","<S2SV_ModStart> if ( ! ( s -> state & PNG_IHDR ) ) { av_log ( avctx , AV_LOG_ERROR , ""trns<S2SV_blank>before<S2SV_blank>IHDR\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( s -> state & PNG_IDAT ) { av_log ( avctx , AV_LOG_ERROR , ""trns<S2SV_blank>after<S2SV_blank>IDAT\\n"" ) ; return AVERROR_INVALIDDATA ; } <S2SV_ModStart> || s -> bit_depth == 1 "
1427,"<S2SV_StartBug> print_as ( ""Notification<S2SV_blank>setup<S2SV_blank>failed,<S2SV_blank>won\'t<S2SV_blank>be<S2SV_blank>able<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>after<S2SV_blank>failure"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""Notification<S2SV_blank>setup<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>won\'t<S2SV_blank>be<S2SV_blank>able<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>after<S2SV_blank>failure"" <S2SV_ModEnd> "
1428,<S2SV_StartBug> dt -> vlan_id [ 0 ] = p -> vlan_id [ 0 ] ; <S2SV_EndBug> ,<S2SV_ModStart> proto = IP_GET_IPPROTO ( p ) ; dt -> 
1429,"<S2SV_StartBug> status = ksz8851ReadReg ( interface , KSZ8851_REG_RXFHSR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & RXFHSR_RXFV ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( status & ( RXFHSR_RXMR | RXFHSR_RXFTL | RXFHSR_RXRF | RXFHSR_RXCE ) ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_RXFHBCR ) & RXFHBCR_RXBC_MASK ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_RXFDPR , RXFDPR_RXFPAI ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851ClearBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_RRXEF ) ; <S2SV_EndBug> ","<S2SV_ModStart> KSZ8851_RXFHSR <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXFHSR_RXFV <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXFHSR_RXMR | KSZ8851_RXFHSR_RXFTL | KSZ8851_RXFHSR_RXRF | KSZ8851_RXFHSR_RXCE <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXFHBCR ) & KSZ8851_RXFHBCR_RXBC <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXFDPR , KSZ8851_RXFDPR_RXFPAI <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXQCR , KSZ8851_RXQCR_RRXEF <S2SV_ModEnd> "
1430,"<S2SV_StartBug> ast_for_funcdef_impl ( struct compiling * c , const node * n , <S2SV_EndBug> <S2SV_StartBug> asdl_seq * decorator_seq , int is_async ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> type_comment , LINENO ( n ) , <S2SV_EndBug> ","<S2SV_ModStart> n0 <S2SV_ModEnd> <S2SV_ModStart> bool <S2SV_ModEnd> <S2SV_ModStart> const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; <S2SV_ModStart> n0 ) , n0 <S2SV_ModEnd> "
1431,"<S2SV_StartBug> pgd = pgd_offset ( mm , 0xA0000 ) ; <S2SV_EndBug> <S2SV_StartBug> flush_tlb ( ) ; <S2SV_EndBug> ",<S2SV_ModStart> down_write ( & mm -> mmap_sem ) ; <S2SV_ModStart> up_write ( & mm -> mmap_sem ) ; 
1432,"<S2SV_StartBug> return aa_audit ( AUDIT_APPARMOR_DENIED , NULL , GFP_KERNEL , <S2SV_EndBug> ","<S2SV_ModStart> __aa_current_profile ( ) , GFP_KERNEL , & sa , NULL <S2SV_ModEnd> "
1433,<S2SV_StartBug> cstate = 0 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth || <S2SV_EndBug> ,"<S2SV_ModStart> siz -> comps = 0 ; <S2SV_ModStart> goto error ; } if ( ! siz -> width || ! siz -> height ) { jas_eprintf ( ""reference<S2SV_blank>grid<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\n"" ) ; goto error ; } if ( ! siz -> tilewidth || ! siz -> tileheight ) { jas_eprintf ( ""tile<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\n"" ) ; goto error ; } if ( ! siz -> numcomps || siz -> numcomps > 16384 ) { jas_eprintf ( ""number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( siz -> xoff >= siz -> width ) { jas_eprintf ( ""XOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( siz -> yoff >= siz -> height ) { jas_eprintf ( ""YOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( siz -> tilexoff > siz -> xoff || siz -> tilexoff + siz -> tilewidth <= siz -> xoff ) { jas_eprintf ( ""XTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( siz -> tileyoff > siz -> yoff || siz -> tileyoff + siz -> tileheight <= siz -> yoff ) { jas_eprintf ( ""YTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { goto error ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { goto error ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . hsamp ) ; goto error ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . vsamp ) ; goto error ; } siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { goto error ; } return 0 ; error : if ( siz -> comps ) { jas_free ( siz -> comps ) ; } <S2SV_ModStart>  <S2SV_ModEnd> "
1434,"<S2SV_StartBug> option_number += previous_option_number ; <S2SV_EndBug> <S2SV_StartBug> ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , <S2SV_EndBug> <S2SV_StartBug> ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , <S2SV_EndBug> <S2SV_StartBug> ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , <S2SV_EndBug> ","<S2SV_ModStart> if ( sn_coap_parser_add_u16_limit ( option_number , previous_option_number , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> <S2SV_ModStart> if ( dst_coap_msg_ptr -> options_list_ptr -> etag_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_ETAG<S2SV_blank>exists!"" ) ; return - 1 ; } <S2SV_ModStart> if ( dst_coap_msg_ptr -> options_list_ptr -> location_query_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_QUERY<S2SV_blank>exists!"" ) ; return - 1 ; } <S2SV_ModStart> if ( dst_coap_msg_ptr -> uri_path_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_PATH<S2SV_blank>exists!"" ) ; return - 1 ; } "
1435,"<S2SV_StartBug> if ( ( setup_ret = _WM_SetupMidiEvent ( xmi_mdi , xmi_data , 0 ) ) == 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> xmi_size , "
1436,"<S2SV_StartBug> total_len = iov_length ( iov , nr_segs ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> void * addr ; <S2SV_EndBug> <S2SV_StartBug> size_t chars = buf -> len ; <S2SV_EndBug> <S2SV_StartBug> int error , atomic ; <S2SV_EndBug> <S2SV_StartBug> atomic = ! iov_fault_in_pages_write ( iov , chars ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct iov_iter iter ; <S2SV_ModStart> ; iov_iter_init ( & iter , iov , nr_segs , total_len , 0 ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; size_t written <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> written = copy_page_to_iter ( buf -> page , buf -> offset , chars , & iter ) ; if ( unlikely ( written < chars ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> "
1437,"<S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> <S2SV_StartBug> index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ; <S2SV_EndBug> <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> if ( k < 0 ) continue <S2SV_ModEnd> 
1438,<S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1439,"<S2SV_StartBug> p_fm_config_conx_hdlt hdl ; <S2SV_EndBug> <S2SV_StartBug> goto die_clean ; <S2SV_EndBug> <S2SV_StartBug> goto die_clean ; <S2SV_EndBug> <S2SV_StartBug> return commandList [ i ] . cmdPtr ( hdl , commandList [ i ] . mgr , ( argc - optind ) , & argv [ optind ] ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> die_clean : <S2SV_EndBug> <S2SV_StartBug> return res ; <S2SV_EndBug> ",<S2SV_ModStart> = NULL <S2SV_ModStart> cleanup <S2SV_ModEnd> <S2SV_ModStart> cleanup <S2SV_ModEnd> <S2SV_ModStart> res = <S2SV_ModEnd> <S2SV_ModStart> goto cleanup ; <S2SV_ModStart> cleanup : if ( hdl ) { if ( hdl -> sm_hdl ) { if ( hdl -> sm_hdl -> c_path [ 0 ] ) unlink ( hdl -> sm_hdl -> c_path ) ; } if ( hdl -> pm_hdl ) { if ( hdl -> pm_hdl -> c_path [ 0 ] ) unlink ( hdl -> pm_hdl -> c_path ) ; } if ( hdl -> fe_hdl ) { if ( hdl -> fe_hdl -> c_path [ 0 ] ) unlink ( hdl -> fe_hdl -> c_path ) ; } <S2SV_ModEnd> <S2SV_ModStart> } 
1440,"<S2SV_StartBug> if ( jas_init ( ) ) { <S2SV_EndBug> <S2SV_StartBug> infile = 0 ; <S2SV_EndBug> <S2SV_StartBug> case OPT_MAXMEM : <S2SV_EndBug> <S2SV_StartBug> if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( numcmpts = jas_image_numcmpts ( image ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) { <S2SV_EndBug> <S2SV_StartBug> printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n"" , fmtname , numcmpts , width , height , depth , ( long ) jas_image_rawsize ( image ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t max_samples ; char optstr [ 32 ] ; <S2SV_ModStart> max_samples = 64 * JAS_MEBI ; <S2SV_ModStart> OPT_MAXSAMPLES : max_samples = strtoull ( jas_optarg , 0 , 10 ) ; break ; case <S2SV_ModStart> snprintf ( optstr , sizeof ( optstr ) , ""max_samples=%-zu"" , max_samples ) ; <S2SV_ModStart> optstr <S2SV_ModEnd> <S2SV_ModStart> fmtname = jas_image_fmttostr ( fmtid ) ) ) { jas_eprintf ( ""format<S2SV_blank>name<S2SV_blank>lookup<S2SV_blank>failed\\n"" ) ; return EXIT_FAILURE ; } if ( ! ( <S2SV_ModStart> printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n"" , fmtname <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( long , <S2SV_ModEnd> <S2SV_ModStart> ) "
1441,"<S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> ",<S2SV_ModStart> false 
1442,<S2SV_StartBug> cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <S2SV_EndBug> ,<S2SV_ModStart> || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) 
1443,"<S2SV_StartBug> for ( row = 0 ; row < height ; row ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( ( RAW ( row , col ) = pred [ col & 1 ] ) > 4098 && col < width ) <S2SV_EndBug> ",<S2SV_ModStart> raw_height <S2SV_ModEnd> <S2SV_ModStart> && row < height 
1444,<S2SV_StartBug> if ( len < needed ) { <S2SV_EndBug> ,<S2SV_ModStart> || len < sizeof ( nl -> dev ) 
1445,<S2SV_StartBug> ExitLoop : <S2SV_EndBug> ,<S2SV_ModStart> quantum_info = DestroyQuantumInfo ( quantum_info ) ; 
1446,"<S2SV_StartBug> int idx , ret = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; <S2SV_EndBug> <S2SV_StartBug> hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { <S2SV_EndBug> ","<S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> || hlist_empty ( <S2SV_ModEnd> <S2SV_ModStart> ) ) { pr_warn_once ( ""no<S2SV_blank>route<S2SV_blank>for<S2SV_blank>guest_irq<S2SV_blank>%u/%u<S2SV_blank>(broken<S2SV_blank>user<S2SV_blank>space?)\\n"" , guest_irq , irq_rt -> nr_rt_entries ) ; goto out ; } hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] "
1447,<S2SV_StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <S2SV_EndBug> ,"<S2SV_ModStart> bfqd , "
1448,<S2SV_StartBug> return rold -> umin_value == 0 && <S2SV_EndBug> ,<S2SV_ModStart> false <S2SV_ModEnd> 
1449,"<S2SV_StartBug> BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; memset ( sa , 0 , sizeof ( * sa ) "
1450,<S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> ,<S2SV_ModStart> || ! SecIsValidHandle ( handle ) 
1451,<S2SV_StartBug> length += PRIMARY_DRAWING_ORDER_FIELD_BYTES [ orderInfo -> orderType ] ; <S2SV_EndBug> ,"<S2SV_ModStart> get_primary_drawing_order_field_bytes ( <S2SV_ModEnd> <S2SV_ModStart> , NULL ) <S2SV_ModEnd> "
1452,"<S2SV_StartBug> olddentry = ovl_dentry_upper ( old ) ; <S2SV_EndBug> <S2SV_StartBug> newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , <S2SV_EndBug> <S2SV_StartBug> err = PTR_ERR ( newdentry ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( newdentry ) ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( olddentry -> d_parent != old_upperdir ) <S2SV_EndBug> <S2SV_StartBug> if ( newdentry -> d_parent != new_upperdir ) <S2SV_EndBug> <S2SV_StartBug> goto out_dput ; <S2SV_EndBug> <S2SV_StartBug> out_unlock : <S2SV_EndBug> ","<S2SV_ModStart> lookup_one_len ( old <S2SV_ModEnd> <S2SV_ModStart> old_upperdir , old <S2SV_ModEnd> <S2SV_ModStart> olddentry <S2SV_ModEnd> <S2SV_ModStart> olddentry <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> != ovl_dentry_upper ( old ) ) goto out_dput_old ; newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , new -> d_name . len ) ; err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out_dput_old ; err = - ESTALE ; if ( ovl_dentry_upper ( new ) ) { if ( opaquedir ) { if ( newdentry != opaquedir <S2SV_ModEnd> <S2SV_ModStart> } else { if ( newdentry != ovl_dentry_upper ( new ) <S2SV_ModEnd> <S2SV_ModStart> } } else { new_create = true ; if ( ! d_is_negative ( newdentry ) && ( ! new_opaque || ! ovl_is_whiteout ( newdentry ) ) ) goto out_dput ; } <S2SV_ModStart> out_dput_old : dput ( olddentry ) ; "
1453,<S2SV_StartBug> # if 0 <S2SV_EndBug> <S2SV_StartBug> p ++ ; s ++ ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1454,<S2SV_StartBug> for ( plane = 0 ; plane < MAX_MB_PLANE ; plane ++ ) <S2SV_EndBug> ,<S2SV_ModStart> ++ plane <S2SV_ModEnd> 
1455,"<S2SV_StartBug> int copied , error = - EINVAL ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1456,"<S2SV_StartBug> return mount_entry_on_generic ( mntent , path ) ; <S2SV_EndBug> ","<S2SV_ModStart> , rootfs "
1457,<S2SV_StartBug> return fd ; <S2SV_EndBug> ,<S2SV_ModStart> sr -> fd_is_fdt = MK_TRUE ; 
1458,"<S2SV_StartBug> static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <S2SV_EndBug> <S2SV_StartBug> kenter ( ""%p"" , dest_keyring ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int ret ; <S2SV_ModStart> bool do_perm_check = true ; <S2SV_ModStart> { do_perm_check = false ; break ; } <S2SV_ModEnd> <S2SV_ModStart> if ( dest_keyring && do_perm_check ) { ret = key_permission ( make_key_ref ( dest_keyring , 1 ) , KEY_NEED_WRITE ) ; if ( ret ) { key_put ( dest_keyring ) ; return ret ; } } <S2SV_ModStart> 0 "
1459,"<S2SV_StartBug> static void nonrd_pick_sb_modes ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> xd -> mi [ 0 ] -> mbmi . sb_type = bsize ; <S2SV_EndBug> <S2SV_StartBug> vp9_pick_inter_mode ( cpi , x , tile , mi_row , mi_col , <S2SV_EndBug> ","<S2SV_ModStart> TileDataEnc * tile_data , MACROBLOCK * const x , int mi_row , int mi_col , RD_COST * rd_cost , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_ModEnd> <S2SV_ModStart> tile_info = & tile_data -> tile_info <S2SV_ModEnd> <S2SV_ModStart> MB_MODE_INFO * mbmi ; <S2SV_ModStart> tile_info , x , mi_row , mi_col , bsize ) ; mbmi = & <S2SV_ModEnd> <S2SV_ModStart> ; mbmi -> sb_type = bsize ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) x -> rdmult = vp9_cyclic_refresh_get_rdmult ( cpi -> cyclic_refresh ) ; if ( cm -> frame_type == KEY_FRAME ) hybrid_intra_mode_search ( cpi , x , rd_cost , bsize , ctx ) ; else if ( segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) set_mode_info_seg_skip ( x , cm -> tx_mode , rd_cost , bsize ) ; else if ( bsize >= BLOCK_8X8 ) <S2SV_ModEnd> <S2SV_ModStart> tile_data , mi_row , mi_col , rd_cost , bsize , ctx ) ; else vp9_pick_inter_mode_sub8x8 ( cpi , x , mi_row , mi_col , rd_cost , bsize , ctx ) ; duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; if ( rd_cost -> rate == INT_MAX ) vp9_rd_cost_reset ( rd_cost ) ; ctx -> rate = rd_cost -> rate ; ctx -> dist = rd_cost -> dist <S2SV_ModEnd> "
1460,<S2SV_StartBug> dev -> hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ; <S2SV_EndBug> <S2SV_StartBug> dev -> features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1461,"<S2SV_StartBug> * err = superblockRead ( & reader , & reader . superblock ) ; <S2SV_EndBug> ",<S2SV_ModStart> reader . recursive_counter = 0 ; 
1462,<S2SV_StartBug> if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) <S2SV_EndBug> ,"<S2SV_ModStart> ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; "
1463,"<S2SV_StartBug> int tmp ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( buf , buffer , count ) ) <S2SV_EndBug> ","<S2SV_ModStart> size_t size ; int tmp ; size = min ( count , sizeof ( buf ) ) <S2SV_ModEnd> <S2SV_ModStart> size <S2SV_ModEnd> "
1464,<S2SV_StartBug> pMap -> ranges = malloc ( sizeof ( MappedRange ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( pMap -> ranges == NULL ) { LOGE ( ""malloc<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; munmap ( memPtr , length ) ; return - 1 ; } "
1465,<S2SV_StartBug> switch ( dip -> di_format ) { <S2SV_EndBug> ,"<S2SV_ModStart> fa = xfs_dinode_verify_fork ( dip , mp , XFS_DATA_FORK ) ; if ( fa ) return fa ; break ; case 0 : break ; default : return __this_address ; } if ( XFS_DFORK_Q ( dip ) ) { fa = xfs_dinode_verify_fork ( dip , mp , XFS_ATTR_FORK ) ; if ( fa ) return fa ; <S2SV_ModEnd> "
1466,"<S2SV_StartBug> if ( ( ret = s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ) < 0 ) <S2SV_EndBug> ",<S2SV_ModStart> x >= 16 || c >= 256 ) { return AVERROR_INVALIDDATA ; } if ( 
1467,<S2SV_StartBug> jas_tvparser_destroy ( tvp ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> jas_tvparser_destroy ( tvp ) ; 
1468,<S2SV_StartBug> if ( ( ( flags & VP8_EFLAG_NO_UPD_GF ) && ( flags & VP8_EFLAG_FORCE_GF ) ) <S2SV_EndBug> <S2SV_StartBug> round = ( vpx_codec_pts_t ) 1000000 <S2SV_EndBug> ,"<S2SV_ModStart> ! flags ) { flags = ctx -> control_frame_flags ; } ctx -> control_frame_flags = 0 ; res = set_reference_and_update ( ctx , flags ) ; <S2SV_ModEnd> <S2SV_ModStart> 10000000 <S2SV_ModEnd> "
1469,"<S2SV_StartBug> BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( unsigned char ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> double <S2SV_ModEnd> 
1470,<S2SV_StartBug> if ( ! head ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> WARN_ON_ONCE ( <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1471,"<S2SV_StartBug> u_int atype , const u_char * pptr , u_int len ) <S2SV_EndBug> <S2SV_StartBug> if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) <S2SV_EndBug> ","<S2SV_ModStart> , const unsigned attr_set_level <S2SV_ModStart> attr_set_level == 10 ) ND_PRINT ( ( ndo , ""(too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>levels,<S2SV_blank>not<S2SV_blank>recursing)"" ) ) ; else if ( <S2SV_ModStart> , attr_set_level + 1 "
1472,"<S2SV_StartBug> ""<td<S2SV_blank>style=\'color:red;\'><form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Stop<S2SV_blank>Monit<S2SV_blank>http<S2SV_blank>server?<S2SV_blank>"" <S2SV_EndBug> <S2SV_StartBug> ""<td><form<S2SV_blank>method=GET<S2SV_blank>action=\'_viewlog\'>View<S2SV_blank>Monit<S2SV_blank>logfile?<S2SV_blank><input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'></form></td>"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""<td<S2SV_blank>style=\'color:red;\'>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Stop<S2SV_blank>Monit<S2SV_blank>http<S2SV_blank>server?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'stop\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'>"" ""</form>"" ""</td>"" , res -> token ) ; StringBuffer_append ( res -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Force<S2SV_blank>validate<S2SV_blank>now?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'validate\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'>"" ""</form>"" ""</td>"" , res -> token <S2SV_ModEnd> <S2SV_ModStart> ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\'_viewlog\'>View<S2SV_blank>Monit<S2SV_blank>logfile?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'>"" ""</form>"" ""</td>"" , res -> token <S2SV_ModEnd> "
1473,"<S2SV_StartBug> vpx_memcpy ( dest , source , dest_width ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> 
1474,"<S2SV_StartBug> snprintf ( constr1 , 32 , ""%lld"" , deadline ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1475,<S2SV_StartBug> assert ( n >= 0 && n < 32 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( n < 0 || n >= 32 ) { return - 1 ; } <S2SV_ModEnd> 
1476,"<S2SV_StartBug> & len , & iovec , compat ) ; <S2SV_EndBug> <S2SV_StartBug> len , iovec ) ; <S2SV_EndBug> <S2SV_StartBug> iov_iter_init ( & iter , rw , iovec , nr_segs , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> , & iter <S2SV_ModStart> , & iter <S2SV_ModStart> ret = iter_op ( req , & iter ) ; } else { ret = rw_op ( req , iter . iov , iter . <S2SV_ModEnd> "
1477,<S2SV_StartBug> if ( ! el ) <S2SV_EndBug> ,"<S2SV_ModStart> { if ( c -> rbytes > 1024 ) { char * ptr = c -> rcurr ; while ( * ptr == '<S2SV_blank>' ) { ++ ptr ; } if ( strcmp ( ptr , ""get<S2SV_blank>"" ) && strcmp ( ptr , ""gets<S2SV_blank>"" ) ) { conn_set_state ( c , conn_closing ) ; return 1 ; } } return 0 ; } <S2SV_ModEnd> "
1478,"<S2SV_StartBug> USB_DT_OTG , ( void * * ) & desc ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( * desc ) "
1479,<S2SV_StartBug> if ( iad_num == USB_MAXIADS ) { <S2SV_EndBug> <S2SV_StartBug> ( struct usb_interface_assoc_descriptor <S2SV_EndBug> ,"<S2SV_ModStart> struct usb_interface_assoc_descriptor * d ; d = ( struct usb_interface_assoc_descriptor * ) header ; if ( d -> bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE ) { dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>interface<S2SV_blank>association<S2SV_blank>descriptor<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>skipping\\n"" , cfgno , d -> bLength ) ; continue ; } <S2SV_ModStart> d <S2SV_ModEnd> "
1480,<S2SV_StartBug> if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> ,"<S2SV_ModStart> info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; if ( replace ) { err = snd_ctl_remove_user_ctl ( file , & info -> id ) ; if ( err ) return err ; } if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1481,"<S2SV_StartBug> exit_client ( client_p , client_p , client_p , ""Mixing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>protocol"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; return 0 ; } if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) { exit_client ( client_p , client_p , client_p , ""Malformed<S2SV_blank>AUTHENTICATE"" "
1482,<S2SV_StartBug> if ( ctxt -> rip_relative ) <S2SV_EndBug> ,<S2SV_ModStart> && likely ( ctxt -> memopp ) 
1483,"<S2SV_StartBug> mmap_event -> event_id . header . size , 0 , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1484,<S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> ,<S2SV_ModStart> ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> 
1485,<S2SV_StartBug> distortion = vp8_variance16x16 <S2SV_EndBug> ,<S2SV_ModStart> vpx_variance16x16 <S2SV_ModEnd> 
1486,"<S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ECON2 , ECON2_ETHEN | ECON2_STRCH ) ; <S2SV_EndBug> <S2SV_StartBug> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR1 ) ; <S2SV_EndBug> <S2SV_StartBug> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR2 ) ; <S2SV_EndBug> <S2SV_StartBug> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR3 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MAADR1 , temp ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MAADR2 , temp ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MAADR3 , temp ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXST , ENC624J600_RX_BUFFER_START ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXFCON , ERXFCON_HTEN | <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT2 , 0x0000 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , 0x0000 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , 0x0000 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 , <S2SV_EndBug> <S2SV_StartBug> enc624j600WritePhyReg ( interface , ENC624J600_PHY_REG_PHANA , PHANA_ADPAUS0 | <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EIE , EIE_INTIE | <S2SV_EndBug> <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_RXEN ) ; <S2SV_EndBug> ","<S2SV_ModStart> ENC624J600_ECON2 , ENC624J600_ECON2_ETHEN | ENC624J600_ECON2_STRCH <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MAADR1 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MAADR2 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MAADR3 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MAADR1 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MAADR2 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MAADR3 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ERXST <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ERXTAIL <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ERXFCON , ENC624J600_ERXFCON_HTEN | ENC624J600_ERXFCON_CRCEN | ENC624J600_ERXFCON_RUNTEN | ENC624J600_ERXFCON_UCEN | ENC624J600_ERXFCON_BCEN ) ; enc624j600WriteReg ( interface , ENC624J600_EHT1 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EHT2 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EHT3 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EHT4 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT ) ; enc624j600WriteReg ( interface , ENC624J600_MAMXFL <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_PHANA , ENC624J600_PHANA_ADPAUS0 | ENC624J600_PHANA_AD100FD | ENC624J600_PHANA_AD100 | ENC624J600_PHANA_AD10FD | ENC624J600_PHANA_AD10 | ENC624J600_PHANA_ADIEEE_DEFAULT ) ; enc624j600WriteReg ( interface , ENC624J600_EIR <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EIE , ENC624J600_EIE_INTIE | ENC624J600_EIE_LINKIE | ENC624J600_EIE_PKTIE | ENC624J600_EIE_TXIE | ENC624J600_EIE_TXABTIE <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ECON1 , ENC624J600_ECON1_RXEN <S2SV_ModEnd> "
1487,<S2SV_StartBug> maxlen = strlen ( ( char * ) psf -> header ) ; <S2SV_EndBug> <S2SV_StartBug> start = ( ( char * ) psf -> header ) + maxlen ; <S2SV_EndBug> <S2SV_StartBug> maxlen = sizeof ( psf -> header ) - maxlen ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex = strlen ( ( char * ) psf -> header ) ; <S2SV_EndBug> ,<S2SV_ModStart> . ptr <S2SV_ModStart> . ptr <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> . len <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr 
1488,<S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct arpt_entry ) && <S2SV_EndBug> <S2SV_StartBug> t -> verdict < 0 && unconditional ( & e -> arp ) ) || <S2SV_EndBug> ,<S2SV_ModStart> unconditional ( e <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1489,<S2SV_StartBug> if ( ! job_id || ! prev_hash || ! coinbase1 || ! coinbase2 || ! bbversion || ! nbit || ! ntime ) { <S2SV_EndBug> <S2SV_StartBug> if ( job_id ) <S2SV_EndBug> ,<S2SV_ModStart> valid_hex ( job_id ) || ! valid_hex ( prev_hash ) || ! valid_hex ( coinbase1 ) || ! valid_hex ( coinbase2 ) || ! valid_hex ( bbversion ) || ! valid_hex ( nbit ) || ! valid_hex ( ntime ) ) { free <S2SV_ModEnd> <S2SV_ModStart> ; free ( coinbase1 ) ; <S2SV_ModEnd> 
1490,<S2SV_StartBug> if ( ctx -> priv -> alg_priv ) <S2SV_EndBug> <S2SV_StartBug> ctx -> iface -> destroy ( ctx -> priv -> alg_priv ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( vpx_codec_alg_priv_t * ) <S2SV_ModStart>  <S2SV_ModEnd> 
1491,<S2SV_StartBug> return 1 ; <S2SV_EndBug> ,<S2SV_ModStart> case EXIT_REASON_INVEPT : 
1492,"<S2SV_StartBug> sf -> adaptive_rd_thresh = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> sf -> less_rectangular_check = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD <S2SV_EndBug> <S2SV_StartBug> sf -> auto_mv_step_size = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> subpel_iters_per_step = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; <S2SV_EndBug> <S2SV_StartBug> sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD <S2SV_EndBug> <S2SV_StartBug> if ( MIN ( cm -> width , cm -> height ) >= 720 ) <S2SV_EndBug> <S2SV_StartBug> sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_LOW_MOTION ; <S2SV_EndBug> <S2SV_StartBug> if ( MIN ( cm -> width , cm -> height ) >= 720 ) <S2SV_EndBug> <S2SV_StartBug> sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ; <S2SV_EndBug> <S2SV_StartBug> sf -> disable_split_mask = DISABLE_ALL_SPLIT ; <S2SV_EndBug> <S2SV_StartBug> sf -> adaptive_rd_thresh = 4 ; <S2SV_EndBug> <S2SV_StartBug> sf -> mode_search_skip_flags |= FLAG_SKIP_COMP_REFMISMATCH | <S2SV_EndBug> <S2SV_StartBug> sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_ALL ; <S2SV_EndBug> <S2SV_StartBug> sf -> use_lp32x32fdct = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> partition_search_type = FIXED_PARTITION ; <S2SV_EndBug> <S2SV_StartBug> sf -> search_method = HEX ; <S2SV_EndBug> <S2SV_StartBug> sf -> intra_y_mode_mask [ i ] = INTRA_DC_ONLY ; <S2SV_EndBug> <S2SV_StartBug> sf -> intra_uv_mode_mask [ i ] = INTRA_DC_ONLY ; <S2SV_EndBug> ",<S2SV_ModStart> const int boosted = frame_is_boosted ( cpi ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ( cpi -> twopass . fr_content_type == FC_GRAPHICS_ANIMATION ) || vp9_internal_image_edge ( cpi ) ) { sf -> use_square_partition_only = ! frame_is_boosted ( cpi ) ; } else { <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mv . <S2SV_ModStart> mv . <S2SV_ModStart> ; sf -> tx_size_search_breakout = 1 ; sf -> partition_search_breakout_rate_thr = 80 <S2SV_ModStart> frame_is_boosted <S2SV_ModEnd> <S2SV_ModStart> sf -> reference_masking = cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ? 1 : 0 ; sf -> mode_search_skip_flags = <S2SV_ModEnd> <S2SV_ModStart> frame_type == KEY_FRAME ) ? 0 : <S2SV_ModEnd> <S2SV_ModStart> allow_partition_search_skip = 1 <S2SV_ModEnd> <S2SV_ModStart> sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; sf -> tx_size_search_method = frame_is_intra_only ( cm ) ? USE_FULL_RD : USE_LARGESTALL ; sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED ; sf -> adaptive_pred_interp_filter = 0 ; sf -> adaptive_mode_search = 1 ; sf -> cb_partition_search = ! boosted ; sf -> cb_pred_filter_search = 1 ; sf -> alt_ref_search_fp = 1 <S2SV_ModEnd> <S2SV_ModStart> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC ; sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC ; sf -> adaptive_interp_filter_search <S2SV_ModEnd> <S2SV_ModStart> mv . search_method = BIGDIA ; sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED_MORE <S2SV_ModEnd> <S2SV_ModStart> if ( cm -> frame_type != KEY_FRAME ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ; sf -> use_fast_coef_costing = 1 ; sf -> motion_field_mode_search = ! boosted ; sf -> partition_search_breakout_rate_thr = 300 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mv . <S2SV_ModStart> INTRA_DC <S2SV_ModEnd> <S2SV_ModStart> INTRA_DC ; } sf -> partition_search_breakout_rate_thr = 500 ; sf -> mv . reduce_first_step_size = 1 ; sf -> simple_model_rd_from_var = 1 <S2SV_ModEnd> 
1493,"<S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> ",<S2SV_ModStart> _dh <S2SV_ModEnd> 
1494,"<S2SV_StartBug> if ( copy_from_user ( & tx32 , utp , sizeof ( struct compat_timex ) ) ) <S2SV_EndBug> ","<S2SV_ModStart> memset ( txc , 0 , sizeof ( struct timex ) ) ; "
1495,"<S2SV_StartBug> int ret = poll ( pfds , ts [ h ] . poll_count , - 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1496,<S2SV_StartBug> int goodsize = inuse + ( inuse / 8 ) + 2 * EXTRA_STACK ; <S2SV_EndBug> ,<S2SV_ModStart> BASIC_STACK_SIZE <S2SV_ModEnd> 
1497,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> 
1498,"<S2SV_StartBug> const char * raw , * s = STR ( CHILD ( n , 0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> char * s = """" ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const 
1499,"<S2SV_StartBug> int is_keyframe_qaunt_set = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( ""encoding-mode"" , option_name ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( ""layers"" , option_name ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( ""quantizers"" , option_name ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! is_keyframe_qaunt_set ) { <S2SV_EndBug> <S2SV_StartBug> is_keyframe_qaunt_set = 1 ; <S2SV_EndBug> <S2SV_StartBug> return res ; <S2SV_EndBug> ","<S2SV_ModStart> SvcInternal_t * const si = get_svc_internal ( svc_ctx ) ; vpx_codec_err_t res = VPX_CODEC_OK ; int i , alt_ref_enabled = 0 <S2SV_ModEnd> <S2SV_ModStart> ""spatial-layers"" , option_name ) == 0 ) { svc_ctx -> spatial_layers = atoi ( option_value ) ; } else if ( strcmp ( ""temporal-layers"" , option_name ) == 0 ) { svc_ctx -> temporal_layers = atoi ( option_value ) ; } else if ( strcmp ( ""scale-factors"" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , SCALE_FACTOR , option_value , si -> svc_params . scaling_factor_num , si -> svc_params . scaling_factor_den <S2SV_ModEnd> <S2SV_ModStart> ""max-quantizers"" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . max_quantizers , NULL <S2SV_ModEnd> <S2SV_ModStart> ""min-quantizers"" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . min_quantizers , NULL <S2SV_ModEnd> <S2SV_ModStart> } else if ( strcmp ( ""auto-alt-refs"" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , AUTO_ALT_REF , option_value , si -> enable_auto_alt_ref , NULL <S2SV_ModEnd> <S2SV_ModStart> } else if ( strcmp ( ""bitrates"" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , BITRATE , option_value , si -> bitrates , NULL ) ; if ( res != VPX_CODEC_OK ) break ; } else if ( strcmp ( ""multi-frame-contexts"" , option_name ) == 0 ) { si -> use_multiple_frame_contexts = atoi ( option_value ) <S2SV_ModEnd> <S2SV_ModStart> for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) { if ( si -> svc_params . max_quantizers [ i ] > MAX_QUANTIZER || si -> svc_params . max_quantizers [ i ] < 0 || si -> svc_params . min_quantizers [ i ] > si -> svc_params . max_quantizers [ i ] || si -> svc_params . min_quantizers [ i ] < 0 ) res = VPX_CODEC_INVALID_PARAM ; } if ( si -> use_multiple_frame_contexts && ( svc_ctx -> spatial_layers > 3 || svc_ctx -> spatial_layers * svc_ctx -> temporal_layers > 4 ) ) res = VPX_CODEC_INVALID_PARAM ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) alt_ref_enabled += si -> enable_auto_alt_ref [ i ] ; if ( alt_ref_enabled > REF_FRAMES - svc_ctx -> spatial_layers ) { svc_log ( svc_ctx , SVC_LOG_ERROR , ""svc:<S2SV_blank>auto<S2SV_blank>alt<S2SV_blank>ref:<S2SV_blank>Maxinum<S2SV_blank>%d(REF_FRAMES<S2SV_blank>-<S2SV_blank>layers)<S2SV_blank>layers<S2SV_blank>could"" ""enabled<S2SV_blank>auto<S2SV_blank>alt<S2SV_blank>reference<S2SV_blank>frame,<S2SV_blank>but<S2SV_blank>%<S2SV_blank>layers<S2SV_blank>are<S2SV_blank>enabled\\n"" , REF_FRAMES - svc_ctx -> spatial_layers , alt_ref_enabled ) ; res = VPX_CODEC_INVALID_PARAM ; } "
1500,<S2SV_StartBug> if ( ! head ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> WARN_ON_ONCE ( <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1501,<S2SV_StartBug> for ( s += 9 ; isspace ( * s ) ; s ++ ) ; <S2SV_EndBug> <S2SV_StartBug> while ( * t && ! isspace ( * t ) ) t ++ ; <S2SV_EndBug> ,<S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) 
1502,<S2SV_StartBug> if ( ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_LAST_PWD_CHANGE ) || <S2SV_EndBug> <S2SV_StartBug> if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) <S2SV_EndBug> <S2SV_StartBug> if ( entry == ( kadm5_principal_ent_t ) NULL ) <S2SV_EndBug> ,<S2SV_ModStart> entry == NULL ) return EINVAL ; if ( <S2SV_ModStart> entry -> policy == NULL <S2SV_ModEnd> <S2SV_ModStart> ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK <S2SV_ModEnd> 
1503,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> <S2SV_StartBug> for ( plane = 1 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) <S2SV_EndBug> ,<S2SV_ModStart> [ plane ] && frame -> linesize <S2SV_ModStart> && frame -> linesize [ plane ] 
1504,"<S2SV_StartBug> fprintf ( mvs , ""\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> mb_index = 0 ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1505,<S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> 
1506,"
","
"
1507,<S2SV_StartBug> if ( data [ 1 ] <= 127 ) <S2SV_EndBug> <S2SV_StartBug> else op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ; <S2SV_EndBug> <S2SV_StartBug> op -> fail = addr + op -> size ; <S2SV_EndBug> ,<S2SV_ModStart> len > 1 ) { if ( <S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> } } else { op -> jump = addr ; } 
1508,"<S2SV_StartBug> do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) , <S2SV_EndBug> ",<S2SV_ModStart> if ( imp_dbh -> pmysql ) 
1509,"<S2SV_StartBug> if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( ioctl ( slot -> fd , FIONREAD , & size ) == 0 && size ) ) <S2SV_EndBug> <S2SV_StartBug> pthread_mutex_unlock ( & slot_lock ) ; <S2SV_EndBug> <S2SV_StartBug> BTA_JvRfcommWrite ( slot -> rfc_handle , slot -> id ) ; <S2SV_EndBug> <S2SV_StartBug> if ( need_close || ioctl ( slot -> fd , FIONREAD , & size ) != 0 || ! size ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> { <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1510,"<S2SV_StartBug> struct ieee_802_11_phdr phdr ; <S2SV_EndBug> <S2SV_StartBug> dissector_try_uint ( wtap_encap_dissector_table , <S2SV_EndBug> <S2SV_StartBug> wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; int wtap_encap ; struct eth_phdr eth ; void * phdrp <S2SV_ModStart> wtap_encap = wtap_pcap_encap_to_wtap_encap ( dlt ) ; switch ( wtap_encap ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdrp = & eth ; break ; default : phdrp = NULL ; break ; } dissector_try_uint_new <S2SV_ModEnd> <S2SV_ModStart> wtap_encap <S2SV_ModEnd> <S2SV_ModStart> , TRUE , phdrp "
1511,<S2SV_StartBug> sh = s_malloc ( hdrlen + initlen + 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart> assert ( initlen + hdrlen + 1 > initlen ) ; 
1512,"<S2SV_StartBug> static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , <S2SV_EndBug> <S2SV_StartBug> UINT32 tempWidth ; <S2SV_EndBug> <S2SV_StartBug> for ( y = 0 ; y < context -> height ; y ++ ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! context || data || ( scanline == 0 ) ) return FALSE <S2SV_ModStart> if ( context -> priv -> PlaneBuffersLength < rw * scanline ) return FALSE ; if ( rw < scanline * 2 ) return FALSE ; <S2SV_ModStart> return TRUE ; 
1513,<S2SV_StartBug> while ( offset < end_offset ) <S2SV_EndBug> <S2SV_StartBug> return offset ; <S2SV_EndBug> ,<S2SV_ModStart> > 0 && offset <S2SV_ModStart> { <S2SV_ModStart> } 
1514,<S2SV_StartBug> return ERR_PTR ( - EINVAL ) ; <S2SV_EndBug> ,<S2SV_ModStart> { ret = - EINVAL ; goto out_free ; } <S2SV_ModEnd> 
1515,"<S2SV_StartBug> const RATE_CONTROL * rc = & cpi -> rc ; <S2SV_EndBug> <S2SV_StartBug> target = ( ( cpi -> oxcf . starting_buffer_level / 2 ) > INT_MAX ) <S2SV_EndBug> <S2SV_StartBug> ? INT_MAX : ( int ) ( cpi -> oxcf . starting_buffer_level / 2 ) ; <S2SV_EndBug> <S2SV_StartBug> int kf_boost = MAX ( initial_boost , ( int ) ( 2 * cpi -> output_framerate - 16 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc -> frames_since_key < cpi -> output_framerate / 2 ) { <S2SV_EndBug> <S2SV_StartBug> ( cpi -> output_framerate / 2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> target = ( ( 16 + kf_boost ) * rc -> av_per_frame_bandwidth ) >> 4 ; <S2SV_EndBug> ","<S2SV_ModStart> ; const VP9EncoderConfig * oxcf = & cpi -> oxcf ; const SVC * const svc = & cpi -> svc <S2SV_ModStart> rc -> <S2SV_ModEnd> <S2SV_ModStart> rc -> starting_buffer_level / 2 ) ; } else { int kf_boost = 32 ; double framerate = cpi -> framerate ; if ( svc -> number_temporal_layers > 1 && oxcf -> rc_mode == VPX_CBR ) { const int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , svc -> temporal_layer_id , svc -> number_temporal_layers ) ; const LAYER_CONTEXT * lc = & svc -> layer_context [ layer ] ; framerate = lc -> framerate ; } <S2SV_ModEnd> <S2SV_ModStart> kf_boost , ( int ) ( 2 * framerate <S2SV_ModEnd> <S2SV_ModStart> framerate <S2SV_ModEnd> <S2SV_ModStart> framerate <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> "
1516,<S2SV_StartBug> update_db_bp_intercept ( vcpu ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1517,"<S2SV_StartBug> static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data ) <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> indx , data , size , 100 ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> const <S2SV_ModStart> u8 * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> kfree ( buf ) ; "
1518,"<S2SV_StartBug> static TX_MODE read_tx_mode ( vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> TX_MODE tx_mode = vp9_read_literal ( r , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> tx_mode += vp9_read_bit ( r ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_read_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_read_bit <S2SV_ModEnd> 
1519,<S2SV_StartBug> register const struct hello6 * hellop = ( const struct hello6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; ND_TCHECK_32BITS ( & hellop -> hello_options 
1520,<S2SV_StartBug> if ( * ( unsigned char * ) data > 1 ) <S2SV_EndBug> ,<S2SV_ModStart> datalen != 1 ) return - EINVAL ; if ( 
1521,"<S2SV_StartBug> rc -> uwbd . task = kthread_run ( uwbd , rc , ""uwbd"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc -> uwbd . task == NULL ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> struct task_struct * <S2SV_ModEnd> <S2SV_ModStart> IS_ERR ( task ) ) { <S2SV_ModStart> = NULL ; <S2SV_ModEnd> <S2SV_ModStart> } else { rc -> uwbd . task = task ; <S2SV_ModEnd> <S2SV_ModStart> } 
1522,"<S2SV_StartBug> # line 96 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1045 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 97 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 98 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 99 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 100 ""re_grammar.y"" <S2SV_EndBug> ","<S2SV_ModStart> 104 <S2SV_ModEnd> <S2SV_ModStart> 1053 <S2SV_ModEnd> <S2SV_ModStart> 105 ""re_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1059 <S2SV_ModEnd> <S2SV_ModStart> 106 ""re_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1065 <S2SV_ModEnd> <S2SV_ModStart> 107 ""re_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1071 <S2SV_ModEnd> <S2SV_ModStart> 108 ""re_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1077 <S2SV_ModEnd> "
1523,<S2SV_StartBug> * ptr = ( char ) ( ( existing & ~ ( mask << bitIdx ) ) | ( ( col & mask ) << bitIdx ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ; 
1524,"<S2SV_StartBug> MACROBLOCKD * xd = args -> xd ; <S2SV_EndBug> <S2SV_StartBug> struct macroblock_plane * p = & cpi -> mb . plane [ plane ] ; <S2SV_EndBug> <S2SV_StartBug> const int16_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> common . fc . coef_probs [ tx_size ] [ type ] [ ref ] ; <S2SV_EndBug> <S2SV_StartBug> cpi -> common . counts . eob_branch [ tx_size ] [ type ] [ ref ] ; <S2SV_EndBug> <S2SV_StartBug> int aoff , loff ; <S2SV_EndBug> <S2SV_StartBug> add_token ( & t , coef_probs [ band [ c ] ] [ pt ] , <S2SV_EndBug> <S2SV_StartBug> vp9_dct_value_tokens_ptr [ v ] . extra , <S2SV_EndBug> <S2SV_StartBug> ( uint8_t ) vp9_dct_value_tokens_ptr [ v ] . token , <S2SV_EndBug> <S2SV_StartBug> vp9_pt_energy_class [ vp9_dct_value_tokens_ptr [ v ] . token ] ; <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * const td = args -> td ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd <S2SV_ModEnd> <S2SV_ModStart> x -> <S2SV_ModEnd> <S2SV_ModStart> tran_low_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; const int segment_id = mbmi -> segment_id ; const int16_t * scan , * nb ; const scan_order * so ; const int ref = is_inter_block ( mbmi ) ; unsigned int ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = td -> rd_counts . coef_counts [ tx_size ] [ type ] [ ref ] ; vpx_prob <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> td -> counts -> <S2SV_ModEnd> <S2SV_ModStart> int16_t token ; EXTRABIT extra ; <S2SV_ModStart> vp9_get_token_extra ( v , & token , & extra ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1525,<S2SV_StartBug> SrcList * pSrc = pSelect -> pSrc ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( pSelect -> selFlags & SF_View ) return WRC_Prune 
1526,<S2SV_StartBug> if ( shmflg & SHM_RND ) <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) && addr >= shmlba 
1527,"<S2SV_StartBug> serv = svc_create ( & nfs4_callback_program , NFS4_CALLBACK_BUFSIZE , sv_ops ) ; <S2SV_EndBug> ",<S2SV_ModStart> svc_create_pooled <S2SV_ModEnd> 
1528,"<S2SV_StartBug> void pointZZ_pMul ( PointZZ_p * rop , const PointZZ_p * point , const mpz_t scalar , const CurveZZ_p * curve ) { <S2SV_EndBug> ",<S2SV_ModStart> if ( pointZZ_pIsIdentityElement ( point ) ) { return pointZZ_pSetToIdentityElement ( rop ) ; } 
1529,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> <S2SV_StartBug> exit_func : <S2SV_EndBug> ",<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : <S2SV_ModStart>  <S2SV_ModEnd> 
1530,<S2SV_StartBug> case NPNVSupportsWindowless : <S2SV_EndBug> ,<S2SV_ModStart> : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling 
1531,"<S2SV_StartBug> ssize_t ret = sendmsg ( socket -> fd , & msg , MSG_DONTWAIT ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1532,"<S2SV_StartBug> do ret = send ( sock_fd , buf , s , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1533,"<S2SV_StartBug> for ( xIter = crm_first_attr ( xml ) ; xIter != NULL ; xIter = xIter -> next ) { <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( prop_name , XML_ATTR_ID ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> char * path = xml_get_path ( xml ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> char * path = xml_get_path ( xml ) ; <S2SV_ModStart> && strstr ( path , ""/"" XML_CIB_TAG_ACLS ""/"" ) == NULL <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> free ( path ) ; "
1534,"<S2SV_StartBug> sprintf ( charbuf , ""%s/%s.html"" , dirout , rootname ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( charbuf , ""%s/%s-links.html"" , dirout , rootname ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( charbuf , ""%s_thumb_%03d"" , rootname , index ) ; <S2SV_EndBug> ","<S2SV_ModStart> snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> "
1535,<S2SV_StartBug> static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) { <S2SV_EndBug> <S2SV_StartBug> return ( const SvcInternal * ) svc_ctx -> internal ; <S2SV_EndBug> ,<S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> <S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> 
1536,"<S2SV_StartBug> spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> ) ; hctx = q -> mq_ops -> map_queue ( q , flush_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , flush_rq -> tag , fq -> orig_rq "
1537,"<S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; <S2SV_EndBug> ","<S2SV_ModStart> uint32 length ; struct stream packet = * s <S2SV_ModEnd> <S2SV_ModStart> if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""mcs_parse_domain_params(),<S2SV_blank>consume<S2SV_blank>domain<S2SV_blank>params<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } "
1538,<S2SV_StartBug> if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) { <S2SV_EndBug> ,<S2SV_ModStart> && Z_TYPE_PP ( ptr ) == IS_ARRAY 
1539,"<S2SV_StartBug> char buffer [ 80 ] ; <S2SV_EndBug> <S2SV_StartBug> _y4m -> vpx_bps = 12 ; <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( _y4m -> chroma_type , ""420"" ) == 0 || <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( _y4m -> chroma_type , ""420mpeg2"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> _y4m -> vpx_bps = 16 ; <S2SV_EndBug> <S2SV_StartBug> _y4m -> convert = y4m_convert_null ; <S2SV_EndBug> <S2SV_StartBug> _y4m -> vpx_bps = 24 ; <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( _y4m -> chroma_type , ""444alpha"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( only_420 ) { <S2SV_EndBug> <S2SV_StartBug> _y4m -> dst_c_dec_h = 2 ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Unknown<S2SV_blank>chroma<S2SV_blank>sampling<S2SV_blank>type:<S2SV_blank>%s\\n"" , _y4m -> chroma_type ) ; <S2SV_EndBug> <S2SV_StartBug> _y4m -> dst_buf_sz = _y4m -> pic_w * _y4m -> pic_h <S2SV_EndBug> <S2SV_StartBug> _y4m -> dst_buf = ( unsigned char * ) malloc ( _y4m -> dst_buf_sz ) ; <S2SV_EndBug> <S2SV_StartBug> _y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz ) ; <S2SV_EndBug> ","<S2SV_ModStart> = { 0 } <S2SV_ModStart> bps <S2SV_ModEnd> <S2SV_ModStart> _y4m -> bit_depth = 8 ; <S2SV_ModStart> ""420p10"" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; _y4m -> bit_depth = 10 ; _y4m -> bps = 15 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42016 ; if ( only_420 ) { fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>420p10<S2SV_blank>to<S2SV_blank>420jpeg\\n"" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , ""420p12"" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; _y4m -> bit_depth = 12 ; _y4m -> bps = 18 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42016 ; if ( only_420 ) { fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>420p12<S2SV_blank>to<S2SV_blank>420jpeg\\n"" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , <S2SV_ModStart> bps <S2SV_ModEnd> <S2SV_ModStart> ; } } else if ( strcmp ( _y4m -> chroma_type , ""422p10"" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ; _y4m -> bps = 20 ; _y4m -> bit_depth = 10 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>422p10<S2SV_blank>to<S2SV_blank>420jpeg\\n"" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , ""422p12"" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ; _y4m -> bps = 24 ; _y4m -> bit_depth = 12 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>422p12<S2SV_blank>to<S2SV_blank>420jpeg\\n"" ) ; return - 1 <S2SV_ModStart> bps <S2SV_ModEnd> <S2SV_ModStart> ""444p10"" <S2SV_ModEnd> <S2SV_ModStart> _y4m -> vpx_fmt = VPX_IMG_FMT_I44416 ; _y4m -> bps = 30 ; _y4m -> bit_depth = 10 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>444p10<S2SV_blank>to<S2SV_blank>420jpeg\\n"" <S2SV_ModEnd> <S2SV_ModStart> } else if ( strcmp ( _y4m -> chroma_type , ""444p12"" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I44416 ; _y4m -> bps = 36 ; _y4m -> bit_depth = 12 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>444p12<S2SV_blank>to<S2SV_blank>420jpeg\\n"" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , ""444alpha"" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; if ( only_420 ) { _y4m -> dst_c_dec_h = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> convert = y4m_convert_444_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_444A ; _y4m -> bps = 32 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 4 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; } } else if ( strcmp ( _y4m -> chroma_type , ""mono"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> src_c_dec_v = 0 ; _y4m -> dst_c_dec_h = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_mono_420jpeg ; } else { fprintf ( stderr , ""Unknown<S2SV_blank>chroma<S2SV_blank>sampling<S2SV_blank>type:<S2SV_blank>%s\\n"" , _y4m -> chroma_type ) ; return - 1 ; } <S2SV_ModStart> if ( _y4m -> bit_depth == 8 ) <S2SV_ModStart> else _y4m -> dst_buf <S2SV_ModEnd> <S2SV_ModStart> 2 * _y4m -> dst_buf_sz ) ; if ( <S2SV_ModStart> > 0 ) _y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz "
1540,"<S2SV_StartBug> struct obj * otmp = readobjnam ( buf , ( struct obj * ) 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> otmp ; if ( strlen ( buf ) >= BUFSZ ) buf [ BUFSZ - 1 ] = '\\0' ; 
1541,"<S2SV_StartBug> long long directory_table_end , table_start ; <S2SV_EndBug> <S2SV_StartBug> return FALSE ; <S2SV_EndBug> <S2SV_StartBug> return FALSE ; <S2SV_EndBug> <S2SV_StartBug> return FALSE ; <S2SV_EndBug> <S2SV_StartBug> if ( read_fragment_table ( & directory_table_end ) == FALSE ) <S2SV_EndBug> <S2SV_StartBug> return FALSE ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> table_start ; if ( sBlk . s . xattr_id_table_start != SQUASHFS_INVALID_BLK ) { if ( sBlk . s . xattr_id_table_start >= sBlk . s . bytes_used ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>xattr<S2SV_blank>id<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } <S2SV_ModEnd> <S2SV_ModStart> goto corrupted ; } else table_start = sBlk . s . bytes_used ; if ( sBlk . s . id_table_start >= table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>id<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( sBlk . s . no_ids == 0 ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>id<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( sBlk . s . no_ids > ( sBlk . s . inodes * 2L ) ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>id<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( read_id_table <S2SV_ModEnd> <S2SV_ModStart> goto corrupted ; if ( sBlk . s . lookup_table_start != SQUASHFS_INVALID_BLK ) { if ( sBlk . s . lookup_table_start >= table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>lookup<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } <S2SV_ModEnd> <S2SV_ModStart> goto corrupted ; } if ( sBlk . s . fragments != 0 ) { if ( sBlk . s . fragment_table_start >= table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>fragment<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( sBlk . s . fragments > sBlk . s . inodes ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>fragment<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } <S2SV_ModEnd> <S2SV_ModStart> table_start ) == FALSE ) goto corrupted ; } else { if ( sBlk . s . fragment_table_start != table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>fragment<S2SV_blank>table<S2SV_blank>start<S2SV_blank>invalid<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } } if ( sBlk . s . directory_table_start >= table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>directory<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( read_directory_table ( sBlk . s . directory_table_start , table_start ) == FALSE ) goto corrupted ; if ( sBlk . s . inode_table_start >= sBlk . s . directory_table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>inode<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } <S2SV_ModEnd> <S2SV_ModStart> goto corrupted <S2SV_ModEnd> <S2SV_ModStart> corrupted : ERROR ( ""File<S2SV_blank>system<S2SV_blank>corruption<S2SV_blank>detected\\n"" ) ; return FALSE ; "
1542,<S2SV_StartBug> createenv ( const struct rule * rule ) <S2SV_EndBug> <S2SV_StartBug> env -> count = 0 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> , const struct passwd * mypw , const struct passwd * targpw <S2SV_ModStart> ; addnode ( env , ""DOAS_USER"" , mypw -> pw_name ) <S2SV_ModStart> else { static const char * copyset [ ] = { ""DISPLAY"" , ""TERM"" , NULL } ; addnode ( env , ""HOME"" , targpw -> pw_dir ) ; addnode ( env , ""LOGNAME"" , targpw -> pw_name ) ; addnode ( env , ""PATH"" , getenv ( ""PATH"" ) ) ; addnode ( env , ""SHELL"" , targpw -> pw_shell ) ; addnode ( env , ""USER"" , targpw -> pw_name ) ; fillenv ( env , copyset ) ; } "
1543,<S2SV_StartBug> if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) { <S2SV_EndBug> ,<S2SV_ModStart> skb -> mac_header <S2SV_ModEnd> 
1544,"<S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> segmentation_map , 0 , cm -> mi_rows * cm -> mi_cols ) ; <S2SV_EndBug> <S2SV_StartBug> in_frame_q_adj_ratio [ segment ] ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> vpx_clear_system_state <S2SV_ModEnd> <S2SV_ModStart> const int aq_strength = get_aq_c_strength ( cm -> base_qindex , cm -> bit_depth ) ; memset ( cpi -> segmentation_map , DEFAULT_AQ2_SEG , cm -> mi_rows * cm -> mi_cols ) ; vp9_clearall_segfeatures ( seg ) ; if ( cpi -> rc . sb64_target_rate < 256 ) { vp9_disable_segmentation ( seg ) ; return ; } vp9_enable_segmentation ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vp9_disable_segfeature ( seg , DEFAULT_AQ2_SEG , SEG_LVL_ALT_Q ) ; for ( segment = 0 ; segment < AQ_C_SEGMENTS ; ++ segment ) { int qindex_delta ; if ( segment == DEFAULT_AQ2_SEG ) continue ; <S2SV_ModEnd> <S2SV_ModStart> aq_c_q_adj_factor [ aq_strength ] [ segment ] , cm -> bit_depth ) ; if ( ( cm -> base_qindex != 0 ) && ( ( cm -> base_qindex + qindex_delta ) == 0 ) ) { qindex_delta = - cm -> base_qindex + 1 ; } if ( ( cm -> base_qindex + qindex_delta ) > 0 ) { <S2SV_ModEnd> <S2SV_ModStart> } "
1545,"<S2SV_StartBug> Module_type = make_type ( ""Module"" , mod_type , Module_fields , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! Module_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> Interactive_type = make_type ( ""Interactive"" , mod_type , Interactive_fields , <S2SV_EndBug> <S2SV_StartBug> if ( ! Interactive_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> Expression_type = make_type ( ""Expression"" , mod_type , Expression_fields , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! FunctionDef_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> AsyncFunctionDef_fields , 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! AsyncFunctionDef_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> ClassDef_type = make_type ( ""ClassDef"" , stmt_type , ClassDef_fields , 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ClassDef_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> Return_type = make_type ( ""Return"" , stmt_type , Return_fields , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> Delete_type = make_type ( ""Delete"" , stmt_type , Delete_fields , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> Assign_type = make_type ( ""Assign"" , stmt_type , Assign_fields , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> AugAssign_type = make_type ( ""AugAssign"" , stmt_type , AugAssign_fields , 3 ) ; <S2SV_EndBug> <S2SV_StartBug> arg_type = make_type ( ""arg"" , & AST_type , arg_fields , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> initialized = 1 ; <S2SV_EndBug> ","<S2SV_ModStart> 2 ) ; if ( ! Module_type ) return 0 ; Interactive_type = make_type ( ""Interactive"" , mod_type , Interactive_fields , <S2SV_ModStart> Interactive_type ) return 0 ; Expression_type = make_type ( ""Expression"" <S2SV_ModEnd> <S2SV_ModStart> Expression_fields , <S2SV_ModEnd> <S2SV_ModStart> Expression_type ) return 0 ; FunctionType_type = make_type ( ""FunctionType"" <S2SV_ModEnd> <S2SV_ModStart> FunctionType_fields , 2 ) ; if ( ! FunctionType_type <S2SV_ModEnd> <S2SV_ModStart> 6 ) ; if ( ! FunctionDef_type ) return 0 ; AsyncFunctionDef_type = make_type ( ""AsyncFunctionDef"" , stmt_type , AsyncFunctionDef_fields , 6 ) ; if ( ! AsyncFunctionDef_type ) return 0 ; ClassDef_type = make_type ( ""ClassDef"" , stmt_type , ClassDef_fields , <S2SV_ModStart> ClassDef_type ) return 0 ; Return_type = make_type ( ""Return"" <S2SV_ModEnd> <S2SV_ModStart> Return_fields , 1 ) ; if ( ! Return_type ) return 0 ; Delete_type = make_type ( ""Delete"" , stmt_type , Delete_fields , 1 ) ; if ( ! Delete_type ) return 0 ; Assign_type = make_type ( ""Assign"" , stmt_type , Assign_fields , 3 ) ; if ( ! Assign_type ) return 0 ; AugAssign_type = make_type ( ""AugAssign"" , stmt_type , AugAssign_fields , 3 ) ; if ( ! AugAssign_type ) return 0 ; AnnAssign_type = make_type ( ""AnnAssign"" , stmt_type , AnnAssign_fields , 4 ) ; if ( ! AnnAssign_type ) return 0 ; For_type = make_type ( ""For"" , stmt_type , For_fields <S2SV_ModEnd> <S2SV_ModStart> For_type ) return 0 ; AsyncFor_type = make_type ( ""AsyncFor"" <S2SV_ModEnd> <S2SV_ModStart> AsyncFor_fields <S2SV_ModEnd> <S2SV_ModStart> AsyncFor_type ) return 0 ; While_type = make_type ( ""While"" <S2SV_ModEnd> <S2SV_ModStart> While_fields , 3 ) ; if ( ! While_type ) return 0 ; If_type = make_type ( ""If"" <S2SV_ModEnd> <S2SV_ModStart> If_fields , 3 ) ; if ( ! If_type ) return 0 ; With_type = make_type ( ""With"" <S2SV_ModEnd> <S2SV_ModStart> With_fields , 3 ) ; if ( ! With_type ) return 0 ; AsyncWith_type = make_type ( ""AsyncWith"" <S2SV_ModEnd> <S2SV_ModStart> AsyncWith_fields , 3 <S2SV_ModEnd> <S2SV_ModStart> 3 <S2SV_ModEnd> <S2SV_ModStart> type_ignore_type = make_type ( ""type_ignore"" , & AST_type , NULL , 0 ) ; if ( ! type_ignore_type ) return 0 ; if ( ! add_attributes ( type_ignore_type , NULL , 0 ) ) return 0 ; TypeIgnore_type = make_type ( ""TypeIgnore"" , type_ignore_type , TypeIgnore_fields , 1 ) ; if ( ! TypeIgnore_type ) return 0 ; "
1546,"<S2SV_StartBug> logfile_fd = open ( log_path , O_WRONLY | O_CREAT | O_TRUNC , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH ) ; <S2SV_EndBug> <S2SV_StartBug> write ( logfile_fd , ""btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea"" , 16 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1547,<S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; } 
1548,<S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart> else ( void ) cpi ; # 
1549,"<S2SV_StartBug> smb_flush_file ( sr , sr -> fid_ofile ) ; <S2SV_EndBug> <S2SV_StartBug> smb_flush_file ( sr , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> smb_ofile_flush <S2SV_ModEnd> <S2SV_ModStart> smb_ofile_flush <S2SV_ModEnd> 
1550,"<S2SV_StartBug> int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs ) <S2SV_EndBug> <S2SV_StartBug> while ( * s && len > 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( u >= PLANE_SIZE ) { <S2SV_EndBug> <S2SV_StartBug> u -= PLANE_SIZE ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = ( wchar_t ) ( SURROGATE_PAIR | <S2SV_EndBug> <S2SV_StartBug> ( ( u >> 10 ) & SURROGATE_BITS ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( u & SURROGATE_BITS ) ) ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = ( wchar_t ) u ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = * s ++ ; <S2SV_EndBug> ","<S2SV_ModStart> enum utf16_endian endian , <S2SV_ModStart> , int maxlen <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && maxlen > 0 && * s <S2SV_ModStart> s += size ; len -= size ; <S2SV_ModStart> if ( maxlen < 2 ) break ; <S2SV_ModStart> put_utf16 ( op ++ , <S2SV_ModEnd> <S2SV_ModStart> , endian ) ; put_utf16 ( op ++ , <S2SV_ModEnd> <S2SV_ModStart> , endian ) ; maxlen -= 2 <S2SV_ModEnd> <S2SV_ModStart> put_utf16 ( op ++ , u , endian ) ; maxlen -- ; } <S2SV_ModEnd> <S2SV_ModStart> put_utf16 ( op ++ , * s ++ , endian ) ; len -- ; maxlen <S2SV_ModEnd> "
1551,"<S2SV_StartBug> if ( ( strchr ( cp , '/' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) { <S2SV_EndBug> ","<S2SV_ModStart> * cp == '\\0' || <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> ""."" ) == 0 || strcmp ( cp , <S2SV_ModStart>  <S2SV_ModEnd> "
1552,"<S2SV_StartBug> int num , i , num1 , num2 ; <S2SV_EndBug> <S2SV_StartBug> char * s , * t , * StartClean ; <S2SV_EndBug> <S2SV_StartBug> double * argbuf = 0 ; <S2SV_EndBug> <S2SV_StartBug> outpos = outputbuffer ; <S2SV_EndBug> <S2SV_StartBug> outpos += sprintf ( outpos , ""\\\\axo@setObject{%s}%%\\n{%s%c}%%\\n{"" , s , t , TERMCHAR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * s == '0' && s [ 1 ] == ']' ) { <S2SV_EndBug> <S2SV_StartBug> outpos += sprintf ( outpos , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output.}"" , VERSION , SUBVERSION ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( outfile , ""%s"" , outputbuffer ) ; <S2SV_EndBug> <S2SV_StartBug> if ( argbuf ) free ( argbuf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ( argbuf = ReadTail ( t , & num ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> ","<S2SV_ModStart> , retcode <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; retcode = - 1 <S2SV_ModStart> fprintf ( outfile , ""\\\\axo@setObject{%s}%%\\n{%s%c}%%\\n{"" , s , t , TERMCHAR ) ; <S2SV_ModStart> nameobject = t ; while ( * t != '<S2SV_blank>' && * t != '\\t' && * t != '\\n' && * t ) t ++ ; * t ++ = 0 ; while ( * t == '<S2SV_blank>' || * t == '\\t' || * t == '\\n' ) t ++ <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> fprintf ( outfile , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output."" <S2SV_ModEnd> <S2SV_ModStart> goto SUCCESS ; } else { fprintf ( <S2SV_ModEnd> <S2SV_ModStart> goto EXIT ; } } <S2SV_ModEnd> <S2SV_ModStart> goto EXIT <S2SV_ModEnd> <S2SV_ModStart> goto EXIT <S2SV_ModEnd> <S2SV_ModStart> argbuf = 0 ; <S2SV_ModStart> goto EXIT <S2SV_ModEnd> <S2SV_ModStart> goto EXIT <S2SV_ModEnd> <S2SV_ModStart> argbuf = 0 ; <S2SV_ModStart> goto EXIT <S2SV_ModEnd> <S2SV_ModStart> argbuf = 0 ; <S2SV_ModStart> goto EXIT <S2SV_ModEnd> <S2SV_ModStart> goto EXIT ; } } SUCCESS : retcode = 0 ; EXIT : if ( argbuf ) { <S2SV_ModStart> } fprintf ( outfile , ""}\\n"" ) ; return ( retcode <S2SV_ModEnd> "
1553,<S2SV_StartBug> default : <S2SV_EndBug> ,<S2SV_ModStart> case MAGIC_PARAM_ELF_NOTES_MAX : * ( size_t * ) val = ms -> elf_notes_max ; return 0 ; 
1554,"<S2SV_StartBug> static u32 ip_idents_hashrnd __read_mostly ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <S2SV_EndBug> <S2SV_StartBug> hash = jhash_3words ( ( __force u32 ) iph -> daddr , <S2SV_EndBug> <S2SV_StartBug> iph -> protocol ^ net_hash_mix ( net ) , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key <S2SV_ModEnd> <S2SV_ModStart> net -> ipv4 . ip_id_key <S2SV_ModEnd> <S2SV_ModStart> siphash_3u32 <S2SV_ModEnd> <S2SV_ModStart> , & net -> ipv4 . ip_id_key <S2SV_ModEnd> "
1555,"<S2SV_StartBug> if ( exists_not_none ( obj , & PyId_lower ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_lower ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> slice_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_slice ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( dims , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Index"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; lower = NULL ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_upper , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; upper = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & upper , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_step , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; step = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & step , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Slice ( lower , upper , step , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ExtSlice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * dims ; if ( lookup_attr_id ( obj , & PyId_dims , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExtSlice"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Index"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * out = Index ( value , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1556,"<S2SV_StartBug> static void write_intra_mode ( vp9_writer * w , MB_PREDICTION_MODE mode , <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * probs ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> 
1557,<S2SV_StartBug> if ( setpwnam ( ctl -> pw ) < 0 ) { <S2SV_EndBug> ,"<S2SV_ModStart> , "".chfn"" "
1558,<S2SV_StartBug> if ( radiotap_header -> it_version ) <S2SV_EndBug> <S2SV_StartBug> ( unsigned long ) iterator -> _rtheader > <S2SV_EndBug> ,<S2SV_ModStart> max_length < sizeof ( struct ieee80211_radiotap_header ) ) return - EINVAL ; if ( <S2SV_ModStart> + sizeof ( uint32_t ) 
1559,"<S2SV_StartBug> if ( ! nfp_abm_u32_check_knode ( alink -> abm , knode , proto , extack ) ) <S2SV_EndBug> <S2SV_StartBug> goto err_delete ; <S2SV_EndBug> <S2SV_StartBug> goto err_delete ; <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> <S2SV_StartBug> list_add ( & match -> list , & alink -> dscp_map ) ; <S2SV_EndBug> <S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug> ",<S2SV_ModStart> { err = - EOPNOTSUPP ; <S2SV_ModStart> } <S2SV_ModStart> err = - EOPNOTSUPP ; <S2SV_ModStart> { err = <S2SV_ModEnd> <S2SV_ModStart> goto err_delete ; } <S2SV_ModStart> err <S2SV_ModEnd> 
1560,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> dst_state -> speculative = src -> speculative ; 
1561,"<S2SV_StartBug> ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( input <= 0.0 || output <= 0.0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Gamma<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>positive"" ) ; RETURN_FALSE ; } "
1562,<S2SV_StartBug> stream -> config . cfg . g_pass = global -> passes == 2 <S2SV_EndBug> <S2SV_StartBug> if ( pass ) <S2SV_EndBug> <S2SV_StartBug> stream -> cx_time = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> # if CONFIG_FP_MB_STATS if ( stream -> config . fpmb_stats_fn ) { if ( ! stats_open_file ( & stream -> fpmb_stats , stream -> config . fpmb_stats_fn , pass ) ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>mb<S2SV_blank>statistics<S2SV_blank>store"" ) ; } else { if ( ! stats_open_mem ( & stream -> fpmb_stats , pass ) ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>mb<S2SV_blank>statistics<S2SV_blank>store"" ) ; } # endif <S2SV_ModStart> { <S2SV_ModStart> # if CONFIG_FP_MB_STATS stream -> config . cfg . rc_firstpass_mb_stats_in = stats_get ( & stream -> fpmb_stats ) ; # endif } "
1563,<S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> ,<S2SV_ModStart> sas_eh_finish_cmd <S2SV_ModEnd> 
1564,<S2SV_StartBug> else <S2SV_EndBug> ,"<S2SV_ModStart> if ( strcmp ( arg , ""@@"" ) == 0 || strcmp ( arg , ""@@u"" ) == 0 ) g_print ( _ ( ""Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\n"" ) , arg ) ; else "
1565,"<S2SV_StartBug> VP9_COMMON * const cm = & pbi -> common ; <S2SV_EndBug> <S2SV_StartBug> const uint8_t * end = NULL ; <S2SV_EndBug> <S2SV_StartBug> vp9_reader r ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cm -> above_context , 0 , <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cm -> above_seg_context , 0 , <S2SV_EndBug> <S2SV_StartBug> sizeof ( * cm -> above_seg_context ) * aligned_cols ) ; <S2SV_EndBug> <S2SV_StartBug> const int last_tile = tile_row == tile_rows - 1 && <S2SV_EndBug> ","<S2SV_ModStart> ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) <S2SV_ModStart> int mi_row , mi_col ; TileData * tile_data <S2SV_ModEnd> <S2SV_ModStart> if ( cm -> lf . filter_level && ! cm -> skip_loop_filter && pbi -> lf_worker . data1 == NULL ) { CHECK_MEM_ERROR ( cm , pbi -> lf_worker . data1 , vpx_memalign ( 32 , sizeof ( LFWorkerData ) ) ) ; pbi -> lf_worker . hook = ( VPxWorkerHook ) vp9_loop_filter_worker ; if ( pbi -> max_threads > 1 && ! winterface -> reset ( & pbi -> lf_worker ) ) { vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Loop<S2SV_blank>filter<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed"" ) ; } } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; winterface -> sync ( & pbi -> lf_worker ) ; vp9_loop_filter_data_reset ( lf_data , get_frame_new_buffer ( cm ) , cm , pbi -> mb . plane ) ; } <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ; if ( pbi -> tile_data == NULL || ( tile_cols * tile_rows ) != pbi -> total_tiles ) { vpx_free ( pbi -> tile_data ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_data , vpx_memalign ( 32 , tile_cols * tile_rows * ( sizeof ( * pbi -> tile_data ) ) ) ) ; pbi -> total_tiles = tile_rows * tile_cols ; } <S2SV_ModStart> TileBuffer * const buf = & tile_buffers [ tile_row ] [ tile_col ] ; tile_data = pbi -> tile_data + tile_cols * tile_row + tile_col ; tile_data -> cm = cm ; tile_data -> xd = pbi -> mb ; tile_data -> xd . corrupted = 0 ; tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? NULL : & cm -> counts ; vp9_zero ( tile_data -> dqcoeff ) ; vp9_tile_init ( & tile_data -> xd . tile , tile_data -> cm , tile_row , tile_col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader , pbi -> decrypt_cb , pbi -> decrypt_state ) ; vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> dqcoeff ) ; } } for ( tile_row = 0 ; tile_row < tile_rows ; ++ tile_row ) { TileInfo tile ; vp9_tile_set_row ( & tile , cm , tile_row ) ; for ( mi_row = tile . mi_row_start ; mi_row < tile . mi_row_end ; mi_row += MI_BLOCK_SIZE ) { for ( tile_col = 0 ; tile_col < tile_cols ; ++ tile_col ) { const int col = pbi -> inv_tile_order ? tile_cols - tile_col - 1 : tile_col ; tile_data = pbi -> tile_data + tile_cols * tile_row + col ; vp9_tile_set_col ( & tile , tile_data -> cm , col ) ; vp9_zero ( tile_data -> xd . left_context ) ; vp9_zero ( tile_data -> xd . left_seg_context ) ; for ( mi_col = tile . mi_col_start ; mi_col < tile . mi_col_end ; mi_col += MI_BLOCK_SIZE ) { decode_partition ( pbi , & tile_data -> xd , mi_row , mi_col , & tile_data -> bit_reader , BLOCK_64X64 , 4 ) ; } pbi -> mb . corrupted |= tile_data -> xd . corrupted ; if ( pbi -> mb . corrupted ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>tile<S2SV_blank>data"" ) ; } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { const int lf_start = mi_row - MI_BLOCK_SIZE ; LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; if ( lf_start < 0 ) continue ; if ( mi_row + MI_BLOCK_SIZE >= cm -> mi_rows ) continue ; winterface -> sync ( & pbi -> lf_worker ) ; lf_data -> start = lf_start ; lf_data -> stop = mi_row ; if ( pbi -> max_threads > 1 ) { winterface -> launch ( & pbi -> lf_worker ) ; } else { winterface -> execute ( & pbi -> lf_worker ) ; } } if ( pbi -> frame_parallel_decode ) vp9_frameworker_broadcast ( pbi -> cur_buf , mi_row << MI_BLOCK_SIZE_LOG2 ) ; } } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; winterface -> sync ( & pbi -> lf_worker ) ; lf_data -> start = lf_data -> stop ; lf_data -> stop = cm -> mi_rows ; winterface -> execute ( & pbi -> lf_worker ) ; } tile_data = pbi -> tile_data + tile_cols * <S2SV_ModEnd> <S2SV_ModStart> ; if ( pbi -> frame_parallel_decode ) vp9_frameworker_broadcast ( pbi -> cur_buf , INT_MAX ) ; return vpx_reader_find_end ( & tile_data -> bit_reader ) <S2SV_ModEnd> "
1566,"<S2SV_StartBug> VP9Decoder * vp9_decoder_create ( const VP9D_CONFIG * oxcf ) { <S2SV_EndBug> <S2SV_StartBug> VP9Decoder * const pbi = vpx_memalign ( 32 , sizeof ( * pbi ) ) ; <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * const cm = pbi ? & pbi -> common : NULL ; <S2SV_EndBug> <S2SV_StartBug> vp9_initialize_dec ( ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> current_video_frame = 0 ; <S2SV_EndBug> <S2SV_StartBug> pbi -> oxcf = * oxcf ; <S2SV_EndBug> <S2SV_StartBug> pbi -> decoded_key_frame = 0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_init_dequantizer ( cm ) ; <S2SV_EndBug> ","<S2SV_ModStart> BufferPool * const pool <S2SV_ModEnd> <S2SV_ModStart> volatile <S2SV_ModStart> volatile <S2SV_ModStart> CHECK_MEM_ERROR ( cm , cm -> fc , ( FRAME_CONTEXT * ) vpx_calloc ( 1 , sizeof ( * cm -> fc ) ) ) ; CHECK_MEM_ERROR ( cm , cm -> frame_contexts , ( FRAME_CONTEXT * ) vpx_calloc ( FRAME_CONTEXTS , sizeof ( * cm -> frame_contexts ) ) ) ; pbi -> need_resync = 1 ; once ( initialize_dec ) ; memset <S2SV_ModEnd> <S2SV_ModStart> memset ( & cm -> next_ref_frame_map , - 1 , sizeof ( cm -> next_ref_frame_map ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> common . buffer_pool = pool ; cm -> bit_depth = VPX_BITS_8 ; cm -> dequant_bit_depth = VPX_BITS_8 ; cm -> alloc_mi = vp9_dec_alloc_mi ; cm -> free_mi = vp9_dec_free_mi ; cm -> setup_mi = vp9_dec_setup_mi ; vp9_loop_filter_init ( cm ) ; cm -> error . setjmp <S2SV_ModEnd> <S2SV_ModStart> vpx_get_worker_interface ( ) -> init <S2SV_ModEnd> "
1567,"<S2SV_StartBug> GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\n"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ; <S2SV_EndBug> ","<S2SV_ModStart> GF_Box * dref ; <S2SV_ModStart> ) ; dref = gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF <S2SV_ModStart> dref ; gf_isom_box_add_for_dump_mode ( s , dref <S2SV_ModEnd> "
1568,"<S2SV_StartBug> client -> priv -> protocol_timeout = g_timeout_add_seconds ( 5 , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1569,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> new_fpl -> user = get_uid ( fpl -> user ) ; 
1570,<S2SV_StartBug> struct ip_options * opt ; <S2SV_EndBug> <S2SV_StartBug> if ( opt == NULL || opt -> cipso == 0 ) <S2SV_EndBug> ,<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> opt . 
1571,"<S2SV_StartBug> static void tree2tok ( struct vp9_token * tokens , const vp9_tree_index * tree , <S2SV_EndBug> <S2SV_StartBug> const vp9_tree_index j = tree [ i ++ ] ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_tree_index <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_index <S2SV_ModEnd> 
1572,"<S2SV_StartBug> if ( img ) <S2SV_EndBug> <S2SV_StartBug> res = validate_img ( ctx , img ) ; <S2SV_EndBug> <S2SV_StartBug> if ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF | <S2SV_EndBug> <S2SV_StartBug> if ( res == VPX_CODEC_OK && ctx -> cpi != NULL ) { <S2SV_EndBug> <S2SV_StartBug> unsigned int lib_flags ; <S2SV_EndBug> <S2SV_StartBug> int64_t dst_time_stamp , dst_end_time_stamp ; <S2SV_EndBug> <S2SV_StartBug> ( ( VP9_COMP * ) ctx -> cpi ) -> b_calculate_psnr = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_receive_raw_frame ( ctx -> cpi , lib_flags , <S2SV_EndBug> <S2SV_StartBug> VP9_COMP * cpi = ( VP9_COMP * ) ctx -> cpi ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> cx_data_sz = ctx -> cx_data_sz ; <S2SV_EndBug> <S2SV_StartBug> - 1 != vp9_get_compressed_data ( ctx -> cpi , & lib_flags , & size , <S2SV_EndBug> <S2SV_StartBug> vpx_codec_pts_t round , delta ; <S2SV_EndBug> <S2SV_StartBug> VP9_COMP * const cpi = ( VP9_COMP * ) ctx -> cpi ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> common . show_frame == 0 ) { <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> pkt . kind = VPX_CODEC_CX_FRAME_PKT ; <S2SV_EndBug> <S2SV_StartBug> ( dst_time_stamp * ctx -> cfg . g_timebase . den + round ) <S2SV_EndBug> <S2SV_StartBug> ( ( delta * ctx -> cfg . g_timebase . den + round ) <S2SV_EndBug> <S2SV_StartBug> pkt . data . frame . flags = lib_flags << 16 ; <S2SV_EndBug> <S2SV_StartBug> size += write_superframe_index ( ctx ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> VP9_COMP * const cpi = ctx -> cpi ; const vpx_rational_t * const timebase = & ctx -> cfg . g_timebase ; size_t data_sz ; <S2SV_ModStart> != NULL ) { <S2SV_ModEnd> <S2SV_ModStart> if ( res == VPX_CODEC_OK && cpi != NULL ) { data_sz = ctx -> cfg . g_w * ctx -> cfg . g_h * get_image_bps ( img ) / 8 * ( cpi -> multi_arf_allowed ? 8 : 2 ) ; if ( data_sz < 4096 ) data_sz = 4096 ; if ( ctx -> cx_data == NULL || ctx -> cx_data_sz < data_sz ) { ctx -> cx_data_sz = data_sz ; free ( ctx -> cx_data ) ; ctx -> cx_data = ( unsigned char * ) malloc ( ctx -> cx_data_sz ) ; if ( ctx -> cx_data == NULL ) { return VPX_CODEC_MEM_ERROR ; } } } } <S2SV_ModStart> vp9_apply_encoding_flags ( cpi , flags ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = 0 <S2SV_ModStart> = timebase_units_to_ticks ( timebase , pts ) ; int64_t dst_end_time_stamp = timebase_units_to_ticks ( timebase , pts + duration ) <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cpi , flags | ctx -> next_frame_flags <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ctx -> next_frame_flags = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_SPATIAL_SVC if ( cpi -> use_svc ) cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers ] . layer_size += size ; # endif if ( ! <S2SV_ModEnd> <S2SV_ModStart> || ( cpi -> use_svc && cpi -> svc . spatial_layer_id < cpi -> svc . number_spatial_layers - 1 ) <S2SV_ModEnd> <S2SV_ModStart> if ( ctx -> output_cx_pkt_cb . output_cx_pkt ) { pkt . kind = VPX_CODEC_CX_FRAME_PKT ; pkt . data . frame . pts = ticks_to_timebase_units ( timebase , dst_time_stamp ) ; pkt . data . frame . duration = ( unsigned long ) ticks_to_timebase_units ( timebase , <S2SV_ModEnd> <S2SV_ModStart> data . frame . flags = get_frame_pkt_flags ( cpi , lib_flags ) ; pkt . data . frame . buf = ctx -> pending_cx_data ; pkt . data . frame . sz = size ; ctx -> pending_cx_data = NULL ; ctx -> pending_cx_data_sz = 0 ; ctx -> pending_frame_count = 0 ; ctx -> pending_frame_magnitude = 0 ; ctx -> output_cx_pkt_cb . output_cx_pkt ( & pkt , ctx -> output_cx_pkt_cb . user_priv ) ; } continue ; } pkt . <S2SV_ModStart> ticks_to_timebase_units ( timebase , dst_time_stamp ) <S2SV_ModEnd> <S2SV_ModStart> ticks_to_timebase_units ( timebase , dst_end_time_stamp - dst_time_stamp <S2SV_ModEnd> <S2SV_ModStart> get_frame_pkt_flags ( cpi , lib_flags ) <S2SV_ModEnd> <S2SV_ModStart> if ( ! ctx -> output_cx_pkt_cb . output_cx_pkt ) <S2SV_ModStart> if ( ctx -> output_cx_pkt_cb . output_cx_pkt ) ctx -> output_cx_pkt_cb . output_cx_pkt ( & pkt , ctx -> output_cx_pkt_cb . user_priv ) ; else <S2SV_ModStart> # if VPX_ENCODER_ABI_VERSION > ( 5 + VPX_CODEC_ABI_VERSION ) # if CONFIG_SPATIAL_SVC if ( cpi -> use_svc && ! ctx -> output_cx_pkt_cb . output_cx_pkt ) { vpx_codec_cx_pkt_t pkt_sizes , pkt_psnr ; int sl ; vp9_zero ( pkt_sizes ) ; vp9_zero ( pkt_psnr ) ; pkt_sizes . kind = VPX_CODEC_SPATIAL_SVC_LAYER_SIZES ; pkt_psnr . kind = VPX_CODEC_SPATIAL_SVC_LAYER_PSNR ; for ( sl = 0 ; sl < cpi -> svc . number_spatial_layers ; ++ sl ) { LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ sl * cpi -> svc . number_temporal_layers ] ; pkt_sizes . data . layer_sizes [ sl ] = lc -> layer_size ; pkt_psnr . data . layer_psnr [ sl ] = lc -> psnr_pkt ; lc -> layer_size = 0 ; } vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt_sizes ) ; vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt_psnr ) ; } # endif # endif if ( is_one_pass_cbr_svc ( cpi ) && ( cpi -> svc . spatial_layer_id == cpi -> svc . number_spatial_layers - 1 ) ) { break ; } "
1573,<S2SV_StartBug> ctx -> clockid = clockid ; <S2SV_EndBug> ,<S2SV_ModStart> spin_lock_init ( & ctx -> cancel_lock ) ; 
1574,"<S2SV_StartBug> struct mount * child , * p ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_MNT_SHARED ( dest_mnt ) ) { <S2SV_EndBug> <S2SV_StartBug> err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ; <S2SV_EndBug> <S2SV_StartBug> umount_tree ( child , UMOUNT_SYNC ) ; <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> ","<S2SV_ModStart> mnt_namespace * ns = dest_mnt -> mnt_ns ; struct <S2SV_ModStart> ! parent_path ) { err = count_mounts ( ns , source_mnt <S2SV_ModEnd> <S2SV_ModStart> } if ( IS_MNT_SHARED ( dest_mnt ) ) { err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; <S2SV_ModStart> child -> mnt_parent -> mnt_ns -> pending_mounts = 0 ; <S2SV_ModStart> ns -> pending_mounts = 0 ; "
1575,"<S2SV_StartBug> ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len ) ; <S2SV_EndBug> ","<S2SV_ModStart> , 0 "
1576,<S2SV_StartBug> void fadst16_8col ( __m128i * in ) { <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_m16_m16 = _mm_set1_epi16 ( - cospi_16_64 ) ; <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug> ,<S2SV_ModStart> static <S2SV_ModStart> ( int16_t ) <S2SV_ModStart> ( int16_t ) 
1577,"<S2SV_StartBug> static int frame_max_bits ( const RATE_CONTROL * rc , const VP9_CONFIG * oxcf ) { <S2SV_EndBug> <S2SV_StartBug> int64_t max_bits = ( ( int64_t ) rc -> av_per_frame_bandwidth * <S2SV_EndBug> ",<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> 
1578,<S2SV_StartBug> uchar magicbuf [ MIF_MAGICLEN ] ; <S2SV_EndBug> ,<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
1579,"<S2SV_StartBug> void Huff_transmit ( huff_t * huff , int ch , byte * fout ) { <S2SV_EndBug> <S2SV_StartBug> Huff_transmit ( huff , NYT , fout ) ; <S2SV_EndBug> <S2SV_StartBug> send ( huff -> loc [ ch ] , NULL , fout ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int maxoffset <S2SV_ModStart> , maxoffset <S2SV_ModStart> , maxoffset "
1580,"<S2SV_StartBug> static void encode_superblock ( VP9_COMP * cpi , TOKENEXTRA * * t , int output_enabled , <S2SV_EndBug> <S2SV_StartBug> int mi_row , int mi_col , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> x -> skip_recode = ! x -> select_txfm_size && mbmi -> sb_type >= BLOCK_8X8 && <S2SV_EndBug> <S2SV_StartBug> x -> skip_optimize = ctx -> is_coded ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_type == KEY_FRAME ) { <S2SV_EndBug> <S2SV_StartBug> set_ref_ptrs ( cm , xd , mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_setup_pre_planes ( xd , ref , cfg , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> skip ) { <S2SV_EndBug> <S2SV_StartBug> vp9_tokenize_sb ( cpi , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> ++ get_tx_counts ( max_txsize_lookup [ bsize ] , vp9_get_tx_size_context ( xd ) , <S2SV_EndBug> <S2SV_StartBug> & cm -> counts . tx ) [ mbmi -> tx_size ] ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , <S2SV_ModStart> , PICK_MODE_CONTEXT * ctx <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> const int seg_skip = segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) <S2SV_ModEnd> <S2SV_ModStart> select_tx_size <S2SV_ModEnd> <S2SV_ModStart> if ( ! x -> skip_recode && ! cpi -> sf . use_nonrd_pick_mode ) memset ( x -> skip_txfm , 0 , sizeof ( x -> skip_txfm ) ) ; <S2SV_ModStart> ! is_inter_block ( mbmi ) ) { int plane ; mbmi -> skip = 1 ; for ( plane = 0 ; plane < MAX_MB_PLANE ; ++ plane ) vp9_encode_intra_block_plane ( x , MAX ( bsize , BLOCK_8X8 ) , plane ) ; if ( output_enabled ) sum_intra_stats ( td -> counts , mi ) ; vp9_tokenize_sb ( cpi , td , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ; <S2SV_ModEnd> <S2SV_ModStart> int ref ; const int is_compound = has_second_ref ( mbmi ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> assert ( cfg != NULL ) ; <S2SV_ModStart> if ( ! ( cpi -> sf . reuse_inter_pred_sby && ctx -> pred_pixel_ready ) || seg_skip ) vp9_build_inter_predictors_sby <S2SV_ModEnd> <S2SV_ModStart> vp9_build_inter_predictors_sbuv ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) <S2SV_ModEnd> <S2SV_ModStart> , td <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> seg_skip <S2SV_ModEnd> <S2SV_ModStart> get_tx_size_context <S2SV_ModEnd> <S2SV_ModStart> td -> counts -> <S2SV_ModEnd> <S2SV_ModStart> ++ td -> counts -> tx . tx_totals [ mbmi -> tx_size ] ; ++ td -> counts -> tx . tx_totals [ get_uv_tx_size ( mbmi , & xd -> plane [ 1 ] ) ] ; "
1581,<S2SV_StartBug> if ( iad_num == USB_MAXIADS ) { <S2SV_EndBug> <S2SV_StartBug> ( struct usb_interface_assoc_descriptor <S2SV_EndBug> ,"<S2SV_ModStart> struct usb_interface_assoc_descriptor * d ; d = ( struct usb_interface_assoc_descriptor * ) header ; if ( d -> bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE ) { dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>interface<S2SV_blank>association<S2SV_blank>descriptor<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>skipping\\n"" , cfgno , d -> bLength ) ; continue ; } <S2SV_ModStart> d <S2SV_ModEnd> "
1582,"<S2SV_StartBug> int rc ; <S2SV_EndBug> <S2SV_StartBug> struct crypto_skcipher * tfm_des ; <S2SV_EndBug> <S2SV_StartBug> tfm_des = crypto_alloc_skcipher ( ""ecb(des)"" , 0 , CRYPTO_ALG_ASYNC ) ; <S2SV_EndBug> <S2SV_StartBug> rc = PTR_ERR ( tfm_des ) ; <S2SV_EndBug> <S2SV_StartBug> goto smbhash_err ; <S2SV_EndBug> <S2SV_StartBug> sg_init_one ( & sgin , in , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> smbhash_err : <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> crypto_cipher * tfm_des <S2SV_ModEnd> <S2SV_ModStart> crypto_alloc_cipher ( ""des"" <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return PTR_ERR ( tfm_des ) ; } crypto_cipher_setkey <S2SV_ModEnd> <S2SV_ModStart> crypto_cipher_encrypt_one ( tfm_des , out , in ) ; crypto_free_cipher <S2SV_ModEnd> <S2SV_ModStart> return 0 <S2SV_ModEnd> "
1583,<S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 4 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = ( x >> 24 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> . ptr [ <S2SV_ModEnd> <S2SV_ModStart> . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1584,"<S2SV_StartBug> uint32_t value ; <S2SV_EndBug> <S2SV_StartBug> int position , zeroes , i , j ; <S2SV_EndBug> <S2SV_StartBug> zeroes = i = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( get_bits_left ( gbc ) < zeroes + 1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( get_bits1 ( gbc ) ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> bits [ i ++ ] = ( value >> ( zeroes - j - 1 ) & 1 ) ? '1' : '0' ; <S2SV_EndBug> <S2SV_StartBug> value += ( 1 << zeroes ) - 1 ; <S2SV_EndBug> ","<S2SV_ModStart> zeroes , bits_value , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> break ; ++ zeroes ; } if ( zeroes >= 32 ) { value = MAX_UINT_BITS ( 32 ) ; } else { if ( get_bits_left ( gbc ) < zeroes ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>uvlc<S2SV_blank>code<S2SV_blank>at<S2SV_blank>"" ""%s:<S2SV_blank>bitstream<S2SV_blank>ended.\\n"" , name ) ; return AVERROR_INVALIDDATA ; } bits_value = get_bits_long ( gbc , zeroes ) ; value = bits_value + ( UINT32_C ( 1 ) << zeroes ) - 1 ; } if ( ctx -> trace_enable ) { char bits [ 65 ] ; int i , j , k ; if ( zeroes >= 32 ) { while ( zeroes > 32 ) { k = FFMIN ( zeroes - 32 , 32 ) ; for ( i = 0 ; i < k ; i ++ ) bits [ i ] = '0' ; bits [ i ] = 0 ; ff_cbs_trace_syntax_element ( ctx , position , name , NULL , bits , 0 ) ; zeroes -= k ; position += k ; } } for ( i = 0 ; i < zeroes ; i ++ ) bits [ i ] = '0' ; <S2SV_ModEnd> <S2SV_ModStart> if ( zeroes < 32 ) { <S2SV_ModEnd> <S2SV_ModStart> bits_value <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModEnd> "
1585,<S2SV_StartBug> else if ( i > pos && i + insn -> off + 1 < pos ) <S2SV_EndBug> ,<S2SV_ModStart> + delta <S2SV_ModStart> <= pos + delta <S2SV_ModEnd> 
1586,<S2SV_StartBug> case EXIT_REASON_INVEPT : <S2SV_EndBug> ,<S2SV_ModStart> case EXIT_REASON_INVVPID : 
1587,"<S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> 
1588,"<S2SV_StartBug> packet -> http_contentlen . ptr = NULL , packet -> http_contentlen . len = 0 , packet -> http_cookie . ptr = NULL , <S2SV_EndBug> ","<S2SV_ModStart> content_disposition_line . ptr = NULL , packet -> content_disposition_line . len = 0 , packet -> "
1589,<S2SV_StartBug> nd -> last_type = LAST_BIND ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1590,"<S2SV_StartBug> assert ( pow ( ( float ) r + 1 , dim ) > entries ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ( int ) floor ( pow ( ( float ) r , dim ) ) <= entries ) ; <S2SV_EndBug> ",<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> <= entries ) return - 1 ; if <S2SV_ModEnd> <S2SV_ModStart> > entries ) return - 1 <S2SV_ModEnd> 
1591,"<S2SV_StartBug> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , <S2SV_EndBug> <S2SV_StartBug> Min ( 4 , dds_info -> height - y ) , exception ) ; <S2SV_EndBug> <S2SV_StartBug> SkipDXTMipmaps ( image , dds_info , 8 ) ; <S2SV_EndBug> ","<S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> return ( <S2SV_ModStart> , exception ) ) <S2SV_ModEnd> "
1592,<S2SV_StartBug> if ( iph -> ihl == 5 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1593,<S2SV_StartBug> if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) { <S2SV_EndBug> ,<S2SV_ModStart> && Z_TYPE_PP ( ptr ) == IS_ARRAY 
1594,"<S2SV_StartBug> int ret = recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ; <S2SV_EndBug> <S2SV_StartBug> ret = recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1595,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> char * outpos = outputbuffer ; <S2SV_ModStart> sendClean ( outputbuffer ) ; 
1596,"<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> struct stat st ; <S2SV_EndBug> <S2SV_StartBug> if ( lstat ( filename , & st ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> file = fopen ( filename , ""a"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> struct stat st ; FILE * file = NULL ; int fd = - 1 ; <S2SV_ModStart> fd = open ( filename , O_WRONLY | O_APPEND | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY ) ; if ( fd >= 0 && ( fstat ( fd <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> fdopen ( fd <S2SV_ModEnd> <S2SV_ModStart> cfg -> is_custom_debug_file = 1 ; file = NULL ; fd = - 1 ; <S2SV_ModEnd> <S2SV_ModStart> if ( fd != - 1 ) close ( fd ) ; if ( file != NULL ) fclose ( file ) ; "
1597,"<S2SV_StartBug> if ( test_opt ( sbi , FLUSH_MERGE ) && ! f2fs_readonly ( sbi -> sb ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1598,<S2SV_StartBug> if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && <S2SV_EndBug> <S2SV_StartBug> ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) <S2SV_EndBug> <S2SV_StartBug> length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( ( number_pixels * <S2SV_ModEnd> <S2SV_ModStart> ) > ( 8 * <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> bytes_per_line <S2SV_ModEnd> 
1599,<S2SV_StartBug> outpos += <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sendClean ( outputbuffer ) ; 
1600,"<S2SV_StartBug> WLog_VRB ( AUTODETECT_TAG , ""received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( Stream_GetRemainingLength ( s ) < 8 ) return - 1 
1601,<S2SV_StartBug> _ipmi_destroy_user ( user ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1602,"<S2SV_StartBug> if ( ( cpi -> current_layer == 0 ) && <S2SV_EndBug> <S2SV_StartBug> else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) ) <S2SV_EndBug> <S2SV_StartBug> pack_tokens ( w , tp_start , tok_count ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { if <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> { if ( cpi -> consec_zero_last [ map_index + mb_col ] < 255 ) cpi -> consec_zero_last [ map_index + mb_col ] += 1 ; if ( cpi -> consec_zero_last_mvbias [ map_index + mb_col ] < 255 ) cpi -> consec_zero_last_mvbias [ map_index + mb_col ] += 1 ; } else { cpi -> consec_zero_last [ map_index + mb_col ] = 0 ; cpi -> consec_zero_last_mvbias [ map_index + mb_col ] = 0 ; } if ( x -> zero_last_dot_suppress ) cpi -> consec_zero_last_mvbias [ map_index + mb_col ] = 0 ; } if ( ( cpi -> current_layer == 0 ) && ( cpi -> cyclic_refresh_mode_enabled && xd -> segmentation_enabled ) ) { cpi -> segmentation_map [ map_index + mb_col ] = xd -> mode_info_context -> mbmi . segment_id ; if ( xd -> mode_info_context -> mbmi . segment_id ) cpi -> cyclic_refresh_map [ map_index + mb_col ] = - 1 ; else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) <S2SV_ModStart> vp8_pack_tokens <S2SV_ModEnd> 
1603,<S2SV_StartBug> if ( type == ARPHRD_ETHER ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; } 
1604,"<S2SV_StartBug> in_uint16_le ( s , type ) ; <S2SV_EndBug> <S2SV_StartBug> if ( status == CLIPRDR_ERROR ) <S2SV_EndBug> ","<S2SV_ModStart> struct stream packet = * s ; <S2SV_ModStart> ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cliprdr_process(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } if ( "
1605,<S2SV_StartBug> if ( pbi -> b_multithreaded_rd ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1606,<S2SV_StartBug> if ( rows > 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> l == NULL ) break ; if ( 
1607,<S2SV_StartBug> if ( xWantedSize > 0 ) <S2SV_EndBug> <S2SV_StartBug> xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> && ( ( xWantedSize + xHeapStructSize ) > xWantedSize ) ) <S2SV_ModStart> if ( ( xWantedSize + <S2SV_ModEnd> <S2SV_ModStart> ) > xWantedSize ) { xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ; } else { xWantedSize = 0 ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { xWantedSize = 0 <S2SV_ModEnd> 
1608,"<S2SV_StartBug> void vp9_iht8x8_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> 
1609,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1610,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % ( bps * stride ) ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""fpDiff"" , ""%s"" , ""(cc%(bps*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModStart> return 1 ; "
1611,"<S2SV_StartBug> uint16 num_updates ; <S2SV_EndBug> <S2SV_StartBug> logger ( Protocol , Debug , ""%s()"" , __func__ ) ; <S2SV_EndBug> <S2SV_StartBug> in_uint16_le ( s , left ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> uint16 num_updates <S2SV_ModEnd> <S2SV_ModStart> process_bitmap_data ( s <S2SV_ModEnd> 
1612,<S2SV_StartBug> if ( error ) <S2SV_EndBug> <S2SV_StartBug> if ( context -> seen_enough ) <S2SV_EndBug> ,<S2SV_ModStart> { kmem_free ( sbuf ) ; <S2SV_ModStart> } 
1613,"<S2SV_StartBug> ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> u_int name_entries = EXTRACT_16BITS ( msg_data + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> u_int addr_size = 4 ; <S2SV_EndBug> <S2SV_StartBug> int name_entries_valid = 0 ; <S2SV_EndBug> <S2SV_StartBug> name_entries_valid = 1 ; <S2SV_EndBug> ","<S2SV_ModStart> if ( is_ipv6 ) { <S2SV_ModStart> olsr_msg6 ) ) ; <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_ModStart> ; u_int addr_size ; int name_entries_valid ; u_int i ; if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entries <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( is_ipv6 ) addr_size = 16 ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1614,"<S2SV_StartBug> uint16 bitspersample , samplesperpixel ; <S2SV_EndBug> <S2SV_StartBug> uint16 input_compression , input_photometric ; <S2SV_EndBug> ",<S2SV_ModStart> = 1 <S2SV_ModStart> = PHOTOMETRIC_MINISBLACK 
1615,"<S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ",<S2SV_ModStart> ssplit <S2SV_ModEnd> 
1616,<S2SV_StartBug> vp9_coeff_stats * coef_branch_ct ) { <S2SV_EndBug> <S2SV_StartBug> vp9_coeff_probs_model * coef_probs = cpi -> frame_coef_probs [ tx_size ] ; <S2SV_EndBug> ,"<S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ) { vp9_coeff_count * coef_counts <S2SV_ModStart> td . rd_counts . <S2SV_ModEnd> "
1617,<S2SV_StartBug> assert ( name ) ; <S2SV_EndBug> ,"<S2SV_ModStart> name ) ; r = vt_verify_kbmode ( fd ) ; if ( r == - EBUSY ) { log_warning_errno ( r , ""Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>K_XLATE<S2SV_blank>or<S2SV_blank>K_UNICODE:<S2SV_blank>%m"" , name ) ; return 0 ; } else if ( r < 0 ) return log_warning_errno ( r , ""Failed<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>kbdmode<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m"" , "
1618,"<S2SV_StartBug> static int su3000_frontend_attach ( struct dvb_usb_adapter * d ) <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x02 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> msleep ( 300 ) ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_EndBug> <S2SV_StartBug> d -> fe_adap [ 0 ] . fe = dvb_attach ( ds3000_attach , & su3000_ds3000_config , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ; <S2SV_EndBug> <S2SV_StartBug> if ( d -> fe_adap [ 0 ] . fe == NULL ) <S2SV_EndBug> <S2SV_StartBug> if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ) { <S2SV_EndBug> ","<S2SV_ModStart> adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x02 ; state -> data [ 2 ] = 1 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> msleep ( 300 ) ; state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data [ 1 ] = 0x83 ; state -> data <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data [ 0 ] = 0x51 <S2SV_ModEnd> <S2SV_ModStart> , state -> data , 1 , state -> data <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1619,<S2SV_StartBug> sock_release ( SOCKET_I ( inode ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> __sock_release <S2SV_ModEnd> <S2SV_ModStart> , inode "
1620,"<S2SV_StartBug> vpx_codec_enc_cfg_t * cfg , <S2SV_EndBug> <S2SV_StartBug> else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> priv ) <S2SV_EndBug> ",<S2SV_ModStart> const <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1621,"<S2SV_StartBug> int uv_block_size , <S2SV_EndBug> <S2SV_StartBug> vp9_get_interp_kernel ( xd -> mi [ 0 ] -> mbmi . interp_filter ) ; <S2SV_EndBug> <S2SV_StartBug> if ( uv_block_size == 8 ) { <S2SV_EndBug> <S2SV_StartBug> vp9_build_inter_predictor ( y_mb_ptr , stride , <S2SV_EndBug> <S2SV_StartBug> & pred [ 256 ] , uv_block_size , <S2SV_EndBug> <S2SV_StartBug> & pred [ 512 ] , uv_block_size , <S2SV_EndBug> ","<S2SV_ModStart> uv_block_width , int uv_block_height <S2SV_ModEnd> <S2SV_ModStart> vp9_filter_kernels [ <S2SV_ModEnd> <S2SV_ModStart> ] <S2SV_ModEnd> <S2SV_ModStart> uv_block_width <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_highbd_build_inter_predictor ( y_mb_ptr , stride , & pred [ 0 ] , 16 , & mv , scale , 16 , 16 , which_mv , kernel , MV_PRECISION_Q3 , x , y , xd -> bd ) ; vp9_highbd_build_inter_predictor ( u_mb_ptr , uv_stride , & pred [ 256 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height , which_mv , kernel , mv_precision_uv , x , y , xd -> bd ) ; vp9_highbd_build_inter_predictor ( v_mb_ptr , uv_stride , & pred [ 512 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height , which_mv , kernel , mv_precision_uv , x , y , xd -> bd ) ; return ; } # endif <S2SV_ModStart> uv_block_width , & mv , scale , uv_block_width , uv_block_height <S2SV_ModEnd> <S2SV_ModStart> uv_block_width , & mv , scale , uv_block_width , uv_block_height <S2SV_ModEnd> "
1622,"<S2SV_StartBug> mungspaces ( strcpy ( buf , origbuf ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> while ( * origbuf == '<S2SV_blank>' || * origbuf == '\\t' ) ++ origbuf ; ( void ) strncpy ( buf , origbuf , sizeof buf - 1 ) ; buf [ sizeof buf - 1 ] = '\\0' ; mungspaces ( buf <S2SV_ModEnd> "
1623,"<S2SV_StartBug> cJSON * cJSON_CreateFloatArray ( double * numbers , int count ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; a && i < count ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> n = cJSON_CreateFloat ( numbers [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! i ) <S2SV_EndBug> ",<S2SV_ModStart> const float <S2SV_ModEnd> <S2SV_ModStart> i ++ <S2SV_ModEnd> <S2SV_ModStart> cJSON_CreateNumber <S2SV_ModEnd> <S2SV_ModStart> if ( ! n ) { cJSON_Delete ( a ) ; return 0 ; } 
1624,<S2SV_StartBug> goto retry_rebind ; <S2SV_EndBug> ,<S2SV_ModStart> switch ( task -> tk_status ) { case - EACCES : case - EIO : goto die ; default : <S2SV_ModStart> } 
1625,"<S2SV_StartBug> unsigned int link_count ; <S2SV_EndBug> <S2SV_StartBug> struct buffer_head * nbh = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ie -> indirectICB . extLength && <S2SV_EndBug> <S2SV_StartBug> ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 , <S2SV_EndBug> <S2SV_StartBug> brelse ( nbh ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned int indirections = 0 ; reread : <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) { brelse ( bh ) ; brelse ( ibh ) ; memcpy ( & iinfo -> i_location <S2SV_ModEnd> <S2SV_ModStart> sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > UDF_MAX_ICB_NESTING ) { udf_err ( inode -> i_sb , ""too<S2SV_blank>many<S2SV_blank>ICBs<S2SV_blank>in<S2SV_blank>ICB<S2SV_blank>hierarchy"" ""<S2SV_blank>(max<S2SV_blank>%d<S2SV_blank>supported)\\n"" , UDF_MAX_ICB_NESTING ) ; make_bad_inode <S2SV_ModEnd> <S2SV_ModStart> goto reread <S2SV_ModEnd> "
1626,"<S2SV_StartBug> float * w = get_window ( f , n ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( w == NULL ) return 0 
1627,"<S2SV_StartBug> uint32 num_properties = GETINT32 ( buf + idx ) ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < ( a -> names [ i ] . len >> 1 ) ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( a -> type == szMAPI_UNICODE_STRING ) <S2SV_EndBug> <S2SV_StartBug> v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; assert ( ( num_properties + 1 ) != 0 <S2SV_ModStart> assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ; <S2SV_ModStart> assert ( v -> len + idx <= len ) ; <S2SV_ModStart> assert ( v -> len != 0 ) ; 
1628,"<S2SV_StartBug> VP9_COMMON * const cm = & pbi -> common ; <S2SV_EndBug> <S2SV_StartBug> const int num_workers = MIN ( pbi -> oxcf . max_threads & ~ 1 , tile_cols ) ; <S2SV_EndBug> <S2SV_StartBug> TileBuffer tile_buffers [ 1 << 6 ] ; <S2SV_EndBug> <S2SV_StartBug> const int num_threads = pbi -> oxcf . max_threads & ~ 1 ; <S2SV_EndBug> <S2SV_StartBug> vpx_malloc ( num_threads * sizeof ( * pbi -> tile_workers ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> VP9Worker * const worker = & pbi -> tile_workers [ i ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_worker_init ( worker ) ; <S2SV_EndBug> <S2SV_StartBug> if ( i < num_threads - 1 && ! vp9_worker_reset ( worker ) ) { <S2SV_EndBug> <S2SV_StartBug> pbi -> tile_workers [ n ] . hook = ( VP9WorkerHook ) tile_worker_hook ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cm -> above_seg_context , 0 , <S2SV_EndBug> <S2SV_StartBug> for ( n = 0 ; n < tile_cols ; ++ n ) { <S2SV_EndBug> <S2SV_StartBug> get_tile ( data_end , n == tile_cols - 1 , & cm -> error , & data ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_worker_launch ( worker ) ; <S2SV_EndBug> <S2SV_StartBug> VP9Worker * const worker = & pbi -> tile_workers [ i - 1 ] ; <S2SV_EndBug> <S2SV_StartBug> pbi -> mb . corrupted |= ! vp9_worker_sync ( worker ) ; <S2SV_EndBug> <S2SV_StartBug> bit_reader_end = vp9_reader_find_end ( & tile_data -> bit_reader ) ; <S2SV_EndBug> <S2SV_StartBug> final_worker = - 1 ; <S2SV_EndBug> ","<S2SV_ModStart> ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ] [ 1 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ) ) ; assert ( ( sizeof ( * pbi -> tile_worker_data ) % 16 ) == 0 ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_worker_data , vpx_memalign ( 32 , num_threads * sizeof ( * pbi -> tile_worker_data ) ) ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_worker_info , vpx_malloc ( num_threads * sizeof ( * pbi -> tile_worker_info <S2SV_ModStart> VPxWorker <S2SV_ModEnd> <S2SV_ModStart> winterface -> init ( worker <S2SV_ModEnd> <S2SV_ModStart> winterface -> reset <S2SV_ModEnd> <S2SV_ModStart> VPxWorker * const worker = & <S2SV_ModStart> ; winterface -> sync ( worker ) ; worker -> <S2SV_ModEnd> <S2SV_ModStart> VPxWorkerHook <S2SV_ModEnd> <S2SV_ModStart> worker -> data1 = & pbi -> tile_worker_data [ n ] ; worker -> data2 = & pbi -> tile_worker_info [ n ] ; } memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ; qsort ( tile_buffers [ 0 ] , tile_cols , sizeof ( tile_buffers [ 0 ] [ 0 ] ) , compare_tile_buffers ) ; { int group_start = 0 ; while ( group_start < tile_cols ) { const TileBuffer largest = tile_buffers [ 0 ] [ group_start ] ; const int group_end = MIN ( group_start + num_workers , tile_cols ) - 1 ; memmove ( tile_buffers [ 0 ] + group_start , tile_buffers [ 0 ] + group_start + 1 , ( group_end - group_start ) * sizeof ( tile_buffers [ 0 ] [ 0 ] ) ) ; tile_buffers [ 0 ] [ group_end ] = largest ; group_start = group_end + 1 ; } } if ( ! cm -> frame_parallel_decoding_mode ) { int i ; for ( i = 0 ; i < num_workers ; ++ i ) { TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ; vp9_zero ( tile_data -> counts ) ; } } n = 0 ; while ( n < tile_cols ) { int i ; for ( i = 0 ; i < num_workers && n < tile_cols ; ++ i ) { VPxWorker * const worker = & pbi -> tile_workers [ i ] ; TileWorkerData * const tile_data = ( TileWorkerData * ) worker -> data1 ; TileInfo * const tile = ( TileInfo * ) worker -> data2 ; TileBuffer * const buf = & tile_buffers [ 0 ] [ n ] ; tile_data -> pbi = pbi ; tile_data -> xd = pbi -> mb ; tile_data -> xd . corrupted = 0 ; tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? 0 : & tile_data -> counts ; vp9_zero ( tile_data -> dqcoeff ) ; vp9_tile_init ( tile , cm , 0 , buf -> col ) ; vp9_tile_init ( & tile_data -> xd . tile , cm , 0 , buf -> col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader , pbi -> decrypt_cb , pbi -> decrypt_state ) ; vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> dqcoeff ) ; worker -> had_error = 0 ; if ( i == num_workers - 1 || <S2SV_ModEnd> <S2SV_ModStart> ) { winterface -> execute <S2SV_ModEnd> <S2SV_ModStart> winterface -> launch <S2SV_ModEnd> <S2SV_ModStart> VPxWorker <S2SV_ModEnd> <S2SV_ModStart> winterface -> sync <S2SV_ModEnd> <S2SV_ModStart> vpx_reader_find_end <S2SV_ModEnd> <S2SV_ModStart> } if ( n >= tile_cols && ! cm -> frame_parallel_decoding_mode ) { for ( i = 0 ; i < num_workers ; ++ i ) { TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ; vp9_accumulate_frame_counts ( cm , & tile_data -> counts , 1 ) ; } "
1629,<S2SV_StartBug> offset = base + get4 ( ) + 8 ; <S2SV_EndBug> <S2SV_StartBug> switch ( tag ) <S2SV_EndBug> ,<S2SV_ModStart> # ifdef LIBRAW_LIBRARY_BUILD if ( offset > ifp -> size ( ) - 8 ) offset = ifp -> size ( ) - 8 ; # endif <S2SV_ModStart> if ( len < 0 ) return ; 
1630,<S2SV_StartBug> err = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> if ( match -> type == type && <S2SV_EndBug> <S2SV_StartBug> out : <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> spin_lock ( & po -> bind_lock ) ; if ( po -> running && <S2SV_ModEnd> <S2SV_ModStart> spin_unlock ( & po -> bind_lock ) ; if ( err && ! refcount_read ( & match -> sk_ref ) ) { list_del ( & match -> list ) ; kfree ( match ) ; } 
1631,"<S2SV_StartBug> struct segmentation * seg = & cm -> seg ; <S2SV_EndBug> <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = ENERGY_MIN ; i <= ENERGY_MAX ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> int qindex_delta , segment_rdmult ; <S2SV_EndBug> <S2SV_StartBug> if ( Q_RATIO ( i ) == 1 ) { <S2SV_EndBug> <S2SV_StartBug> qindex_delta = vp9_compute_qdelta ( & cpi -> rc , base_q , base_q * Q_RATIO ( i ) ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_set_segdata ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q , qindex_delta ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_enable_segfeature ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q ) ; <S2SV_EndBug> <S2SV_StartBug> segment_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + qindex_delta + <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_clear_system_state <S2SV_ModEnd> <S2SV_ModStart> 0 ; i < MAX_SEGMENTS ; ++ i <S2SV_ModEnd> <S2SV_ModStart> = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , cm -> base_qindex , rate_ratio [ i ] , cm -> bit_depth ) <S2SV_ModEnd> <S2SV_ModStart> ( cm -> base_qindex != 0 ) && ( ( cm -> base_qindex + qindex_delta ) == 0 ) ) { qindex_delta = - cm -> base_qindex + 1 ; } if ( rate_ratio [ i ] == 1.0 ) { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> i <S2SV_ModEnd> <S2SV_ModStart> i <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1632,"<S2SV_StartBug> if ( ! net_eq ( net , & init_net ) ) <S2SV_EndBug> ",<S2SV_ModStart> protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if ( 
1633,"<S2SV_StartBug> ( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ; <S2SV_EndBug> ",<S2SV_ModStart> TIFFGetFieldDefaulted <S2SV_ModEnd> 
1634,<S2SV_StartBug> ctx -> base . err_detail = error -> has_detail ? error -> detail : NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> set_error_detail ( ctx , <S2SV_ModEnd> <S2SV_ModStart> ) "
1635,"<S2SV_StartBug> for ( i = j = 0 ; i < sizeof ( buf ) - 1 && str [ i ] ; i ++ , j ++ ) { <S2SV_EndBug> ",<S2SV_ModStart> j <S2SV_ModEnd> 
1636,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1637,"<S2SV_StartBug> b = BCON_NEW ( ""my_dbref"" , <S2SV_EndBug> ","<S2SV_ModStart> VALIDATE_TEST ( ""test59.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; "
1638,<S2SV_StartBug> x86_pmu . extra_regs = intel_snb_extra_regs ; <S2SV_EndBug> <S2SV_StartBug> x86_pmu . pebs_aliases = intel_pebs_aliases_snb ; <S2SV_EndBug> ,<S2SV_ModStart> if ( boot_cpu_data . x86_model == 45 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else <S2SV_ModStart> if ( boot_cpu_data . x86_model == 62 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else 
1639,"<S2SV_StartBug> pocstruct_t * ps_prev_poc , * ps_cur_poc ; <S2SV_EndBug> ","<S2SV_ModStart> ; WORD32 size ; size = sizeof ( pred_info_t ) * 2 * 32 ; memset ( ps_dec -> ps_pred , 0 , size ) ; size = sizeof ( disp_mgr_t ) ; memset ( ps_dec -> pv_disp_buf_mgr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_pic_buf_mgr , 0 , size ) ; size = sizeof ( dec_err_status_t ) ; memset ( ps_dec -> ps_dec_err_status , 0 , size ) ; size = sizeof ( sei ) ; memset ( ps_dec -> ps_sei , 0 , size ) ; size = sizeof ( dpb_commands_t ) ; memset ( ps_dec -> ps_dpb_cmds , 0 , size ) ; size = sizeof ( dec_bit_stream_t ) ; memset ( ps_dec -> ps_bitstrm , 0 , size ) ; size = sizeof ( dec_slice_params_t ) ; memset ( ps_dec -> ps_cur_slice , 0 , size ) ; size = MAX ( sizeof ( dec_seq_params_t ) , sizeof ( dec_pic_params_t ) ) ; memset ( ps_dec -> pv_scratch_sps_pps , 0 , size ) ; size = sizeof ( ctxt_inc_mb_info_t ) ; memset ( ps_dec -> ps_left_mb_ctxt_info , 0 , size ) ; size = ( sizeof ( neighbouradd_t ) << 2 ) ; memset ( ps_dec -> ps_left_mvpred_addr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_mv_buf_mgr , 0 , size ) "
1640,<S2SV_StartBug> if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end && <S2SV_EndBug> <S2SV_StartBug> vma -> vm_userfaultfd_ctx . ctx != ctx ) ; <S2SV_EndBug> ,<S2SV_ModStart> ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ; <S2SV_ModStart> ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) 
1641,<S2SV_StartBug> krb5_key_data * key_data ; <S2SV_EndBug> <S2SV_StartBug> if ( key_data_in == NULL ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i <= num_versions ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( ret [ i ] != NULL ) <S2SV_EndBug> ,<S2SV_ModStart> = NULL ; if ( n_key_data < <S2SV_ModEnd> <S2SV_ModStart> key_data <S2SV_ModEnd> <S2SV_ModStart> ret [ i ] != NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1642,"<S2SV_StartBug> ssize_t ret = read ( fd , btpan_cb . congest_packet , sizeof ( btpan_cb . congest_packet ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( poll ( & ufd , 1 , 0 ) <= 0 || IS_EXCEPTION ( ufd . revents ) ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1643,"<S2SV_StartBug> if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) { <S2SV_EndBug> ",<S2SV_ModStart> dumpable != SUID_DUMP_USER && <S2SV_ModEnd> 
1644,"<S2SV_StartBug> static int su3000_frontend_attach ( struct dvb_usb_adapter * d ) <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x02 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> msleep ( 300 ) ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_EndBug> <S2SV_StartBug> d -> fe_adap [ 0 ] . fe = dvb_attach ( ds3000_attach , & su3000_ds3000_config , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ; <S2SV_EndBug> <S2SV_StartBug> if ( d -> fe_adap [ 0 ] . fe == NULL ) <S2SV_EndBug> <S2SV_StartBug> if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ) { <S2SV_EndBug> ","<S2SV_ModStart> adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x02 ; state -> data [ 2 ] = 1 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> msleep ( 300 ) ; state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data [ 1 ] = 0x83 ; state -> data <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data [ 0 ] = 0x51 <S2SV_ModEnd> <S2SV_ModStart> , state -> data , 1 , state -> data <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1645,"<S2SV_StartBug> static int getnum ( const char * * fmt , int df ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> ","<S2SV_ModStart> lua_State * L , <S2SV_ModStart> if ( a > ( INT_MAX / 10 ) || a * 10 > ( INT_MAX - ( * * fmt - '0' ) ) ) luaL_error ( L , ""integral<S2SV_blank>size<S2SV_blank>overflow"" ) ; "
1646,"<S2SV_StartBug> markold ( g , g -> survival , g -> reallyold ) ; <S2SV_EndBug> ",<S2SV_ModStart> allgc <S2SV_ModEnd> 
1647,<S2SV_StartBug> return - EIO ; <S2SV_EndBug> ,<S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> if ( ! ret ) 
1648,"<S2SV_StartBug> ( void ) opt ; <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( safe_memcmp ( buffer , ssl_request , sizeof ssl_request ) ) { <S2SV_EndBug> <S2SV_StartBug> s_log ( LOG_ERR , ""PostgreSQL<S2SV_blank>client<S2SV_blank>did<S2SV_blank>not<S2SV_blank>request<S2SV_blank>TLS,<S2SV_blank>rejecting"" ) ; <S2SV_EndBug> <S2SV_StartBug> s_write ( c , c -> local_wfd . fd , ssl_ok , sizeof ssl_ok ) ; <S2SV_EndBug> ","<S2SV_ModStart> static const uint8_t gss_request [ 8 ] = { 0 , 0 , 0 , 8 , 0x04 , 0xd2 , 0x16 , 0x30 } ; static const uint8_t gss_response [ 62 ] = { 'E' , 0 , 0 , 0 , 61 , 'S' , 'E' , 'R' , 'R' , 'O' , 'R' , 0 , 'C' , 'X' , 'X' , '0' , '0' , '0' , 0 , 'M' , 'S' , 'S' , 'L' , '<S2SV_blank>' , 'e' , 'x' , 'p' , 'e' , 'c' , 't' , 'e' , 'd' , '<S2SV_blank>' , 'b' , 'u' , 't' , '<S2SV_blank>' , 'n' , 'o' , 't' , '<S2SV_blank>' , 'r' , 'e' , 'q' , 'u' , 'e' , 's' , 't' , 'e' , 'd' , '<S2SV_blank>' , 'b' , 'y' , '<S2SV_blank>' , 'c' , 'l' , 'i' , 'e' , 'n' , 't' , 0 , 0 } ; <S2SV_ModStart> ; s_log ( LOG_DEBUG , ""Started<S2SV_blank>server-side<S2SV_blank>psql<S2SV_blank>protcol<S2SV_blank>negotiation"" ) <S2SV_ModStart> ! <S2SV_ModStart> gss_request , sizeof gss_request <S2SV_ModEnd> <S2SV_ModStart> LOG_INFO , ""GSSAPI<S2SV_blank>encryption<S2SV_blank>requested,<S2SV_blank>rejecting<S2SV_blank>gracefully"" ) ; <S2SV_ModEnd> <S2SV_ModStart> gss_response , sizeof gss_response ) ; throw_exception ( c , 2 ) ; } if ( safe_memcmp ( buffer , ssl_request , sizeof ssl_request ) ) { s_log ( LOG_ERR , ""PostgreSQL<S2SV_blank>client<S2SV_blank>did<S2SV_blank>not<S2SV_blank>request<S2SV_blank>TLS,<S2SV_blank>rejecting"" ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_DEBUG , ""SSLRequest<S2SV_blank>received"" ) ; s_write ( c , c -> local_wfd . fd , "
1649,"<S2SV_StartBug> cib_tls_signon ( cib_t * cib , struct remote_connection_s * connection ) <S2SV_EndBug> <S2SV_StartBug> struct sockaddr_in addr ; <S2SV_EndBug> <S2SV_StartBug> char * server = private -> server ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> . dispatch = cib_remote_dispatch , <S2SV_EndBug> <S2SV_StartBug> . destroy = cib_remote_connection_destroy , <S2SV_EndBug> <S2SV_StartBug> sock = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ; <S2SV_EndBug> <S2SV_StartBug> gnutls_global_init ( ) ; <S2SV_EndBug> <S2SV_StartBug> connection -> session = create_tls_session ( sock , GNUTLS_CLIENT ) ; <S2SV_EndBug> <S2SV_StartBug> close ( sock ) ; <S2SV_EndBug> <S2SV_StartBug> answer = crm_recv_remote_msg ( connection -> session , connection -> encrypted ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc != 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , gboolean event_channel <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int disconnected = 0 <S2SV_ModEnd> <S2SV_ModStart> { 0 , } ; cib_fd_callbacks <S2SV_ModEnd> <S2SV_ModStart> event_channel ? cib_remote_callback_dispatch : cib_remote_command_dispatch ; cib_fd_callbacks <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> crm_remote_tcp_connect ( private -> server , private -> port ) ; if ( sock <= 0 ) { crm_perror ( LOG_ERR , ""remote<S2SV_blank>tcp<S2SV_blank>connection<S2SV_blank>to<S2SV_blank>%s:%d<S2SV_blank>failed"" , private -> server , private -> port ) ; } connection -> socket = sock ; <S2SV_ModEnd> <S2SV_ModStart> if ( remote_gnutls_credentials_init == FALSE ) { <S2SV_ModStart> remote_gnutls_credentials_init = TRUE ; } connection -> session = crm_create_anon_tls_session <S2SV_ModEnd> <S2SV_ModStart> , anon_cred_c ) ; if ( crm_initiate_client_tls_handshake ( connection -> session , DEFAULT_CLIENT_HANDSHAKE_TIMEOUT ) != 0 ) { crm_err ( ""Session<S2SV_blank>creation<S2SV_blank>for<S2SV_blank>%s:%d<S2SV_blank>failed"" , private -> <S2SV_ModEnd> <S2SV_ModStart> gnutls_deinit ( * connection -> session ) ; gnutls_free ( connection -> session ) ; connection -> session = NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> & connection -> recv_buf , <S2SV_ModStart> , - 1 , & disconnected ) ; if ( disconnected ) { rc = - ENOTCONN ; } answer = crm_parse_remote_buffer ( & connection -> recv_buf <S2SV_ModStart> free_xml ( answer ) ; answer = NULL ; <S2SV_ModStart> return rc ; } crm_trace ( ""remote<S2SV_blank>client<S2SV_blank>connection<S2SV_blank>established"" ) <S2SV_ModEnd> "
1650,"<S2SV_StartBug> vpx_memset ( cpi , 0 , sizeof ( VP8_COMP ) ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> kf_overspend_bits = 0 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> cyclic_refresh_mode_enabled = cpi -> oxcf . error_resilient_mode ; <S2SV_EndBug> <S2SV_StartBug> cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 5 ; <S2SV_EndBug> <S2SV_StartBug> # ifdef VP8_ENTROPY_STATS <S2SV_EndBug> <S2SV_StartBug> cpi -> b_calculate_psnr = CONFIG_INTERNAL_STATS ; <S2SV_EndBug> <S2SV_StartBug> # if 0 <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . sdf = vp8_sad16x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . vf = vp8_variance16x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . svf = vp8_sub_pixel_variance16x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_h = vp8_variance_halfpixvar16x16_h ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_v = vp8_variance_halfpixvar16x16_v ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_hv = vp8_variance_halfpixvar16x16_hv ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx3f = vp8_sad16x16x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx8f = vp8_sad16x16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx4df = vp8_sad16x16x4d ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . sdf = vp8_sad16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . vf = vp8_variance16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . svf = vp8_sub_pixel_variance16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx3f = vp8_sad16x8x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx8f = vp8_sad16x8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx4df = vp8_sad16x8x4d ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . sdf = vp8_sad8x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . vf = vp8_variance8x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . svf = vp8_sub_pixel_variance8x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx3f = vp8_sad8x16x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx8f = vp8_sad8x16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx4df = vp8_sad8x16x4d ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . sdf = vp8_sad8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . vf = vp8_variance8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . svf = vp8_sub_pixel_variance8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx3f = vp8_sad8x8x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx8f = vp8_sad8x8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx4df = vp8_sad8x8x4d ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . sdf = vp8_sad4x4 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . vf = vp8_variance4x4 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . svf = vp8_sub_pixel_variance4x4 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx3f = vp8_sad4x4x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx8f = vp8_sad4x4x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx4df = vp8_sad4x4x4d ; <S2SV_EndBug> ","<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> temporal_layer_id = - 1 ; cpi -> <S2SV_ModStart> mse_source_denoised = 0 ; cpi -> <S2SV_ModStart> if ( cpi -> oxcf . number_of_layers == 1 ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 20 ; } else if ( cpi -> oxcf . number_of_layers == 2 ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 10 ; } <S2SV_ModStart> CHECK_MEM_ERROR ( cpi -> consec_zero_last , vpx_calloc ( cm -> mb_rows * cm -> mb_cols , 1 ) ) ; CHECK_MEM_ERROR ( cpi -> consec_zero_last_mvbias , vpx_calloc ( ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , 1 ) ) ; <S2SV_ModStart> force_maxqp = 0 ; cpi -> <S2SV_ModStart> ifdef OUTPUT_YUV_DENOISED yuv_denoised_file = fopen ( ""denoised.yuv"" , ""ab"" ) ; # endif # <S2SV_ModStart> vpx_sad16x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance16x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_sub_pixel_variance16x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance_halfpixvar16x16_h <S2SV_ModEnd> <S2SV_ModStart> vpx_variance_halfpixvar16x16_v <S2SV_ModEnd> <S2SV_ModStart> vpx_variance_halfpixvar16x16_hv <S2SV_ModEnd> <S2SV_ModStart> vpx_sad16x16x3 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad16x16x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad16x16x4d <S2SV_ModEnd> <S2SV_ModStart> vpx_sad16x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance16x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_sub_pixel_variance16x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad16x8x3 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad16x8x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad16x8x4d <S2SV_ModEnd> <S2SV_ModStart> vpx_sad8x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance8x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_sub_pixel_variance8x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad8x16x3 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad8x16x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad8x16x4d <S2SV_ModEnd> <S2SV_ModStart> vpx_sad8x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance8x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_sub_pixel_variance8x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad8x8x3 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad8x8x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad8x8x4d <S2SV_ModEnd> <S2SV_ModStart> vpx_sad4x4 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance4x4 <S2SV_ModEnd> <S2SV_ModStart> vpx_sub_pixel_variance4x4 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad4x4x3 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad4x4x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad4x4x4d <S2SV_ModEnd> "
1651,"<S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> ",<S2SV_ModStart> _dh <S2SV_ModEnd> 
1652,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1653,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , mldv2_tstr <S2SV_ModEnd> "
1654,"<S2SV_StartBug> ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ; <S2SV_EndBug> ",<S2SV_ModStart> -> unary . child 
1655,"<S2SV_StartBug> while ( ( c != '\\n' ) && ( c != '\\0' ) ) <S2SV_EndBug> <S2SV_StartBug> ( void ) sscanf ( value , ""%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g"" , <S2SV_EndBug> <S2SV_StartBug> & white_point [ 0 ] , & white_point [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> ( void ) sscanf ( value , ""%d<S2SV_blank>+X<S2SV_blank>%d"" , & height , & width ) ; <S2SV_EndBug> <S2SV_StartBug> image -> rows = ( size_t ) height ; <S2SV_EndBug> ",<S2SV_ModStart> && ( c != EOF ) <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> == 8 ) { <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> == 2 ) { <S2SV_ModEnd> <S2SV_ModStart> } 
1656,"<S2SV_StartBug> mptctl_mpt_command ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> struct mpt_ioctl_command karg ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <S2SV_EndBug> <S2SV_StartBug> rc = mptctl_do_mpt_command ( karg , & uarg -> MF ) ; <S2SV_EndBug> ","<S2SV_ModStart> MPT_ADAPTER * ioc , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ioc , "
1657,"<S2SV_StartBug> * image ; <S2SV_EndBug> <S2SV_StartBug> padding , <S2SV_EndBug> <S2SV_StartBug> value = XBMInteger ( image , hex_digits ) ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) ( value >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> <S2SV_StartBug> byte = ( size_t ) ( * p ++ ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; int c <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> c <S2SV_ModEnd> <S2SV_ModStart> ; if ( c < 0 ) break <S2SV_ModStart> c <S2SV_ModEnd> <S2SV_ModStart> c <S2SV_ModEnd> <S2SV_ModStart> if ( c < 0 ) break ; <S2SV_ModStart> c ; } if ( EOFBlob ( image ) != MagickFalse ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) <S2SV_ModEnd> <S2SV_ModStart> unsigned int <S2SV_ModEnd> "
1658,"<S2SV_StartBug> if ( ! ( com -> data = JAS_CAST ( uchar * , jas_strdup ( buf ) ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
1659,<S2SV_StartBug> chanmode_found = 1 ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> ,<S2SV_ModStart> if ( ! chanmode_found ) { <S2SV_ModStart> } 
1660,"<S2SV_StartBug> static int decode_uniform ( vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> const int v = vp9_read_literal ( r , l - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> return v < m ? v : ( v << 1 ) - m + vp9_read_bit ( r ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_read_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_read_bit <S2SV_ModEnd> 
1661,<S2SV_StartBug> int is_valid ; <S2SV_EndBug> <S2SV_StartBug> giterr_clear ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> = ( error == GIT_OK ) <S2SV_ModStart>  <S2SV_ModEnd> 
1662,"<S2SV_StartBug> void vp9_cost_tokens_skip ( int * costs , const vp9_prob * probs , vp9_tree tree ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_tree <S2SV_ModEnd> 
1663,"<S2SV_StartBug> vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> ( REFERENCE_MODE ) vp9_read ( r , cm -> fc . comp_inter_prob [ ctx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> 
1664,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> return - 1 ; 
1665,"<S2SV_StartBug> if ( ! stream ) <S2SV_EndBug> <S2SV_StartBug> fatal ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>new<S2SV_blank>stream."" ) ; <S2SV_EndBug> <S2SV_StartBug> res = vpx_codec_enc_config_default ( global -> codec -> interface ( ) , <S2SV_EndBug> <S2SV_StartBug> stream -> config . stereo_fmt = STEREO_FORMAT_MONO ; <S2SV_EndBug> <S2SV_StartBug> stream -> config . write_webm = 1 ; <S2SV_EndBug> <S2SV_StartBug> stream -> ebml . last_pts_ms = - 1 ; <S2SV_EndBug> ",<S2SV_ModStart> stream == NULL ) { <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> write_webm = 1 ; # if CONFIG_WEBM_IO stream -> config . <S2SV_ModStart> ebml . last_pts_ns <S2SV_ModEnd> <S2SV_ModStart> ; stream -> ebml . writer = NULL ; stream -> ebml . segment = NULL 
1666,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""[ndp<S2SV_blank>opt]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , icmp6_tstr <S2SV_ModEnd> "
1667,<S2SV_StartBug> ( * re_ast ) -> root_node = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> levels = 0 ; ( * re_ast ) -> 
1668,<S2SV_StartBug> other = unix_peer_get ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unix_peer ( other ) != sk ) { <S2SV_EndBug> <S2SV_StartBug> if ( unix_recvq_full ( other ) ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( writable ) { unix_state_lock ( sk ) ; other = unix_peer ( sk ) ; if ( other && unix_peer ( <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> && unix_dgram_peer_wake_me ( sk , other ) <S2SV_ModStart> unix_state_unlock ( sk <S2SV_ModEnd> "
1669,"<S2SV_StartBug> ret = var_expand ( path , key -> key -> key , iter -> var_expand_table , & error ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB , <S2SV_EndBug> <S2SV_StartBug> ""Failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , key -> key -> key , error ) ; <S2SV_EndBug> <S2SV_StartBug> ret = dict_lookup ( iter -> conn -> dict , iter -> pool , <S2SV_EndBug> ","<S2SV_ModStart> str_append ( path , key -> key -> key ) ; ret = dict_lookup ( iter -> conn -> dict , iter -> pool , str_c ( path ) , & key -> value <S2SV_ModEnd> <S2SV_ModStart> > <S2SV_ModEnd> <S2SV_ModStart> auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Lookup:<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>%s"" , str_c ( path ) , key -> value ) ; } else if ( ret < 0 ) { <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>lookup<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , str_c ( path ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1670,<S2SV_StartBug> if ( A > skb -> len - sizeof ( struct nlattr ) ) <S2SV_EndBug> <S2SV_StartBug> if ( nla -> nla_len > A - skb -> len ) <S2SV_EndBug> ,<S2SV_ModStart> skb -> len < sizeof ( struct nlattr ) ) return 0 ; if ( <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> - A 
1671,<S2SV_StartBug> length = icon_file . directory [ i ] . size ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( ~ length < 16 ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) "
1672,"<S2SV_StartBug> ""<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost\'>"" <S2SV_EndBug> ","<S2SV_ModStart> ""<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'stabber@localhost\'>"" <S2SV_ModEnd> "
1673,"<S2SV_StartBug> memcpy ( serial -> value , priv -> cac_id , priv -> cac_id_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> serial -> len <S2SV_ModEnd> 
1674,<S2SV_StartBug> tok -> level = 0 ; <S2SV_EndBug> <S2SV_StartBug> return tok ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tok -> async_always = 0 ; 
1675,<S2SV_StartBug> if ( av1 -> av1_config ) { <S2SV_EndBug> ,<S2SV_ModStart> && av1 -> av1_config -> config 
1676,"<S2SV_StartBug> GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\n"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ; <S2SV_EndBug> ","<S2SV_ModStart> GF_Box * dref ; <S2SV_ModStart> ) ; dref = gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF <S2SV_ModStart> dref ; gf_isom_box_add_for_dump_mode ( s , dref <S2SV_ModEnd> "
1677,<S2SV_StartBug> buff [ r ] = '\\0' ; <S2SV_EndBug> ,"<S2SV_ModStart> MIN ( ( size_t ) r , ( sizeof buff ) - 1 ) <S2SV_ModEnd> "
1678,<S2SV_StartBug> ASSERT ( dpbSize ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( picSizeInMbs > ( UINT32_MAX - 32 - 15 ) / 384 ) { ALOGE ( ""b/28533562"" ) ; android_errorWriteLog ( 0x534e4554 , ""28533562"" ) ; return ( MEMORY_ALLOCATION_ERROR ) ; } "
1679,<S2SV_StartBug> oe_errno = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! sock ) <S2SV_EndBug> <S2SV_StartBug> if ( addrlen ) <S2SV_EndBug> <S2SV_StartBug> addrlen_in = * addrlen ; <S2SV_EndBug> <S2SV_StartBug> addrlen ) != OE_OK ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ,<S2SV_ModStart> oe_socklen_t addrlen_out = 0 ; <S2SV_ModStart> || ! addr || ! addrlen <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( addrlen_in < 0 ) OE_RAISE_ERRNO ( OE_EINVAL ) <S2SV_ModStart> & addrlen_out <S2SV_ModEnd> <S2SV_ModStart> if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; * addrlen = addrlen_out ; 
1680,"
","
"
1681,"<S2SV_StartBug> nego_process_negotiation_request ( nego , s ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) return FALSE 
1682,<S2SV_StartBug> struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt == NULL ) <S2SV_EndBug> <S2SV_StartBug> fl6_sock_release ( flowlabel ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; struct ipv6_txoptions * opt_to_free = NULL <S2SV_ModStart> ! opt ) { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> <S2SV_ModStart> ) ; txopt_put ( opt_to_free 
1683,"<S2SV_StartBug> unsigned int i , found , upx_success = 0 , min = 0 , max = 0 , err , overlays = 0 ; <S2SV_EndBug> <S2SV_StartBug> uint32_t valign , falign , hdr_size , j ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < nsections ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> strncpy ( sname , ( char * ) section_hdr [ i ] . Name , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> sname [ 8 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( exe_sections [ i ] . raw >= fsize ) { <S2SV_EndBug> ","<S2SV_ModStart> j , <S2SV_ModStart> , rescan = 1 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> while ( rescan == 1 ) { rescan = 0 ; <S2SV_ModStart> exe_sections [ i ] . rva = PEALIGN ( EC32 ( section_hdr [ i ] . VirtualAddress ) , valign ) ; exe_sections [ i ] . vsz = PESALIGN ( EC32 ( section_hdr [ i ] . VirtualSize ) , valign ) ; exe_sections [ i ] . raw = PEALIGN ( EC32 ( section_hdr [ i ] . PointerToRawData ) , falign ) ; exe_sections [ i ] . rsz = PESALIGN ( EC32 ( section_hdr [ i ] . SizeOfRawData ) , falign ) ; exe_sections [ i ] . chr = EC32 ( section_hdr [ i ] . Characteristics ) ; exe_sections [ i ] . urva = EC32 ( section_hdr [ i ] . VirtualAddress ) ; exe_sections [ i ] . uvsz = EC32 ( section_hdr [ i ] . VirtualSize ) ; exe_sections [ i ] . uraw = EC32 ( section_hdr [ i ] . PointerToRawData ) ; exe_sections [ i ] . ursz = EC32 ( section_hdr [ i ] . SizeOfRawData ) ; if ( exe_sections [ i ] . rsz ) { if ( ! CLI_ISCONTAINED ( 0 , fsize , exe_sections [ i ] . uraw , exe_sections [ i ] . ursz ) || exe_sections [ i ] . raw >= fsize ) { cli_dbgmsg ( ""Broken<S2SV_blank>PE<S2SV_blank>file<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>%d<S2SV_blank>starts<S2SV_blank>or<S2SV_blank>exists<S2SV_blank>beyond<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>(Offset@<S2SV_blank>%lu,<S2SV_blank>Total<S2SV_blank>filesize<S2SV_blank>%lu)\\n"" , i , ( unsigned long ) exe_sections [ i ] . raw , ( unsigned long ) fsize ) ; if ( nsections == 1 ) { free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } for ( j = i ; j < nsections - 1 ; j ++ ) memcpy ( & exe_sections [ j ] , & exe_sections [ j + 1 ] , sizeof ( struct cli_exe_section ) ) ; for ( j = i ; j < nsections - 1 ; j ++ ) memcpy ( & section_hdr [ j ] , & section_hdr [ j + 1 ] , sizeof ( struct pe_image_section_hdr ) ) ; nsections -- ; rescan = 1 ; break ; } } } } for ( i = 0 ; i < nsections ; i ++ ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1684,"<S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPAR , 0x40 | address ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS | EPCR_ERPRR ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( dm9000ReadReg ( DM9000_REG_EPCR ) & EPCR_ERRE ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS ) ; <S2SV_EndBug> <S2SV_StartBug> return ( dm9000ReadReg ( DM9000_REG_EPDRH ) << 8 ) | dm9000ReadReg ( DM9000_REG_EPDRL ) ; <S2SV_EndBug> ","<S2SV_ModStart> DM9000_EPAR <S2SV_ModEnd> <S2SV_ModStart> DM9000_EPCR , DM9000_EPCR_EPOS | DM9000_EPCR_ERPRR <S2SV_ModEnd> <S2SV_ModStart> DM9000_EPCR ) & DM9000_EPCR_ERRE <S2SV_ModEnd> <S2SV_ModStart> DM9000_EPCR , DM9000_EPCR_EPOS <S2SV_ModEnd> <S2SV_ModStart> DM9000_EPDRH <S2SV_ModEnd> <S2SV_ModStart> DM9000_EPDRL <S2SV_ModEnd> "
1685,"<S2SV_StartBug> & bufferoffset , <S2SV_EndBug> ","<S2SV_ModStart> t2p -> tiff_datasize , "
1686,"<S2SV_StartBug> ! inode_capable ( inode , CAP_CHOWN ) ) <S2SV_EndBug> <S2SV_StartBug> ! inode_capable ( inode , CAP_CHOWN ) ) <S2SV_EndBug> <S2SV_StartBug> ! inode_capable ( inode , CAP_FSETID ) ) <S2SV_EndBug> ",<S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> <S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> <S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> 
1687,"<S2SV_StartBug> static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , <S2SV_EndBug> <S2SV_StartBug> UINT32 tempWidth ; <S2SV_EndBug> <S2SV_StartBug> for ( y = 0 ; y < context -> height ; y ++ ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! context || data || ( scanline == 0 ) ) return FALSE <S2SV_ModStart> if ( context -> priv -> PlaneBuffersLength < rw * scanline ) return FALSE ; if ( rw < scanline * 2 ) return FALSE ; <S2SV_ModStart> return TRUE ; 
1688,"<S2SV_StartBug> static int isofs_read_inode ( struct inode * inode ) <S2SV_EndBug> <S2SV_StartBug> parse_rock_ridge_inode ( de , inode ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int relocated <S2SV_ModStart> , relocated "
1689,"<S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> <S2SV_StartBug> __ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> current_cred ( ) <S2SV_ModEnd> 
1690,<S2SV_StartBug> ( * re_ast ) -> root_node = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> levels = 0 ; ( * re_ast ) -> 
1691,"<S2SV_StartBug> rc = cib_tls_signon ( cib , & ( private -> command ) ) ; <S2SV_EndBug> <S2SV_StartBug> rc = cib_tls_signon ( cib , & ( private -> callback ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> , FALSE <S2SV_ModStart> , TRUE "
1692,<S2SV_StartBug> msg . msg_name = ( struct sockaddr * ) & address ; <S2SV_EndBug> <S2SV_StartBug> msg . msg_namelen = sizeof ( address ) ; <S2SV_EndBug> ,<S2SV_ModStart> addr ? <S2SV_ModStart> : NULL <S2SV_ModStart> 0 <S2SV_ModEnd> 
1693,"<S2SV_StartBug> int num00 , tmp_err , n , sr = 0 ; <S2SV_EndBug> <S2SV_StartBug> int new_mv_mode_penalty = 256 ; <S2SV_EndBug> <S2SV_StartBug> const int quart_frm = MIN ( cpi -> common . width , cpi -> common . height ) ; <S2SV_EndBug> <S2SV_StartBug> tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv , <S2SV_EndBug> <S2SV_StartBug> x -> sadperbit16 , & num00 , & v_fn_ptr , <S2SV_EndBug> <S2SV_StartBug> best_mv -> row = tmp_mv . row ; <S2SV_EndBug> <S2SV_StartBug> tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv , <S2SV_EndBug> <S2SV_StartBug> x -> nmvjointcost , <S2SV_EndBug> <S2SV_StartBug> best_mv -> row = tmp_mv . row ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> NEW_MV_MODE_PENALTY ; int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param <S2SV_ModEnd> <S2SV_ModStart> sr = get_search_range ( cpi ) <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { v_fn_ptr . vf = highbd_get_block_variance_fn ( bsize , xd -> bd ) ; } # endif <S2SV_ModStart> cpi -> ss_cfg , & <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * best_mv = tmp_mv <S2SV_ModEnd> <S2SV_ModStart> , & cpi -> ss_cfg <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * best_mv = tmp_mv <S2SV_ModEnd> "
1694,"<S2SV_StartBug> ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , <S2SV_EndBug> ","<S2SV_ModStart> , filename , page_size , off ) ; goto error ; } if ( off + page_size > h -> size ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>extends<S2SV_blank>beyond<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file,<S2SV_blank>bad<S2SV_blank>registry"" "
1695,<S2SV_StartBug> return merged ; <S2SV_EndBug> ,<S2SV_ModStart> merged -> xml_external_entity = ( child -> xml_external_entity == NOT_SET ? parent -> xml_external_entity : child -> xml_external_entity ) ; 
1696,"<S2SV_StartBug> if ( used_address && used_address -> name_len == msg_sys -> msg_namelen && <S2SV_EndBug> <S2SV_StartBug> ! memcmp ( & used_address -> name , msg -> msg_name , <S2SV_EndBug> <S2SV_StartBug> memcpy ( & used_address -> name , msg -> msg_name , <S2SV_EndBug> ",<S2SV_ModStart> msg_sys -> msg_name && <S2SV_ModStart> msg_sys <S2SV_ModEnd> <S2SV_ModStart> if ( msg_sys -> msg_name ) <S2SV_ModStart> msg_sys <S2SV_ModEnd> 
1697,<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1698,"<S2SV_StartBug> offset , <S2SV_EndBug> <S2SV_StartBug> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) <S2SV_EndBug> <S2SV_StartBug> p = pixels + offset ; <S2SV_EndBug> <S2SV_StartBug> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) <S2SV_EndBug> ","<S2SV_ModStart> pixel_info_length ; ssize_t count , offset <S2SV_ModEnd> <S2SV_ModStart> ( offset < 0 ) || ( <S2SV_ModStart> ) <S2SV_ModStart> if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } <S2SV_ModStart>  <S2SV_ModEnd> "
1699,"<S2SV_StartBug> ( r = sshbuf_put_u32 ( b , comp -> enabled ) ) != 0 || <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1700,"<S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ",<S2SV_ModStart> ssplit <S2SV_ModEnd> 
1701,<S2SV_StartBug> cib_client_t * client = user_data ; <S2SV_EndBug> <S2SV_StartBug> free ( client -> name ) ; <S2SV_EndBug> <S2SV_StartBug> free ( client ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ; int csock = 0 <S2SV_ModStart> if ( client -> remote_auth_timeout ) { g_source_remove ( client -> remote_auth_timeout ) ; } if ( client -> encrypted ) { # ifdef HAVE_GNUTLS_GNUTLS_H if ( client -> session ) { void * sock_ptr = gnutls_transport_get_ptr ( * client -> session ) ; csock = GPOINTER_TO_INT ( sock_ptr ) ; if ( client -> handshake_complete ) { gnutls_bye ( * client -> session , GNUTLS_SHUT_WR ) ; } gnutls_deinit ( * client -> session ) ; gnutls_free ( client -> session ) ; } # endif } else { csock = GPOINTER_TO_INT ( client -> session ) ; } client -> session = NULL ; if ( csock > 0 ) { close ( csock ) ; } <S2SV_ModStart> -> recv_buf ) ; free ( client "
1702,<S2SV_StartBug> * p = thread -> twups ; <S2SV_EndBug> <S2SV_StartBug> work ++ ; <S2SV_EndBug> ,<S2SV_ModStart> lua_assert ( ! isold ( thread ) || thread -> openupval == NULL ) ; <S2SV_ModStart> lua_assert ( getage ( uv ) <= getage ( thread ) ) ; 
1703,<S2SV_StartBug> px -> ft -> data = px ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! px -> ft ) { return FALSE ; } 
1704,<S2SV_StartBug> return FALSE ; <S2SV_EndBug> ,<S2SV_ModStart> transport -> credssp = NULL ; 
1705,"<S2SV_StartBug> olddentry = ovl_dentry_upper ( old ) ; <S2SV_EndBug> <S2SV_StartBug> newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , <S2SV_EndBug> <S2SV_StartBug> err = PTR_ERR ( newdentry ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( newdentry ) ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( olddentry -> d_parent != old_upperdir ) <S2SV_EndBug> <S2SV_StartBug> if ( newdentry -> d_parent != new_upperdir ) <S2SV_EndBug> <S2SV_StartBug> goto out_dput ; <S2SV_EndBug> <S2SV_StartBug> out_unlock : <S2SV_EndBug> ","<S2SV_ModStart> lookup_one_len ( old <S2SV_ModEnd> <S2SV_ModStart> old_upperdir , old <S2SV_ModEnd> <S2SV_ModStart> olddentry <S2SV_ModEnd> <S2SV_ModStart> olddentry <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> != ovl_dentry_upper ( old ) ) goto out_dput_old ; newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , new -> d_name . len ) ; err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out_dput_old ; err = - ESTALE ; if ( ovl_dentry_upper ( new ) ) { if ( opaquedir ) { if ( newdentry != opaquedir <S2SV_ModEnd> <S2SV_ModStart> } else { if ( newdentry != ovl_dentry_upper ( new ) <S2SV_ModEnd> <S2SV_ModStart> } } else { new_create = true ; if ( ! d_is_negative ( newdentry ) && ( ! new_opaque || ! ovl_is_whiteout ( newdentry ) ) ) goto out_dput ; } <S2SV_ModStart> out_dput_old : dput ( olddentry ) ; "
1706,<S2SV_StartBug> && obj [ 0 ] == 0x00 && objlen > 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> objlen > 1 && <S2SV_ModStart>  <S2SV_ModEnd> 
1707,<S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( ! try_get_page ( page ) ) ) { spin_unlock ( ptl ) ; return ERR_PTR ( - ENOMEM ) ; } <S2SV_ModEnd> 
1708,<S2SV_StartBug> mntput ( ns -> proc_mnt ) ; <S2SV_EndBug> ,<S2SV_ModStart> kern_unmount <S2SV_ModEnd> 
1709,<S2SV_StartBug> switch ( bps / 8 ) <S2SV_EndBug> ,"<S2SV_ModStart> if ( bytes_per_pixel > sizeof ( swapbuff ) ) { TIFFError ( ""reverseSamplesBytes"" , ""bytes_per_pixel<S2SV_blank>too<S2SV_blank>large"" ) ; return ( 1 ) ; } "
1710,"<S2SV_StartBug> if ( img && ( img -> d_w != cfg -> g_w || img -> d_h != cfg -> g_h ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! stream -> img ) <S2SV_EndBug> <S2SV_StartBug> stream -> img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I420 , <S2SV_EndBug> <S2SV_StartBug> img = stream -> img ; <S2SV_EndBug> ","<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( img ) { if ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) <S2SV_ModEnd> <S2SV_ModStart> img -> fmt != VPX_IMG_FMT_I42016 ) { fprintf ( stderr , ""%s<S2SV_blank>can<S2SV_blank>only<S2SV_blank>scale<S2SV_blank>4:2:0<S2SV_blank>inputs\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; } # if CONFIG_LIBYUV if ( <S2SV_ModStart> { <S2SV_ModStart> VPX_IMG_FMT_I42016 , cfg -> g_w , cfg -> g_h , 16 ) ; } I420Scale_16 ( ( uint16 * ) img -> planes [ VPX_PLANE_Y ] , img -> stride [ VPX_PLANE_Y ] / 2 , ( uint16 * ) img -> planes [ VPX_PLANE_U ] , img -> stride [ VPX_PLANE_U ] / 2 , ( uint16 * ) img -> planes [ VPX_PLANE_V ] , img -> stride [ VPX_PLANE_V ] / 2 , img -> d_w , img -> d_h , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_Y ] , stream -> img -> stride [ VPX_PLANE_Y ] / 2 , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_U ] , stream -> img -> stride [ VPX_PLANE_U ] / 2 , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_V ] , stream -> img -> stride [ VPX_PLANE_V ] / 2 , stream -> img -> d_w , stream -> img -> d_h , kFilterBox ) ; img = stream -> img ; # else stream -> encoder . err = 1 ; ctx_exit_on_error ( & stream -> encoder , ""Stream<S2SV_blank>%d:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame.\\n"" ""Scaling<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>configuration.<S2SV_blank>\\n"" ""To<S2SV_blank>enable,<S2SV_blank>configure<S2SV_blank>with<S2SV_blank>--enable-libyuv\\n"" , stream -> index ) ; # endif } } # endif if ( img && ( img -> d_w != cfg -> g_w || img -> d_h != cfg -> g_h ) ) { if ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_YV12 ) { fprintf ( stderr , ""%s<S2SV_blank>can<S2SV_blank>only<S2SV_blank>scale<S2SV_blank>4:2:0<S2SV_blank>8bpp<S2SV_blank>inputs\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; } # if CONFIG_LIBYUV if ( ! stream -> img ) stream -> img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I420 <S2SV_ModEnd> <S2SV_ModStart> # else stream -> encoder . err = 1 ; ctx_exit_on_error ( & stream -> encoder , ""Stream<S2SV_blank>%d:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame.\\n"" ""Scaling<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>configuration.<S2SV_blank>\\n"" ""To<S2SV_blank>enable,<S2SV_blank>configure<S2SV_blank>with<S2SV_blank>--enable-libyuv\\n"" , stream -> index ) ; # endif "
1711,<S2SV_StartBug> params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) <S2SV_EndBug> ,<S2SV_ModStart> INT_MAX <S2SV_ModEnd> 
1712,<S2SV_StartBug> dev -> netdev_ops = & l2tp_eth_netdev_ops ; <S2SV_EndBug> ,<S2SV_ModStart> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> 
1713,"<S2SV_StartBug> int ret , wo ; <S2SV_EndBug> <S2SV_StartBug> wo = ( rbuf == NULL || rlen == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( wo ) <S2SV_EndBug> <S2SV_StartBug> rbuf , rlen , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( rlen > MAX_XFER_SIZE ) { warn ( ""i2c<S2SV_blank>rd:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\n"" , rlen ) ; return - EOPNOTSUPP ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> st -> data <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( ! ret && rbuf && rlen ) memcpy ( rbuf , st -> data , rlen "
1714,"<S2SV_StartBug> return r ? : __blkdev_driver_ioctl ( bdev , mode , cmd , arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! r && ti -> len != i_size_read ( bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; "
1715,"<S2SV_StartBug> cli_dbgmsg ( ""Possible<S2SV_blank>data<S2SV_blank>corruption<S2SV_blank>fixed\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * p ) <S2SV_EndBug> ","<S2SV_ModStart> if ( strlen ( p ) > 8 ) { <S2SV_ModStart> cli_dbgmsg ( ""Possible<S2SV_blank>data<S2SV_blank>corruption<S2SV_blank>not<S2SV_blank>fixed\\n"" ) ; } } else { "
1716,"<S2SV_StartBug> if ( dst_group && ! netlink_capable ( sock , NL_NONROOT_SEND ) ) <S2SV_EndBug> ",<S2SV_ModStart> ( dst_group || dst_pid ) <S2SV_ModEnd> 
1717,"<S2SV_StartBug> err = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( err <S2SV_ModEnd> "
1718,"<S2SV_StartBug> * ( int * ) pReplyData = Downmix_setParameter ( pDownmixer , * ( int32_t * ) cmd -> data , <S2SV_EndBug> ","<S2SV_ModStart> if ( cmd -> psize != sizeof ( int32_t ) ) { android_errorWriteLog ( 0x534e4554 , ""63662938"" ) ; return - EINVAL ; } "
1719,"<S2SV_StartBug> static void choose_intra_uv_mode ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , <S2SV_EndBug> <S2SV_StartBug> MB_PREDICTION_MODE * mode_uv ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> ","<S2SV_ModStart> MACROBLOCK * const x , <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1720,"<S2SV_StartBug> void nfs4_close_state ( struct path * path , struct nfs4_state * state , mode_t mode ) <S2SV_EndBug> <S2SV_StartBug> __nfs4_close ( path , state , mode , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> 
1721,"<S2SV_StartBug> return mount_pseudo ( fs_type , ""aio:"" , NULL , & ops , AIO_RING_MAGIC ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> struct dentry * root = <S2SV_ModEnd> <S2SV_ModStart> if ( ! IS_ERR ( root ) ) root -> d_sb -> s_iflags |= SB_I_NOEXEC ; return root ; 
1722,"<S2SV_StartBug> uint32 rows , uint32 cols , int outskew , int inskew ) <S2SV_EndBug> ",<S2SV_ModStart> int64 <S2SV_ModEnd> 
1723,"<S2SV_StartBug> memcpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ; <S2SV_EndBug> ","<S2SV_ModStart> s -> append_char ( s , 0 ) ; strncpy <S2SV_ModEnd> "
1724,<S2SV_StartBug> if ( request -> ssids [ i ] . ssid_len > <S2SV_EndBug> <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug> ,<S2SV_ModStart> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
1725,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1726,<S2SV_StartBug> o4 = o * sizeof ( uint32_t ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( q + o >= e ) goto out ; 
1727,<S2SV_StartBug> for ( plane = 0 ; plane < 3 ; ++ plane ) { <S2SV_EndBug> <S2SV_StartBug> const int w = ( plane ? ( 1 + yuv_frame -> d_w ) / 2 : yuv_frame -> d_w ) ; <S2SV_EndBug> <S2SV_StartBug> const int h = ( plane ? ( 1 + yuv_frame -> d_h ) / 2 : yuv_frame -> d_h ) ; <S2SV_EndBug> <S2SV_StartBug> size_t needed = w ; <S2SV_EndBug> ,"<S2SV_ModStart> const int bytespp = ( yuv_frame -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ; <S2SV_ModStart> vpx_img_plane_width ( yuv_frame , plane <S2SV_ModEnd> <S2SV_ModStart> vpx_img_plane_height ( yuv_frame , plane <S2SV_ModEnd> <S2SV_ModStart> * bytespp "
1728,"<S2SV_StartBug> struct keydata * keyptr ; <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = half_md4_transform ( hash , keyptr -> secret ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> unsigned int ret <S2SV_ModEnd> <S2SV_ModStart> md5_transform <S2SV_ModEnd> <S2SV_ModStart> random_int_secret ) ; ret = hash [ 0 ] <S2SV_ModEnd> 
1729,"<S2SV_StartBug> CallInfo * ci = next_ci ( L ) ; <S2SV_EndBug> <S2SV_StartBug> ci -> func = func ; <S2SV_EndBug> <S2SV_StartBug> CallInfo * ci = next_ci ( L ) ; <S2SV_EndBug> <S2SV_StartBug> checkstackp ( L , fsize , func ) ; <S2SV_EndBug> <S2SV_StartBug> checkstackp ( L , 1 , func ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; checkstackGCp ( L , LUA_MINSTACK , func ) ; L -> ci = ci <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> checkstackGCp <S2SV_ModEnd> <S2SV_ModStart> ) ; L -> ci = ci = next_ci ( L <S2SV_ModStart> checkstackGCp <S2SV_ModEnd> "
1730,"<S2SV_StartBug> ns_to_timespec ( cur_setting -> it_interval , timr -> it . mmtimer . incr * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> ns_to_timespec ( cur_setting -> it_value , ( timr -> it . mmtimer . expires - rtc_time ( ) ) * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = ns_to_timespec ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = ns_to_timespec ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1731,<S2SV_StartBug> snd_usbmidi_free ( umidi ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1732,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , icmp6_tstr <S2SV_ModEnd> "
1733,"<S2SV_StartBug> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> mark_key_instantiated ( key , 0 <S2SV_ModEnd> "
1734,<S2SV_StartBug> sigev_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1735,<S2SV_StartBug> if ( server . vm_enabled ) <S2SV_EndBug> <S2SV_StartBug> if ( server . vm_enabled ) vmInit ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> ds_enabled <S2SV_ModEnd> <S2SV_ModStart> ds_enabled ) dsInit <S2SV_ModEnd> 
1736,"<S2SV_StartBug> assert_regexp_syntax_error ( "")"" ) ; <S2SV_EndBug> <S2SV_StartBug> ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>317<S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}?t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>314<S2SV_blank>}"" , <S2SV_EndBug> ","<S2SV_ModStart> assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""\\0a\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""\\ta\\0b\\0c\\0"" ) ; assert_false_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""x\\0a\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""x\\ta\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0\\t"" ) ; assert_false_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0x\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0b\\t"" ) ; assert_false_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""abc"" ) ; <S2SV_ModStart> ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>317<S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}?t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>314<S2SV_blank>}"" <S2SV_ModEnd> "
1737,<S2SV_StartBug> struct tcp_sock_t * tcp_socket ; <S2SV_EndBug> <S2SV_StartBug> while ( ( tcp_socket = tcp_open ( desired_port ) ) == NULL && <S2SV_EndBug> <S2SV_StartBug> g_options . only_desired_port == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> uint16_t real_port = tcp_port_number_get ( tcp_socket ) ; <S2SV_EndBug> <S2SV_StartBug> uint16_t pid ; <S2SV_EndBug> <S2SV_StartBug> args -> tcp = tcp_conn_accept ( tcp_socket ) ; <S2SV_EndBug> <S2SV_StartBug> cleanup_usb : <S2SV_EndBug> ,"<S2SV_ModStart> = NULL , * tcp6_socket = NULL ; for ( ; ; ) { <S2SV_ModEnd> <S2SV_ModStart> ; tcp6_socket = tcp6_open ( desired_port ) ; if ( tcp_socket || tcp6_socket || <S2SV_ModEnd> <S2SV_ModStart> ) break ; <S2SV_ModEnd> <S2SV_ModStart> NOTE ( ""Access<S2SV_blank>to<S2SV_blank>desired<S2SV_blank>port<S2SV_blank>failed,<S2SV_blank>trying<S2SV_blank>alternative<S2SV_blank>port<S2SV_blank>%d"" , desired_port ) ; } if ( tcp_socket == NULL && tcp6_socket <S2SV_ModEnd> <S2SV_ModStart> ; if ( tcp_socket ) real_port <S2SV_ModStart> ) ; else real_port = tcp_port_number_get ( tcp6_socket <S2SV_ModStart> NOTE ( ""Port:<S2SV_blank>%d,<S2SV_blank>IPv4<S2SV_blank>%savailable,<S2SV_blank>IPv6<S2SV_blank>%savailable"" , real_port , tcp_socket ? """" : ""not<S2SV_blank>"" , tcp6_socket ? """" : ""not<S2SV_blank>"" ) ; <S2SV_ModStart> tcp_conn_select ( tcp_socket , tcp6_socket <S2SV_ModEnd> <S2SV_ModStart> if ( tcp6_socket != NULL ) tcp_close ( tcp6_socket ) ; "
1738,"<S2SV_StartBug> file_sb_list_add ( f , inode -> i_sb ) ; <S2SV_EndBug> <S2SV_StartBug> file_sb_list_del ( f ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1739,<S2SV_StartBug> if ( * off >= skb -> len ) { <S2SV_EndBug> ,<S2SV_ModStart> && skb -> len 
1740,<S2SV_StartBug> if ( len < 1 ) <S2SV_EndBug> ,<S2SV_ModStart> 10 <S2SV_ModEnd> 
1741,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> ",<S2SV_ModStart> key_is_negative ( key <S2SV_ModEnd> 
1742,"<S2SV_StartBug> page -> index , <S2SV_EndBug> ",<S2SV_ModStart> page_index ( page ) <S2SV_ModEnd> 
1743,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> unlink ( RUN_LIB_FILE ) ; 
1744,<S2SV_StartBug> if ( atomic_read ( & current -> mm -> mm_users ) > 1 ) <S2SV_EndBug> ,<S2SV_ModStart> 1 ) return - EINVAL ; if ( current -> fs -> users != 
1745,<S2SV_StartBug> if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( <S2SV_ModStart> ) 
1746,"<S2SV_StartBug> mpz_t numer , denom , lambda ; <S2SV_EndBug> ",<S2SV_ModStart> if ( pointZZ_pIsIdentityElement ( op ) ) { return pointZZ_pSetToIdentityElement ( rop ) ; } 
1747,"<S2SV_StartBug> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> 
1748,<S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) <S2SV_EndBug> <S2SV_StartBug> numBytes += size ; <S2SV_EndBug> <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; } <S2SV_ModEnd> <S2SV_ModStart> * num <S2SV_ModStart> * num "
1749,<S2SV_StartBug> bufp += bytes_read ; <S2SV_EndBug> ,<S2SV_ModStart> stripsize <S2SV_ModEnd> 
1750,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( pool ) ; 
1751,<S2SV_StartBug> if ( ( creds -> pid == task_tgid_vnr ( current ) || nsown_capable ( CAP_SYS_ADMIN ) ) && <S2SV_EndBug> ,"<S2SV_ModStart> ns_capable ( current -> nsproxy -> pid_ns -> user_ns , <S2SV_ModEnd> "
1752,<S2SV_StartBug> coerce_reg_to_32 ( dst_reg ) ; <S2SV_EndBug> <S2SV_StartBug> coerce_reg_to_32 ( & src_reg ) ; <S2SV_EndBug> ,"<S2SV_ModStart> coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size <S2SV_ModEnd> <S2SV_ModStart> , 4 "
1753,<S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> ,<S2SV_ModStart> key_is_positive <S2SV_ModEnd> 
1754,<S2SV_StartBug> kfree ( tu -> queue ) ; <S2SV_EndBug> ,<S2SV_ModStart> tu -> qhead = tu -> qtail = tu -> qused = 0 ; 
1755,"<S2SV_StartBug> if ( unlikely ( path [ depth ] . p_ext > EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) ) { <S2SV_EndBug> <S2SV_StartBug> ext4_extent_block_csum_set ( inode , neh ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_extent_block_csum_set ( inode , neh ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t ext_size = 0 ; <S2SV_ModStart> ext_size = sizeof ( struct ext4_extent_header ) + sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ; <S2SV_ModStart> ext_size = sizeof ( struct ext4_extent_header ) + ( sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ; "
1756,"<S2SV_StartBug> if ( ret ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! prph_info ) <S2SV_EndBug> <S2SV_StartBug> ctxt_info_gen3 = dma_alloc_coherent ( trans -> dev , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> goto err_free_prph_scratch ; <S2SV_ModEnd> <S2SV_ModStart> ) { ret = - ENOMEM ; goto err_free_prph_scratch ; } ctxt_info_gen3 = dma_alloc_coherent ( trans -> dev , sizeof ( * ctxt_info_gen3 ) , & trans_pcie -> ctxt_info_dma_addr , GFP_KERNEL ) ; if ( ! ctxt_info_gen3 ) { ret = - ENOMEM ; goto err_free_prph_info ; } ctxt_info_gen3 -> prph_info_base_addr = cpu_to_le64 ( trans_pcie -> prph_info_dma_addr ) ; ctxt_info_gen3 -> prph_scratch_base_addr = cpu_to_le64 ( trans_pcie -> prph_scratch_dma_addr ) ; ctxt_info_gen3 -> prph_scratch_size = cpu_to_le32 ( sizeof ( * prph_scratch ) ) ; ctxt_info_gen3 -> cr_head_idx_arr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> rb_stts_dma ) ; ctxt_info_gen3 -> tr_tail_idx_arr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> tr_tail_dma ) ; ctxt_info_gen3 -> cr_tail_idx_arr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> cr_tail_dma ) ; ctxt_info_gen3 -> cr_idx_arr_size = cpu_to_le16 ( IWL_NUM_OF_COMPLETION_RINGS ) ; ctxt_info_gen3 -> tr_idx_arr_size = cpu_to_le16 ( IWL_NUM_OF_TRANSFER_RINGS ) ; ctxt_info_gen3 -> mtr_base_addr = cpu_to_le64 ( trans_pcie -> txq [ trans_pcie -> cmd_queue ] -> dma_addr ) ; ctxt_info_gen3 -> mcr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> used_bd_dma ) ; ctxt_info_gen3 -> mtr_size = cpu_to_le16 ( TFD_QUEUE_CB_SIZE ( cmdq_size ) ) ; ctxt_info_gen3 -> mcr_size = cpu_to_le16 ( RX_QUEUE_CB_SIZE ( MQ_RX_TABLE_SIZE ) ) ; trans_pcie -> ctxt_info_gen3 = ctxt_info_gen3 ; trans_pcie -> prph_info = prph_info ; trans_pcie -> prph_scratch = prph_scratch ; iml_img = dma_alloc_coherent ( trans -> dev , trans -> iml_len , & trans_pcie -> iml_dma_addr , GFP_KERNEL ) ; if ( ! iml_img <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> err_free_prph_info : dma_free_coherent ( trans -> dev , sizeof ( * prph_info ) , prph_info , trans_pcie -> prph_info_dma_addr ) ; err_free_prph_scratch : dma_free_coherent ( trans -> dev , sizeof ( * prph_scratch ) , prph_scratch , trans_pcie -> prph_scratch_dma_addr ) ; return ret ; "
1757,<S2SV_StartBug> if ( ! s -> cdx [ i ] || ! s -> cdy [ i ] ) { <S2SV_EndBug> ,<S2SV_ModStart> s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || <S2SV_ModStart> || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4 
1758,"<S2SV_StartBug> & msg -> addrto , & msg -> ifindex ) ; <S2SV_EndBug> <S2SV_StartBug> dbg ( ndp , ""rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> str_in6_addr ( & msg -> addrto ) , msg -> ifindex ) ; <S2SV_EndBug> ","<S2SV_ModStart> , & msg -> hoplimit <S2SV_ModStart> ""rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u,<S2SV_blank>hoplimit:<S2SV_blank>%d"" <S2SV_ModEnd> <S2SV_ModStart> , msg -> hoplimit ) ; if ( msg -> hoplimit != 255 ) { warn ( ndp , ""ignoring<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>bad<S2SV_blank>hop<S2SV_blank>limit<S2SV_blank>(%d)"" , msg -> hoplimit ) ; err = 0 ; goto free_msg ; } <S2SV_ModEnd> "
1759,<S2SV_StartBug> if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { <S2SV_EndBug> ,<S2SV_ModStart> i_lenEAttr > bs || iinfo -> i_lenAlloc > bs ) goto out ; if ( udf_file_entry_alloc_offset ( inode ) + iinfo -> i_lenAlloc > bs ) goto out ; if ( iinfo -> 
1760,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> iw_set_error ( rctx -> ctx , ""Compression<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>with<S2SV_blank>top-down<S2SV_blank>images"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> goto done ; <S2SV_ModStart> ; goto done 
1761,"<S2SV_StartBug> vp9_copy ( cm -> fc . coef_probs [ TX_4X4 ] , default_coef_probs_4x4 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_copy ( cm -> fc . coef_probs [ TX_8X8 ] , default_coef_probs_8x8 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_copy ( cm -> fc . coef_probs [ TX_16X16 ] , default_coef_probs_16x16 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_copy ( cm -> fc . coef_probs [ TX_32X32 ] , default_coef_probs_32x32 ) ; <S2SV_EndBug> ",<S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> 
1762,"<S2SV_StartBug> xmlNode * op_msg = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( sync_timer == NULL ) { <S2SV_EndBug> <S2SV_StartBug> crm_send_remote_msg ( private -> command . session , op_msg , private -> command . encrypted ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cib -> call_timeout > 0 ) { <S2SV_EndBug> <S2SV_StartBug> op_reply = crm_recv_remote_msg ( private -> command . session , private -> command . encrypted ) ; <S2SV_EndBug> <S2SV_StartBug> crm_element_value_int ( op_reply , F_CIB_CALLID , & reply_id ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int disconnected = 0 ; int remaining_time = 0 ; time_t start_time ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! ( call_options & cib_sync_call ) ) { <S2SV_ModStart> callback . session , op_msg , private -> command . encrypted ) ; } else { crm_send_remote_msg ( private -> command . <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> start_time = time ( NULL ) ; remaining_time = <S2SV_ModEnd> <S2SV_ModStart> ? cib -> call_timeout : 60 ; while ( remaining_time > 0 && ! disconnected <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> & <S2SV_ModStart> recv_buf , private -> command . encrypted , remaining_time * 1000 , & disconnected ) ; op_reply = crm_parse_remote_buffer ( & private -> command . recv_buf ) ; if ( ! op_reply <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> remaining_time = time ( NULL ) - start_time ; } if ( disconnected ) { crm_err ( ""Disconnected<S2SV_blank>while<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>reply."" ) ; return - ENOTCONN ; } else <S2SV_ModEnd> "
1763,"<S2SV_StartBug> pr_debug ( ""%p<S2SV_blank>%zu\\n"" , sk , len ) ; <S2SV_EndBug> <S2SV_StartBug> sockaddr -> sa_family = AF_NFC ; <S2SV_EndBug> ","<S2SV_ModStart> ; msg -> msg_namelen = 0 <S2SV_ModStart> memset ( sockaddr , 0 , sizeof ( * sockaddr ) ) ; "
1764,"<S2SV_StartBug> ghash_flush ( ctx , dctx ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! ctx -> gf128 ) return - ENOKEY ; 
1765,"<S2SV_StartBug> LPSTR tmp = NULL ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( NULL == tmp ) <S2SV_EndBug> ",<S2SV_ModStart> = NULL ; LPSTR tmp2 <S2SV_ModStart> { tmp2 <S2SV_ModEnd> <S2SV_ModStart> if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 ; } <S2SV_ModStart> tmp2 <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> tmp2 <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> tmp2 <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> tmp2 <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> tmp2 <S2SV_ModEnd> <S2SV_ModStart> ! tmp2 ) free ( tmp ) ; tmp = tmp2 ; if ( 
1766,"<S2SV_StartBug> int number_bidders , i , bid , best_bid ; <S2SV_EndBug> <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , n <S2SV_ModStart> n = 0 ; n < 25 ; ++ n <S2SV_ModEnd> <S2SV_ModStart> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Input<S2SV_blank>requires<S2SV_blank>too<S2SV_blank>many<S2SV_blank>filters<S2SV_blank>for<S2SV_blank>decoding"" ) ; return ( ARCHIVE_FATAL ) ; "
1767,<S2SV_StartBug> if ( newlen < SDS_MAX_PREALLOC ) <S2SV_EndBug> <S2SV_StartBug> hdrlen = sdsHdrSize ( type ) ; <S2SV_EndBug> ,<S2SV_ModStart> assert ( newlen > len ) ; <S2SV_ModStart> ) ; assert ( hdrlen + newlen + 1 > len 
1768,"<S2SV_StartBug> if ( ip_options_echo ( & icmp_param -> replyopts , skb ) ) <S2SV_EndBug> <S2SV_StartBug> if ( icmp_param -> replyopts . optlen ) { <S2SV_EndBug> <S2SV_StartBug> ipc . opt = & icmp_param -> replyopts ; <S2SV_EndBug> <S2SV_StartBug> daddr = icmp_param -> replyopts . faddr ; <S2SV_EndBug> ",<S2SV_ModStart> . opt . opt <S2SV_ModStart> opt . opt . <S2SV_ModStart> . opt ; if ( ipc . opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> . opt . opt 
1769,<S2SV_StartBug> if ( bmp_info . number_colors > GetBlobSize ( image ) ) <S2SV_EndBug> <S2SV_StartBug> * magick = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> if ( bmp_info . ba_offset != 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( offset < 0 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> ( MagickSizeType ) <S2SV_ModStart> offset = ( MagickOffsetType ) <S2SV_ModEnd> <S2SV_ModStart> ; if ( offset <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) <S2SV_ModEnd> <S2SV_ModStart> * magick = '\\0' ; <S2SV_ModEnd> "
1770,"<S2SV_StartBug> u_int tlen , pdu_type , pdu_len ; <S2SV_EndBug> <S2SV_StartBug> while ( tlen >= sizeof ( rpki_rtr_pdu ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( rpki_rtr_pdu_print ( ndo , tptr , 8 ) ) <S2SV_EndBug> <S2SV_StartBug> tptr += pdu_len ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> len ) { u_int pdu_len = <S2SV_ModEnd> <S2SV_ModStart> pptr , len , 1 <S2SV_ModEnd> <S2SV_ModStart> ; len <S2SV_ModEnd> <S2SV_ModStart> pptr <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1771,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""%sBandwidth<S2SV_blank>Constraints<S2SV_blank>Model<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(%u)"" , <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , 4 ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( subl == 0 ) break ; <S2SV_ModStart>  <S2SV_ModEnd> 
1772,<S2SV_StartBug> settings . udpport = 11211 ; <S2SV_EndBug> ,<S2SV_ModStart> 0 <S2SV_ModEnd> 
1773,"<S2SV_StartBug> CU_add_test ( parserTestSuite , ""Parse<S2SV_blank>Exchange"" , test_parserComplete ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""Parse<S2SV_blank>hvi<S2SV_blank>check<S2SV_blank>fail"" , test_parser_hvi ) ; CU_add_test ( parserTestSuite , "
1774,<S2SV_StartBug> bprm -> interp = iname ; <S2SV_EndBug> ,"<S2SV_ModStart> retval = bprm_change_interp ( iname , bprm ) ; if ( retval < 0 ) goto _error <S2SV_ModEnd> "
1775,"<S2SV_StartBug> yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ; <S2SV_EndBug> <S2SV_StartBug> yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ; <S2SV_EndBug> <S2SV_StartBug> yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" <S2SV_ModEnd> <S2SV_ModStart> ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" <S2SV_ModEnd> <S2SV_ModStart> ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" <S2SV_ModEnd> "
1776,"<S2SV_StartBug> unsigned int sse = INT_MAX , best_rd_sse = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> unsigned int zero_mv_sse = INT_MAX , best_sse = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> int sf_improved_mv_pred = cpi -> sf . improved_mv_pred ; <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_EndBug> <S2SV_StartBug> int parent_ref_valid = cpi -> oxcf . mr_encoder_id && cpi -> mr_low_res_mv_avail ; <S2SV_EndBug> <S2SV_StartBug> parent_ref_flag = ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> mode_mv = mode_mv_sb [ sign_bias ] ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( & best_mbmode , 0 , sizeof ( best_mbmode ) ) ; <S2SV_EndBug> <S2SV_StartBug> get_predictor_pointers ( cpi , plane , recon_yoffset , recon_uvoffset ) ; <S2SV_EndBug> <S2SV_StartBug> calculate_zeromv_rd_adjustment ( cpi , x , & rd_adjustment ) ; <S2SV_EndBug> <S2SV_StartBug> distortion2 = vp8_variance16x16 ( <S2SV_EndBug> <S2SV_StartBug> distortion2 = vp8_variance16x16 <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . mr_encoder_id && ! parent_ref_valid ) <S2SV_EndBug> <S2SV_StartBug> if ( parent_ref_valid && parent_ref_frame ) <S2SV_EndBug> <S2SV_StartBug> if ( parent_ref_valid && parent_ref_frame && dissim <= 2 && <S2SV_EndBug> <S2SV_StartBug> if ( ! parent_ref_valid ) <S2SV_EndBug> <S2SV_StartBug> rate2 += vp8_mv_bit_cost ( & mode_mv [ NEWMV ] , & best_ref_mv , <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( this_mode == ZEROMV && sse < zero_mv_sse ) <S2SV_EndBug> <S2SV_StartBug> sse < best_sse ) <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & best_mbmode , & x -> e_mbd . mode_info_context -> mbmi , <S2SV_EndBug> <S2SV_StartBug> if ( x -> best_sse_inter_mode == DC_PRED ) <S2SV_EndBug> <S2SV_StartBug> vp8_denoiser_denoise_mb ( & cpi -> denoiser , x , best_sse , zero_mv_sse , <S2SV_EndBug> <S2SV_StartBug> recon_yoffset , recon_uvoffset ) ; <S2SV_EndBug> <S2SV_StartBug> if ( best_mbmode . ref_frame == INTRA_FRAME && <S2SV_EndBug> <S2SV_StartBug> rate2 = x -> ref_frame_cost [ this_ref_frame ] + <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & best_mbmode , & x -> e_mbd . mode_info_context -> mbmi , <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mbmode , <S2SV_EndBug> ","<S2SV_ModStart> UINT_MAX <S2SV_ModEnd> <S2SV_ModStart> UINT_MAX <S2SV_ModEnd> <S2SV_ModStart> UINT_MAX <S2SV_ModEnd> <S2SV_ModStart> UINT_MAX <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_MULTI_RES_ENCODING int dissim = INT_MAX ; int parent_ref_frame = 0 ; int_mv parent_ref_mv ; MB_PREDICTION_MODE parent_mode = 0 ; int parent_ref_valid = 0 ; # endif <S2SV_ModStart> int dot_artifact_candidate = 0 ; get_predictor_pointers ( cpi , plane , recon_yoffset , recon_uvoffset ) ; if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) { unsigned char * target_y = x -> src . y_buffer ; unsigned char * target_u = x -> block [ 16 ] . src + * x -> block [ 16 ] . base_src ; unsigned char * target_v = x -> block [ 20 ] . src + * x -> block [ 20 ] . base_src ; int stride = x -> src . y_stride ; int stride_uv = x -> block [ 16 ] . src_stride ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { const int uv_denoise = ( cpi -> oxcf . noise_sensitivity >= 2 ) ? 1 : 0 ; target_y = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . y_buffer + recon_yoffset ; stride = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . y_stride ; if ( uv_denoise ) { target_u = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . u_buffer + recon_uvoffset ; target_v = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . v_buffer + recon_uvoffset ; stride_uv = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . uv_stride ; } } # endif dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_y , stride , plane [ LAST_FRAME ] [ 0 ] , mb_row , mb_col , 0 ) ; if ( ! dot_artifact_candidate ) { dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_u , stride_uv , plane [ LAST_FRAME ] [ 1 ] , mb_row , mb_col , 1 ) ; if ( ! dot_artifact_candidate ) { dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_v , stride_uv , plane [ LAST_FRAME ] [ 2 ] , mb_row , mb_col , 2 ) ; } } } # if CONFIG_MULTI_RES_ENCODING <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( dot_artifact_candidate ) parent_ref_valid = 0 ; <S2SV_ModStart> { const int y = x -> src . y_buffer [ 7 * x -> src . y_stride + 7 ] ; const int cb = x -> src . u_buffer [ 3 * x -> src . uv_stride + 3 ] ; const int cr = x -> src . v_buffer [ 3 * x -> src . uv_stride + 3 ] ; x -> is_skin = 0 ; if ( ! cpi -> oxcf . screen_content_mode ) x -> is_skin = is_skin_color ( y , cb , cr ) ; } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { } # endif <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> Speed < 12 ) { <S2SV_ModStart> } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { rd_adjustment = ( int ) ( rd_adjustment * cpi -> denoiser . denoise_pars . pickmode_mv_bias / 100 ) ; } # endif if ( dot_artifact_candidate ) { rd_adjustment = 150 ; } <S2SV_ModStart> vpx_variance16x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance16x16 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( parent_ref_frame == this_ref_frame ) <S2SV_ModEnd> <S2SV_ModStart> ( parent_ref_frame == this_ref_frame ) <S2SV_ModEnd> <S2SV_ModStart> || ( parent_ref_frame != this_ref_frame ) <S2SV_ModStart> vp8_clamp_mv2 ( & mode_mv [ this_mode ] , xd ) ; <S2SV_ModStart> int skip_old_reference = ( ( this_ref_frame != LAST_FRAME ) && ( cpi -> common . current_video_frame - cpi -> current_ref_frames [ this_ref_frame ] > MAX_GF_ARF_DENOISE_RANGE ) ) ? 1 : 0 ; <S2SV_ModStart> && ! skip_old_reference <S2SV_ModStart> && ! skip_old_reference <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> int block_index = mb_row * cpi -> common . mb_cols + mb_col ; int reevaluate = 0 ; int is_noisy = 0 ; <S2SV_ModStart> if ( cpi -> oxcf . noise_sensitivity == 4 ) { if ( cpi -> denoiser . nmse_source_diff > 70 * cpi -> denoiser . threshold_aggressive_mode / 100 ) is_noisy = 1 ; } else { if ( cpi -> mse_source_denoised > 1000 ) is_noisy = 1 ; } x -> increase_denoising = 0 ; if ( ! x -> is_skin && x -> best_sse_inter_mode == ZEROMV && ( x -> best_reference_frame == LAST_FRAME || x -> best_reference_frame == cpi -> closest_reference_frame ) && cpi -> consec_zero_last [ block_index ] >= 20 && is_noisy ) { x -> increase_denoising = 1 ; } x -> denoise_zeromv = 0 ; <S2SV_ModStart> , & cpi -> common . lf_info , mb_row , mb_col , block_index ) ; reevaluate = <S2SV_ModEnd> <S2SV_ModStart> ) || ( best_mbmode . mode != ZEROMV && x -> denoise_zeromv && cpi -> mse_source_denoised > 2000 ) ; if ( ! dot_artifact_candidate && reevaluate <S2SV_ModStart> rd_adjustment = 100 ; <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> "
1777,<S2SV_StartBug> if ( err ) <S2SV_EndBug> ,<S2SV_ModStart> < 0 
1778,<S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> ,<S2SV_ModStart> { if ( unlikely ( ! try_get_page ( page ) ) ) { page = ERR_PTR ( - ENOMEM ) ; goto out ; } } <S2SV_ModEnd> 
1779,"<S2SV_StartBug> int this_frame_target , <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> int recode_tolerance = <S2SV_EndBug> <S2SV_StartBug> ( cpi -> sf . recode_tolerance * this_frame_target ) / 100 ; <S2SV_EndBug> <S2SV_StartBug> * frame_over_shoot_limit = this_frame_target + recode_tolerance ; <S2SV_EndBug> <S2SV_StartBug> * frame_over_shoot_limit += 200 ; <S2SV_EndBug> <S2SV_StartBug> if ( * frame_over_shoot_limit > cpi -> rc . max_frame_bandwidth ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> frame_target <S2SV_ModEnd> <S2SV_ModStart> rc_mode == VPX_Q <S2SV_ModEnd> <S2SV_ModStart> const int tolerance <S2SV_ModEnd> <S2SV_ModStart> frame_target <S2SV_ModEnd> <S2SV_ModStart> frame_under_shoot_limit = MAX ( frame_target - tolerance - 200 , 0 ) <S2SV_ModEnd> <S2SV_ModStart> = MIN ( frame_target + tolerance + 200 , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1780,<S2SV_StartBug> if ( asn1_com_prkey_attr -> flags & SC_ASN1_PRESENT && <S2SV_EndBug> ,<S2SV_ModStart> free ( info . subject . value ) ; <S2SV_ModEnd> 
1781,<S2SV_StartBug> down_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( id . index > UINT_MAX - kcontrol -> count ) goto error ; 
1782,<S2SV_StartBug> if ( ! fs_searchpaths ) <S2SV_EndBug> <S2SV_StartBug> for ( search = fs_searchpaths ; search ; search = search -> next ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> qboolean isLocalConfig ; <S2SV_ModStart> isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> if ( isLocalConfig && search -> pack ) continue ; "
1783,<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> ,<S2SV_ModStart> void 
1784,"<S2SV_StartBug> ret = arg ( name , annotation , LINENO ( n ) , n -> n_col_offset , <S2SV_EndBug> ","<S2SV_ModStart> NULL , "
1785,"<S2SV_StartBug> else if ( strcmp ( arg , ""@@"" ) == 0 || strcmp ( arg , ""@@u"" ) == 0 ) <S2SV_EndBug> ",<S2SV_ModStart> g_str_has_prefix <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1786,<S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ; <S2SV_EndBug> <S2SV_StartBug> lrc -> av_per_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; <S2SV_EndBug> <S2SV_StartBug> lrc -> min_frame_bandwidth = ( int ) ( lrc -> av_per_frame_bandwidth * <S2SV_EndBug> <S2SV_StartBug> lrc -> max_frame_bandwidth = ( int ) ( ( ( int64_t ) lrc -> av_per_frame_bandwidth * <S2SV_EndBug> <S2SV_StartBug> lrc -> max_gf_interval = 16 ; <S2SV_EndBug> ,"<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> vp9_rc_set_gf_interval_range ( cpi , lrc ) <S2SV_ModEnd> "
1787,"<S2SV_StartBug> register int i ; <S2SV_EndBug> <S2SV_StartBug> raw_printf ( ""No<S2SV_blank>window<S2SV_blank>types?"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( windowprocs . win_raw_print == def_raw_print <S2SV_EndBug> ","<S2SV_ModStart> int i ; char * tmps = 0 <S2SV_ModEnd> <S2SV_ModStart> ""No<S2SV_blank>window<S2SV_blank>types<S2SV_blank>supported?"" <S2SV_ModEnd> <S2SV_ModStart> # define WINDOW_TYPE_MAXLEN 50 if ( strlen ( s ) >= WINDOW_TYPE_MAXLEN ) { tmps = ( char * ) alloc ( WINDOW_TYPE_MAXLEN ) ; ( void ) strncpy ( tmps , s , WINDOW_TYPE_MAXLEN - 1 ) ; tmps [ WINDOW_TYPE_MAXLEN - 1 ] = '\\0' ; s = tmps ; } # undef WINDOW_TYPE_MAXLEN <S2SV_ModStart> tmps ) free ( ( genericptr_t ) tmps ) ; if ( "
1788,"<S2SV_StartBug> ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , <S2SV_EndBug> <S2SV_StartBug> ( const UWORD8 * ) & ps_codec -> s_parse . s_cabac . au1_ctxt_models_sync ) ; <S2SV_EndBug> <S2SV_StartBug> if ( 0 == end_of_pic ) <S2SV_EndBug> ",<S2SV_ModStart> ret = <S2SV_ModStart> if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } <S2SV_ModStart> ret = <S2SV_ModStart> if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } <S2SV_ModStart> ret = <S2SV_ModStart> if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } <S2SV_ModStart> ret = <S2SV_ModStart> if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } <S2SV_ModStart> ps_codec -> i4_slice_error = 0 ; 
1789,"<S2SV_StartBug> if ( NGX_DECLINED == ngx_http_auth_spnego_basic ( r , ctx , alcf ) ) { <S2SV_EndBug> ",<S2SV_ModStart> NGX_OK != <S2SV_ModEnd> 
1790,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>ho=0x%04x<S2SV_blank>co=0x%04x)"" , <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_TCHECK_16BITS ( & bp [ i + 4 ] ) ; 
1791,<S2SV_StartBug> return sizeof ( vpx_codec_alg_priv_t ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( void ) flags ; 
1792,"<S2SV_StartBug> dtls1_record_bitmap_update ( s , & ( s -> d1 -> bitmap ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1793,"<S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 256UL , image -> rows * <S2SV_EndBug> ",<S2SV_ModStart> 257UL <S2SV_ModEnd> 
1794,<S2SV_StartBug> struct pipe_buffer * buf ; <S2SV_EndBug> <S2SV_StartBug> orig_sz = size ; <S2SV_EndBug> <S2SV_StartBug> if ( off ) <S2SV_EndBug> <S2SV_StartBug> size += off - pipe -> bufs [ idx ] . offset ; <S2SV_EndBug> <S2SV_StartBug> if ( size <= buf -> len ) <S2SV_EndBug> <S2SV_StartBug> size -= buf -> len ; <S2SV_EndBug> <S2SV_StartBug> buf -> len = size ; <S2SV_EndBug> <S2SV_StartBug> off = i -> iov_offset = buf -> offset + size ; <S2SV_EndBug> <S2SV_StartBug> i -> count -= orig_sz ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> struct pipe_buffer * buf ; size_t off = i -> iov_offset , left = size ; int idx = i -> idx ; <S2SV_ModStart> left <S2SV_ModEnd> <S2SV_ModStart> left <S2SV_ModEnd> <S2SV_ModStart> left <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> left ; <S2SV_ModEnd> <S2SV_ModStart> size ; pipe_truncate ( i ) <S2SV_ModEnd> "
1795,<S2SV_StartBug> if ( cs > CQSPI_MAX_CHIPSELECT ) { <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> 
1796,"<S2SV_StartBug> goto unmap_pages ; <S2SV_EndBug> <S2SV_StartBug> kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn ) ; <S2SV_EndBug> ","<S2SV_ModStart> kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_ModStart> - slot -> base_gfn "
1797,"<S2SV_StartBug> struct key * find_keyring_by_name ( const char * name , bool skip_perm_check ) <S2SV_EndBug> <S2SV_StartBug> if ( ! skip_perm_check && <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> ","<S2SV_ModStart> uid_keyring <S2SV_ModEnd> <S2SV_ModStart> uid_keyring ) { if ( ! test_bit ( KEY_FLAG_UID_KEYRING , & keyring -> flags ) ) continue ; } else { if ( <S2SV_ModEnd> <S2SV_ModStart> } "
1798,<S2SV_StartBug> char * identifier ; <S2SV_EndBug> <S2SV_StartBug> return ERROR_INSUFFICIENT_MEMORY ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> r1 . o = function -> return_obj ; <S2SV_EndBug> <S2SV_StartBug> yr_modules_unload_all ( context ) ; <S2SV_EndBug> ,"<S2SV_ModStart> YR_OBJECT * * obj_ptr ; YR_ARENA * obj_arena ; <S2SV_ModStart> ; FAIL_ON_ERROR_WITH_CLEANUP ( yr_arena_create ( 1024 , 0 , & obj_arena ) , yr_free ( stack ) ) <S2SV_ModStart> assert ( sp == 0 ) ; <S2SV_ModStart> result = yr_object_copy ( function -> return_obj , & <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( result == ERROR_SUCCESS ) result = yr_arena_write_data ( obj_arena , & r1 . o , sizeof ( r1 . o ) , NULL ) ; stop = ( result != ERROR_SUCCESS ) ; push ( r1 ) ; <S2SV_ModEnd> <S2SV_ModStart> obj_ptr = ( YR_OBJECT * * ) yr_arena_base_address ( obj_arena ) ; while ( obj_ptr != NULL ) { yr_object_destroy ( * obj_ptr ) ; obj_ptr = ( YR_OBJECT * * ) yr_arena_next_address ( obj_arena , obj_ptr , sizeof ( YR_OBJECT * ) ) ; } yr_arena_destroy ( obj_arena ) ; "
1799,"<S2SV_StartBug> res = ctx -> iface -> dec . get_si ( ctx -> priv -> alg_priv , si ) ; <S2SV_EndBug> ",<S2SV_ModStart> get_alg_priv ( ctx ) <S2SV_ModEnd> 
1800,<S2SV_StartBug> static void nsc_encode_subsampling ( NSC_CONTEXT * context ) <S2SV_EndBug> <S2SV_StartBug> BYTE * co_dst ; <S2SV_EndBug> <S2SV_StartBug> UINT32 tempHeight ; <S2SV_EndBug> <S2SV_StartBug> for ( y = 0 ; y < tempHeight >> 1 ; y ++ ) <S2SV_EndBug> <S2SV_StartBug> co_dst = context -> priv -> PlaneBuffers [ 1 ] + y * ( tempWidth >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> cg_dst = context -> priv -> PlaneBuffers [ 2 ] + y * ( tempWidth >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> co_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 1 ] + ( y << 1 ) * tempWidth ; <S2SV_EndBug> <S2SV_StartBug> co_src1 = co_src0 + tempWidth ; <S2SV_EndBug> <S2SV_StartBug> cg_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 2 ] + ( y << 1 ) * tempWidth ; <S2SV_EndBug> <S2SV_StartBug> cg_src1 = cg_src0 + tempWidth ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! context ) return FALSE <S2SV_ModStart> if ( tempHeight == 0 ) return FALSE ; if ( tempWidth > context -> priv -> PlaneBuffersLength / tempHeight ) return FALSE ; <S2SV_ModStart> BYTE * <S2SV_ModStart> BYTE * <S2SV_ModStart> const INT8 * <S2SV_ModStart> const INT8 * <S2SV_ModStart> const INT8 * <S2SV_ModStart> const INT8 * <S2SV_ModStart> return TRUE ; 
1801,"<S2SV_StartBug> ngx_http_lua_copy_request_headers ( ngx_http_request_t * sr , ngx_http_request_t * r ) <S2SV_EndBug> <S2SV_StartBug> ngx_table_elt_t * header ; <S2SV_EndBug> <S2SV_StartBug> ngx_uint_t i ; <S2SV_EndBug> <S2SV_StartBug> dd ( ""before:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , <S2SV_EndBug> <S2SV_StartBug> ( int ) r -> headers_in . headers . part . nelts ) ; <S2SV_EndBug> <S2SV_StartBug> if ( part -> next == NULL ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ( int ) r -> headers_in . headers . part . nelts ) ; <S2SV_EndBug> ","<S2SV_ModStart> pr , int pr_not_chunked <S2SV_ModEnd> <S2SV_ModStart> clh , * <S2SV_ModStart> ; u_char * p ; off_t len ; dd ( ""before:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , ( int ) pr -> headers_in . headers . part . nelts ) <S2SV_ModStart> if ( sr -> request_body && ! pr_not_chunked ) { len = sr -> request_body -> buf ? ngx_buf_size ( sr -> request_body -> buf ) : 0 ; clh = ngx_list_push ( & sr <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( clh <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> clh -> hash = ngx_http_lua_content_length_hash ; clh -> key = ngx_http_lua_content_length_header_key ; clh -> lowcase_key = ngx_pnalloc ( sr -> pool , clh -> key . len ) ; if ( clh -> lowcase_key == NULL ) { return NGX_ERROR ; } ngx_strlow ( clh -> lowcase_key , clh -> key . data , clh -> key . len ) ; p = ngx_palloc ( sr -> pool , NGX_OFF_T_LEN ) ; if ( p == NULL ) { return NGX_ERROR ; } clh -> value . data = p ; clh -> value . len = ngx_sprintf ( clh -> value . data , ""%O"" , len ) - clh -> value . data ; sr -> headers_in . content_length = clh ; sr -> headers_in . content_length_n = len ; dd ( ""sr<S2SV_blank>crafted<S2SV_blank>content-length:<S2SV_blank>%.*s"" , ( int ) sr -> headers_in . content_length -> value . len , sr -> headers_in . content_length -> value . data ) ; } part = & pr -> headers_in . headers . part ; header = part -> elts ; for ( i = 0 ; ; i ++ ) { if ( i >= part -> nelts ) { if ( part -> next == NULL ) { break ; } part = part -> next ; header = part -> elts ; i = 0 ; } if ( ! pr_not_chunked && header [ i ] . key . len == sizeof ( ""Content-Length"" ) - 1 && ngx_strncasecmp ( header [ i ] . key . data , ( u_char * ) ""Content-Length"" , sizeof ( ""Content-Length"" ) - 1 ) == 0 ) { continue ; } dd ( ""sr<S2SV_blank>copied<S2SV_blank>req<S2SV_blank>header<S2SV_blank>%.*s:<S2SV_blank>%.*s"" , ( int ) header [ i ] . key . len , header [ i ] . key . data , ( int ) header [ i ] . value . len , header [ i ] . value . data ) ; if ( ngx_http_lua_set_input_header ( sr , header [ i ] . key , header [ i ] . value , 0 ) == NGX_ERROR ) { return NGX_ERROR ; } } dd ( <S2SV_ModEnd> <S2SV_ModStart> pr <S2SV_ModEnd> "
1802,"<S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> vp9_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ BLOCK_16X16 ] ; <S2SV_EndBug> <S2SV_StartBug> int step_param = cpi -> sf . reduce_first_step_size + <S2SV_EndBug> <S2SV_StartBug> step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_hex_search ( x , & ref_full , step_param , x -> errorperbit , 0 , & v_fn_ptr , 0 , <S2SV_EndBug> <S2SV_StartBug> & v_fn_ptr , 0 , cpi -> sf . subpel_iters_per_step , NULL , NULL , & distortion , <S2SV_EndBug> <S2SV_StartBug> & sse ) ; <S2SV_EndBug> <S2SV_StartBug> return vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <S2SV_EndBug> <S2SV_StartBug> xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride , <S2SV_EndBug> ","<S2SV_ModStart> td . <S2SV_ModStart> const MV_SPEED_FEATURES * const mv_sf = & cpi -> sf . mv ; const <S2SV_ModStart> cost_list [ 5 ] ; int step_param = mv_sf -> reduce_first_step_size <S2SV_ModEnd> <S2SV_ModStart> MAX_MVSEARCH_STEPS - 2 <S2SV_ModEnd> <S2SV_ModStart> cond_cost_list ( cpi , cost_list ) , <S2SV_ModStart> mv_sf -> subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , <S2SV_ModEnd> <S2SV_ModStart> , NULL , 0 , 0 <S2SV_ModStart> vpx_sad16x16 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1803,"<S2SV_StartBug> int secure_decrypt ( void * data , unsigned int data_length , int is_signed ) <S2SV_EndBug> <S2SV_StartBug> at91_aes_key_size_t key_size ; <S2SV_EndBug> <S2SV_StartBug> init_keys ( & key_size , cipher_key , cmac_key , iv ) ; <S2SV_EndBug> <S2SV_StartBug> memset ( cmac_key , 0 , sizeof ( cmac_key ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> static <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if defined ( CONFIG_AES_KEY_SIZE_128 ) key_size = AT91_AES_KEY_SIZE_128 ; # elif defined ( CONFIG_AES_KEY_SIZE_192 ) key_size = AT91_AES_KEY_SIZE_192 ; # elif defined ( CONFIG_AES_KEY_SIZE_256 ) key_size = AT91_AES_KEY_SIZE_256 ; # else # error ""bad<S2SV_blank>AES<S2SV_blank>key<S2SV_blank>size"" # endif <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1804,"<S2SV_StartBug> o = 2 ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < nelements ; j ++ , i ++ ) { <S2SV_EndBug> ","<S2SV_ModStart> if ( nelements == 0 ) { DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\n"" ) ) ; goto out ; } <S2SV_ModStart> && i < sh . sh_properties ; <S2SV_ModEnd> "
1805,<S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n"" , __func__ , type ) ; return <S2SV_ModEnd> "
1806,<S2SV_StartBug> if ( image_info -> ping != MagickFalse ) <S2SV_EndBug> ,"<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
1807,<S2SV_StartBug> if ( ! adis -> buffer ) <S2SV_EndBug> <S2SV_StartBug> tx = adis -> buffer + burst_length ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree ( adis -> xfer ) ; adis -> xfer = NULL ; <S2SV_ModStart> } 
1808,<S2SV_StartBug> dst_reg -> id = ptr_reg -> id ; <S2SV_EndBug> <S2SV_StartBug> __update_reg_bounds ( dst_reg ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL <S2SV_ModStart> if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ; "
1809,"<S2SV_StartBug> Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; return ; } if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) { Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".cfg\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" "
1810,<S2SV_StartBug> usleep ( 250000 ) ; <S2SV_EndBug> ,<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1811,"<S2SV_StartBug> static void update_mv_probs ( vp9_prob * p , int n , vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> if ( vp9_read ( r , MV_UPDATE_PROB ) ) <S2SV_EndBug> <S2SV_StartBug> p [ i ] = ( vp9_read_literal ( r , 7 ) << 1 ) | 1 ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> vpx_read_literal <S2SV_ModEnd> 
1812,"<S2SV_StartBug> if ( copy_to_user ( uaddr , ( ( u32 * ) regs ) + off , KVM_REG_SIZE ( reg -> id ) ) ) <S2SV_EndBug> ",<S2SV_ModStart> validate_core_offset ( reg ) ) return - EINVAL ; if ( 
1813,<S2SV_StartBug> mk_vhost_close ( sr ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sr -> fd_is_fdt == MK_TRUE ) { <S2SV_ModStart> } else { close ( sr -> fd_file ) ; } 
1814,<S2SV_StartBug> while ( ( tmpName [ i ] != 0 ) && ( i < to_read ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( i < to_read ) && <S2SV_ModStart>  <S2SV_ModEnd> 
1815,"<S2SV_StartBug> int err = 0 ; <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_zeroout ( inode , & orig_ex ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; BUG_ON ( ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) == ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) <S2SV_ModStart> if ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) { if ( split_flag & EXT4_EXT_DATA_VALID1 ) err = ext4_ext_zeroout ( inode , ex2 ) ; else err = ext4_ext_zeroout ( inode , ex ) ; } else "
1816,"<S2SV_StartBug> long rem ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> ",<S2SV_ModStart> u32 <S2SV_ModEnd> <S2SV_ModStart> div_u64_rem <S2SV_ModEnd> 
1817,<S2SV_StartBug> hndl = sock_diag_lock_handler ( req -> sdiag_family ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( req -> sdiag_family >= AF_MAX ) return - EINVAL ; 
1818,<S2SV_StartBug> goto end ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1819,"<S2SV_StartBug> l2tp_bearer_type_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> <S2SV_StartBug> const uint32_t * ptr = ( const uint32_t * ) dat ; <S2SV_EndBug> ","<S2SV_ModStart> , u_int length <S2SV_ModStart> if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } "
1820,"<S2SV_StartBug> # line 94 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 95 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 96 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 97 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 100 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 99 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 98 ""hex_grammar.y"" <S2SV_EndBug> ","<S2SV_ModStart> 101 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1030 <S2SV_ModEnd> <S2SV_ModStart> 102 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1036 <S2SV_ModEnd> <S2SV_ModStart> 103 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1042 <S2SV_ModEnd> <S2SV_ModStart> 104 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1048 <S2SV_ModEnd> <S2SV_ModStart> 107 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1054 <S2SV_ModEnd> <S2SV_ModStart> 106 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1060 <S2SV_ModEnd> <S2SV_ModStart> 105 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1066 <S2SV_ModEnd> "
1821,"<S2SV_StartBug> if ( ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , index_key ) ) { <S2SV_EndBug> ",<S2SV_ModStart> assoc_array_ptr_is_leaf ( ptr ) && 
1822,"<S2SV_StartBug> if ( memcmp ( & name [ 2 ] , & content_name [ 2 ] , 31L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . content = fi ; <S2SV_EndBug> <S2SV_StartBug> else if ( memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . control = fi ; <S2SV_EndBug> <S2SV_StartBug> else if ( memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . spaninfo = fi ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> name_len == 40 && memcmp ( name , content_name , 40 <S2SV_ModEnd> <S2SV_ModStart> chm -> sec1 . content = fi ; } else if ( name_len == 44 && memcmp ( name , control_name , 44 <S2SV_ModEnd> <S2SV_ModStart> control <S2SV_ModEnd> <S2SV_ModStart> name_len == 41 && memcmp ( name , spaninfo_name , 41 <S2SV_ModEnd> <S2SV_ModStart> spaninfo <S2SV_ModEnd> <S2SV_ModStart> name_len == 105 && memcmp ( name , rtable_name , 105 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1823,"<S2SV_StartBug> const char * args [ 11 ] ; <S2SV_EndBug> <S2SV_StartBug> args [ i ++ ] = ""--"" ; <S2SV_EndBug> <S2SV_StartBug> execvp ( EXECUTABLE , ( char * * ) args ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> char tmp_directory [ ] = LARGE_DATA_TMP_DIR ""/abrt-tmp-debuginfo.XXXXXX"" ; if ( mkdtemp ( tmp_directory ) == NULL ) perror_msg_and_die ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>working<S2SV_blank>directory"" ) ; log_info ( ""Created<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , tmp_directory ) ; const char * args [ 13 <S2SV_ModEnd> <S2SV_ModStart> ""--tmpdir"" ; args [ i ++ ] = tmp_directory ; args [ i ++ ] = <S2SV_ModStart> pid_t pid = fork ( ) ; if ( pid < 0 ) perror_msg_and_die ( ""fork"" ) ; if ( pid == 0 ) { <S2SV_ModStart> int status ; if ( safe_waitpid ( pid , & status , 0 ) < 0 ) perror_msg_and_die ( ""waitpid"" ) ; if ( rmdir ( tmp_directory ) >= 0 ) log_info ( ""Removed<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , tmp_directory ) ; else if ( errno != ENOENT ) perror_msg ( ""Failed<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>working<S2SV_blank>directory"" ) ; if ( WIFEXITED ( status ) ) return WEXITSTATUS ( status ) ; if ( WIFSIGNALED ( status ) ) error_msg_and_die ( ""Child<S2SV_blank>terminated<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d"" , WTERMSIG ( status ) ) ; error_msg_and_die ( ""Child<S2SV_blank>exit<S2SV_blank>failed"" ) ; } "
1824,<S2SV_StartBug> newinet -> opt = ireq -> opt ; <S2SV_EndBug> ,<S2SV_ModStart> inet_opt <S2SV_ModEnd> 
1825,"<S2SV_StartBug> isoclns_print ( ndo , p - 1 , length + 1 , ndo -> ndo_snapend - p + 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; break ; case NLPID_SNAP : if ( snap_print ( ndo , p , length <S2SV_ModStart>  <S2SV_ModEnd> "
1826,<S2SV_StartBug> return 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> # if OPENSSL_VERSION_NUMBER > 0x10002000L lua_pushliteral ( L , ""check_flag"" ) ; lua_newtable ( L ) ; auxiliar_enumerate ( L , - 1 , check_flags_const ) ; lua_settable ( L , - 3 ) ; # endif "
1827,<S2SV_StartBug> struct perf_event_context * ctx = event -> ctx ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> ,"<S2SV_ModStart> ; ctx = perf_event_ctx_lock <S2SV_ModEnd> <S2SV_ModStart> _perf_event_enable ( event ) ; perf_event_ctx_unlock ( event , ctx <S2SV_ModEnd> "
1828,"<S2SV_StartBug> validate_event ( struct pmu_hw_events * hw_events , <S2SV_EndBug> <S2SV_StartBug> struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ; <S2SV_EndBug> <S2SV_StartBug> if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) <S2SV_EndBug> <S2SV_StartBug> return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ; <S2SV_EndBug> ","<S2SV_ModStart> struct pmu * pmu , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pmu ) return 0 ; if ( event -> pmu != <S2SV_ModStart> armpmu = to_arm_pmu ( event -> pmu ) ; "
1829,<S2SV_StartBug> BOOL ret = FALSE ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> data = NULL ; <S2SV_EndBug> <S2SV_StartBug> ret = TRUE ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> return TRUE ; err : sud -> directory <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> FALSE <S2SV_ModEnd> 
1830,<S2SV_StartBug> u8 opcode = BPF_OP ( insn -> code ) ; <S2SV_EndBug> <S2SV_StartBug> if ( known && ( ptr_reg -> off + smin_val == <S2SV_EndBug> <S2SV_StartBug> if ( dst_reg == off_reg ) { <S2SV_EndBug> ,"<S2SV_ModStart> ; int ret <S2SV_ModStart> ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\n"" , dst ) ; return ret ; } <S2SV_ModStart> ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\n"" , dst ) ; return ret ; } "
1831,"<S2SV_StartBug> struct mb_cache_entry * ce = NULL ; <S2SV_EndBug> <S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_get ( ext4_mb_cache , bs -> bh -> b_bdev , <S2SV_EndBug> <S2SV_StartBug> if ( ce ) { <S2SV_EndBug> <S2SV_StartBug> if ( ce ) { <S2SV_EndBug> <S2SV_StartBug> le32_add_cpu ( & BHDR ( new_bh ) -> h_refcount , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> ","<S2SV_ModStart> mb2_cache_entry <S2SV_ModEnd> <S2SV_ModStart> mb2_cache <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> __u32 hash = le32_to_cpu ( BHDR ( bs -> bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( ext4_mb_cache , hash , bs -> bh -> b_blocknr ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) { unlock_buffer ( new_bh ) ; dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; brelse ( new_bh ) ; mb2_cache_entry_put ( ext4_mb_cache , ce ) ; ce = NULL ; new_bh = NULL ; goto inserted ; } <S2SV_ModStart> mb2_cache_entry_touch ( ext4_mb_cache , ce ) ; mb2_cache_entry_put ( ext4_mb_cache , <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_entry_put ( ext4_mb_cache , <S2SV_ModEnd> "
1832,"
","
"
1833,"<S2SV_StartBug> struct in6_addr * addr , uint32_t * ifindex ) <S2SV_EndBug> <S2SV_StartBug> unsigned char cbuf [ CMSG_SPACE ( sizeof ( struct in6_pktinfo ) ) ] ; <S2SV_EndBug> <S2SV_StartBug> if ( cmsghdr -> cmsg_level == IPPROTO_IPV6 && <S2SV_EndBug> <S2SV_StartBug> cmsghdr -> cmsg_type == IPV6_PKTINFO && <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , int * hoplimit <S2SV_ModStart> 2 * <S2SV_ModStart> != IPPROTO_IPV6 ) continue ; switch ( <S2SV_ModEnd> <S2SV_ModStart> ) { case IPV6_PKTINFO : if ( <S2SV_ModEnd> <S2SV_ModStart> break ; case IPV6_HOPLIMIT : if ( cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( int ) ) ) { int * val ; val = ( int * ) CMSG_DATA ( cmsghdr ) ; * hoplimit = * val ; } break ; } "
1834,<S2SV_StartBug> if ( mode > 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> != MODE_INVALID <S2SV_ModEnd> 
1835,"<S2SV_StartBug> struct address_space * mapping = inode -> i_mapping ; <S2SV_EndBug> <S2SV_StartBug> if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) { <S2SV_EndBug> <S2SV_StartBug> truncate_pagecache_range ( inode , start , end - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> flags , mode ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem 
1836,"<S2SV_StartBug> memcpy ( tp -> fw_ver , & vpd_data [ j ] , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( tp -> fw_ver , ""<S2SV_blank>bc<S2SV_blank>"" , vpdlen - len - 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( len >= sizeof <S2SV_ModEnd> <S2SV_ModStart> ) ) len = sizeof <S2SV_ModEnd> <S2SV_ModStart> ) - 1 ; memset ( tp -> fw_ver , 0 , sizeof ( tp -> fw_ver ) ) ; snprintf ( tp -> fw_ver , sizeof ( tp -> fw_ver ) , ""%.*s<S2SV_blank>bc<S2SV_blank>"" , len , & vpd_data [ j ] <S2SV_ModEnd> "
1837,<S2SV_StartBug> path -> mnt = mntget ( nd -> path . mnt ) ; <S2SV_EndBug> <S2SV_StartBug> follow_mount ( path ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mntget ( path -> mnt ) ; 
1838,<S2SV_StartBug> i ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { clear_bit ( WDM_OVERFLOW , & desc -> flags ) ; rv = - ENOBUFS ; goto err ; } "
1839,"<S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIREGADR , address & REG_ADDR_MASK ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MICMD , MICMD_MIIRD ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc28j60ReadReg ( interface , ENC28J60_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MICMD , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> data = enc28j60ReadReg ( interface , ENC28J60_REG_MIRDL ) ; <S2SV_EndBug> <S2SV_StartBug> data |= enc28j60ReadReg ( interface , ENC28J60_REG_MIRDH ) << 8 ; <S2SV_EndBug> ","<S2SV_ModStart> ENC28J60_MIREGADR <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MICMD , ENC28J60_MICMD_MIIRD <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MISTAT ) & ENC28J60_MISTAT_BUSY <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MICMD <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MIRDL <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MIRDH <S2SV_ModEnd> "
1840,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> sas_destruct_devices ( port ) ; sas_destruct_ports ( port ) ; sas_probe_devices ( port ) ; 
1841,"<S2SV_StartBug> mptctl_readtest ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <S2SV_EndBug> ","<S2SV_ModStart> MPT_ADAPTER * ioc , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1842,"<S2SV_StartBug> static void choose_partitioning ( VP9_COMP * cpi , <S2SV_EndBug> <S2SV_StartBug> int mi_row , int mi_col ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> int i , j , k ; <S2SV_EndBug> <S2SV_StartBug> v64x64 vt ; <S2SV_EndBug> <S2SV_StartBug> int_mv nearest_mv , near_mv ; <S2SV_EndBug> <S2SV_StartBug> const struct scale_factors * const sf = & cm -> frame_refs [ LAST_FRAME - 1 ] . sf ; <S2SV_EndBug> <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( xd -> mb_to_right_edge < 0 ) <S2SV_EndBug> <S2SV_StartBug> vp9_setup_pre_planes ( xd , 0 , yv12 , mi_row , mi_col , sf ) ; <S2SV_EndBug> <S2SV_StartBug> dp = xd -> plane [ 0 ] . dst . stride ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < 4 ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> const int y16_idx = y32_idx + ( ( j >> 1 ) << 4 ) ; <S2SV_EndBug> <S2SV_StartBug> for ( k = 0 ; k < 4 ; k ++ ) { <S2SV_EndBug> <S2SV_StartBug> int x_idx = x16_idx + ( ( k & 1 ) << 3 ) ; <S2SV_EndBug> <S2SV_StartBug> int y_idx = y16_idx + ( ( k >> 1 ) << 3 ) ; <S2SV_EndBug> <S2SV_StartBug> unsigned int sse = 0 ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < 4 ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> fill_variance_tree ( & vt . split [ i ] . split [ j ] , BLOCK_16X16 ) ; <S2SV_EndBug> <S2SV_StartBug> fill_variance_tree ( & vt . split [ i ] , BLOCK_32X32 ) ; <S2SV_EndBug> <S2SV_StartBug> fill_variance_tree ( & vt , BLOCK_64X64 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! set_vt_partitioning ( cpi , & vt , tile , BLOCK_64X64 , <S2SV_EndBug> <S2SV_StartBug> mi_row , mi_col , 8 ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] , tile , BLOCK_32X32 , <S2SV_EndBug> <S2SV_StartBug> ( mi_row + y32_idx ) , ( mi_col + x32_idx ) , 4 ) ) { <S2SV_EndBug> <S2SV_StartBug> # define DISABLE_8X8_VAR_BASED_PARTITION <S2SV_EndBug> <S2SV_StartBug> if ( mi_row + y32_idx + y16_idx + 1 < cm -> mi_rows && <S2SV_EndBug> <S2SV_StartBug> mi_row + x32_idx + x16_idx + 1 < cm -> mi_cols ) { <S2SV_EndBug> <S2SV_StartBug> set_block_size ( cpi , tile , <S2SV_EndBug> <S2SV_StartBug> if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] . split [ j ] , tile , <S2SV_EndBug> <S2SV_StartBug> ( mi_row + y32_idx + y16_idx ) , <S2SV_EndBug> <S2SV_StartBug> ( mi_col + x32_idx + x16_idx ) , 2 ) ) { <S2SV_EndBug> <S2SV_StartBug> set_block_size ( cpi , tile , <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , int mi_row , int mi_col ) { VP9_COMMON * const cm = & cpi -> common <S2SV_ModEnd> <S2SV_ModStart> x -> <S2SV_ModEnd> <S2SV_ModStart> , m <S2SV_ModStart> ; v16x16 vt2 [ 16 ] ; int force_split [ 21 ] <S2SV_ModStart> int64_t thresholds [ 4 ] = { cpi -> vbp_thresholds [ 0 ] , cpi -> vbp_thresholds [ 1 ] , cpi -> vbp_thresholds [ 2 ] , cpi -> vbp_thresholds [ 3 ] } ; const int is_key_frame = ( cm -> frame_type == KEY_FRAME ) ; const int use_4x4_partition = is_key_frame ; const int low_res = ( cm -> width <= 352 && cm -> height <= 288 ) ; int variance4x4downsample [ 16 ] ; int segment_id = CR_SEGMENT_ID_BASE ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) { const uint8_t * const map = cm -> seg . update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ; if ( cyclic_refresh_segment_id_boosted ( segment_id ) ) { int q = vp9_get_qindex ( & cm -> seg , segment_id , cm -> base_qindex ) ; set_vbp_thresholds ( cpi , thresholds , q ) ; } } set_offsets ( cpi , tile , x , mi_row , mi_col , BLOCK_64X64 ) ; if ( xd -> mb_to_right_edge < 0 ) pixels_wide += ( xd -> mb_to_right_edge >> 3 ) ; if ( xd -> mb_to_bottom_edge < 0 ) pixels_high += ( xd -> mb_to_bottom_edge >> 3 ) ; s = x -> plane [ 0 ] . src . buf ; sp = x -> plane [ 0 ] . src . stride ; if ( ! is_key_frame && ! ( is_one_pass_cbr_svc ( cpi ) && cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ) ) { MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; unsigned int uv_sad <S2SV_ModEnd> <S2SV_ModStart> YV12_BUFFER_CONFIG * yv12_g = NULL ; unsigned int y_sad , y_sad_g ; const BLOCK_SIZE bsize = BLOCK_32X32 + ( mi_col + 4 < cm -> mi_cols ) * 2 + ( mi_row + 4 < cm -> mi_rows ) ; assert ( yv12 != NULL ) ; if ( ! ( is_one_pass_cbr_svc ( cpi ) && cpi -> svc . spatial_layer_id ) ) { yv12_g = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; } if ( yv12_g && yv12_g != yv12 && ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) ) { vp9_setup_pre_planes ( xd , 0 , yv12_g , mi_row , mi_col , & cm -> frame_refs [ GOLDEN_FRAME - 1 ] . sf ) ; y_sad_g = cpi -> fn_ptr [ bsize ] . sdf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . pre [ 0 ] . buf , xd -> plane [ 0 ] . pre [ 0 ] . stride ) ; } else { y_sad_g = UINT_MAX ; } vp9_setup_pre_planes ( xd , 0 , yv12 , mi_row , mi_col , <S2SV_ModEnd> <S2SV_ModStart> ) ; mbmi -> ref_frame [ 0 ] = LAST_FRAME ; mbmi -> ref_frame [ 1 ] = NONE ; mbmi -> sb_type = BLOCK_64X64 ; mbmi -> mv [ 0 ] . as_int = 0 ; mbmi -> interp_filter = BILINEAR ; y_sad = vp9_int_pro_motion_estimation ( cpi , x , bsize <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( y_sad_g < y_sad ) { vp9_setup_pre_planes ( xd , 0 , yv12_g , mi_row , mi_col , & cm -> frame_refs [ GOLDEN_FRAME - 1 ] . sf ) ; mbmi -> ref_frame [ 0 ] = GOLDEN_FRAME ; mbmi -> mv [ 0 ] . as_int = 0 ; y_sad = y_sad_g ; } else { x -> pred_mv [ LAST_FRAME ] = mbmi -> mv [ 0 ] . as_mv ; } vp9_build_inter_predictors_sb ( xd , mi_row , mi_col <S2SV_ModStart> for ( i = 1 ; i <= 2 ; ++ i ) { struct macroblock_plane * p = & x -> plane [ i ] ; struct macroblockd_plane * pd = & xd -> plane [ i ] ; const BLOCK_SIZE bs = get_plane_block_size ( bsize , pd ) ; if ( bs == BLOCK_INVALID ) uv_sad = UINT_MAX ; else uv_sad = cpi -> fn_ptr [ bs ] . sdf ( p -> src . buf , p -> src . stride , pd -> dst . buf , pd -> dst . stride ) ; x -> color_sensitivity [ i - 1 ] = uv_sad > ( y_sad >> 2 ) ; } d = xd -> plane [ 0 ] . dst . buf ; dp = xd -> plane [ 0 ] . dst . stride ; if ( segment_id == CR_SEGMENT_ID_BASE && y_sad < cpi -> vbp_threshold_sad ) { const int block_width = num_8x8_blocks_wide_lookup [ BLOCK_64X64 ] ; const int block_height = num_8x8_blocks_high_lookup [ BLOCK_64X64 ] ; if ( mi_col + block_width / 2 < cm -> mi_cols && mi_row + block_height / 2 < cm -> mi_rows ) { set_block_size ( cpi , x , xd <S2SV_ModEnd> <S2SV_ModStart> BLOCK_64X64 ) ; return 0 ; } } } else { d = VP9_VAR_OFFS <S2SV_ModEnd> <S2SV_ModStart> 0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { switch ( xd -> bd ) { case 10 : d = CONVERT_TO_BYTEPTR ( VP9_HIGH_VAR_OFFS_10 ) ; break ; case 12 : d = CONVERT_TO_BYTEPTR ( VP9_HIGH_VAR_OFFS_12 ) ; break ; case 8 : default : d = CONVERT_TO_BYTEPTR ( VP9_HIGH_VAR_OFFS_8 ) ; break ; } } # endif } force_split [ 0 ] = 0 ; <S2SV_ModEnd> <S2SV_ModStart> const int i2 = i << 2 ; force_split [ i + 1 ] = 0 ; <S2SV_ModStart> ; const int split_index = 5 + i2 + j <S2SV_ModStart> force_split [ split_index ] = 0 ; variance4x4downsample [ i2 + j ] = 0 ; if ( ! is_key_frame ) { fill_variance_8x8avg ( s , sp , d , dp , x16_idx , y16_idx , vst , # if CONFIG_VP9_HIGHBITDEPTH xd -> cur_buf -> flags , # endif pixels_wide , pixels_high , is_key_frame ) ; fill_variance_tree ( & vt . split [ i ] . split [ j ] , BLOCK_16X16 ) ; get_variance ( & vt . split [ i ] . split [ j ] . part_variances . none ) ; if ( vt . split [ i ] . split [ j ] . part_variances . none . variance > thresholds [ 2 ] ) { force_split [ split_index ] = 1 ; force_split [ i + 1 ] = 1 ; force_split [ 0 ] = 1 ; } else if ( vt . split [ i ] . split [ j ] . part_variances . none . variance > thresholds [ 1 ] && ! cyclic_refresh_segment_id_boosted ( segment_id ) ) { int minmax = compute_minmax_8x8 ( s , sp , d , dp , x16_idx , y16_idx , # if CONFIG_VP9_HIGHBITDEPTH xd -> cur_buf -> flags , # endif pixels_wide , pixels_high ) ; if ( minmax > cpi -> vbp_threshold_minmax ) { force_split [ split_index ] = 1 ; force_split [ i + 1 ] = 1 ; force_split [ 0 ] = 1 ; } } } if ( is_key_frame || ( low_res && ! cpi -> use_svc && vt . split [ i ] . split [ j ] . part_variances . none . variance > ( thresholds [ 1 ] << 1 ) ) ) { force_split [ split_index ] = 0 ; variance4x4downsample [ i2 + j ] = 1 ; <S2SV_ModStart> x8_idx <S2SV_ModEnd> <S2SV_ModStart> y8_idx <S2SV_ModEnd> <S2SV_ModStart> v8x8 * vst2 = is_key_frame ? & vst -> split [ k ] : & vt2 [ i2 + j ] . split [ k ] ; fill_variance_4x4avg ( s , sp , d , dp , x8_idx , y8_idx , vst2 , # if CONFIG_VP9_HIGHBITDEPTH xd -> cur_buf -> flags , # endif pixels_wide , pixels_high , is_key_frame ) ; } <S2SV_ModEnd> <S2SV_ModStart> const int i2 = i << 2 ; <S2SV_ModStart> if ( variance4x4downsample [ i2 + j ] == 1 ) { v16x16 * vtemp = ( ! is_key_frame ) ? & vt2 [ i2 + j ] : & vt . split [ i ] . split [ j ] ; for ( m = 0 ; m < 4 ; m ++ ) <S2SV_ModStart> vtemp -> split [ m ] , BLOCK_8X8 ) ; fill_variance_tree ( vtemp , BLOCK_16X16 ) ; } } fill_variance_tree ( & <S2SV_ModStart> , BLOCK_32X32 ) ; if ( ! force_split [ i + 1 ] ) { get_variance ( & vt <S2SV_ModStart> i ] . part_variances . none ) ; if ( vt . split [ i ] . part_variances . none . variance > thresholds [ 1 ] ) { force_split [ i + 1 ] = 1 ; force_split [ 0 ] = 1 ; } } } if ( ! force_split [ 0 ] ) { <S2SV_ModEnd> <S2SV_ModStart> , BLOCK_64X64 ) ; get_variance <S2SV_ModEnd> <S2SV_ModStart> . part_variances . none ) ; } if ( mi_col + 8 > cm -> mi_cols || mi_row + 8 > cm -> mi_rows || <S2SV_ModEnd> <S2SV_ModStart> x , xd , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> thresholds [ 0 ] , BLOCK_16X16 , force_split [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> const int i2 = i << 2 ; <S2SV_ModStart> x , xd , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> thresholds [ 1 ] , BLOCK_16X16 , force_split [ i + 1 ] <S2SV_ModEnd> <S2SV_ModStart> v16x16 * vtemp = ( ! is_key_frame && variance4x4downsample [ i2 + j ] == 1 ) ? & vt2 [ i2 + j ] : & vt . split [ i ] . split [ j ] ; if ( ! set_vt_partitioning ( cpi , x , xd , vtemp , BLOCK_16X16 , <S2SV_ModEnd> <S2SV_ModStart> , mi_col <S2SV_ModEnd> <S2SV_ModStart> , thresholds [ 2 ] , cpi -> vbp_bsize_min , force_split [ 5 + i2 + j ] ) ) <S2SV_ModEnd> <S2SV_ModStart> if ( use_4x4_partition ) { <S2SV_ModEnd> <S2SV_ModStart> x , xd , & vtemp -> split [ k ] , BLOCK_8X8 , <S2SV_ModEnd> <S2SV_ModStart> + y8_idx , <S2SV_ModEnd> <S2SV_ModStart> + x8_idx , thresholds [ 3 ] , BLOCK_8X8 , 0 ) ) { set_block_size ( cpi , x , xd , ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_4X4 ) ; } } else { <S2SV_ModEnd> <S2SV_ModStart> x , xd <S2SV_ModEnd> <S2SV_ModStart> } } } } } return 0 ; <S2SV_ModEnd> "
1843,"<S2SV_StartBug> struct inode * inode , int regard_xa ) <S2SV_EndBug> <S2SV_StartBug> int cnt , sig ; <S2SV_EndBug> <S2SV_StartBug> if ( regard_xa ) { <S2SV_EndBug> <S2SV_StartBug> ISOFS_I ( inode ) -> i_first_extent = <S2SV_EndBug> <S2SV_StartBug> isofs_iget ( inode -> i_sb , <S2SV_EndBug> <S2SV_StartBug> ISOFS_I ( inode ) -> i_first_extent , <S2SV_EndBug> ","<S2SV_ModStart> flags <S2SV_ModEnd> <S2SV_ModStart> ; unsigned int reloc_block <S2SV_ModStart> flags & RR_REGARD_XA <S2SV_ModEnd> <S2SV_ModStart> if ( flags & RR_RELOC_DE ) { printk ( KERN_ERR ""ISOFS:<S2SV_blank>Recursive<S2SV_blank>directory<S2SV_blank>relocation<S2SV_blank>"" ""is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; goto eio ; } reloc_block = isonum_733 ( rr -> u . CL . location ) ; if ( reloc_block == <S2SV_ModStart> i_iget5_block && ISOFS_I ( inode ) -> i_iget5_offset == 0 ) { printk ( KERN_ERR ""ISOFS:<S2SV_blank>Directory<S2SV_blank>relocation<S2SV_blank>points<S2SV_blank>to<S2SV_blank>"" ""itself\\n"" ) ; goto eio ; } ISOFS_I ( inode ) -> i_first_extent = reloc_block <S2SV_ModEnd> <S2SV_ModStart> isofs_iget_reloc <S2SV_ModEnd> <S2SV_ModStart> reloc_block , <S2SV_ModEnd> "
1844,"<S2SV_StartBug> if ( perf_event_overflow ( event , 0 , & data , regs ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1845,<S2SV_StartBug> struct pstore * ps = get_info ( store ) ; <S2SV_EndBug> <S2SV_StartBug> stride = ( ps -> exceptions_per_area + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ps -> next_free ++ ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; skip_metadata ( ps ) 
1846,<S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug> ,<S2SV_ModStart> kfree_skb ( skb ) ; 
1847,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1848,"<S2SV_StartBug> * decorator_list , expr_ty returns , int lineno , int col_offset , <S2SV_EndBug> <S2SV_StartBug> p -> v . AsyncFunctionDef . returns = returns ; <S2SV_EndBug> ","<S2SV_ModStart> string type_comment , int <S2SV_ModEnd> <S2SV_ModStart> ; p -> v . AsyncFunctionDef . type_comment = type_comment "
1849,<S2SV_StartBug> frag = ( hm_fragment * ) item -> data ; <S2SV_EndBug> ,<S2SV_ModStart> rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data <S2SV_ModEnd> 
1850,<S2SV_StartBug> && obj [ 0 ] == 0x00 && objlen > 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> objlen > 1 && <S2SV_ModStart>  <S2SV_ModEnd> 
1851,"<S2SV_StartBug> err |= get_user ( length , & up -> length ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( err ) return - EFAULT 
1852,<S2SV_StartBug> if ( map_data ) <S2SV_EndBug> <S2SV_StartBug> rq -> bio = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ! iter_is_iovec ( iter ) ) goto fail ; if ( <S2SV_ModStart> fail : 
1853,"<S2SV_StartBug> opt = xchg ( & np -> opt , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> <S2SV_StartBug> opt = ipv6_renew_options ( sk , np -> opt , optname , <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> <S2SV_StartBug> opt -> tot_len = sizeof ( * opt ) + optlen ; <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> ","<S2SV_ModStart> ( __force struct ipv6_txoptions * * ) <S2SV_ModStart> { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> <S2SV_ModStart> rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; opt = <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> <S2SV_ModStart> atomic_set ( & opt -> refcnt , 1 ) ; <S2SV_ModStart> { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> "
1854,"<S2SV_StartBug> uint16_t auxsize ; <S2SV_EndBug> <S2SV_StartBug> av_get_packet ( pb , pkt , vsize ) ; <S2SV_EndBug> <S2SV_StartBug> av_get_packet ( pb , pkt , asize ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; int ret <S2SV_ModStart> if ( ( ret = <S2SV_ModStart> ) < 0 ) return ret <S2SV_ModStart> if ( ( ret = <S2SV_ModStart> ) < 0 ) return ret 
1855,<S2SV_StartBug> int buflen = bin -> buf -> length ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <S2SV_ModStart> - <S2SV_ModEnd> 
1856,<S2SV_StartBug> if ( ! last_pic_droppable && h0 -> cur_pic_ptr -> tf . owner == h0 -> avctx ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1857,"<S2SV_StartBug> const int v = ( int ) ( .5 + 256 * vp8_gaussian ( sigma , 0 , i ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> gaussian <S2SV_ModEnd> 
1858,"<S2SV_StartBug> uint64 nstrips64 ; <S2SV_EndBug> <S2SV_StartBug> nstrips64 = TIFFhowmany_64 ( bytecount , stripbytes ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( nstrips64 == 0 ) || ( nstrips64 > 0xFFFFFFFF ) ) <S2SV_EndBug> <S2SV_StartBug> newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> <S2SV_StartBug> newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> <S2SV_StartBug> for ( strip = 0 ; strip < nstrips32 ; strip ++ ) { <S2SV_EndBug> <S2SV_StartBug> newoffsets [ strip ] = offset ; <S2SV_EndBug> <S2SV_StartBug> td -> td_stripsperimage = td -> td_nstrips = nstrips32 ; <S2SV_EndBug> ","<S2SV_ModStart> uint32 nstrips <S2SV_ModEnd> <S2SV_ModStart> nstrips = TIFFhowmany_32 ( td -> td_imagelength , rowsperstrip ) ; if ( nstrips <S2SV_ModEnd> <S2SV_ModStart> return ; <S2SV_ModEnd> <S2SV_ModStart> nstrips <S2SV_ModEnd> <S2SV_ModStart> nstrips <S2SV_ModEnd> <S2SV_ModStart> nstrips <S2SV_ModEnd> <S2SV_ModStart> stripbytes ? offset : 0 <S2SV_ModEnd> <S2SV_ModStart> nstrips <S2SV_ModEnd> "
1859,<S2SV_StartBug> assert ( addrsize <= LLDPD_MGMT_MAXADDRSIZE ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1860,"<S2SV_StartBug> int result ; <S2SV_EndBug> <S2SV_StartBug> Newz ( 908 , imp_dbh -> pmysql , 1 , MYSQL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! result ) <S2SV_EndBug> <S2SV_StartBug> Safefree ( imp_dbh -> pmysql ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; int fresh = 0 <S2SV_ModStart> fresh = 1 ; <S2SV_ModStart> fresh && <S2SV_ModStart> { do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) , mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; <S2SV_ModStart> imp_dbh -> pmysql = NULL ; } "
1861,"<S2SV_StartBug> strcpy ( cat_enum . szPath , fileName ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( cat_enum . szRad1 , fileName ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( cat_enum . szRad1 , sep + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> sep = strchr ( cat_enum . szRad1 , '*' ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( cat_enum . szRad2 , sep + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> sep = strchr ( cat_enum . szRad2 , '%' ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sep ) { <S2SV_EndBug> ","<S2SV_ModStart> if ( strlen ( fileName ) >= sizeof <S2SV_ModEnd> <S2SV_ModStart> ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szPath <S2SV_ModStart> if ( strlen ( fileName ) >= sizeof <S2SV_ModEnd> <S2SV_ModStart> ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 <S2SV_ModStart> if ( strlen ( <S2SV_ModEnd> <S2SV_ModStart> >= sizeof <S2SV_ModEnd> <S2SV_ModStart> ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , ( <S2SV_ModEnd> <S2SV_ModStart> ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 , sep + 1 ) <S2SV_ModStart> } <S2SV_ModStart> szRad1 , '*' ) ; if ( strlen ( sep + 1 ) >= sizeof ( cat_enum . szRad2 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , ( sep + 1 ) ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad2 , sep + 1 ) ; sep [ 0 ] = 0 ; sep = strchr ( cat_enum . szRad2 <S2SV_ModEnd> <S2SV_ModStart> if ( strlen ( sep ) >= sizeof ( cat_enum . szOpt ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""Invalid<S2SV_blank>option:<S2SV_blank>%s.\\n"" , sep ) ) ; return GF_NOT_SUPPORTED ; } "
1862,"<S2SV_StartBug> ""<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost\'>"" <S2SV_EndBug> ","<S2SV_ModStart> ""<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'stabber@localhost\'>"" <S2SV_ModEnd> "
1863,<S2SV_StartBug> int n ; <S2SV_EndBug> ,<S2SV_ModStart> ssize_t <S2SV_ModEnd> 
1864,"<S2SV_StartBug> # define EXIFMultipleValues ( size , format , arg ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , arg ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> <S2SV_StartBug> # define EXIFMultipleFractions ( size , format , arg1 , arg2 ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , ( arg1 ) , ( arg2 ) ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> <S2SV_StartBug> if ( GetValueFromSplayTree ( exif_resources , q ) == q ) <S2SV_EndBug> <S2SV_StartBug> components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> q > ( exif + length - 12 ) ) break ; if ( <S2SV_ModStart> ; if ( components < 0 ) break 
1865,<S2SV_StartBug> if ( fuji_width ) <S2SV_EndBug> ,<S2SV_ModStart> # ifdef LIBRAW_LIBRARY_BUILD if ( fuji_width && ! dng_version && ! ( imgdata . process_warnings & LIBRAW_WARN_PARSEFUJI_PROCESSED ) ) fuji_width = 0 ; # endif 
1866,<S2SV_StartBug> if ( daddr == 0 || rs -> rs_bound_addr == 0 ) { <S2SV_EndBug> <S2SV_StartBug> ret = - ENOTCONN ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> lock_sock ( sk ) ; <S2SV_ModStart> release_sock ( sk ) ; <S2SV_ModStart> release_sock ( sk ) ; 
1867,<S2SV_StartBug> fptr = ( struct frag_hdr * ) ( ( u8 * ) ipv6h + unfrag_ip6hlen ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ; 
1868,"<S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> eobs , 0 , 25 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> eobs , 0 , 25 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> else ( void ) mb_idx ; # <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
1869,"<S2SV_StartBug> static void show_object ( struct object * object , struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , void * data ) <S2SV_EndBug> <S2SV_StartBug> if ( bitmap_pos < 0 ) { <S2SV_EndBug> <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1870,"<S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> ","<S2SV_ModStart> | CVAR_PROTECTED <S2SV_ModStart> if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; } "
1871,"<S2SV_StartBug> if ( g_file_test ( filename , G_FILE_TEST_EXISTS ) || g_path_is_absolute ( filename ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1872,<S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug> ,<S2SV_ModStart> ctx -> terminated || 
1873,<S2SV_StartBug> slave -> master = master ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irq ( & slave_active_lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> spin_lock ( & master -> timer -> lock ) ; <S2SV_ModStart> spin_unlock ( & master -> timer -> lock ) ; 
1874,<S2SV_StartBug> static char * print_number ( cJSON * item ) <S2SV_EndBug> <S2SV_StartBug> f = item -> valuefloat ; <S2SV_EndBug> <S2SV_StartBug> if ( f2 == f && item -> valueint >= LLONG_MIN && item -> valueint <= LLONG_MAX ) <S2SV_EndBug> ,"<S2SV_ModStart> , printbuffer * p ) { char * str = 0 ; double d <S2SV_ModEnd> <S2SV_ModStart> valuedouble ; if ( d == 0 ) { if ( p ) str = ensure ( p , 2 ) ; else str = ( char * ) cJSON_malloc ( 2 ) ; if ( str ) strcpy ( str , ""0"" ) ; } else if ( fabs ( ( ( double ) <S2SV_ModEnd> <S2SV_ModStart> ) - d ) <= DBL_EPSILON && d <= LLONG_MAX && d >= LLONG_MIN ) { if ( p ) str = ensure ( p , 64 ) ; else str = ( char * ) cJSON_malloc ( 64 ) ; if ( str ) sprintf ( str , ""%lld"" , ( long long ) <S2SV_ModEnd> <S2SV_ModStart> ) ; } else { if ( p ) str = ensure ( p , 64 ) ; else str = ( char * ) cJSON_malloc ( 64 ) ; if ( str ) { if ( fpclassify ( d ) != FP_ZERO && ! isnormal ( d ) ) sprintf ( str , ""null"" ) ; else if ( fabs ( floor ( d ) - d ) <= DBL_EPSILON && fabs ( d ) < 1.0e60 ) sprintf ( str , ""%.0f"" , d ) ; else if ( fabs ( d ) < 1.0e-6 || fabs ( d ) > 1.0e9 ) sprintf ( str , ""%e"" , d ) ; else sprintf ( str , ""%f"" , d ) ; } <S2SV_ModEnd> "
1875,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> r -> iov . iov_len = MIN ( r -> sector_count * 512 , SCSI_DMA_BUF_SIZE ) ; <S2SV_EndBug> ","<S2SV_ModStart> SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; if ( ! r -> iov . iov_base ) { r -> buflen = SCSI_DMA_BUF_SIZE ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } <S2SV_ModStart> r -> buflen <S2SV_ModEnd> "
1876,<S2SV_StartBug> return headcount ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( datalen > 0 ) ) { r = UIO_MAXIOV + 1 ; goto err ; } 
1877,<S2SV_StartBug> ps_cur_slice -> u1_field_pic_flag = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1878,"<S2SV_StartBug> memcpy ( & priv -> ctrl , p , sizeof ( priv -> ctrl ) ) ; <S2SV_EndBug> <S2SV_StartBug> rc = - ENOMEM ; <S2SV_EndBug> ",<S2SV_ModStart> priv -> ctrl . fname = NULL ; <S2SV_ModStart> return <S2SV_ModEnd> 
1879,"<S2SV_StartBug> if ( c == 0 ) { <S2SV_EndBug> <S2SV_StartBug> xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , ""Name"" ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; return ( NULL ) ; } if ( ctxt -> input -> cur - ctxt -> input -> base < len ) { xmlFatalErr ( ctxt , XML_ERR_INTERNAL_ERROR , ""unexpected<S2SV_blank>change<S2SV_blank>of<S2SV_blank>input<S2SV_blank>buffer"" "
1880,<S2SV_StartBug> return ( ( image -> columns + 7 ) / 8 ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) * GetPSDPacketSize ( image ) 
1881,"<S2SV_StartBug> p = gf_filter_pid_get_property ( ctx -> ipid , GF_PROP_PID_AUDIO_FORMAT ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( p ) 
1882,"<S2SV_StartBug> bit_set_position ( dat , restartpos ) ; <S2SV_EndBug> <S2SV_StartBug> obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; <S2SV_EndBug> <S2SV_StartBug> if ( klass && ! is_entity ) <S2SV_EndBug> <S2SV_StartBug> if ( err >= DWG_ERR_CRITICAL ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> is_entity ) error |= dwg_decode_UNKNOWN_ENT ( dat , obj ) ; else error |= dwg_decode_UNKNOWN_OBJ ( dat , obj ) ; if ( ! <S2SV_ModEnd> <S2SV_ModStart> error <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1883,<S2SV_StartBug> value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned short ) ( value & 0xffff ) ) ; <S2SV_EndBug> <S2SV_StartBug> value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned short ) ( value & 0xffff ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned short ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> buffer <S2SV_ModEnd> <S2SV_ModStart> ; value |= <S2SV_ModEnd> <S2SV_ModStart> buffer [ 1 ] ; return <S2SV_ModStart>  <S2SV_ModEnd> 
1884,<S2SV_StartBug> libettercap_init ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( write_output ( ) != E_SUCCESS ) <S2SV_EndBug> ,"<S2SV_ModStart> int ret_value = 0 ; <S2SV_ModStart> ret_value = <S2SV_ModEnd> <S2SV_ModStart> ; if ( ret_value == - E_NOTHANDLED ) FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correctly<S2SV_blank>handled."" , EF_GBL_OPTIONS -> output_file ) ; else if ( ret_value == - E_INVALID ) FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>format<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correct.<S2SV_blank>"" <S2SV_ModEnd> "
1885,<S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> <S2SV_StartBug> up_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! mmget_still_valid ( mm ) ) goto skip_mm <S2SV_ModStart> skip_mm : 
1886,"<S2SV_StartBug> kref_put ( & reservations -> refs , resv_map_release ) ; <S2SV_EndBug> ",<S2SV_ModStart> resv_map_put ( vma <S2SV_ModEnd> 
1887,<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt != NULL && inet -> opt -> srr ) { <S2SV_EndBug> <S2SV_StartBug> nexthop = inet -> opt -> faddr ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt == NULL || ! inet -> opt -> srr ) <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt != NULL ) <S2SV_EndBug> ,"<S2SV_ModStart> ; struct ip_options_rcu * inet_opt <S2SV_ModStart> inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt <S2SV_ModEnd> <S2SV_ModStart> inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt <S2SV_ModEnd> <S2SV_ModStart> inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . <S2SV_ModEnd> "
1888,<S2SV_StartBug> ps_dec -> au2_f_code [ 0 ] [ 0 ] = ps_dec -> au2_f_code [ 0 ] [ 1 ] = ps_dec -> u2_forw_f_code ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ps_dec -> u2_forw_f_code < 1 || ps_dec -> u2_forw_f_code > 7 || ps_dec -> u2_back_f_code < 1 || ps_dec -> u2_back_f_code > 7 ) { return IMPEG2D_UNKNOWN_ERROR ; } 
1889,"<S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_PROBE ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1890,"<S2SV_StartBug> if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> for ( n = 0 ; n < num_images ; n ++ ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( num_images < 1 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; "
1891,<S2SV_StartBug> sin -> sin_family = AF_INET ; <S2SV_EndBug> <S2SV_StartBug> if ( isk -> cmsg_flags ) <S2SV_EndBug> <S2SV_StartBug> sin6 -> sin6_family = AF_INET6 ; <S2SV_EndBug> <S2SV_StartBug> * addr_len = sizeof ( * sin6 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sin ) { <S2SV_ModStart> } <S2SV_ModStart> if ( sin6 ) { <S2SV_ModStart> } 
1892,<S2SV_StartBug> pvc . sap_family = AF_ATMPVC ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & pvc , 0 , sizeof ( pvc ) ) ; "
1893,<S2SV_StartBug> char * bufptr ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( cnt < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_read"" ) ; } "
1894,<S2SV_StartBug> if ( ! retval ) { <S2SV_EndBug> ,"<S2SV_ModStart> r = k5memdup0 ( realm , rlen , & retval ) ; <S2SV_ModEnd> "
1895,<S2SV_StartBug> if ( ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) ) <S2SV_EndBug> <S2SV_StartBug> task -> task_state_flags |= SAS_TASK_STATE_ABORTED ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; } "
1896,"<S2SV_StartBug> assert ( ( size_t ) CDF_SHORT_SEC_SIZE ( h ) == len ) ; <S2SV_EndBug> <S2SV_StartBug> ( ( const char * ) sst -> sst_tab ) + CDF_SHORT_SEC_POS ( h , id ) , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t ss = <S2SV_ModEnd> <S2SV_ModStart> ; size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss <S2SV_ModStart> if ( sst -> sst_len < ( size_t ) id ) { DPRINTF ( ( ""bad<S2SV_blank>sector<S2SV_blank>id<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\\n"" , id , sst -> sst_len ) ) ; return - 1 ; } <S2SV_ModStart> pos <S2SV_ModEnd> "
1897,"<S2SV_StartBug> l2tp_proxy_auth_type_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> <S2SV_StartBug> const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_EndBug> ","<S2SV_ModStart> , u_int length <S2SV_ModStart> if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } "
1898,"<S2SV_StartBug> oe_errno = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! sock ) <S2SV_EndBug> <S2SV_StartBug> if ( optlen ) <S2SV_EndBug> <S2SV_StartBug> & ret , sock -> host_fd , level , optname , optval , optlen_in , optlen ) != <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ",<S2SV_ModStart> oe_socklen_t optlen_out = 0 ; <S2SV_ModStart> || ! optval || ! optlen <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> & optlen_out <S2SV_ModEnd> <S2SV_ModStart> if ( optlen_out > optlen_in ) optlen_out = optlen_in ; * optlen = optlen_out ; 
1899,"<S2SV_StartBug> return crypto_skcipher_setkey ( private , key , keylen ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> struct skcipher_tfm * tfm = private ; int err ; err = crypto_skcipher_setkey ( tfm -> skcipher <S2SV_ModEnd> <S2SV_ModStart> tfm -> has_key = ! err ; return err ; 
1900,"<S2SV_StartBug> if ( l_strnstart ( ""MSG"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""RPY<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""ERR<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""ANS<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""NUL<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""SEQ<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""END"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> ","<S2SV_ModStart> ndo , <S2SV_ModStart> ndo , <S2SV_ModStart> ndo , <S2SV_ModStart> ndo , <S2SV_ModStart> ndo , <S2SV_ModStart> ndo , <S2SV_ModStart> ndo , "
1901,<S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> <S2SV_StartBug> if ( * object + size * 2 > bplist -> offset_table ) { <S2SV_EndBug> <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> ,"<S2SV_ModStart> < * object || * object + size <S2SV_ModStart> * object + size < * object || <S2SV_ModStart> < * object || * object + size * 2 <S2SV_ModStart> < * object || * object + size <S2SV_ModStart> < * object || * object + size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DICT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" <S2SV_ModEnd> "
1902,"<S2SV_StartBug> if ( ! inode -> i_op -> set_acl || ! IS_POSIXACL ( inode ) ) <S2SV_EndBug> <S2SV_StartBug> host_error = inode -> i_op -> set_acl ( inode , pacl , ACL_TYPE_ACCESS ) ; <S2SV_EndBug> <S2SV_StartBug> goto out_release ; <S2SV_EndBug> <S2SV_StartBug> host_error = inode -> i_op -> set_acl ( inode , dpacl , <S2SV_EndBug> <S2SV_StartBug> out_release : <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> fh_lock ( fhp ) ; host_error = set_posix_acl ( inode , ACL_TYPE_ACCESS , pacl <S2SV_ModEnd> <S2SV_ModStart> out_drop_lock <S2SV_ModEnd> <S2SV_ModStart> set_posix_acl ( inode , ACL_TYPE_DEFAULT , dpacl <S2SV_ModEnd> <S2SV_ModStart> out_drop_lock : fh_unlock ( fhp ) ; <S2SV_ModEnd> "
1903,"<S2SV_StartBug> sprintf ( descriptor -> msg , ""\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" , <S2SV_EndBug> <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug> ","<S2SV_ModStart> ""\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" <S2SV_ModEnd> <S2SV_ModStart> intptr_t <S2SV_ModEnd> <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) "
1904,"<S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MIREGADR , MIREGADR_R8 | address ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MIWR , data ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ","<S2SV_ModStart> uint16_t status ; <S2SV_ModStart> ENC624J600_MIREGADR , ENC624J600_MIREGADR_R12_8_DEFAULT <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MIWR <S2SV_ModEnd> <S2SV_ModStart> do { status = <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MISTAT ) ; } while ( ( status & ENC624J600_MISTAT_BUSY <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> "
1905,<S2SV_StartBug> wStream * s ; <S2SV_EndBug> <S2SV_StartBug> UINT32 flags ; <S2SV_EndBug> <S2SV_StartBug> NTLM_AV_PAIR * AvFlags ; <S2SV_EndBug> <S2SV_StartBug> flags = 0 ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> return SEC_E_INTERNAL_ERROR ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> SECURITY_STATUS status = SEC_E_INVALID_TOKEN ; <S2SV_ModStart> = 0 <S2SV_ModStart> = NULL <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; if ( Stream_GetRemainingLength ( s ) < 4 ) goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; if ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION ) { if ( ntlm_read_version_info ( s , & ( message -> Version ) ) < 0 ) goto fail ; } PayloadBufferOffset = Stream_GetPosition ( s ) ; status = SEC_E_INTERNAL_ERROR ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> DomainName ) ) < 0 ) goto fail ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> UserName ) ) < 0 ) goto fail ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> Workstation ) ) < 0 ) goto fail ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> LmChallengeResponse ) ) < 0 ) goto fail ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> NtChallengeResponse ) ) < 0 ) goto fail ; if ( message -> NtChallengeResponse . Len > 0 ) { int rc ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; status = SEC_E_INVALID_TOKEN ; rc = ntlm_read_ntlm_v2_response ( snt , & ( context -> NTLMv2Response ) ) ; Stream_Free ( snt <S2SV_ModEnd> <S2SV_ModStart> if ( rc < 0 ) goto fail ; status = SEC_E_INTERNAL_ERROR <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; CopyMemory ( context -> AuthenticateMessage . pvBuffer , Stream_Buffer ( s ) , length ) ; buffer -> cbBuffer = length ; Stream_SetPosition ( s , PayloadBufferOffset ) ; if ( flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK ) { context -> MessageIntegrityCheckOffset = ( UINT32 ) Stream_GetPosition ( s ) ; status = SEC_E_INVALID_TOKEN ; if ( Stream_GetRemainingLength ( s ) < 16 ) goto fail ; Stream_Read ( s , message -> MessageIntegrityCheck , 16 ) ; } status = SEC_E_INTERNAL_ERROR ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> fail : Stream_Free ( s , FALSE ) ; return status ; "
1906,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( caught_signal ) <S2SV_EndBug> <S2SV_StartBug> sleep ( 2 ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , _ ( ""<S2SV_blank>...killed.\\n"" ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> child = ( pid_t ) - 1 ; <S2SV_ModStart> && child != ( pid_t ) - 1 <S2SV_ModStart> if ( child != ( pid_t ) - 1 ) { <S2SV_ModStart> } 
1907,<S2SV_StartBug> saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> ,<S2SV_ModStart> INADDR_LOOPBACK <S2SV_ModEnd> 
1908,"<S2SV_StartBug> xfs_daddr_t blkno = map [ 0 ] . bm_bn ; <S2SV_EndBug> <S2SV_StartBug> pag = xfs_perag_get ( btp -> bt_mount , <S2SV_EndBug> ","<S2SV_ModStart> ; xfs_daddr_t eofs <S2SV_ModStart> eofs = XFS_FSB_TO_BB ( btp -> bt_mount , btp -> bt_mount -> m_sb . sb_dblocks ) ; if ( blkno >= eofs ) { xfs_alert ( btp -> bt_mount , ""%s:<S2SV_blank>Block<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>block<S2SV_blank>0x%llx,<S2SV_blank>EOFS<S2SV_blank>0x%llx<S2SV_blank>"" , __func__ , blkno , eofs ) ; return NULL ; } "
1909,"<S2SV_StartBug> int ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( d2i_DSA_SIG ( & s , & sigbuf , siglen ) == NULL ) goto err ; <S2SV_EndBug> <S2SV_StartBug> DSA_SIG_free ( s ) ; <S2SV_EndBug> ","<S2SV_ModStart> const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> p <S2SV_ModEnd> <S2SV_ModStart> goto err ; derlen = i2d_DSA_SIG ( s , & der ) ; if ( derlen != siglen || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; } "
1910,<S2SV_StartBug> while ( res == 0 && dev ) { <S2SV_EndBug> <S2SV_StartBug> dev = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1911,<S2SV_StartBug> netdev -> hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1912,<S2SV_StartBug> goto next_desc ; <S2SV_EndBug> ,"<S2SV_ModStart> ; } if ( ( buflen < elength ) || ( elength < 3 ) ) { dev_err ( & intf -> dev , ""invalid<S2SV_blank>descriptor<S2SV_blank>buffer<S2SV_blank>length\\n"" ) ; break "
1913,"<S2SV_StartBug> f = fopen ( filepath , ""rb"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""r"" <S2SV_ModEnd> "
1914,<S2SV_StartBug> if ( ex && ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug> <S2SV_StartBug> if ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug> ,<S2SV_ModStart> ! ( flag & <S2SV_ModEnd> <S2SV_ModStart> ! ( flag & EXT4_GET_BLOCKS_PRE_IO ) <S2SV_ModEnd> 
1915,<S2SV_StartBug> evt -> event . lun [ 1 ] = tpg -> tport_tpgt & 0xFF ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1916,"<S2SV_StartBug> struct btrfs_dir_item * di ; <S2SV_EndBug> <S2SV_StartBug> if ( flags & XATTR_REPLACE ) { <S2SV_EndBug> <S2SV_StartBug> di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , <S2SV_EndBug> <S2SV_StartBug> } else if ( ! di ) { <S2SV_EndBug> <S2SV_StartBug> ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ; <S2SV_EndBug> <S2SV_StartBug> btrfs_release_path ( path ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( flags & XATTR_CREATE ) <S2SV_EndBug> <S2SV_StartBug> btrfs_release_path ( path ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( ! di ) { <S2SV_EndBug> <S2SV_StartBug> if ( value ) { <S2SV_EndBug> ","<S2SV_ModStart> = NULL <S2SV_ModStart> path -> skip_release_on_error = 1 ; if ( ! value ) { di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ; if ( ! di && <S2SV_ModEnd> <S2SV_ModStart> ) ret = - ENODATA ; else if ( di ) ret = btrfs_delete_one_dir_name <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( flags & XATTR_REPLACE ) { ASSERT ( mutex_is_locked ( & inode -> i_mutex ) ) ; di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ; <S2SV_ModEnd> <S2SV_ModStart> btrfs_release_path ( path ) ; di = NULL ; } ret = btrfs_insert_xattr_item <S2SV_ModEnd> <S2SV_ModStart> btrfs_ino ( inode ) , name , name_len , value , size ) ; if ( ret == - EOVERFLOW ) { ret = 0 ; btrfs_assert_tree_locked ( path -> nodes [ 0 ] ) ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; if ( ! di && ! ( flags & XATTR_REPLACE ) ) { ret = - ENOSPC ; <S2SV_ModEnd> <S2SV_ModStart> } } else if ( ret == - EEXIST ) { ret = 0 ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; ASSERT ( di ) ; } else if ( ret ) { <S2SV_ModEnd> <S2SV_ModStart> if ( di && <S2SV_ModEnd> <S2SV_ModStart> ) { ret = - EEXIST ; <S2SV_ModStart> } if ( di ) { const int slot = path -> slots [ 0 ] ; struct extent_buffer * leaf = path -> nodes [ 0 ] ; const u16 old_data_len = btrfs_dir_data_len ( leaf , di ) ; const u32 item_size = btrfs_item_size_nr ( leaf , slot ) ; const u32 data_size = sizeof ( * di ) + name_len + size ; struct btrfs_item * item ; unsigned long data_ptr ; char * ptr ; if ( size > old_data_len ) { if ( btrfs_leaf_free_space ( root , leaf ) < ( size - old_data_len ) ) { ret = - ENOSPC <S2SV_ModEnd> <S2SV_ModStart> } if ( old_data_len + name_len + sizeof ( * di ) == item_size ) { if ( size > old_data_len ) btrfs_extend_item ( root , path , size - old_data_len ) ; <S2SV_ModStart> size < old_data_len ) btrfs_truncate_item ( root , path , data_size , 1 ) ; } else { <S2SV_ModEnd> <S2SV_ModStart> btrfs_extend_item ( root , path , data_size ) ; } item = btrfs_item_nr ( slot ) ; ptr = btrfs_item_ptr ( leaf , slot , char ) ; ptr += btrfs_item_size ( leaf , item ) - data_size ; di = ( struct btrfs_dir_item * ) ptr ; btrfs_set_dir_data_len ( leaf , di , size ) ; data_ptr = ( ( unsigned long ) ( di + 1 ) ) + name_len ; write_extent_buffer ( leaf , value , data_ptr , size ) ; btrfs_mark_buffer_dirty ( leaf ) ; } else { <S2SV_ModEnd> "
1917,<S2SV_StartBug> newlen = x -> length * 6 / 5 ; <S2SV_EndBug> <S2SV_StartBug> if ( newlen == x -> length ) <S2SV_EndBug> ,<S2SV_ModStart> area_size <S2SV_ModEnd> <S2SV_ModStart> area_size <S2SV_ModEnd> 
1918,<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> msg -> msg_namelen = 0 ; 
1919,<S2SV_StartBug> if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( alloc > 2 ) && 
1920,"<S2SV_StartBug> res = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> ",<S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) 
1921,<S2SV_StartBug> skb_dst_drop ( skb ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( IPCB ( skb ) -> opt . optlen ) ) skb_dst_force ( skb ) ; else 
1922,<S2SV_StartBug> if ( ( CUR == '/' ) && ( NXT ( 1 ) == '/' ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ctxt -> error ) return ; if ( 
1923,<S2SV_StartBug> u32 offset ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1924,"<S2SV_StartBug> if ( ( r = ssh_packet_get_compress_state ( m , ssh ) ) != 0 || <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1925,<S2SV_StartBug> bi -> pdwidth = ( bi -> rowbytes * 8 ) / bi -> pixelsize ; <S2SV_EndBug> <S2SV_StartBug> if ( bi -> pdwidth < bi -> npwidth ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( bi -> pixelsize > 0 ) { <S2SV_ModStart> } 
1926,<S2SV_StartBug> sas_port_delete ( phy -> port ) ; <S2SV_EndBug> ,"<S2SV_ModStart> list_add_tail ( & phy -> port -> del_list , & parent -> port -> sas_port_del_list <S2SV_ModEnd> "
1927,"<S2SV_StartBug> static u32 __ipv6_select_ident ( struct net * net , u32 hashrnd , <S2SV_EndBug> <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( dst , hashrnd ) ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( src , hash ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const struct { struct in6_addr dst ; struct in6_addr src ; } __aligned ( SIPHASH_ALIGNMENT ) combined = { . dst = * dst , . src = * src , } ; <S2SV_ModStart> if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key , sizeof ( net -> ipv4 . ip_id_key ) <S2SV_ModEnd> <S2SV_ModStart> siphash ( & combined , sizeof ( combined ) , & net -> ipv4 . ip_id_key <S2SV_ModEnd> "
1928,"<S2SV_StartBug> if ( unlikely ( ! access_ok ( ! rw , buf , kiocb -> ki_nbytes ) ) ) <S2SV_EndBug> <S2SV_StartBug> iovec -> iov_len = kiocb -> ki_nbytes ; <S2SV_EndBug> ",<S2SV_ModStart> size_t len = kiocb -> ki_nbytes ; if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ; <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> 
1929,"<S2SV_StartBug> ( * sp -> encodepfunc ) ( tif , bp , cc ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) return 0 
1930,"<S2SV_StartBug> vpx_memset ( & next_frame , 0 , sizeof ( next_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( this_frame , & next_frame , sizeof ( * this_frame ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
1931,"<S2SV_StartBug> char * outname = create_output_name ( ( unsigned char * ) f [ i ] -> filename , NULL , 0 , 1 , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1932,"<S2SV_StartBug> uint16_t numChannels , chansSpecified , chanMask = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( numChannels < chansSpecified || numChannels < 1 ) { <S2SV_EndBug> <S2SV_StartBug> total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; <S2SV_EndBug> ","<S2SV_ModStart> = 0 <S2SV_ModStart> || numChannels > 256 <S2SV_ModStart> if ( ! config -> num_channels ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } "
1933,<S2SV_StartBug> return PTR_ERR ( tty ) ; <S2SV_EndBug> ,<S2SV_ModStart> tty_driver_kref_put ( driver ) ; 
1934,"<S2SV_StartBug> ( sctp_paramhdr_t * ) addip_hdr -> params , <S2SV_EndBug> ","<S2SV_ModStart> asconf_ack , false , <S2SV_ModEnd> "
1935,"<S2SV_StartBug> memory_length += extra_length - available_length + BLOCK_QUEUE ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( cp , qp -> d_memory , memory_length ) ; <S2SV_EndBug> ",<S2SV_ModStart> size_t original_length = memory_length ; <S2SV_ModStart> original_length <S2SV_ModEnd> 
1936,<S2SV_StartBug> res . acl_len ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1937,"<S2SV_StartBug> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , <S2SV_EndBug> <S2SV_StartBug> Min ( 4 , dds_info -> height - y ) , exception ) ; <S2SV_EndBug> <S2SV_StartBug> SkipDXTMipmaps ( image , dds_info , 16 ) ; <S2SV_EndBug> ","<S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> return ( <S2SV_ModStart> , exception ) ) <S2SV_ModEnd> "
1938,"<S2SV_StartBug> id = idr_alloc ( & ids -> ipcs_idr , new , <S2SV_EndBug> <S2SV_StartBug> current_euid_egid ( & euid , & egid ) ; <S2SV_EndBug> ","<S2SV_ModStart> current_euid_egid ( & euid , & egid ) ; new -> cuid = new -> uid = euid ; new -> gid = new -> cgid = egid ; <S2SV_ModStart>  <S2SV_ModEnd> "
1939,<S2SV_StartBug> __be32 * pdata = ( __be32 * ) data ; <S2SV_EndBug> ,<S2SV_ModStart> pdata ; if ( datalen != 4 ) return - EINVAL ; 
1940,<S2SV_StartBug> if ( unlikely ( len > ring -> rx_buffersize ) ) { <S2SV_EndBug> ,<S2SV_ModStart> + ring -> frameoffset 
1941,"<S2SV_StartBug> set_string ( ""foo"" , module_object , ""string_array[%i]"" , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> set_integer ( 256 , module_object , ""integer_array[%i]"" , 256 ) ; "
1942,<S2SV_StartBug> WARN_ON_ONCE ( ctx -> parent_ctx ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & ctx -> mutex ) ; <S2SV_EndBug> ,<S2SV_ModStart> lockdep_assert_held <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1943,"<S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> <S2SV_StartBug> pr_warn ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> 
1944,"<S2SV_StartBug> xcfdata = ( XCFPixelInfo * ) AcquireQuantumMemory ( data_length , sizeof ( * xcfdata ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> MagickMax ( data_length , tile_image -> columns * tile_image -> rows ) <S2SV_ModEnd> "
1945,"<S2SV_StartBug> struct sshbuf * b ; <S2SV_EndBug> <S2SV_StartBug> char * pkalg , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ; <S2SV_EndBug> <S2SV_StartBug> u_char * pkblob , * sig , have_sig ; <S2SV_EndBug> <S2SV_StartBug> if ( ! authctxt -> valid ) { <S2SV_EndBug> <S2SV_StartBug> __func__ , ssh_err ( r ) ) ; <S2SV_EndBug> <S2SV_StartBug> free ( sig ) ; <S2SV_EndBug> <S2SV_StartBug> fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; <S2SV_EndBug> <S2SV_StartBug> return authenticated ; <S2SV_EndBug> ","<S2SV_ModStart> = NULL <S2SV_ModStart> = NULL <S2SV_ModStart> = NULL <S2SV_ModStart> = NULL <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; } if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; goto done <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; goto done ; } <S2SV_ModStart> free ( sig ) ; "
1946,<S2SV_StartBug> NameContext sNC ; <S2SV_EndBug> <S2SV_StartBug> sNC . pParse = & sParse ; <S2SV_EndBug> ,<S2SV_ModStart> Select * pSelect = pTab -> pSelect ; <S2SV_ModStart> ; assert ( pSelect -> selFlags & SF_View ) ; pSelect -> selFlags &= ~ SF_View 
1947,<S2SV_StartBug> args -> rmtblkno = 0 ; <S2SV_EndBug> <S2SV_StartBug> args -> rmtblkcnt = 0 ; <S2SV_EndBug> <S2SV_StartBug> args -> rmtblkcnt = args -> rmtblkcnt2 ; <S2SV_EndBug> ,<S2SV_ModStart> rmtvaluelen2 = args -> rmtvaluelen ; args -> <S2SV_ModStart> = 0 ; args -> rmtvaluelen <S2SV_ModStart> ; args -> rmtvaluelen = args -> rmtvaluelen2 
1948,"<S2SV_StartBug> int i , j ; <S2SV_EndBug> <S2SV_StartBug> i = ctm -> length ; <S2SV_EndBug> <S2SV_StartBug> if ( ( i < 11 ) || ( i > 17 ) ) <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( i < 13 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> * ( p ++ ) = * ( str ++ ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( * str >= '0' ) && ( * str <= '9' ) ) <S2SV_EndBug> <S2SV_StartBug> if ( * str == 'Z' ) <S2SV_EndBug> <S2SV_StartBug> else { <S2SV_EndBug> <S2SV_StartBug> if ( ( * str != '+' ) && ( * str != '-' ) ) <S2SV_EndBug> ","<S2SV_ModStart> , remaining <S2SV_ModStart> remaining <S2SV_ModEnd> <S2SV_ModStart> int min_length = sizeof ( ""YYMMDDHHMMZ"" ) - 1 ; int max_length = sizeof ( ""YYMMDDHHMMSS+hhmm"" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> <S2SV_ModStart> remaining -= 10 ; <S2SV_ModStart> int min_length = sizeof ( ""YYYYMMDDHHMMZ"" ) - 1 ; int max_length = sizeof ( ""YYYYMMDDHHMMSS.fff+hhmm"" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> <S2SV_ModStart> remaining -= 12 ; <S2SV_ModStart> if ( remaining < 2 ) return 0 ; * ( p ++ ) = * ( str ++ ) ; * ( p ++ ) = * ( str ++ ) ; remaining -= 2 ; if ( remaining && <S2SV_ModEnd> <S2SV_ModStart> remaining -- ; for ( i = 0 ; i < 3 && remaining ; i ++ , str ++ , remaining -- ) { if ( * str < '0' || * str > '9' ) break ; } <S2SV_ModEnd> <S2SV_ModStart> ! remaining ) return 0 ; if ( <S2SV_ModStart> { if ( remaining != 1 ) return 0 ; <S2SV_ModStart> } <S2SV_ModStart> ) return 0 ; if ( remaining != 5 ) return 0 ; if ( str [ 1 ] < '0' || str [ 1 ] > '9' || str [ 2 ] < '0' || str [ 2 ] > '9' || str [ 3 ] < '0' || str [ 3 ] > '9' || str [ 4 ] < '0' || str [ 4 ] > '9' "
1949,<S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decompress_data ( context ) ; <S2SV_EndBug> <S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> <S2SV_StartBug> context -> decode ( context ) ; <S2SV_EndBug> <S2SV_StartBug> PROFILER_EXIT ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> ,<S2SV_ModStart> { BOOL rc ; <S2SV_ModStart> rc = <S2SV_ModStart> if ( ! rc ) return FALSE ; } { BOOL rc ; <S2SV_ModStart> rc = <S2SV_ModStart> if ( ! rc ) return FALSE ; } 
1950,"<S2SV_StartBug> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <S2SV_EndBug> ","<S2SV_ModStart> js_doregexec ( J , <S2SV_ModEnd> "
1951,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = hns_nic_net_xmit_hw ( ndev , skb , <S2SV_EndBug> <S2SV_StartBug> if ( ret == NETDEV_TX_OK ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1952,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> title , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> style_block , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> script , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> object , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> textarea , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> option , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> math , s ) ; <S2SV_EndBug> <S2SV_StartBug> # ifdef USE_PRETTYSRC <S2SV_EndBug> ","<S2SV_ModStart> HTChunk * target = NULL ; <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( target != NULL ) { if ( target -> data == s ) { CTRACE ( ( tfp , ""BUG:<S2SV_blank>appending<S2SV_blank>chunk<S2SV_blank>to<S2SV_blank>itself:<S2SV_blank>`%.*s\'\\n"" , target -> size , target -> data ) ) ; } else { HTChunkPuts ( target , s ) ; } } "
1953,<S2SV_StartBug> return error ; <S2SV_EndBug> ,<S2SV_ModStart> < 0 ? error : 0 
1954,<S2SV_StartBug> kiocb -> ki_nr_segs = kiocb -> ki_nbytes ; <S2SV_EndBug> ,"<S2SV_ModStart> ret = rw_verify_area ( type , kiocb -> ki_filp , & kiocb -> ki_pos , ret ) ; if ( ret < 0 ) goto out ; "
1955,"<S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_PROBE ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1956,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> pdo_row_ce -> unserialize = zend_class_unserialize_deny ; 
1957,<S2SV_StartBug> int error ; <S2SV_EndBug> <S2SV_StartBug> if ( ext2_xattr_cache_insert ( bh ) ) <S2SV_EndBug> ,"<S2SV_ModStart> ; struct mb2_cache * ext2_mb_cache = EXT2_SB ( inode -> i_sb ) -> s_mb_cache <S2SV_ModStart> ext2_mb_cache , "
1958,<S2SV_StartBug> if ( client -> type == USER_CLIENT ) <S2SV_EndBug> ,<S2SV_ModStart> && client -> data . user . fifo 
1959,<S2SV_StartBug> if ( ! index_key . type -> match || ! index_key . type -> instantiate || <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1960,"<S2SV_StartBug> file = fopen ( ""/tmp/keepalived.json"" , ""w"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> fopen_safe <S2SV_ModEnd> 
1961,"<S2SV_StartBug> pdf -> xrefs = calloc ( 1 , sizeof ( xref_t ) * pdf -> n_xrefs ) ; <S2SV_EndBug> ",<S2SV_ModStart> safe_calloc ( <S2SV_ModEnd> 
1962,<S2SV_StartBug> return err ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree_skb ( skb ) ; return err ; } <S2SV_ModEnd> 
1963,<S2SV_StartBug> int delta_munlocked ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> delta_munlocked = - nr + pagevec_count ( & pvec_putback ) ; <S2SV_EndBug> ,<S2SV_ModStart> = - nr <S2SV_ModStart> else { delta_munlocked ++ ; } <S2SV_ModStart>  <S2SV_ModEnd> 
1964,<S2SV_StartBug> skipsize = LOGICAL_BLOCK_SIZE * vd -> location ; <S2SV_EndBug> <S2SV_StartBug> skipsize = LOGICAL_BLOCK_SIZE * vd -> location ; <S2SV_EndBug> ,<S2SV_ModStart> ( int64_t ) <S2SV_ModStart> ( int64_t ) 
1965,<S2SV_StartBug> int val = 1 ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ssocket == NULL ) return - ENOTSOCK 
1966,"<S2SV_StartBug> const int eb_y = MAX ( ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) - src -> y_width , <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_ALPHA <S2SV_EndBug> <S2SV_StartBug> src -> y_width , src -> y_height , <S2SV_EndBug> <S2SV_StartBug> src -> uv_width , src -> uv_height , <S2SV_EndBug> <S2SV_StartBug> src -> uv_width , src -> uv_height , <S2SV_EndBug> ","<S2SV_ModStart> er_y = MAX ( src -> y_width + 16 , ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) ) - src -> y_crop_width ; const int <S2SV_ModStart> src -> y_height + 16 , <S2SV_ModStart> y_height <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> y_crop_height <S2SV_ModEnd> <S2SV_ModStart> CONFIG_VP9_HIGHBITDEPTH if ( src -> flags & YV12_FLAG_HIGHBITDEPTH ) { highbd_copy_and_extend_plane ( src -> y_buffer , src -> y_stride , dst -> y_buffer , dst -> y_stride , src -> y_crop_width , src -> y_crop_height , et_y , el_y , eb_y , er_y ) ; highbd_copy_and_extend_plane ( src -> u_buffer , src -> uv_stride , dst -> u_buffer , dst -> uv_stride , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ; highbd_copy_and_extend_plane ( src -> v_buffer , src -> uv_stride , dst -> v_buffer , dst -> uv_stride , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ; return ; } <S2SV_ModEnd> <S2SV_ModStart> y_crop_width , src -> y_crop_height <S2SV_ModEnd> <S2SV_ModStart> uv_crop_width , src -> uv_crop_height <S2SV_ModEnd> <S2SV_ModStart> uv_crop_width , src -> uv_crop_height <S2SV_ModEnd> "
1967,<S2SV_StartBug> void * base = dlmalloc ( bytes + sizeof ( AllocationEntry ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> size_t size = bytes + sizeof ( AllocationEntry ) ; if ( size < bytes ) { return NULL ; } <S2SV_ModStart> size <S2SV_ModEnd> 
1968,<S2SV_StartBug> ps_dec -> u1_mb_idx = 0 ; <S2SV_EndBug> <S2SV_StartBug> ps_dec -> u2_total_mbs_coded ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( u1_tfr_n_mb ) <S2SV_EndBug> ,<S2SV_ModStart> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ps_dec -> u2_total_mbs_coded += u1_num_mbs ; 
1969,"<S2SV_StartBug> ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; <S2SV_EndBug> <S2SV_StartBug> tlen = len ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> type , length ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( tptr [ 3 ] , length - 3 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( tptr [ 3 ] , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> EXTRACT_64BITS ( tptr + 3 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> print_unknown_data ( ndo , tptr + 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , length - 3 ) ; <S2SV_EndBug> ",<S2SV_ModStart> tlen = len ; while ( tlen >= 3 ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tptr += 3 ; tlen -= 3 ; <S2SV_ModStart> ; if ( length < 3 ) goto trunc ; length -= 3 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( length < 8 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1970,"<S2SV_StartBug> # line 106 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1330 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 115 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1338 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 119 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1351 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 128 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ; <S2SV_EndBug> <S2SV_StartBug> # line 1413 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 190 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1421 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 194 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1434 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 207 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1442 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 211 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1451 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 220 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1468 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 233 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1476 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 237 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1485 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 246 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1512 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 269 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1548 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 301 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1574 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 323 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1594 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 343 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1602 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 347 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; <S2SV_EndBug> <S2SV_StartBug> # line 1617 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 361 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1629 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 369 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1653 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1657 ""hex_grammar.c"" <S2SV_EndBug> ","<S2SV_ModStart> 113 <S2SV_ModEnd> <S2SV_ModStart> 1337 <S2SV_ModEnd> <S2SV_ModStart> 122 <S2SV_ModEnd> <S2SV_ModStart> 1345 <S2SV_ModEnd> <S2SV_ModStart> 126 ""hex_grammar.y"" { incr_ast_levels ( ) ; <S2SV_ModEnd> <S2SV_ModStart> 1360 <S2SV_ModEnd> <S2SV_ModStart> 137 <S2SV_ModEnd> <S2SV_ModStart> ) ; incr_ast_levels ( <S2SV_ModStart> 1424 <S2SV_ModEnd> <S2SV_ModStart> 201 <S2SV_ModEnd> <S2SV_ModStart> 1432 <S2SV_ModEnd> <S2SV_ModStart> 205 ""hex_grammar.y"" { incr_ast_levels ( ) ; <S2SV_ModEnd> <S2SV_ModStart> 1447 <S2SV_ModEnd> <S2SV_ModStart> 220 <S2SV_ModEnd> <S2SV_ModStart> 1455 <S2SV_ModEnd> <S2SV_ModStart> 224 <S2SV_ModEnd> <S2SV_ModStart> 1464 <S2SV_ModEnd> <S2SV_ModStart> 233 <S2SV_ModEnd> <S2SV_ModStart> 1481 <S2SV_ModEnd> <S2SV_ModStart> 246 <S2SV_ModEnd> <S2SV_ModStart> 1489 <S2SV_ModEnd> <S2SV_ModStart> 250 <S2SV_ModEnd> <S2SV_ModStart> 1498 <S2SV_ModEnd> <S2SV_ModStart> 259 <S2SV_ModEnd> <S2SV_ModStart> 1525 <S2SV_ModEnd> <S2SV_ModStart> 282 <S2SV_ModEnd> <S2SV_ModStart> 1561 <S2SV_ModEnd> <S2SV_ModStart> 314 <S2SV_ModEnd> <S2SV_ModStart> 1587 <S2SV_ModEnd> <S2SV_ModStart> 336 <S2SV_ModEnd> <S2SV_ModStart> 1607 <S2SV_ModEnd> <S2SV_ModStart> 356 <S2SV_ModEnd> <S2SV_ModStart> 1615 <S2SV_ModEnd> <S2SV_ModStart> 360 <S2SV_ModEnd> <S2SV_ModStart> incr_ast_levels ( ) ; <S2SV_ModStart> 1631 <S2SV_ModEnd> <S2SV_ModStart> 375 <S2SV_ModEnd> <S2SV_ModStart> 1643 <S2SV_ModEnd> <S2SV_ModStart> 383 <S2SV_ModEnd> <S2SV_ModStart> 1667 <S2SV_ModEnd> <S2SV_ModStart> 1671 <S2SV_ModEnd> "
1971,"<S2SV_StartBug> char group [ LONG_STRING ] ; <S2SV_EndBug> <S2SV_StartBug> if ( sscanf ( line , ""%s<S2SV_blank>"" ANUM ""<S2SV_blank>"" ANUM ""<S2SV_blank>%c<S2SV_blank>%[^\\n]"" , group , & last , & first , & mod , desc ) < 4 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> = """" <S2SV_ModStart> ""%1023s<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank>%c<S2SV_blank>%8191[^\\n]"" <S2SV_ModEnd> <S2SV_ModStart> { mutt_debug ( 4 , ""Cannot<S2SV_blank>parse<S2SV_blank>server<S2SV_blank>line:<S2SV_blank>%s\\n"" , line ) ; <S2SV_ModStart> } "
1972,<S2SV_StartBug> pStorage -> picSizeInMbs = <S2SV_EndBug> <S2SV_StartBug> pStorage -> activeSps -> picHeightInMbs ; <S2SV_EndBug> ,<S2SV_ModStart> if ( pStorage -> activeSps -> picWidthInMbs == 0 ) { pStorage -> picSizeInMbs = 0 ; } else if ( pStorage -> activeSps -> picHeightInMbs > UINT32_MAX / pStorage -> activeSps -> picWidthInMbs ) { return ( MEMORY_ALLOCATION_ERROR ) ; } else { <S2SV_ModStart> } 
1973,<S2SV_StartBug> if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { <S2SV_EndBug> <S2SV_StartBug> if ( umax_val > 63 ) { <S2SV_EndBug> <S2SV_StartBug> if ( umax_val > 63 ) { <S2SV_EndBug> <S2SV_StartBug> __reg_deduce_bounds ( dst_reg ) ; <S2SV_EndBug> ,"<S2SV_ModStart> u64 insn_bitness = <S2SV_ModEnd> <S2SV_ModStart> == BPF_ALU64 ) ? 64 : 32 ; <S2SV_ModEnd> <S2SV_ModStart> >= insn_bitness <S2SV_ModEnd> <S2SV_ModStart> >= insn_bitness <S2SV_ModEnd> <S2SV_ModStart> if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } "
1974,<S2SV_StartBug> int iskew = imagew - tilew ; <S2SV_EndBug> <S2SV_StartBug> if ( colb + tilew > imagew ) { <S2SV_EndBug> ,<S2SV_ModStart> int64 iskew = ( int64 ) imagew - ( int64 ) <S2SV_ModEnd> <S2SV_ModStart> > iskew <S2SV_ModEnd> 
1975,<S2SV_StartBug> if ( ! ( dev -> flags & IFF_UP ) ) <S2SV_EndBug> <S2SV_StartBug> if ( skb -> len > ( dev -> mtu + dev -> hard_header_len ) ) <S2SV_EndBug> <S2SV_StartBug> return NET_RX_DROP ; <S2SV_EndBug> ,<S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> ) { kfree_skb ( skb ) ; <S2SV_ModStart> } 
1976,"<S2SV_StartBug> else if ( ! strcasecmp ( target , ""LIST"" ) && myentity_find_ext ( target ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> else if ( ! strcasecmp ( target , ""CLEAR"" ) && myentity_find_ext ( target ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> else if ( ! strcasecmp ( target , ""MODIFY"" ) && myentity_find_ext ( target ) == NULL ) <S2SV_EndBug> ",<S2SV_ModStart> anope_flags_compat && <S2SV_ModStart> anope_flags_compat && <S2SV_ModStart> anope_flags_compat && 
1977,<S2SV_StartBug> user = key_user_lookup ( current_fsuid ( ) ) ; <S2SV_EndBug> <S2SV_StartBug> return ERR_PTR ( - ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> goto couldnt_alloc_key ; <S2SV_EndBug> <S2SV_StartBug> couldnt_alloc_key : <S2SV_EndBug> <S2SV_StartBug> key_put ( dest_keyring ) ; <S2SV_EndBug> ,<S2SV_ModStart> ret = construct_get_dest_keyring ( & dest_keyring ) ; if ( ret ) goto error ; <S2SV_ModStart> { ret = - ENOMEM ; goto error_put_dest_keyring ; } <S2SV_ModEnd> <S2SV_ModStart> error_put_dest_keyring <S2SV_ModEnd> <S2SV_ModStart> error_put_dest_keyring <S2SV_ModEnd> <S2SV_ModStart> error : 
1978,"<S2SV_StartBug> if ( s -> chunksize >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> s -> chunksize = strtoll ( line , NULL , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> av_log ( NULL , AV_LOG_TRACE , ""Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%"" PRId64 ""\'\\n"" , <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> int64_t target = h -> is_streamed ? 0 : s -> off ; <S2SV_EndBug> <S2SV_StartBug> av_log ( h , AV_LOG_INFO , ""Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRId64 ""<S2SV_blank>error=%s.\\n"" , s -> off , av_err2str ( read_ret ) ) ; <S2SV_EndBug> <S2SV_StartBug> av_log ( h , AV_LOG_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRId64 "".\\n"" , target ) ; <S2SV_EndBug> ","<S2SV_ModStart> != UINT64_MAX <S2SV_ModEnd> <S2SV_ModStart> strtoull <S2SV_ModEnd> <S2SV_ModStart> h <S2SV_ModEnd> <S2SV_ModStart> PRIu64 <S2SV_ModEnd> <S2SV_ModStart> else if ( s -> chunksize == UINT64_MAX ) { av_log ( h , AV_LOG_ERROR , ""Invalid<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>%"" PRIu64 ""\\n"" , s -> chunksize ) ; return AVERROR ( EINVAL ) ; } <S2SV_ModStart> uint64_t <S2SV_ModEnd> <S2SV_ModStart> PRIu64 <S2SV_ModEnd> <S2SV_ModStart> PRIu64 <S2SV_ModEnd> "
1979,<S2SV_StartBug> long tmp = * old ; <S2SV_EndBug> <S2SV_StartBug> return * old == tmp ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( tmp == * old ) { * old = new ; return 1 ; } else { * old = tmp ; return 0 ; } <S2SV_ModEnd> 
1980,"<S2SV_StartBug> static void write_sync_code ( struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_SYNC_CODE_0 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_SYNC_CODE_1 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_SYNC_CODE_2 , 8 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> 
1981,"<S2SV_StartBug> static void nsc_encode_sse2 ( NSC_CONTEXT * context , const BYTE * data , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> return TRUE ; 
1982,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> case RMT_NONE : break ; 
1983,"<S2SV_StartBug> other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false "
1984,"<S2SV_StartBug> if ( fseek ( stats -> file , 0 , SEEK_END ) ) <S2SV_EndBug> ","<S2SV_ModStart> stats -> file == NULL ) fatal ( ""First-pass<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist!"" ) ; if ( "
1985,"<S2SV_StartBug> if ( name && memchr ( name , '\\0' , namelen ) ) <S2SV_EndBug> ",<S2SV_ModStart> != NULL && namelen == 0 ) namelen = strlen ( name ) ; if ( name 
1986,"<S2SV_StartBug> static int mem_resize ( jas_stream_memobj_t * m , int bufsize ) <S2SV_EndBug> <S2SV_StartBug> assert ( bufsize >= 0 ) ; <S2SV_EndBug> <S2SV_StartBug> JAS_DBGLOG ( 100 , ( ""mem_resize(%p,<S2SV_blank>%d)\\n"" , m , bufsize ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""mem_resize(%p,<S2SV_blank>%zu)\\n"" <S2SV_ModEnd> <S2SV_ModStart> if ( ! bufsize ) { jas_eprintf ( ""mem_resize<S2SV_blank>was<S2SV_blank>not<S2SV_blank>really<S2SV_blank>designed<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>a<S2SV_blank>buffer<S2SV_blank>of<S2SV_blank>size<S2SV_blank>0\\n"" ""This<S2SV_blank>may<S2SV_blank>not<S2SV_blank>work.\\n"" ) ; } "
1987,<S2SV_StartBug> unsigned int i ; <S2SV_EndBug> ,<S2SV_ModStart> ; cmap -> ents = 0 
1988,"<S2SV_StartBug> BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( * vs > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ; 
1989,<S2SV_StartBug> ut8 opcode = * ( p4 ++ ) & 0xff ; <S2SV_EndBug> ,<S2SV_ModStart> if ( p4 <= 0 ) { return ; } 
1990,"<S2SV_StartBug> h = __archive_read_ahead ( a , <S2SV_EndBug> ","<S2SV_ModStart> if ( cpio -> entry_bytes_remaining > 1024 * 1024 ) { archive_set_error ( & a -> archive , ENOMEM , ""Rejecting<S2SV_blank>malformed<S2SV_blank>cpio<S2SV_blank>archive:<S2SV_blank>symlink<S2SV_blank>contents<S2SV_blank>exceed<S2SV_blank>1<S2SV_blank>megabyte"" ) ; return ( ARCHIVE_FATAL ) ; } "
1991,"<S2SV_StartBug> . match_data . cmp = user_match , <S2SV_EndBug> ",<S2SV_ModStart> key_default_cmp <S2SV_ModEnd> 
1992,"<S2SV_StartBug> if ( pos + 8 > len ) { <S2SV_EndBug> <S2SV_StartBug> int min_val = ( ut32 ) ( UINT ( data , pos + 4 ) ) , <S2SV_EndBug> ",<S2SV_ModStart> + 8 <S2SV_ModStart> const <S2SV_ModStart> ; const int <S2SV_ModEnd> 
1993,"<S2SV_StartBug> ber_parse_header ( STREAM s , int tagval , int * length ) <S2SV_EndBug> ",<S2SV_ModStart> uint32 <S2SV_ModEnd> 
1994,"<S2SV_StartBug> if ( cid <= 0 ) <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = ff_dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) <S2SV_EndBug> <S2SV_StartBug> return dctx -> remaining ; <S2SV_EndBug> ",<S2SV_ModStart> int remaining ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> 
1995,"<S2SV_StartBug> first_block_offset = round_up ( offset , sb -> s_blocksize ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( last_block_offset > first_block_offset ) <S2SV_EndBug> <S2SV_StartBug> ext4_inode_resume_unlocked_dio ( inode ) ; <S2SV_EndBug> ",<S2SV_ModStart> ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; 
1996,"<S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> res = vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , <S2SV_EndBug> ",<S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> codec_interface <S2SV_ModEnd> 
1997,"<S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || <S2SV_EndBug> ","<S2SV_ModStart> > MAXDATELEN ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } switch ( dtype ) { case DTK_DATE : if ( tm2timestamp ( tm , fsec , NULL , & result <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1998,"<S2SV_StartBug> Huff_transmit ( & huff , ch , seq ) ; <S2SV_EndBug> ","<S2SV_ModStart> , size << 3 "
1999,"<S2SV_StartBug> cmd = kmalloc ( sizeof ( * cmd ) , GFP_ATOMIC ) ; <S2SV_EndBug> ",<S2SV_ModStart> kzalloc <S2SV_ModEnd> 
2000,<S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> < <S2SV_ModEnd> 
2001,"<S2SV_StartBug> assert ( ( size_t ) CDF_SEC_SIZE ( h ) == len ) ; <S2SV_EndBug> <S2SV_StartBug> return cdf_read ( info , ( off_t ) CDF_SEC_POS ( h , id ) , <S2SV_EndBug> ","<S2SV_ModStart> size_t ss = <S2SV_ModEnd> <S2SV_ModStart> ; size_t pos = CDF_SEC_POS ( h , id ) ; assert ( ss <S2SV_ModStart> pos , <S2SV_ModEnd> "
2002,"<S2SV_StartBug> int client_socket = accept ( listen_socket_ , NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> send ( client_socket_ , ""btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea"" , 16 , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
2003,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( clk_src ) ; 
2004,<S2SV_StartBug> struct buffer_head * page_bufs ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> ,"<S2SV_ModStart> = NULL <S2SV_ModStart> if ( page_bufs && buffer_uninit ( page_bufs ) ) { ext4_set_bh_endio ( page_bufs , inode ) ; ret = block_write_full_page_endio ( page , noalloc_get_block_write , wbc , ext4_end_io_buffer_write ) ; } else "
2005,<S2SV_StartBug> for ( i = 0 ; i < height ; ++ i ) <S2SV_EndBug> ,<S2SV_ModStart> assert ( width > 0 ) ; assert ( height > 0 ) ; assert ( width2 > 0 ) ; assert ( height2 > 0 ) ; 
2006,<S2SV_StartBug> schedule_work ( & sunkbd -> tq ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sunkbd -> enabled ) 
2007,"<S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> <S2SV_StartBug> index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ; <S2SV_EndBug> <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> if ( k < 0 ) continue <S2SV_ModEnd> 
2008,"<S2SV_StartBug> else umount_tree ( mnt , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> UMOUNT_CONNECTED <S2SV_ModEnd> 
2009,<S2SV_StartBug> if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) <S2SV_EndBug> ,<S2SV_ModStart> 4 <S2SV_ModEnd> 
2010,"<S2SV_StartBug> char buffer [ 4096 ] ; <S2SV_EndBug> <S2SV_StartBug> char * buf = buffer , * buf2 = buffer2 , * d , * d_url ; <S2SV_EndBug> <S2SV_StartBug> if ( name_len > sizeof ( buffer ) - 2 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> <S2SV_StartBug> if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) { <S2SV_EndBug> <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , * buf2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> efree ( buf ) ; <S2SV_ModEnd> <S2SV_ModStart> buf2 = estrndup ( value , value_len ) ; <S2SV_ModEnd> <S2SV_ModStart> efree ( buf ) ; efree ( buf2 ) ; <S2SV_ModEnd> "
2011,"<S2SV_StartBug> int q ) { <S2SV_EndBug> <S2SV_StartBug> const double power_term = MIN ( vp9_convert_qindex_to_q ( q ) * 0.0125 + pt_low , <S2SV_EndBug> ","<S2SV_ModStart> , vpx_bit_depth_t bit_depth <S2SV_ModStart> , bit_depth ) * 0.01 <S2SV_ModEnd> "
2012,<S2SV_StartBug> tcp_init_send_head ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> icsk -> icsk_ack . rcv_mss = TCP_MIN_MSS ; 
2013,<S2SV_StartBug> return true ; <S2SV_EndBug> ,<S2SV_ModStart> nf_generic_should_process ( nf_ct_protonum ( ct ) ) <S2SV_ModEnd> 
2014,<S2SV_StartBug> parse_input ( conn ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( <S2SV_ModStart> != 0 ) return 
2015,<S2SV_StartBug> MATLAB_KO : <S2SV_EndBug> ,<S2SV_ModStart> if ( clone_info != ( ImageInfo * ) NULL ) 
2016,"<S2SV_StartBug> if ( ! bgp_attr_print ( ndo , atype , p , alen ) ) <S2SV_EndBug> ","<S2SV_ModStart> , 0 "
2017,<S2SV_StartBug> ext2_xattr_put_super ( sb ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sbi -> s_mb_cache ) { ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } <S2SV_ModEnd> 
2018,<S2SV_StartBug> if ( _payload ) { <S2SV_EndBug> ,<S2SV_ModStart> plen <S2SV_ModEnd> 
2019,"<S2SV_StartBug> sf -> RD = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> thresh_mult [ THR_SPLIT3 ] = speed_map ( Speed , thresh_mult_map_split2 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . error_bins , 0 , sizeof ( cpi -> mb . error_bins ) ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> mb . quantize_b_pair = vp8_regular_quantize_b_pair ; <S2SV_EndBug> <S2SV_StartBug> cpi -> mb . quantize_b = vp8_fast_quantize_b ; <S2SV_EndBug> ",<S2SV_ModStart> cpi -> mb . mbs_zero_last_dot_suppress = 0 ; <S2SV_ModStart> if ( ( cpi -> Speed <= 6 ) && ( cpi -> oxcf . number_of_layers > 1 ) && ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) && ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ) { if ( cpi -> closest_reference_frame == GOLDEN_FRAME ) { sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO2 ] >> 3 ; sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST2 ] >> 3 ; sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR2 ] >> 3 ; } else { sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO2 ] >> 1 ; sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST2 ] >> 1 ; sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR2 ] >> 1 ; } } <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> } else { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2020,<S2SV_StartBug> char * bufptr ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( cnt < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_read"" ) ; } "
2021,"<S2SV_StartBug> struct r_bin_dyldcache_obj_t * bin ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( bin = malloc ( sizeof ( struct r_bin_dyldcache_obj_t ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> memset ( bin , 0 , sizeof ( struct r_bin_dyldcache_obj_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! r_buf_set_bytes ( bin -> b , buf , size ) ) { <S2SV_EndBug> ",<S2SV_ModStart> = R_NEW0 ( struct r_bin_dyldcache_obj_t ) <S2SV_ModStart> bin <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ! bin -> b || 
2022,"<S2SV_StartBug> img = ctx -> iface -> dec . get_frame ( ctx -> priv -> alg_priv , iter ) ; <S2SV_EndBug> ",<S2SV_ModStart> get_alg_priv ( ctx ) <S2SV_ModEnd> 
2023,<S2SV_StartBug> if ( Offset < ( SizeOfHeader + 8 ) ) goto Error ; <S2SV_EndBug> ,<S2SV_ModStart> ) goto Error ; if ( ( Offset + Len ) > SizeOfTag + 8 
2024,"<S2SV_StartBug> static u32 ip_idents_hashrnd __read_mostly ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <S2SV_EndBug> <S2SV_StartBug> hash = jhash_3words ( ( __force u32 ) iph -> daddr , <S2SV_EndBug> <S2SV_StartBug> iph -> protocol ^ net_hash_mix ( net ) , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key <S2SV_ModEnd> <S2SV_ModStart> net -> ipv4 . ip_id_key <S2SV_ModEnd> <S2SV_ModStart> siphash_3u32 <S2SV_ModEnd> <S2SV_ModStart> , & net -> ipv4 . ip_id_key <S2SV_ModEnd> "
2025,"<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_lock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2026,"<S2SV_StartBug> touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> MODE_INVALID <S2SV_ModEnd> 
2027,<S2SV_StartBug> skb_dst_force ( skb ) ; <S2SV_EndBug> ,<S2SV_ModStart> skb_set_err_queue ( skb ) ; 
2028,"<S2SV_StartBug> lua_authz_provider_spec * spec ; <S2SV_EndBug> <S2SV_StartBug> if ( require_line && * require_line ) { <S2SV_EndBug> <S2SV_StartBug> spec -> args = apr_array_make ( cmd -> pool , 2 , sizeof ( const char * ) ) ; <S2SV_EndBug> <S2SV_StartBug> APR_ARRAY_PUSH ( spec -> args , const char * ) = arg ; <S2SV_EndBug> <S2SV_StartBug> * parsed_require_line = spec ; <S2SV_EndBug> ","<S2SV_ModStart> ; lua_authz_provider_func * func = apr_pcalloc ( cmd -> pool , sizeof ( lua_authz_provider_func ) ) <S2SV_ModStart> func -> spec = spec ; <S2SV_ModStart> func <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> "
2029,<S2SV_StartBug> len -= cut ; <S2SV_EndBug> ,<S2SV_ModStart> + 1 
2030,"<S2SV_StartBug> authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT , 0664 ) ; <S2SV_EndBug> <S2SV_StartBug> return retval ; <S2SV_EndBug> ",<S2SV_ModStart> | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY <S2SV_ModStart> if ( cfg -> is_custom_debug_file ) { fclose ( cfg -> debug_file ) ; } 
2031,"<S2SV_StartBug> vpx_memset ( lfi -> lfthr [ lvl ] . lim , block_inside_limit , SIMD_WIDTH ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( lfi -> lfthr [ lvl ] . mblim , ( 2 * ( lvl + 2 ) + block_inside_limit ) , <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
2032,"<S2SV_StartBug> recv ( uipc_main . signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
2033,<S2SV_StartBug> ASSERT ( redir_index < IOAPIC_NUM_PINS ) ; <S2SV_EndBug> <S2SV_StartBug> redir_content = ioapic -> redirtbl [ redir_index ] . bits ; <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; else redir_content = ~ 0ULL 
2034,"<S2SV_StartBug> void <S2SV_EndBug> <S2SV_StartBug> if ( encrypted ) { <S2SV_EndBug> <S2SV_StartBug> # else <S2SV_EndBug> <S2SV_StartBug> cib_send_plaintext ( GPOINTER_TO_INT ( session ) , msg ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int rc = - 1 ; char * xml_text = NULL ; int len = 0 ; xml_text = dump_xml_unformatted ( <S2SV_ModEnd> <S2SV_ModStart> if ( xml_text ) { len = strlen ( xml_text ) ; <S2SV_ModEnd> <S2SV_ModStart> crm_err ( ""Invalid<S2SV_blank>XML,<S2SV_blank>can<S2SV_blank>not<S2SV_blank>send<S2SV_blank>msg"" ) ; return - 1 ; } rc = crm_send_remote_msg_raw ( session , xml_text , len , encrypted ) ; if ( rc < 0 ) { goto done ; } rc = crm_send_remote_msg_raw ( session , REMOTE_MSG_TERMINATOR , strlen ( REMOTE_MSG_TERMINATOR ) , encrypted ) ; done : if ( rc < 0 ) { crm_err ( ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>remote<S2SV_blank>msg,<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>%d"" , rc <S2SV_ModEnd> <S2SV_ModStart> free ( xml_text ) ; return rc ; "
2035,<S2SV_StartBug> ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; <S2SV_EndBug> ,"<S2SV_ModStart> { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } "
2036,<S2SV_StartBug> if ( ( int ) val < 0 ) <S2SV_EndBug> ,<S2SV_ModStart> pmc_overflow ( val ) <S2SV_ModEnd> 
2037,<S2SV_StartBug> } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) <S2SV_EndBug> <S2SV_StartBug> ses -> server -> ops = & smb311_operations ; <S2SV_EndBug> ,<S2SV_ModStart> ses -> server -> vals = & smb21_values ; <S2SV_ModStart> { <S2SV_ModStart> ses -> server -> vals = & smb311_values ; } 
2038,"<S2SV_StartBug> err = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( err <S2SV_ModEnd> "
2039,<S2SV_StartBug> if ( report -> id == REPORT_KEY_STATE ) { <S2SV_EndBug> ,"<S2SV_ModStart> size > 64 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>picolcd<S2SV_blank>raw<S2SV_blank>event\\n"" , size ) ; return 0 ; } if ( "
2040,<S2SV_StartBug> struct rt6_info * rt = ( struct rt6_info * ) dst ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( dst -> ops -> family != AF_INET6 ) { dst_release ( dst ) ; return NULL ; } rt = ( struct rt6_info * ) dst 
2041,<S2SV_StartBug> done : <S2SV_EndBug> <S2SV_StartBug> ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> done : 
2042,"<S2SV_StartBug> json_t * object , * foo , * bar , * baz ; <S2SV_EndBug> <S2SV_StartBug> void * iter ; <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( json_object_iter_key ( iter ) , ""a"" ) ) <S2SV_EndBug> <S2SV_StartBug> fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ; <S2SV_EndBug> <S2SV_StartBug> iter = json_object_iter_next ( object , iter ) ; <S2SV_EndBug> <S2SV_StartBug> fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( json_object_iter_value ( iter ) != bar ) <S2SV_EndBug> <S2SV_StartBug> if ( json_object_iter_value ( iter ) != baz ) <S2SV_EndBug> ","<S2SV_ModStart> int i ; <S2SV_ModStart> const char * iter_keys [ 3 ] ; int have_key [ 3 ] = { 0 , 0 , 0 } ; json_t * iter_values [ 3 ] ; <S2SV_ModStart> iter_keys [ 0 ] = json_object_iter_key ( iter ) ; iter_values [ 0 ] = json_object_iter_value ( iter ) ; iter = json_object_iter_next ( object , iter ) ; if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ; iter_keys [ 1 ] = json_object_iter_key ( iter ) ; iter_values [ 1 ] = json_object_iter_value ( iter ) ; iter = json_object_iter_next ( object , iter ) ; if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ; iter_keys [ 2 ] = json_object_iter_key ( iter ) ; iter_values [ 2 ] = json_object_iter_value ( iter ) ; if ( json_object_iter_next ( object , iter ) != NULL ) fail ( ""able<S2SV_blank>to<S2SV_blank>iterate<S2SV_blank>over<S2SV_blank>the<S2SV_blank>end"" ) ; for ( i = 0 ; i < 3 ; i ++ ) { <S2SV_ModStart> iter_keys [ i ] <S2SV_ModEnd> <S2SV_ModStart> == 0 ) { if ( iter_values [ i ] <S2SV_ModEnd> <S2SV_ModStart> ""wrong<S2SV_blank>value<S2SV_blank>for<S2SV_blank>iter<S2SV_blank>key<S2SV_blank>a"" ) ; else have_key [ 0 ] = 1 ; } else if ( strcmp ( iter_keys [ i ] , ""b"" ) == 0 ) { if ( iter_values [ i ] != bar ) fail ( ""wrong<S2SV_blank>value<S2SV_blank>for<S2SV_blank>iter<S2SV_blank>key<S2SV_blank>b"" ) ; else have_key [ 1 ] = 1 ; } else if ( strcmp ( iter_keys [ i ] , ""c"" ) == 0 ) { if ( iter_values [ i ] != baz ) fail ( ""wrong<S2SV_blank>value<S2SV_blank>for<S2SV_blank>iter<S2SV_blank>key<S2SV_blank>c"" ) ; else have_key [ 2 ] = 1 ; } } for ( i = 0 ; i < 3 ; i ++ ) { if ( ! have_key [ i ] ) fail ( ""a<S2SV_blank>key<S2SV_blank>wasn\'t<S2SV_blank>iterated<S2SV_blank>over"" ) ; } if ( json_object_iter_at ( object , ""foo"" ) ) fail ( ""json_object_iter_at()<S2SV_blank>succeeds<S2SV_blank>for<S2SV_blank>non-existent<S2SV_blank>key"" ) ; iter = json_object_iter_at ( object , ""b"" ) ; if ( ! iter ) fail ( ""json_object_iter_at()<S2SV_blank>fails<S2SV_blank>for<S2SV_blank>an<S2SV_blank>existing<S2SV_blank>key"" ) ; if ( strcmp ( json_object_iter_key ( iter ) , ""b"" ) ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ; if ( json_object_iter_value ( iter ) != bar ) fail ( <S2SV_ModStart> if ( json_object_iter_set ( object , iter , baz ) ) fail ( ""unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>value<S2SV_blank>at<S2SV_blank>iterator"" <S2SV_ModEnd> <S2SV_ModStart> ""json_object_iter_key()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()"" <S2SV_ModEnd> <S2SV_ModStart> baz ) fail ( ""json_object_iter_value()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()"" ) ; if ( json_object_get ( object , ""b"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2043,"<S2SV_StartBug> memcpy ( serial -> value , priv -> cac_id , priv -> cac_id_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> serial -> len <S2SV_ModEnd> 
2044,<S2SV_StartBug> for ( i = 0 ; i < 4 && out -> data [ i ] ; i ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && out -> linesize [ i ] 
2045,<S2SV_StartBug> if ( ( intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR ) <S2SV_EndBug> ,<S2SV_ModStart> is_nmi ( intr_info ) <S2SV_ModEnd> 
2046,<S2SV_StartBug> unsigned char * data ; <S2SV_EndBug> <S2SV_StartBug> data32 = ( uint32_t * ) data ; <S2SV_EndBug> <S2SV_StartBug> data32 [ i ] ^= wsctx -> header . mask . u ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> uint32_t tmp ; memcpy ( & tmp , data + i * sizeof ( tmp ) , sizeof ( tmp ) ) ; tmp <S2SV_ModEnd> <S2SV_ModStart> ; memcpy ( data + i * sizeof ( tmp ) , & tmp , sizeof ( tmp ) ) "
2047,"<S2SV_StartBug> return mount_pseudo ( fs_type , ""aio:"" , NULL , & ops , AIO_RING_MAGIC ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> struct dentry * root = <S2SV_ModEnd> <S2SV_ModStart> if ( ! IS_ERR ( root ) ) root -> d_sb -> s_iflags |= SB_I_NOEXEC ; return root ; 
2048,<S2SV_StartBug> * dptr ++ = 0xAA ; <S2SV_EndBug> ,<S2SV_ModStart> ROSE_CALL_REQ_ADDR_LEN_VAL <S2SV_ModEnd> 
2049,<S2SV_StartBug> xmep -> proc = EXTRACT_32BITS ( & rp -> rm_call . cb_proc ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! ND_TTEST ( rp -> rm_call . cb_proc ) ) return ( 0 ) ; <S2SV_ModStart> ) ; if ( ! ND_TTEST ( rp -> rm_call . cb_vers ) ) return ( 0 
2050,"<S2SV_StartBug> vmcs_write32 ( TPR_THRESHOLD , vmcs12 -> tpr_threshold ) ; <S2SV_EndBug> ",<S2SV_ModStart> } else { # ifdef CONFIG_X86_64 exec_control |= CPU_BASED_CR8_LOAD_EXITING | CPU_BASED_CR8_STORE_EXITING ; # endif 
2051,"<S2SV_StartBug> ! ( e -> ip . flags & IPT_F_GOTO ) ) <S2SV_EndBug> <S2SV_StartBug> e = get_entry ( table_base , v ) ; <S2SV_EndBug> ",<S2SV_ModStart> { if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; } <S2SV_ModStart> } 
2052,<S2SV_StartBug> int nNew = pSorter -> nMemory * 2 ; <S2SV_EndBug> ,<S2SV_ModStart> sqlite3_int64 nNew = 2 * ( sqlite3_int64 ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2053,<S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> switch ( EXTRACT_16BITS ( bp ) ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } return ; <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( bp ) ; 
2054,<S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> sock * sk = asoc -> base . sk ; struct <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2055,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> return TEE_SUCCESS ; <S2SV_EndBug> ,"<S2SV_ModStart> size_t req_size = 0 ; <S2SV_ModStart> if ( ADD_OVERFLOW ( mem -> offs , mem -> size , & req_size ) || mem -> mobj -> size < req_size ) return TEE_ERROR_SECURITY ; "
2056,"<S2SV_StartBug> int ret = proc_dointvec ( table , write , buffer , lenp , ppos ) ; <S2SV_EndBug> ",<S2SV_ModStart> proc_dointvec_minmax <S2SV_ModEnd> 
2057,<S2SV_StartBug> return ret <= 0 ? ret : - EIO ; <S2SV_EndBug> ,<S2SV_ModStart> < <S2SV_ModEnd> 
2058,<S2SV_StartBug> int rc = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! scontext_len ) return - EINVAL 
2059,<S2SV_StartBug> char * identifier ; <S2SV_EndBug> <S2SV_StartBug> return ERROR_INSUFFICIENT_MEMORY ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> r1 . o = function -> return_obj ; <S2SV_EndBug> <S2SV_StartBug> yr_modules_unload_all ( context ) ; <S2SV_EndBug> ,"<S2SV_ModStart> YR_OBJECT * * obj_ptr ; YR_ARENA * obj_arena ; <S2SV_ModStart> ; FAIL_ON_ERROR_WITH_CLEANUP ( yr_arena_create ( 1024 , 0 , & obj_arena ) , yr_free ( stack ) ) <S2SV_ModStart> assert ( sp == 0 ) ; <S2SV_ModStart> result = yr_object_copy ( function -> return_obj , & <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( result == ERROR_SUCCESS ) result = yr_arena_write_data ( obj_arena , & r1 . o , sizeof ( r1 . o ) , NULL ) ; stop = ( result != ERROR_SUCCESS ) ; push ( r1 ) ; <S2SV_ModEnd> <S2SV_ModStart> obj_ptr = ( YR_OBJECT * * ) yr_arena_base_address ( obj_arena ) ; while ( obj_ptr != NULL ) { yr_object_destroy ( * obj_ptr ) ; obj_ptr = ( YR_OBJECT * * ) yr_arena_next_address ( obj_arena , obj_ptr , sizeof ( YR_OBJECT * ) ) ; } yr_arena_destroy ( obj_arena ) ; "
2060,<S2SV_StartBug> err = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> ds = salg -> digestsize ; <S2SV_EndBug> <S2SV_StartBug> ss = salg -> statesize ; <S2SV_EndBug> ,<S2SV_ModStart> alg = & salg -> base ; <S2SV_ModStart> if ( crypto_shash_alg_has_setkey ( salg ) ) goto out_put_alg ; <S2SV_ModStart>  <S2SV_ModEnd> 
2061,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2062,"<S2SV_StartBug> _pam_log ( LOG_DEBUG , ""server[%lu]<S2SV_blank>{<S2SV_blank>addr=%s,<S2SV_blank>key=\'%s\'<S2SV_blank>}"" , n , tac_ntop ( tac_srv [ n ] . addr -> ai_addr ) , <S2SV_EndBug> ","<S2SV_ModStart> ""server[%lu]<S2SV_blank>{<S2SV_blank>addr=%s,<S2SV_blank>key=\'********\'<S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2063,"<S2SV_StartBug> vpx_memcpy ( p , vp8_bmode_prob , sizeof ( vp8_bmode_prob ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> 
2064,<S2SV_StartBug> client -> connectTimeout = DEFAULT_CONNECT_TIMEOUT ; <S2SV_EndBug> ,<S2SV_ModStart> ; client -> readTimeout = DEFAULT_READ_TIMEOUT 
2065,<S2SV_StartBug> for ( plane = 0 ; inpic -> data [ plane ] && plane < 4 ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && inpic -> data [ plane ] && inpic -> linesize [ plane ] 
2066,"<S2SV_StartBug> map = q -> bufs [ first ] -> map = kmalloc ( sizeof ( struct videobuf_mapping ) , GFP_KERNEL ) ; <S2SV_EndBug> ",<S2SV_ModStart> kzalloc <S2SV_ModEnd> 
2067,<S2SV_StartBug> sock -> sk -> sk_uid = iattr -> ia_uid ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( sock -> sk ) <S2SV_ModStart> else err = - ENOENT ; 
2068,<S2SV_StartBug> struct sk_buff * skb ; <S2SV_EndBug> <S2SV_StartBug> ipc . opt = inet -> opt ; <S2SV_EndBug> <S2SV_StartBug> if ( ipc . opt && ipc . opt -> srr ) { <S2SV_EndBug> <S2SV_StartBug> faddr = ipc . opt -> faddr ; <S2SV_EndBug> <S2SV_StartBug> ( ipc . opt && ipc . opt -> is_strictroute ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> ; struct ip_options_data opt_copy <S2SV_ModStart> { struct ip_options_rcu * inet_opt ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt ) { memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ; ipc . opt = & opt_copy . opt ; } rcu_read_unlock ( ) ; } <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> opt . "
2069,<S2SV_StartBug> for ( vma = mm -> mmap ; vma ; vma = vma -> vm_next ) <S2SV_EndBug> ,<S2SV_ModStart> VM_WARN_ON ( ! mmget_still_valid ( mm ) ) ; 
2070,"<S2SV_StartBug> ret = ext4_convert_unwritten_extents_endio ( handle , inode , <S2SV_EndBug> ","<S2SV_ModStart> map , "
2071,"<S2SV_StartBug> if ( mi < 0 ) <S2SV_EndBug> <S2SV_StartBug> idev -> info -> mem [ mi ] . addr >> PAGE_SHIFT , <S2SV_EndBug> ",<S2SV_ModStart> struct uio_mem * mem ; <S2SV_ModStart> ) return - EINVAL ; mem = idev -> info -> mem + mi ; if ( vma -> vm_end - vma -> vm_start > mem -> size <S2SV_ModStart> mem -> <S2SV_ModEnd> 
2072,"<S2SV_StartBug> mpz_t xdiff , ydiff , lambda ; <S2SV_EndBug> <S2SV_StartBug> mpz_clears ( xdiff , ydiff , lambda , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( pointZZ_pIsIdentityElement ( op1 ) && pointZZ_pIsIdentityElement ( op2 ) ) { return pointZZ_pSetToIdentityElement ( rop ) ; } else if ( pointZZ_pIsIdentityElement ( op1 ) ) { mpz_set ( rop -> x , op2 -> x ) ; mpz_set ( rop -> y , op2 -> y ) ; return ; } else if ( pointZZ_pIsIdentityElement ( op2 ) ) { mpz_set ( rop -> x , op1 -> x ) ; mpz_set ( rop -> y , op1 -> y ) ; return ; } if ( pointZZ_pEqual ( op1 , op2 ) ) { pointZZ_pDouble ( rop , op1 , curve ) ; return ; } mpz_t negy ; mpz_init ( negy ) ; mpz_sub ( negy , curve -> p , op2 -> y ) ; if ( mpz_cmp ( op1 -> x , op2 -> x ) == 0 && mpz_cmp ( op1 -> y , negy ) == 0 ) { mpz_clear ( negy ) ; return pointZZ_pSetToIdentityElement ( rop ) ; } mpz_t <S2SV_ModEnd> <S2SV_ModStart> negy , "
2073,"<S2SV_StartBug> char * ext , szName [ 1000 ] , szExt [ 20 ] ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( szName , url ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ext && strlen ( ext ) > 1 ) { <S2SV_EndBug> ",<S2SV_ModStart> 1024 <S2SV_ModEnd> <S2SV_ModStart> if ( strlen ( url ) >= sizeof ( szName ) ) return GF_FALSE ; <S2SV_ModStart> && strlen ( ext ) <= sizeof ( szExt ) 
2074,"<S2SV_StartBug> vdev -> ctx = kzalloc ( nvec * sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ; <S2SV_EndBug> ","<S2SV_ModStart> kcalloc ( nvec , <S2SV_ModEnd> "
2075,<S2SV_StartBug> int rc = 0 ; <S2SV_EndBug> <S2SV_StartBug> * uaddrlen = sizeof ( sllc ) ; <S2SV_EndBug> ,"<S2SV_ModStart> - EBADF ; memset ( & sllc , 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2076,<S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> if ( vmx_get_cpl ( vcpu ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 0 ; } "
2077,<S2SV_StartBug> if ( atomic_dec_and_test ( & ucounts -> count ) ) { <S2SV_EndBug> <S2SV_StartBug> hlist_del_init ( & ucounts -> node ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ucounts -> count -= 1 ; if ( ! ucounts -> count ) <S2SV_ModStart> ; else ucounts = NULL <S2SV_ModStart>  <S2SV_ModEnd> 
2078,<S2SV_StartBug> data = img -> img_data ; <S2SV_EndBug> <S2SV_StartBug> data + x + y * img -> stride [ VPX_PLANE_ALPHA ] ; <S2SV_EndBug> <S2SV_StartBug> img -> planes [ VPX_PLANE_Y ] = data + x + y * img -> stride [ VPX_PLANE_Y ] ; <S2SV_EndBug> <S2SV_StartBug> img -> planes [ VPX_PLANE_U ] = data <S2SV_EndBug> <S2SV_StartBug> + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ; <S2SV_EndBug> <S2SV_StartBug> img -> planes [ VPX_PLANE_V ] = data <S2SV_EndBug> <S2SV_StartBug> + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ; <S2SV_EndBug> <S2SV_StartBug> img -> planes [ VPX_PLANE_V ] = data <S2SV_EndBug> <S2SV_StartBug> + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ; <S2SV_EndBug> <S2SV_StartBug> img -> planes [ VPX_PLANE_U ] = data <S2SV_EndBug> <S2SV_StartBug> + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ; <S2SV_EndBug> ,<S2SV_ModStart> const int bytes_per_sample = ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ; <S2SV_ModStart> * bytes_per_sample <S2SV_ModStart> * bytes_per_sample + <S2SV_ModEnd> <S2SV_ModStart> data <S2SV_ModEnd> <S2SV_ModStart> * bytes_per_sample + <S2SV_ModEnd> <S2SV_ModStart> data <S2SV_ModEnd> <S2SV_ModStart> * bytes_per_sample + <S2SV_ModEnd> <S2SV_ModStart> data <S2SV_ModEnd> <S2SV_ModStart> * bytes_per_sample + <S2SV_ModEnd> <S2SV_ModStart> data <S2SV_ModEnd> <S2SV_ModStart> * bytes_per_sample + <S2SV_ModEnd> 
2079,"<S2SV_StartBug> JAS_DBGLOG ( 101 , ( ""jas_realloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%x,%zu\\n"" , ptr , size ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""jas_realloc(%x,<S2SV_blank>%zu)\\n"" <S2SV_ModEnd> "
2080,<S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2081,"<S2SV_StartBug> vpx_memcpy ( cm -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> 
2082,<S2SV_StartBug> int mapping_address = address - mb_mapping -> start_bits ; <S2SV_EndBug> <S2SV_StartBug> if ( nb < 1 || MODBUS_MAX_WRITE_BITS < nb ) { <S2SV_EndBug> <S2SV_StartBug> int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb ) { <S2SV_EndBug> ,<S2SV_ModStart> nb_bits = req [ offset + 5 ] ; int <S2SV_ModStart> || nb_bits * 8 < nb <S2SV_ModStart> ] ; int nb_bytes = req [ offset + 5 <S2SV_ModStart> < nb || nb_bytes * 8 
2083,"<S2SV_StartBug> int ret = 0 , found = 0 ; <S2SV_EndBug> <S2SV_StartBug> repo_config = perf_pathdup ( ""config"" ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2084,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % ( 4 * stride ) ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horDiff32"" , ""%s"" , ""(cc%(4*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; "
2085,"<S2SV_StartBug> bestsad = fn_ptr -> sdf ( what , what_stride , in_what , in_what_stride , UINT_MAX ) <S2SV_EndBug> <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2086,<S2SV_StartBug> if ( A > skb -> len - sizeof ( struct nlattr ) ) <S2SV_EndBug> <S2SV_StartBug> if ( nla -> nla_len > A - skb -> len ) <S2SV_EndBug> ,<S2SV_ModStart> skb -> len < sizeof ( struct nlattr ) ) return 0 ; if ( <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> - A 
2087,<S2SV_StartBug> total = le32_to_cpu ( raw_super -> segment_count ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( f2fs_cp_error ( sbi ) ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> unsigned int main_segs , blocks_per_seg ; int i ; <S2SV_ModStart> main_segs = le32_to_cpu ( raw_super -> segment_count_main ) ; blocks_per_seg = sbi -> blocks_per_seg ; for ( i = 0 ; i < NR_CURSEG_NODE_TYPE ; i ++ ) { if ( le32_to_cpu ( ckpt -> cur_node_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_node_blkoff [ i ] ) >= blocks_per_seg ) return 1 ; } for ( i = 0 ; i < NR_CURSEG_DATA_TYPE ; i ++ ) { if ( le32_to_cpu ( ckpt -> cur_data_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_data_blkoff [ i ] ) >= blocks_per_seg ) return 1 ; } "
2088,"<S2SV_StartBug> REQ ( n , suite ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 2 ; i < ( NCH ( n ) - 1 ) ; i ++ ) { <S2SV_EndBug> ","<S2SV_ModStart> if ( TYPE ( n ) != func_body_suite ) { <S2SV_ModStart> } <S2SV_ModStart> i = 2 ; if ( TYPE ( CHILD ( n , 1 ) ) == TYPE_COMMENT ) { i += 2 ; REQ ( CHILD ( n , 2 ) , NEWLINE ) ; } for ( <S2SV_ModEnd> "
2089,"<S2SV_StartBug> int status = - 1 ; <S2SV_EndBug> <S2SV_StartBug> ALOGV ( ""%s<S2SV_blank>context<S2SV_blank>%p"" , __func__ , handle ) ; <S2SV_EndBug> <S2SV_StartBug> pthread_mutex_lock ( & vol_listner_init_lock ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( memcmp ( & ( context -> desc -> uuid ) , & ( recv_contex -> desc -> uuid ) , sizeof ( effect_uuid_t ) ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> && ( context -> session_id == recv_contex -> session_id ) <S2SV_EndBug> <S2SV_StartBug> && ( context -> stream_type == recv_contex -> stream_type ) ) { <S2SV_EndBug> <S2SV_StartBug> list_remove ( & context -> effect_list_node ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> EINVAL <S2SV_ModEnd> <S2SV_ModStart> uint32_t session_id ; uint32_t stream_type ; effect_uuid_t uuid ; <S2SV_ModStart> if ( recv_contex == NULL ) { return status ; } <S2SV_ModStart> ; session_id = recv_contex -> session_id ; stream_type = recv_contex -> stream_type ; uuid = recv_contex -> desc -> uuid <S2SV_ModStart> uuid <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> node <S2SV_ModEnd> <S2SV_ModStart> pthread_mutex_unlock ( & vol_listner_init_lock ) ; return status ; 
2090,<S2SV_StartBug> w -> linebreak = 1 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( w -> linebreak || w == text_info -> glyphs ) text_info -> n_lines -- ; if ( w != text_info -> glyphs ) 
2091,<S2SV_StartBug> if ( state -> expr_list . size == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( seq -> size == 1 ) <S2SV_EndBug> ,<S2SV_ModStart> ! state -> fmode ) { assert ( ! <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2092,<S2SV_StartBug> if ( vma -> vm_flags & ( VM_DONTEXPAND | VM_PFNMAP ) ) { <S2SV_EndBug> ,<S2SV_ModStart> new_len > old_len ) { unsigned long pgoff ; if ( <S2SV_ModStart> goto Efault ; pgoff = ( addr - vma -> vm_start ) >> PAGE_SHIFT ; pgoff += vma -> vm_pgoff ; if ( pgoff + ( new_len >> PAGE_SHIFT ) < pgoff ) goto Einval <S2SV_ModEnd> 
2093,<S2SV_StartBug> kvm_async_pf_hash_reset ( vcpu ) ; <S2SV_EndBug> ,<S2SV_ModStart> vcpu -> arch . pv_time_enabled = false ; 
2094,<S2SV_StartBug> tfrc . tfrctx_x = hc -> tx_x ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & tfrc , 0 , sizeof ( tfrc ) ) ; "
2095,<S2SV_StartBug> if ( ! is_exception ( intr_info ) ) <S2SV_EndBug> ,<S2SV_ModStart> is_nmi <S2SV_ModEnd> 
2096,<S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> n ++ ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> if ( n == nitems ( p ) ) { free ( copy ) ; return ; } } 
2097,<S2SV_StartBug> void ext4_xattr_destroy_cache ( struct mb_cache * cache ) <S2SV_EndBug> <S2SV_StartBug> mb_cache_destroy ( cache ) ; <S2SV_EndBug> ,<S2SV_ModStart> mb2_cache <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_destroy <S2SV_ModEnd> 
2098,"<S2SV_StartBug> static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs ) <S2SV_EndBug> <S2SV_StartBug> fclose ( fp ) ; <S2SV_EndBug> ","<S2SV_ModStart> , uid_t uid , gid_t gid <S2SV_ModStart> const int dest_fd = fileno ( fp ) ; if ( fchown ( dest_fd , uid , gid ) < 0 ) { perror_msg ( ""Can\'t<S2SV_blank>change<S2SV_blank>\'%s\'<S2SV_blank>ownership<S2SV_blank>to<S2SV_blank>%lu:%lu"" , dest_filename , ( long ) uid , ( long ) gid ) ; fclose ( fp ) ; unlink ( dest_filename ) ; return false ; } "
2099,<S2SV_StartBug> u1_nal_unit_type = NAL_UNIT_TYPE ( u1_first_byte ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ( ps_dec -> u2_total_mbs_coded != 0 ) && ( u1_nal_unit_type > IDR_SLICE_NAL ) ) { return ERROR_INCOMPLETE_FRAME ; } 
2100,"<S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2101,"<S2SV_StartBug> PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; <S2SV_EndBug> <S2SV_StartBug> zval * * tmp ; <S2SV_EndBug> <S2SV_StartBug> efree ( name ) ; <S2SV_EndBug> <S2SV_StartBug> php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ; <S2SV_EndBug> <S2SV_StartBug> PS_ADD_VARL ( name , namelen ) ; <S2SV_EndBug> ",<S2SV_ModStart> int skip = 0 ; <S2SV_ModStart> ; skip = 0 <S2SV_ModStart> skip = 1 <S2SV_ModEnd> <S2SV_ModStart> if ( ! skip ) { <S2SV_ModStart> } <S2SV_ModStart> if ( ! skip ) { <S2SV_ModStart> } 
2102,<S2SV_StartBug> if ( mode > 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> != MODE_INVALID <S2SV_ModEnd> 
2103,"<S2SV_StartBug> if ( sk_filter ( sk , skb ) ) <S2SV_EndBug> ",<S2SV_ModStart> tcp_filter <S2SV_ModEnd> 
2104,"<S2SV_StartBug> uint32_t bcount ; <S2SV_EndBug> <S2SV_StartBug> int supported = TRUE , format ; <S2SV_EndBug> ","<S2SV_ModStart> int format_chunk = 0 ; <S2SV_ModStart> if ( format_chunk ++ ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } "
2105,<S2SV_StartBug> static int get_max_filter_level ( VP9_COMP * cpi ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> const <S2SV_ModStart> ) { if ( cpi -> oxcf . pass == 2 <S2SV_ModStart> else { return MAX_LOOP_FILTER ; } } 
2106,<S2SV_StartBug> for ( ifa1 = in_dev -> ifa_list ; ifa1 ; ifa1 = ifa1 -> ifa_next ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( in_dev -> dead ) goto no_promotions ; <S2SV_ModStart> no_promotions : 
2107,<S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> sysctl_head_finish ( head ) ; <S2SV_EndBug> ,<S2SV_ModStart> goto out <S2SV_ModEnd> <S2SV_ModStart> out : 
2108,<S2SV_StartBug> char * tmp_str ; <S2SV_EndBug> <S2SV_StartBug> if ( ! tmp_str [ i ] ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> int j = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! tmp_str [ j ] ) <S2SV_EndBug> <S2SV_StartBug> if ( j ) { <S2SV_EndBug> <S2SV_StartBug> int j = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! tmp_str [ j ] ) <S2SV_EndBug> <S2SV_StartBug> if ( j ) { <S2SV_EndBug> <S2SV_StartBug> while ( tmp_strsize ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! tmp_str [ i ] ) <S2SV_EndBug> <S2SV_StartBug> if ( i ) { <S2SV_EndBug> <S2SV_StartBug> while ( tmp_strsize ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! tmp_str [ i ] ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ; Bool zfound = GF_FALSE <S2SV_ModStart> { zfound = GF_TRUE ; break ; } <S2SV_ModEnd> <S2SV_ModStart> if ( ! zfound ) return GF_ISOM_INVALID_FILE ; <S2SV_ModStart> ; zfound = GF_FALSE <S2SV_ModStart> { zfound = GF_TRUE ; break ; } <S2SV_ModEnd> <S2SV_ModStart> ! zfound ) return GF_ISOM_INVALID_FILE ; if ( <S2SV_ModStart> ; zfound = GF_FALSE <S2SV_ModStart> { zfound = GF_TRUE ; break ; } <S2SV_ModEnd> <S2SV_ModStart> ! zfound ) return GF_ISOM_INVALID_FILE ; if ( <S2SV_ModStart> zfound = GF_FALSE ; <S2SV_ModStart> { zfound = GF_TRUE ; break ; } <S2SV_ModEnd> <S2SV_ModStart> ! zfound ) return GF_ISOM_INVALID_FILE ; if ( <S2SV_ModStart> zfound = GF_FALSE ; <S2SV_ModStart> { zfound = GF_TRUE ; break ; } <S2SV_ModEnd> <S2SV_ModStart> if ( ! zfound ) return GF_ISOM_INVALID_FILE ; 
2109,<S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug> ,<S2SV_ModStart> mb2_cache <S2SV_ModEnd> 
2110,<S2SV_StartBug> for ( s = 0 ; s < ns ; s ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && row < imagelength 
2111,<S2SV_StartBug> if ( len < 0 || addr . nl_pid ) { <S2SV_EndBug> <S2SV_StartBug> incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( addr . nl_pid ) { syslog ( LOG_WARNING , ""Received<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>untrusted<S2SV_blank>pid:%u"" , addr . nl_pid ) ; continue ; } "
2112,"<S2SV_StartBug> int ntlm_read_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <S2SV_EndBug> ",<S2SV_ModStart> static 
2113,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> av_assert1 ( avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ; <S2SV_EndBug> ,<S2SV_ModStart> MpegEncContext * s = avctx -> priv_data ; <S2SV_ModStart> s -> studio_profile <S2SV_ModEnd> 
2114,"<S2SV_StartBug> struct in6_addr * saddr = NULL , * final_p , final ; <S2SV_EndBug> <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> if ( np -> opt != NULL ) <S2SV_EndBug> <S2SV_StartBug> icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen + <S2SV_EndBug> <S2SV_StartBug> np -> opt -> opt_nflen ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; struct ipv6_txoptions * opt <S2SV_ModStart> opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> opt <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2115,"<S2SV_StartBug> cpi -> ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME ; <S2SV_EndBug> <S2SV_StartBug> cpi -> temporal_pattern_counter = 0 ; <S2SV_EndBug> <S2SV_StartBug> cm -> Width = cpi -> oxcf . Width ; <S2SV_EndBug> <S2SV_StartBug> cm -> Height = cpi -> oxcf . Height ; <S2SV_EndBug> <S2SV_StartBug> vp8_denoiser_allocate ( & cpi -> denoiser , width , height ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> temporal_layer_id > 0 ) { cpi -> temporal_layer_id = 0 ; } <S2SV_ModStart> if ( ! cpi -> initial_width ) { cpi -> initial_width = cpi -> oxcf . Width ; cpi -> initial_height = cpi -> oxcf . Height ; } cm -> Width = cpi -> oxcf . Width <S2SV_ModEnd> <S2SV_ModStart> ; assert ( cm -> Width <= cpi -> initial_width ) ; assert ( cm -> Height <= cpi -> initial_height ) <S2SV_ModStart> , cm -> mb_rows , cm -> mb_cols , cpi -> oxcf . noise_sensitivity "
2116,<S2SV_StartBug> if ( tcp -> csty & J2K_CP_CSTY_SOP ) { <S2SV_EndBug> <S2SV_StartBug> if ( tcp -> csty & J2K_CP_CSTY_EPH ) { <S2SV_EndBug> ,"<S2SV_ModStart> if ( length < 6 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n"" , length , 6 ) ; } return OPJ_FALSE ; } <S2SV_ModStart> if ( length < 2 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n"" , length , 2 ) ; } return OPJ_FALSE ; } "
2117,<S2SV_StartBug> if ( sum_calculated != headersum ) { <S2SV_EndBug> ,<S2SV_ModStart> lha -> compsize < 0 ) goto invalid ; if ( 
2118,<S2SV_StartBug> ( * size ) ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! allocate_field ( stream , field -> pField , field -> data_size , ( size_t ) ( * size + 1 ) ) ) return false ; field -> pData = * ( char * * ) field -> pField + field -> data_size * ( * size ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
2119,<S2SV_StartBug> rfcomm_dlc_accept ( d ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; msg -> msg_namelen = 0 
2120,"<S2SV_StartBug> static vpx_codec_err_t vp8e_update_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2121,"<S2SV_StartBug> memcpy ( & bss_cfg -> wmm_info , wmm_ie + <S2SV_EndBug> <S2SV_StartBug> sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> > sizeof ( struct mwifiex_types_wmm_info ) ) return ; memcpy ( & bss_cfg -> wmm_info , wmm_ie + sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) "
2122,"<S2SV_StartBug> FILE * file = fopen ( dump_file , ""w"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> fopen_safe <S2SV_ModEnd> 
2123,<S2SV_StartBug> if ( d_mountpoint ( dentry ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ( exp -> ex_flags & NFSEXP_V4ROOT ) ) <S2SV_EndBug> <S2SV_StartBug> return d_inode ( dentry ) != NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ! d_inode <S2SV_ModEnd> <S2SV_ModStart> ) return 0 ; if ( exp -> ex_flags & NFSEXP_V4ROOT <S2SV_ModStart> d_mountpoint ( dentry ) ) return 2 ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2124,<S2SV_StartBug> StringValue ( data ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! RTEST ( rb_attr_get ( self , id_key_set ) ) ) ossl_raise ( eCipherError , ""key<S2SV_blank>not<S2SV_blank>set"" ) ; "
2125,"<S2SV_StartBug> p = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
2126,"<S2SV_StartBug> int pkt_len , pktnum , hr , min , sec , csec ; <S2SV_EndBug> <S2SV_StartBug> num_items_scanned = sscanf ( line + 64 , ""LEN=%9d"" , & pkt_len ) ; <S2SV_EndBug> <S2SV_StartBug> phdr -> rec_type = REC_TYPE_PACKET ; <S2SV_EndBug> <S2SV_StartBug> ws_buffer_assure_space ( buf , TOSHIBA_MAX_PACKET_LEN ) ; <S2SV_EndBug> ","<S2SV_ModStart> guint pkt_len ; int <S2SV_ModEnd> <S2SV_ModStart> ""LEN=%9u"" <S2SV_ModEnd> <S2SV_ModStart> if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( ""toshiba:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u"" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } <S2SV_ModStart> pkt_len <S2SV_ModEnd> "
2127,<S2SV_StartBug> long timeo ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2128,"<S2SV_StartBug> int nNew = MAX ( 128 , p -> nAlloc * 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart> sqlite3_int64 <S2SV_ModEnd> <S2SV_ModStart> 2 * ( sqlite3_int64 ) <S2SV_ModStart>  <S2SV_ModEnd> 
2129,"<S2SV_StartBug> void vp9_iht16x16_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> 
2130,"<S2SV_StartBug> xfs_daddr_t blkno = map [ 0 ] . bm_bn ; <S2SV_EndBug> <S2SV_StartBug> pag = xfs_perag_get ( btp -> bt_mount , <S2SV_EndBug> ","<S2SV_ModStart> ; xfs_daddr_t eofs <S2SV_ModStart> eofs = XFS_FSB_TO_BB ( btp -> bt_mount , btp -> bt_mount -> m_sb . sb_dblocks ) ; if ( blkno >= eofs ) { xfs_alert ( btp -> bt_mount , ""%s:<S2SV_blank>Block<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>block<S2SV_blank>0x%llx,<S2SV_blank>EOFS<S2SV_blank>0x%llx<S2SV_blank>"" , __func__ , blkno , eofs ) ; return NULL ; } "
2131,<S2SV_StartBug> fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ; <S2SV_EndBug> <S2SV_StartBug> fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ; <S2SV_EndBug> ,"<S2SV_ModStart> fptr_orig = io_get_open_fptr ( mrb , orig ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
2132,"<S2SV_StartBug> ret = poll ( pfds , 1 , 50 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
2133,<S2SV_StartBug> struct flowi6 * fl6 = & inet -> cork . fl . u . ip6 ; <S2SV_EndBug> <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> fl6 ; int err = 0 ; int is_udplite = IS_UDPLITE ( sk ) ; __wsum csum = 0 ; if ( up -> pending == AF_INET ) return udp_push_pending_frames ( sk ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
2134,"<S2SV_StartBug> while ( c && cJSON_strcasecmp ( c -> string , string ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> i ++ , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2135,<S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug> ,<S2SV_ModStart> ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> 
2136,<S2SV_StartBug> upperdentry = ovl_dentry_upper ( dentry ) ; <S2SV_EndBug> <S2SV_StartBug> if ( upperdentry ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ,<S2SV_ModStart> err = ovl_copy_up ( dentry ) ; if ( ! err ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2137,<S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! tls_desc_okay ( & info ) ) return - EINVAL 
2138,<S2SV_StartBug> if ( rc == - 1 ) <S2SV_EndBug> ,<S2SV_ModStart> mutt_socket_empty ( adata -> conn ) ; 
2139,<S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> ret = - EIO ; goto out <S2SV_ModEnd> <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> goto out ; } ret = snprintf ( buf , PAGE_SIZE , ""%d\\n"" , current_profile ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> "
2140,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> fdc = FDC ( drive ) ; <S2SV_EndBug> <S2SV_StartBug> if ( fdc != 1 && fdc != 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> unsigned int new_fdc = fdc ; <S2SV_ModStart> new_fdc <S2SV_ModEnd> <S2SV_ModStart> new_fdc >= N_FDC <S2SV_ModEnd> <S2SV_ModStart> fdc = new_fdc ; 
2141,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( pool ) ; 
2142,<S2SV_StartBug> # if ! ( CONFIG_FAST_UNALIGNED ) <S2SV_EndBug> ,"<S2SV_ModStart> memcpy ( dst , src , 16 ) ; <S2SV_ModEnd> "
2143,"<S2SV_StartBug> spin_lock ( & desc -> iuspin ) ; <S2SV_EndBug> <S2SV_StartBug> desc -> reslength = urb -> actual_length ; <S2SV_EndBug> <S2SV_StartBug> memmove ( desc -> ubuf + desc -> length , desc -> inbuf , desc -> reslength ) ; <S2SV_EndBug> ","<S2SV_ModStart> int length = urb -> actual_length ; <S2SV_ModStart> if ( length + desc -> length > desc -> wMaxCommand ) { set_bit ( WDM_OVERFLOW , & desc -> flags ) ; } else { if ( ! test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { <S2SV_ModEnd> <S2SV_ModStart> length ) ; desc -> length += length ; <S2SV_ModStart> = length ; } } <S2SV_ModEnd> "
2144,"<S2SV_StartBug> timr -> it_overrun += ( int ) kc -> timer_forward ( timr , now ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2145,"<S2SV_StartBug> av_log ( avctx , AV_LOG_DEBUG , <S2SV_EndBug> ","<S2SV_ModStart> if ( s -> diff_start + s -> diff_height > cur_blk_height ) { av_log ( avctx , AV_LOG_ERROR , ""Block<S2SV_blank>parameters<S2SV_blank>invalid\\n"" ) ; return AVERROR_INVALIDDATA ; } "
2146,<S2SV_StartBug> struct sshcomp * comp ; <S2SV_EndBug> <S2SV_StartBug> for ( mode = 0 ; mode < MODE_MAX ; mode ++ ) { <S2SV_EndBug> <S2SV_StartBug> ( r = ssh_packet_init_compression ( ssh ) ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> int r <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> ssh_packet_enable_delayed_compress <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2147,"<S2SV_StartBug> logger ( Protocol , Debug , ""rdpdr_process()"" ) ; <S2SV_EndBug> <S2SV_StartBug> in_uint32_le ( s , g_client_id ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct stream packet = * s ; <S2SV_ModStart> if ( ! s_check ( s ) ) { rdp_protocol_error ( ""rdpdr_process(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>g_client_id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>did<S2SV_blank>overrun"" , & packet ) ; } "
2148,"<S2SV_StartBug> static void filter_selectively_vert_row2 ( PLANE_TYPE plane_type , <S2SV_EndBug> <S2SV_StartBug> const int mask_shift = plane_type ? 4 : 8 ; <S2SV_EndBug> <S2SV_StartBug> const int mask_cutoff = plane_type ? 0xf : 0xff ; <S2SV_EndBug> <S2SV_StartBug> const int lfl_forward = plane_type ? 4 : 8 ; <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_16_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_16 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_16 ( s + 8 * pitch , pitch , lfi1 -> mblim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_8_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_8 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_8 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_4_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_4 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_4 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_4_dual ( s + 4 , pitch , lfi0 -> mblim , lfi0 -> lim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_4 ( s + 4 , pitch , lfi0 -> mblim , lfi0 -> lim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_4 ( s + 8 * pitch + 4 , pitch , lfi1 -> mblim , lfi1 -> lim , <S2SV_EndBug> ",<S2SV_ModStart> int subsampling_factor <S2SV_ModEnd> <S2SV_ModStart> subsampling_factor <S2SV_ModEnd> <S2SV_ModStart> subsampling_factor <S2SV_ModEnd> <S2SV_ModStart> subsampling_factor <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_16_dual <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_16 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_16 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_8_dual <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_8 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_8 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_4_dual <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_4 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_4 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_4_dual <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_4 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_4 <S2SV_ModEnd> 
2149,"<S2SV_StartBug> struct mii_data * miidata = ( struct mii_data * ) & rq -> ifr_ifru ; <S2SV_EndBug> <S2SV_StartBug> case SIOCDEVPRIVATE : <S2SV_EndBug> <S2SV_StartBug> case SIOCDEVPRIVATE + 1 : <S2SV_EndBug> <S2SV_StartBug> miidata -> out_value = mii_read ( dev , phy_addr , miidata -> reg_num ) ; <S2SV_EndBug> <S2SV_StartBug> case SIOCDEVPRIVATE + 2 : <S2SV_EndBug> <S2SV_StartBug> mii_write ( dev , phy_addr , miidata -> reg_num , miidata -> in_value ) ; <S2SV_EndBug> ",<S2SV_ModStart> mii_ioctl_data <S2SV_ModEnd> <S2SV_ModStart> if_mii ( rq ) <S2SV_ModEnd> <S2SV_ModStart> SIOCGMIIPHY : miidata -> phy_id = phy_addr ; <S2SV_ModEnd> <S2SV_ModStart> SIOCGMIIREG <S2SV_ModEnd> <S2SV_ModStart> val_out <S2SV_ModEnd> <S2SV_ModStart> SIOCSMIIREG : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; <S2SV_ModEnd> <S2SV_ModStart> val_in <S2SV_ModEnd> 
2150,"<S2SV_StartBug> if ( fread ( buf , 1 , 4 , reader -> fhd ) != 4 || strncmp ( buf , ""FHDB"" , 4 ) ) { <S2SV_EndBug> <S2SV_StartBug> log ( ""%08"" PRIX64 ""<S2SV_blank>%.4s\\n"" , ( uint64_t ) ftell ( reader -> fhd ) - 4 , buf ) ; <S2SV_EndBug> <S2SV_StartBug> return MYSOFA_OK ; <S2SV_EndBug> ","<S2SV_ModStart> reader -> recursive_counter >= 10 ) return MYSOFA_INVALID_FORMAT ; else reader -> recursive_counter ++ ; if ( <S2SV_ModStart> ""<S2SV_blank>%.4s<S2SV_blank>stack<S2SV_blank>%d\\n"" <S2SV_ModEnd> <S2SV_ModStart> , reader -> recursive_counter <S2SV_ModStart> reader -> recursive_counter -- ; "
2151,<S2SV_StartBug> rhost_old [ 0 ] = '\\0' ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( desc == NULL ) desc = """" ; "
2152,"<S2SV_StartBug> _PyMemoTable_ResizeTable ( PyMemoTable * self , Py_ssize_t min_size ) <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t new_size = MT_MINSIZE ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t to_process ; <S2SV_EndBug> <S2SV_StartBug> while ( new_size < min_size && new_size > 0 ) <S2SV_EndBug> ",<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> if ( min_size > PY_SSIZE_T_MAX ) { PyErr_NoMemory ( ) ; return - 1 ; } <S2SV_ModStart> ) { new_size <<= <S2SV_ModEnd> 
2153,"<S2SV_StartBug> struct stat st ; <S2SV_EndBug> <S2SV_StartBug> pr_fs_clear_cache ( ) ; <S2SV_EndBug> <S2SV_StartBug> xerrno = errno ; <S2SV_EndBug> <S2SV_StartBug> pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>check<S2SV_blank>%s:<S2SV_blank>%s"" , path , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> res = is_symlink_path ( p , path , pathlen <S2SV_ModEnd> <S2SV_ModStart> if ( errno == EPERM ) { <S2SV_ModEnd> <S2SV_ModStart> ""error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>"" ""(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)"" , path ) ; } <S2SV_ModEnd> "
2154,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> dec_tables . counter_head ++ ; dec_tables . counter_tail ++ ; 
2155,"<S2SV_StartBug> gdImageWBMPCtx ( im , fg , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! _gdImageWBMPCtx <S2SV_ModEnd> <S2SV_ModStart> ) { <S2SV_ModEnd> <S2SV_ModStart> } else { rv = NULL ; } 
2156,<S2SV_StartBug> parameters -> res_spec = parameters -> numresolution - 1 ; <S2SV_EndBug> <S2SV_StartBug> parameters -> prch_init [ i ] = 256 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( parameters -> numresolution == 1 ) { parameters -> res_spec = 1 ; parameters -> prcw_init [ 0 ] = 128 ; parameters -> prch_init [ 0 ] = 128 ; } else { <S2SV_ModStart> } 
2157,"<S2SV_StartBug> int copied , error = - EINVAL ; <S2SV_EndBug> ",<S2SV_ModStart> ; msg -> msg_namelen = 0 
2158,"<S2SV_StartBug> status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ; <S2SV_EndBug> <S2SV_StartBug> goto release_write_pending_unlocked ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> release_write_pending_unlocked : <S2SV_EndBug> ","<S2SV_ModStart> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_ModStart> release_write_pending <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2159,"<S2SV_StartBug> struct usmStateReference * old_ref = ( struct usmStateReference * ) old ; <S2SV_EndBug> <S2SV_StartBug> if ( old_ref ) { <S2SV_EndBug> <S2SV_StartBug> if ( old_ref -> usr_engine_id_length ) <S2SV_EndBug> <S2SV_StartBug> if ( old_ref -> usr_auth_protocol_length ) <S2SV_EndBug> <S2SV_StartBug> if ( old_ref -> usr_priv_protocol_length ) <S2SV_EndBug> <S2SV_StartBug> if ( old_ref -> usr_auth_key_length && old_ref -> usr_auth_key ) { <S2SV_EndBug> <S2SV_StartBug> SNMP_ZERO ( old_ref -> usr_auth_key , old_ref -> usr_auth_key_length ) ; <S2SV_EndBug> <S2SV_StartBug> SNMP_FREE ( old_ref -> usr_auth_key ) ; <S2SV_EndBug> <S2SV_StartBug> if ( old_ref -> usr_priv_key_length && old_ref -> usr_priv_key ) { <S2SV_EndBug> <S2SV_StartBug> SNMP_ZERO ( old_ref -> usr_priv_key , old_ref -> usr_priv_key_length ) ; <S2SV_EndBug> <S2SV_StartBug> SNMP_FREE ( old_ref -> usr_priv_key ) ; <S2SV_EndBug> <S2SV_StartBug> SNMP_ZERO ( old_ref , sizeof ( * old_ref ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> ref = <S2SV_ModEnd> <S2SV_ModStart> ! ref ) return ; if ( -- ref -> refcnt > 0 ) return ; SNMP_FREE ( ref <S2SV_ModEnd> <S2SV_ModStart> SNMP_FREE ( ref <S2SV_ModEnd> <S2SV_ModStart> SNMP_FREE ( ref <S2SV_ModEnd> <S2SV_ModStart> SNMP_FREE ( ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> SNMP_FREE ( ref <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2160,<S2SV_StartBug> if ( status ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) { <S2SV_EndBug> <S2SV_StartBug> urb -> actual_length - 1 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ! urb -> actual_length ) { dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>empty<S2SV_blank>response,<S2SV_blank>exiting.\\n"" , __func__ ) ; return ; } if ( <S2SV_ModStart> ( <S2SV_ModStart> && ( <S2SV_ModEnd> <S2SV_ModStart> <= sizeof ( command_info -> result_buffer ) ) ) { memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1 "
2161,"<S2SV_StartBug> void ptrace_triggered ( struct perf_event * bp , int nmi , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2162,<S2SV_StartBug> if ( _payload ) { <S2SV_EndBug> ,<S2SV_ModStart> plen <S2SV_ModEnd> 
2163,"<S2SV_StartBug> static void save_context ( VP9_COMP * cpi , int mi_row , int mi_col , <S2SV_EndBug> <S2SV_StartBug> const MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( sa , xd -> above_seg_context + mi_col , <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( sl , xd -> left_seg_context + ( mi_row & MI_MASK ) , <S2SV_EndBug> ",<S2SV_ModStart> MACROBLOCK * const x <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
2164,"<S2SV_StartBug> int blockstodecode ; <S2SV_EndBug> <S2SV_StartBug> if ( ! nblocks || nblocks > INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size , <S2SV_EndBug> <S2SV_StartBug> 2 * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; uint64_t decoded_buffer_size <S2SV_ModStart> / 2 / sizeof ( * s -> decoded_buffer ) - 8 <S2SV_ModStart> decoded_buffer_size = 2LL * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ; av_assert0 ( decoded_buffer_size <= INT_MAX ) ; <S2SV_ModStart> decoded_buffer_size <S2SV_ModEnd> "
2165,"<S2SV_StartBug> int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ; <S2SV_EndBug> <S2SV_StartBug> f -> colorspace = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( f -> version > 0 ) <S2SV_EndBug> <S2SV_StartBug> f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> chroma_planes = get_rac ( c , state ) ; <S2SV_EndBug> <S2SV_StartBug> chroma_h_shift = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( chroma_planes != f -> chroma_planes <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , colorspace , bits_per_raw_sample <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> bits_per_raw_sample = <S2SV_ModEnd> <S2SV_ModStart> ? get_symbol ( c , state , 0 ) : <S2SV_ModEnd> <S2SV_ModStart> ; chroma_planes = get_rac ( c , state ) ; chroma_h_shift <S2SV_ModStart> chroma_v_shift = get_symbol ( c , state , 0 ) ; transparency <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> colorspace != f -> colorspace || bits_per_raw_sample != f -> avctx -> bits_per_raw_sample || <S2SV_ModStart> f -> colorspace = colorspace ; f -> avctx -> bits_per_raw_sample = bits_per_raw_sample ; "
2166,<S2SV_StartBug> frame_end : <S2SV_EndBug> ,<S2SV_ModStart> if ( ! s -> studio_profile ) 
2167,<S2SV_StartBug> sas_port_delete ( port -> port ) ; <S2SV_EndBug> ,<S2SV_ModStart> sas_destruct_devices ( port ) ; 
2168,<S2SV_StartBug> ( ( YR_OBJECT_INTEGER * ) copy ) -> value = UNDEFINED ; <S2SV_EndBug> <S2SV_StartBug> ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ( ( YR_OBJECT_INTEGER * ) object ) -> value <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModStart> object ) -> value != NULL ) { ( ( YR_OBJECT_STRING * ) copy ) -> value = sized_string_dup ( ( ( YR_OBJECT_STRING * ) object ) -> value ) ; } else { ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ; } break ; case OBJECT_TYPE_FLOAT : ( ( YR_OBJECT_DOUBLE * ) copy ) -> value = ( ( YR_OBJECT_DOUBLE * ) object ) -> value <S2SV_ModEnd> 
2169,<S2SV_StartBug> if ( ! vct_iscrlf ( * r ) ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2170,<S2SV_StartBug> unsigned int random_variable = 0 ; <S2SV_EndBug> <S2SV_StartBug> random_variable = get_random_int ( ) & STACK_RND_MASK ; <S2SV_EndBug> ,<S2SV_ModStart> long <S2SV_ModEnd> <S2SV_ModStart> ( unsigned long ) <S2SV_ModStart> ; random_variable &= <S2SV_ModEnd> 
2171,"<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_lock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2172,"<S2SV_StartBug> spin_lock ( & inode -> i_lock ) ; <S2SV_EndBug> <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , ( chg - freed ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> hugepage_subpool_put_pages ( spool <S2SV_ModEnd> 
2173,<S2SV_StartBug> if ( keyring_key -> type != & key_type_logon ) { <S2SV_EndBug> <S2SV_StartBug> down_read ( & keyring_key -> sem ) ; <S2SV_EndBug> <S2SV_StartBug> ukp = user_key_payload ( keyring_key ) ; <S2SV_EndBug> ,"<S2SV_ModStart> down_read ( & keyring_key -> sem ) ; <S2SV_ModStart> ukp = user_key_payload ( keyring_key ) ; if ( ukp -> datalen != sizeof ( struct fscrypt_key ) ) { res = - EINVAL ; goto out ; } master_key = ( struct fscrypt_key * ) ukp -> data ; BUILD_BUG_ON ( FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE ) ; if ( master_key -> size != FS_AES_256_XTS_KEY_SIZE ) { printk_once ( KERN_WARNING ""%s:<S2SV_blank>key<S2SV_blank>size<S2SV_blank>incorrect:<S2SV_blank>%d\\n"" , __func__ , master_key -> size ) ; res = - ENOKEY ; goto out ; } res = derive_key_aes ( ctx -> nonce , master_key -> raw , raw_key ) ; out : up_read <S2SV_ModEnd> <S2SV_ModStart> key_put ( keyring_key ) ; return <S2SV_ModEnd> "
2174,"<S2SV_StartBug> memcpy ( res , dbg_data , nb10sz ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2175,"<S2SV_StartBug> int need_error_free = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( inbuf . data , sendauth_version ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( appl_version && strcmp ( inbuf . data , appl_version ) ) { <S2SV_EndBug> ","<S2SV_ModStart> krb5_data d ; <S2SV_ModStart> d = make_data ( ( char * ) sendauth_version , strlen ( sendauth_version ) + 1 ) ; if ( ! data_eq ( inbuf , d <S2SV_ModEnd> <S2SV_ModStart> != NULL && ! problem ) { d = make_data ( appl_version , strlen ( appl_version ) + 1 ) ; if ( ! data_eq ( inbuf , d ) <S2SV_ModEnd> "
2176,<S2SV_StartBug> list = lptr = ( nodeitem * ) palloc ( sizeof ( nodeitem ) * ( num + 1 ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( num + 1 > MaxAllocSize / sizeof ( nodeitem ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , num + 1 , ( int ) ( MaxAllocSize / sizeof ( nodeitem ) ) ) ) ) ; "
2177,<S2SV_StartBug> hwc -> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 ; <S2SV_EndBug> ,<S2SV_ModStart> + ( hwc -> idx - X86_PMC_IDX_FIXED ) 
2178,<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( qid > NVMET_NR_QUEUES ) return NULL 
2179,"<S2SV_StartBug> if ( msg -> maxsize - msg -> cursize < 4 ) { <S2SV_EndBug> <S2SV_StartBug> if ( bits == 8 ) { <S2SV_EndBug> <S2SV_StartBug> nbits = bits & 7 ; <S2SV_EndBug> <S2SV_StartBug> Huff_offsetTransmit ( & msgHuff . compressor , ( value & 0xff ) , msg -> data , & msg -> bit ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> overflowed ) { <S2SV_ModEnd> <S2SV_ModStart> msg -> cursize + ( bits >> 3 ) > msg -> maxsize ) { msg -> overflowed = qtrue ; return ; } if ( <S2SV_ModStart> if ( msg -> bit + nbits > msg -> maxsize << 3 ) { msg -> overflowed = qtrue ; return ; } <S2SV_ModStart> , msg -> maxsize << 3 <S2SV_ModStart> if ( msg -> bit > msg -> maxsize << 3 ) { msg -> overflowed = qtrue ; return ; } "
2180,<S2SV_StartBug> && ( NULL != ptr -> line ) <S2SV_EndBug> <S2SV_StartBug> && ( ( '+' != ptr -> line [ 0 ] ) <S2SV_EndBug> <S2SV_StartBug> && ( '-' != ptr -> line [ 0 ] ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( NULL != ptr ) && ( NULL != ptr -> line ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( NULL == <S2SV_ModEnd> <S2SV_ModStart> || ( ( '+' != ptr -> line [ 0 ] ) && ( '-' <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> NULL != ptr <S2SV_ModEnd> 
2181,"<S2SV_StartBug> vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_width ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( temp_area + i * dest_pitch , temp_area + ( i - 1 ) * dest_pitch , dest_pitch ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_pitch ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
2182,<S2SV_StartBug> if ( ack -> subh . addip_hdr -> serial == serial ) { <S2SV_EndBug> ,<S2SV_ModStart> sctp_chunk_pending ( ack ) ) continue ; if ( 
2183,<S2SV_StartBug> if ( IS_ERR ( blkg ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2184,"<S2SV_StartBug> mptctl_do_fw_download ( int ioc , char __user * ufwbuf , size_t fwlen ) <S2SV_EndBug> <S2SV_StartBug> MPT_FRAME_HDR * mf ; <S2SV_EndBug> <S2SV_StartBug> if ( mpt_verify_adapter ( ioc , & iocp ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> iocp -> name , ( int ) fwlen ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> MPT_ADAPTER * iocp <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2185,<S2SV_StartBug> skb -> sk = sk ; <S2SV_EndBug> ,<S2SV_ModStart> skb_orphan ( skb ) ; sock_hold ( sk ) ; <S2SV_ModStart> ; skb -> destructor = sock_efree 
2186,"<S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> <S2SV_StartBug> return VPX_CODEC_CORRUPT_FRAME ; <S2SV_EndBug> <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . number_of_layers > 1 ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> layer = cpi -> oxcf . layer_id [ <S2SV_EndBug> <S2SV_StartBug> cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> int y_samples = orig -> y_height * orig -> y_width ; <S2SV_EndBug> <S2SV_StartBug> int uv_samples = orig -> uv_height * orig -> uv_width ; <S2SV_EndBug> <S2SV_StartBug> double sq_error , sq_error2 ; <S2SV_EndBug> <S2SV_StartBug> recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ; <S2SV_EndBug> <S2SV_StartBug> ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride , <S2SV_EndBug> <S2SV_StartBug> recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ; <S2SV_EndBug> <S2SV_StartBug> double frame_psnr2 , frame_ssim2 = 0 ; <S2SV_EndBug> <S2SV_StartBug> pp -> y_buffer , pp -> y_stride , orig -> y_width , orig -> y_height ) ; <S2SV_EndBug> <S2SV_StartBug> ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride , <S2SV_EndBug> <S2SV_StartBug> pp -> u_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ; <S2SV_EndBug> <S2SV_StartBug> frame_ssim2 = vp8_calc_ssim ( cpi -> Source , <S2SV_EndBug> <S2SV_StartBug> & cm -> post_proc_buffer , 1 , & weight ) ; <S2SV_EndBug> <S2SV_StartBug> frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show , <S2SV_EndBug> <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vp8_clear_system_state ( ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_total_resolutions > 1 ) { LOWER_RES_FRAME_INFO * low_res_frame_info = ( LOWER_RES_FRAME_INFO * ) cpi -> oxcf . mr_low_res_mode_info ; if ( cpi -> oxcf . mr_encoder_id ) { cpi -> ref_framerate = low_res_frame_info -> low_res_framerate ; } else { low_res_frame_info -> low_res_framerate = cpi -> ref_framerate ; } } # endif <S2SV_ModStart> && i < VPX_TS_MAX_LAYERS ; ++ i <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> temporal_layer_id >= 0 ) { layer = cpi -> temporal_layer_id ; } else { <S2SV_ModStart> } <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> unsigned int y_width = cpi -> common . Width ; unsigned int y_height = cpi -> common . Height ; unsigned int uv_width = ( y_width + 1 ) / 2 ; unsigned int uv_height = ( y_height + 1 ) / 2 ; <S2SV_ModStart> y_height * <S2SV_ModEnd> <S2SV_ModStart> uv_height * <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> y_width , y_height ) ; ue = calc_plane_error ( orig -> u_buffer <S2SV_ModEnd> <S2SV_ModStart> uv_stride , recon -> u_buffer , recon -> uv_stride , uv_width , uv_height ) ; ve <S2SV_ModEnd> <S2SV_ModStart> v_buffer <S2SV_ModEnd> <S2SV_ModStart> v_buffer <S2SV_ModEnd> <S2SV_ModStart> uv_width , <S2SV_ModEnd> <S2SV_ModStart> sq_error2 ; double <S2SV_ModStart> y_width , y_height ) ; ue = calc_plane_error ( orig -> u_buffer <S2SV_ModEnd> <S2SV_ModStart> uv_stride , pp -> u_buffer , pp -> uv_stride , uv_width , uv_height ) ; ve <S2SV_ModEnd> <S2SV_ModStart> v_buffer <S2SV_ModEnd> <S2SV_ModStart> v_buffer <S2SV_ModEnd> <S2SV_ModStart> uv_width , <S2SV_ModEnd> <S2SV_ModStart> vpx_calc_ssim <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_calc_ssimg <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2187,"<S2SV_StartBug> ""InvalidGeometry"" , ""`%s\'"" , option ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; page_geometry = DestroyString ( page_geometry 
2188,"<S2SV_StartBug> if ( ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) ) <S2SV_EndBug> ",<S2SV_ModStart> ( data -> schemata [ cid ] + len <= data -> schemadatalen ) && <S2SV_ModStart> ( data -> schemata [ cid ] + len <= data -> schemadatalen ) && 
2189,<S2SV_StartBug> exit ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> exit ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> exit ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> exit ( - 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2190,"<S2SV_StartBug> struct efx_nic * efx = netdev_priv ( net_dev ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ring -> rx_pending < EFX_MIN_RING_SIZE || <S2SV_EndBug> <S2SV_StartBug> ""TX<S2SV_blank>and<S2SV_blank>RX<S2SV_blank>queues<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>%ld\\n"" , <S2SV_EndBug> <S2SV_StartBug> return efx_realloc_channels ( efx , ring -> rx_pending , ring -> tx_pending ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; u32 txq_entries <S2SV_ModStart> EFX_RXQ_MIN_ENT <S2SV_ModEnd> <S2SV_ModStart> ""RX<S2SV_blank>queues<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>%u\\n"" , EFX_RXQ_MIN_ENT <S2SV_ModEnd> <S2SV_ModStart> txq_entries = max ( ring -> tx_pending , EFX_TXQ_MIN_ENT ( efx ) ) ; if ( txq_entries != ring -> tx_pending ) netif_warn ( efx , drv , efx -> net_dev , ""increasing<S2SV_blank>TX<S2SV_blank>queue<S2SV_blank>size<S2SV_blank>to<S2SV_blank>minimum<S2SV_blank>of<S2SV_blank>%u\\n"" , txq_entries ) ; <S2SV_ModStart> txq_entries <S2SV_ModEnd> "
2191,"<S2SV_StartBug> bitmap_zero ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPUS ) ; <S2SV_EndBug> ",<S2SV_ModStart> KVM_MAX_VCPU_ID <S2SV_ModEnd> 
2192,<S2SV_StartBug> if ( shdr -> sh_size < 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> || shdr -> sh_size > SIZE_MAX 
2193,<S2SV_StartBug> if ( header_len > LEVEL_3_MAX_HEADER_LEN ) { <S2SV_EndBug> ,<S2SV_ModStart> || header_len < RAW_DATA_LEN ( header ) 
2194,<S2SV_StartBug> image -> columns = image -> rows = 0 ; <S2SV_EndBug> <S2SV_StartBug> BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ; <S2SV_EndBug> ,<S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2195,"<S2SV_StartBug> void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi ) <S2SV_EndBug> <S2SV_StartBug> __wait_discard_cmd ( sbi , false ) ; <S2SV_EndBug> ","<S2SV_ModStart> , bool umount <S2SV_ModStart> ! umount <S2SV_ModEnd> "
2196,"<S2SV_StartBug> dprintk ( ""%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\n"" , bd -> name , count ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL "
2197,"<S2SV_StartBug> if ( check_stack_guard_page ( vma , address ) < 0 ) <S2SV_EndBug> ",<S2SV_ModStart> vma -> vm_flags & VM_SHARED ) return VM_FAULT_SIGBUS ; if ( 
2198,<S2SV_StartBug> if ( ! mm ) <S2SV_EndBug> ,<S2SV_ModStart> || ! mm -> env_end 
2199,"<S2SV_StartBug> static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , <S2SV_EndBug> <S2SV_StartBug> ref -> ref ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> bool <S2SV_ModEnd> <S2SV_ModStart> if ( ref -> ref > INT_MAX / 2 ) return false ; <S2SV_ModStart> return true ; 
2200,<S2SV_StartBug> cork -> length += length ; <S2SV_EndBug> <S2SV_StartBug> if ( length > mtu ) { <S2SV_EndBug> <S2SV_StartBug> if ( dontfrag && ( proto == IPPROTO_UDP || proto == IPPROTO_RAW ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( proto == IPPROTO_UDP && <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> sk -> sk_protocol <S2SV_ModEnd> <S2SV_ModStart> sk -> sk_protocol <S2SV_ModEnd> <S2SV_ModStart> skb = skb_peek_tail ( & sk -> sk_write_queue ) ; cork -> length += length ; if ( ( ( length > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) <S2SV_ModEnd> <S2SV_ModStart> if ( ! skb <S2SV_ModEnd> 
2201,<S2SV_StartBug> INST_HANDLER ( sts ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 4 ) { return ; } 
2202,<S2SV_StartBug> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) <S2SV_EndBug> ,"<S2SV_ModStart> EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( "
2203,"<S2SV_StartBug> return kvm_x86_ops -> set_msr ( vcpu , msr ) ; <S2SV_EndBug> ",<S2SV_ModStart> switch ( msr -> index ) { case MSR_FS_BASE : case MSR_GS_BASE : case MSR_KERNEL_GS_BASE : case MSR_CSTAR : case MSR_LSTAR : if ( is_noncanonical_address ( msr -> data ) ) return 1 ; break ; case MSR_IA32_SYSENTER_EIP : case MSR_IA32_SYSENTER_ESP : msr -> data = get_canonical ( msr -> data ) ; } 
2204,"<S2SV_StartBug> char file [ PATH_MAX ] ; <S2SV_EndBug> <S2SV_StartBug> while ( fscanf ( maps , ""%*x-%*x<S2SV_blank>%*s<S2SV_blank>%zx<S2SV_blank>%s<S2SV_blank>%ld<S2SV_blank>%s\\n"" , & offset , device , & inode , <S2SV_EndBug> ","<S2SV_ModStart> 1024 <S2SV_ModEnd> <S2SV_ModStart> ""%*x-%*x<S2SV_blank>%*s<S2SV_blank>%zx<S2SV_blank>%5s<S2SV_blank>%ld<S2SV_blank>%1023s\\n"" <S2SV_ModEnd> "
2205,"<S2SV_StartBug> int is_pdf ; <S2SV_EndBug> <S2SV_StartBug> header = get_header ( fp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( header && strstr ( header , ""%PDF-"" ) ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! ( <S2SV_ModStart> ) ) return 0 ; const char * c = <S2SV_ModEnd> <S2SV_ModStart> ; const int is_pdf = c && ( ( c - header + strlen ( ""%PDF-M.m"" ) ) < 1024 ) <S2SV_ModEnd> "
2206,"<S2SV_StartBug> uint dblocks = XFS_B_TO_FSB ( mp , valuelen ) ; <S2SV_EndBug> ",<S2SV_ModStart> xfs_attr3_rmt_blocks <S2SV_ModEnd> 
2207,"<S2SV_StartBug> archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC , <S2SV_EndBug> <S2SV_StartBug> ARCHIVE_STATE_DATA , ""archive_write_data"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> const size_t max_write = INT_MAX ; <S2SV_ModStart> ; if ( s > max_write ) s = max_write 
2208,<S2SV_StartBug> case RAPTOR_OPTION_RELATIVE_URIS : <S2SV_EndBug> ,<S2SV_ModStart> RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case 
2209,"<S2SV_StartBug> if ( PyArena_AddPyObject ( c -> c_arena , str ) < 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> ! str ) return NULL ; if ( 
2210,"<S2SV_StartBug> if ( ( error_code >> 16 ) != 0x8009 ) <S2SV_EndBug> <S2SV_StartBug> return ""None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted."" ; <S2SV_EndBug> ","<S2SV_ModStart> ( <S2SV_ModStart> && ( ( error_code >> 16 ) != 0x800B ) ) <S2SV_ModStart> ; case CERT_E_UNTRUSTEDROOT : return ""The<S2SV_blank>root<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>not<S2SV_blank>trusted."" ; case TRUST_E_NOSIGNATURE : return ""Not<S2SV_blank>digitally<S2SV_blank>signed."" ; case TRUST_E_EXPLICIT_DISTRUST : return ""One<S2SV_blank>of<S2SV_blank>the<S2SV_blank>certificates<S2SV_blank>used<S2SV_blank>was<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>untrusted<S2SV_blank>by<S2SV_blank>the<S2SV_blank>user."" "
2211,"<S2SV_StartBug> if ( perf_event_overflow ( event , 1 , & data , regs ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2212,<S2SV_StartBug> int_fb_list -> int_fb [ i ] . size = min_size ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( int_fb_list -> int_fb [ i ] . data , 0 , min_size ) ; "
2213,<S2SV_StartBug> box -> info = boxinfo ; <S2SV_EndBug> <S2SV_StartBug> box -> ops = & jp2_boxinfo_unk . ops ; <S2SV_EndBug> <S2SV_StartBug> jas_stream_rewind ( tmpstream ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; box -> ops = & boxinfo -> ops 
2214,"<S2SV_StartBug> __evtchn_fifo_handle_events ( cpu , true ) ; <S2SV_EndBug> ",<S2SV_ModStart> NULL <S2SV_ModEnd> 
2215,"<S2SV_StartBug> ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; <S2SV_EndBug> ",<S2SV_ModStart> ASN1_F_ASN1_ITEM_VERIFY <S2SV_ModEnd> 
2216,"<S2SV_StartBug> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if <S2SV_EndBug> ",<S2SV_ModStart> 00 ; if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) { l_current_pi -> include = <S2SV_ModStart> } 
2217,"<S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> != c ) break 
2218,"<S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> <S2SV_StartBug> set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> key -> state == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> <S2SV_ModStart> mark_key_instantiated ( key , 0 <S2SV_ModEnd> "
2219,"<S2SV_StartBug> const int sb_cols = mi_cols_aligned_to_sb ( mi_cols ) >> MI_BLOCK_SIZE_LOG2 ; <S2SV_EndBug> <S2SV_StartBug> int min_log2 = 0 , max_log2 = 0 ; <S2SV_EndBug> <S2SV_StartBug> * min_log2_tile_cols = min_log2 ; <S2SV_EndBug> <S2SV_StartBug> * max_log2_tile_cols = max_log2 ; <S2SV_EndBug> ",<S2SV_ModStart> sb64_cols <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_min_log2_tile_cols ( sb64_cols ) <S2SV_ModEnd> <S2SV_ModStart> get_max_log2_tile_cols ( sb64_cols ) ; assert ( * min_log2_tile_cols <= * max_log2_tile_cols ) <S2SV_ModEnd> 
2220,"<S2SV_StartBug> if ( vp9_segfeature_active ( seg , seg_id , SEG_LVL_ALT_LF ) ) { <S2SV_EndBug> <S2SV_StartBug> const int data = vp9_get_segdata ( seg , seg_id , SEG_LVL_ALT_LF ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( lfi -> lvl [ seg_id ] , lvl_seg , sizeof ( lfi -> lvl [ seg_id ] ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> segfeature_active <S2SV_ModEnd> <S2SV_ModStart> get_segdata <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
2221,"<S2SV_StartBug> dev_net_set ( dev , net ) ; <S2SV_EndBug> ","<S2SV_ModStart> err = dev_get_valid_name ( net , dev , name ) ; if ( err ) goto err_free_dev ; "
2222,"<S2SV_StartBug> ctxt -> dst . type = OP_REG ; <S2SV_EndBug> <S2SV_StartBug> rc = emulate_pop ( ctxt , & ctxt -> dst . val , ctxt -> op_bytes ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned long eip <S2SV_ModEnd> <S2SV_ModStart> eip <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_near ( ctxt , eip "
2223,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( pool ) ; 
2224,<S2SV_StartBug> size = INT_MAX ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( unlikely ( ! access_ok ( VERIFY_WRITE , ubuf , size ) ) ) return - EFAULT "
2225,<S2SV_StartBug> if ( attr >= 0 ) { <S2SV_EndBug> ,"<S2SV_ModStart> && xhash_get ( in -> states , rkey ) == ( void * ) conn_INPROGRESS "
2226,"<S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> <S2SV_StartBug> qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> qiov . size <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2227,"<S2SV_StartBug> src_devid , NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> NULL , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> , true <S2SV_ModStart> , true "
2228,<S2SV_StartBug> if ( ( rsa = RSA_new ( ) ) == NULL ) <S2SV_EndBug> ,"<S2SV_ModStart> ! SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_SERVER_CERTIFICATE , SSL_R_UNEXPECTED_MESSAGE ) ; goto f_err ; } if ( "
2229,<S2SV_StartBug> if ( header_len > LEVEL_3_MAX_HEADER_LEN ) { <S2SV_EndBug> ,<S2SV_ModStart> || header_len < RAW_DATA_LEN ( header ) 
2230,<S2SV_StartBug> crypto_free_skcipher ( private ) ; <S2SV_EndBug> ,<S2SV_ModStart> struct skcipher_tfm * tfm = private ; crypto_free_skcipher ( tfm -> skcipher ) ; kfree ( tfm <S2SV_ModEnd> 
2231,"<S2SV_StartBug> static void restore_context ( VP9_COMP * cpi , int mi_row , int mi_col , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( xd -> above_seg_context + mi_col , sa , <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( xd -> left_seg_context + ( mi_row & MI_MASK ) , sl , <S2SV_EndBug> ",<S2SV_ModStart> MACROBLOCK * const x <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
2232,<S2SV_StartBug> ND_TCHECK ( dp [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> dp += 3 ; <S2SV_EndBug> ,"<S2SV_ModStart> 4 <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 3 ] <S2SV_ModEnd> "
2233,"<S2SV_StartBug> isoclns_print ( ndo , p , length , caplen ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2234,<S2SV_StartBug> if ( name == NULL ) { <S2SV_EndBug> ,<S2SV_ModStart> ctxt -> instate == XML_PARSER_EOF ) return ; if ( 
2235,"<S2SV_StartBug> pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; <S2SV_EndBug> ",<S2SV_ModStart> hdr -> sadb_msg_reserved = 0 ; 
2236,<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> ,<S2SV_ModStart> void 
2237,"<S2SV_StartBug> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> size_t ) ( <S2SV_ModStart> 1U <S2SV_ModEnd> 
2238,<S2SV_StartBug> assert ( dev -> lintr . pin > 0 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> <= 0 ) { pr_warn ( ""%s:<S2SV_blank>Invalid<S2SV_blank>intr<S2SV_blank>pin<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>[%s]\\n"" , __func__ , dev -> name ) ; return ; } <S2SV_ModEnd> "
2239,"<S2SV_StartBug> ""InvalidGeometry"" , ""`%s\'"" , option ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; geometry = DestroyString ( geometry 
2240,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""tell<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""at<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""for<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""who-has<S2SV_blank>"" ) ) ; atmarp_tpaddr_print ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank>tell<S2SV_blank>"" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> atmarp_spaddr_print ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>is-at<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ""at<S2SV_blank>"" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> ""for<S2SV_blank>"" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> "
2241,<S2SV_StartBug> if ( ! ext_dp -> icmp_length ) { <S2SV_EndBug> <S2SV_StartBug> vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; <S2SV_EndBug> <S2SV_StartBug> hlen -= 4 ; <S2SV_EndBug> ,"<S2SV_ModStart> && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) <S2SV_ModStart> if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) { <S2SV_ModStart> } "
2242,"<S2SV_StartBug> struct strbuf * path , const char * component ) <S2SV_EndBug> <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name ) { const <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2243,<S2SV_StartBug> usleep ( us_delay ) ; <S2SV_EndBug> ,<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
2244,"<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> struct frag_hdr fhdr ; <S2SV_EndBug> <S2SV_StartBug> skb -> ip_summed = CHECKSUM_PARTIAL ; <S2SV_EndBug> <S2SV_StartBug> __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct frag_hdr fhdr ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> csum = 0 ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; } else if ( skb_is_gso ( skb ) ) { goto append ; } skb -> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> append : <S2SV_ModEnd> "
2245,<S2SV_StartBug> if ( dp -> icmp6_data16 [ 1 ] & 0xc0 ) <S2SV_EndBug> <S2SV_StartBug> if ( dp -> icmp6_data16 [ 1 ] & 0x80 ) <S2SV_EndBug> <S2SV_StartBug> if ( dp -> icmp6_data16 [ 1 ] & 0x40 ) <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 0xc0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> 0x80 ) ND_PRINT ( ( ndo , ""M"" ) ) ; if ( dp -> icmp6_data16 [ 1 ] & "
2246,<S2SV_StartBug> PureFileInfo * r ; <S2SV_EndBug> <S2SV_StartBug> while ( opt_R && r != s ) { <S2SV_EndBug> <S2SV_StartBug> char * alloca_subdir ; <S2SV_EndBug> <S2SV_StartBug> ALLOCA_FREE ( alloca_subdir ) ; <S2SV_EndBug> <S2SV_StartBug> free ( names ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; char * alloca_subdir ; size_t sizeof_subdir <S2SV_ModStart> sizeof_subdir = PATH_MAX + 1U ; if ( ( alloca_subdir = ALLOCA ( sizeof_subdir ) ) == NULL ) { goto toomany ; } <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ALLOCA_FREE ( alloca_subdir ) ; 
2247,"<S2SV_StartBug> if ( getenv_int ( ""STRIP"" ) ) { <S2SV_EndBug> ","<S2SV_ModStart> getenv ( ""HASHSEED"" ) ) json_object_seed ( getenv_int ( ""HASHSEED"" ) ) ; if ( "
2248,"<S2SV_StartBug> oe_errno = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! sock ) <S2SV_EndBug> <S2SV_StartBug> if ( addrlen ) <S2SV_EndBug> <S2SV_StartBug> ( struct oe_sockaddr * ) addr , <S2SV_EndBug> <S2SV_StartBug> addrlen ) != OE_OK ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ",<S2SV_ModStart> oe_socklen_t addrlen_out = 0 ; <S2SV_ModStart> || ! addr || ! addrlen ) OE_RAISE_ERRNO ( OE_EINVAL ) ; addrlen_in = * addrlen ; if ( addrlen_in < 0 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> & addrlen_out <S2SV_ModEnd> <S2SV_ModStart> if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( addrlen_in >= addrlen_out ) * addrlen = addrlen_out ; 
2249,<S2SV_StartBug> u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ; <S2SV_EndBug> <S2SV_StartBug> case PSR_AA32_MODE_FIQ : <S2SV_EndBug> <S2SV_StartBug> case PSR_MODE_EL0t : <S2SV_EndBug> <S2SV_StartBug> case PSR_MODE_EL1h : <S2SV_EndBug> ,<S2SV_ModStart> u64 <S2SV_ModEnd> <S2SV_ModStart> u64 <S2SV_ModEnd> <S2SV_ModStart> if ( ! system_supports_32bit_el0 ( ) ) return - EINVAL ; break ; <S2SV_ModStart> if ( ! vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ; break ; <S2SV_ModStart> if ( vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ; 
2250,<S2SV_StartBug> return ret ; <S2SV_EndBug> ,<S2SV_ModStart> goto out_controller_put <S2SV_ModEnd> 
2251,<S2SV_StartBug> for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) { <S2SV_EndBug> <S2SV_StartBug> if ( unix_sock_count ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( too_many_unix_fds ( current ) ) return - ETOOMANYREFS ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2252,<S2SV_StartBug> register const u_char * ep ; <S2SV_EndBug> <S2SV_StartBug> ep = ( const u_char * ) ndo -> ndo_snapend ; <S2SV_EndBug> <S2SV_StartBug> if ( ndo -> ndo_vflag ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { if ( len < 8 ) goto trunc ; <S2SV_ModStart> } 
2253,"<S2SV_StartBug> if ( offset != 0 ) <S2SV_EndBug> <S2SV_StartBug> csum_partial ( skb_transport_header ( skb ) + tlen , <S2SV_EndBug> <S2SV_StartBug> offset , 0 ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> { int tend_off = skb_transport_offset ( skb ) + tlen ; <S2SV_ModStart> skb_checksum ( skb , tend_off , <S2SV_ModEnd> <S2SV_ModStart> } "
2254,"<S2SV_StartBug> size_t input_size , <S2SV_EndBug> <S2SV_StartBug> int max_bytes_matched = input_size ; <S2SV_EndBug> ","<S2SV_ModStart> input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> <S2SV_ModStart> ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? input_backwards_size : input_forwards_size <S2SV_ModEnd> "
2255,"<S2SV_StartBug> set_string ( ""foo"" , module_object , ""string_array[%i]"" , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> set_integer ( 256 , module_object , ""integer_array[%i]"" , 256 ) ; "
2256,"<S2SV_StartBug> file = kmalloc ( sizeof ( * file ) , GFP_NOIO ) ; <S2SV_EndBug> ",<S2SV_ModStart> kzalloc <S2SV_ModEnd> 
2257,"<S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( user_password , ( char * ) crypt ( password , user_password ) ) != 0 ) <S2SV_EndBug> ","<S2SV_ModStart> char * crypt_password ; <S2SV_ModStart> crypt_password = crypt ( password , user_password ) ; if ( crypt_password == NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" ) ; return - 1 ; } <S2SV_ModStart> crypt_password <S2SV_ModEnd> "
2258,<S2SV_StartBug> if ( atomic_dec_and_test ( & ucounts -> count ) ) { <S2SV_EndBug> <S2SV_StartBug> hlist_del_init ( & ucounts -> node ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ucounts -> count -= 1 ; if ( ! ucounts -> count ) <S2SV_ModStart> ; else ucounts = NULL <S2SV_ModStart>  <S2SV_ModEnd> 
2259,<S2SV_StartBug> length += len ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( length > ( size_t ) ( length + len ) ) ) goto _output_error ; 
2260,<S2SV_StartBug> if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) <S2SV_EndBug> ,"<S2SV_ModStart> ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; "
2261,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( pid == INT_MIN ) return - ESRCH ; 
2262,<S2SV_StartBug> free ( mem ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( mem ) { <S2SV_ModStart> mem = NULL ; } return ; 
2263,"<S2SV_StartBug> size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ; <S2SV_EndBug> <S2SV_StartBug> luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; luaL_argcheck ( L , pos > 0 , 3 , ""offset<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ) ; pos -- <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && pos <= ld - size , <S2SV_ModEnd> "
2264,"<S2SV_StartBug> if ( send ( common -> ctrl_fd , & cmd , 1 , MSG_NOSIGNAL ) == - 1 ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
2265,<S2SV_StartBug> bin -> dyld_info = malloc ( sizeof ( struct dyld_info_command ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( off + sizeof ( struct dyld_info_command ) > bin -> size ) { <S2SV_EndBug> <S2SV_StartBug> free ( bin -> dyld_info ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> calloc ( 1 , <S2SV_ModEnd> <S2SV_ModStart> bin -> dyld_info ) { if ( <S2SV_ModStart> R_FREE <S2SV_ModEnd> <S2SV_ModStart> } "
2266,"<S2SV_StartBug> COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! COM_CompareExtension ( filename , "".txt"" ) ) { Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".txt\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" ) ; return ; } "
2267,"<S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> 
2268,"<S2SV_StartBug> unix_state_double_unlock ( sk , other ) ; <S2SV_EndBug> ","<S2SV_ModStart> unix_dgram_peer_wake_disconnect_wakeup ( sk , old_peer ) ; "
2269,"<S2SV_StartBug> void Huff_offsetReceive ( node_t * node , int * ch , byte * fin , int * offset ) { <S2SV_EndBug> <S2SV_StartBug> while ( node && node -> symbol == INTERNAL_NODE ) { <S2SV_EndBug> ","<S2SV_ModStart> , int maxoffset <S2SV_ModStart> if ( bloc >= maxoffset ) { * ch = 0 ; * offset = maxoffset + 1 ; return ; } "
2270,<S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug> ,<S2SV_ModStart> ctx -> terminated || 
2271,<S2SV_StartBug> if ( enable_apicv ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2272,"<S2SV_StartBug> state -> frame [ 0 ] = kzalloc ( sizeof ( struct bpf_func_state ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> verbose ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n"" , <S2SV_EndBug> <S2SV_StartBug> env -> prev_insn_idx , env -> insn_idx ) ; <S2SV_EndBug> <S2SV_StartBug> verbose ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:"" , <S2SV_EndBug> <S2SV_StartBug> env -> prev_insn_idx , env -> insn_idx ) ; <S2SV_EndBug> ","<S2SV_ModStart> speculative = false ; state -> <S2SV_ModStart> ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d%s:<S2SV_blank>safe\\n"" <S2SV_ModEnd> <S2SV_ModStart> , env -> cur_state -> speculative ? ""<S2SV_blank>(speculative<S2SV_blank>execution)"" : """" <S2SV_ModStart> ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d%s:"" <S2SV_ModEnd> <S2SV_ModStart> , env -> cur_state -> speculative ? ""<S2SV_blank>(speculative<S2SV_blank>execution)"" : """" "
2273,"<S2SV_StartBug> if ( in ) { <S2SV_EndBug> <S2SV_StartBug> dev -> out_pipe = usb_sndbulkpipe ( udev , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( out ) <S2SV_ModStart>  <S2SV_ModEnd> 
2274,<S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * addr_len = sizeof ( * sin ) ; 
2275,<S2SV_StartBug> VM_SHARED | VM_MAYSHARE | <S2SV_EndBug> <S2SV_StartBug> VM_SHARED | VM_MAYSHARE | <S2SV_EndBug> ,<S2SV_ModStart> VM_NO_THP <S2SV_ModEnd> <S2SV_ModStart> VM_NO_THP <S2SV_ModEnd> 
2276,<S2SV_StartBug> ops -> destroy ( dev ) ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & kvm -> lock ) ; list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
2277,"<S2SV_StartBug> if ( ! flatpak_bwrap_bundle_args ( bwrap , 1 , - 1 , FALSE , error ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! g_spawn_async ( NULL , <S2SV_EndBug> <S2SV_StartBug> if ( execvpe ( flatpak_get_bwrap ( ) , ( char * * ) bwrap -> argv -> pdata , bwrap -> envp ) == - 1 ) <S2SV_EndBug> ",<S2SV_ModStart> flatpak_bwrap_envp_to_args ( bwrap ) ; <S2SV_ModStart> g_assert ( bwrap -> envp != NULL ) ; g_assert ( bwrap -> envp [ 0 ] == NULL ) ; <S2SV_ModStart> g_assert ( bwrap -> envp != NULL ) ; g_assert ( bwrap -> envp [ 0 ] == NULL ) ; 
2278,"<S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2279,"<S2SV_StartBug> static vpx_codec_err_t vp8_get_last_ref_updates ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2280,<S2SV_StartBug> if ( ! new_buffer ) <S2SV_EndBug> <S2SV_StartBug> return AVERROR ( ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! new_buffer ) <S2SV_EndBug> <S2SV_StartBug> return AVERROR ( ENOMEM ) ; <S2SV_EndBug> ,<S2SV_ModStart> { pc -> index = 0 ; <S2SV_ModStart> } <S2SV_ModStart> { pc -> overread_index = pc -> index = 0 ; <S2SV_ModStart> } 
2281,"<S2SV_StartBug> struct fsnotify_group * group ; <S2SV_EndBug> <S2SV_StartBug> user = get_current_user ( ) ; <S2SV_EndBug> <S2SV_StartBug> group = inotify_new_group ( user , inotify_max_queued_events ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( group ) ) { <S2SV_EndBug> <S2SV_StartBug> ret = PTR_ERR ( group ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret >= 0 ) <S2SV_EndBug> <S2SV_StartBug> fsnotify_put_group ( group ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> < 0 ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2282,"<S2SV_StartBug> vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end , <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> set_mi_row_col ( xd , tile , <S2SV_EndBug> <S2SV_StartBug> write_mb_modes_kf ( cpi , xd -> mi , w ) ; <S2SV_EndBug> <S2SV_StartBug> pack_mb_tokens ( w , tok , tok_end ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> const TOKENEXTRA * const <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> td . <S2SV_ModStart> cpi -> td . mb . mbmi_ext = cpi -> td . mb . mbmi_ext_base + ( mi_row * cm -> mi_cols + mi_col ) ; <S2SV_ModStart> cm , xd <S2SV_ModEnd> <S2SV_ModStart> , cm -> bit_depth "
2283,"<S2SV_StartBug> mlx4_dbg ( dev , ""Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\n"" , free ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( free < 0 ) { err = - ENOMEM ; goto out ; } 
2284,<S2SV_StartBug> aof_fsync ( server . appendfd ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2285,"<S2SV_StartBug> byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> offset . QuadPart = 0 ; <S2SV_EndBug> <S2SV_StartBug> sizeof ( readBuffer ) , <S2SV_EndBug> <S2SV_StartBug> if ( NT_SUCCESS ( ntStatus ) ) <S2SV_EndBug> <S2SV_StartBug> Irp -> IoStatus . Status = ntStatus ; <S2SV_EndBug> <S2SV_StartBug> Irp -> IoStatus . Information = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> size_t devicePathLen = 0 <S2SV_ModEnd> <S2SV_ModStart> if ( ! NT_SUCCESS ( RtlUnalignedStringCchLengthW ( request -> DevicePath , TC_MAX_PATH , & devicePathLen ) ) || ( devicePathLen < 28 ) || ( devicePathLen > 30 ) || ( memcmp ( request -> DevicePath , L""\\\\Device\\\\Harddisk"" , 16 * sizeof ( WCHAR ) ) ) || ( memcmp ( & request -> DevicePath [ devicePathLen - 11 ] , L""\\\\Partition0"" , 11 * sizeof ( WCHAR ) ) ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } <S2SV_ModStart> byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } else { <S2SV_ModStart> TC_MAX_VOLUME_SECTOR_SIZE <S2SV_ModEnd> <S2SV_ModStart> ) { if ( IoStatus . Information >= TC_SECTOR_SIZE_BIOS <S2SV_ModStart> STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } else { Irp -> IoStatus . Status = <S2SV_ModStart> ; } TCfree ( readBuffer ) "
2286,<S2SV_StartBug> fh32 [ 2 ] = inode -> i_generation ; <S2SV_EndBug> ,<S2SV_ModStart> fh16 [ 3 ] = 0 ; 
2287,<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> daddr = inet -> inet_daddr ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt && inet -> opt -> srr ) <S2SV_EndBug> ,<S2SV_ModStart> struct ip_options_rcu * inet_opt ; <S2SV_ModStart> rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; <S2SV_ModStart> inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ; rcu_read_unlock ( ) <S2SV_ModEnd> 
2288,"<S2SV_StartBug> static inline void mcryptd_check_internal ( struct rtattr * * tb , u32 * type , <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> if ( ( algt -> type & CRYPTO_ALG_INTERNAL ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( algt -> mask & CRYPTO_ALG_INTERNAL ) ) <S2SV_EndBug> ",<S2SV_ModStart> bool <S2SV_ModEnd> <S2SV_ModStart> false ; * type |= <S2SV_ModEnd> <S2SV_ModStart> ; * mask |= algt -> mask & <S2SV_ModEnd> <S2SV_ModStart> * type & * <S2SV_ModEnd> <S2SV_ModStart> return true ; else return false <S2SV_ModEnd> 
2289,"<S2SV_StartBug> priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! port -> interrupt_out_urb || ! port -> interrupt_in_urb ) { dev_err ( & port -> dev , ""required<S2SV_blank>endpoint<S2SV_blank>is<S2SV_blank>missing\\n"" ) ; return - ENODEV ; } "
2290,"<S2SV_StartBug> int yy , mm , dd , hr , min , sec , csec ; <S2SV_EndBug> <S2SV_StartBug> ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , <S2SV_EndBug> <S2SV_StartBug> ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , <S2SV_EndBug> <S2SV_StartBug> yy = mm = dd = hr = min = sec = csec = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" <S2SV_ModEnd> <S2SV_ModStart> ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" <S2SV_ModEnd> <S2SV_ModStart> ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ; return FALSE "
2291,<S2SV_StartBug> ND_TCHECK ( dp -> ip6f_offlg ) ; <S2SV_EndBug> ,<S2SV_ModStart> * dp <S2SV_ModEnd> 
2292,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""seq<S2SV_blank>0x%03x,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" , <S2SV_EndBug> ","<S2SV_ModStart> if ( length < 2 ) { ND_PRINT ( ( ndo , ""[|mlppp]"" ) ) ; return ; } if ( ! ND_TTEST_16BITS ( p ) ) { ND_PRINT ( ( ndo , ""[|mlppp]"" ) ) ; return ; } "
2293,"<S2SV_StartBug> return vp8_get4x4sse_cs ( sptr , be -> src_stride , dptr , 16 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_get4x4sse_cs <S2SV_ModEnd> 
2294,"<S2SV_StartBug> if ( sk_filter ( sk , skb ) ) <S2SV_EndBug> <S2SV_StartBug> goto discard_and_relse ; <S2SV_EndBug> ",<S2SV_ModStart> tcp_filter <S2SV_ModEnd> <S2SV_ModStart> ; th = ( const struct tcphdr * ) skb -> data ; hdr = ipv6_hdr ( skb ) 
2295,<S2SV_StartBug> if ( keyring ) <S2SV_EndBug> ,<S2SV_ModStart> && link_ret == 0 
2296,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( s -> codec_id == AV_CODEC_ID_MPEG4 ) s -> idsp . mpeg4_studio_profile = s -> studio_profile ; 
2297,<S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( numSamples <= 0 ) { ALOGE ( ""b/26366256"" ) ; return ; } "
2298,"<S2SV_StartBug> split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ? <S2SV_EndBug> <S2SV_StartBug> err = ext4_split_extent_at ( handle , inode , path , <S2SV_EndBug> <S2SV_StartBug> split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ? <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( split_flag & EXT4_EXT_DATA_VALID2 ) split_flag1 |= EXT4_EXT_DATA_VALID1 ; <S2SV_ModStart> ( EXT4_EXT_MAY_ZEROOUT | EXT4_EXT_DATA_VALID2 ) <S2SV_ModEnd> 
2299,<S2SV_StartBug> user = key_user_lookup ( current_fsuid ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ctx -> index_key . type == & key_type_keyring ) return ERR_PTR ( - EPERM ) ; 
2300,"<S2SV_StartBug> BIO * cmsbio = NULL , * tmpin = NULL ; <S2SV_EndBug> <S2SV_StartBug> cmsbio = CMS_dataInit ( cms , tmpin ) ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( dcont && ( tmpin == dcont ) ) <S2SV_EndBug> <S2SV_StartBug> if ( cms_certs ) <S2SV_EndBug> ","<S2SV_ModStart> = NULL , * tmpout <S2SV_ModStart> if ( ! ( flags & SMIME_BINARY ) && dcont ) { tmpout = cms_get_text_bio ( out , flags ) ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } <S2SV_ModStart> tmpout ) ; if ( ! cmsbio ) goto err ; SMIME_crlf_copy ( dcont , cmsbio , flags & ~ SMIME_TEXT ) ; if ( flags & CMS_TEXT ) { if ( ! SMIME_text ( tmpout , out ) ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SMIME_TEXT_ERROR ) ; goto err ; } } } else { cmsbio = CMS_dataInit ( cms , <S2SV_ModStart> } <S2SV_ModStart> ! ( flags & SMIME_BINARY ) && dcont ) { do_free_upto ( cmsbio , tmpout ) ; if ( tmpin != dcont ) BIO_free ( tmpin ) ; } else { if ( <S2SV_ModStart> } if ( tmpout && out != tmpout ) BIO_free_all ( tmpout ) ; "
2301,"<S2SV_StartBug> __ip_vs_get_timeouts ( net , & t ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( & t , 0 , sizeof ( t ) ) ; "
2302,"<S2SV_StartBug> if ( cfg -> g_w != ctx -> cfg . g_w || cfg -> g_h != ctx -> cfg . g_h ) <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_change_config ( ctx -> cpi , & ctx -> oxcf ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int force_key = 0 ; if ( cfg -> g_w != ctx -> cfg . g_w || cfg -> g_h != ctx -> cfg . g_h ) { if ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS <S2SV_ModEnd> <S2SV_ModStart> if ( ! valid_ref_frame_size ( ctx -> cfg . g_w , ctx -> cfg . g_h , cfg -> g_w , cfg -> g_h ) || ( ctx -> cpi -> initial_width && ( int ) cfg -> g_w > ctx -> cpi -> initial_width ) || ( ctx -> cpi -> initial_height && ( int ) cfg -> g_h > ctx -> cpi -> initial_height ) ) force_key = 1 ; } <S2SV_ModStart> force_key |= ctx -> cpi -> common . profile != ctx -> oxcf . profile ; <S2SV_ModStart> if ( force_key ) ctx -> next_frame_flags |= VPX_EFLAG_FORCE_KF ; "
2303,<S2SV_StartBug> fp -> protocol = altsd -> bInterfaceProtocol ; <S2SV_EndBug> ,<S2SV_ModStart> if ( altsd -> bNumEndpoints < 1 ) { kfree ( fp ) ; kfree ( rate_table ) ; return - EINVAL ; } 
2304,<S2SV_StartBug> if ( pkt == NULL ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2305,"<S2SV_StartBug> int err = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> up_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> for ( idx = 0 ; idx < kcontrol -> count ; idx ++ , id . index ++ , id . numid ++ ) <S2SV_EndBug> ",<S2SV_ModStart> unsigned int count ; <S2SV_ModStart> count = kcontrol -> count ; <S2SV_ModStart>  <S2SV_ModEnd> 
2306,<S2SV_StartBug> while ( c ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> i ++ , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2307,<S2SV_StartBug> time_t then ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( strlen ( stamp ) != 2 ) return SRS_ETIMESTAMPOUTOFDATE 
2308,"<S2SV_StartBug> xmlNode * <S2SV_EndBug> <S2SV_StartBug> crm_recv_remote_msg ( void * session , gboolean encrypted ) <S2SV_EndBug> <S2SV_StartBug> xmlNode * xml = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( encrypted ) { <S2SV_EndBug> ","<S2SV_ModStart> gboolean <S2SV_ModEnd> <S2SV_ModStart> , char * * recv_buf <S2SV_ModStart> , int total_timeout , int * disconnected ) { int ret ; size_t request_len = 0 ; time_t start = time ( NULL ) ; char * raw_request <S2SV_ModEnd> <S2SV_ModStart> int remaining_timeout = 0 ; if ( total_timeout == 0 ) { total_timeout = 10000 ; } else if ( total_timeout < 0 ) { total_timeout = 60000 ; } * disconnected = 0 ; remaining_timeout = total_timeout ; while ( ( remaining_timeout > 0 ) && ! ( * disconnected ) ) { crm_trace ( ""waiting<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>remote<S2SV_blank>msg,<S2SV_blank>starting<S2SV_blank>timeout<S2SV_blank>%d,<S2SV_blank>remaining_timeout<S2SV_blank>%d"" , total_timeout , remaining_timeout ) ; ret = crm_recv_remote_ready ( session , encrypted , remaining_timeout ) ; raw_request <S2SV_ModEnd> <S2SV_ModStart> ret == 0 ) { crm_err ( ""poll<S2SV_blank>timed<S2SV_blank>out<S2SV_blank>(%d<S2SV_blank>ms)<S2SV_blank>while<S2SV_blank>waiting<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>msg"" , remaining_timeout ) ; return FALSE ; } else if ( ret < 0 ) { if ( errno != EINTR ) { crm_debug ( ""poll<S2SV_blank>returned<S2SV_blank>error<S2SV_blank>while<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>msg,<S2SV_blank>rc:<S2SV_blank>%d,<S2SV_blank>errno:<S2SV_blank>%d"" , ret , errno ) ; * disconnected = 1 ; return FALSE ; } crm_debug ( ""poll<S2SV_blank>EINTR<S2SV_blank>encountered<S2SV_blank>during<S2SV_blank>poll,<S2SV_blank>retrying"" ) ; } else { raw_request = crm_recv_remote_raw ( session , encrypted , 0 , & request_len , disconnected ) ; } remaining_timeout = remaining_timeout - ( ( time ( NULL ) - start ) * 1000 ) ; if ( ! raw_request ) { crm_debug ( ""Empty<S2SV_blank>msg<S2SV_blank>received<S2SV_blank>after<S2SV_blank>poll"" ) ; continue ; } if ( * recv_buf ) { int old_len = strlen ( * recv_buf ) ; crm_trace ( ""Expanding<S2SV_blank>recv<S2SV_blank>buffer<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d"" , old_len , old_len + request_len ) ; * recv_buf = realloc ( * recv_buf , old_len + request_len + 1 ) ; memcpy ( * recv_buf + old_len , raw_request , request_len ) ; * ( * recv_buf + old_len + request_len ) = '\\0' ; free ( raw_request ) ; } else { * recv_buf = raw_request ; } if ( strstr ( * recv_buf , REMOTE_MSG_TERMINATOR ) ) { return TRUE ; } } return FALSE <S2SV_ModEnd> "
2309,"<S2SV_StartBug> int r , len , group = 0 ; <S2SV_EndBug> <S2SV_StartBug> Node * * tp ; <S2SV_EndBug> <S2SV_StartBug> goto end_of_token ; <S2SV_EndBug> <S2SV_StartBug> qn = node_new_quantifier ( tok -> u . repeat . lower , tok -> u . repeat . upper , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; unsigned int parse_depth ; group = 0 <S2SV_ModStart> ; parse_depth = env -> parse_depth <S2SV_ModStart> parse_depth ++ ; if ( parse_depth > ParseDepthLimit ) return ONIGERR_PARSE_DEPTH_LIMIT_OVER ; 
2310,"<S2SV_StartBug> if ( ! ND_TTEST2 ( * ar_tpa ( ap ) , PROTO_LEN ( ap ) ) ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , TPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>%s"" , ipaddr_string ( ndo , SPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , <S2SV_EndBug> ","<S2SV_ModStart> TPA <S2SV_ModEnd> <S2SV_ModStart> ""who-has<S2SV_blank>"" ) ) ; tpaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank>tell<S2SV_blank>"" ) ) ; spaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> spaddr_print_ip ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>is-at<S2SV_blank>%s"" <S2SV_ModEnd> <S2SV_ModStart> ""%s<S2SV_blank>at<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ) ) ; tpaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> ""%s<S2SV_blank>at<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ) ) ; spaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> "
2311,<S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( image -> number_meta_channels > MaxPixelChannels ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; "
2312,<S2SV_StartBug> if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal ) <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) && ! ( EXT4_SB ( inode -> i_sb ) -> s_mount_state & EXT4_ORPHAN_FS ) 
2313,<S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> ,"<S2SV_ModStart> buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } "
2314,"<S2SV_StartBug> if ( ! proc_parse_options ( options , ns ) ) { <S2SV_EndBug> ",<S2SV_ModStart> sb -> s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH ; 
2315,<S2SV_StartBug> SSL_USE_ETM ( s ) ) ) { <S2SV_EndBug> ,<S2SV_ModStart> s -> tlsext_use_etm <S2SV_ModEnd> 
2316,<S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> ,<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> 
2317,"<S2SV_StartBug> skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; <S2SV_EndBug> <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ",<S2SV_ModStart> msg -> msg_namelen = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> 
2318,"<S2SV_StartBug> static bool tailmatch ( const char * little , const char * bigone ) <S2SV_EndBug> <S2SV_StartBug> size_t littlelen = strlen ( little ) ; <S2SV_EndBug> <S2SV_StartBug> size_t biglen = strlen ( bigone ) ; <S2SV_EndBug> <S2SV_StartBug> if ( littlelen > biglen ) <S2SV_EndBug> <S2SV_StartBug> return Curl_raw_equal ( little , bigone + biglen - littlelen ) ? TRUE : FALSE ; <S2SV_EndBug> ","<S2SV_ModStart> cooke_domain <S2SV_ModEnd> <S2SV_ModStart> hostname <S2SV_ModEnd> <S2SV_ModStart> cookie_domain_len <S2SV_ModEnd> <S2SV_ModStart> cooke_domain <S2SV_ModEnd> <S2SV_ModStart> hostname_len <S2SV_ModEnd> <S2SV_ModStart> hostname <S2SV_ModEnd> <S2SV_ModStart> hostname_len < cookie_domain_len <S2SV_ModEnd> <S2SV_ModStart> if ( ! Curl_raw_equal ( cooke_domain , hostname + hostname_len - cookie_domain_len ) ) return FALSE ; if ( hostname_len == cookie_domain_len ) return TRUE ; if ( '.' == * ( hostname + hostname_len - cookie_domain_len - 1 ) ) return TRUE ; return <S2SV_ModEnd> "
2319,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> seg -> update_map = 0 ; seg -> update_data = 0 ; 
2320,<S2SV_StartBug> for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) { <S2SV_EndBug> <S2SV_StartBug> if ( unix_sock_count ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( too_many_unix_fds ( current ) ) return - ETOOMANYREFS ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2321,<S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ,<S2SV_ModStart> rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if ( 
2322,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> source -> id = 0 ; 
2323,<S2SV_StartBug> if ( user -> uid_keyring ) { <S2SV_EndBug> ,<S2SV_ModStart> && user -> session_keyring 
2324,<S2SV_StartBug> for ( i = 0 ; mechbuf [ i ] ; i ++ ) mechbuf [ i ] = tolower ( mechbuf [ i ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>mech<S2SV_blank>(mech=%s)"" , mechbuf "
2325,"<S2SV_StartBug> static void __evtchn_fifo_handle_events ( unsigned cpu , bool drop ) <S2SV_EndBug> <S2SV_StartBug> consume_one_event ( cpu , control_block , q , & ready , drop ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct evtchn_loop_ctrl * ctrl <S2SV_ModEnd> <S2SV_ModStart> ctrl , <S2SV_ModStart>  <S2SV_ModEnd> "
2326,"<S2SV_StartBug> if ( spwd && spwd -> sp_expire > 0 && <S2SV_EndBug> <S2SV_StartBug> ( request -> timestamp / 86400 ) > spwd -> sp_expire ) { <S2SV_EndBug> <S2SV_StartBug> radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ; <S2SV_EndBug> ","<S2SV_ModStart> sp_lstchg > 0 && spwd -> sp_max >= <S2SV_ModEnd> <S2SV_ModStart> ( spwd -> sp_lstchg + spwd -> sp_max ) ) { radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ; return RLM_MODULE_REJECT ; } if ( spwd && <S2SV_ModStart> > 0 && ( request -> timestamp / 86400 ) > spwd -> sp_expire <S2SV_ModStart> ""[%s]:<S2SV_blank>account<S2SV_blank>has<S2SV_blank>expired"" <S2SV_ModEnd> "
2327,<S2SV_StartBug> dev -> netdev_ops = & ieee80211_dataif_ops ; <S2SV_EndBug> ,<S2SV_ModStart> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> 
2328,"<S2SV_StartBug> case 'l' : RBININFO ( ""libs"" , R_CORE_BIN_ACC_LIBS , NULL , obj ? r_list_length ( obj -> libs ) : 0 ) ; break ; <S2SV_EndBug> <S2SV_StartBug> case 'i' : RBININFO ( ""imports"" , R_CORE_BIN_ACC_IMPORTS , NULL , obj ? r_list_length ( obj -> imports ) : 0 ) ; break ; <S2SV_EndBug> ",<S2SV_ModStart> { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; <S2SV_ModStart> } <S2SV_ModStart> { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; <S2SV_ModStart> } 
2329,"<S2SV_StartBug> uint8_t i ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>Sel:<S2SV_blank>%d"" , <S2SV_EndBug> <S2SV_StartBug> tval >> 5 , ( tval >> 3 ) & 0x03 , ( tval & 0x07 ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> u_int <S2SV_ModEnd> <S2SV_ModStart> ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>RES:<S2SV_blank>%u,<S2SV_blank>Sel:<S2SV_blank>%u,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%u"" <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> "
2330,"<S2SV_StartBug> futex_wait_queue_me ( hb , & q , to ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( match_futex ( & q . key , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; } "
2331,<S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ipt_entry ) && <S2SV_EndBug> <S2SV_StartBug> t -> verdict < 0 && unconditional ( & e -> ip ) ) || <S2SV_EndBug> ,<S2SV_ModStart> unconditional ( e <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2332,"<S2SV_StartBug> struct { <S2SV_EndBug> <S2SV_StartBug> if ( ip_options_echo ( & replyopts . opt , skb ) ) <S2SV_EndBug> <S2SV_StartBug> if ( replyopts . opt . optlen ) { <S2SV_EndBug> <S2SV_StartBug> if ( ipc . opt -> srr ) <S2SV_EndBug> <S2SV_StartBug> daddr = replyopts . opt . faddr ; <S2SV_EndBug> ",<S2SV_ModStart> ip_options_data <S2SV_ModEnd> <S2SV_ModStart> . opt <S2SV_ModStart> opt . <S2SV_ModStart> replyopts . opt . opt . <S2SV_ModEnd> <S2SV_ModStart> . opt 
2333,<S2SV_StartBug> struct svc_rqst * rqstp = vrqstp ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> ; struct net * net = & init_net ; struct lockd_net * ln = net_generic ( net , lockd_net_id ) <S2SV_ModStart> cancel_delayed_work_sync ( & ln -> grace_period_end ) ; locks_end_grace ( & ln -> lockd_manager ) ; "
2334,"<S2SV_StartBug> ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; <S2SV_EndBug> ","<S2SV_ModStart> ep2 <S2SV_ModEnd> <S2SV_ModStart> if ( cp == NULL ) { ND_PRINT ( ( ndo , "")"" ) ) ; goto trunc ; } "
2335,"<S2SV_StartBug> # line 94 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 95 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 96 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 97 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 100 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 99 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 98 ""hex_grammar.y"" <S2SV_EndBug> ","<S2SV_ModStart> 101 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1030 <S2SV_ModEnd> <S2SV_ModStart> 102 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1036 <S2SV_ModEnd> <S2SV_ModStart> 103 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1042 <S2SV_ModEnd> <S2SV_ModStart> 104 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1048 <S2SV_ModEnd> <S2SV_ModStart> 107 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1054 <S2SV_ModEnd> <S2SV_ModStart> 106 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1060 <S2SV_ModEnd> <S2SV_ModStart> 105 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1066 <S2SV_ModEnd> "
2336,<S2SV_StartBug> pch -> chan_net = net ; <S2SV_EndBug> ,<S2SV_ModStart> get_net ( net ) <S2SV_ModEnd> 
2337,<S2SV_StartBug> image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ; <S2SV_EndBug> <S2SV_StartBug> image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ; <S2SV_EndBug> <S2SV_StartBug> image -> columns = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ; <S2SV_EndBug> <S2SV_StartBug> image -> rows = ( size_t ) ( metrics . ascent - metrics . descent + <S2SV_EndBug> <S2SV_StartBug> image -> rows = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ; <S2SV_EndBug> ,<S2SV_ModStart> floor <S2SV_ModStart> floor <S2SV_ModStart> floor <S2SV_ModStart> floor <S2SV_ModStart> floor 
2338,<S2SV_StartBug> offset = saio -> offsets [ 0 ] + moof_offset ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < gf_list_count ( traf -> sai_sizes ) ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( saio -> offsets && saio -> entry_count ) { <S2SV_ModStart> saio = NULL ; } <S2SV_ModStart> saiz = NULL ; 
2339,<S2SV_StartBug> int target = rc -> av_per_frame_bandwidth ; <S2SV_EndBug> <S2SV_StartBug> ( cm -> frame_flags & FRAMEFLAGS_KEY ) || <S2SV_EndBug> <S2SV_StartBug> cpi -> key_frame_frequency == 0 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> pass == 0 && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { <S2SV_EndBug> ,"<S2SV_ModStart> avg_frame_bandwidth ; const int layer = LAYER_IDS_TO_IDX ( cpi -> svc . spatial_layer_id , cpi -> svc . temporal_layer_id , cpi -> svc . number_temporal_layers ) <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> oxcf . key_freq <S2SV_ModEnd> <S2SV_ModStart> is_two_pass_svc ( cpi ) ) { cpi -> svc . layer_context [ layer ] . is_key_frame = 1 ; cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ; } else if ( is_one_pass_cbr_svc ( cpi ) ) { cpi -> svc . layer_context [ layer ] . is_key_frame = 1 ; reset_temporal_layer_to_zero ( cpi ) ; cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ; target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; } } else { cm -> frame_type = INTER_FRAME ; if ( is_two_pass_svc ( cpi ) ) { LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ; if ( cpi -> svc . spatial_layer_id == 0 ) { lc -> is_key_frame = 0 ; } else { lc -> is_key_frame = cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ; if ( lc -> is_key_frame ) cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ; } cpi -> ref_frame_flags &= ( ~ VP9_ALT_FLAG ) ; } else if ( is_one_pass_cbr_svc ( cpi ) ) { LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ; if ( cpi -> svc . spatial_layer_id == 0 ) { lc -> is_key_frame = 0 ; } else { lc -> is_key_frame = cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ; } target = calc_pframe_target_size_one_pass_cbr ( cpi ) ; } } if ( <S2SV_ModEnd> <S2SV_ModStart> aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_update_parameters ( cpi ) ; <S2SV_ModEnd> "
2340,"<S2SV_StartBug> if ( used_address && used_address -> name_len == msg_sys -> msg_namelen && <S2SV_EndBug> <S2SV_StartBug> ! memcmp ( & used_address -> name , msg -> msg_name , <S2SV_EndBug> <S2SV_StartBug> memcpy ( & used_address -> name , msg -> msg_name , <S2SV_EndBug> ",<S2SV_ModStart> msg_sys -> msg_name && <S2SV_ModStart> msg_sys <S2SV_ModEnd> <S2SV_ModStart> if ( msg_sys -> msg_name ) <S2SV_ModStart> msg_sys <S2SV_ModEnd> 
2341,"<S2SV_StartBug> static void read_mv_probs ( nmv_context * ctx , int allow_hp , vp9_reader * r ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> 
2342,"<S2SV_StartBug> commonlen = COMPUTESIZE ( state . num , state . sumlen ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( LTXTQUERY_TOO_BIG ( state . num , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""ltxtquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ; "
2343,"<S2SV_StartBug> send ( uipc_main . signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
2344,<S2SV_StartBug> * ( buf + insertpos ) = x2c ( & buf [ editpos + 3 ] ) ; <S2SV_EndBug> ,<S2SV_ModStart> _x2c <S2SV_ModEnd> 
2345,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> case RMT_NONE : break ; 
2346,"<S2SV_StartBug> static void nonrd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int mi_col , BLOCK_SIZE bsize , int * rate , <S2SV_EndBug> <S2SV_StartBug> int64_t * dist , int do_recon , int64_t best_rd ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> BLOCK_SIZE subsize ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> <S2SV_StartBug> x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> partition_none_allowed &= ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> <S2SV_StartBug> bsize >= cpi -> sf . min_partition_size ) ; <S2SV_EndBug> <S2SV_StartBug> partition_horz_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> <S2SV_StartBug> bsize > cpi -> sf . min_partition_size ) || <S2SV_EndBug> <S2SV_StartBug> partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> <S2SV_StartBug> bsize > cpi -> sf . min_partition_size ) || <S2SV_EndBug> <S2SV_StartBug> do_split &= bsize > cpi -> sf . min_partition_size ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> in_active_map && ( partition_horz_allowed || partition_vert_allowed ) ) <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> & this_rate , & this_dist , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( this_rate != INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> this_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ; <S2SV_EndBug> <S2SV_StartBug> int64_t stop_thresh = 4096 ; <S2SV_EndBug> <S2SV_StartBug> stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> e_mbd . lossless && best_rd < stop_thresh_rd ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> in_active_map ) { <S2SV_EndBug> <S2SV_StartBug> sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 4 && sum_rd < best_rd ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = i ; <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , <S2SV_EndBug> <S2SV_StartBug> subsize , & this_rate , & this_dist , 0 , <S2SV_EndBug> <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . less_rectangular_check ) <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row + ms , mi_col , <S2SV_EndBug> <S2SV_StartBug> & this_rate , & this_dist , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( this_rate == INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> this_rate += x -> partition_cost [ pl ] [ PARTITION_HORZ ] ; <S2SV_EndBug> <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col + ms , <S2SV_EndBug> <S2SV_StartBug> & this_rate , & this_dist , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( this_rate == INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> this_rate += x -> partition_cost [ pl ] [ PARTITION_VERT ] ; <S2SV_EndBug> <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> <S2SV_StartBug> if ( best_rate == INT_MAX ) <S2SV_EndBug> <S2SV_StartBug> * ( get_sb_partitioning ( x , bsize ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( best_rate < INT_MAX && best_dist < INT64_MAX && do_recon ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) { <S2SV_EndBug> <S2SV_StartBug> best_rate ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize == BLOCK_64X64 ) { <S2SV_EndBug> <S2SV_StartBug> assert ( best_rate < INT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( best_dist < INT64_MAX ) ; <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> <S2SV_ModStart> RD_COST * rd_cost , <S2SV_ModEnd> <S2SV_ModStart> , PC_TREE * pc_tree ) { const SPEED_FEATURES * const sf = & cpi -> sf ; <S2SV_ModEnd> <S2SV_ModStart> TileInfo * const tile_info = & tile_data -> tile_info ; <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> & pc_tree -> none <S2SV_ModEnd> <S2SV_ModStart> = bsize ; RD_COST this_rdc , sum_rdc , best_rdc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vp9_rd_cost_init ( & sum_rdc ) ; vp9_rd_cost_reset ( & best_rdc ) ; best_rdc . rdcost = best_rd ; if ( sf -> <S2SV_ModEnd> <S2SV_ModStart> x -> <S2SV_ModEnd> <S2SV_ModStart> x -> <S2SV_ModEnd> <S2SV_ModStart> x -> <S2SV_ModEnd> <S2SV_ModStart> x -> <S2SV_ModEnd> <S2SV_ModStart> x -> <S2SV_ModEnd> <S2SV_ModStart> x -> <S2SV_ModEnd> <S2SV_ModStart> x -> min_partition_size ; } if ( sf -> <S2SV_ModEnd> <S2SV_ModStart> ctx -> pred_pixel_ready = ! ( partition_vert_allowed || partition_horz_allowed || do_split ) <S2SV_ModEnd> <S2SV_ModStart> tile_data , x <S2SV_ModEnd> <S2SV_ModStart> this_rdc , bsize , ctx ) ; ctx <S2SV_ModEnd> <S2SV_ModStart> ctx -> mbmi_ext = * x -> mbmi_ext ; ctx -> skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; ctx -> skip = x -> skip ; if ( this_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> this_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> this_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> this_rdc . rate , this_rdc . dist ) ; if ( this_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> dist_breakout_thr = sf -> partition_search_breakout_dist_thr ; int64_t rate_breakout_thr = sf -> partition_search_breakout_rate_thr ; dist_breakout_thr <S2SV_ModEnd> <S2SV_ModStart> rate_breakout_thr *= num_pels_log2_lookup [ bsize ] ; best_rdc = this_rdc ; if ( bsize >= BLOCK_8X8 ) pc_tree -> partitioning = PARTITION_NONE <S2SV_ModEnd> <S2SV_ModStart> this_rdc . rate < rate_breakout_thr && this_rdc . dist < dist_breakout_thr <S2SV_ModEnd> <S2SV_ModStart> } store_pred_mv ( x , ctx ) ; if ( do_split <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> ; sum_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , sum_rdc . rate , sum_rdc . dist ) <S2SV_ModStart> sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> td , tile_data <S2SV_ModEnd> <S2SV_ModStart> this_rdc , 0 , best_rdc . rdcost - sum_rdc . rdcost , pc_tree -> split [ i ] ) ; if ( this_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> vp9_rd_cost_reset ( & sum_rdc ) <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_SPLIT <S2SV_ModEnd> <S2SV_ModStart> sf -> <S2SV_ModEnd> <S2SV_ModStart> if ( sf -> adaptive_motion_search ) load_pred_mv ( x , ctx ) ; pc_tree -> horizontal [ 0 ] . pred_pixel_ready = 1 ; nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> horizontal [ 0 ] ) ; pc_tree -> horizontal [ 0 ] . <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> horizontal [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 0 ] . skip = x -> skip ; if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> horizontal [ 1 ] . pred_pixel_ready = 1 ; <S2SV_ModStart> tile_data , x <S2SV_ModEnd> <S2SV_ModStart> this_rdc , subsize , & pc_tree -> horizontal [ 1 ] ) ; pc_tree -> horizontal [ 1 ] . <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> horizontal [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 1 ] . skip = x -> skip ; if ( this_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> vp9_rd_cost_reset ( & sum_rdc ) <S2SV_ModEnd> <S2SV_ModStart> this_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate , sum_rdc . dist ) ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_HORZ ; } else { pred_pixel_ready_reset ( pc_tree , bsize ) <S2SV_ModEnd> <S2SV_ModStart> if ( sf -> adaptive_motion_search ) load_pred_mv ( x , ctx ) ; pc_tree -> vertical [ 0 ] . pred_pixel_ready = 1 ; nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> vertical [ 0 ] ) ; pc_tree -> vertical [ 0 ] . <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> vertical [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 0 ] . skip = x -> skip ; if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> vertical [ 1 ] . pred_pixel_ready = 1 ; <S2SV_ModStart> tile_data , x <S2SV_ModEnd> <S2SV_ModStart> this_rdc , subsize , & pc_tree -> vertical [ 1 ] ) ; pc_tree -> vertical [ 1 ] . <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> vertical [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 1 ] . skip = x -> skip ; if ( this_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> vp9_rd_cost_reset ( & sum_rdc ) <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate , sum_rdc . dist ) ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_VERT ; } else { pred_pixel_ready_reset ( pc_tree , bsize ) ; } } * rd_cost = best_rdc ; if ( best_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> { vp9_rd_cost_reset ( rd_cost ) ; return ; } <S2SV_ModEnd> <S2SV_ModStart> pc_tree ) ; if ( best_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> best_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> encode_sb_rt ( cpi , td , tile_info , tp <S2SV_ModEnd> <S2SV_ModStart> bsize , pc_tree <S2SV_ModEnd> <S2SV_ModStart> && do_recon <S2SV_ModStart> best_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> best_rdc . dist <S2SV_ModEnd> "
2347,"<S2SV_StartBug> if ( ! ND_TTEST2 ( * tptr , 1 ) ) <S2SV_EndBug> ",<S2SV_ModStart> 2 <S2SV_ModEnd> 
2348,"<S2SV_StartBug> static int scsi_disk_emulate_command ( SCSIDiskReq * r , uint8_t * outbuf ) <S2SV_EndBug> ","<S2SV_ModStart> ) { SCSIRequest * req = & r -> req ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; uint64_t nb_sectors ; <S2SV_ModEnd> <S2SV_ModStart> ; int buflen = 0 ; if ( ! r -> iov . iov_base ) { if ( req -> cmd . xfer > 65536 ) { goto illegal_request ; } r -> buflen = MAX ( 4096 , req -> cmd . xfer ) ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } outbuf = r -> iov . iov_base <S2SV_ModEnd> "
2349,<S2SV_StartBug> __enable_irq ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> FLASH -> CR |= FLASH_CR_OBL_LAUNCH ; while ( true <S2SV_ModEnd> 
2350,<S2SV_StartBug> size_t val_len ; <S2SV_EndBug> ,<S2SV_ModStart> = 0 
2351,"<S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> 
2352,<S2SV_StartBug> addr -> sap_family = AF_ATMPVC ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( addr , 0 , sizeof ( * addr ) ) ; "
2353,<S2SV_StartBug> else <S2SV_EndBug> ,"<S2SV_ModStart> else if ( strcmp ( filetype [ i ] . ext , "".SVG"" ) == 0 ) { rsprintf ( ""Content-Type:<S2SV_blank>%s\\r\\n"" , filetype [ i ] . type ) ; if ( strrchr ( file_name , '/' ) ) strlcpy ( str , strrchr ( file_name , '/' ) + 1 , sizeof ( str ) ) ; else strlcpy ( str , file_name , sizeof ( str ) ) ; if ( str [ 6 ] == '_' && str [ 13 ] == '_' ) rsprintf ( ""Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\""%s\\""\\r\\n"" , str + 14 ) ; else rsprintf ( ""Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\""%s\\""\\r\\n"" , str ) ; } "
2354,<S2SV_StartBug> return ret ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ; "
2355,<S2SV_StartBug> long elements ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( * p >= max - 2 ) { zend_error ( E_WARNING , ""Bad<S2SV_blank>unserialize<S2SV_blank>data"" ) ; return - 1 ; } <S2SV_ModStart> - 1 <S2SV_ModEnd> "
2356,<S2SV_StartBug> token ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> ; } if ( operand >= MAX_OPERANDS ) { eprintf ( ""Too<S2SV_blank>many<S2SV_blank>operands\\n"" ) ; return false "
2357,<S2SV_StartBug> void impeg2d_dec_p_mb_params ( dec_state_t * ps_dec ) <S2SV_EndBug> <S2SV_StartBug> ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> WORD32 <S2SV_ModEnd> <S2SV_ModStart> if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ; <S2SV_ModStart> return 0 ; 
2358,<S2SV_StartBug> int row8x8_remaining = tile -> mi_row_end - mi_row ; <S2SV_EndBug> <S2SV_StartBug> int col8x8_remaining = tile -> mi_col_end - mi_col ; <S2SV_EndBug> <S2SV_StartBug> for ( block_row = 0 ; block_row < MI_BLOCK_SIZE ; block_row += bh ) { <S2SV_EndBug> ,"<S2SV_ModStart> const <S2SV_ModStart> const <S2SV_ModStart> set_partial_b64x64_partition ( mi_upper_left , mis , bh , bw , row8x8_remaining , col8x8_remaining , bsize , mi_8x8 ) ; <S2SV_ModEnd> "
2359,<S2SV_StartBug> if ( info . si_code >= 0 ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug> ,<S2SV_ModStart> != SI_QUEUE ) { WARN_ON_ONCE ( info . si_code < 0 ) ; <S2SV_ModEnd> <S2SV_ModStart> } 
2360,<S2SV_StartBug> else if ( verify & GNUTLS_CERT_INVALID ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> } if ( error == NULL ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2361,"<S2SV_StartBug> return ! inode_capable ( inode , CAP_FOWNER ) ; <S2SV_EndBug> ",<S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> 
2362,"<S2SV_StartBug> if ( ( opt_len != mp_dss_len ( mdss , 1 ) && <S2SV_EndBug> <S2SV_StartBug> if ( mdss -> flags & MP_DSS_A ) { <S2SV_EndBug> <S2SV_StartBug> if ( mdss -> flags & MP_DSS_a ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( mdss -> flags & MP_DSS_m ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_16BITS ( opt ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len == mp_dss_len ( mdss , 1 ) ) <S2SV_EndBug> ","<S2SV_ModStart> opt_len < 4 ) return 0 ; if ( <S2SV_ModEnd> <S2SV_ModStart> opt_len -= 4 ; <S2SV_ModStart> if ( opt_len < 8 ) return 0 ; <S2SV_ModStart> opt_len -= 8 ; <S2SV_ModStart> if ( opt_len < 4 ) return 0 ; <S2SV_ModStart> opt_len -= 4 ; <S2SV_ModStart> if ( opt_len < 8 ) return 0 ; <S2SV_ModStart> opt_len -= 8 ; <S2SV_ModStart> if ( opt_len < 4 ) return 0 ; <S2SV_ModStart> opt_len -= 4 ; } if ( opt_len < 4 ) return 0 ; <S2SV_ModEnd> <S2SV_ModStart> opt_len -= 4 ; if ( opt_len < 2 ) return 0 ; <S2SV_ModStart> opt_len -= 2 ; if ( opt_len >= 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>csum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( opt ) ) ) ; opt_len -= 2 ; } } if ( opt_len != 0 ) return 0 ; return 1 <S2SV_ModEnd> "
2363,"<S2SV_StartBug> fprintf ( fpfile , ""%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f<S2SV_blank>%12.4f"" <S2SV_EndBug> <S2SV_StartBug> stats -> intra_error , <S2SV_EndBug> <S2SV_StartBug> stats -> ssim_weighted_pred_err , <S2SV_EndBug> <S2SV_StartBug> stats -> pcnt_neutral , <S2SV_EndBug> ","<S2SV_ModStart> ""%12.0lf<S2SV_blank>%12.4lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf"" ""%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf"" ""%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.4lf\\n"" <S2SV_ModEnd> <S2SV_ModStart> weight , stats -> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , stats -> intra_skip_pct , stats -> inactive_zone_rows , stats -> inactive_zone_cols "
2364,<S2SV_StartBug> int_fb -> in_use = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( int_fb ) 
2365,<S2SV_StartBug> inbuf = _TIFFmalloc ( scanlinesizein ) ; <S2SV_EndBug> ,"<S2SV_ModStart> uint16 bps = 0 ; ( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; if ( bps != 8 ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s"" , ""cpSeparate2ContigByRow"" ) ; return 0 ; } "
2366,<S2SV_StartBug> if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( chunk -> chunk_end < skb_tail_pointer ( chunk -> skb ) ) { <S2SV_EndBug> <S2SV_StartBug> sctp_chunk_free ( chunk ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> + sizeof ( sctp_chunkhdr_t ) <S2SV_ModStart> chunk -> pdiscard = 1 ; chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( ""+++sctp_inq_pop+++<S2SV_blank>chunk:%p[%s],<S2SV_blank>length:%d,<S2SV_blank>skb->len:%d\\n"" , chunk , sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return <S2SV_ModEnd> "
2367,<S2SV_StartBug> err = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> ds = salg -> digestsize ; <S2SV_EndBug> <S2SV_StartBug> ss = salg -> statesize ; <S2SV_EndBug> ,<S2SV_ModStart> alg = & salg -> base ; <S2SV_ModStart> if ( crypto_shash_alg_has_setkey ( salg ) ) goto out_put_alg ; <S2SV_ModStart>  <S2SV_ModEnd> 
2368,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> horAcc32 ( tif , cp0 , cc ) ; <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return 
2369,<S2SV_StartBug> if ( atomic_read ( & kvm -> online_vcpus ) == KVM_MAX_VCPUS ) { <S2SV_EndBug> ,<S2SV_ModStart> ! kvm_vcpu_compatible ( vcpu ) ) { r = - EINVAL ; goto unlock_vcpu_destroy ; } if ( 
2370,<S2SV_StartBug> struct cred * cred ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cred ) <S2SV_EndBug> <S2SV_StartBug> return create_user_ns ( cred ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; int err = - ENOMEM <S2SV_ModStart> cred ) { err = create_user_ns ( cred ) ; if ( err ) put_cred ( cred ) ; else <S2SV_ModEnd> <S2SV_ModStart> } return err <S2SV_ModEnd> 
2371,<S2SV_StartBug> if ( peer ) { <S2SV_EndBug> ,<S2SV_ModStart> lsa -> l2tp_unused = 0 ; 
2372,<S2SV_StartBug> if ( * rsize >= 60 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 && <S2SV_EndBug> ,<S2SV_ModStart> 62 <S2SV_ModEnd> 
2373,<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt && inet -> opt -> srr ) { <S2SV_EndBug> <S2SV_StartBug> nexthop = inet -> opt -> faddr ; <S2SV_EndBug> <S2SV_StartBug> if ( ! inet -> opt || ! inet -> opt -> srr ) <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt ) <S2SV_EndBug> ,"<S2SV_ModStart> ; struct ip_options_rcu * inet_opt <S2SV_ModStart> inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt || ! inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . <S2SV_ModEnd> "
2374,<S2SV_StartBug> drop_futex_key_refs ( & q -> key ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2375,<S2SV_StartBug> if ( test_tsk_need_resched ( rq -> curr ) ) <S2SV_EndBug> ,<S2SV_ModStart> rq -> curr -> se . on_rq && 
2376,<S2SV_StartBug> dh_clnt = EVP_PKEY_get0_DH ( ckey ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ckey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ; return 0 ; } "
2377,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2378,"<S2SV_StartBug> ! inode_capable ( inode , CAP_FSETID ) ) <S2SV_EndBug> ",<S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> 
2379,"<S2SV_StartBug> int offs , int count , int pmgr_flag ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( & ( ( char * ) & sysex ) [ offs ] , & ( addr ) [ offs ] , hdr_size - offs ) ) <S2SV_EndBug> <S2SV_StartBug> if ( count < sysex . len ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sysex , addr , hdr_size <S2SV_ModEnd> <S2SV_ModStart> ( unsigned ) count < ( unsigned ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2380,<S2SV_StartBug> mk_vhost_close ( sr ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sr -> fd_is_fdt == MK_TRUE ) { <S2SV_ModStart> } else { close ( sr -> fd_file ) ; } 
2381,<S2SV_StartBug> } else { <S2SV_EndBug> ,<S2SV_ModStart> rdev -> ena_pin = NULL ; return ; 
2382,<S2SV_StartBug> int chars_processed ; <S2SV_EndBug> <S2SV_StartBug> int data_size = ndo -> ndo_snapend - bp ; <S2SV_EndBug> <S2SV_StartBug> chars_processed = 1 ; <S2SV_EndBug> <S2SV_StartBug> cp = bp + ( ( ( i << 8 ) | * cp ) & 0x3fff ) ; <S2SV_EndBug> <S2SV_StartBug> chars_processed ++ ; <S2SV_EndBug> <S2SV_StartBug> chars_processed += l ; <S2SV_EndBug> <S2SV_StartBug> chars_processed ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> elt ; u_int offset , max_offset ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; max_offset = ( u_int ) ( cp - bp ) ; if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) { compress = 0 ; rp = cp + l ; } if ( i != 0 ) while ( i && cp < <S2SV_ModEnd> <S2SV_ModStart> ) { if ( ( i & INDIR_MASK ) == INDIR_MASK ) { if ( ! compress ) { rp = cp + 1 ; compress = 1 ; } <S2SV_ModEnd> <S2SV_ModStart> offset = ( ( ( i << 8 ) | * cp ) & 0x3fff ) ; if ( offset >= max_offset ) { ND_PRINT ( ( ndo , ""<BAD<S2SV_blank>PTR>"" ) ) ; return ( NULL ) ; } max_offset = offset ; cp = bp + offset ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2383,<S2SV_StartBug> if ( ! valid_localpart ( maddr -> user ) || <S2SV_EndBug> <S2SV_StartBug> ! valid_domainpart ( maddr -> domain ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> mailfrom && maddr -> user [ 0 ] == '\\0' && maddr -> domain [ 0 ] == '\\0' ) return ( 1 ) ; if ( maddr -> user [ 0 ] == '\\0' || <S2SV_ModStart> ) return ( 0 ) ; if ( maddr -> domain [ 0 ] == '\\0' ) { ( void ) strlcpy ( maddr -> domain , domain , sizeof ( maddr -> domain ) ) ; } if ( <S2SV_ModEnd> <S2SV_ModStart> return ( 0 ) ; <S2SV_ModEnd> "
2384,"<S2SV_StartBug> return send ( socket -> fd , buf , count , MSG_DONTWAIT ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
2385,"<S2SV_StartBug> static int input_stats ( struct twopass_rc * p , FIRSTPASS_STATS * fps ) { <S2SV_EndBug> ",<S2SV_ModStart> TWO_PASS <S2SV_ModEnd> 
2386,<S2SV_StartBug> # ifdef CONFIG_SWAP <S2SV_EndBug> <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> ,<S2SV_ModStart> * prev = vma ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2387,<S2SV_StartBug> if ( image -> debug != MagickFalse ) <S2SV_EndBug> ,"<S2SV_ModStart> EOFBlob ( image ) != MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""InsufficientImageDataInFile"" , image -> filename ) ; } if ( "
2388,<S2SV_StartBug> struct static_key * done_key ) <S2SV_EndBug> <S2SV_StartBug> __net_random_once_disable_jump ( done_key ) ; <S2SV_EndBug> ,<S2SV_ModStart> once_key <S2SV_ModEnd> <S2SV_ModStart> once_key <S2SV_ModEnd> 
2389,"
","
"
2390,"<S2SV_StartBug> unsigned int var = block_variance ( cpi , x , bs ) ; <S2SV_EndBug> ",<S2SV_ModStart> double energy_midpoint ; vpx_clear_system_state ( ) ; energy_midpoint = ( cpi -> oxcf . pass == 2 ) ? cpi -> twopass . mb_av_energy : DEFAULT_E_MIDPOINT ; energy = vp9_log_block_var <S2SV_ModEnd> <S2SV_ModStart> - energy_midpoint <S2SV_ModEnd> 
2391,"<S2SV_StartBug> static vpx_codec_err_t ctrl_set_svc_layer_id ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2392,<S2SV_StartBug> srose -> srose_family = AF_ROSE ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( srose , 0 , msg -> msg_namelen ) ; "
2393,"<S2SV_StartBug> static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options ) <S2SV_EndBug> <S2SV_StartBug> if ( ! options ) { <S2SV_EndBug> <S2SV_StartBug> case ecryptfs_opt_err : <S2SV_EndBug> ","<S2SV_ModStart> , uid_t * check_ruid <S2SV_ModStart> * check_ruid = 0 ; <S2SV_ModStart> ecryptfs_opt_check_dev_ruid : * check_ruid = 1 ; break ; case "
2394,"<S2SV_StartBug> cJSON_AddFloatToObject ( j , ""cpu_util_total"" , test -> cpu_util [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddFloatToObject ( j , ""cpu_util_user"" , test -> cpu_util [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddFloatToObject ( j , ""cpu_util_system"" , test -> cpu_util [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddIntToObject ( j , ""sender_has_retransmits"" , sender_has_retransmits ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddIntToObject ( j_stream , ""id"" , sp -> id ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddIntToObject ( j_stream , ""bytes"" , bytes_transferred ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddIntToObject ( j_stream , ""retransmits"" , retransmits ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddFloatToObject ( j_stream , ""jitter"" , sp -> jitter ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddIntToObject ( j_stream , ""errors"" , sp -> cnt_error ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddIntToObject ( j_stream , ""packets"" , sp -> packet_count ) ; <S2SV_EndBug> ",<S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> <S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> <S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> <S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> <S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> <S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> <S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> <S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> <S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> <S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> 
2395,"<S2SV_StartBug> memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2396,<S2SV_StartBug> u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ; <S2SV_EndBug> <S2SV_StartBug> case PSR_AA32_MODE_FIQ : <S2SV_EndBug> <S2SV_StartBug> case PSR_MODE_EL0t : <S2SV_EndBug> <S2SV_StartBug> case PSR_MODE_EL1h : <S2SV_EndBug> ,<S2SV_ModStart> u64 <S2SV_ModEnd> <S2SV_ModStart> u64 <S2SV_ModEnd> <S2SV_ModStart> if ( ! system_supports_32bit_el0 ( ) ) return - EINVAL ; break ; <S2SV_ModStart> if ( ! vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ; break ; <S2SV_ModStart> if ( vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ; 
2397,"<S2SV_StartBug> int64_t tx_cache [ TX_MODES ] , <S2SV_EndBug> <S2SV_StartBug> MB_PREDICTION_MODE mode ; <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> intra_super_block_yrd ( cpi , x , & this_rate_tokenonly , & this_distortion , <S2SV_EndBug> <S2SV_StartBug> & s , NULL , bsize , local_tx_cache , best_rd ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . tx_size_search_method == USE_FULL_RD && this_rd < INT64_MAX ) { <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE mode ; PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> * bmode_costs ; const MODE_INFO * above_mi = xd -> above_mi ; const MODE_INFO * left_mi = xd -> left_mi ; const PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , 0 ) ; const PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , 0 ) ; bmode_costs = cpi <S2SV_ModEnd> <S2SV_ModStart> memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) ; for ( mode = DC_PRED ; mode <= TM_PRED ; mode ++ ) { if ( cpi -> sf . use_nonrd_pick_mode ) { if ( conditional_skipintra ( mode , mode_selected ) ) continue ; if ( * skippable ) break ; <S2SV_ModStart> super_block_yrd <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2398,<S2SV_StartBug> CurrentColorSpace = ColorSpaceOut ; <S2SV_EndBug> <S2SV_StartBug> cmsPipelineFree ( Lut ) ; <S2SV_EndBug> ,<S2SV_ModStart> Lut = NULL ; <S2SV_ModStart> if ( Lut != NULL ) 
2399,"<S2SV_StartBug> len = curl_msnprintf ( fptr , left , ""%ld"" , width ) ; <S2SV_EndBug> <S2SV_StartBug> len = curl_msnprintf ( fptr , left , "".%ld"" , prec ) ; <S2SV_EndBug> <S2SV_StartBug> for ( fptr = work ; * fptr ; fptr ++ ) <S2SV_EndBug> ",<S2SV_ModStart> if ( width >= ( long ) sizeof ( work ) ) width = sizeof ( work ) - 1 ; <S2SV_ModStart> size_t maxprec = sizeof ( work ) - 2 ; double val = p -> data . dnum ; while ( val >= 10.0 ) { val /= 10 ; maxprec -- ; } if ( prec > ( long ) maxprec ) prec = maxprec - 1 ; <S2SV_ModStart> # ifdef CURLDEBUG assert ( strlen ( work ) <= sizeof ( work ) ) ; # endif 
2400,<S2SV_StartBug> int vert_causal_ctx_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_VSC ; <S2SV_EndBug> ,<S2SV_ModStart> ; av_assert0 ( width <= JPEG2000_MAX_CBLKW ) ; av_assert0 ( height <= JPEG2000_MAX_CBLKH ) 
2401,<S2SV_StartBug> if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> ,<S2SV_ModStart> return 0 ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2402,<S2SV_StartBug> CollSeq * p4 ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( pParse -> nErr ) return 0 
2403,"<S2SV_StartBug> mc -> id = idr_alloc ( & multicast_idr , mc , 0 , 0 , GFP_KERNEL ) ; <S2SV_EndBug> ",<S2SV_ModStart> NULL <S2SV_ModEnd> 
2404,<S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> memset ( p , 0 , sizeof ( * p ) ) ; "
2405,<S2SV_StartBug> continue ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( len >= FPM_LOG_BUFFER ) { zlog ( ZLOG_NOTICE , ""the<S2SV_blank>log<S2SV_blank>buffer<S2SV_blank>is<S2SV_blank>full<S2SV_blank>(%d).<S2SV_blank>The<S2SV_blank>access<S2SV_blank>log<S2SV_blank>request<S2SV_blank>has<S2SV_blank>been<S2SV_blank>truncated."" , FPM_LOG_BUFFER ) ; len = FPM_LOG_BUFFER ; break ; } "
2406,"<S2SV_StartBug> if ( ! fc_may_access ( fc , controller , path1 , path2 , fi -> flags ) ) { <S2SV_EndBug> ","<S2SV_ModStart> caller_may_see_dir ( fc -> pid , controller , path1 ) ) { ret = - ENOENT ; goto out ; } if ( ! "
2407,"<S2SV_StartBug> CYCLIC_REFRESH * vp9_cyclic_refresh_alloc ( int mi_rows , int mi_cols ) { <S2SV_EndBug> <S2SV_StartBug> return cr ; <S2SV_EndBug> ","<S2SV_ModStart> size_t last_coded_q_map_size ; <S2SV_ModStart> last_coded_q_map_size = mi_rows * mi_cols * sizeof ( * cr -> last_coded_q_map ) ; cr -> last_coded_q_map = vpx_malloc ( last_coded_q_map_size ) ; if ( cr -> last_coded_q_map == NULL ) { vpx_free ( cr ) ; return NULL ; } assert ( MAXQ <= 255 ) ; memset ( cr -> last_coded_q_map , MAXQ , last_coded_q_map_size ) ; "
2408,"<S2SV_StartBug> dm9000WriteReg ( DM9000_REG_MWCMDX , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> DM9000_INDEX_REG = DM9000_REG_MWCMD ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_TXPLL , LSB ( length ) ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_TXPLH , MSB ( length ) ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_ISR , ISR_PT ) ; <S2SV_EndBug> ","<S2SV_ModStart> DM9000_MWCMDX <S2SV_ModEnd> <S2SV_ModStart> DM9000_MWCMD <S2SV_ModEnd> <S2SV_ModStart> DM9000_TXPLL <S2SV_ModEnd> <S2SV_ModStart> DM9000_TXPLH <S2SV_ModEnd> <S2SV_ModStart> DM9000_ISR , DM9000_ISR_PT ) ; dm9000WriteReg ( DM9000_TCR , DM9000_TCR_TXREQ <S2SV_ModEnd> "
2409,<S2SV_StartBug> inbuf = _TIFFmalloc ( scanlinesizein ) ; <S2SV_EndBug> ,"<S2SV_ModStart> uint16 bps = 0 ; ( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; if ( bps != 8 ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s"" , ""cpContig2SeparateByRow"" ) ; return 0 ; } "
2410,<S2SV_StartBug> if ( ! SSL_USE_ETM ( s ) && EVP_MD_CTX_md ( s -> read_hash ) != NULL ) <S2SV_EndBug> ,<S2SV_ModStart> SSL_READ_ETM <S2SV_ModEnd> 
2411,<S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> if ( vmx_get_cpl ( vcpu ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 0 ; } "
2412,"<S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> err = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> ","<S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) <S2SV_ModStart> ) ; rcu_read_unlock ( <S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) , <S2SV_ModEnd> <S2SV_ModStart> ) ; rcu_read_unlock ( "
2413,"<S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 3 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_24BITS ( p + 2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 
2414,"<S2SV_StartBug> pynum = parsenumber ( c , s ) ; <S2SV_EndBug> ",<S2SV_ModStart> STR ( ch ) <S2SV_ModEnd> 
2415,"<S2SV_StartBug> udf_pc_to_char ( inode -> i_sb , symlink , inode -> i_size , p ) ; <S2SV_EndBug> <S2SV_StartBug> brelse ( bh ) ; <S2SV_EndBug> ","<S2SV_ModStart> err = <S2SV_ModStart> , PAGE_SIZE <S2SV_ModStart> ; if ( err ) goto out_unlock_inode "
2416,<S2SV_StartBug> const MB_PREDICTION_MODE y_mode = mi -> mbmi . mode ; <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE uv_mode = mi -> mbmi . uv_mode ; <S2SV_EndBug> ,<S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> 
2417,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % stride ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horAcc8"" , ""%s"" , ""(cc%stride)!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; "
2418,"<S2SV_StartBug> env = g_environ_setenv ( env , var , val , TRUE ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( var [ 0 ] == '\\0' ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Environment<S2SV_blank>variable<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>empty<S2SV_blank>name"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( strchr ( var , '=' ) != NULL ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Environment<S2SV_blank>variable<S2SV_blank>name<S2SV_blank>cannot<S2SV_blank>contain<S2SV_blank>\'=\'"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } g_string_append ( env_string , var ) ; g_string_append_c ( env_string , '=' ) ; g_string_append ( env_string , val ) ; g_string_append_c ( env_string , '\\0' <S2SV_ModEnd> "
2419,<S2SV_StartBug> goto errout_locked ; <S2SV_EndBug> <S2SV_StartBug> kfree ( family -> attrbuf ) ; <S2SV_EndBug> ,<S2SV_ModStart> errout_free <S2SV_ModEnd> <S2SV_ModStart> errout_free : 
2420,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % ( 2 * stride ) ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horDiff8"" , ""%s"" , ""(cc%(2*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; "
2421,"<S2SV_StartBug> up_read ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_TLV , & kctl -> id ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct snd_ctl_elem_id id = kctl -> id ; <S2SV_ModStart>  <S2SV_ModEnd> 
2422,"<S2SV_StartBug> ""InvalidGeometry"" , ""`%s\'"" , option ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; geometry = DestroyString ( geometry 
2423,"<S2SV_StartBug> static inline bool unconditional ( const struct arpt_arp * arp ) <S2SV_EndBug> <S2SV_StartBug> return memcmp ( arp , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug> ",<S2SV_ModStart> arpt_entry * e <S2SV_ModEnd> <S2SV_ModStart> e -> target_offset == sizeof ( struct arpt_entry ) && memcmp ( & e -> <S2SV_ModEnd> 
2424,<S2SV_StartBug> if ( user_alloc && ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) ) <S2SV_EndBug> ,"<S2SV_ModStart> ( <S2SV_ModStart> ) ) || ! access_ok ( VERIFY_WRITE , mem -> userspace_addr , mem -> memory_size "
2425,"<S2SV_StartBug> size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> tail = <S2SV_ModEnd> <S2SV_ModStart> ; if ( cdf_check_stream_offset ( sst , h , p , tail * sizeof ( uint32_t ) , __LINE__ ) == - 1 ) goto out ; size_t ofs = CDF_GETUINT32 ( p , tail "
2426,<S2SV_StartBug> err = - EMSGSIZE ; <S2SV_EndBug> <S2SV_StartBug> ipc . opt = inet -> opt ; <S2SV_EndBug> <S2SV_StartBug> if ( ipc . opt -> srr ) { <S2SV_EndBug> <S2SV_StartBug> daddr = ipc . opt -> faddr ; <S2SV_EndBug> ,"<S2SV_ModStart> struct ip_options_data opt_copy ; <S2SV_ModStart> { struct ip_options_rcu * inet_opt ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt ) { memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ; ipc . opt = & opt_copy . opt ; } rcu_read_unlock ( ) ; } <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . "
2427,<S2SV_StartBug> img = ctx -> iface -> enc . get_preview ( ctx -> priv -> alg_priv ) ; <S2SV_EndBug> ,<S2SV_ModStart> get_alg_priv ( ctx ) <S2SV_ModEnd> 
2428,<S2SV_StartBug> static void follow_dotdot ( struct nameidata * nd ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ; <S2SV_ModStart> return 0 ; 
2429,<S2SV_StartBug> else if ( rc == - ENODATA ) <S2SV_EndBug> <S2SV_StartBug> return rc ; <S2SV_EndBug> ,<S2SV_ModStart> && inode -> i_op -> removexattr ) { <S2SV_ModEnd> <S2SV_ModStart> } 
2430,<S2SV_StartBug> MP4_READBOX_ENTER ( MP4_Box_data_string_t ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; if ( p_box -> i_size < 8 || p_box -> i_size > SIZE_MAX ) MP4_READBOX_EXIT ( 0 
2431,"<S2SV_StartBug> u8 obuf [ 0x40 ] , ibuf [ 0x40 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( mutex_lock_interruptible ( & d -> i2c_mutex ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> switch ( num ) { <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = msg [ 0 ] . buf [ 0 ] + 0x36 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 3 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 0 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0x10 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 2 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> msg [ 0 ] . buf [ 1 ] = ibuf [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> msg [ 0 ] . buf [ 0 ] = ibuf [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0x08 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = msg [ 0 ] . addr ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = msg [ 0 ] . len ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & obuf [ 3 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 3 , <S2SV_EndBug> <S2SV_StartBug> ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0x09 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = msg [ 0 ] . len ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 3 ] = msg [ 0 ] . addr ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & obuf [ 4 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 4 , <S2SV_EndBug> <S2SV_StartBug> ibuf , msg [ 1 ] . len + 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg [ 1 ] . buf , & ibuf [ 1 ] , msg [ 1 ] . len ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & d -> i2c_mutex ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct dw2102_state * state <S2SV_ModEnd> <S2SV_ModStart> state = d -> priv ; <S2SV_ModStart> if ( mutex_lock_interruptible ( & d -> data_mutex ) < 0 ) { mutex_unlock ( & d -> i2c_mutex ) ; return - EAGAIN ; } <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data , 1 , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data [ 1 ] = msg [ 0 ] . len ; state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> data_mutex ) ; mutex_unlock ( & d -> "
2432,"<S2SV_StartBug> if ( yych != ':' ) goto yy18 ; <S2SV_EndBug> <S2SV_StartBug> # line 804 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 836 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 881 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 936 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 989 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1086 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1161 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1214 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1228 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1237 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1285 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1334 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> ",<S2SV_ModStart> <= '/' ) goto yy18 ; if ( yych >= ';' <S2SV_ModEnd> <S2SV_ModStart> 805 <S2SV_ModEnd> <S2SV_ModStart> 837 <S2SV_ModEnd> <S2SV_ModStart> 882 <S2SV_ModEnd> <S2SV_ModStart> 937 <S2SV_ModEnd> <S2SV_ModStart> 990 <S2SV_ModEnd> <S2SV_ModStart> 1087 <S2SV_ModEnd> <S2SV_ModStart> 1162 <S2SV_ModEnd> <S2SV_ModStart> 1215 <S2SV_ModEnd> <S2SV_ModStart> 1229 <S2SV_ModEnd> <S2SV_ModStart> 1238 <S2SV_ModEnd> <S2SV_ModStart> 1286 <S2SV_ModEnd> <S2SV_ModStart> 1335 <S2SV_ModEnd> 
2433,"<S2SV_StartBug> if ( timeri -> master ) <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & slave_active_lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> && timeri -> timer ) { spin_lock ( & timeri -> timer -> lock ) ; <S2SV_ModEnd> <S2SV_ModStart> spin_unlock ( & timeri -> timer -> lock ) ; } 
2434,<S2SV_StartBug> int n = * pnEntry ; <S2SV_EndBug> <S2SV_StartBug> int sz = ( n == 0 ) ? 1 : 2 * n ; <S2SV_EndBug> ,<S2SV_ModStart> sqlite3_int64 <S2SV_ModEnd> <S2SV_ModStart> sqlite3_int64 <S2SV_ModEnd> 
2435,<S2SV_StartBug> if ( NFCT_FRAG6_CB ( fp ) -> orig == NULL ) <S2SV_EndBug> ,<S2SV_ModStart> fp && 
2436,<S2SV_StartBug> sbi -> s_mb_cache = ext4_xattr_create_cache ( sb -> s_id ) ; <S2SV_EndBug> <S2SV_StartBug> failed_mount_wq : <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( sbi -> s_mb_cache ) { ext4_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } 
2437,"<S2SV_StartBug> const InterpKernel * kernel = vp9_get_interp_kernel ( mi -> mbmi . interp_filter ) ; <S2SV_EndBug> <S2SV_StartBug> ? ( plane == 0 ? mi -> bmi [ block ] . as_mv [ ref ] . as_mv <S2SV_EndBug> <S2SV_StartBug> if ( vp9_is_scaled ( sf ) ) { <S2SV_EndBug> <S2SV_StartBug> inter_predictor ( pre , pre_buf -> stride , dst , dst_buf -> stride , <S2SV_EndBug> <S2SV_StartBug> subpel_x , subpel_y , sf , w , h , ref , kernel , xs , ys ) ; <S2SV_EndBug> ","<S2SV_ModStart> vp9_filter_kernels [ <S2SV_ModEnd> <S2SV_ModStart> ] <S2SV_ModEnd> <S2SV_ModStart> average_split_mvs ( pd , mi , ref , block <S2SV_ModEnd> <S2SV_ModStart> const int is_scaled = vp9_is_scaled ( sf ) ; if ( is_scaled <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { high_inter_predictor ( pre , pre_buf -> stride , dst , dst_buf -> stride , subpel_x , subpel_y , sf , w , h , ref , kernel , xs , ys , xd -> bd ) ; } else { <S2SV_ModStart> } # else inter_predictor ( pre , pre_buf -> stride , dst , dst_buf -> stride , subpel_x , subpel_y , sf , w , h , ref , kernel , xs , ys ) ; # endif "
2438,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> i1_intra_pred = CLIP3 ( 0 , 8 , i1_intra_pred ) ; <S2SV_ModStart> i1_intra_pred = CLIP3 ( 0 , 8 , i1_intra_pred ) ; "
2439,<S2SV_StartBug> assert ( caplen > 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2440,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK2 ( * s , 1 ) ; "
2441,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( image -> colors < tga_info . colormap_index ) image -> colors = tga_info . colormap_index ; 
2442,<S2SV_StartBug> res . acl_len ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2443,<S2SV_StartBug> mutex_unlock ( & file -> mut ) ; <S2SV_EndBug> ,"<S2SV_ModStart> mutex_lock ( & mut ) ; idr_replace ( & multicast_idr , mc , mc -> id ) ; mutex_unlock ( & mut ) ; "
2444,"<S2SV_StartBug> timeri = list_entry ( timer -> open_list_head . next , <S2SV_EndBug> <S2SV_StartBug> if ( timeri -> flags & SNDRV_TIMER_IFLG_EXCLUSIVE ) { <S2SV_EndBug> <S2SV_StartBug> err = - EBUSY ; <S2SV_EndBug> ",<S2SV_ModStart> struct snd_timer_instance * t = <S2SV_ModEnd> <S2SV_ModStart> t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2445,<S2SV_StartBug> d0u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> d1u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 1 ] ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2446,"<S2SV_StartBug> static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , <S2SV_EndBug> <S2SV_StartBug> ref -> ref ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> bool <S2SV_ModEnd> <S2SV_ModStart> if ( ref -> ref > INT_MAX / 2 ) return false ; <S2SV_ModStart> return true ; 
2447,"<S2SV_StartBug> int is_rf64 = ! strncmp ( fourcc , ""RF64"" , 4 ) , got_ds64 = 0 ; <S2SV_EndBug> <S2SV_StartBug> int supported = TRUE , format ; <S2SV_EndBug> ","<S2SV_ModStart> = 0 , format_chunk <S2SV_ModStart> if ( format_chunk ++ ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } "
2448,<S2SV_StartBug> l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ; <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK_16BITS ( p + l2info -> cookie_len ) ; 
2449,"<S2SV_StartBug> if ( JAS_CAST ( uint , jas_stream_read ( in , ppm -> data , ppm -> len ) ) != ppm -> len ) { <S2SV_EndBug> ",<S2SV_ModStart> jas_uint <S2SV_ModEnd> 
2450,"<S2SV_StartBug> ( mutt_bcache_exists ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) == 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> cache_id ( ctx -> hdrs [ i ] -> data ) <S2SV_ModEnd> 
2451,<S2SV_StartBug> int nNew = ( v -> nOpAlloc >= 512 ? v -> nOpAlloc * 2 : v -> nOpAlloc + nOp ) ; <S2SV_EndBug> <S2SV_StartBug> int nNew = ( v -> nOpAlloc ? v -> nOpAlloc * 2 : ( int ) ( 1024 / sizeof ( Op ) ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> sqlite3_int64 <S2SV_ModEnd> <S2SV_ModStart> 2 * ( sqlite3_int64 ) v -> nOpAlloc : ( sqlite3_int64 ) <S2SV_ModEnd> <S2SV_ModStart> sqlite3_int64 <S2SV_ModEnd> <S2SV_ModStart> 2 * ( sqlite3_int64 ) v -> nOpAlloc : ( sqlite3_int64 ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2452,<S2SV_StartBug> if ( key -> type -> destroy ) <S2SV_EndBug> ,"<S2SV_ModStart> test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && "
2453,"<S2SV_StartBug> int mi_row ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 = cm -> mi_grid_visible ; <S2SV_EndBug> <S2SV_StartBug> log_frame_info ( cm , descriptor , file ) ; <S2SV_EndBug> <S2SV_StartBug> * ( ( int * ) ( ( char * ) ( & mi_8x8 [ mi_index ] -> mbmi ) + <S2SV_EndBug> <S2SV_StartBug> mi_index ++ ; <S2SV_EndBug> <S2SV_StartBug> mi_index += 8 ; <S2SV_EndBug> ","<S2SV_ModStart> , mi_col <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mi [ 0 <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> "
2454,"<S2SV_StartBug> FIRSTPASS_STATS this_frame ; <S2SV_EndBug> <S2SV_StartBug> if ( read_frame_stats ( twopass , & this_frame , ( i + offset ) ) == EOF ) <S2SV_EndBug> <S2SV_StartBug> accumulate_frame_motion_stats ( & this_frame , <S2SV_EndBug> <S2SV_StartBug> decay_accumulator *= get_prediction_decay_rate ( & cpi -> common , & this_frame ) ; <S2SV_EndBug> <S2SV_StartBug> boost_score += ( decay_accumulator * <S2SV_EndBug> <S2SV_StartBug> calc_frame_boost ( cpi , & this_frame , this_frame_mv_in_out ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( read_frame_stats ( twopass , & this_frame , ( i + offset ) ) == EOF ) <S2SV_EndBug> <S2SV_StartBug> accumulate_frame_motion_stats ( & this_frame , <S2SV_EndBug> <S2SV_StartBug> decay_accumulator *= get_prediction_decay_rate ( & cpi -> common , & this_frame ) ; <S2SV_EndBug> <S2SV_StartBug> boost_score += ( decay_accumulator * <S2SV_EndBug> <S2SV_StartBug> calc_frame_boost ( cpi , & this_frame , this_frame_mv_in_out ) ) ; <S2SV_EndBug> <S2SV_StartBug> arf_boost = ( ( b_frames + f_frames ) * 20 ) ; <S2SV_EndBug> ","<S2SV_ModStart> TWO_PASS <S2SV_ModEnd> <S2SV_ModStart> const FIRSTPASS_STATS * this_frame = read_frame_stats ( twopass , i + offset ) ; if ( this_frame == NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cpi , <S2SV_ModEnd> <S2SV_ModStart> decay_accumulator * <S2SV_ModEnd> <S2SV_ModStart> this_frame , this_frame_mv_in_out , GF_MAX_BOOST <S2SV_ModEnd> <S2SV_ModStart> const FIRSTPASS_STATS * this_frame = read_frame_stats ( twopass , i + offset ) ; if ( this_frame == NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cpi , <S2SV_ModEnd> <S2SV_ModStart> decay_accumulator * <S2SV_ModEnd> <S2SV_ModStart> this_frame , this_frame_mv_in_out , GF_MAX_BOOST <S2SV_ModEnd> <S2SV_ModStart> ) ; arf_boost = MAX ( arf_boost , MIN_ARF_GF_BOOST "
2455,"<S2SV_StartBug> emsg ( _ ( ""E145:<S2SV_blank>Shell<S2SV_blank>commands<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""E145:<S2SV_blank>Shell<S2SV_blank>commands<S2SV_blank>and<S2SV_blank>some<S2SV_blank>functionality<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim"" <S2SV_ModEnd> "
2456,<S2SV_StartBug> goto read_error ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2457,"<S2SV_StartBug> vpx_memset ( lfi -> lfthr [ lvl ] . hev_thr , ( lvl >> 4 ) , SIMD_WIDTH ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> 
2458,"<S2SV_StartBug> static void print_bpf_insn ( struct bpf_insn * insn ) <S2SV_EndBug> <S2SV_StartBug> } else if ( BPF_MODE ( insn -> code ) == BPF_IMM ) { <S2SV_EndBug> <S2SV_StartBug> insn -> code , insn -> dst_reg , insn -> imm ) ; <S2SV_EndBug> ","<S2SV_ModStart> const struct bpf_verifier_env * env , const <S2SV_ModStart> && BPF_SIZE ( insn -> code ) == BPF_DW ) { u64 imm = ( ( u64 ) ( insn + 1 ) -> imm << 32 ) | ( u32 ) insn -> imm ; bool map_ptr = insn -> src_reg == BPF_PSEUDO_MAP_FD ; if ( map_ptr && ! env -> allow_ptr_leaks ) imm = 0 ; verbose ( ""(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>0x%llx\\n"" , insn -> code , <S2SV_ModEnd> <S2SV_ModStart> ( unsigned long long ) <S2SV_ModEnd> "
2459,"<S2SV_StartBug> static INLINE void read_mv ( vp9_reader * r , MV * mv , const MV * ref , <S2SV_EndBug> <S2SV_StartBug> ( MV_JOINT_TYPE ) vp9_read_tree ( r , vp9_mv_joint_tree , ctx -> joints ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_read_tree <S2SV_ModEnd> 
2460,"<S2SV_StartBug> virCheckDomainReturn ( dom , - 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; virCheckReadOnlyGoto ( dom -> conn -> flags , error "
2461,<S2SV_StartBug> if ( ! data ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> || len < 2 ) { <S2SV_ModEnd> <S2SV_ModStart> } 
2462,"<S2SV_StartBug> const char * value = NULL ; <S2SV_EndBug> <S2SV_StartBug> cib_client_t * client = data ; <S2SV_EndBug> <S2SV_StartBug> command = crm_recv_remote_msg ( client -> session , client -> encrypted ) ; <S2SV_EndBug> <S2SV_StartBug> value = crm_element_name ( command ) ; <S2SV_EndBug> <S2SV_StartBug> crm_xml_add ( command , F_CIB_USER , client -> user ) ; <S2SV_EndBug> <S2SV_StartBug> crm_xml_add ( command , F_CIB_CALLID , call_uuid ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; int disconnected = 0 ; int timeout = client -> remote_auth ? - 1 : 1000 <S2SV_ModStart> # ifdef HAVE_GNUTLS_GNUTLS_H if ( client -> encrypted && ( client -> handshake_complete == FALSE ) ) { int rc = 0 ; do { rc = gnutls_handshake ( * <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( rc < 0 && rc != GNUTLS_E_AGAIN ) { crm_err ( ""Remote<S2SV_blank>cib<S2SV_blank>tls<S2SV_blank>handshake<S2SV_blank>failed"" ) ; <S2SV_ModEnd> <S2SV_ModStart> } while ( rc == GNUTLS_E_INTERRUPTED ) ; if ( rc == 0 ) { crm_debug ( ""Remote<S2SV_blank>cib<S2SV_blank>tls<S2SV_blank>handshake<S2SV_blank>completed"" ) ; client -> handshake_complete = TRUE ; if ( client -> remote_auth_timeout ) { g_source_remove ( client -> remote_auth_timeout ) ; } client -> remote_auth_timeout = g_timeout_add ( REMOTE_AUTH_TIMEOUT , remote_auth_timeout_cb , client ) ; } return 0 ; } # endif crm_recv_remote_msg ( client -> session , & client -> recv_buf , client -> encrypted , timeout , & disconnected ) ; if ( client -> remote_auth == FALSE ) { xmlNode * reg <S2SV_ModEnd> <S2SV_ModStart> const char * user = NULL ; # endif command = crm_parse_remote_buffer ( & client -> recv_buf ) ; if ( cib_remote_auth ( command ) == FALSE ) { free_xml ( command ) ; return - 1 ; } crm_debug ( ""remote<S2SV_blank>connection<S2SV_blank>authenticated<S2SV_blank>successfully"" ) ; client -> remote_auth = TRUE ; g_source_remove ( client -> remote_auth_timeout ) ; client -> remote_auth_timeout = 0 ; client -> name = crm_element_value_copy ( command , ""name"" ) ; # if ENABLE_ACL user = crm_element_value ( command , ""user"" ) ; if ( user ) { new_client -> user = strdup ( user ) ; } # endif reg = create_xml_node ( NULL , ""cib_result"" <S2SV_ModEnd> <S2SV_ModStart> reg , F_CIB_OPERATION , CRM_OP_REGISTER ) ; crm_xml_add ( reg , F_CIB_CLIENTID , client -> id ) ; crm_send_remote_msg ( client -> session , reg , client -> encrypted ) ; free_xml ( reg ) ; free_xml ( command ) ; } command = crm_parse_remote_buffer ( & client -> recv_buf ) ; while ( command ) { crm_trace ( ""command<S2SV_blank>received"" ) ; cib_handle_remote_msg ( client , command ) ; free_xml ( command ) ; command = crm_parse_remote_buffer ( & client -> recv_buf ) ; } if ( disconnected ) { crm_trace ( ""disconnected<S2SV_blank>while<S2SV_blank>receiving<S2SV_blank>remote<S2SV_blank>cib<S2SV_blank>msg."" ) ; return - 1 ; } return <S2SV_ModEnd> "
2463,"<S2SV_StartBug> if ( ! ( self -> mt_used * 3 >= ( self -> mt_mask + 1 ) * 2 ) ) <S2SV_EndBug> <S2SV_StartBug> return _PyMemoTable_ResizeTable ( self , <S2SV_EndBug> <S2SV_StartBug> ( self -> mt_used > 50000 ? 2 : 4 ) * self -> mt_used ) ; <S2SV_EndBug> ","<S2SV_ModStart> SIZE_MAX / 3 >= self -> mt_used && <S2SV_ModEnd> <S2SV_ModStart> < self -> mt_allocated <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModEnd> <S2SV_ModStart> } size_t desired_size = <S2SV_ModEnd> <S2SV_ModStart> ; return _PyMemoTable_ResizeTable ( self , desired_size "
2464,<S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> ,"<S2SV_ModStart> size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> alloc_size <S2SV_ModEnd> "
2465,"<S2SV_StartBug> vpx_memset ( segment_counts , 0 , sizeof ( segment_counts ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
2466,"<S2SV_StartBug> const char command5 [ ] = { 0x05 , 0x00 } ; <S2SV_EndBug> <S2SV_StartBug> close ( s ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> } ; const char bad_command4 [ ] = { 0x04 , 0x01 , 0x60 , 0x8f , 0xff , 0xff , 0xff , 0x7f <S2SV_ModStart> if ( n == 0 ) { <S2SV_ModStart> s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( bad_command4 , sizeof ( bad_command4 ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( ""Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n"" , ( int ) n ) ; printresponse ( buf , n ) ; close ( s ) ; "
2467,<S2SV_StartBug> return self ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( p_key ) rb_ivar_set ( self , id_key_set , Qtrue ) ; "
2468,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && frame -> linesize [ plane ] 
2469,"<S2SV_StartBug> struct flowi4 fl4 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! __sk_dst_get ( sk ) || __sk_dst_check ( sk , 0 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! IS_ERR ( rt ) ) <S2SV_EndBug> <S2SV_StartBug> __sk_dst_set ( sk , & rt -> dst ) ; <S2SV_EndBug> ","<S2SV_ModStart> dst_entry * dst ; struct <S2SV_ModStart> rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; <S2SV_ModStart> dst || ! dst -> obsolete || dst -> ops -> check ( dst <S2SV_ModEnd> <S2SV_ModStart> { rcu_read_unlock ( ) ; return ; } <S2SV_ModEnd> <S2SV_ModStart> dst = <S2SV_ModEnd> <S2SV_ModStart> ? <S2SV_ModEnd> <S2SV_ModStart> dst : NULL ; sk_dst_set ( sk , "
2470,"<S2SV_StartBug> c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> aligned_height = FFALIGN ( c -> height , 16 ) ; <S2SV_EndBug> ",<S2SV_ModStart> + 15 <S2SV_ModEnd> <S2SV_ModStart> * 3 ; aligned_height = <S2SV_ModEnd> <S2SV_ModStart> + 15 <S2SV_ModEnd> 
2471,"<S2SV_StartBug> bool tsonly ; <S2SV_EndBug> <S2SV_StartBug> sk -> sk_type == SOCK_STREAM ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , tstype ) ; <S2SV_EndBug> ","<S2SV_ModStart> , opt_stats = false <S2SV_ModStart> { <S2SV_ModStart> opt_stats = true ; } <S2SV_ModStart> , opt_stats "
2472,<S2SV_StartBug> if ( * rsize >= 107 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 && <S2SV_EndBug> ,<S2SV_ModStart> 112 <S2SV_ModEnd> 
2473,"<S2SV_StartBug> static vpx_codec_err_t vp8e_set_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2474,<S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } <S2SV_ModEnd> <S2SV_ModStart> { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } <S2SV_ModEnd> "
2475,"<S2SV_StartBug> size_t ss = CDF_SEC_SIZE ( h ) , i , j ; <S2SV_EndBug> ",<S2SV_ModStart> CDF_SHORT_SEC_SIZE <S2SV_ModEnd> 
2476,"<S2SV_StartBug> return send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
2477,"<S2SV_StartBug> a = 1.0f / MaxF ( w . x , MaxF ( w . y , w . z ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> MagickMax ( w . x , MagickMax <S2SV_ModEnd> "
2478,"<S2SV_StartBug> static int jas_iccgetuint ( jas_stream_t * in , int n , ulonglong * val ) <S2SV_EndBug> <S2SV_StartBug> ulonglong v ; <S2SV_EndBug> ",<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> <S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> 
2479,<S2SV_StartBug> int n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! body -> unit_size ) break ; n 
2480,<S2SV_StartBug> uint32 nstrips ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2481,"<S2SV_StartBug> memccpy ( result , ptr , 0 , len ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2482,"<S2SV_StartBug> imap_quote_string ( dest , dlen , buf ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false "
2483,<S2SV_StartBug> ifd ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( len > 2560000 || ! ( cbuf = ( char * ) malloc ( len ) ) ) <S2SV_EndBug> ,<S2SV_ModStart> # ifdef LIBRAW_LIBRARY_BUILD if ( ifd >= sizeof tiff_ifd / sizeof tiff_ifd [ 0 ] ) throw LIBRAW_EXCEPTION_IO_CORRUPT ; # endif <S2SV_ModStart> < 1 || len 
2484,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> trace_kvm_emulate_insn_failed ( vcpu ) ; <S2SV_EndBug> <S2SV_StartBug> kvm_queue_exception ( vcpu , UD_VECTOR ) ; <S2SV_EndBug> <S2SV_StartBug> return EMULATE_FAIL ; <S2SV_EndBug> ",<S2SV_ModStart> int r = EMULATE_DONE ; <S2SV_ModStart> if ( ! is_guest_mode ( vcpu ) ) { <S2SV_ModStart> r = EMULATE_FAIL ; } <S2SV_ModStart> r <S2SV_ModEnd> 
2485,"<S2SV_StartBug> # define COPY_PORT ( dest , src ) do { int i ; for ( i = 0 ; i < ARRAY_SIZE ( src -> read_urbs ) ; ++ i ) { dest -> read_urbs [ i ] = src -> read_urbs [ i ] ; dest -> read_urbs [ i ] -> context = dest ; dest -> bulk_in_buffers [ i ] = src -> bulk_in_buffers [ i ] ; } dest -> read_urb = src -> read_urb ; dest -> bulk_in_endpointAddress = src -> bulk_in_endpointAddress ; dest -> bulk_in_buffer = src -> bulk_in_buffer ; dest -> bulk_in_size = src -> bulk_in_size ; dest -> interrupt_in_urb = src -> interrupt_in_urb ; dest -> interrupt_in_urb -> context = dest ; dest -> interrupt_in_endpointAddress = src -> interrupt_in_endpointAddress ; dest -> interrupt_in_buffer = src -> interrupt_in_buffer ; } while ( 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( serial -> num_bulk_in < 2 || serial -> num_interrupt_in < 2 ) { dev_err ( & serial -> interface -> dev , ""missing<S2SV_blank>endpoints\\n"" ) ; return - ENODEV ; } "
2486,<S2SV_StartBug> err = 0 ; <S2SV_EndBug> <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> msg -> msg_namelen = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> 
2487,"<S2SV_StartBug> pixs = pixRead ( ""cat.035.jpg"" ) ; <S2SV_EndBug> <S2SV_StartBug> lept_stderr ( ""pdf<S2SV_blank>file<S2SV_blank>made:<S2SV_blank>/tmp/lept/model/dewarptest1.pdf\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> lept_rmdir ( ""lept/dewmod"" ) ; lept_mkdir ( ""lept/dewmod"" ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
2488,<S2SV_StartBug> endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; <S2SV_EndBug> <S2SV_StartBug> goto fail3 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( intf -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & intf -> dev , ""interface<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>endpoints,<S2SV_blank>but<S2SV_blank>must<S2SV_blank>have<S2SV_blank>minimum<S2SV_blank>1\\n"" , intf -> altsetting [ 0 ] . desc . bNumEndpoints ) ; err = - EINVAL ; goto fail3 ; } <S2SV_ModStart> err = - EINVAL ; "
2489,<S2SV_StartBug> long newpos ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> 
2490,"<S2SV_StartBug> set_header ( res , ""Content-Type"" , mime ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , "
2491,"<S2SV_StartBug> int net ; <S2SV_EndBug> <S2SV_StartBug> CLIENT * client ; <S2SV_EndBug> <S2SV_StartBug> if ( ( net = accept ( sock , ( struct sockaddr * ) & addrin , & addrinlen ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> client = negotiate ( net , NULL , servers , NEG_INIT | NEG_MODERN ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> handle_modern_connection ( servers , sock ) ; } for ( i = 0 ; i < servers -> len ; i ++ ) { int net ; SERVER * serve ; serve = & ( g_array_index ( servers , SERVER , i ) ) ; if ( serve -> socket < 0 ) { continue ; } if ( FD_ISSET ( serve -> socket , & rset ) ) { <S2SV_ModEnd> <S2SV_ModStart> serve -> socket <S2SV_ModEnd> <S2SV_ModStart> handle_connection ( servers , net , serve , NULL <S2SV_ModEnd> "
2492,<S2SV_StartBug> sc -> drefs = av_mallocz ( entries * sizeof ( * sc -> drefs ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> drefs_count = 0 ; sc -> 
2493,"<S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , sizeof ( struct in_addr ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 6 ] , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 6 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> bp += 8 ; <S2SV_EndBug> <S2SV_StartBug> len -= 8 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , sizeof ( struct in_addr ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 4 ] , sizeof ( struct in_addr ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( EXTRACT_32BITS ( & bp [ 4 ] ) != 0xffffffff ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""/%s"" , ipaddr_string ( ndo , & bp [ 4 ] ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 8 ] , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> njoin = EXTRACT_16BITS ( & bp [ 8 ] ) ; <S2SV_EndBug> <S2SV_StartBug> nprune = EXTRACT_16BITS ( & bp [ 10 ] ) ; <S2SV_EndBug> <S2SV_StartBug> bp += 12 ; <S2SV_EndBug> <S2SV_StartBug> len -= 12 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , 6 ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( len < sizeof ( struct in_addr ) ) goto trunc ; <S2SV_ModStart> bp += 4 ; len -= 4 ; if ( len < 4 ) goto trunc ; <S2SV_ModStart> 2 <S2SV_ModEnd> <S2SV_ModStart> 2 <S2SV_ModEnd> <S2SV_ModStart> 4 <S2SV_ModEnd> <S2SV_ModStart> 4 ; if ( len < 4 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> if ( len < 4 ) goto trunc ; <S2SV_ModStart> bp += 4 ; len -= 4 ; if ( len < 4 ) goto trunc ; <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> 0 ] ) ) ) ; bp += 4 ; len -= 4 ; if ( len < 4 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> 2 <S2SV_ModEnd> <S2SV_ModStart> 4 <S2SV_ModEnd> <S2SV_ModStart> 4 <S2SV_ModEnd> <S2SV_ModStart> if ( len < 6 ) goto trunc ; 
2494,"<S2SV_StartBug> static void sas_destruct_devices ( struct work_struct * work ) <S2SV_EndBug> <S2SV_StartBug> struct domain_device * dev , * n ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> asd_sas_port * port <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2495,"<S2SV_StartBug> int number_bidders , i , bid , best_bid ; <S2SV_EndBug> <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , n <S2SV_ModStart> n = 0 ; n < 25 ; ++ n <S2SV_ModEnd> <S2SV_ModStart> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Input<S2SV_blank>requires<S2SV_blank>too<S2SV_blank>many<S2SV_blank>filters<S2SV_blank>for<S2SV_blank>decoding"" ) ; return ( ARCHIVE_FATAL ) ; "
2496,"<S2SV_StartBug> flush_dcache_page ( page ) ; <S2SV_EndBug> <S2SV_StartBug> iov_iter_advance ( ii , tmp ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; iov_iter_advance ( ii , tmp <S2SV_ModStart>  <S2SV_ModEnd> "
2497,<S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( numSamples <= 0 ) { ALOGE ( ""b/26366256"" ) ; return ; } "
2498,"<S2SV_StartBug> netdev_dbg ( vif -> dev , ""Need<S2SV_blank>more<S2SV_blank>frags\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Too<S2SV_blank>many<S2SV_blank>frags\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Frags<S2SV_blank>galore\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\n"" , <S2SV_EndBug> <S2SV_StartBug> txp -> offset , txp -> size ) ; <S2SV_EndBug> ","<S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> netdev_err ( vif -> dev , ""Frag<S2SV_blank>is<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>frame.\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> <S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif "
2499,<S2SV_StartBug> qemu_vfree ( r -> iov . iov_base ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( r -> iov . iov_base ) { <S2SV_ModStart> } 
2500,<S2SV_StartBug> if ( ! ( dev -> flags & IFF_UP ) ) <S2SV_EndBug> <S2SV_StartBug> if ( skb -> len > ( dev -> mtu + dev -> hard_header_len ) ) <S2SV_EndBug> <S2SV_StartBug> return NET_RX_DROP ; <S2SV_EndBug> ,<S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> ) { kfree_skb ( skb ) ; <S2SV_ModStart> } 
2501,"<S2SV_StartBug> int ret , n ; <S2SV_EndBug> <S2SV_StartBug> hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; <S2SV_EndBug> <S2SV_StartBug> hid -> country = hdesc -> bCountryCode ; <S2SV_EndBug> <S2SV_StartBug> for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) <S2SV_EndBug> ","<S2SV_ModStart> ; int num_descriptors ; size_t offset = offsetof ( struct hid_descriptor , desc ) <S2SV_ModStart> if ( hdesc -> bLength < sizeof ( struct hid_descriptor ) ) { dbg_hid ( ""hid<S2SV_blank>descriptor<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\\n"" ) ; return - EINVAL ; } <S2SV_ModStart> ; num_descriptors = min_t ( int , hdesc -> bNumDescriptors , ( hdesc -> bLength - offset ) / sizeof ( struct hid_class_descriptor ) ) <S2SV_ModStart> num_descriptors <S2SV_ModEnd> "
2502,"<S2SV_StartBug> void vp9_iht16x16_256_add_c ( const int16_t * input , uint8_t * dest , int stride , <S2SV_EndBug> <S2SV_StartBug> int16_t out [ 16 * 16 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = out ; <S2SV_EndBug> <S2SV_StartBug> int16_t temp_in [ 16 ] , temp_out [ 16 ] ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < 16 ; ++ j ) <S2SV_EndBug> <S2SV_StartBug> dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) <S2SV_EndBug> <S2SV_StartBug> + dest [ j * stride + i ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> clip_pixel_add ( <S2SV_ModEnd> <S2SV_ModStart> , ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) ) ; } <S2SV_ModEnd> "
2503,"<S2SV_StartBug> memset ( sax , 0 , sizeof ( sax ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> * 
2504,<S2SV_StartBug> for ( j = 0 ; j < book -> dim ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < book -> dim ; j ++ ) <S2SV_EndBug> ,<S2SV_ModStart> && i < n <S2SV_ModStart> && i < n 
2505,<S2SV_StartBug> zip_object_handlers . get_properties = php_zip_get_properties ; <S2SV_EndBug> ,<S2SV_ModStart> get_gc = php_zip_get_gc ; zip_object_handlers . 
2506,"<S2SV_StartBug> ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> pptr += BGP_VPN_RD_LEN ; <S2SV_EndBug> ",<S2SV_ModStart> + 4 <S2SV_ModStart> + 4 
2507,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( TSQUERY_TOO_BIG ( list_length ( state . polstr ) , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ; "
2508,<S2SV_StartBug> if ( ent != NULL ) { <S2SV_EndBug> <S2SV_StartBug> cleanup : <S2SV_EndBug> ,"<S2SV_ModStart> == NULL ) { st = KRB5_KDB_NOENTRY ; <S2SV_ModEnd> <S2SV_ModStart> st = populate_policy ( context , ld , ent , pol_name , * policy ) ; "
2509,"<S2SV_StartBug> static void sas_probe_devices ( struct work_struct * work ) <S2SV_EndBug> <S2SV_StartBug> struct domain_device * dev , * n ; <S2SV_EndBug> ",<S2SV_ModStart> asd_sas_port * port <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2510,<S2SV_StartBug> if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > <S2SV_EndBug> <S2SV_StartBug> pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2511,"<S2SV_StartBug> char * ext_name = NULL ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( ( r = sshbuf_get_cstring ( m , & ext_name , NULL ) ) != 0 ) { <S2SV_EndBug> <S2SV_StartBug> err : <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart> r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart> r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> <S2SV_ModStart> r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> <S2SV_ModStart> r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart> parse_key_constraint_extension ( m , sk_providerp ) ) != 0 ) goto out ; break ; default : error_f ( <S2SV_ModEnd> <S2SV_ModStart> r = SSH_ERR_FEATURE_UNSUPPORTED ; goto out ; } } r = 0 ; out : return r <S2SV_ModEnd> "
2512,"<S2SV_StartBug> sprintf ( url_address , ""%.*s"" , url_len , url_begin ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( url_len >= sizeof ( url_address ) ) { applog ( LOG_WARNING , ""%s:<S2SV_blank>Truncating<S2SV_blank>overflowed<S2SV_blank>address<S2SV_blank>\'%.*s\'"" , __func__ , url_len , url_begin ) ; url_len = sizeof ( url_address ) - 1 ; } "
2513,"<S2SV_StartBug> vp8_decrypt_cb * decrypt_cb , <S2SV_EndBug> <S2SV_StartBug> int n = data_sz > 10 ? 10 : data_sz ; <S2SV_EndBug> <S2SV_StartBug> res = VPX_CODEC_UNSUP_BITSTREAM ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_decrypt_cb <S2SV_ModEnd> <S2SV_ModStart> MIN ( sizeof ( clear_buffer ) , data_sz ) <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> "
2514,<S2SV_StartBug> addr . sun_family = AF_UNIX ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( strlen ( sockFile ) + 1 > sizeof ( addr . sun_path ) ) { rfbClientErr ( ""ConnectToUnixSock:<S2SV_blank>socket<S2SV_blank>file<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long\\n"" ) ; return - 1 ; } "
2515,<S2SV_StartBug> prev = NULL ; <S2SV_EndBug> <S2SV_StartBug> up_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! mmget_still_valid ( mm ) ) goto skip_mm ; <S2SV_ModStart> skip_mm : 
2516,<S2SV_StartBug> return IMPEG2D_MB_TEX_DECODE_ERR ; <S2SV_EndBug> ,<S2SV_ModStart> if ( 0 >= ps_dec -> u2_num_mbs_left ) { break ; } 
2517,"<S2SV_StartBug> vpx_memset ( a , has_eob , sizeof ( ENTROPY_CONTEXT ) * tx_size_in_blocks ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( l , has_eob , sizeof ( ENTROPY_CONTEXT ) * tx_size_in_blocks ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
2518,"<S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( q + 32 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( q + 48 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
2519,<S2SV_StartBug> ENSURE_BITS ( 16 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( bits_left == 0 ) <S2SV_ModStart>  <S2SV_ModEnd> 
2520,"<S2SV_StartBug> static void nsc_rle_decompress_data ( NSC_CONTEXT * context ) <S2SV_EndBug> <S2SV_StartBug> rle = context -> Planes ; <S2SV_EndBug> <S2SV_StartBug> FillMemory ( context -> priv -> PlaneBuffers [ i ] , originalSize , 0xFF ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( planeSize < originalSize ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decode ( rle , context -> priv -> PlaneBuffers [ i ] , originalSize ) ; <S2SV_EndBug> <S2SV_StartBug> rle += planeSize ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> if ( ! context ) return FALSE ; <S2SV_ModStart> { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModStart> } <S2SV_ModStart> { if ( ! <S2SV_ModStart> context -> priv -> PlaneBuffersLength , originalSize ) ) return FALSE ; } else { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> return TRUE ; "
2521,<S2SV_StartBug> local_bh_disable ( ) ; <S2SV_EndBug> <S2SV_StartBug> local_bh_enable ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> spin_lock_bh ( & net -> sctp . addr_wq_lock <S2SV_ModEnd> <S2SV_ModStart> spin_unlock_bh ( & net -> sctp . addr_wq_lock <S2SV_ModEnd> 
2522,<S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 4 ) <S2SV_EndBug> <S2SV_StartBug> p ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ( image -> columns % 4 ) >= 1 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( image -> columns % 4 ) >= 2 ) <S2SV_EndBug> ,<S2SV_ModStart> 3 <S2SV_ModEnd> <S2SV_ModStart> q += GetPixelChannels ( image ) ; p ++ <S2SV_ModEnd> <S2SV_ModStart> > <S2SV_ModEnd> <S2SV_ModStart> > <S2SV_ModEnd> 
2523,"<S2SV_StartBug> const struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( np -> opt ) <S2SV_EndBug> <S2SV_StartBug> newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ; <S2SV_EndBug> <S2SV_StartBug> if ( newnp -> opt ) <S2SV_EndBug> <S2SV_StartBug> inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + <S2SV_EndBug> <S2SV_StartBug> newnp -> opt -> opt_flen ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; struct ipv6_txoptions * opt <S2SV_ModStart> opt = rcu_dereference <S2SV_ModEnd> <S2SV_ModStart> ; if ( opt ) { <S2SV_ModEnd> <S2SV_ModStart> opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2524,"<S2SV_StartBug> static int cost_mv_ref ( const VP9_COMP * cpi , MB_PREDICTION_MODE mode , <S2SV_EndBug> <S2SV_StartBug> int mode_context ) { <S2SV_EndBug> <S2SV_StartBug> return x -> inter_mode_cost [ mode_context ] [ INTER_OFFSET ( mode ) ] ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ",<S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2525,"<S2SV_StartBug> register u_int amt ; <S2SV_EndBug> <S2SV_StartBug> j = length / sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6 <S2SV_EndBug> <S2SV_StartBug> if ( j * sizeof ( * ni ) != length - 4 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d:"" , j ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> i -= sizeof ( * ni ) , ++ ni ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> j = length / sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> if ( j * sizeof ( * ni ) != length - 4 ) <S2SV_EndBug> <S2SV_StartBug> trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ; <S2SV_EndBug> <S2SV_StartBug> for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> i -= sizeof ( * ni ) , ++ ni ) { <S2SV_EndBug> <S2SV_StartBug> if ( trunc ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> unsigned int length_left ; u_int j ; ND_TCHECK ( rp -> rip6_cmd <S2SV_ModEnd> <S2SV_ModStart> length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> <S2SV_ModStart> ) { ND_TCHECK ( rp -> rip6_nets ) ; if ( <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u[%u]:"" , j , length <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank>ripng-req<S2SV_blank>%u:"" , j ) <S2SV_ModEnd> <S2SV_ModStart> length_left <S2SV_ModEnd> <S2SV_ModStart> length_left <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( * ni ) ; <S2SV_ModStart> if ( length_left != 0 ) goto trunc ; <S2SV_ModStart> length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> <S2SV_ModStart> length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> length_left <S2SV_ModEnd> <S2SV_ModStart> length_left <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( * ni ) ; <S2SV_ModStart> length_left != 0 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( rp -> rip6_vers ) ; <S2SV_ModStart> return ; trunc : ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ; return ; "
2526,<S2SV_StartBug> if ( ! alt ) <S2SV_EndBug> ,<S2SV_ModStart> ) return - ENODEV ; if ( alt -> desc . bNumEndpoints < 1 
2527,<S2SV_StartBug> if ( q > e ) { <S2SV_EndBug> ,<S2SV_ModStart> < p || q 
2528,<S2SV_StartBug> if ( ( ldblk > 9999 ) || ( ldblk < 0 ) ) <S2SV_EndBug> ,<S2SV_ModStart> EOFBlob ( image ) ) break ; if ( 
2529,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( ( size_t ) len >= sizeof ( icon_buf ) ) { logger ( Protocol , Warning , ""seamless_process_line(),<S2SV_blank>icon<S2SV_blank>data<S2SV_blank>would<S2SV_blank>overrun<S2SV_blank>icon_buf"" ) ; break ; } "
2530,<S2SV_StartBug> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! tmp ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; 
2531,<S2SV_StartBug> if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,"<S2SV_ModStart> { <S2SV_ModStart> ; } else memset ( & ifr , 0 , sizeof ( ifr ) ) "
2532,"<S2SV_StartBug> char src [ PATH_MAX + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( src , dir , dir_len ) ; <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> if ( dir_len > PATH_MAX ) { uwsgi_log ( ""invalid<S2SV_blank>path<S2SV_blank>size:<S2SV_blank>%d<S2SV_blank>(max<S2SV_blank>%d)\\n"" , dir_len , PATH_MAX ) ; return NULL ; } char * src = uwsgi_concat2n ( <S2SV_ModEnd> <S2SV_ModStart> , """" , 0 ) <S2SV_ModEnd> <S2SV_ModStart> free ( src ) ; <S2SV_ModStart> free ( src ) ; "
2533,"<S2SV_StartBug> const int w = vpx_img_plane_width ( img , plane ) ; <S2SV_EndBug> ",<S2SV_ModStart> * ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) 
2534,<S2SV_StartBug> put_device ( & bus -> dev ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2535,"<S2SV_StartBug> vpx_memcpy ( ctx -> pred_mv , x -> pred_mv , sizeof ( x -> pred_mv ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> 
2536,<S2SV_StartBug> OVS_NOT_REACHED ( ) ; <S2SV_EndBug> <S2SV_StartBug> OVS_NOT_REACHED ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> return OFPERR_OFPGMFC_BAD_TYPE <S2SV_ModEnd> <S2SV_ModStart> return OFPERR_OFPGMFC_BAD_COMMAND <S2SV_ModEnd> 
2537,<S2SV_StartBug> if ( ack -> subh . addip_hdr -> serial == serial ) { <S2SV_EndBug> ,<S2SV_ModStart> sctp_chunk_pending ( ack ) ) continue ; if ( 
2538,"<S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_find_first ( ext2_xattr_cache , inode -> i_sb -> s_bdev , <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> inode -> i_ino , ( unsigned long ) ce -> e_block ) ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_find_next ( ce , inode -> i_sb -> s_bdev , hash ) ; <S2SV_EndBug> ","<S2SV_ModStart> mb2_cache_entry * ce ; struct mb2_cache * ext2_mb_cache = EXT2_SB ( inode -> i_sb ) -> s_mb_cache <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_entry_find_first ( ext2_mb_cache , hash ) ; while ( ce ) { struct buffer_head * bh ; bh = sb_bread ( <S2SV_ModEnd> <S2SV_ModStart> , ce -> e_block ) ; if ( ! bh ) { ext2_error ( inode -> i_sb , ""ext2_xattr_cache_find"" , ""inode<S2SV_blank>%ld:<S2SV_blank>block<S2SV_blank>%ld<S2SV_blank>read<S2SV_blank>error"" , inode -> i_ino , ( unsigned long ) ce -> e_block ) ; } else { lock_buffer ( bh ) ; if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) { mb2_cache_entry_put ( ext2_mb_cache , ce ) ; unlock_buffer ( bh ) ; brelse ( bh ) ; <S2SV_ModEnd> <S2SV_ModStart> } else if ( le32_to_cpu ( HDR ( bh ) -> h_refcount ) > EXT2_XATTR_REFCOUNT_MAX ) { ea_idebug ( inode , ""block<S2SV_blank>%ld<S2SV_blank>refcount<S2SV_blank>%d>%d"" , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_entry_touch ( ext2_mb_cache , ce ) ; mb2_cache_entry_put ( ext2_mb_cache , <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_entry_find_next ( ext2_mb_cache , ce <S2SV_ModEnd> "
2539,"<S2SV_StartBug> if ( sk_filter ( sk , skb ) ) <S2SV_EndBug> ",<S2SV_ModStart> tcp_filter <S2SV_ModEnd> 
2540,<S2SV_StartBug> for ( plane = 0 ; plane < MAX_MB_PLANE ; ++ plane ) { <S2SV_EndBug> <S2SV_StartBug> const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi ) : mbmi -> tx_size ; <S2SV_EndBug> ,"<S2SV_ModStart> mbmi -> skip = 1 ; if ( x -> skip ) return ; <S2SV_ModStart> , pd "
2541,"<S2SV_StartBug> memmove ( s + j , s + qs , blen - qs ) ; <S2SV_EndBug> <S2SV_StartBug> j += blen - qs ; <S2SV_EndBug> ",<S2SV_ModStart> const int qslen = blen - qs ; <S2SV_ModStart> ( size_t ) qslen ) ; qs = j <S2SV_ModEnd> <S2SV_ModStart> qslen <S2SV_ModEnd> 
2542,<S2SV_StartBug> if ( sec_attr == NULL ) { <S2SV_EndBug> ,<S2SV_ModStart> || sec_attr_len 
2543,<S2SV_StartBug> U2FHID_INIT_RESP initresp ; <S2SV_EndBug> <S2SV_StartBug> if ( resplen > sizeof ( initresp ) ) <S2SV_EndBug> <S2SV_StartBug> dev -> cid = initresp . cid ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionInterface = initresp . versionInterface ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionMajor = initresp . versionMajor ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionMinor = initresp . versionMinor ; <S2SV_EndBug> <S2SV_StartBug> dev -> capFlags = initresp . capFlags ; <S2SV_EndBug> ,"<S2SV_ModStart> int offs = sizeof ( nonce ) <S2SV_ModEnd> <S2SV_ModStart> < 17 ) { return U2FH_SIZE_ERROR ; } if ( memcmp ( nonce , resp , sizeof ( nonce ) ) != 0 ) { return U2FH_TRANSPORT_ERROR ; } <S2SV_ModEnd> <S2SV_ModStart> resp [ offs ] << 24 | resp [ offs + 1 ] << 16 | resp [ offs + 2 ] << 8 | resp [ offs + 3 ] ; offs += 4 <S2SV_ModEnd> <S2SV_ModStart> resp [ offs ++ ] <S2SV_ModEnd> <S2SV_ModStart> resp [ offs ++ ] <S2SV_ModEnd> <S2SV_ModStart> resp [ offs ++ ] ; dev -> versionBuild = resp [ offs ++ ] <S2SV_ModEnd> <S2SV_ModStart> resp [ offs ++ ] <S2SV_ModEnd> "
2544,<S2SV_StartBug> while ( f != upto ) ; <S2SV_EndBug> ,<S2SV_ModStart> && f 
2545,<S2SV_StartBug> hash_param . data = 0 ; <S2SV_EndBug> <S2SV_StartBug> hash_param . len = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> instance -> private_key <S2SV_ModEnd> <S2SV_ModStart> instance -> private_key_len <S2SV_ModEnd> 
2546,<S2SV_StartBug> ctxt -> dst . type = OP_REG ; <S2SV_EndBug> <S2SV_StartBug> ctxt -> dst . bytes = ctxt -> op_bytes ; <S2SV_EndBug> ,"<S2SV_ModStart> int rc ; unsigned long eip ; rc = emulate_pop ( ctxt , & eip , <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; return assign_eip_near ( ctxt , eip <S2SV_ModEnd> "
2547,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> <S2SV_StartBug> exit_func : <S2SV_EndBug> ",<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : <S2SV_ModStart>  <S2SV_ModEnd> 
2548,<S2SV_StartBug> key_user_put ( key -> user ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( key -> type -> destroy ) key -> type -> destroy ( key ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
2549,"<S2SV_StartBug> static int expandRegular ( rpmfi fi , const char * dest , rpmpsm psm , int nodigest , int nocontent ) <S2SV_EndBug> <S2SV_StartBug> wfd = Fopen ( dest , ""w.ufdio"" ) ; <S2SV_EndBug> <S2SV_StartBug> umask ( old_umask ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int exclusive <S2SV_ModStart> exclusive ? ""wx.ufdio"" : ""a.ufdio"" <S2SV_ModEnd> <S2SV_ModStart> if ( ! exclusive && wfd != NULL && ! linkSane ( wfd , dest ) ) { rc = RPMERR_OPEN_FAILED ; goto exit ; } "
2550,"<S2SV_StartBug> int rose_parse_facilities ( unsigned char * p , <S2SV_EndBug> <S2SV_StartBug> if ( facilities_len == 0 ) <S2SV_EndBug> <S2SV_StartBug> while ( facilities_len > 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ","<S2SV_ModStart> , unsigned packet_len <S2SV_ModStart> || ( unsigned ) facilities_len > packet_len <S2SV_ModStart> >= 3 && <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> break ; default : printk ( KERN_DEBUG ""ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\n"" , * p ) ; len = 1 ; break ; } <S2SV_ModStart> ) return 0 ; if ( WARN_ON ( len >= facilities_len ) <S2SV_ModStart> } return facilities_len == 0 <S2SV_ModEnd> "
2551,"<S2SV_StartBug> tcpSendSegment ( socket , TCP_FLAG_ACK , socket -> sndNxt , socket -> rcvNxt , 0 , FALSE ) ; <S2SV_EndBug> ",<S2SV_ModStart> { <S2SV_ModStart> } 
2552,"<S2SV_StartBug> vpx_img_fmt_t fmt ) { <S2SV_EndBug> <S2SV_StartBug> const char * const color = fmt == VPX_IMG_FMT_444A ? ""C444alpha\\n"" : <S2SV_EndBug> <S2SV_StartBug> ""C420jpeg\\n"" ; <S2SV_EndBug> ","<S2SV_ModStart> , unsigned int bit_depth <S2SV_ModStart> color ; switch ( bit_depth ) { case 8 : <S2SV_ModEnd> <S2SV_ModStart> break ; case 9 : color = fmt == VPX_IMG_FMT_I44416 ? ""C444p9<S2SV_blank>XYSCSS=444P9\\n"" : fmt == VPX_IMG_FMT_I42216 ? ""C422p9<S2SV_blank>XYSCSS=422P9\\n"" : ""C420p9<S2SV_blank>XYSCSS=420P9\\n"" ; break ; case 10 : color = fmt == VPX_IMG_FMT_I44416 ? ""C444p10<S2SV_blank>XYSCSS=444P10\\n"" : fmt == VPX_IMG_FMT_I42216 ? ""C422p10<S2SV_blank>XYSCSS=422P10\\n"" : ""C420p10<S2SV_blank>XYSCSS=420P10\\n"" ; break ; case 12 : color = fmt == VPX_IMG_FMT_I44416 ? ""C444p12<S2SV_blank>XYSCSS=444P12\\n"" : fmt == VPX_IMG_FMT_I42216 ? ""C422p12<S2SV_blank>XYSCSS=422P12\\n"" : ""C420p12<S2SV_blank>XYSCSS=420P12\\n"" ; break ; case 14 : color = fmt == VPX_IMG_FMT_I44416 ? ""C444p14<S2SV_blank>XYSCSS=444P14\\n"" : fmt == VPX_IMG_FMT_I42216 ? ""C422p14<S2SV_blank>XYSCSS=422P14\\n"" : ""C420p14<S2SV_blank>XYSCSS=420P14\\n"" ; break ; case 16 : color = fmt == VPX_IMG_FMT_I44416 ? ""C444p16<S2SV_blank>XYSCSS=444P16\\n"" : fmt == VPX_IMG_FMT_I42216 ? ""C422p16<S2SV_blank>XYSCSS=422P16\\n"" : ""C420p16<S2SV_blank>XYSCSS=420P16\\n"" ; break ; default : color = NULL ; assert ( 0 ) ; } "
2553,<S2SV_StartBug> const VP9_CONFIG * oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> const int max_rate = rc -> av_per_frame_bandwidth * <S2SV_EndBug> ,<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> 
2554,"<S2SV_StartBug> if ( nad_find_attr ( nad , 0 , - 1 , ""type"" , ""valid"" ) >= 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> && xhash_get ( out -> states , rkey ) == ( void * ) conn_INPROGRESS "
2555,<S2SV_StartBug> if ( flags & __GFP_ZERO ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2556,<S2SV_StartBug> static SvcInternal * get_svc_internal ( SvcContext * svc_ctx ) { <S2SV_EndBug> <S2SV_StartBug> SvcInternal * const si = ( SvcInternal * ) malloc ( sizeof ( * si ) ) ; <S2SV_EndBug> <S2SV_StartBug> return ( SvcInternal * ) svc_ctx -> internal ; <S2SV_EndBug> ,<S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> <S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> <S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> <S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> 
2557,"<S2SV_StartBug> baswap ( ( void * ) dst , & l2cap_pi ( sock -> sk ) -> chan -> dst ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! l2cap_is_socket ( sock ) ) return - EBADFD ; 
2558,"<S2SV_StartBug> jsWarn ( ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> { jsExceptionHere ( JSET_ERROR , <S2SV_ModEnd> <S2SV_ModStart> return 0 ; } if ( gfx . data . height & 7 ) { jsExceptionHere ( JSET_ERROR , ""height<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8<S2SV_blank>when<S2SV_blank>using<S2SV_blank>vertical_byte\\n"" ) ; return 0 ; } "
2559,"<S2SV_StartBug> vp9_prob oldp , vp9_prob * bestp , <S2SV_EndBug> <S2SV_StartBug> vp9_prob upd ) { <S2SV_EndBug> <S2SV_StartBug> vp9_prob newp , bestnewp = oldp ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_prob oldp , vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> "
2560,<S2SV_StartBug> if ( x & ( 1 << i ) ) return i ; <S2SV_EndBug> ,<S2SV_ModStart> 1U << ( unsigned int ) <S2SV_ModEnd> 
2561,"<S2SV_StartBug> if ( secure_decrypt ( data , sizeof ( * header ) , 0 ) ) <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return secure_decrypt ( file , header -> file_size , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int ret = - 1 ; <S2SV_ModStart> goto secure_wipe_keys <S2SV_ModEnd> <S2SV_ModStart> goto secure_wipe_keys <S2SV_ModEnd> <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> secure_wipe_keys : wipe_keys ( ) ; return ret ; 
2562,<S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> <S2SV_StartBug> if ( ! signal_pending ( current ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> <S2SV_StartBug> out_put_key : <S2SV_EndBug> ,<S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2563,<S2SV_StartBug> u16 offset = sizeof ( struct ipv6hdr ) ; <S2SV_EndBug> <S2SV_StartBug> while ( offset + 1 <= packet_len ) { <S2SV_EndBug> <S2SV_StartBug> switch ( * * nexthdr ) { <S2SV_EndBug> <S2SV_StartBug> offset += ipv6_optlen ( exthdr ) ; <S2SV_EndBug> <S2SV_StartBug> exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> struct ipv6_opt_hdr * exthdr ; <S2SV_ModStart> if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <S2SV_ModStart> } return - EINVAL <S2SV_ModEnd> 
2564,"<S2SV_StartBug> mm_segment_t old_fs ; <S2SV_EndBug> <S2SV_StartBug> ret = sys_wait4 ( pid , ustatus , options , ( struct rusage __user * ) & r ) ; <S2SV_EndBug> <S2SV_StartBug> err |= __put_user ( r . ru_utime . tv_sec , & ur -> ru_utime . tv_sec ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned int status = 0 ; <S2SV_ModStart> ( unsigned int __user * ) & status <S2SV_ModEnd> <S2SV_ModStart> put_user ( status , ustatus ) ; err |= "
2565,"<S2SV_StartBug> int get_vp9_frame_buffer ( void * cb_priv , size_t min_size , <S2SV_EndBug> <S2SV_StartBug> ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) malloc ( min_size ) ; <S2SV_EndBug> ","<S2SV_ModStart> static <S2SV_ModStart> calloc ( min_size , sizeof ( uint8_t ) <S2SV_ModEnd> "
2566,"<S2SV_StartBug> SkipRGBMipmaps ( image , dds_info , 4 ) ; <S2SV_EndBug> ","<S2SV_ModStart> return ( <S2SV_ModStart> , exception ) ) <S2SV_ModEnd> "
2567,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( s == 0 ) return ( ( void * ) NULL ) ; 
2568,<S2SV_StartBug> & dec_tables ) ; <S2SV_EndBug> <S2SV_StartBug> & dec_tables ) ; <S2SV_EndBug> ,<S2SV_ModStart> dec_tables . T <S2SV_ModEnd> <S2SV_ModStart> dec_tables . T <S2SV_ModEnd> 
2569,<S2SV_StartBug> if ( ret < 0 ) <S2SV_EndBug> ,<S2SV_ModStart> && ! p -> skip_release_on_error 
2570,"<S2SV_StartBug> Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; return ; } if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) { Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".cfg\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" "
2571,<S2SV_StartBug> if ( ! ( skb -> dev -> flags & IFF_LOOPBACK ) ) { <S2SV_EndBug> ,<S2SV_ModStart> skb == NULL || 
2572,"<S2SV_StartBug> height , <S2SV_EndBug> <S2SV_StartBug> if ( bytes_per_line == 0 ) <S2SV_EndBug> <S2SV_StartBug> bytes_per_line = image -> columns ; <S2SV_EndBug> <S2SV_StartBug> length = image -> rows * ( image -> columns + image -> columns % 2 ) ; <S2SV_EndBug> <S2SV_StartBug> SetPixelIndex ( image , * p ++ , q ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( image -> columns % 2 ) != 0 ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , <S2SV_ModEnd> <S2SV_ModStart> , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) <S2SV_ModEnd> <S2SV_ModStart> ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( <S2SV_ModEnd> <S2SV_ModStart> != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns <S2SV_ModEnd> <S2SV_ModStart> if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } <S2SV_ModStart>  <S2SV_ModEnd> "
2573,<S2SV_StartBug> if ( L_ICANON ( tty ) ) <S2SV_EndBug> ,<S2SV_ModStart> && ! L_EXTPROC ( tty ) 
2574,"<S2SV_StartBug> slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , ""at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>required<S2SV_blank>attribute<S2SV_blank>has<S2SV_blank>been<S2SV_blank>moved<S2SV_blank>to<S2SV_blank>the<S2SV_blank>BDB<S2SV_blank>scecific<S2SV_blank>configuration<S2SV_blank>entry"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> SLAPI_RESULT_TEXT <S2SV_ModEnd> 
2575,<S2SV_StartBug> ipc_lock_object ( & shp -> shm_perm ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( shp -> shm_file == NULL ) { ipc_unlock_object ( & shp -> shm_perm ) ; err = - EIDRM ; goto out_unlock ; } 
2576,"<S2SV_StartBug> af -> from_addr_param ( & addr , addr_param , <S2SV_EndBug> ",<S2SV_ModStart> if ( af == NULL ) break ; 
2577,"<S2SV_StartBug> ih264d_create_op_t * ps_create_op ; <S2SV_EndBug> <S2SV_StartBug> WORD32 ret ; <S2SV_EndBug> <S2SV_StartBug> ret = ih264d_allocate_static_bufs ( & dec_hdl , pv_api_ip , pv_api_op ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( IV_FAIL == ret ) && ( NULL != dec_hdl ) ) <S2SV_EndBug> <S2SV_StartBug> ih264d_free_static_bufs ( dec_hdl ) ; <S2SV_EndBug> ","<S2SV_ModStart> ih264d_create_ip_t * ps_create_ip ; <S2SV_ModStart> ; ps_create_ip = ( ih264d_create_ip_t * ) pv_api_ip <S2SV_ModStart> dec_hdl = NULL ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { if ( dec_hdl ) { if ( dec_hdl -> pv_codec_handle <S2SV_ModEnd> <S2SV_ModStart> } else { void ( * pf_aligned_free ) ( void * pv_mem_ctxt , void * pv_buf ) ; void * pv_mem_ctxt ; pf_aligned_free = ps_create_ip -> s_ivd_create_ip_t . pf_aligned_free ; pv_mem_ctxt = ps_create_ip -> s_ivd_create_ip_t . pv_mem_ctxt ; pf_aligned_free ( pv_mem_ctxt , dec_hdl ) ; } } "
2578,<S2SV_StartBug> ip6_rt_put ( rt ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! ( arg -> flags & FIB_LOOKUP_NOREF ) ) 
2579,<S2SV_StartBug> if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) { <S2SV_EndBug> <S2SV_StartBug> return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ; <S2SV_EndBug> <S2SV_StartBug> return sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; <S2SV_EndBug> ,"<S2SV_ModStart> struct scatterlist * sgp = & rm -> data . op_sg [ sg ] ; int ret = sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; <S2SV_ModStart> ret = min_t ( int , ret , sgp -> length - conn -> c_xmit_data_off ) ; goto out <S2SV_ModEnd> <S2SV_ModStart> out : return ret <S2SV_ModEnd> "
2580,<S2SV_StartBug> arg_allow_debuggers = 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> struct utsname u ; int rv = uname ( & u ) ; if ( rv != 0 ) errExit ( ""uname"" ) ; int major ; int minor ; if ( 2 != sscanf ( u . release , ""%d.%d"" , & major , & minor ) ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>extract<S2SV_blank>Linux<S2SV_blank>kernel<S2SV_blank>version:<S2SV_blank>%s\\n"" , u . version ) ; exit ( 1 ) ; } if ( major < 4 || ( major == 4 && minor < 8 ) ) { fprintf ( stderr , ""Error:<S2SV_blank>--allow-debuggers<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>on<S2SV_blank>Linux<S2SV_blank>kernels<S2SV_blank>prior<S2SV_blank>to<S2SV_blank>4.8.<S2SV_blank>"" ""A<S2SV_blank>bug<S2SV_blank>in<S2SV_blank>ptrace<S2SV_blank>call<S2SV_blank>allows<S2SV_blank>a<S2SV_blank>full<S2SV_blank>bypass<S2SV_blank>of<S2SV_blank>the<S2SV_blank>seccomp<S2SV_blank>filter.<S2SV_blank>"" ""Your<S2SV_blank>current<S2SV_blank>kernel<S2SV_blank>version<S2SV_blank>is<S2SV_blank>%d.%d.\\n"" , major , minor ) ; exit ( 1 ) ; } "
2581,<S2SV_StartBug> } else <S2SV_EndBug> ,"<S2SV_ModStart> else if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) && ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( dir , CAP_FSETID ) ) mode &= ~ S_ISGID ; "
2582,<S2SV_StartBug> if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) <S2SV_EndBug> ,"<S2SV_ModStart> unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ; if ( "
2583,<S2SV_StartBug> long newpos ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> 
2584,"<S2SV_StartBug> uint16_t hmi_bpm = 0 ; <S2SV_EndBug> <S2SV_StartBug> } * note ; <S2SV_EndBug> <S2SV_StartBug> if ( hmi_data [ 0 ] == 0xfe ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( hmi_data [ 1 ] == 0x15 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , hmi_running_event [ i ] ) ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> note [ hmi_tmp ] . length = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( * hmi_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> } while ( * hmi_data > 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> hmi_data ++ ; <S2SV_EndBug> ","<S2SV_ModStart> uint32_t data_siz ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> hmi_track_offset [ i ] >= hmi_size ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } data_siz = hmi_size - hmi_track_offset [ i ] ; if ( <S2SV_ModStart> hmi_tmp += 4 ; <S2SV_ModStart> hmi_tmp = 8 ; } else { hmi_tmp = 4 ; } hmi_data <S2SV_ModEnd> <S2SV_ModStart> hmi_track_offset [ i ] += 4 ; if ( hmi_tmp > data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } data_siz -= hmi_tmp ; <S2SV_ModStart> , data_siz <S2SV_ModStart> data_siz -= setup_ret ; <S2SV_ModStart> data_siz && <S2SV_ModStart> if ( ! data_siz ) break ; <S2SV_ModStart> data_siz -- ; <S2SV_ModStart> ; } if ( ! data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end <S2SV_ModStart> data_siz -- ; <S2SV_ModStart> data_siz -= setup_ret ; } } if ( data_siz && <S2SV_ModEnd> <S2SV_ModStart> if ( ! data_siz ) break ; <S2SV_ModStart> data_siz -- ; <S2SV_ModStart> if ( ! data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } <S2SV_ModStart> ; data_siz -- "
2585,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>title<S2SV_blank>\'%s\'"" , gplot -> title ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>xlabel<S2SV_blank>\'%s\'"" , gplot -> xlabel ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>ylabel<S2SV_blank>\'%s\'"" , gplot -> ylabel ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>x"" ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>y"" ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s"" , <S2SV_EndBug> ",<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> 
2586,<S2SV_StartBug> struct rt6_info * rt = ( struct rt6_info * ) dst ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( dst -> ops -> family != AF_INET6 ) { dst_release ( dst ) ; return NULL ; } rt = ( struct rt6_info * ) dst 
2587,"<S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> ea_bdebug ( bh , ""modifying<S2SV_blank>in-place"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> <S2SV_StartBug> int offset ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> __u32 hash = le32_to_cpu ( header -> h_hash ) ; <S2SV_ModStart> mb2_cache_entry_delete_block ( EXT2_SB ( sb ) -> s_mb_cache , hash , bh -> b_blocknr <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2588,"<S2SV_StartBug> u8 ip_proto = 0 ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return true ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> key_basic -> n_proto = proto ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> key_basic -> n_proto = proto ; <S2SV_EndBug> <S2SV_StartBug> if ( skb_flow_dissector_uses_key ( flow_dissector , <S2SV_EndBug> ","<S2SV_ModStart> ; bool ret = false <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_good <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_good ; } goto out_good <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_PORTS ) ) { key_ports = skb_flow_dissector_target ( flow_dissector , FLOW_DISSECTOR_KEY_PORTS , target_container ) ; key_ports -> ports = __skb_flow_get_ports ( skb , nhoff , ip_proto , data , hlen ) ; } out_good : ret = true ; out_bad : <S2SV_ModStart> return ret <S2SV_ModEnd> "
2589,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> 
2590,"<S2SV_StartBug> VP8Frame * av_uninit ( curframe ) , * prev_frame ; <S2SV_EndBug> ",<S2SV_ModStart> ; av_assert0 ( avctx -> pix_fmt == AV_PIX_FMT_YUVA420P || avctx -> pix_fmt == AV_PIX_FMT_YUV420P ) 
2591,"<S2SV_StartBug> show ( obj , base , name , cb_data ) ; <S2SV_EndBug> ","<S2SV_ModStart> strbuf_addstr ( base , name ) ; <S2SV_ModStart> -> buf , cb_data <S2SV_ModEnd> "
2592,"<S2SV_StartBug> int64_t off = s -> off ; <S2SV_EndBug> <S2SV_StartBug> ""Range:<S2SV_blank>bytes=%"" PRId64 ""-"" , s -> off ) ; <S2SV_EndBug> <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> ",<S2SV_ModStart> uint64_t <S2SV_ModEnd> <S2SV_ModStart> PRIu64 <S2SV_ModEnd> <S2SV_ModStart> UINT64_MAX <S2SV_ModEnd> 
2593,"<S2SV_StartBug> number_planes , <S2SV_EndBug> <S2SV_StartBug> if ( ( number_pixels * number_planes ) != ( size_t ) ( number_pixels * number_planes ) ) <S2SV_EndBug> <S2SV_StartBug> pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes , 4 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , number_planes_filled <S2SV_ModStart> number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; <S2SV_ModStart> number_planes_filled <S2SV_ModEnd> <S2SV_ModStart> number_planes_filled <S2SV_ModEnd> <S2SV_ModStart> number_planes_filled <S2SV_ModEnd> "
2594,"<S2SV_StartBug> uint32 rows , uint32 cols , int outskew , int inskew ) <S2SV_EndBug> ",<S2SV_ModStart> int64 <S2SV_ModEnd> 
2595,"<S2SV_StartBug> if ( pos + 8 > len ) { <S2SV_EndBug> <S2SV_StartBug> int min_val = ( ut32 ) ( UINT ( data , pos + 4 ) ) , <S2SV_EndBug> ",<S2SV_ModStart> + 8 <S2SV_ModStart> const <S2SV_ModStart> ; const int <S2SV_ModEnd> 
2596,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p + 2 ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2597,<S2SV_StartBug> interface = intf -> cur_altsetting ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( interface -> desc . bNumEndpoints < 1 ) return - EINVAL 
2598,<S2SV_StartBug> const char * bufptr ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( cnt < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_write"" ) ; } "
2599,"<S2SV_StartBug> static void update_read_synchronize ( rdpUpdate * update , wStream * s ) <S2SV_EndBug> <S2SV_StartBug> Stream_Seek_UINT16 ( s ) ; <S2SV_EndBug> ","<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> return Stream_SafeSeek ( s , 2 <S2SV_ModEnd> "
2600,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , icmp6_tstr <S2SV_ModEnd> "
2601,<S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2602,<S2SV_StartBug> uchar buf [ JPG_MAGICLEN ] ; <S2SV_EndBug> ,<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
2603,<S2SV_StartBug> ps_dec -> pf_vld_inv_quant = impeg2d_vld_inv_quant_mpeg1 ; <S2SV_EndBug> ,<S2SV_ModStart> u2_forw_f_code = 7 ; ps_dec -> u2_back_f_code = 7 ; ps_dec -> 
2604,"<S2SV_StartBug> memcpy ( vs_param_set -> ie , priv -> vs_ie [ id ] . ie , <S2SV_EndBug> ","<S2SV_ModStart> if ( le16_to_cpu ( vs_param_set -> header . len ) > MWIFIEX_MAX_VSIE_LEN ) { mwifiex_dbg ( priv -> adapter , ERROR , ""Invalid<S2SV_blank>param<S2SV_blank>length!\\n"" ) ; break ; } "
2605,"<S2SV_StartBug> static int match ( Reinst * pc , const char * sp , const char * bol , int flags , Resub * out ) <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( match ( pc -> x , sp , bol , flags , & scratch ) ) { <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! match ( pc -> x , sp , bol , flags , out ) ) <S2SV_EndBug> <S2SV_StartBug> if ( match ( pc -> x , sp , bol , flags , & scratch ) ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> , int depth <S2SV_ModStart> result ; int <S2SV_ModStart> if ( depth > MAXREC ) return - 1 ; <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> result = <S2SV_ModEnd> <S2SV_ModStart> , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 0 <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> result = <S2SV_ModEnd> <S2SV_ModStart> , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 1 ) return 1 <S2SV_ModEnd> <S2SV_ModStart> result = <S2SV_ModEnd> <S2SV_ModStart> , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 0 ) return 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> "
2606,<S2SV_StartBug> m -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2607,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
2608,"<S2SV_StartBug> _ ( ""_Launch<S2SV_blank>Anyway"" ) , RESPONSE_RUN ) ; <S2SV_EndBug> <S2SV_StartBug> _ ( ""Mark<S2SV_blank>as<S2SV_blank>_Trusted"" ) , RESPONSE_MARK_TRUSTED ) ; <S2SV_EndBug> <S2SV_StartBug> gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , <S2SV_EndBug> ","<S2SV_ModStart> ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL <S2SV_ModEnd> <S2SV_ModStart> ""Trust<S2SV_blank>and<S2SV_blank>_Launch"" ) , GTK_RESPONSE_OK <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2609,<S2SV_StartBug> size_t size = ( alignment - MALLOC_ALIGNMENT ) + bytes ; <S2SV_EndBug> ,<S2SV_ModStart> if ( size < bytes ) { return NULL ; } 
2610,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> hook_del_nick_can_register ( check_registration_keywords ) ; hook_del_user_can_register ( check_registration_keywords ) ; del_conf_item ( ""ANOPE_FLAGS_COMPAT"" , & chansvs . me -> conf_table ) ; "
2611,"<S2SV_StartBug> skb -> ip_summed = CHECKSUM_PARTIAL ; <S2SV_EndBug> <S2SV_StartBug> __skb_queue_tail ( queue , skb ) ; <S2SV_EndBug> ","<S2SV_ModStart> csum = 0 ; __skb_queue_tail ( queue , skb ) ; } else if ( skb_is_gso ( skb ) ) { goto append ; } skb -> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> append : <S2SV_ModEnd> "
2612,<S2SV_StartBug> r = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2613,"<S2SV_StartBug> FIRSTPASS_STATS this_frame ; <S2SV_EndBug> <S2SV_StartBug> const int is_spatial_svc = ( svc -> number_spatial_layers > 1 ) && <S2SV_EndBug> <S2SV_StartBug> ( svc -> number_temporal_layers == 1 ) ; <S2SV_EndBug> <S2SV_StartBug> double frame_rate ; <S2SV_EndBug> <S2SV_StartBug> twopass = & svc -> layer_context [ svc -> spatial_layer_id ] . twopass ; <S2SV_EndBug> <S2SV_StartBug> twopass -> total_stats = * twopass -> stats_in_end ; <S2SV_EndBug> <S2SV_StartBug> twopass -> total_left_stats = twopass -> total_stats ; <S2SV_EndBug> <S2SV_StartBug> frame_rate = 10000000.0 * twopass -> total_stats . count / <S2SV_EndBug> <S2SV_StartBug> if ( is_spatial_svc ) { <S2SV_EndBug> <S2SV_StartBug> ( int64_t ) ( twopass -> total_stats . duration * <S2SV_EndBug> <S2SV_StartBug> twopass -> bits_left = ( int64_t ) ( twopass -> total_stats . duration * <S2SV_EndBug> <S2SV_StartBug> cpi -> output_framerate = oxcf -> framerate ; <S2SV_EndBug> <S2SV_StartBug> double sum_iiratio = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> start_pos = twopass -> stats_in ; <S2SV_EndBug> <S2SV_StartBug> while ( input_stats ( twopass , & this_frame ) != EOF ) { <S2SV_EndBug> <S2SV_StartBug> calculate_modified_err ( cpi , & this_frame ) ; <S2SV_EndBug> <S2SV_StartBug> twopass -> modified_error_left = twopass -> modified_error_total ; <S2SV_EndBug> ","<S2SV_ModStart> const VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> is_two_pass_svc <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> > <S2SV_ModEnd> <S2SV_ModStart> TWO_PASS * const twopass = is_two_pass_svc ? <S2SV_ModEnd> <S2SV_ModStart> : & cpi -> twopass ; double frame_rate ; FIRSTPASS_STATS * stats ; <S2SV_ModEnd> <S2SV_ModStart> stats = & <S2SV_ModStart> ; * stats <S2SV_ModStart> * stats <S2SV_ModEnd> <S2SV_ModStart> stats -> count / stats -> <S2SV_ModEnd> <S2SV_ModStart> is_two_pass_svc <S2SV_ModEnd> <S2SV_ModStart> stats -> <S2SV_ModEnd> <S2SV_ModStart> stats -> <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const double avg_error = stats -> coded_error / DOUBLE_DIVIDE_CHECK ( stats -> count ) ; const FIRSTPASS_STATS * s = twopass -> stats_in ; double modified_error_total <S2SV_ModEnd> <S2SV_ModStart> twopass -> modified_error_min = ( avg_error * oxcf -> two_pass_vbrmin_section ) / 100 ; twopass -> modified_error_max = ( avg_error * oxcf -> two_pass_vbrmax_section ) / 100 <S2SV_ModEnd> <S2SV_ModStart> s < twopass -> stats_in_end ) { <S2SV_ModEnd> <S2SV_ModStart> twopass , oxcf , s ) ; ++ s <S2SV_ModEnd> <S2SV_ModStart> modified_error_total ; } cpi -> rc . vbr_bits_off_target = 0 ; cpi -> rc . vbr_bits_off_target_fast = 0 ; cpi -> rc . rate_error_estimate = 0 ; twopass -> kf_zeromotion_pct = 100 ; twopass -> last_kfgroup_zeromotion_pct = 100 ; if ( oxcf -> resize_mode != RESIZE_NONE ) { vp9_init_subsampling ( cpi <S2SV_ModEnd> "
2614,<S2SV_StartBug> int overflow_error = 0 ; <S2SV_EndBug> <S2SV_StartBug> res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( u = 0 ; u < line_length ; u ++ ) { <S2SV_EndBug> <S2SV_StartBug> res -> ContribRow [ u ] . Weights = ( double * ) gdMalloc ( windows_size * sizeof ( double ) ) ; <S2SV_EndBug> <S2SV_StartBug> u -- ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i <= u ; i ++ ) { <S2SV_EndBug> ,"<S2SV_ModStart> size_t weights_size ; if ( overflow2 ( windows_size , sizeof ( double ) ) ) { return NULL ; } else { weights_size = windows_size * sizeof ( double ) ; } res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ; if ( ! res ) { return NULL ; } res -> WindowSize = windows_size ; res -> LineLength = line_length ; if ( overflow2 ( line_length , sizeof ( ContributionType ) ) ) { gdFree ( res ) ; return NULL ; } res -> ContribRow = ( ContributionType * ) gdMalloc ( line_length * sizeof ( ContributionType ) ) ; if ( res -> ContribRow == NULL ) { gdFree ( res ) ; return NULL ; } for ( u <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> weights_size ) ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> < <S2SV_ModEnd> "
2615,"<S2SV_StartBug> Stream_Read_UINT16 ( s , <S2SV_EndBug> ",<S2SV_ModStart> if ( Stream_GetRemainingLength ( s ) < 8 ) return FALSE ; 
2616,<S2SV_StartBug> struct siginfo info ; <S2SV_EndBug> ,<S2SV_ModStart> = { } 
2617,"<S2SV_StartBug> DRM_DEBUG ( ""clip<S2SV_blank>rectangles<S2SV_blank>are<S2SV_blank>only<S2SV_blank>valid<S2SV_blank>with<S2SV_blank>the<S2SV_blank>render<S2SV_blank>ring\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; return - EINVAL ; } if ( args -> num_cliprects > UINT_MAX / sizeof ( * cliprects ) ) { DRM_DEBUG ( ""execbuf<S2SV_blank>with<S2SV_blank>%u<S2SV_blank>cliprects\\n"" , args -> num_cliprects "
2618,"<S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_lineno ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_lineno ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_int ( tmp , & lineno , arena ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_op ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_op ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( values , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_left ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_left ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( tmp , & left , arena ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_op ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_op ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_args ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_args ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_test ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_test ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( tmp , & test , arena ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( keys , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( values , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( elts , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_elt ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_elt ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> comprehension_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( generators , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_elt ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_elt ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> comprehension_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( generators , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_key ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_key ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( tmp , & key , arena ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> comprehension_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( generators , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_elt ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_elt ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> comprehension_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( generators , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_left ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_left ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> cmpop_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_cmpop ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( ops , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( comparators , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_func ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_func ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( args , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> keyword_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_keyword ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( keywords , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_n ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_n ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_s ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_s ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( tmp , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( values , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_s ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_s ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_attr ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_slice ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_id ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_id ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_elts ) ) { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( elts , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_ctx ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_elts ) ) { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( elts , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""elts\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Tuple"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>expr"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_int ( tmp , & lineno , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""col_offset\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>expr"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> col_offset <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""op\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BoolOp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_boolop ( tmp , & op , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_values , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""values\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BoolOp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""left\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BinOp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & left , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_op , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""op\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BinOp"" ) ; return 1 ; } else { int res ; res = obj2ast_operator ( tmp , & op , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_right , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""right\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BinOp"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> right <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""op\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>UnaryOp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_unaryop ( tmp , & op , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_operand , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""operand\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>UnaryOp"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & operand <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Lambda"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_arguments ( tmp , & args , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Lambda"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & body <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""test\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>IfExp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>IfExp"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> body , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>IfExp"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & orelse , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = IfExp ( test , body , orelse , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Dict_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * keys ; asdl_seq * values ; if ( lookup_attr_id ( obj , & PyId_keys , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""keys\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Dict"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_values , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""values\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Dict"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> * out = Dict ( keys , values , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Set_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * elts ; if ( lookup_attr_id ( obj , & PyId_elts , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""elts\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Set"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""elt\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ListComp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & elt , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_generators , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""generators\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ListComp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""elt\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>SetComp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & elt , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_generators , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""generators\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>SetComp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""key\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>DictComp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & key , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>DictComp"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> value <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_generators , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""generators\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>DictComp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""elt\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>GeneratorExp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & elt , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_generators , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""generators\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>GeneratorExp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Await"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; value = NULL ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>YieldFrom"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""left\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Compare"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & left , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_ops , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ops\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Compare"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_comparators , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""comparators\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Compare"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""func\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Call"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & func , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_args , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Call"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_keywords , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""keywords\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Call"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""n\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Num"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""s\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Str"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FormattedValue"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_conversion , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; conversion = 0 ; } else { int res ; res = obj2ast_int ( tmp , & conversion , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_format_spec , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; format_spec = NULL ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> format_spec , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = FormattedValue ( value , conversion , format_spec , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) JoinedStr_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * values ; if ( lookup_attr_id ( obj , & PyId_values , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""values\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>JoinedStr"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""s\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Bytes"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>NameConstant"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Constant"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Attribute"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_attr , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""attr\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Attribute"" ) ; return 1 ; } else { int res ; res = obj2ast_identifier ( tmp , & attr <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_ctx , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ctx\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Attribute"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr_context ( tmp , & ctx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Subscript"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_slice , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""slice\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Subscript"" ) ; return 1 ; } else { int res ; res = obj2ast_slice ( tmp , & slice <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_ctx , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ctx\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Subscript"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr_context ( tmp , & ctx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Starred"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_ctx , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ctx\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Starred"" ) ; return 1 ; } else { int res ; res = obj2ast_expr_context ( tmp , & ctx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""id\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Name"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_identifier ( tmp , & id , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_ctx , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ctx\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Name"" ) ; return 1 ; } else { int res ; res = obj2ast_expr_context ( tmp , & ctx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""elts\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>List"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_ctx , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ctx\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>List"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""elts\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Tuple"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_ctx , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ctx\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Tuple"" ) ; return 1 ; } else { int res ; res = obj2ast_expr_context ( tmp , & ctx , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Tuple ( elts , ctx , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <S2SV_ModEnd> <S2SV_ModStart> ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>expr,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj <S2SV_ModEnd> "
2619,"<S2SV_StartBug> parse_field ( netdissect_options * ndo , const char * * pptr , int * len ) <S2SV_EndBug> <S2SV_StartBug> if ( * len <= 0 || ! pptr || ! * pptr ) <S2SV_EndBug> <S2SV_StartBug> while ( * pptr <= ( const char * ) ndo -> ndo_snapend && * len >= 0 && * * pptr ) { <S2SV_EndBug> <S2SV_StartBug> if ( * len < 0 || * pptr > ( const char * ) ndo -> ndo_snapend ) <S2SV_EndBug> ","<S2SV_ModStart> , int * truncated <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> for ( ; ; ) { if ( * len == 0 ) { return NULL ; } if ( ! ND_TTEST ( <S2SV_ModEnd> <S2SV_ModStart> ) { * truncated = 1 ; return NULL ; } if ( * * pptr == '\\0' ) { break ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2620,<S2SV_StartBug> if ( ! ( assigned_dev -> flags & KVM_DEV_ASSIGN_ENABLE_IOMMU ) ) <S2SV_EndBug> <S2SV_StartBug> if ( pci_enable_device ( dev ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> u8 header_type ; <S2SV_ModStart> pci_read_config_byte ( dev , PCI_HEADER_TYPE , & header_type ) ; if ( ( header_type & PCI_HEADER_TYPE ) != PCI_HEADER_TYPE_NORMAL ) { r = - EPERM ; goto out_put ; } r = probe_sysfs_permissions ( dev ) ; if ( r ) goto out_put ; "
2621,<S2SV_StartBug> flush_rq -> mq_ctx = first_rq -> mq_ctx ; <S2SV_EndBug> <S2SV_StartBug> flush_rq -> tag = first_rq -> tag ; <S2SV_EndBug> ,"<S2SV_ModStart> struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> ; fq -> orig_rq = first_rq ; hctx = q -> mq_ops -> map_queue ( q , first_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , first_rq -> tag , flush_rq ) "
2622,<S2SV_StartBug> struct kvm_lapic * apic = vcpu -> arch . apic ; <S2SV_EndBug> <S2SV_StartBug> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> kvm_write_guest_cached ( vcpu -> kvm , & <S2SV_ModEnd> <S2SV_ModStart> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> "
2623,"<S2SV_StartBug> dtls1_process_buffered_records ( s ) ; <S2SV_EndBug> <S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( <S2SV_ModStart> < 0 ) return - 1 <S2SV_ModStart> if ( <S2SV_ModStart> ) < 0 ) return - 1 ; dtls1_record_bitmap_update ( s , bitmap <S2SV_ModStart> dtls1_record_bitmap_update ( s , bitmap ) ; "
2624,<S2SV_StartBug> if ( ctx -> img_avail ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( * iter ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> frame_parallel_decode && ctx -> available_threads > 0 && ! ctx -> flushed ) { return NULL ; } if ( ctx -> num_cache_frames > 0 ) { release_last_output_frame ( ctx ) ; ctx -> last_show_frame = ctx -> frame_cache [ ctx -> frame_cache_read ] . fb_idx ; if ( ctx -> need_resync ) return NULL ; img = & ctx -> frame_cache [ ctx -> frame_cache_read ] . img ; ctx -> frame_cache_read = ( ctx -> frame_cache_read + 1 ) % FRAME_CACHE_SIZE ; -- ctx -> num_cache_frames ; return img ; } if <S2SV_ModEnd> <S2SV_ModStart> == NULL && ctx -> frame_workers != NULL ) { do { YV12_BUFFER_CONFIG sd ; vp9_ppflags_t flags = { 0 , 0 , 0 } ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; VPxWorker * const worker = & ctx -> frame_workers [ ctx -> next_output_worker_id ] ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; ctx -> next_output_worker_id = ( ctx -> next_output_worker_id + 1 ) % ctx -> num_frame_workers ; if ( ctx -> base . init_flags & VPX_CODEC_USE_POSTPROC ) set_ppflags ( ctx , & flags ) ; if ( winterface -> sync ( worker ) ) { if ( frame_worker_data -> received_frame == 1 ) { ++ ctx -> available_threads ; frame_worker_data -> received_frame = 0 ; check_resync ( ctx , frame_worker_data -> pbi ) ; } if ( vp9_get_raw_frame ( frame_worker_data -> pbi , & sd , & flags ) == 0 ) { VP9_COMMON * const cm = & frame_worker_data -> pbi -> common ; RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs ; release_last_output_frame ( ctx ) ; ctx -> last_show_frame = frame_worker_data -> pbi -> common . new_fb_idx ; if ( ctx -> need_resync ) return NULL ; yuvconfig2image ( & ctx -> img , & sd , frame_worker_data -> user_priv ) ; ctx -> img . fb_priv = frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer . priv ; img = & ctx -> img ; return img ; } } else { frame_worker_data -> received_frame = 0 ; ++ ctx -> available_threads ; ctx -> need_resync = 1 ; if ( ctx -> flushed != 1 ) return NULL ; } } while ( ctx -> next_output_worker_id != ctx -> next_submit_worker_id ) ; } return NULL <S2SV_ModEnd> "
2625,"<S2SV_StartBug> . match_data . cmp = type -> match , <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> ",<S2SV_ModStart> key_default_cmp <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2626,<S2SV_StartBug> pairs = palloc ( count * sizeof ( Pairs ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ; "
2627,"<S2SV_StartBug> ptr = realloc ( priv -> EF_C_DevAut , len ) ; <S2SV_EndBug> <S2SV_StartBug> priv -> EF_C_DevAut_len = len ; <S2SV_EndBug> ",<S2SV_ModStart> if ( len > 0 ) { <S2SV_ModStart> } 
2628,"<S2SV_StartBug> DBG_ENTER ( ""php_mysqlnd_rowp_read_text_protocol_aux"" ) ; <S2SV_EndBug> <S2SV_StartBug> unsigned long len = php_mysqlnd_net_field_length ( & p ) ; <S2SV_EndBug> ","<S2SV_ModStart> const zend_uchar * const packet_end = ( zend_uchar * ) row_buffer -> ptr + data_size ; <S2SV_ModStart> const <S2SV_ModStart> if ( len != MYSQLND_NULL_LENGTH && ( ( p + len ) > packet_end ) ) { php_error_docref ( NULL , E_WARNING , ""Malformed<S2SV_blank>server<S2SV_blank>packet.<S2SV_blank>Field<S2SV_blank>length<S2SV_blank>pointing<S2SV_blank>"" MYSQLND_SZ_T_SPEC ""<S2SV_blank>bytes<S2SV_blank>after<S2SV_blank>end<S2SV_blank>of<S2SV_blank>packet"" , ( p + len ) - packet_end - 1 ) ; DBG_RETURN ( FAIL ) ; } "
2629,<S2SV_StartBug> return ; <S2SV_EndBug> ,<S2SV_ModStart> 0 
2630,<S2SV_StartBug> kfree ( rm -> atomic . op_notifier ) ; <S2SV_EndBug> ,<S2SV_ModStart> rm -> atomic . op_active = 0 ; 
2631,<S2SV_StartBug> idata -> status = IMAP_FATAL ; <S2SV_EndBug> ,"<S2SV_ModStart> ; return ; } if ( strlen ( idata -> buf ) < litlen ) { mutt_debug ( 1 , ""Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>mailbox\\n"" ) "
2632,"<S2SV_StartBug> l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ; <S2SV_EndBug> <S2SV_StartBug> opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ; 
2633,<S2SV_StartBug> return true ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( IS ( req -> method , METHOD_POST ) ) { const char * cookie = get_header ( req , ""Cookie"" ) ; const char * token = get_parameter ( req , ""securitytoken"" ) ; if ( ! cookie ) { LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>missing<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>cookie\\n"" , NVLSTR ( Socket_getRemoteHost ( req -> S ) ) ) ; send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ; return false ; } if ( ! token ) { LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>missing<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>in<S2SV_blank>HTTP<S2SV_blank>parameter\\n"" , NVLSTR ( Socket_getRemoteHost ( req -> S ) ) ) ; send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ; return false ; } if ( ! Str_startsWith ( cookie , ""securitytoken="" ) ) { LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>no<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>in<S2SV_blank>cookie\\n"" , NVLSTR ( Socket_getRemoteHost ( req -> S ) ) ) ; send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ; return false ; } if ( Str_compareConstantTime ( cookie + 14 , token ) ) { LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>mismatch\\n"" , NVLSTR ( Socket_getRemoteHost ( req -> S ) ) ) ; send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ; return false ; } } "
2634,"<S2SV_StartBug> int n = 0 , size = 0 , ret = - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> struct perf_event_context * ctx = leader -> ctx ; <S2SV_EndBug> <S2SV_StartBug> ret = - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> goto unlock ; <S2SV_EndBug> <S2SV_StartBug> unlock : <S2SV_EndBug> ","<S2SV_ModStart> struct perf_event_context * ctx = leader -> ctx ; <S2SV_ModStart> ; u64 count , enabled , running ; u64 values [ 5 ] ; lockdep_assert_held ( & ctx -> mutex ) ; count = perf_event_read_value ( leader , & enabled , & running ) ; values [ n ++ ] = 1 + leader -> nr_siblings ; if ( read_format & PERF_FORMAT_TOTAL_TIME_ENABLED ) values [ n ++ ] = enabled ; if ( read_format & PERF_FORMAT_TOTAL_TIME_RUNNING ) values [ n ++ ] = running ; values [ n ++ ] = count ; if ( read_format & PERF_FORMAT_ID ) values [ n ++ ] = primary_event_id ( leader ) ; size = n * sizeof ( u64 ) ; if ( copy_to_user ( buf , values , size ) ) return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2635,"<S2SV_StartBug> int setpwnam ( struct passwd * pwd ) <S2SV_EndBug> <S2SV_StartBug> char * atomic_dir = ""/etc"" ; <S2SV_EndBug> <S2SV_StartBug> if ( ( fp = xfmkstemp ( & tmpname , atomic_dir ) ) == NULL ) <S2SV_EndBug> ","<S2SV_ModStart> , const char * prefix <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""/etc"" , prefix <S2SV_ModEnd> "
2636,<S2SV_StartBug> PCI_DMA_FROMDEVICE ) ) <S2SV_EndBug> <S2SV_StartBug> buf_pa = MWIFIEX_SKB_DMA_ADDR ( skb ) ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree_skb ( skb ) ; kfree ( card -> evtbd_ring_vbase ) ; <S2SV_ModStart> } 
2637,<S2SV_StartBug> if ( count < sizeof ( cmd . type ) ) { <S2SV_EndBug> ,<S2SV_ModStart> WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if ( 
2638,<S2SV_StartBug> done = EAS_TRUE ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( pWTIntFrame -> numSamples < 0 ) { ALOGE ( ""b/26366256"" ) ; pWTIntFrame -> numSamples = 0 ; } "
2639,<S2SV_StartBug> max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; <S2SV_EndBug> <S2SV_StartBug> max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ; <S2SV_EndBug> ,"<S2SV_ModStart> { if ( CheckMemoryOverflow <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; } else { if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_ModEnd> <S2SV_ModStart> } "
2640,"<S2SV_StartBug> struct strbuf * path , const char * last , <S2SV_EndBug> <S2SV_StartBug> char * name = path_name ( path , last ) ; <S2SV_EndBug> <S2SV_StartBug> free ( ( char * ) name ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2641,<S2SV_StartBug> cdf_secid_t maxsector = ( cdf_secid_t ) ( sat -> sat_len * size ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sid > maxsector ) { <S2SV_EndBug> ,"<S2SV_ModStart> ( <S2SV_ModStart> / sizeof ( maxsector ) ) <S2SV_ModStart> >= maxsector ) { DPRINTF ( ( ""Sector<S2SV_blank>%d<S2SV_blank>>=<S2SV_blank>%d\\n"" <S2SV_ModEnd> "
2642,"<S2SV_StartBug> makewhite ( g , o ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( g -> gckind == KGC_INC ) 
2643,<S2SV_StartBug> if ( ( wp -> path = websNormalizeUriPath ( path ) ) == 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> websValidateUriPath <S2SV_ModEnd> 
2644,<S2SV_StartBug> while ( ibuf [ ind ] == 0x01 ) { <S2SV_EndBug> ,<S2SV_ModStart> && i < gemsafe_cert_max 
2645,<S2SV_StartBug> if ( src_end - src < zsize ) <S2SV_EndBug> <S2SV_StartBug> bitbuf = * src ++ ; <S2SV_EndBug> ,<S2SV_ModStart> + ( sub_type != 2 ) <S2SV_ModStart> if ( src >= src_end ) return AVERROR_INVALIDDATA ; 
2646,<S2SV_StartBug> if ( ! prev_pkt [ channel_id ] . read ) { <S2SV_EndBug> ,"<S2SV_ModStart> prev_pkt [ channel_id ] . read && size != prev_pkt [ channel_id ] . size ) { av_log ( NULL , AV_LOG_ERROR , ""RTMP<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>mismatch<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>%d\\n"" , size , prev_pkt [ channel_id ] . size ) ; ff_rtmp_packet_destroy ( & prev_pkt [ channel_id ] ) ; prev_pkt [ channel_id ] . read = 0 ; } if ( "
2647,<S2SV_StartBug> int nAlloc = pSrc -> nSrc * 2 + nExtra ; <S2SV_EndBug> ,<S2SV_ModStart> sqlite3_int64 nAlloc = 2 * ( sqlite3_int64 ) pSrc -> nSrc <S2SV_ModEnd> 
2648,<S2SV_StartBug> get_page ( * page ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( ! try_get_page ( * page ) ) ) { ret = - ENOMEM ; goto unmap ; } <S2SV_ModEnd> 
2649,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && in -> linesize [ plane ] 
2650,<S2SV_StartBug> len = dp -> ip6r_len ; <S2SV_EndBug> ,<S2SV_ModStart> ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> ip6r_segleft ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
2651,"<S2SV_StartBug> if ( js_regexec ( re -> prog , source , & m , 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! js_regexec ( re -> prog , source , & m , REG_NOTBOL ) ) <S2SV_EndBug> ","<S2SV_ModStart> js_doregexec ( J , <S2SV_ModEnd> <S2SV_ModStart> js_doregexec ( J , <S2SV_ModEnd> "
2652,"<S2SV_StartBug> struct oabi_flock64 user ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( & user , ( struct oabi_flock64 __user * ) arg , <S2SV_EndBug> <S2SV_StartBug> ret = sys_fcntl64 ( fd , cmd , local_arg ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return do_locks ( fd , cmd , arg ) ; default : return <S2SV_ModEnd> <S2SV_ModStart> arg <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2653,<S2SV_StartBug> if ( err ) <S2SV_EndBug> ,<S2SV_ModStart> < 0 
2654,<S2SV_StartBug> if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root > chm -> num_chunks ) { <S2SV_EndBug> <S2SV_StartBug> name = p ; p += name_len ; <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> <S2SV_ModStart> if ( name_len == 0 ) goto chunk_end ; 
2655,<S2SV_StartBug> if ( ! file ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ,<S2SV_ModStart> || count > OE_SSIZE_MAX <S2SV_ModStart> if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } 
2656,"<S2SV_StartBug> memcpy ( res , dbg_data , nb10sz ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2657,"<S2SV_StartBug> if ( istreq ( str , ""all"" ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ! str ) return false ; if ( 
2658,<S2SV_StartBug> conn -> c_trans = trans ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( trans == NULL ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( - ENODEV ) ; goto out ; } "
2659,<S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> msg -> msg_namelen = 0 ; 
2660,<S2SV_StartBug> if ( NCH ( n ) == 1 ) <S2SV_EndBug> <S2SV_StartBug> l = 0 ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 2 ; i < ( NCH ( n ) - 1 ) ; i ++ ) <S2SV_EndBug> ,"<S2SV_ModStart> case func_body_suite : <S2SV_ModStart> i = 2 ; l = 0 ; if ( TYPE ( CHILD ( n , 1 ) ) == TYPE_COMMENT ) i += 2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2661,"<S2SV_StartBug> struct reloc_struct_t * got_table = calloc ( 1 , n_got * sizeof ( ut32 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct reloc_struct_t <S2SV_ModEnd> 
2662,"<S2SV_StartBug> void vp9_loop_filter_rows ( const YV12_BUFFER_CONFIG * frame_buffer , <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_EndBug> <S2SV_StartBug> int mi_row , mi_col ; <S2SV_EndBug> <S2SV_StartBug> int use_420 = y_only || ( xd -> plane [ 1 ] . subsampling_y == 1 && <S2SV_EndBug> <S2SV_StartBug> xd -> plane [ 1 ] . subsampling_x == 1 ) ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + mi_row * cm -> mi_stride ; <S2SV_EndBug> <S2SV_StartBug> vp9_setup_dst_planes ( xd , frame_buffer , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> if ( use_420 ) <S2SV_EndBug> <S2SV_StartBug> vp9_setup_mask ( cm , mi_row , mi_col , mi_8x8 + mi_col , cm -> mi_stride , <S2SV_EndBug> <S2SV_StartBug> for ( plane = 0 ; plane < num_planes ; ++ plane ) { <S2SV_EndBug> <S2SV_StartBug> if ( use_420 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> struct macroblockd_plane planes [ MAX_MB_PLANE ] <S2SV_ModEnd> <S2SV_ModStart> enum lf_path path <S2SV_ModEnd> <S2SV_ModStart> mi_row , mi_col ; if ( y_only ) path = LF_PATH_444 ; else if ( planes <S2SV_ModEnd> <S2SV_ModStart> planes <S2SV_ModEnd> <S2SV_ModStart> path = LF_PATH_420 ; else if ( planes [ 1 ] . subsampling_y == 0 && planes [ 1 ] . subsampling_x == 0 ) path = LF_PATH_444 ; else path = LF_PATH_SLOW <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> planes <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> vp9_filter_block_plane_ss00 ( cm , & planes [ 0 ] , mi_row , & lfm ) ; <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> switch ( path ) { case LF_PATH_420 : vp9_filter_block_plane_ss11 ( cm , & planes [ plane ] , mi_row , & lfm ) ; break ; case LF_PATH_444 : vp9_filter_block_plane_ss00 ( cm , & planes [ plane ] , mi_row , & lfm ) ; break ; case LF_PATH_SLOW : vp9_filter_block_plane_non420 ( cm , & planes [ plane ] , mi <S2SV_ModEnd> <S2SV_ModStart> break ; } "
2663,<S2SV_StartBug> if ( ! ( quirks & CP_RDESC_SWAPPED_MIN_MAX ) ) <S2SV_EndBug> ,<S2SV_ModStart> ) return rdesc ; if ( * rsize < 4 
2664,<S2SV_StartBug> config -> listeners [ config -> listener_count - 1 ] . security_options . password_file = config -> default_listener . security_options . password_file ; <S2SV_EndBug> ,<S2SV_ModStart> acl_file = config -> default_listener . security_options . acl_file ; config -> listeners [ config -> listener_count - 1 ] . security_options . 
2665,<S2SV_StartBug> EXT4_DESC_PER_BLOCK ( sb ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ext4_has_feature_meta_bg ( sb ) ) { if ( le32_to_cpu ( es -> s_first_meta_bg ) >= db_count ) { ext4_msg ( sb , KERN_WARNING , ""first<S2SV_blank>meta<S2SV_blank>block<S2SV_blank>group<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>"" ""(group<S2SV_blank>descriptor<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%u)"" , le32_to_cpu ( es -> s_first_meta_bg ) , db_count ) ; goto failed_mount ; } } "
2666,"<S2SV_StartBug> int j , len = apdu . resp [ i + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( file -> name , d , len ) ; <S2SV_EndBug> <S2SV_StartBug> file -> namelen = len ; <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> file -> namelen = MIN ( sizeof file -> name , len ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> "
2667,"<S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> processed_rcds ) , <S2SV_EndBug> <S2SV_StartBug> s -> s3 -> rrec . seq_num ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( <S2SV_ModStart> < 0 ) return - 1 
2668,"<S2SV_StartBug> if ( ( event -> sigev_notify & SIGEV_THREAD_ID ) && <S2SV_EndBug> <S2SV_StartBug> ( ! ( rtn = find_task_by_vpid ( event -> sigev_notify_thread_id ) ) || <S2SV_EndBug> <S2SV_StartBug> ! same_thread_group ( rtn , current ) || <S2SV_EndBug> <S2SV_StartBug> if ( ( ( event -> sigev_notify & ~ SIGEV_THREAD_ID ) != SIGEV_NONE ) && <S2SV_EndBug> <S2SV_StartBug> ( ( event -> sigev_signo <= 0 ) || ( event -> sigev_signo > SIGRTMAX ) ) ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> switch <S2SV_ModEnd> <S2SV_ModStart> ) { case SIGEV_SIGNAL | SIGEV_THREAD_ID : <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! rtn <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> case SIGEV_SIGNAL : case SIGEV_THREAD : if <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> case SIGEV_NONE : <S2SV_ModStart> default : return NULL ; } 
2669,<S2SV_StartBug> if ( vcpu -> mmio_cur_fragment == vcpu -> mmio_nr_fragments ) { <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> 
2670,"<S2SV_StartBug> r = parse_gid ( e + 1 , & gid ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( e - p > HOST_NAME_MAX - 1 ) goto not_found ; 
2671,<S2SV_StartBug> pch -> file . dead = 1 ; <S2SV_EndBug> ,<S2SV_ModStart> put_net ( pch -> chan_net ) ; pch -> chan_net = NULL ; 
2672,"<S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPAR , 0x40 | address ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPDRL , LSB ( data ) ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPDRH , MSB ( data ) ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS | EPCR_ERPRW ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( dm9000ReadReg ( DM9000_REG_EPCR ) & EPCR_ERRE ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS ) ; <S2SV_EndBug> ","<S2SV_ModStart> DM9000_EPAR <S2SV_ModEnd> <S2SV_ModStart> DM9000_EPDRL <S2SV_ModEnd> <S2SV_ModStart> DM9000_EPDRH <S2SV_ModEnd> <S2SV_ModStart> DM9000_EPCR , DM9000_EPCR_EPOS | DM9000_EPCR_ERPRW <S2SV_ModEnd> <S2SV_ModStart> DM9000_EPCR ) & DM9000_EPCR_ERRE <S2SV_ModEnd> <S2SV_ModStart> DM9000_EPCR , DM9000_EPCR_EPOS <S2SV_ModEnd> "
2673,"<S2SV_StartBug> if ( sk_filter ( sk , skb ) ) <S2SV_EndBug> <S2SV_StartBug> goto discard_and_relse ; <S2SV_EndBug> ",<S2SV_ModStart> tcp_filter <S2SV_ModEnd> <S2SV_ModStart> ; th = ( const struct tcphdr * ) skb -> data ; iph = ip_hdr ( skb ) 
2674,<S2SV_StartBug> goto retry ; <S2SV_EndBug> ,"<S2SV_ModStart> err = fuse_verify_ioctl_iov ( in_iov , in_iovs ) ; if ( err ) goto out ; err = fuse_verify_ioctl_iov ( out_iov , out_iovs ) ; if ( err ) goto out ; "
2675,<S2SV_StartBug> if ( retval != 0 ) <S2SV_EndBug> ,<S2SV_ModStart> == 0 && server_ptr == NULL ) retval = KRB5_KDB_NOENTRY ; if ( retval 
2676,"<S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> next = zap_pte_range ( tlb , vma , pmd , addr , next , details ) ; <S2SV_EndBug> ",<S2SV_ModStart> goto next <S2SV_ModEnd> <S2SV_ModStart> pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> <S2SV_ModStart> goto next <S2SV_ModEnd> <S2SV_ModStart> next : 
2677,"<S2SV_StartBug> REQ ( CHILD ( n , 0 ) , ASYNC ) ; <S2SV_EndBug> <S2SV_StartBug> return ast_for_funcdef_impl ( c , CHILD ( n , 1 ) , NULL , <S2SV_EndBug> <S2SV_StartBug> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> return ast_for_with_stmt ( c , CHILD ( n , 1 ) , <S2SV_EndBug> <S2SV_StartBug> return ast_for_for_stmt ( c , CHILD ( n , 1 ) , <S2SV_EndBug> ","<S2SV_ModStart> NAME ) ; assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , ""async"" ) == 0 <S2SV_ModEnd> <S2SV_ModStart> n <S2SV_ModEnd> <S2SV_ModStart> true <S2SV_ModEnd> <S2SV_ModStart> n , true <S2SV_ModEnd> <S2SV_ModStart> n , true <S2SV_ModEnd> "
2678,<S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_tptr + offset + 4 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ; <S2SV_ModStart> trunc : return - 1 ; 
2679,"<S2SV_StartBug> metadatalength = GetDuration ( mp4 ) ; <S2SV_EndBug> <S2SV_StartBug> float in = 0.0 , out = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> uint32_t fourcc = GPMF_Key ( ms ) ; <S2SV_EndBug> <S2SV_StartBug> double rate = GetGPMFSampleRate ( mp4 , fourcc , GPMF_SAMPLE_RATE_PRECISE ) ; <S2SV_EndBug> <S2SV_StartBug> printf ( ""%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz\\n"" , PRINTF_4CC ( fourcc ) , rate ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( mp4 == 0 ) { printf ( ""error:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>MP4/MOV\\n"" , argv [ 1 ] ) ; return - 1 ; } <S2SV_ModStart> double <S2SV_ModEnd> <S2SV_ModStart> double in = 0.0 , out = 0.0 ; <S2SV_ModStart> , & in , & out ) ; printf ( ""%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz<S2SV_blank>(from<S2SV_blank>%f<S2SV_blank>to<S2SV_blank>%f)\\n"" <S2SV_ModEnd> <S2SV_ModStart> , in , out "
2680,"<S2SV_StartBug> For ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , int <S2SV_EndBug> <S2SV_StartBug> p -> v . For . orelse = orelse ; <S2SV_EndBug> ","<S2SV_ModStart> string type_comment , int <S2SV_ModEnd> <S2SV_ModStart> ; p -> v . For . type_comment = type_comment "
2681,"<S2SV_StartBug> strcpy ( the_url , evt -> navigate . to_url ) ; <S2SV_EndBug> ","<S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <S2SV_ModEnd> "
2682,"<S2SV_StartBug> int i , attr_id = 0 , nattr ; <S2SV_EndBug> ",<S2SV_ModStart> ; tagname [ 0 ] = '\\0' 
2683,"<S2SV_StartBug> DWORD nbWritten = 0 ; <S2SV_EndBug> <S2SV_StartBug> Stream_Seek ( irp -> input , 20 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( CommWriteFile ( serial -> hComm , Stream_Pointer ( irp -> input ) , Length , & nbWritten , NULL ) ) <S2SV_EndBug> ","<S2SV_ModStart> void * ptr ; <S2SV_ModStart> if ( ! Stream_SafeSeek <S2SV_ModEnd> <S2SV_ModStart> ) return ERROR_INVALID_DATA <S2SV_ModStart> ptr = Stream_Pointer ( irp -> input ) ; if ( ! Stream_SafeSeek ( irp -> input , Length ) ) return ERROR_INVALID_DATA ; <S2SV_ModStart> ptr <S2SV_ModEnd> "
2684,<S2SV_StartBug> char * buf ; <S2SV_EndBug> ,"<S2SV_ModStart> struct stream packet = * s ; if ( ! s_check ( s ) ) { rdp_protocol_error ( ""seamless_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state"" , & packet ) ; } "
2685,"<S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> ",<S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) 
2686,"<S2SV_StartBug> ret = hermes_enable_port ( hw , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> hermes_disable_port ( hw , 0 ) ; } else { priv -> tkip_cm_active = 0 ; ret = hermes_enable_port <S2SV_ModEnd> "
2687,<S2SV_StartBug> bool slow ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * addr_len = sizeof ( * sin6 ) ; 
2688,<S2SV_StartBug> count = Z_LVAL_P ( pcount ) ; <S2SV_EndBug> <S2SV_StartBug> if ( Z_TYPE ( entry ) != IS_OBJECT ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ,<S2SV_ModStart> ) ; ZVAL_UNDEF ( & entry ) ; ZVAL_UNDEF ( & inf <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( Z_TYPE ( entry ) != IS_OBJECT ) { zval_ptr_dtor ( & entry ) ; zval_ptr_dtor ( & inf ) ; goto outexcept <S2SV_ModEnd> 
2689,<S2SV_StartBug> uri -> port = port & INT_MAX ; <S2SV_EndBug> ,<S2SV_ModStart> USHRT_MAX <S2SV_ModEnd> 
2690,<S2SV_StartBug> pch -> chan_net = net ; <S2SV_EndBug> ,<S2SV_ModStart> get_net ( net ) <S2SV_ModEnd> 
2691,"<S2SV_StartBug> RETVAL_STRINGL ( replaced , ( int ) new_len , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( new_len > INT_MAX ) { efree ( replaced ) ; RETURN_FALSE ; } 
2692,"<S2SV_StartBug> ret = hermes_enable_port ( hw , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> hermes_disable_port ( hw , 0 ) ; } else { priv -> tkip_cm_active = 0 ; ret = hermes_enable_port <S2SV_ModEnd> "
2693,<S2SV_StartBug> tunnel_type = * ( tptr + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> tlen = len ; <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
2694,"<S2SV_StartBug> NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> GSTD_GSS_ERROR ( maj , min , NULL , ""gss_accept_sec_context"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; gss_release_buffer ( & min , & in <S2SV_ModStart> gss_release_buffer ( & min , & out ) ; "
2695,"<S2SV_StartBug> xref -> entries = calloc ( 1 , xref -> n_entries * sizeof ( struct _xref_entry ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> safe_calloc ( <S2SV_ModEnd> 
2696,<S2SV_StartBug> pairs = palloc ( ncolumns * sizeof ( Pairs ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> Assert ( ncolumns <= MaxTupleAttributeNumber ) ; 
2697,<S2SV_StartBug> assert ( ( cc0 % rowsize ) == 0 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""PredictorEncodeTile"" , ""%s"" , ""(cc0%rowsize)!=0"" ) ; return 0 ; } <S2SV_ModEnd> "
2698,"<S2SV_StartBug> int procfd ; <S2SV_EndBug> <S2SV_StartBug> pid_t to_cleanup_pid = pid ; <S2SV_EndBug> <S2SV_StartBug> status = 0 ; <S2SV_EndBug> <S2SV_StartBug> ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret != 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( options -> stdin_fd == 0 ) { <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" ) ; <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(2)"" ) ; <S2SV_EndBug> <S2SV_StartBug> shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; <S2SV_EndBug> <S2SV_StartBug> cleanup_error : <S2SV_EndBug> <S2SV_StartBug> procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY ) ; <S2SV_EndBug> <S2SV_StartBug> . procfd = procfd <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int procfd = - 1 ; <S2SV_ModStart> procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY | O_CLOEXEC ) ; if ( procfd < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc."" <S2SV_ModEnd> <S2SV_ModStart> status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status <S2SV_ModEnd> <S2SV_ModStart> status ) <S2SV_ModEnd> <S2SV_ModStart> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" <S2SV_ModEnd> <S2SV_ModStart> ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process"" ) ; goto cleanup_error ; } <S2SV_ModStart> ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>"" ""from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" <S2SV_ModEnd> <S2SV_ModStart> ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>"" ""initialization<S2SV_blank>(2):<S2SV_blank>%s."" , strerror ( errno ) <S2SV_ModEnd> <S2SV_ModStart> expected = 3 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>the<S2SV_blank>child<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>to<S2SV_blank>open<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(3):<S2SV_blank>%s."" , strerror ( errno ) ) ; goto cleanup_error ; } if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec , labelfd ; on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; labelfd = lsm_openat ( procfd , attached_pid , on_exec ) ; if ( labelfd < 0 ) goto cleanup_error ; ret = lxc_abstract_unix_send_fd ( ipc_sockets [ 0 ] , labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>send<S2SV_blank>child<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s."" , strerror ( errno ) ) ; goto cleanup_error ; } } <S2SV_ModStart> if ( procfd >= 0 ) close ( procfd ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2699,"<S2SV_StartBug> static int try_filter_frame ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * const cpi , <S2SV_EndBug> <S2SV_StartBug> int filt_err ; <S2SV_EndBug> <S2SV_StartBug> vp9_loop_filter_frame ( cm , & cpi -> mb . e_mbd , filt_level , 1 , partial_frame ) ; <S2SV_EndBug> <S2SV_StartBug> filt_err = vp9_get_y_sse ( sd , cm -> frame_to_show ) ; <S2SV_EndBug> ","<S2SV_ModStart> int64_t <S2SV_ModEnd> <S2SV_ModStart> int64_t filt_err ; if ( cpi -> num_workers > 1 ) vp9_loop_filter_frame_mt ( cm -> frame_to_show , cm , cpi -> td . mb . e_mbd . plane , filt_level , 1 , partial_frame , cpi -> workers , cpi -> num_workers , & cpi -> lf_row_sync ) ; else vp9_loop_filter_frame ( cm -> frame_to_show , <S2SV_ModEnd> <S2SV_ModStart> td . <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) { filt_err = vp9_highbd_get_y_sse ( sd , cm -> frame_to_show ) ; } else { <S2SV_ModStart> } # else filt_err = vp9_get_y_sse ( sd , cm -> frame_to_show ) ; # endif "
2700,"<S2SV_StartBug> ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) <S2SV_EndBug> ",<S2SV_ModStart> key_read_state ( key ) == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> 
2701,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> ( void ) cpi ; ( void ) fullpixel ; 
2702,"<S2SV_StartBug> void vp9_update_mv_count ( VP9_COMMON * cm , const MACROBLOCKD * xd ) { <S2SV_EndBug> <S2SV_StartBug> const MB_MODE_INFO * const mbmi = & mi -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> inc_mvs ( mbmi , mi -> bmi [ i ] . as_mv , & cm -> counts . mv ) ; <S2SV_EndBug> <S2SV_StartBug> inc_mvs ( mbmi , mbmi -> mv , & cm -> counts . mv ) ; <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td ) { <S2SV_ModEnd> <S2SV_ModStart> = & td -> mb . e_mbd ; <S2SV_ModEnd> <S2SV_ModStart> ; const MB_MODE_INFO_EXT * mbmi_ext = td -> mb . mbmi_ext <S2SV_ModStart> mbmi_ext , <S2SV_ModStart> td -> counts -> <S2SV_ModEnd> <S2SV_ModStart> mbmi_ext , <S2SV_ModStart> td -> counts -> <S2SV_ModEnd> "
2703,"<S2SV_StartBug> static bool <S2SV_EndBug> <S2SV_StartBug> bool success = NS_TRUE ; <S2SV_EndBug> <S2SV_StartBug> size_t chunk_length ; <S2SV_EndBug> <S2SV_StartBug> success = NS_FALSE ; <S2SV_EndBug> <S2SV_StartBug> chunk_length = ( size_t ) strtol ( chunkStart , NULL , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( p + 2 + chunk_length > end ) { <S2SV_EndBug> <S2SV_StartBug> success = NS_FALSE ; <S2SV_EndBug> <S2SV_StartBug> memmove ( writeBuffer , p + 2 , chunk_length ) ; <S2SV_EndBug> <S2SV_StartBug> reqPtr -> chunkWriteOff += chunk_length ; <S2SV_EndBug> <S2SV_StartBug> * ( writeBuffer + chunk_length ) = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> reqPtr -> chunkStartOff += ( size_t ) ( p - chunkStart ) + 4u + chunk_length ; <S2SV_EndBug> <S2SV_StartBug> return success ; <S2SV_EndBug> ","<S2SV_ModStart> SockState <S2SV_ModEnd> <S2SV_ModStart> SockState result = SOCK_READY <S2SV_ModEnd> <S2SV_ModStart> long chunkLength <S2SV_ModEnd> <S2SV_ModStart> result = SOCK_MORE <S2SV_ModEnd> <S2SV_ModStart> chunkLength = <S2SV_ModEnd> <S2SV_ModStart> chunkLength < 0 ) { Ns_Log ( Warning , ""ChunkedDecode:<S2SV_blank>negative<S2SV_blank>chunk<S2SV_blank>length"" ) ; result = SOCK_BADREQUEST ; break ; } * p = '\\r' ; if ( <S2SV_ModStart> chunkLength <S2SV_ModEnd> <S2SV_ModStart> result = SOCK_MORE <S2SV_ModEnd> <S2SV_ModStart> ( size_t ) chunkLength <S2SV_ModEnd> <S2SV_ModStart> ( size_t ) chunkLength <S2SV_ModEnd> <S2SV_ModStart> chunkLength <S2SV_ModEnd> <S2SV_ModStart> ( size_t ) chunkLength <S2SV_ModEnd> <S2SV_ModStart> result <S2SV_ModEnd> "
2704,"<S2SV_StartBug> static int jas_iccgetuint ( jas_stream_t * in , int n , ulonglong * val ) <S2SV_EndBug> <S2SV_StartBug> ulonglong v ; <S2SV_EndBug> ",<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> <S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> 
2705,<S2SV_StartBug> char * buf ; <S2SV_EndBug> ,"<S2SV_ModStart> struct stream packet = * s ; if ( ! s_check ( s ) ) { rdp_protocol_error ( ""lspci_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state"" , & packet ) ; } "
2706,"<S2SV_StartBug> PyObject * bufobj = PyObject_CallObject ( readline , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> _PyObject_CallNoArg ( readline <S2SV_ModEnd> 
2707,"<S2SV_StartBug> u16 selector , int seg , u8 cpl , bool in_task_switch ) <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> ","<S2SV_ModStart> , struct desc_struct * desc <S2SV_ModStart> if ( desc ) * desc = seg_desc ; "
2708,<S2SV_StartBug> data [ l ++ ] = SEG_REG_PREFIXES [ op -> operands [ 1 ] . regs [ 0 ] ] ; <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = 0x8b ; <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = offset ; <S2SV_EndBug> <S2SV_StartBug> return l ; <S2SV_EndBug> <S2SV_StartBug> if ( a -> bits == 64 ) { <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = 0x25 ; <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ; <S2SV_EndBug> <S2SV_StartBug> if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) { <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ; <S2SV_EndBug> ,<S2SV_ModStart> % 6 <S2SV_ModStart> data [ l ++ ] = ( ( ( ut32 ) op -> operands [ 0 ] . reg ) << 3 ) | 0x5 ; data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; return l ; } if ( a -> bits == 64 ) { if ( op -> operands [ 0 ] . type & OT_QWORD ) { if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { if ( op -> operands [ 1 ] . regs [ 0 ] != - 1 ) { data [ l ++ ] = 0x67 ; } data [ l ++ ] = 0x48 ; } } else if ( op -> operands [ 1 ] . type & OT_DWORD ) { data [ l ++ ] = 0x44 ; } else if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x67 ; } if ( op -> operands [ 1 ] . type & OT_QWORD && op -> operands [ 0 ] . type & OT_QWORD ) { data [ l ++ ] = 0x48 ; } } if ( op -> operands [ 0 ] . type & OT_WORD ) { data [ l ++ ] = 0x66 ; data [ l ++ ] = op -> operands [ 1 ] . type & OT_BYTE ? 0x8a : 0x8b ; } else { data [ l ++ ] = ( op -> operands [ 1 ] . type & OT_BYTE || op -> operands [ 0 ] . type & OT_BYTE ) ? 0x8a : 0x8b ; } if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_UNDEFINED ) { if ( a -> bits == 64 ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x4 ; data [ l ++ ] = 0x25 ; } else { <S2SV_ModStart> } <S2SV_ModStart> } else { if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ; if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) { base = 5 ; } if ( base ) { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 6 | op -> operands [ 1 ] . regs [ 0 ] << 3 | base ; } else { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 3 | op -> operands [ 1 ] . regs [ 0 ] ; } if ( offset || base ) { data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } <S2SV_ModStart> op -> operands [ 1 ] . regs [ 1 ] != X86R_UNDEFINED <S2SV_ModEnd> <S2SV_ModStart> op -> operands [ 1 ] . regs [ 1 ] << 3 | op -> operands [ 1 ] . regs [ 0 ] ; return l ; } if ( offset || op -> operands [ 1 ] . regs [ 0 ] == X86R_EBP ) { mod = 0x2 ; if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x4 ; } } if ( a -> bits == 64 && offset && op -> operands [ 0 ] . type & OT_QWORD ) { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) { data [ l ++ ] = 0x5 <S2SV_ModEnd> <S2SV_ModStart> if ( op -> operands [ 1 ] . offset > 127 ) { data [ l ++ ] = 0x80 | <S2SV_ModEnd> <S2SV_ModStart> op -> operands [ 1 ] . regs [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> data [ l ++ ] = 0x40 | op -> operands [ 1 ] . regs [ 0 ] ; } } if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x1 ; } } else { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_EIP && ( op -> operands [ 0 ] . type & OT_DWORD ) ) { data [ l ++ ] = 0x0d ; } else if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP && ( op -> operands [ 0 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x05 ; } else { data [ l ++ ] = mod << 5 | <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2709,<S2SV_StartBug> unsigned long size ) <S2SV_EndBug> <S2SV_StartBug> end_gfn = gfn + ( size >> PAGE_SHIFT ) ; <S2SV_EndBug> ,<S2SV_ModStart> npages <S2SV_ModEnd> <S2SV_ModStart> npages <S2SV_ModEnd> 
2710,"<S2SV_StartBug> int lpc = 0 ; <S2SV_EndBug> <S2SV_StartBug> unsigned laddr ; <S2SV_EndBug> <S2SV_StartBug> # ifdef HAVE_GNUTLS_GNUTLS_H <S2SV_EndBug> <S2SV_StartBug> xmlNode * login = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ssock == remote_tls_fd ) { <S2SV_EndBug> <S2SV_StartBug> session = create_tls_session ( csock , GNUTLS_SERVER ) ; <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> login = crm_recv_remote_msg ( session , TRUE ) ; <S2SV_EndBug> <S2SV_StartBug> login = crm_recv_remote_msg ( GINT_TO_POINTER ( csock ) , FALSE ) ; <S2SV_EndBug> <S2SV_StartBug> bail : <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int flag ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( flag = fcntl ( csock , F_GETFL ) ) >= 0 ) { if ( fcntl ( csock , F_SETFL , flag | O_NONBLOCK ) < 0 ) { crm_err ( ""fcntl()<S2SV_blank>write<S2SV_blank>failed"" ) ; close ( csock ) ; return TRUE ; } } else { crm_err ( ""fcntl()<S2SV_blank>read<S2SV_blank>failed"" ) ; close ( csock ) ; return TRUE ; } if ( <S2SV_ModStart> crm_create_anon_tls_session <S2SV_ModEnd> <S2SV_ModStart> , anon_cred_s <S2SV_ModStart> num_clients ++ ; new_client = calloc ( 1 , sizeof ( cib_client_t ) ) ; new_client -> id = crm_generate_uuid ( ) ; new_client -> callback_id = NULL ; new_client -> remote_auth_timeout = g_timeout_add ( REMOTE_AUTH_TIMEOUT , remote_auth_timeout_cb , new_client <S2SV_ModEnd> <S2SV_ModStart> new_client -> encrypted = TRUE ; new_client -> session = session <S2SV_ModEnd> <S2SV_ModStart> new_client -> session = <S2SV_ModEnd> <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2711,<S2SV_StartBug> if ( serial -> num_ports < 2 ) <S2SV_EndBug> ,"<S2SV_ModStart> num_bulk_out <S2SV_ModEnd> <S2SV_ModStart> { dev_err ( & serial -> interface -> dev , ""missing<S2SV_blank>bulk<S2SV_blank>out<S2SV_blank>endpoints\\n"" ) ; return - ENODEV ; } <S2SV_ModEnd> "
2712,<S2SV_StartBug> int n ; <S2SV_EndBug> <S2SV_StartBug> if ( ! body -> unit_size ) <S2SV_EndBug> <S2SV_StartBug> n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) <S2SV_EndBug> ,<S2SV_ModStart> unsigned <S2SV_ModStart> || len < sizeof ( struct oz_multiple_fixed ) - 1 <S2SV_ModStart> ( <S2SV_ModStart> - 1 ) <S2SV_ModEnd> 
2713,"<S2SV_StartBug> ""<td><form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" <S2SV_EndBug> <S2SV_StartBug> ""<td><form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" <S2SV_EndBug> <S2SV_StartBug> ""<td><form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\'start\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Start<S2SV_blank>service\'>"" ""</form>"" ""</td>"" , s -> name , res -> token <S2SV_ModEnd> <S2SV_ModStart> ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\'stop\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Stop<S2SV_blank>service\'>"" ""</form>"" ""</td>"" , s -> name , res -> token <S2SV_ModEnd> <S2SV_ModStart> ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\'restart\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Restart<S2SV_blank>service\'>"" ""</form>"" ""</td>"" , s -> name , res -> token ) ; StringBuffer_append ( res -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\'%s\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'%s\'>"" ""</form>"" ""</td>"" , s -> name , res -> token <S2SV_ModEnd> <S2SV_ModStart> StringBuffer_append ( res -> outputbuffer , ""</tr></table>"" ) ; "
2714,"<S2SV_StartBug> ! inode_capable ( inode , CAP_FSETID ) ) <S2SV_EndBug> ",<S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> 
2715,"<S2SV_StartBug> void * * p , void * end , void * obuf , size_t olen ) <S2SV_EndBug> <S2SV_StartBug> ret = ceph_decrypt2 ( secret , & head , & head_len , obuf , & olen , <S2SV_EndBug> ","<S2SV_ModStart> * <S2SV_ModStart> if ( * obuf == NULL ) { * obuf = kmalloc ( len , GFP_NOFS ) ; if ( ! * obuf ) return - ENOMEM ; olen = len ; } <S2SV_ModStart> * "
2716,"<S2SV_StartBug> static void ptrace_triggered ( struct perf_event * bp , int nmi , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2717,<S2SV_StartBug> int mapping_address = address - mb_mapping -> start_bits ; <S2SV_EndBug> <S2SV_StartBug> if ( nb < 1 || MODBUS_MAX_WRITE_BITS < nb ) { <S2SV_EndBug> <S2SV_StartBug> int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb ) { <S2SV_EndBug> ,<S2SV_ModStart> nb_bits = req [ offset + 5 ] ; int <S2SV_ModStart> || nb_bits * 8 < nb <S2SV_ModStart> ] ; int nb_bytes = req [ offset + 5 <S2SV_ModStart> < nb || nb_bytes * 8 
2718,<S2SV_StartBug> if ( net != c_net || ! tc -> t_sock ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2719,"<S2SV_StartBug> struct resv_map * reservations = vma_resv_map ( vma ) ; <S2SV_EndBug> <S2SV_StartBug> hugetlb_put_quota ( vma -> vm_file -> f_mapping , reserve ) ; <S2SV_EndBug> ",<S2SV_ModStart> ( vma ) ; struct hugepage_subpool * spool = subpool_vma <S2SV_ModStart> hugepage_subpool_put_pages ( spool <S2SV_ModEnd> 
2720,<S2SV_StartBug> sc = create_spnego_ctx ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> 0 
2721,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> } else if ( request_size < 0 ) { rc = - EINVAL ; goto out_free_buffer ; 
2722,<S2SV_StartBug> rfcomm_dlc_accept ( d ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2723,<S2SV_StartBug> case '\\r' : <S2SV_EndBug> ,"<S2SV_ModStart> \'""\' : case '\\\\' : case "
2724,<S2SV_StartBug> return in ; <S2SV_EndBug> ,<S2SV_ModStart> NULL <S2SV_ModEnd> 
2725,"<S2SV_StartBug> int perf_event_overflow ( struct perf_event * event , int nmi , <S2SV_EndBug> <S2SV_StartBug> return __perf_event_overflow ( event , nmi , 1 , data , regs ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2726,<S2SV_StartBug> size_t i ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2727,"<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> err = crypto_ahash_export ( req , state ) ; <S2SV_EndBug> <S2SV_StartBug> ctx2 -> more = 1 ; <S2SV_EndBug> ",<S2SV_ModStart> bool more ; <S2SV_ModStart> lock_sock ( sk ) ; more = ctx -> more ; err = more ? <S2SV_ModEnd> <S2SV_ModStart> : 0 ; release_sock ( sk ) <S2SV_ModStart> more ; if ( ! more ) return err <S2SV_ModEnd> 
2728,<S2SV_StartBug> flags |= EXT4_GET_BLOCKS_PRE_IO ; <S2SV_EndBug> ,<S2SV_ModStart> if ( flags & EXT4_GET_BLOCKS_CONVERT ) split_flag |= EXT4_EXT_DATA_VALID2 ; 
2729,"<S2SV_StartBug> void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) <S2SV_EndBug> ",<S2SV_ModStart> static 
2730,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( rdp -> rc4_decrypt_key == NULL ) return FALSE ; 
2731,<S2SV_StartBug> const char * errstr ; <S2SV_EndBug> <S2SV_StartBug> # else <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> # if ! defined ( __linux__ ) && ! defined ( __NetBSD__ ) <S2SV_ModStart> = NULL ; # else int status ; # endif <S2SV_ModEnd> <S2SV_ModStart> if ( errstr ) return - 1 ; # else status = <S2SV_ModEnd> <S2SV_ModStart> if ( status != 1 <S2SV_ModEnd> <S2SV_ModStart> # endif 
2732,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> new_mnemonic [ strlen ( new_mnemonic ) - 1 ] = '\\0' ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! recovery_started ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , ""Not<S2SV_blank>in<S2SV_blank>Recovery<S2SV_blank>mode"" ) ; layoutHome ( ) ; return ; } <S2SV_ModStart> MAX ( 0u , strnlen ( new_mnemonic , sizeof ( new_mnemonic ) <S2SV_ModEnd> <S2SV_ModStart> ) "
2733,"<S2SV_StartBug> Fp = fopen ( filename , ""wb"" ) ; <S2SV_EndBug> <S2SV_StartBug> return HTTP_UNAUTHORIZED ; <S2SV_EndBug> ",<S2SV_ModStart> # ifdef UPNP_ENABLE_POST_WRITE <S2SV_ModStart> # else return HTTP_NOT_FOUND ; # endif 
2734,<S2SV_StartBug> inbuf = _TIFFmalloc ( scanlinesizein ) ; <S2SV_EndBug> ,"<S2SV_ModStart> uint16 bps = 0 ; ( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; if ( bps != 8 ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s"" , ""cpSeparate2ContigByRow"" ) ; return 0 ; } "
2735,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> * addr_len = sizeof ( * saddr ) ; } <S2SV_ModEnd> 
2736,<S2SV_StartBug> if ( iterator -> next ) rfbDecrClientRef ( iterator -> next ) ; <S2SV_EndBug> ,<S2SV_ModStart> iterator && 
2737,<S2SV_StartBug> if ( key -> type -> destroy ) <S2SV_EndBug> ,"<S2SV_ModStart> test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && "
2738,<S2SV_StartBug> if ( pbi -> decoding_thread_count > num_token_partitions - 1 ) <S2SV_EndBug> <S2SV_StartBug> pbi -> decoding_thread_count = num_token_partitions - 1 ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } if ( pbi -> decoding_thread_count > pbi -> common . mb_rows - 1 ) { pbi -> decoding_thread_count = pbi -> common . mb_rows - 1 ; } 
2739,<S2SV_StartBug> if ( fileblock < INDIRECT_BLOCKS ) <S2SV_EndBug> <S2SV_StartBug> else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } 
2740,"<S2SV_StartBug> int32_t leftoverblock , int32_t ntbytes , int32_t maxbytes , <S2SV_EndBug> <S2SV_StartBug> _sw32 ( dest - 4 , - value ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ntbytes + maxout > maxbytes ) { <S2SV_EndBug> <S2SV_StartBug> maxout = ( int64_t ) maxbytes - ( int64_t ) ntbytes ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ntbytes + neblock ) > maxbytes ) { <S2SV_EndBug> ",<S2SV_ModStart> destsize <S2SV_ModEnd> <S2SV_ModStart> if ( ntbytes > destsize ) { return - 1 ; } <S2SV_ModStart> destsize <S2SV_ModEnd> <S2SV_ModStart> destsize <S2SV_ModEnd> <S2SV_ModStart> destsize <S2SV_ModEnd> 
2741,<S2SV_StartBug> zval_ptr_dtor ( value ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2742,<S2SV_StartBug> BIO * tmpout = NULL ; <S2SV_EndBug> <S2SV_StartBug> tmpout = BIO_new ( BIO_s_mem ( ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ; tmpout = cms_get_text_bio ( out , flags ) ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ; goto err ; } for ( ; ; ) { i = BIO_read ( in , buf , sizeof ( buf ) ) ; if ( i <= 0 ) { if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) { if ( ! BIO_get_cipher_status ( in ) ) goto err ; } if ( i < 0 ) goto err ; break ; } if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2743,<S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> buffer_size -= ( size_t ) pkg_length ; <S2SV_ModStart> buffer_size -= ( size_t ) pkg_length ; <S2SV_ModStart> buffer_size -= ( size_t ) pkg_length ; 
2744,"
","
"
2745,"<S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> isoclns_print ( ndo , p , length , ndo -> ndo_snapend - p ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2746,"<S2SV_StartBug> int copylen ; <S2SV_EndBug> <S2SV_StartBug> if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) ) <S2SV_EndBug> <S2SV_StartBug> copylen = vnet_hdr . hdr_len ; <S2SV_EndBug> ","<S2SV_ModStart> = 0 <S2SV_ModStart> err = - EMSGSIZE ; if ( unlikely ( count > UIO_MAXIOV ) ) goto err ; <S2SV_ModStart> if ( count > MAX_SKB_FRAGS ) { copylen = iov_length ( iv , count - MAX_SKB_FRAGS ) ; if ( copylen < vnet_hdr_len ) copylen = 0 ; else copylen -= vnet_hdr_len ; } if ( copylen < vnet_hdr . hdr_len ) "
2747,<S2SV_StartBug> problem_data_reload_from_dump_dir ( ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2748,"<S2SV_StartBug> return kvm_x86_ops -> set_msr ( vcpu , msr ) ; <S2SV_EndBug> ",<S2SV_ModStart> switch ( msr -> index ) { case MSR_FS_BASE : case MSR_GS_BASE : case MSR_KERNEL_GS_BASE : case MSR_CSTAR : case MSR_LSTAR : if ( is_noncanonical_address ( msr -> data ) ) return 1 ; break ; case MSR_IA32_SYSENTER_EIP : case MSR_IA32_SYSENTER_ESP : msr -> data = get_canonical ( msr -> data ) ; } 
2749,"<S2SV_StartBug> struct perf_event_context * ctx ; <S2SV_EndBug> <S2SV_StartBug> struct perf_event_context * gctx = group_leader -> ctx ; <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & gctx -> mutex ) ; <S2SV_EndBug> <S2SV_StartBug> perf_remove_from_context ( group_leader , false ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & gctx -> mutex ) ; <S2SV_EndBug> ","<S2SV_ModStart> , * uninitialized_var ( gctx ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_lock_double ( & gctx -> mutex , & ctx -> mutex ) ; perf_remove_from_context ( group_leader , false ) ; perf_event__state_init ( group_leader ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_remove_from_context ( sibling , false ) ; perf_event__state_init ( sibling ) ; put_ctx ( gctx ) ; } } else { <S2SV_ModStart> ctx -> mutex ) ; } WARN_ON_ONCE ( ctx -> parent_ctx ) ; if ( move_group ) { synchronize_rcu ( ) ; perf_install_in_context ( ctx , group_leader , group_leader -> cpu ) ; get_ctx ( ctx ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_install_in_context ( ctx , sibling , sibling -> cpu ) ; get_ctx ( ctx ) ; } } perf_install_in_context ( ctx , event , event -> cpu ) ; perf_unpin_context ( ctx ) ; if ( move_group ) { mutex_unlock ( & <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2750,"<S2SV_StartBug> return crypto_alloc_skcipher ( name , type , mask ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> struct skcipher_tfm * tfm ; struct crypto_skcipher * skcipher ; tfm = kzalloc ( sizeof ( * tfm ) , GFP_KERNEL ) ; if ( ! tfm ) return ERR_PTR ( - ENOMEM ) ; skcipher = <S2SV_ModEnd> <S2SV_ModStart> if ( IS_ERR ( skcipher ) ) { kfree ( tfm ) ; return ERR_CAST ( skcipher ) ; } tfm -> skcipher = skcipher ; return tfm ; "
2751,<S2SV_StartBug> if ( x & ( 1 << i ) ) return i ; <S2SV_EndBug> ,<S2SV_ModStart> 1U << ( unsigned int ) <S2SV_ModEnd> 
2752,<S2SV_StartBug> if ( attr >= 0 ) { <S2SV_EndBug> ,"<S2SV_ModStart> && xhash_get ( in -> states , rkey ) == ( void * ) conn_INPROGRESS "
2753,<S2SV_StartBug> int req_len ; <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned <S2SV_ModStart> ; if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) ) return - EINVAL 
2754,"<S2SV_StartBug> separator = strchr ( connection -> buffer , '=' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
2755,"<S2SV_StartBug> const int min_frame_target = MAX ( rc -> min_frame_bandwidth , <S2SV_EndBug> <S2SV_StartBug> rc -> av_per_frame_bandwidth >> 5 ) ; <S2SV_EndBug> <S2SV_StartBug> return target ; <S2SV_EndBug> ","<S2SV_ModStart> VP9EncoderConfig * oxcf = & cpi -> oxcf ; const <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> if ( oxcf -> rc_max_inter_bitrate_pct ) { const int max_rate = rc -> avg_frame_bandwidth * oxcf -> rc_max_inter_bitrate_pct / 100 ; target = MIN ( target , max_rate ) ; } "
2756,<S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ,<S2SV_ModStart> rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if ( 
2757,"<S2SV_StartBug> & key_datums , & key_nulls , & key_count ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) "
2758,<S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> <S2SV_StartBug> if ( ! signal_pending ( current ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> <S2SV_StartBug> out_put_key : <S2SV_EndBug> ,<S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2759,"
","
"
2760,<S2SV_StartBug> xstep = picomp -> hsamp * ( 1 << <S2SV_EndBug> <S2SV_StartBug> ystep = picomp -> vsamp * ( 1 << <S2SV_EndBug> <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || <S2SV_EndBug> <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || <S2SV_EndBug> ,"<S2SV_ModStart> if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> "
2761,"<S2SV_StartBug> static char * print_value ( cJSON * item , int depth , int fmt ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> case cJSON_NULL : out = cJSON_strdup ( ""null"" ) ; break ; <S2SV_EndBug> <S2SV_StartBug> case cJSON_Number : out = print_number ( item ) ; break ; <S2SV_EndBug> <S2SV_StartBug> case cJSON_String : out = print_string ( item ) ; break ; <S2SV_EndBug> <S2SV_StartBug> case cJSON_Array : out = print_array ( item , depth , fmt ) ; break ; <S2SV_EndBug> <S2SV_StartBug> case cJSON_Object : out = print_object ( item , depth , fmt ) ; break ; <S2SV_EndBug> ","<S2SV_ModStart> , printbuffer * p <S2SV_ModStart> if ( p ) { <S2SV_ModStart> { out = ensure ( p , 5 ) ; if ( out ) strcpy ( out , ""null"" ) ; break ; } case cJSON_False : { out = ensure ( p , 6 ) ; if ( out ) strcpy ( out , ""false"" ) ; break ; } case cJSON_True : { out = ensure ( p , 5 ) ; if ( out ) strcpy ( out , ""true"" ) ; break ; } case cJSON_Number : out = print_number ( item , p ) ; break ; case cJSON_String : out = print_string ( item , p ) ; break ; case cJSON_Array : out = print_array ( item , depth , fmt , p ) ; break ; case cJSON_Object : out = print_object ( item , depth , fmt , p ) ; break ; } } else { switch ( ( item -> type ) & 255 ) { case cJSON_NULL : <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 ) ; break ; } <S2SV_ModEnd> "
2762,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> ( void ) cpi ; ( void ) fullpixel ; 
2763,"<S2SV_StartBug> static void update_coef_probs ( VP9_COMP * cpi , vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> vp9_coeff_stats frame_branch_ct [ TX_SIZES ] [ PLANE_TYPES ] ; <S2SV_EndBug> <S2SV_StartBug> for ( tx_size = TX_4X4 ; tx_size <= max_tx_size ; ++ tx_size ) <S2SV_EndBug> <S2SV_StartBug> update_coef_probs_common ( w , cpi , tx_size , frame_branch_ct [ tx_size ] ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { vp9_coeff_stats frame_branch_ct [ PLANE_TYPES ] ; vp9_coeff_probs_model frame_coef_probs [ PLANE_TYPES ] ; if ( cpi -> td . counts -> tx . tx_totals [ tx_size ] <= 20 || ( tx_size >= TX_16X16 && cpi -> sf . tx_size_search_method == USE_TX_8X8 ) ) { vpx_write_bit ( w , 0 ) ; } else { build_tree_distribution ( cpi , tx_size , frame_branch_ct , frame_coef_probs ) ; <S2SV_ModStart> , frame_coef_probs <S2SV_ModEnd> <S2SV_ModStart> } } "
2764,"<S2SV_StartBug> ptr = strchr ( ptr + 1 , '/' ) + 1 ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( ptr == NULL ) return ( ENOENT ) ; ptr ++ <S2SV_ModEnd> 
2765,<S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit ) { <S2SV_EndBug> ,<S2SV_ModStart> limit || ( unsigned char * ) e + e -> next_offset > 
2766,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> assert_regexp_syntax_error ( ""\\\\x0"" ) ; assert_regexp_syntax_error ( ""\\\\x"" ) ; assert_regexp_syntax_error ( ""\\\\xxy"" ) ; "
2767,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> L -> oldpc = 0 ; 
2768,"<S2SV_StartBug> const u_char * ep , uint32_t phase , uint32_t doi0 _U_ , <S2SV_EndBug> <S2SV_StartBug> uint32_t proto0 _U_ , int depth ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>orig=("" ) ) ; <S2SV_EndBug> <S2SV_StartBug> size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case IPSECDOI_NTYPE_REPLAY_STATUS : <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> isakmp_print ( ndo , cp , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> _U_ <S2SV_ModStart> _U_ <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>attrs=("" ) <S2SV_ModStart> ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ""<S2SV_blank>status=("" ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , "")"" ) ) <S2SV_ModEnd> <S2SV_ModStart> if ( ndo -> ndo_vflag > 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>data=("" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> } else { if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; } break ; } "
2769,<S2SV_StartBug> if ( filter [ i ] . jf ) <S2SV_EndBug> <S2SV_StartBug> t_offset += is_near ( f_offset ) ? 2 : 6 ; <S2SV_EndBug> ,<S2SV_ModStart> && f_offset <S2SV_ModStart> 5 <S2SV_ModEnd> 
2770,"<S2SV_StartBug> if ( test_bit ( DMF_FREEING , & md -> flags ) || <S2SV_EndBug> <S2SV_StartBug> dm_deleting_md ( md ) ) <S2SV_EndBug> <S2SV_StartBug> dm_get ( md ) ; <S2SV_EndBug> ",<S2SV_ModStart> spin_lock ( & _minor_lock ) ; <S2SV_ModStart> { md = NULL ; goto out ; } <S2SV_ModEnd> <S2SV_ModStart> ) ; out : spin_unlock ( & _minor_lock 
2771,<S2SV_StartBug> if ( ! ps_dec -> u1_first_slice_in_stream && ( ps_dec -> u4_first_slice_in_pic == 2 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic != 2 ) <S2SV_EndBug> <S2SV_StartBug> else if ( ps_dec -> u4_first_slice_in_pic == 2 ) <S2SV_EndBug> <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic ) <S2SV_EndBug> <S2SV_StartBug> num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; <S2SV_EndBug> <S2SV_StartBug> num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) <S2SV_EndBug> <S2SV_StartBug> if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) <S2SV_EndBug> <S2SV_StartBug> - ps_dec -> u2_total_mbs_coded ; <S2SV_EndBug> <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic == 2 ) <S2SV_EndBug> <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic == 2 ) <S2SV_EndBug> <S2SV_StartBug> ps_dec -> u4_first_slice_in_pic = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> == 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> prev_slice_err = 2 <S2SV_ModEnd> <S2SV_ModStart> ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } } else { if ( ( <S2SV_ModStart> ) > ps_dec -> u2_total_mbs_coded ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> - <S2SV_ModEnd> <S2SV_ModStart> ; ps_cur_poc = & s_tmp_poc ; } else if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2772,<S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( s -> codec_id == AV_CODEC_ID_JV ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO ) { w_align = 8 ; h_align = 8 ; } <S2SV_ModStart> || s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO 
2773,<S2SV_StartBug> if ( L_ICANON ( tty ) ) <S2SV_EndBug> ,<S2SV_ModStart> && ! L_EXTPROC ( tty ) 
2774,"<S2SV_StartBug> sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) sun_info . length , <S2SV_EndBug> <S2SV_StartBug> sizeof ( * sun_data ) ) ; <S2SV_EndBug> <S2SV_StartBug> height = sun_info . height ; <S2SV_EndBug> ","<S2SV_ModStart> bytes_per_line = sun_info . width * sun_info . depth ; <S2SV_ModStart> MagickMax ( <S2SV_ModStart> bytes_per_line * sun_info . width ) , <S2SV_ModStart>  <S2SV_ModEnd> "
2775,"<S2SV_StartBug> int release_vp9_frame_buffer ( void * cb_priv , <S2SV_EndBug> ",<S2SV_ModStart> static 
2776,"<S2SV_StartBug> void vp9_cost_tokens ( int * costs , const vp9_prob * probs , vp9_tree tree ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_tree <S2SV_ModEnd> 
2777,"<S2SV_StartBug> vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ; <S2SV_EndBug> <S2SV_StartBug> vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned long cr4 ; <S2SV_ModStart> HOST_CR3 , read_cr3 ( ) ) ; cr4 = read_cr4 ( ) ; vmcs_writel ( HOST_CR4 , cr4 ) ; vmx -> host_state . vmcs_host_cr4 = cr4 <S2SV_ModEnd> "
2778,<S2SV_StartBug> value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> <S2SV_StartBug> value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | <S2SV_EndBug> <S2SV_StartBug> ( ( unsigned char * ) buffer ) [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned short ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> buffer <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned short ) buffer <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2779,"<S2SV_StartBug> code = validate_as_request ( kdc_active_realm , request , * princ , <S2SV_EndBug> ","<S2SV_ModStart> princ -> pw_expiration = 0 ; clear ( princ -> attributes , KRB5_KDB_REQUIRES_PWCHANGE ) ; "
2780,"<S2SV_StartBug> dprintk ( 2 , ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%d,vma=%08lx-%08lx]\\n"" , map , <S2SV_EndBug> ","<S2SV_ModStart> ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n"" <S2SV_ModEnd> "
2781,"<S2SV_StartBug> u8 obuf [ 0x40 ] , ibuf [ 0x40 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( mutex_lock_interruptible ( & d -> i2c_mutex ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> switch ( num ) { <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = msg [ 0 ] . buf [ 0 ] + 0x36 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 3 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 0 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0x10 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 2 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> msg [ 0 ] . buf [ 1 ] = ibuf [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> msg [ 0 ] . buf [ 0 ] = ibuf [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0x08 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = msg [ 0 ] . addr ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = msg [ 0 ] . len ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & obuf [ 3 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 3 , <S2SV_EndBug> <S2SV_StartBug> ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0x09 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = msg [ 0 ] . len ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 3 ] = msg [ 0 ] . addr ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & obuf [ 4 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 4 , <S2SV_EndBug> <S2SV_StartBug> ibuf , msg [ 1 ] . len + 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg [ 1 ] . buf , & ibuf [ 1 ] , msg [ 1 ] . len ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & d -> i2c_mutex ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct dw2102_state * state <S2SV_ModEnd> <S2SV_ModStart> state = d -> priv ; <S2SV_ModStart> if ( mutex_lock_interruptible ( & d -> data_mutex ) < 0 ) { mutex_unlock ( & d -> i2c_mutex ) ; return - EAGAIN ; } <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data , 1 , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data [ 1 ] = msg [ 0 ] . len ; state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> data_mutex ) ; mutex_unlock ( & d -> "
2782,<S2SV_StartBug> blockcnt = ( ( len + pos ) + blocksize - 1 ) >> <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 1 || len == 0xffffffff ) { return - 1 ; } 
2783,<S2SV_StartBug> struct cred * cred ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cred ) <S2SV_EndBug> <S2SV_StartBug> return create_user_ns ( cred ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; int err = - ENOMEM <S2SV_ModStart> cred ) { err = create_user_ns ( cred ) ; if ( err ) put_cred ( cred ) ; else <S2SV_ModEnd> <S2SV_ModStart> } return err <S2SV_ModEnd> 
2784,<S2SV_StartBug> status = sctp_v4_protosw_init ( ) ; <S2SV_EndBug> <S2SV_StartBug> status = register_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> <S2SV_StartBug> unregister_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> <S2SV_StartBug> err_protosw_init : <S2SV_EndBug> ,<S2SV_ModStart> register_pernet_subsys ( & sctp_defaults_ops ) ; if ( status ) goto err_register_defaults ; status = <S2SV_ModStart> sctp_ctrlsock_ops ) ; if ( status ) goto err_register_ctrlsock <S2SV_ModEnd> <S2SV_ModStart> sctp_ctrlsock_ops ) ; err_register_ctrlsock <S2SV_ModEnd> <S2SV_ModStart> : unregister_pernet_subsys ( & sctp_defaults_ops ) ; err_register_defaults 
2785,<S2SV_StartBug> if ( ! chip -> num_interfaces ) <S2SV_EndBug> <S2SV_StartBug> atomic_dec ( & chip -> active ) ; <S2SV_EndBug> ,<S2SV_ModStart> atomic_dec ( & chip -> active ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
2786,"<S2SV_StartBug> cntsize ( in , & sumlen , & nnode ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; if ( TSQUERY_TOO_BIG ( nnode , sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) "
2787,<S2SV_StartBug> s -> decode_mb = mpeg4_decode_studio_mb ; <S2SV_EndBug> ,<S2SV_ModStart> interlaced_dct = 0 ; s -> 
2788,"<S2SV_StartBug> ret = read ( p_dev -> fd , & ev , sizeof ( ev ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
2789,"<S2SV_StartBug> int status = 0 ; <S2SV_EndBug> <S2SV_StartBug> state = nfs4_do_open ( dir , & path , flags , sattr , cred ) ; <S2SV_EndBug> <S2SV_StartBug> status = nfs4_intent_set_file ( nd , & path , state ) ; <S2SV_EndBug> <S2SV_StartBug> nfs4_close_sync ( & path , state , flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> fmode_t fmode = flags & ( FMODE_READ | FMODE_WRITE ) ; <S2SV_ModStart> , fmode <S2SV_ModStart> , fmode <S2SV_ModStart> fmode <S2SV_ModEnd> "
2790,<S2SV_StartBug> struct key * keyring ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( new -> thread_keyring ) return 0 
2791,<S2SV_StartBug> if ( index > glyphCache -> glyphCache [ id ] . number ) <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> 
2792,"<S2SV_StartBug> end = strchr ( * value + 1 , \'""\' ) ; <S2SV_EndBug> <S2SV_StartBug> end ++ ; <S2SV_EndBug> ","<S2SV_ModStart> char * p = end = <S2SV_ModEnd> <S2SV_ModStart> ; while ( * p ) { if ( * p == '\\\\' ) { p ++ ; * end = * p ; } else { * end = * p ; if ( * p == \'""\' ) break ; } p ++ ; end ++ ; } if ( * end != \'""\' <S2SV_ModEnd> <S2SV_ModStart> = ++ p <S2SV_ModEnd> "
2793,"<S2SV_StartBug> timr -> it_overrun += ( unsigned int ) hrtimer_forward ( timer , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2794,<S2SV_StartBug> if ( ! file ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ,<S2SV_ModStart> || count > OE_SSIZE_MAX <S2SV_ModStart> if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } 
2795,"<S2SV_StartBug> cmpt -> stream_ = ( inmem ) ? jas_stream_memopen ( 0 , size ) : <S2SV_EndBug> ",<S2SV_ModStart> jas_stream_memopen2 <S2SV_ModEnd> 
2796,"<S2SV_StartBug> checkstackp ( L , 1 , ra ) ; <S2SV_EndBug> ",<S2SV_ModStart> checkstackGCp <S2SV_ModEnd> 
2797,<S2SV_StartBug> vpx_active_map_t map = { 0 } ; <S2SV_EndBug> ,"<S2SV_ModStart> 0 , 0 , "
2798,<S2SV_StartBug> nPath = ( int ) strlen ( zPath ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( zPath == 0 ) zPath = """" ; "
2799,"<S2SV_StartBug> union sctp_addr_param * addr_param ; <S2SV_EndBug> <S2SV_StartBug> addr_param = ( union sctp_addr_param * ) hdr -> params ; <S2SV_EndBug> <S2SV_StartBug> ( sctp_paramhdr_t * ) ( ( void * ) addr_param + length ) , <S2SV_EndBug> ","<S2SV_ModStart> __u32 serial <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> chunk , true , <S2SV_ModEnd> "
2800,<S2SV_StartBug> vstart += entry -> vn_aux ; <S2SV_EndBug> ,<S2SV_ModStart> st32 vnaux = entry -> vn_aux ; if ( vnaux < 1 ) { goto beach ; } vstart += vnaux <S2SV_ModEnd> 
2801,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && src -> data [ plane ] ; plane ++ ) <S2SV_EndBug> ,<S2SV_ModStart> [ plane ] && src -> linesize 
2802,"<S2SV_StartBug> n = r -> sector_count ; <S2SV_EndBug> <S2SV_StartBug> r -> iov . iov_len = n * 512 ; <S2SV_EndBug> <S2SV_StartBug> qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , & r -> qiov , n , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> n = scsi_init_iovec ( r ) ; bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_READ ) ; r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , <S2SV_ModEnd> <S2SV_ModStart> n , scsi_read_complete , r ) ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2803,"<S2SV_StartBug> vpx_memset ( ybf -> y_buffer - 1 - ybf -> y_stride , 127 , ybf -> y_width + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ybf -> u_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ybf -> v_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
2804,<S2SV_StartBug> char added ; <S2SV_EndBug> <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2805,<S2SV_StartBug> int vm_shared = dst_vma -> vm_flags & VM_SHARED ; <S2SV_EndBug> <S2SV_StartBug> if ( vm_shared ) { <S2SV_EndBug> <S2SV_StartBug> struct address_space * mapping = dst_vma -> vm_file -> f_mapping ; <S2SV_EndBug> <S2SV_StartBug> spin_lock ( ptl ) ; <S2SV_EndBug> ,"<S2SV_ModStart> struct address_space * mapping ; pgoff_t idx ; unsigned long size ; <S2SV_ModStart> mapping = dst_vma -> vm_file -> f_mapping ; idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; <S2SV_ModStart> size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_nounlock <S2SV_ModEnd> <S2SV_ModStart> ; size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_unlock "
2806,"<S2SV_StartBug> error = xfs_da_shrink_inode ( args , 0 , bp ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( bp && ( <S2SV_ModEnd> <S2SV_ModStart> != 0 ) <S2SV_ModEnd> 
2807,<S2SV_StartBug> if ( ! stream -> config . cfg . g_w || ! stream -> config . cfg . g_h ) <S2SV_EndBug> <S2SV_StartBug> if ( stream -> config . cfg . g_profile != 0 && ! global -> experimental_bitstream ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! streami -> config . out_fn ) <S2SV_EndBug> <S2SV_StartBug> const char * a = stream -> config . out_fn ; <S2SV_EndBug> <S2SV_StartBug> const char * a = stream -> config . stats_fn ; <S2SV_EndBug> ,"<S2SV_ModStart> ( void ) global ; <S2SV_ModStart> g_input_bit_depth > ( unsigned int ) stream -> config . cfg . g_bit_depth ) { fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>codec<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>(%d)<S2SV_blank>less<S2SV_blank>than<S2SV_blank>input<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>(%d)"" , stream -> index , ( int ) stream -> config . cfg . g_bit_depth , stream -> config . cfg . g_input_bit_depth ) ; } for ( streami = stream ; streami ; streami = streami -> next ) { if ( ! streami -> config . out_fn ) fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>Output<S2SV_blank>file<S2SV_blank>is<S2SV_blank>required<S2SV_blank>(specify<S2SV_blank>with<S2SV_blank>-o)"" , streami -> index ) ; if ( streami != stream ) { const char * a = stream <S2SV_ModEnd> <S2SV_ModStart> ; const char * b = streami -> config . out_fn ; if ( ! strcmp ( a , b ) && strcmp ( a , ""/dev/null"" ) && strcmp ( a , "":nul"" ) ) fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>duplicate<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(from<S2SV_blank>stream<S2SV_blank>%d)"" , streami -> index , stream -> index ) ; } <S2SV_ModEnd> <S2SV_ModStart> stats_fn ; const char * b = streami -> config . stats_fn ; if ( a && b && ! strcmp ( a , b ) ) fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>duplicate<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>(from<S2SV_blank>stream<S2SV_blank>%d)"" , streami -> index , stream -> index ) ; } # if CONFIG_FP_MB_STATS <S2SV_ModEnd> <S2SV_ModStart> fpmb_stats_fn ; const char * b = streami -> config . fpmb_stats_fn ; if ( a && b && ! strcmp ( a , b ) ) fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>duplicate<S2SV_blank>mb<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>(from<S2SV_blank>stream<S2SV_blank>%d)"" , streami -> index , stream -> index ) ; } # endif <S2SV_ModEnd> "
2808,"<S2SV_StartBug> ip_printroute ( ndo , cp , option_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( <S2SV_ModStart> == - 1 ) goto trunc 
2809,"<S2SV_StartBug> if ( ! kvm_read_cr4_bits ( vcpu , X86_CR4_VMXE ) ) { <S2SV_EndBug> ","<S2SV_ModStart> ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } if ( vmx_get_cpl ( vcpu "
2810,"<S2SV_StartBug> bool issrc , isneg ; <S2SV_EndBug> <S2SV_StartBug> off_reg = issrc ? insn -> src_reg : insn -> dst_reg ; <S2SV_EndBug> <S2SV_StartBug> if ( isneg ) <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_REG ( BPF_SUB , BPF_REG_AX , off_reg ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_REG ( BPF_OR , BPF_REG_AX , off_reg ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_IMM ( BPF_NEG , BPF_REG_AX , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_REG ( BPF_AND , BPF_REG_AX , off_reg ) ; <S2SV_EndBug> <S2SV_StartBug> if ( issrc && isneg ) <S2SV_EndBug> ","<S2SV_ModStart> , isimm <S2SV_ModStart> isimm = aux -> alu_state & BPF_ALU_IMMEDIATE ; <S2SV_ModStart> isimm ) { <S2SV_ModEnd> <S2SV_ModStart> BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit ) ; } else { if ( isneg ) <S2SV_ModEnd> <S2SV_ModStart> BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 <S2SV_ModEnd> <S2SV_ModStart> BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit <S2SV_ModEnd> <S2SV_ModStart> BPF_SUB <S2SV_ModEnd> <S2SV_ModStart> BPF_ALU64_REG ( BPF_OR <S2SV_ModEnd> <S2SV_ModStart> off_reg <S2SV_ModEnd> <S2SV_ModStart> BPF_NEG <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ; * patch ++ = <S2SV_ModStart> } <S2SV_ModStart> && ! isimm "
2811,<S2SV_StartBug> err = 0 ; <S2SV_EndBug> <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> msg -> msg_namelen = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> 
2812,"<S2SV_StartBug> size_t i , maxcount ; <S2SV_EndBug> <S2SV_StartBug> ssi -> si_count = CDF_TOLE2 ( si -> si_count ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < CDF_TOLE4 ( si -> si_count ) ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> info , count , & maxcount ) == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> CDF_TOLE4 <S2SV_ModEnd> <S2SV_ModStart> if ( cdf_read_property_info ( sst , h , CDF_TOLE4 ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2813,"<S2SV_StartBug> for ( j = 0 ; j < size ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> r_cons_printf ( ""%02x"" , buf [ j + idx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( op . val != UT64_MAX ) <S2SV_EndBug> <S2SV_StartBug> if ( op . ptr != UT64_MAX ) <S2SV_EndBug> <S2SV_StartBug> printline ( ""ptr"" , ""0x%08"" PFMT64x ""\\n"" , op . ptr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( op . refptr != - 1 ) <S2SV_EndBug> <S2SV_StartBug> printline ( ""refptr"" , ""%d\\n"" , op . refptr ) ; <S2SV_EndBug> ","<S2SV_ModStart> int minsz = R_MIN ( len , size ) ; minsz = R_MAX ( minsz , 0 ) ; <S2SV_ModStart> minsz <S2SV_ModEnd> <S2SV_ModStart> ut8 ch = ( ( j + idx - 1 ) > minsz ) ? 0xff : <S2SV_ModEnd> <S2SV_ModStart> ; r_cons_printf ( ""%02x"" , ch <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } "
2814,"<S2SV_StartBug> int pidfd = creat ( pid_file , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <S2SV_EndBug> ","<S2SV_ModStart> open ( pid_file , O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC <S2SV_ModEnd> "
2815,<S2SV_StartBug> if ( ret < 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> goto error ; <S2SV_ModEnd> 
2816,"<S2SV_StartBug> REQ ( CHILD ( n , 0 ) , ASYNC ) ; <S2SV_EndBug> <S2SV_StartBug> return ast_for_funcdef_impl ( c , CHILD ( n , 1 ) , decorator_seq , <S2SV_EndBug> <S2SV_StartBug> 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> NAME ) ; assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , ""async"" ) == 0 <S2SV_ModEnd> <S2SV_ModStart> n <S2SV_ModEnd> <S2SV_ModStart> true <S2SV_ModEnd> "
2817,"<S2SV_StartBug> sprintf ( buf , ""%s.conf"" , set ) ; <S2SV_EndBug> <S2SV_StartBug> printf ( ""\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\n\\n"" , <S2SV_EndBug> ","<S2SV_ModStart> snprintf ( buf , sizeof ( buf ) <S2SV_ModEnd> <S2SV_ModStart> ""\\\n<S2SV_blank><S2SV_blank><S2SV_blank>\\n\\n"" <S2SV_ModEnd> "
2818,<S2SV_StartBug> hdr = ( void * ) p - head -> iov_base ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( hdr > head -> iov_len ) return 0 
2819,"<S2SV_StartBug> char * p , * q , * r ; <S2SV_EndBug> <S2SV_StartBug> printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\n<S2SV_blank>This<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\n<S2SV_blank>There<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\n<S2SV_blank>particular<S2SV_blank>purpose.\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( p = line + 18 ; isspace ( * p ) ; p ++ ) <S2SV_EndBug> <S2SV_StartBug> lenIV = atoi ( line + 6 ) ; <S2SV_EndBug> <S2SV_StartBug> && strstr ( line , ""readstring"" ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( p = strstr ( line , ""/Subrs"" ) ) && isdigit ( p [ 7 ] ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( ( p = strstr ( line , ""/CharStrings"" ) ) && isdigit ( p [ 13 ] ) ) <S2SV_EndBug> <S2SV_StartBug> for ( q = p ; isspace ( * q ) && * q != '\\n' ; q ++ ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\nThis<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\nThere<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\nparticular<S2SV_blank>purpose.\\n"" <S2SV_ModEnd> <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> set_lenIV ( line <S2SV_ModEnd> <S2SV_ModStart> ) { set_cs_start ( line ) <S2SV_ModEnd> <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) "
2820,"<S2SV_StartBug> if ( * p ) { <S2SV_EndBug> <S2SV_StartBug> * q = 0 ; <S2SV_EndBug> <S2SV_StartBug> cmd = p + 1 ; <S2SV_EndBug> <S2SV_StartBug> * p = \'""\' ; <S2SV_EndBug> ",<S2SV_ModStart> char op0 = 0 ; <S2SV_ModStart> op0 = * q ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> op0 <S2SV_ModEnd> 
2821,<S2SV_StartBug> ( mysql -> options . extension && mysql -> options . extension -> ssl_crlpath ) ) <S2SV_EndBug> <S2SV_StartBug> mysql -> options . use_ssl = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( mysql -> client_flag & CLIENT_SSL ) <S2SV_EndBug> <S2SV_StartBug> unsigned long ssl_error ; <S2SV_EndBug> ,"<S2SV_ModStart> || ( mysql -> options . extension && mysql -> options . extension -> ssl_enforce ) <S2SV_ModStart> TRUE <S2SV_ModEnd> <S2SV_ModStart> options . extension && mysql -> options . extension -> ssl_enforce ) { DBUG_ASSERT ( mysql -> options . use_ssl ) ; if ( ! ( mysql -> server_capabilities & CLIENT_SSL ) ) { set_mysql_extended_error ( mysql , CR_SSL_CONNECTION_ERROR , unknown_sqlstate , ER ( CR_SSL_CONNECTION_ERROR ) , ""SSL<S2SV_blank>is<S2SV_blank>required<S2SV_blank>but<S2SV_blank>the<S2SV_blank>server<S2SV_blank>doesn\'t<S2SV_blank>"" ""support<S2SV_blank>it"" ) ; goto error ; } } if ( ( mysql -> server_capabilities & CLIENT_SSL ) && mysql -> options . use_ssl <S2SV_ModEnd> <S2SV_ModStart> if ( ! mysql -> options . ssl_cipher ) { SET_OPTION ( ssl_cipher , default_ssl_cipher ) ; } "
2822,<S2SV_StartBug> if ( header -> biSize >= 40U ) { <S2SV_EndBug> ,"<S2SV_ModStart> biBitCount == 0 ) { fprintf ( stderr , ""Error,<S2SV_blank>invalid<S2SV_blank>biBitCount<S2SV_blank>%d\\n"" , 0 ) ; return OPJ_FALSE ; } if ( header -> "
2823,"<S2SV_StartBug> int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ; <S2SV_EndBug> ",<S2SV_ModStart> unlink ( path ) ; <S2SV_ModStart> O_EXCL <S2SV_ModEnd> 
2824,<S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug> ,<S2SV_ModStart> kfree_skb ( skb ) ; 
2825,<S2SV_StartBug> vp8_clear_system_state ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> ctx -> si . w = 0 ; ctx -> si . h = 0 ; 
2826,"<S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> <S2SV_StartBug> set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> key -> state == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> <S2SV_ModStart> mark_key_instantiated ( key , 0 <S2SV_ModEnd> "
2827,"<S2SV_StartBug> ldblk , sizeof ( * BImgBuff ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> + 1 
2828,<S2SV_StartBug> if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,"<S2SV_ModStart> { <S2SV_ModStart> ; } else memset ( & ifr , 0 , sizeof ( ifr ) ) "
2829,<S2SV_StartBug> if ( gfs ) <S2SV_EndBug> ,<S2SV_ModStart> last_name = 0 ; 
2830,"<S2SV_StartBug> void bpf_map_inc ( struct bpf_map * map , bool uref ) <S2SV_EndBug> <S2SV_StartBug> atomic_inc ( & map -> refcnt ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> struct bpf_map * <S2SV_ModEnd> <S2SV_ModStart> if ( atomic_inc_return ( & map -> refcnt ) > BPF_MAX_REFCNT ) { atomic_dec <S2SV_ModEnd> <S2SV_ModStart> return ERR_PTR ( - EBUSY ) ; } <S2SV_ModStart> return map ; 
2831,<S2SV_StartBug> usb_conv_info -> class_data = u3v_conv_info ; <S2SV_EndBug> ,<S2SV_ModStart> ; usb_conv_info -> class_data_type = USB_CONV_U3V ; } else if ( usb_conv_info -> class_data_type != USB_CONV_U3V ) { return 0 
2832,"<S2SV_StartBug> if ( plen == 0 ) { <S2SV_EndBug> <S2SV_StartBug> phdr = sctp_get_next_param ( m , offset , <S2SV_EndBug> ",<S2SV_ModStart> < sizeof ( struct sctp_paramhdr ) <S2SV_ModEnd> <S2SV_ModStart> if ( plen < sizeof ( struct sctp_asconf_addrv4_param ) ) { return ( - 101 ) ; } 
2833,<S2SV_StartBug> else if ( verify & GNUTLS_CERT_INVALID ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> } if ( error == NULL ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2834,"<S2SV_StartBug> str = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) count , sizeof ( * str ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> + 1 
2835,"<S2SV_StartBug> PyObject * logical = NULL ; <S2SV_EndBug> <S2SV_StartBug> FriBidiParType base = FRIBIDI_TYPE_RTL ; <S2SV_EndBug> <S2SV_StartBug> { ""logical"" , ""base_direction"" , ""encoding"" , ""clean"" , ""reordernsm"" , NULL } ; <S2SV_EndBug> <S2SV_StartBug> if ( ! PyArg_ParseTupleAndKeywords ( args , kw , ""O|isii"" , kwargs , <S2SV_EndBug> <S2SV_StartBug> & logical , & base , & encoding , & clean , & reordernsm ) ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON ) ) <S2SV_EndBug> <S2SV_StartBug> if ( PyUnicode_Check ( logical ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( PyString_Check ( logical ) ) <S2SV_EndBug> ","<S2SV_ModStart> PyUnicodeObject <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""U|iii"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } return unicode_log2vis <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2836,<S2SV_StartBug> nfca_poll -> nfcid1_len = * data ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> min_t ( __u8 , <S2SV_ModStart> , NFC_NFCID1_MAXSIZE ) "
2837,"<S2SV_StartBug> int zero_bits = * in & 0x07 ; <S2SV_EndBug> <S2SV_StartBug> size_t octets_left = inlen - 1 ; <S2SV_EndBug> <S2SV_StartBug> int i , count = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> i , count = 0 ; int zero_bits ; size_t octets_left ; if ( outlen < octets_left ) return SC_ERROR_BUFFER_TOO_SMALL ; if ( inlen < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> in ++ ; memset ( outbuf , 0 , outlen ) ; while ( octets_left ) { int bits_to_go ; * out = 0 ; if ( octets_left == 1 ) bits_to_go = 8 - zero_bits ; else bits_to_go = 8 ; if ( invert ) for ( i = 0 ; i < bits_to_go ; i ++ ) { * out |= ( ( * in >> ( 7 - i ) ) & 1 ) << i ; } else { * out = * in ; } out ++ ; in ++ ; octets_left -- ; count ++ ; } return ( count * 8 <S2SV_ModEnd> "
2838,<S2SV_StartBug> if ( uid >= AID_APP ) { <S2SV_EndBug> ,<S2SV_ModStart> multiuser_get_app_id ( uid ) <S2SV_ModEnd> 
2839,"<S2SV_StartBug> ret = get_tag ( asn1 , len , & inner_tag , & asn1 , & len , & rem , & rlen ) ; <S2SV_EndBug> ","<S2SV_ModStart> , 0 "
2840,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK2 ( * s , 1 ) ; "
2841,"<S2SV_StartBug> if ( ( ret = av_image_check_size ( s -> width , s -> height , 0 , avctx ) ) < 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> ff_set_dimensions ( avctx , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2842,"<S2SV_StartBug> pipe_write ( struct kiocb * iocb , const struct iovec * _iov , <S2SV_EndBug> <S2SV_StartBug> ssize_t ret ; <S2SV_EndBug> <S2SV_StartBug> int do_wakeup ; <S2SV_EndBug> <S2SV_StartBug> size_t total_len ; <S2SV_EndBug> <S2SV_StartBug> total_len = iov_length ( iov , nr_segs ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> int error , atomic = 1 ; <S2SV_EndBug> <S2SV_StartBug> iov_fault_in_pages_read ( iov , chars ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> total_len -= chars ; <S2SV_EndBug> <S2SV_StartBug> char * src ; <S2SV_EndBug> <S2SV_StartBug> chars = PAGE_SIZE ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( error ) ) { <S2SV_EndBug> <S2SV_StartBug> ret += chars ; <S2SV_EndBug> <S2SV_StartBug> buf -> len = chars ; <S2SV_EndBug> <S2SV_StartBug> total_len -= chars ; <S2SV_EndBug> ","<S2SV_ModStart> struct iov_iter * from <S2SV_ModEnd> <S2SV_ModStart> = 0 <S2SV_ModStart> = 0 <S2SV_ModEnd> <S2SV_ModStart> = iov_iter_count ( from ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ret = copy_page_from_iter ( buf -> page , offset , chars , from ) ; if ( unlikely ( ret < chars ) ) { error = - EFAULT ; <S2SV_ModEnd> <S2SV_ModStart> do_wakeup = 1 ; <S2SV_ModStart> ret = chars ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> <S2SV_ModStart> int copied <S2SV_ModEnd> <S2SV_ModStart> copied = copy_page_from_iter ( page , 0 , PAGE_SIZE , from <S2SV_ModEnd> <S2SV_ModStart> copied < PAGE_SIZE && iov_iter_count ( from ) ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> <S2SV_ModStart> copied <S2SV_ModEnd> <S2SV_ModStart> copied <S2SV_ModEnd> <S2SV_ModStart> if ( ! iov_iter_count ( from ) <S2SV_ModEnd> "
2843,"<S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> <S2SV_StartBug> if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || <S2SV_EndBug> <S2SV_StartBug> if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || <S2SV_EndBug> ","<S2SV_ModStart> ; u32 dst = insn -> dst_reg ; int ret <S2SV_ModStart> ret = sanitize_val_alu ( env , insn ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\n"" , dst ) ; return ret ; } <S2SV_ModStart> ret = sanitize_val_alu ( env , insn ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\n"" , dst ) ; return ret ; } "
2844,"<S2SV_StartBug> tlv = cp + i ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 2 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( i + 2 > length ) return - 1 ; <S2SV_ModStart> ; if ( i + 2 + optlen > length ) return - 1 
2845,<S2SV_StartBug> name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ; <S2SV_EndBug> ,<S2SV_ModStart> rmtvaluelen <S2SV_ModEnd> 
2846,<S2SV_StartBug> if ( shdr -> sh_size < 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> || shdr -> sh_size > SIZE_MAX 
2847,<S2SV_StartBug> const gchar * to = xmpp_stanza_get_to ( message ) ; <S2SV_EndBug> <S2SV_StartBug> Jid * jid_to = jid_create ( to ) ; <S2SV_EndBug> ,"<S2SV_ModStart> Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ; const char * const stanza_from = xmpp_stanza_get_from ( stanza ) ; Jid * msg_jid = jid_create ( stanza_from ) ; if ( g_strcmp0 ( my_jid -> barejid , msg_jid -> barejid ) != 0 ) { log_warning ( ""Invalid<S2SV_blank>carbon<S2SV_blank>received,<S2SV_blank>from:<S2SV_blank>%s"" , stanza_from ) ; return TRUE ; } <S2SV_ModStart>  <S2SV_ModEnd> "
2848,<S2SV_StartBug> buff [ r ] = '\\0' ; <S2SV_EndBug> ,"<S2SV_ModStart> MIN ( ( size_t ) r , ( sizeof buff ) - 1 ) <S2SV_ModEnd> "
2849,<S2SV_StartBug> return error ; <S2SV_EndBug> ,<S2SV_ModStart> < 0 ? error : 0 
2850,<S2SV_StartBug> if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; <S2SV_EndBug> ,<S2SV_ModStart> || num >= 256 
2851,"<S2SV_StartBug> register const u_char * tptr ) <S2SV_EndBug> <S2SV_StartBug> u_int hexdump = FALSE ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> , const u_int length ) { u_int network_addr_type ; u_int <S2SV_ModEnd> <S2SV_ModStart> if ( length < 1 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Network<S2SV_blank>Address<S2SV_blank>Type<S2SV_blank>(invalid,<S2SV_blank>no<S2SV_blank>data"" ) ) ; return hexdump ; } <S2SV_ModStart> if ( length != 1 + 4 ) { ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> if ( length != 1 + 16 ) { ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ; hexdump = TRUE ; break ; } "
2852,"<S2SV_StartBug> vpx_memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
2853,"<S2SV_StartBug> decoder_info -> log2_sb_size = get_flc ( 3 , stream ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; decoder_info -> log2_sb_size = clip ( decoder_info -> log2_sb_size , log2i ( MIN_BLOCK_SIZE ) , log2i ( MAX_SB_SIZE ) "
2854,"<S2SV_StartBug> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
2855,"<S2SV_StartBug> void vp9_write_nmv_probs ( VP9_COMMON * cm , int usehp , vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> nmv_context * const mvc = & cm -> fc . nmvc ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_writer * w , nmv_context_counts * const counts <S2SV_ModEnd> <S2SV_ModStart> -> nmvc ; <S2SV_ModEnd> "
2856,"<S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; <S2SV_EndBug> <S2SV_StartBug> pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , <S2SV_EndBug> <S2SV_StartBug> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> ","<S2SV_ModStart> rows ; rows = MagickMax ( GetImageListLength ( images ) , <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> rows , <S2SV_ModEnd> <S2SV_ModStart> columns = MaxPixelChannels ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 <S2SV_ModEnd> <S2SV_ModStart> rows <S2SV_ModEnd> "
2857,"<S2SV_StartBug> int frame_count , <S2SV_EndBug> <S2SV_StartBug> int mb_cols = cpi -> common . mb_cols ; <S2SV_EndBug> <S2SV_StartBug> int mb_rows = cpi -> common . mb_rows ; <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , unsigned int , accumulator , 16 * 16 * 3 ) ; <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , uint16_t , count , 16 * 16 * 3 ) ; <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * mbd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> YV12_BUFFER_CONFIG * f = cpi -> frames [ alt_ref_index ] ; <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , predictor , 16 * 16 * 3 ) ; <S2SV_EndBug> <S2SV_StartBug> uint8_t * input_buffer [ MAX_MB_PLANE ] ; <S2SV_EndBug> <S2SV_StartBug> assert ( mbd -> plane [ 1 ] . subsampling_x == mbd -> plane [ 1 ] . subsampling_y ) ; <S2SV_EndBug> <S2SV_StartBug> # if ALT_REF_MC_ENABLED <S2SV_EndBug> <S2SV_StartBug> cpi -> mb . mv_row_max = ( ( cpi -> common . mb_rows - 1 - mb_row ) * 16 ) <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( accumulator , 0 , 16 * 16 * 3 * sizeof ( accumulator [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( count , 0 , 16 * 16 * 3 * sizeof ( count [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> # if ALT_REF_MC_ENABLED <S2SV_EndBug> <S2SV_StartBug> cpi -> mb . mv_col_max = ( ( cpi -> common . mb_cols - 1 - mb_col ) * 16 ) <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> frames [ frame ] == NULL ) <S2SV_EndBug> <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> frames [ alt_ref_index ] -> y_buffer + mb_y_offset , <S2SV_EndBug> <S2SV_StartBug> cpi -> frames [ frame ] -> y_buffer + mb_y_offset , <S2SV_EndBug> <S2SV_StartBug> cpi -> frames [ frame ] -> y_stride ) ; <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> filter_weight = err < THRESH_LOW <S2SV_EndBug> <S2SV_StartBug> ? 2 : err < THRESH_HIGH ? 1 : 0 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> frames [ frame ] -> y_buffer + mb_y_offset , <S2SV_EndBug> <S2SV_StartBug> pval *= cpi -> fixed_divide [ count [ k ] ] ; <S2SV_EndBug> <S2SV_StartBug> dst1 [ byte ] = ( uint8_t ) pval ; <S2SV_EndBug> <S2SV_StartBug> stride = cpi -> alt_ref_buffer . uv_stride ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < mb_uv_height ; j ++ , k ++ ) { <S2SV_EndBug> <S2SV_StartBug> pval *= cpi -> fixed_divide [ count [ k ] ] ; <S2SV_EndBug> <S2SV_StartBug> dst1 [ byte ] = ( uint8_t ) pval ; <S2SV_EndBug> <S2SV_StartBug> pval *= cpi -> fixed_divide [ count [ m ] ] ; <S2SV_EndBug> <S2SV_StartBug> dst2 [ byte ] = ( uint8_t ) pval ; <S2SV_EndBug> <S2SV_StartBug> byte += stride - mb_uv_height ; <S2SV_EndBug> <S2SV_StartBug> mb_y_offset += 16 ; <S2SV_EndBug> <S2SV_StartBug> mb_uv_offset += mb_uv_height ; <S2SV_EndBug> <S2SV_StartBug> mb_uv_offset += mb_uv_height * ( f -> uv_stride - mb_cols ) ; <S2SV_EndBug> ","<S2SV_ModStart> YV12_BUFFER_CONFIG * * frames , <S2SV_ModStart> ( frames [ alt_ref_index ] -> y_crop_width + 15 ) >> 4 <S2SV_ModEnd> <S2SV_ModStart> ( frames [ alt_ref_index ] -> y_crop_height + 15 ) >> 4 <S2SV_ModEnd> <S2SV_ModStart> DECLARE_ALIGNED <S2SV_ModEnd> <S2SV_ModStart> [ <S2SV_ModEnd> <S2SV_ModStart> ] ) ; DECLARE_ALIGNED <S2SV_ModEnd> <S2SV_ModStart> [ <S2SV_ModEnd> <S2SV_ModStart> ] <S2SV_ModStart> td . <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , predictor16 [ 16 * 16 * 3 ] ) ; DECLARE_ALIGNED <S2SV_ModEnd> <S2SV_ModStart> predictor8 [ 16 * 16 * 3 ] ) ; uint8_t * predictor ; # else DECLARE_ALIGNED ( 16 , uint8_t , predictor [ <S2SV_ModEnd> <S2SV_ModStart> ] ) ; # endif <S2SV_ModEnd> <S2SV_ModStart> const int mb_uv_width = 16 >> mbd -> plane [ 1 ] . subsampling_x ; <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if <S2SV_ModEnd> <S2SV_ModStart> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { predictor = CONVERT_TO_BYTEPTR ( predictor16 ) ; } else { predictor = predictor8 ; } # endif <S2SV_ModEnd> <S2SV_ModStart> cpi -> td . <S2SV_ModEnd> <S2SV_ModStart> td . <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> cpi -> td . <S2SV_ModEnd> <S2SV_ModStart> td . <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const int thresh_low = 10000 ; const int thresh_high = 20000 ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> thresh_low <S2SV_ModEnd> <S2SV_ModStart> thresh_high <S2SV_ModEnd> <S2SV_ModStart> frames [ frame ] -> y_buffer + mb_y_offset , frames [ frame ] -> u_buffer + mb_uv_offset , frames [ frame ] -> v_buffer + mb_uv_offset , frames [ frame ] -> y_stride , mb_uv_width , mb_uv_height , mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . row , mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . col , predictor , scale , mb_col * 16 , mb_row * 16 ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( mbd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { int adj_strength = strength + 2 * ( mbd -> bd - 8 ) ; vp9_highbd_temporal_filter_apply ( f -> y_buffer + mb_y_offset , f -> y_stride , predictor , 16 , 16 , adj_strength , filter_weight , accumulator , count ) ; vp9_highbd_temporal_filter_apply ( f -> u_buffer + mb_uv_offset , f -> uv_stride , predictor + 256 , mb_uv_width , mb_uv_height , adj_strength , filter_weight , accumulator + 256 , count + 256 ) ; vp9_highbd_temporal_filter_apply ( f -> v_buffer + mb_uv_offset , f -> uv_stride , predictor + 512 , mb_uv_width , mb_uv_height , adj_strength , filter_weight , accumulator + 512 , count + 512 ) ; } else { vp9_temporal_filter_apply ( f -> y_buffer + mb_y_offset , f -> y_stride , predictor , 16 , 16 , strength , filter_weight , accumulator , count ) ; vp9_temporal_filter_apply ( f -> u_buffer + mb_uv_offset , f -> uv_stride , predictor + 256 , mb_uv_width , mb_uv_height , strength , filter_weight , accumulator + 256 , count + 256 ) ; vp9_temporal_filter_apply ( f -> v_buffer + mb_uv_offset , f -> uv_stride , predictor + 512 , mb_uv_width , mb_uv_height , strength , filter_weight , accumulator + 512 , count + 512 ) ; } # else vp9_temporal_filter_apply ( f -> y_buffer + mb_y_offset , f -> y_stride , predictor , 16 , 16 , strength , filter_weight , accumulator , count ) ; vp9_temporal_filter_apply ( f -> u_buffer + mb_uv_offset , f -> uv_stride , predictor + 256 , mb_uv_width , mb_uv_height , strength , filter_weight , accumulator + 256 , count + 256 ) ; vp9_temporal_filter_apply ( f -> v_buffer + mb_uv_offset , f -> uv_stride , predictor + 512 , mb_uv_width , mb_uv_height , strength , filter_weight , accumulator + 512 , count + 512 ) ; # endif } } # if CONFIG_VP9_HIGHBITDEPTH if ( mbd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { uint16_t * dst1_16 ; uint16_t * dst2_16 ; dst1 = cpi -> alt_ref_buffer . y_buffer ; dst1_16 = CONVERT_TO_SHORTPTR ( dst1 ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dst1_16 [ byte ] = ( uint16_t <S2SV_ModEnd> <S2SV_ModStart> dst1_16 = CONVERT_TO_SHORTPTR ( dst1 ) ; dst2_16 = CONVERT_TO_SHORTPTR ( dst2 ) ; <S2SV_ModStart> mb_uv_width <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dst1_16 [ byte ] = ( uint16_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dst2_16 [ byte ] = ( uint16_t <S2SV_ModEnd> <S2SV_ModStart> mb_uv_width ; } } else { dst1 = cpi -> alt_ref_buffer . y_buffer ; stride = cpi -> alt_ref_buffer . y_stride ; byte = mb_y_offset ; for ( i = 0 , k = 0 ; i < 16 ; i ++ ) { for ( j = 0 ; j < 16 ; j ++ , k ++ ) { unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; pval *= fixed_divide [ count [ k ] ] ; pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ; byte ++ ; } byte += stride - 16 ; } dst1 = cpi -> alt_ref_buffer . u_buffer ; dst2 = cpi -> alt_ref_buffer . v_buffer ; stride = cpi -> alt_ref_buffer . uv_stride ; byte = mb_uv_offset ; for ( i = 0 , k = 256 ; i < mb_uv_height ; i ++ ) { for ( j = 0 ; j < mb_uv_width ; j ++ , k ++ ) { int m = k + 256 ; unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; pval *= fixed_divide [ count [ k ] ] ; pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ; pval = accumulator [ m ] + ( count [ m ] >> 1 ) ; pval *= fixed_divide [ count [ m ] ] ; pval >>= 19 ; dst2 [ byte ] = ( uint8_t ) pval ; byte ++ ; } byte += stride - mb_uv_width ; } } # else dst1 = cpi -> alt_ref_buffer . y_buffer ; stride = cpi -> alt_ref_buffer . y_stride ; byte = mb_y_offset ; for ( i = 0 , k = 0 ; i < 16 ; i ++ ) { for ( j = 0 ; j < 16 ; j ++ , k ++ ) { unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; pval *= fixed_divide [ count [ k ] ] ; pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ; byte ++ ; } byte += stride - 16 ; } dst1 = cpi -> alt_ref_buffer . u_buffer ; dst2 = cpi -> alt_ref_buffer . v_buffer ; stride = cpi -> alt_ref_buffer . uv_stride ; byte = mb_uv_offset ; for ( i = 0 , k = 256 ; i < mb_uv_height ; i ++ ) { for ( j = 0 ; j < mb_uv_width ; j ++ , k ++ ) { int m = k + 256 ; unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; pval *= fixed_divide [ count [ k ] ] ; pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ; pval = accumulator [ m ] + ( count [ m ] >> 1 ) ; pval *= fixed_divide [ count [ m ] ] ; pval >>= 19 ; dst2 [ byte ] = ( uint8_t ) pval ; byte ++ ; } byte += stride - mb_uv_width ; } # endif <S2SV_ModEnd> <S2SV_ModStart> ; mb_uv_offset += mb_uv_width ; } mb_y_offset += 16 * ( f -> y_stride - mb_cols ) <S2SV_ModStart> * <S2SV_ModEnd> <S2SV_ModStart> mb_uv_width * mb_cols <S2SV_ModEnd> "
2858,<S2SV_StartBug> if ( l >= ( len - o ) ) { <S2SV_EndBug> ,<S2SV_ModStart> - 4 
2859,<S2SV_StartBug> if ( ! rtlpriv -> usb_data ) <S2SV_EndBug> <S2SV_StartBug> spin_lock_init ( & rtlpriv -> locks . usb_lock ) ; <S2SV_EndBug> <S2SV_StartBug> complete ( & rtlpriv -> firmware_loading_complete ) ; <S2SV_EndBug> ,<S2SV_ModStart> { ieee80211_free_hw ( hw ) ; <S2SV_ModStart> } <S2SV_ModStart> ) ; kfree ( rtlpriv -> usb_data 
2860,"<S2SV_StartBug> ihevcd_ref_list ( ps_codec , ps_pps , ps_sps , ps_slice_hdr ) ; <S2SV_EndBug> ",<S2SV_ModStart> ret = <S2SV_ModStart> if ( ( WORD32 ) IHEVCD_SUCCESS != ret ) { return ret ; } 
2861,<S2SV_StartBug> while ( collen > 0 ) <S2SV_EndBug> <S2SV_StartBug> while ( replen > 0 ) <S2SV_EndBug> <S2SV_StartBug> while ( collen > 0 ) <S2SV_EndBug> <S2SV_StartBug> while ( replen > 0 ) <S2SV_EndBug> ,<S2SV_ModStart> indexw < width && <S2SV_ModStart> indexw < width && <S2SV_ModStart> indexw < width && <S2SV_ModStart> indexw < width && 
2862,<S2SV_StartBug> if ( g -> sect <= 0 || <S2SV_EndBug> <S2SV_StartBug> g -> head <= 0 || <S2SV_EndBug> ,<S2SV_ModStart> ( int ) <S2SV_ModStart> ( int ) <S2SV_ModStart> <= 0 || ( int ) ( g -> sect * g -> head ) 
2863,"<S2SV_StartBug> int retval = 0 ; <S2SV_EndBug> <S2SV_StartBug> retval = - ENODEV ; <S2SV_EndBug> <S2SV_StartBug> bytes_read = snprintf ( in_buffer , 20 , ""%lld\\n"" , dev -> bbu ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * ppos < bytes_read ) { <S2SV_EndBug> <S2SV_StartBug> return retval ; <S2SV_EndBug> ","<S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & dev -> io_mutex ) ; return - ENODEV <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> simple_read_from_buffer ( buffer , count , ppos , in_buffer , len ) <S2SV_ModEnd> "
2864,<S2SV_StartBug> draw_info -> geometry = AcquireString ( geometry ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ( void ) CloneString ( & <S2SV_ModStart> , <S2SV_ModEnd> "
2865,"<S2SV_StartBug> isoclns_print ( ndo , p , length , caplen ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2866,<S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> int layer ; <S2SV_EndBug> <S2SV_StartBug> if ( svc -> number_temporal_layers > 1 ) { <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * const lc = & svc -> layer_context [ layer ] ; <S2SV_EndBug> ,"<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> sl , tl ; int alt_ref_idx = svc -> number_spatial_layers ; svc -> spatial_layer_id = 0 ; svc -> temporal_layer_id = 0 ; if ( cpi -> oxcf . error_resilient_mode == 0 && cpi -> oxcf . pass == 2 ) { if ( vpx_realloc_frame_buffer ( & cpi -> svc . empty_frame . img , SMALL_FRAME_WIDTH , SMALL_FRAME_HEIGHT , cpi -> common . subsampling_x , cpi -> common . subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH cpi -> common . use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , cpi -> common . byte_alignment , NULL , NULL , NULL ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>empty<S2SV_blank>frame<S2SV_blank>for<S2SV_blank>multiple<S2SV_blank>frame<S2SV_blank>"" ""contexts"" ) ; memset ( cpi -> svc . empty_frame . img . buffer_alloc , 0x80 , cpi -> svc . empty_frame . img . buffer_alloc_sz ) ; } for ( sl = 0 ; sl < oxcf -> ss_number_layers ; ++ sl ) { for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { int layer = LAYER_IDS_TO_IDX ( sl , tl , oxcf -> ts_number_layers ) ; LAYER_CONTEXT * const lc = & svc -> layer_context [ layer ] ; RATE_CONTROL * const lrc = & lc -> rc ; int i ; lc -> current_video_frame_in_layer = 0 ; lc -> layer_size = 0 ; lc -> frames_from_key_frame = 0 ; lc -> last_frame_type = FRAME_TYPES ; lrc -> ni_av_qi = oxcf -> worst_allowed_q ; lrc -> total_actual_bits = 0 ; lrc -> total_target_vs_actual = 0 ; lrc -> ni_tot_qi = 0 ; lrc -> tot_q = 0.0 ; lrc -> avg_q = 0.0 ; lrc -> ni_frames = 0 ; lrc -> decimation_count = 0 ; lrc -> decimation_factor = 0 ; for ( i = 0 ; i < RATE_FACTOR_LEVELS ; ++ i ) { lrc -> rate_correction_factors [ i ] = 1.0 ; } if ( cpi -> oxcf . rc_mode == VPX_CBR ) { lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; lrc -> last_q [ INTER_FRAME ] = oxcf -> worst_allowed_q ; lrc -> avg_frame_qindex [ INTER_FRAME ] = oxcf -> worst_allowed_q ; lrc -> avg_frame_qindex [ KEY_FRAME ] = oxcf -> worst_allowed_q ; } else { lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; lrc -> last_q [ KEY_FRAME ] = oxcf -> best_allowed_q ; lrc -> last_q [ INTER_FRAME ] = oxcf -> best_allowed_q ; lrc -> avg_frame_qindex [ KEY_FRAME ] = ( oxcf -> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ; lrc -> avg_frame_qindex [ INTER_FRAME ] = ( oxcf -> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ; if ( oxcf -> ss_enable_auto_arf [ sl ] ) lc -> alt_ref_idx = alt_ref_idx ++ ; else lc -> alt_ref_idx = INVALID_IDX ; lc -> gold_ref_idx = INVALID_IDX ; } lrc -> buffer_level = oxcf -> starting_buffer_level_ms * lc -> target_bandwidth / 1000 ; lrc -> bits_off_target = lrc -> buffer_level ; } } if ( ! <S2SV_ModEnd> <S2SV_ModStart> && cpi -> oxcf . rc_mode == VPX_CBR ) && alt_ref_idx < REF_FRAMES ) <S2SV_ModEnd> <S2SV_ModStart> 0 ] . gold_ref_idx = alt_ref_idx ; <S2SV_ModEnd> "
2867,"<S2SV_StartBug> struct inode * inode = page -> mapping -> host ; <S2SV_EndBug> <S2SV_StartBug> ret = f2fs_mpage_readpages ( page -> mapping , NULL , page , 1 , false ) ; <S2SV_EndBug> ",<S2SV_ModStart> page_file_mapping ( page ) <S2SV_ModEnd> <S2SV_ModStart> page_file_mapping ( page ) <S2SV_ModEnd> 
2868,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> hook_del_nick_can_register ( check_registration_keywords ) ; hook_del_user_can_register ( check_registration_keywords ) ; del_conf_item ( ""ANOPE_FLAGS_COMPAT"" , & chansvs . me -> conf_table ) ; "
2869,<S2SV_StartBug> ddi . dinfo_nboards = dgnc_NumBoards ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & ddi , 0 , sizeof ( ddi ) ) ; "
2870,<S2SV_StartBug> if ( po -> fanout ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> lock_sock ( sk ) ; spin_lock ( & po -> bind_lock ) ; rcu_read_lock ( ) ; <S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto out_unlock ; } <S2SV_ModEnd> 
2871,<S2SV_StartBug> ps_dec -> u2_total_mbs_coded ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( u1_tfr_n_mb ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ps_dec -> u2_total_mbs_coded += u1_num_mbs ; 
2872,"<S2SV_StartBug> if ( list_empty ( & EXT4_I ( inode ) -> i_completed_io_list ) ) { <S2SV_EndBug> <S2SV_StartBug> ext4_debug ( ""Dump<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>completed_io<S2SV_blank>list<S2SV_blank>\\n"" , inode -> i_ino ) ; <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ","<S2SV_ModStart> unsigned long flags ; <S2SV_ModStart> ) ; spin_lock_irqsave ( & EXT4_I ( inode ) -> i_completed_io_lock , flags <S2SV_ModStart> spin_unlock_irqrestore ( & EXT4_I ( inode ) -> i_completed_io_lock , flags ) ; "
2873,"<S2SV_StartBug> static int __perf_event_overflow ( struct perf_event * event , int nmi , <S2SV_EndBug> <S2SV_StartBug> if ( nmi ) { <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> perf_event_output ( event , nmi , data , regs ) ; <S2SV_EndBug> <S2SV_StartBug> if ( nmi ) { <S2SV_EndBug> <S2SV_StartBug> irq_work_queue ( & event -> pending ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( event -> overflow_handler ) event -> overflow_handler ( event , data , regs ) ; else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2874,"<S2SV_StartBug> assert_regexp_syntax_error ( "")"" ) ; <S2SV_EndBug> <S2SV_StartBug> ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>317<S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}?t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>314<S2SV_blank>}"" , <S2SV_EndBug> ","<S2SV_ModStart> assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""\\0a\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""\\ta\\0b\\0c\\0"" ) ; assert_false_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""x\\0a\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""x\\ta\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0\\t"" ) ; assert_false_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0x\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0b\\t"" ) ; assert_false_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""abc"" ) ; <S2SV_ModStart> ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>317<S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}?t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>314<S2SV_blank>}"" <S2SV_ModEnd> "
2875,"<S2SV_StartBug> static int jas_iccputsint ( jas_stream_t * out , int n , longlong val ) <S2SV_EndBug> <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> ",<S2SV_ModStart> jas_longlong <S2SV_ModEnd> <S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> 
2876,"<S2SV_StartBug> rc = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> return rc ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( rc ) return rc ; inode -> i_ctime = CURRENT_TIME ; mark_inode_dirty ( inode ) ; } break ; case ACL_TYPE_DEFAULT : ea_name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) return - ENOMEM ; rc = posix_acl_to_xattr ( & init_user_ns , acl , value , size <S2SV_ModStart>  <S2SV_ModEnd> "
2877,<S2SV_StartBug> pirlvl = pi -> picomp -> pirlvls ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || <S2SV_EndBug> <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || <S2SV_EndBug> ,"<S2SV_ModStart> if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> "
2878,"<S2SV_StartBug> static int changedline ( const Proto * p , int oldpc , int newpc ) { <S2SV_EndBug> ",<S2SV_ModStart> if ( p -> lineinfo == NULL ) return 0 ; 
2879,"<S2SV_StartBug> p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ; <S2SV_EndBug> <S2SV_StartBug> pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , & unmounted ) ; <S2SV_EndBug> <S2SV_StartBug> umount_mnt ( p ) ; <S2SV_EndBug> <S2SV_StartBug> change_mnt_propagation ( p , MS_PRIVATE ) ; <S2SV_EndBug> ","<S2SV_ModStart> bool disconnect ; <S2SV_ModStart> disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_ModStart> disconnect ? & unmounted : NULL <S2SV_ModEnd> <S2SV_ModStart> if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { <S2SV_ModStart> } "
2880,"<S2SV_StartBug> static void encode_frame ( vpx_codec_ctx_t * codec , <S2SV_EndBug> <S2SV_StartBug> VpxVideoWriter * writer ) { <S2SV_EndBug> <S2SV_StartBug> while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int got_pkts = 0 ; <S2SV_ModStart> got_pkts = 1 ; <S2SV_ModStart> return got_pkts ; 
2881,<S2SV_StartBug> for ( x = 0 ; x < ( ssize_t ) number_pixels ; x += 2 ) <S2SV_EndBug> ,<S2SV_ModStart> 4 <S2SV_ModEnd> 
2882,"<S2SV_StartBug> static VALUE from_document ( VALUE klass , VALUE document ) <S2SV_EndBug> <S2SV_StartBug> return rb_schema ; <S2SV_EndBug> ","<S2SV_ModStart> int argc , VALUE * argv , VALUE klass ) { VALUE document ; VALUE parse_options ; xmlDocPtr doc ; xmlRelaxNGParserCtxtPtr ctx ; xmlRelaxNGPtr schema ; VALUE errors ; VALUE rb_schema ; int scanned_args = 0 ; scanned_args = rb_scan_args ( argc , argv , ""11"" , & document , & parse_options ) ; Data_Get_Struct ( document , xmlDoc , doc ) ; doc = doc -> doc ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( ""ParseOptions"" ) ) , rb_intern ( ""DEFAULT_SCHEMA"" ) ) ; } <S2SV_ModEnd> <S2SV_ModStart> rb_iv_set ( rb_schema , ""@parse_options"" , parse_options ) ; "
2883,"<S2SV_StartBug> ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; <S2SV_EndBug> <S2SV_StartBug> setup_syscalls_segments ( ctxt , & cs , & ss ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! ( em_syscall_is_enabled ( ctxt ) ) ) return emulate_ud ( ctxt ) ; <S2SV_ModStart> ) ; if ( ! ( efer & EFER_SCE ) ) return emulate_ud ( ctxt 
2884,"<S2SV_StartBug> static void send ( node_t * node , node_t * child , byte * fout ) { <S2SV_EndBug> <S2SV_StartBug> send ( node -> parent , node , fout ) ; <S2SV_EndBug> <S2SV_StartBug> if ( child ) { <S2SV_EndBug> ","<S2SV_ModStart> , int maxoffset <S2SV_ModStart> , maxoffset <S2SV_ModStart> if ( bloc >= maxoffset ) { bloc = maxoffset + 1 ; return ; } "
2885,"<S2SV_StartBug> int bytes_read = read ( reader -> inbound_fd , buffer -> data , reader -> buffer_size ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
2886,"<S2SV_StartBug> if ( ! revs -> blob_objects ) <S2SV_EndBug> <S2SV_StartBug> show ( obj , path , name , cb_data ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> size_t pathlen ; <S2SV_ModStart> pathlen = path -> len ; strbuf_addstr ( path , name ) ; <S2SV_ModStart> -> buf <S2SV_ModEnd> <S2SV_ModStart> strbuf_setlen ( path , pathlen ) ; "
2887,"<S2SV_StartBug> yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ; <S2SV_EndBug> <S2SV_StartBug> yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ; <S2SV_EndBug> <S2SV_StartBug> yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" <S2SV_ModEnd> <S2SV_ModStart> ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" <S2SV_ModEnd> <S2SV_ModStart> ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" <S2SV_ModEnd> "
2888,"<S2SV_StartBug> static bool new_idmap_permitted ( struct user_namespace * ns , int cap_setid , <S2SV_EndBug> <S2SV_StartBug> if ( ns_capable ( ns -> parent , cap_setid ) ) <S2SV_EndBug> ","<S2SV_ModStart> const struct file * file , <S2SV_ModStart> && file_ns_capable ( file , ns -> parent , cap_setid ) "
2889,"<S2SV_StartBug> unsigned long cs ; <S2SV_EndBug> <S2SV_StartBug> rc = emulate_pop ( ctxt , & ctxt -> _eip , ctxt -> op_bytes ) ; <S2SV_EndBug> <S2SV_StartBug> return rc ; <S2SV_EndBug> <S2SV_StartBug> rc = load_segment_descriptor ( ctxt , ( u16 ) cs , VCPU_SREG_CS ) ; <S2SV_EndBug> ","<S2SV_ModStart> eip , cs ; u16 old_cs <S2SV_ModEnd> <S2SV_ModStart> struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , VCPU_SREG_CS ) ; <S2SV_ModStart> eip <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> __load_segment_descriptor <S2SV_ModEnd> <S2SV_ModStart> , 0 , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_far ( ctxt , eip , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; } <S2SV_ModEnd> "
2890,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> return body ; <S2SV_EndBug> ,<S2SV_ModStart> { if ( a -> type == szMAPI_BINARY ) <S2SV_ModStart> } 
2891,"<S2SV_StartBug> sc_debug ( card -> ctx , SC_LOG_DEBUG_NORMAL , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> if ( bufLen < 2 ) break ; <S2SV_ModStart> bufLen -= 2 ; 
2892,"<S2SV_StartBug> rval = tpm_kdfa ( sapi_context , session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2893,"<S2SV_StartBug> ( mutt_bcache_exists ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) == 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> cache_id ( ctx -> hdrs [ i ] -> data ) <S2SV_ModEnd> 
2894,<S2SV_StartBug> struct iovec iov ; <S2SV_EndBug> <S2SV_StartBug> if ( ret < local_nr_pages ) { <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < nr_pages ; j ++ ) { <S2SV_EndBug> ,"<S2SV_ModStart> ; struct bio_vec * bvec <S2SV_ModStart> unlikely ( <S2SV_ModStart> ) { for ( j = cur_page ; j < page_limit ; j ++ ) { if ( ! pages [ j ] ) break ; put_page ( pages [ j ] ) ; } <S2SV_ModEnd> <S2SV_ModStart> bio_for_each_segment_all ( bvec , bio , j ) { put_page ( bvec -> bv_page <S2SV_ModEnd> "
2895,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , regs -> ARM_pc ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
2896,"<S2SV_StartBug> ut8 * buf = calloc ( to - from , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> r_buf_read_at ( bf -> buf , from , buf , to - from ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( to - needle ) > 5 ) { <S2SV_EndBug> <S2SV_StartBug> bool is_wide32 = needle + rc + 2 < to && ! w [ 0 ] && ! w [ 1 ] && ! w [ 2 ] && w [ 3 ] && ! w [ 4 ] ; <S2SV_EndBug> ",<S2SV_ModStart> int len = to - from ; <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> + rc <S2SV_ModStart> ( <S2SV_ModStart> ) && ( <S2SV_ModEnd> <S2SV_ModStart> ) 
2897,"
","
"
2898,"<S2SV_StartBug> rd_create_ui ( ) ; <S2SV_EndBug> <S2SV_StartBug> in_uint16_le ( s , len_combined_caps ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct stream packet = * s ; <S2SV_ModStart> if ( ! s_check_rem ( s , len_src_descriptor ) ) { rdp_protocol_error ( ""rdp_demand_active(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>source<S2SV_blank>descriptor<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } "
2899,<S2SV_StartBug> block_length = data [ i ] * 256 + data [ i + 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart> if ( i + 1 < data_size ) 
2900,"<S2SV_StartBug> switch ( type ) <S2SV_EndBug> <S2SV_StartBug> SetPixelIndex ( image , ( ( ( unsigned char ) pixel ) & <S2SV_EndBug> <S2SV_StartBug> ( 0x01 << ( 7 - bit ) ) ) != 0 ? 0 : 255 , q ) ; <S2SV_EndBug> <S2SV_StartBug> x -- ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ","<S2SV_ModStart> if ( image -> depth > 1 ) { SetPSDPixel ( image , channels , type , packet_size , pixel , q , exception ) ; q += GetPixelChannels ( image ) ; } else <S2SV_ModEnd> <S2SV_ModStart> SetPSDPixel ( image , channels , type , packet_size <S2SV_ModEnd> <S2SV_ModStart> , exception <S2SV_ModEnd> <S2SV_ModStart> if ( x != image -> columns ) <S2SV_ModStart>  <S2SV_ModEnd> "
2901,<S2SV_StartBug> if ( sock -> type == SOCK_RAW ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> sock -> ops = & rawsock_ops ; <S2SV_EndBug> ,<S2SV_ModStart> { if ( ! capable ( CAP_NET_RAW ) ) return - EPERM ; <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> } 
2902,<S2SV_StartBug> set_caps ( ) ; <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> fs_rdonly ( RUN_SECCOMP_DIR ) ; # endif set_caps ( ) ; <S2SV_ModEnd> 
2903,<S2SV_StartBug> siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . hsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . vsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } "
2904,<S2SV_StartBug> if ( ( temp_buffer & 0xffffff00 ) != 0x100 ) <S2SV_EndBug> <S2SV_StartBug> else if ( temp_buffer < 0x120 ) <S2SV_EndBug> <S2SV_StartBug> else if ( temp_buffer < 0x130 ) <S2SV_EndBug> ,<S2SV_ModStart> temp_buffer & 0xfffffe00 ) continue ; if ( temp_buffer < 2 <S2SV_ModEnd> <S2SV_ModStart> >= 0x100 && temp_buffer <S2SV_ModStart> temp_buffer >= 0x120 && 
2905,<S2SV_StartBug> if ( ! curbuf -> b_p_ma && ( ea . argt & MODIFY ) ) <S2SV_EndBug> ,"<S2SV_ModStart> restricted != 0 && ( ea . argt & RESTRICT ) ) { errormsg = _ ( ""E981:<S2SV_blank>Command<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim"" ) ; goto doend ; } if ( "
2906,"<S2SV_StartBug> chip -> data_buffer = kmalloc ( TPM_BUFSIZE * sizeof ( u8 ) , GFP_KERNEL ) ; <S2SV_EndBug> ",<S2SV_ModStart> kzalloc ( TPM_BUFSIZE <S2SV_ModEnd> 
2907,<S2SV_StartBug> unsigned int channo ; <S2SV_EndBug> ,<S2SV_ModStart> ; cdef -> ents = 0 
2908,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> } else if ( request_size < 0 ) { rc = - EINVAL ; goto out_free_buffer ; 
2909,"<S2SV_StartBug> guchar * match ; <S2SV_EndBug> <S2SV_StartBug> gsize to_match = MIN ( left , buffer -> pos ) ; <S2SV_EndBug> <S2SV_StartBug> if ( memcmp ( buffer -> data , & AUTH_END_STRING [ client -> auth_end_offset ] , to_match ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> return match - buffer -> data + strlen ( AUTH_END_STRING ) ; <S2SV_EndBug> ","<S2SV_ModStart> goffset offset = 0 ; gsize original_size = client -> auth_buffer -> len ; g_byte_array_append ( client -> auth_buffer <S2SV_ModEnd> <S2SV_ModStart> data , buffer -> <S2SV_ModStart> while ( TRUE ) { guint8 * line_start = client -> auth_buffer <S2SV_ModEnd> <S2SV_ModStart> offset ; gsize remaining_data = client -> auth_buffer -> len - offset ; guint8 * line_end ; line_end = memmem ( line_start , remaining_data , AUTH_LINE_SENTINEL , strlen ( AUTH_LINE_SENTINEL ) ) ; if ( line_end ) { offset = ( line_end + strlen ( AUTH_LINE_SENTINEL ) - line_start ) ; if ( ! auth_line_is_valid ( line_start , line_end ) ) return FIND_AUTH_END_ABORT ; * line_end = 0 ; if ( auth_line_is_begin ( line_start ) ) return offset - original_size ; } else { g_byte_array_remove_range ( client -> auth_buffer , 0 , offset ) ; if ( client -> auth_buffer -> len >= 16 * 1024 ) return FIND_AUTH_END_ABORT ; return FIND_AUTH_END_CONTINUE ; } } <S2SV_ModEnd> "
2910,<S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> strict = true ; 
2911,<S2SV_StartBug> # if ! ( CONFIG_FAST_UNALIGNED ) <S2SV_EndBug> ,"<S2SV_ModStart> memcpy ( dst , src , 8 ) ; <S2SV_ModEnd> "
2912,<S2SV_StartBug> size_t i ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2913,<S2SV_StartBug> ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( ps_dec ) ; <S2SV_EndBug> ,<S2SV_ModStart> { i_temp = ih264d_read_mmco_commands ( ps_dec ) ; if ( i_temp < 0 ) { return ERROR_DBP_MANAGER_T ; } <S2SV_ModStart> i_temp ; } <S2SV_ModEnd> 
2914,<S2SV_StartBug> ( Rec2 . RecordLength - 2 - 2 ) / 3 ) <S2SV_EndBug> ,"<S2SV_ModStart> ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries "
2915,<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> ,<S2SV_ModStart> void 
2916,"<S2SV_StartBug> # define PAM_END ( msg ) do { syslog ( LOG_ERR , ""%s:<S2SV_blank>%s"" , msg , pam_strerror ( pamh , pam_err ) ) ; warnx ( ""%s:<S2SV_blank>%s"" , msg , pam_strerror ( pamh , pam_err ) ) ; pam_end ( pamh , pam_err ) ; exit ( EXIT_FAILURE ) ; } while ( 0 ) <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> # ifndef HAVE_LOGIN_CAP_H <S2SV_EndBug> ","<S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> else # if defined ( __linux__ ) || defined ( __FreeBSD__ ) || defined ( __NetBSD__ ) if ( setresgid ( target_pw -> pw_gid , target_pw -> pw_gid , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""setresgid"" ) ; # else if ( setregid ( target_pw -> pw_gid , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""setregid"" ) ; # endif if ( initgroups ( target_pw -> pw_name , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""initgroups"" ) ; # if defined ( __linux__ ) || defined ( __FreeBSD__ ) || defined ( __NetBSD__ ) if ( setresuid ( target , target , target ) == - 1 ) err ( 1 , ""setresuid"" ) ; # else if ( setreuid ( target , target ) == - 1 ) err ( 1 , ""setreuid"" ) ; # endif # <S2SV_ModStart>  <S2SV_ModEnd> "
2917,<S2SV_StartBug> be32_to_cpu ( agf -> agf_flcount ) <= xfs_agfl_size ( mp ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( bp -> b_pag && be32_to_cpu ( agf -> agf_seqno ) != bp -> b_pag -> pag_agno ) <S2SV_EndBug> <S2SV_StartBug> be32_to_cpu ( agf -> agf_btreeblks ) > be32_to_cpu ( agf -> agf_length ) ) <S2SV_EndBug> ,<S2SV_ModStart> ) ) return __this_address ; if ( be32_to_cpu ( agf -> agf_length ) > mp -> m_sb . sb_dblocks ) return __this_address ; if ( be32_to_cpu ( agf -> agf_freeblks ) < be32_to_cpu ( agf -> agf_longest ) || be32_to_cpu ( agf -> agf_freeblks ) > be32_to_cpu ( agf -> agf_length <S2SV_ModStart> xfs_sb_version_hasrmapbt ( & mp -> m_sb ) && be32_to_cpu ( agf -> agf_rmap_blocks ) > be32_to_cpu ( agf -> agf_length ) ) return __this_address ; if ( <S2SV_ModStart> be32_to_cpu ( agf -> agf_length ) ) return __this_address ; if ( xfs_sb_version_hasreflink ( & mp -> m_sb ) && be32_to_cpu ( agf -> agf_refcount_blocks ) > 
2918,"<S2SV_StartBug> skb -> ip_summed = CHECKSUM_PARTIAL ; <S2SV_EndBug> <S2SV_StartBug> __skb_queue_tail ( queue , skb ) ; <S2SV_EndBug> ","<S2SV_ModStart> csum = 0 ; __skb_queue_tail ( queue , skb ) ; } else if ( skb_is_gso ( skb ) ) { goto append ; } skb -> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> append : <S2SV_ModEnd> "
2919,"<S2SV_StartBug> int byte_count = 0 , count ; <S2SV_EndBug> <S2SV_StartBug> { switch ( c ) <S2SV_EndBug> <S2SV_StartBug> ucptr = ( unsigned char * ) intptr ; <S2SV_EndBug> <S2SV_StartBug> intptr = va_arg ( argptr , unsigned int * ) ; <S2SV_EndBug> <S2SV_StartBug> if ( count > 0 ) <S2SV_EndBug> <S2SV_StartBug> case 'G' : <S2SV_EndBug> <S2SV_StartBug> if ( count > 0 ) <S2SV_EndBug> <S2SV_StartBug> header_seek ( psf , count , SEEK_SET ) ; <S2SV_EndBug> <S2SV_StartBug> byte_count += count ; <S2SV_EndBug> ","<S2SV_ModStart> = 0 <S2SV_ModStart> if ( psf -> header . indx + 16 >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count ; <S2SV_ModStart> * intptr = 0 ; <S2SV_ModStart> ; * intptr = 0 <S2SV_ModStart> memset ( charptr , 0 , count ) ; byte_count += header_read ( psf , charptr , count ) ; break ; case 'G' : charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ; memset ( charptr , 0 , count ) ; if ( psf -> header . indx + count >= psf -> header . len && psf_bump_header_allocation ( psf , count ) ) return 0 ; byte_count += header_gets <S2SV_ModEnd> <S2SV_ModStart> 'z' : psf_log_printf ( psf , ""Format<S2SV_blank>conversion<S2SV_blank>\'z\'<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet.\\n"" ) ; break ; case 'p' : <S2SV_ModEnd> <S2SV_ModStart> header_seek ( psf , count , SEEK_SET ) ; byte_count = count ; break ; case 'j' <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2920,<S2SV_StartBug> if ( ! ( info = bmp_getinfo ( in ) ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\n"" , hdr . magic , hdr . siz , hdr . reserved1 , hdr . reserved2 , hdr . off ) ) ; <S2SV_ModStart> JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%d;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>hres<S2SV_blank>%d;<S2SV_blank>vres<S2SV_blank>%d;<S2SV_blank>numcolors<S2SV_blank>%d;<S2SV_blank>"" ""mincolors<S2SV_blank>%d\\n"" , info -> len , info -> width , info -> height , info -> numplanes , info -> depth , info -> enctype , info -> siz , info -> hres , info -> vres , info -> numcolors , info -> mincolors ) ) ; "
2921,"<S2SV_StartBug> } else if ( ACTION ( RUN ) ) { <S2SV_EndBug> <S2SV_StartBug> handle_run ( req , res ) ; <S2SV_EndBug> <S2SV_StartBug> is_monit_running ( res ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( ACTION ( STATUS ) ) { <S2SV_EndBug> ",<S2SV_ModStart> RUNTIME <S2SV_ModEnd> <S2SV_ModStart> handle_runtime <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { handle_service <S2SV_ModEnd> 
2922,"<S2SV_StartBug> btrfs_file_extent_compression ( leaf , fi ) == 0 && <S2SV_EndBug> <S2SV_StartBug> if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) <S2SV_EndBug> <S2SV_StartBug> new_size ) ; <S2SV_EndBug> ","<S2SV_ModStart> btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) { if ( <S2SV_ModStart> != BTRFS_COMPRESS_NONE && pending_del_nr ) { err = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } pending_del_nr = 0 ; } err = truncate_inline_extent ( inode , path , & found_key , item_end , new_size ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } } else <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart>  <S2SV_ModEnd> "
2923,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_last_source ) ; vpx_free ( denoiser -> denoise_state ) ; 
2924,"<S2SV_StartBug> struct stat st ; <S2SV_EndBug> <S2SV_StartBug> pr_fs_clear_cache ( ) ; <S2SV_EndBug> <S2SV_StartBug> xerrno = errno ; <S2SV_EndBug> <S2SV_StartBug> pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>check<S2SV_blank>%s:<S2SV_blank>%s"" , path , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> res = is_symlink_path ( p , path , pathlen <S2SV_ModEnd> <S2SV_ModStart> if ( errno == EPERM ) { <S2SV_ModEnd> <S2SV_ModStart> ""error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>"" ""(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)"" , path ) ; } <S2SV_ModEnd> "
2925,<S2SV_StartBug> if ( length == 1 && bp [ 0 ] == 0xff ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK ( bp [ 0 ] ) ; <S2SV_ModStart> ND_TCHECK ( bp [ 3 ] ) ; 
2926,"<S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , unsigned short , sad_array8 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> bestaddress , in_what_stride , UINT_MAX ) <S2SV_EndBug> <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> ","<S2SV_ModStart> DECLARE_ALIGNED <S2SV_ModEnd> <S2SV_ModStart> int , sad_array8 [ 8 ] <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2927,<S2SV_StartBug> hlist_del ( & pin -> m_list ) ; <S2SV_EndBug> <S2SV_StartBug> hlist_del ( & pin -> s_list ) ; <S2SV_EndBug> ,<S2SV_ModStart> hlist_del_init <S2SV_ModEnd> <S2SV_ModStart> hlist_del_init <S2SV_ModEnd> 
2928,"<S2SV_StartBug> static bool do_write_pids ( pid_t tpid , const char * contrl , const char * cg , const char * file , const char * buf ) <S2SV_EndBug> <S2SV_StartBug> if ( fprintf ( pids_file , ""%d"" , ( int ) cred . pid ) < 0 ) <S2SV_EndBug> ","<S2SV_ModStart> uid_t tuid , <S2SV_ModStart> ! may_move_pid ( tpid , tuid , <S2SV_ModEnd> <S2SV_ModStart> ) { fail = true ; break ; } if ( fprintf ( pids_file , ""%d"" , ( int ) cred . pid ) "
2929,"<S2SV_StartBug> u_char * b , * s , * t , c ; <S2SV_EndBug> <S2SV_StartBug> b = ( uint8_t * ) malloc ( length ) ; <S2SV_EndBug> <S2SV_StartBug> for ( s = ( u_char * ) p , t = b , i = length ; i > 0 ; i -- ) { <S2SV_EndBug> <S2SV_StartBug> if ( i > 1 ) { <S2SV_EndBug> <S2SV_StartBug> c = * s ++ ^ 0x20 ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; const u_char * s <S2SV_ModStart> u_char <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && ND_TTEST ( * s ) <S2SV_ModStart> <= 1 || ! ND_TTEST ( * s ) ) break ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2930,<S2SV_StartBug> assert ( dev -> lintr . pin > 0 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> <= 0 ) { pr_warn ( ""%s:<S2SV_blank>Invalid<S2SV_blank>intr<S2SV_blank>pin<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>[%s]\\n"" , __func__ , dev -> name ) ; return ; } <S2SV_ModEnd> "
2931,<S2SV_StartBug> BUG_ON ( ret == - EEXIST ) ; <S2SV_EndBug> ,<S2SV_ModStart> || ret == - EOVERFLOW 
2932,"<S2SV_StartBug> int opts ; <S2SV_EndBug> <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <S2SV_EndBug> ","<S2SV_ModStart> result ; int <S2SV_ModStart> result = <S2SV_ModEnd> <S2SV_ModStart> ; if ( result < 0 ) js_error ( J , ""regexec<S2SV_blank>failed"" ) ; if ( result == 0 "
2933,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> check_stack_depth ( ) ; 
2934,"<S2SV_StartBug> int ntlm_read_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> ",<S2SV_ModStart> static 
2935,"<S2SV_StartBug> if ( ! ctx -> priv ) { <S2SV_EndBug> <S2SV_StartBug> vpx_codec_alg_priv_t * alg_priv = vpx_memalign ( 32 , sizeof ( * alg_priv ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( alg_priv == NULL ) <S2SV_EndBug> <S2SV_StartBug> return VPX_CODEC_MEM_ERROR ; <S2SV_EndBug> <S2SV_StartBug> ctx -> priv = ( vpx_codec_priv_t * ) alg_priv ; <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> config . dec ) { <S2SV_EndBug> <S2SV_StartBug> ctx -> priv -> alg_priv -> cfg = * ctx -> config . dec ; <S2SV_EndBug> <S2SV_StartBug> ctx -> config . dec = & ctx -> priv -> alg_priv -> cfg ; <S2SV_EndBug> ",<S2SV_ModStart> ( void ) data ; <S2SV_ModStart> const priv = vpx_calloc ( 1 <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart> priv -> si . sz = sizeof ( priv -> si ) ; priv -> flushed = 0 ; priv -> frame_parallel_decode = ( ctx -> config . dec && ( ctx -> config . dec -> threads > 1 ) && ( ctx -> init_flags & VPX_CODEC_USE_FRAME_THREADING ) ) ? 1 : 0 ; <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> 
2936,<S2SV_StartBug> valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; <S2SV_EndBug> <S2SV_StartBug> valuelen ) ; <S2SV_EndBug> <S2SV_StartBug> args -> valuelen = valuelen ; <S2SV_EndBug> <S2SV_StartBug> if ( args -> valuelen < valuelen ) { <S2SV_EndBug> <S2SV_StartBug> args -> valuelen = valuelen ; <S2SV_EndBug> ,<S2SV_ModStart> args -> rmtvaluelen <S2SV_ModEnd> <S2SV_ModStart> args -> rmtvaluelen <S2SV_ModEnd> <S2SV_ModStart> args -> rmtvaluelen <S2SV_ModEnd> <S2SV_ModStart> args -> rmtvaluelen ) { args -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> <S2SV_ModStart> args -> rmtvaluelen <S2SV_ModEnd> 
2937,"<S2SV_StartBug> char * sockaddr_url , * stratum_port , * tmp ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_disable_client_reconnect ) { <S2SV_EndBug> <S2SV_StartBug> url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( address , ""%s:%s"" , url , port ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( opt_disable_client_reconnect ) { applog ( LOG_WARNING , ""Stratum<S2SV_blank>client.reconnect<S2SV_blank>received<S2SV_blank>but<S2SV_blank>is<S2SV_blank>disabled,<S2SV_blank>not<S2SV_blank>reconnecting."" ) ; return false ; } <S2SV_ModEnd> <S2SV_ModStart> char * sockaddr_url , * stratum_port , * tmp ; url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ; if ( ! url ) url = pool -> sockaddr_url ; port <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> snprintf ( address , sizeof ( address ) <S2SV_ModEnd> "
2938,"<S2SV_StartBug> input ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ! r_fs_mount ( core -> fs , ptr , input , off ) ) <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = r_fs_name ( core -> fs , core -> offset ) ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( ! r_fs_mount ( core -> fs , ptr , input , core -> offset ) ) <S2SV_EndBug> <S2SV_StartBug> eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\n"" , input ) ; <S2SV_EndBug> ",<S2SV_ModStart> { input ++ ; } <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } 
2939,<S2SV_StartBug> while ( -- n >= 0 && ! ND_TTEST ( * ps ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( ie = io + ps -> nid ; io < ie && ! ND_TTEST ( * io ) ; ++ io ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
2940,<S2SV_StartBug> if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE && <S2SV_EndBug> <S2SV_StartBug> sbi -> s_inode_size ) { <S2SV_EndBug> ,<S2SV_ModStart> unsigned def_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; <S2SV_ModStart> == EXT4_GOOD_OLD_INODE_SIZE ) { sbi -> s_want_extra_isize = 0 ; return ; } if ( sbi -> s_want_extra_isize < 4 ) { sbi -> s_want_extra_isize = def_extra_isize ; if ( ext4_has_feature_extra_isize ( sb ) ) { if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_want_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_want_extra_isize ) ; if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_min_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_min_extra_isize ) ; } } if ( ( sbi -> s_want_extra_isize > sbi -> s_inode_size ) || <S2SV_ModEnd> <S2SV_ModStart> ) { sbi -> s_want_extra_isize = def_extra_isize <S2SV_ModEnd> 
2941,"<S2SV_StartBug> struct mii_data * miidata = ( struct mii_data * ) & rq -> ifr_ifru ; <S2SV_EndBug> <S2SV_StartBug> case SIOCDEVPRIVATE : <S2SV_EndBug> <S2SV_StartBug> case SIOCDEVPRIVATE + 1 : <S2SV_EndBug> <S2SV_StartBug> miidata -> out_value = mii_read ( dev , phy_addr , miidata -> reg_num ) ; <S2SV_EndBug> <S2SV_StartBug> case SIOCDEVPRIVATE + 2 : <S2SV_EndBug> <S2SV_StartBug> mii_write ( dev , phy_addr , miidata -> reg_num , miidata -> in_value ) ; <S2SV_EndBug> ",<S2SV_ModStart> mii_ioctl_data <S2SV_ModEnd> <S2SV_ModStart> if_mii ( rq ) <S2SV_ModEnd> <S2SV_ModStart> SIOCGMIIPHY : miidata -> phy_id = phy_addr ; <S2SV_ModEnd> <S2SV_ModStart> SIOCGMIIREG <S2SV_ModEnd> <S2SV_ModStart> val_out <S2SV_ModEnd> <S2SV_ModStart> SIOCSMIIREG : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; <S2SV_ModEnd> <S2SV_ModStart> val_in <S2SV_ModEnd> 
2942,"<S2SV_StartBug> int hns_nic_net_xmit_hw ( struct net_device * ndev , <S2SV_EndBug> <S2SV_StartBug> wmb ( ) ; <S2SV_EndBug> ",<S2SV_ModStart> netdev_tx_t <S2SV_ModEnd> <S2SV_ModStart> netif_trans_update ( ndev ) ; ndev -> stats . tx_bytes += skb -> len ; ndev -> stats . tx_packets ++ ; 
2943,<S2SV_StartBug> if ( sk_hashed ( sk ) ) { <S2SV_EndBug> <S2SV_StartBug> write_lock_bh ( & ping_table . lock ) ; <S2SV_EndBug> <S2SV_StartBug> write_unlock_bh ( & ping_table . lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> write_lock_bh ( & ping_table . lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> 
2944,"<S2SV_StartBug> char query [ 1024 ] , * end ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( query , ""select<S2SV_blank>count(*)<S2SV_blank>from<S2SV_blank>`%s`"" , table ) ; <S2SV_EndBug> <S2SV_StartBug> end = strmov ( strmov ( strmov ( query , ""show<S2SV_blank>/*!32332<S2SV_blank>FULL<S2SV_blank>*/<S2SV_blank>columns<S2SV_blank>from<S2SV_blank>`"" ) , table ) , ""`"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( wild && wild [ 0 ] ) <S2SV_EndBug> <S2SV_StartBug> end = strmov ( strmov ( strmov ( query , ""show<S2SV_blank>keys<S2SV_blank>from<S2SV_blank>`"" ) , table ) , ""`"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> NAME_LEN + 100 ] ; int len <S2SV_ModEnd> <S2SV_ModStart> my_snprintf ( query , sizeof ( query ) <S2SV_ModEnd> <S2SV_ModStart> len = sizeof ( query ) ; len -= my_snprintf ( query , len , ""show<S2SV_blank>/*!32332<S2SV_blank>FULL<S2SV_blank>*/<S2SV_blank>columns<S2SV_blank>from<S2SV_blank>`%s`"" , table <S2SV_ModEnd> <S2SV_ModStart> && len ) strxnmov ( query + strlen ( query ) , len <S2SV_ModEnd> <S2SV_ModStart> my_snprintf ( query , sizeof ( query ) , ""show<S2SV_blank>keys<S2SV_blank>from<S2SV_blank>`%s`"" , table <S2SV_ModEnd> "
2945,"<S2SV_StartBug> VP8Frame * av_uninit ( curframe ) , * prev_frame ; <S2SV_EndBug> ",<S2SV_ModStart> ; av_assert0 ( avctx -> pix_fmt == AV_PIX_FMT_YUVA420P || avctx -> pix_fmt == AV_PIX_FMT_YUV420P ) 
2946,<S2SV_StartBug> ssize_t result ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES 
2947,<S2SV_StartBug> img_buf_free ( img -> img_data ) ; <S2SV_EndBug> ,<S2SV_ModStart> vpx_free <S2SV_ModEnd> 
2948,"<S2SV_StartBug> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> size_t ) ( <S2SV_ModStart> 1U <S2SV_ModEnd> 
2949,"<S2SV_StartBug> struct stat st ; <S2SV_EndBug> <S2SV_StartBug> pr_fs_clear_cache2 ( path ) ; <S2SV_EndBug> <S2SV_StartBug> xerrno = errno ; <S2SV_EndBug> <S2SV_StartBug> pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>check<S2SV_blank>%s:<S2SV_blank>%s"" , path , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> res = is_symlink_path ( p , path , pathlen <S2SV_ModEnd> <S2SV_ModStart> if ( errno == EPERM ) { <S2SV_ModEnd> <S2SV_ModStart> ""error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>"" ""(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)"" , path ) ; } <S2SV_ModEnd> "
2950,"<S2SV_StartBug> af -> from_addr_param ( & addr , addr_param , <S2SV_EndBug> ",<S2SV_ModStart> if ( af == NULL ) break ; 
2951,"<S2SV_StartBug> imbuf = ( unsigned char * ) AcquireQuantumMemory ( imsx * imsy , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) ResetMagickMemory ( imbuf , background_color_index , imsx * imsy ) ; <S2SV_EndBug> <S2SV_StartBug> dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) ResetMagickMemory ( dmbuf , background_color_index , dmsx * dmsy ) ; <S2SV_EndBug> <S2SV_StartBug> dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) ResetMagickMemory ( dmbuf , background_color_index , dmsx * dmsy ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) ResetMagickMemory ( imbuf + imsx * y + posision_x , color_index , repeat_count ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ) == NULL ) { <S2SV_EndBug> ","<S2SV_ModStart> , imsy <S2SV_ModEnd> <S2SV_ModStart> ( size_t ) <S2SV_ModStart> , dmsy <S2SV_ModEnd> <S2SV_ModStart> ( size_t ) <S2SV_ModStart> , dmsy <S2SV_ModEnd> <S2SV_ModStart> ( size_t ) <S2SV_ModStart> ( size_t ) <S2SV_ModStart> , dmsy <S2SV_ModEnd> "
2952,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""replay<S2SV_blank>detection<S2SV_blank>%sabled"" , <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_32BITS ( cp ) ; 
2953,"<S2SV_StartBug> ALOGE ( ""b/26366256"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; android_errorWriteLog ( 0x534e4554 , ""26366256"" "
2954,"<S2SV_StartBug> u64 base_addr , size ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( get_securelevel ( ) > 0 ) return - EPERM 
2955,<S2SV_StartBug> if ( client -> rcSource ) <S2SV_EndBug> ,<S2SV_ModStart> width >= MAX_CURSOR_SIZE || height >= MAX_CURSOR_SIZE ) return FALSE ; if ( 
2956,<S2SV_StartBug> if ( bee -> ui -> ft_in_start ) { <S2SV_EndBug> ,<S2SV_ModStart> && bu 
2957,<S2SV_StartBug> if ( vps_id >= 16 ) { <S2SV_EndBug> ,<S2SV_ModStart> ( vps_id < 0 ) || ( <S2SV_ModStart> ) 
2958,<S2SV_StartBug> ether_setup ( dev ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING 
2959,"<S2SV_StartBug> struct key * find_keyring_by_name ( const char * name , bool skip_perm_check ) <S2SV_EndBug> <S2SV_StartBug> if ( ! skip_perm_check && <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> ","<S2SV_ModStart> uid_keyring <S2SV_ModEnd> <S2SV_ModStart> uid_keyring ) { if ( ! test_bit ( KEY_FLAG_UID_KEYRING , & keyring -> flags ) ) continue ; } else { if ( <S2SV_ModEnd> <S2SV_ModStart> } "
2960,<S2SV_StartBug> while ( ! kthread_should_stop ( ) ) { <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> kthread_freezable_should_stop ( NULL <S2SV_ModEnd> <S2SV_ModStart> if ( signal_pending ( current ) ) flush_signals ( current ) ; <S2SV_ModStart> svc_exit_thread ( rqstp ) ; module_put_and_exit ( 0 ) ; 
2961,"<S2SV_StartBug> PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; <S2SV_EndBug> <S2SV_StartBug> q = p ; <S2SV_EndBug> <S2SV_StartBug> goto skip ; <S2SV_EndBug> <S2SV_StartBug> php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ; <S2SV_EndBug> <S2SV_StartBug> PS_ADD_VARL ( name , namelen ) ; <S2SV_EndBug> ",<S2SV_ModStart> int skip = 0 ; <S2SV_ModStart> ; skip = 0 <S2SV_ModStart> skip = 1 <S2SV_ModEnd> <S2SV_ModStart> if ( ! skip ) { <S2SV_ModStart> } <S2SV_ModStart> if ( ! skip ) { <S2SV_ModStart> } 
2962,"<S2SV_StartBug> if ( ( child -> ptrace & PT_PTRACED ) && child -> parent == current ) { <S2SV_EndBug> <S2SV_StartBug> spin_lock_irq ( & child -> sighand -> siglock ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ignore_state || ( task_is_traced ( child ) && <S2SV_EndBug> <S2SV_StartBug> ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ret && ! ignore_state ) <S2SV_EndBug> <S2SV_StartBug> ret = wait_task_inactive ( child , TASK_TRACED ) ? 0 : - ESRCH ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> WARN_ON ( child -> state == __TASK_TRACED <S2SV_ModEnd> <S2SV_ModStart> ptrace_freeze_traced ( child <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { if ( ! <S2SV_ModEnd> <S2SV_ModStart> __TASK_TRACED ) ) { WARN_ON ( child -> state == __TASK_TRACED ) ; ret = <S2SV_ModEnd> <S2SV_ModStart> } } 
2963,"<S2SV_StartBug> int ctrl_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> if ( display_size ) { <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> pbi ) { <S2SV_EndBug> <S2SV_StartBug> const VP9_COMMON * const cm = & ctx -> pbi -> common ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> return VPX_CODEC_OK ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ctx -> frame_parallel_decode ) { set_error_detail ( ctx , ""Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode"" ) ; return VPX_CODEC_INCAPABLE ; } if ( <S2SV_ModStart> frame_workers ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; <S2SV_ModEnd> <S2SV_ModStart> frame_worker_data <S2SV_ModEnd> <S2SV_ModStart> return VPX_CODEC_OK ; <S2SV_ModStart> } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2964,<S2SV_StartBug> altcol = ( altcol / tok -> alttabsize + 1 ) <S2SV_EndBug> <S2SV_StartBug> * tok -> alttabsize ; <S2SV_EndBug> <S2SV_StartBug> if ( indenterror ( tok ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( indenterror ( tok ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( indenterror ( tok ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( tok -> async_def ) { <S2SV_EndBug> ,<S2SV_ModStart> ALTTABSIZE <S2SV_ModEnd> <S2SV_ModStart> * ALTTABSIZE <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> <S2SV_ModStart> tok -> async_always || 
2965,"<S2SV_StartBug> # ifndef _MSC_VER <S2SV_EndBug> <S2SV_StartBug> char filename [ dirent . namelen + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( hook ( filename , type , fdiro , closure ) ) <S2SV_EndBug> ",<S2SV_ModStart> char * filename = grub_malloc ( <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart> if ( ! filename ) { break ; } <S2SV_ModStart> { free ( filename ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> { free ( filename ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> { free ( filename ) ; <S2SV_ModEnd> <S2SV_ModStart> { free ( filename ) ; return 1 ; } free ( filename ) <S2SV_ModEnd> 
2966,"<S2SV_StartBug> if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( line += 18 ; isspace ( * line ) ; line ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( ; line < last && isspace ( * line ) ; line ++ ) <S2SV_EndBug> <S2SV_StartBug> else if ( last >= line + 4 && isxdigit ( line [ 0 ] ) && isxdigit ( line [ 1 ] ) <S2SV_EndBug> <S2SV_StartBug> && isxdigit ( line [ 2 ] ) && isxdigit ( line [ 3 ] ) ) <S2SV_EndBug> ",<S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) 
2967,<S2SV_StartBug> if ( transhdrlen ) { <S2SV_EndBug> <S2SV_StartBug> copy = datalen - transhdrlen - fraggap ; <S2SV_EndBug> ,"<S2SV_ModStart> copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; goto error ; } <S2SV_ModStart> if ( copy > 0 && getfrag ( from , data + transhdrlen <S2SV_ModEnd> "
2968,<S2SV_StartBug> if ( ! from_buffer ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
2969,<S2SV_StartBug> if ( env -> allow_ptr_leaks || BPF_SRC ( insn -> code ) == BPF_K ) <S2SV_EndBug> <S2SV_StartBug> if ( aux -> alu_state && <S2SV_EndBug> <S2SV_StartBug> return - EACCES ; <S2SV_EndBug> ,"<S2SV_ModStart> can_skip_alu_sanitation ( env , insn ) <S2SV_ModEnd> <S2SV_ModStart> update_alu_sanitation_state ( aux , alu_state , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2970,"<S2SV_StartBug> pr_debug ( ""%p<S2SV_blank>%zu\\n"" , sk , len ) ; <S2SV_EndBug> <S2SV_StartBug> sockaddr -> sa_family = AF_NFC ; <S2SV_EndBug> ","<S2SV_ModStart> ; msg -> msg_namelen = 0 <S2SV_ModStart> memset ( sockaddr , 0 , sizeof ( * sockaddr ) ) ; "
2971,<S2SV_StartBug> if ( s ) { <S2SV_EndBug> <S2SV_StartBug> struct unix_sock * u = unix_sk ( s ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock ( & unix_gc_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> spin_lock ( & unix_gc_lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } fp -> f_cred -> user -> unix_inflight -- ; <S2SV_ModStart>  <S2SV_ModEnd> 
2972,"<S2SV_StartBug> unsigned char * buf ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && bufsize 
2973,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> 
2974,"<S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> set_modeinfo_offsets ( & cpi -> common , xd , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> duplicate_mode_info_in_sb ( & cpi -> common , xd , mi_row , mi_col , bsize ) ; <S2SV_EndBug> ","<S2SV_ModStart> MACROBLOCK * const x , MACROBLOCKD * const xd <S2SV_ModEnd> <S2SV_ModStart> set_mode_info_offsets <S2SV_ModEnd> <S2SV_ModStart> , x <S2SV_ModStart>  <S2SV_ModEnd> "
2975,"<S2SV_StartBug> sprintf ( address , ""%s:%s"" , url , port ) ; <S2SV_EndBug> ","<S2SV_ModStart> snprintf ( address , 254 <S2SV_ModEnd> "
2976,"<S2SV_StartBug> memset ( global , 0 , sizeof ( * global ) ) ; <S2SV_EndBug> <S2SV_StartBug> global -> codec = get_vpx_encoder_by_index ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> global -> use_i420 = 0 ; <S2SV_EndBug> <S2SV_StartBug> else if ( arg_match ( & arg , & experimental_bitstream , argi ) ) <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_VP9_ENCODER <S2SV_EndBug> ","<S2SV_ModStart> const int num_encoder = get_vpx_encoder_count ( ) ; if ( num_encoder < 1 ) die ( ""Error:<S2SV_blank>no<S2SV_blank>valid<S2SV_blank>encoder<S2SV_blank>available\\n"" ) ; <S2SV_ModStart> num_encoder - 1 ) ; global -> passes = 0 ; global -> color_type = I420 <S2SV_ModEnd> <S2SV_ModStart> color_type = YV12 ; else if ( arg_match ( & arg , & use_i420 , argi ) ) global -> color_type = I420 ; else if ( arg_match ( & arg , & use_i422 , argi ) ) global -> color_type = I422 ; else if ( arg_match ( & arg , & use_i444 , argi ) ) global -> color_type = I444 ; else if ( arg_match ( & arg , & use_i440 , argi ) ) global -> color_type = I440 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> || CONFIG_VP10_ENCODER if ( global -> codec != NULL && global -> codec -> name != NULL ) "
2977,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> m -> msg_namelen = 0 ; 
2978,<S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> ,<S2SV_ModStart> { if ( unlikely ( ! try_get_page ( page ) ) ) { page = ERR_PTR ( - ENOMEM ) ; goto out ; } } <S2SV_ModEnd> 
2979,<S2SV_StartBug> sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels 
2980,<S2SV_StartBug> hndl = sock_diag_lock_handler ( req -> sdiag_family ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( req -> sdiag_family >= AF_MAX ) return - EINVAL ; 
2981,"<S2SV_StartBug> static inline ulong encode_twos_comp ( long n , int prec ) <S2SV_EndBug> <S2SV_StartBug> ulong result ; <S2SV_EndBug> ",<S2SV_ModStart> jas_ulong <S2SV_ModEnd> <S2SV_ModStart> jas_ulong <S2SV_ModEnd> 
2982,<S2SV_StartBug> mptctl_eventquery ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> struct mpt_ioctl_eventquery karg ; <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,"<S2SV_ModStart> MPT_ADAPTER * ioc , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2983,<S2SV_StartBug> if ( source == target ) <S2SV_EndBug> ,"<S2SV_ModStart> vfs_select_inode ( old_dentry , 0 ) == vfs_select_inode ( new_dentry , 0 ) <S2SV_ModEnd> "
2984,<S2SV_StartBug> if ( ! vma -> vm_userfaultfd_ctx . ctx ) <S2SV_EndBug> ,<S2SV_ModStart> WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ; 
2985,"<S2SV_StartBug> static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options ) <S2SV_EndBug> <S2SV_StartBug> if ( ! options ) { <S2SV_EndBug> <S2SV_StartBug> case ecryptfs_opt_err : <S2SV_EndBug> ","<S2SV_ModStart> , uid_t * check_ruid <S2SV_ModStart> * check_ruid = 0 ; <S2SV_ModStart> ecryptfs_opt_check_dev_ruid : * check_ruid = 1 ; break ; case "
2986,"<S2SV_StartBug> len = mutt_b64_decode ( obuf , idata -> buf + 2 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( obuf ) "
2987,"<S2SV_StartBug> int Downmix_Reset ( downmix_object_t * pDownmixer , bool init ) { <S2SV_EndBug> ",<S2SV_ModStart> __unused <S2SV_ModStart> __unused 
2988,<S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_PRE_IO ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) <S2SV_ModEnd> <S2SV_ModStart> if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result ) ; 
2989,<S2SV_StartBug> if ( retval ) { <S2SV_EndBug> ,<S2SV_ModStart> || pname_data . length == 0 || pname_data . data [ pname_data . length - 1 ] != '\\0' 
2990,<S2SV_StartBug> block_length = data [ i ] * 256 + data [ i + 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart> if ( i + 1 < data_size ) 
2991,<S2SV_StartBug> for ( plane = 0 ; in -> data [ plane ] && plane < 4 ; plane ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( plane = 0 ; in -> data [ plane ] && plane < 4 ; plane ++ ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && in -> data [ plane ] && in -> linesize [ plane ] <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && in -> data [ plane ] && in -> linesize [ plane ] 
2992,"<S2SV_StartBug> RATE_CONTROL * const rc = & cpi -> rc ; <S2SV_EndBug> <S2SV_StartBug> VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> struct twopass_rc * const twopass = & cpi -> twopass ; <S2SV_EndBug> <S2SV_StartBug> FIRSTPASS_STATS next_frame = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> const FIRSTPASS_STATS * start_pos ; <S2SV_EndBug> <S2SV_StartBug> double gf_first_frame_err = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> const int max_bits = frame_max_bits ( rc , oxcf ) ; <S2SV_EndBug> <S2SV_StartBug> mv_ratio_accumulator_thresh = ( cpi -> common . width + cpi -> common . height ) / 10.0 ; <S2SV_EndBug> <S2SV_StartBug> active_max_gf_interval = rc -> max_gf_interval ; <S2SV_EndBug> <S2SV_StartBug> mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; <S2SV_EndBug> <S2SV_StartBug> if ( EOF == input_stats ( twopass , & next_frame ) ) <S2SV_EndBug> <S2SV_StartBug> loop_decay_rate = get_prediction_decay_rate ( & cpi -> common , & next_frame ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( next_frame . pcnt_inter - next_frame . pcnt_motion ) < <S2SV_EndBug> <S2SV_StartBug> if ( detect_transition_to_still ( twopass , i , 5 , loop_decay_rate , <S2SV_EndBug> <S2SV_StartBug> boost_score += ( decay_accumulator * <S2SV_EndBug> <S2SV_StartBug> calc_frame_boost ( cpi , & next_frame , this_frame_mv_in_out ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( i >= active_max_gf_interval && ( zero_motion_accumulator < 0.995 ) ) || <S2SV_EndBug> <S2SV_StartBug> ( i > MIN_GF_INTERVAL ) && <S2SV_EndBug> <S2SV_StartBug> ( ( boost_score - old_boost_score ) < IIFACTOR ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( rc -> frames_to_key - i ) < MIN_GF_INTERVAL ) { <S2SV_EndBug> <S2SV_StartBug> while ( i < ( rc -> frames_to_key + ! rc -> next_key_frame_forced ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( i < rc -> frames_to_key ) { <S2SV_EndBug> <S2SV_StartBug> rc -> baseline_gf_interval = i - 1 ; <S2SV_EndBug> <S2SV_StartBug> rc -> baseline_gf_interval = i ; <S2SV_EndBug> <S2SV_StartBug> ( i < cpi -> oxcf . lag_in_frames ) && <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> multi_arf_enabled && ( cpi -> common . frame_type != KEY_FRAME ) ) { <S2SV_EndBug> ","<S2SV_ModStart> VP9_COMMON * const cm = & cpi -> common ; <S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> TWO_PASS <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const start_pos = twopass -> stats_in <S2SV_ModEnd> <S2SV_ModStart> # if GROUP_ADAPTIVE_MAXQ double gf_group_raw_error = 0.0 ; # endif double gf_group_skip_pct = 0.0 ; double gf_group_inactive_zone_rows = 0.0 ; <S2SV_ModStart> unsigned int allow_alt_ref = is_altref_enabled ( cpi ) ; int f_boost = 0 ; int b_boost = 0 ; int flash_detected ; int active_max_gf_interval ; int active_min_gf_interval ; int64_t gf_group_bits ; double gf_group_error_left ; int gf_arf_bits ; const int is_key_frame = frame_is_intra_only ( cm ) ; const int arf_active_or_kf = is_key_frame || rc -> source_alt_ref_active ; if ( is_key_frame == 0 ) { vp9_zero ( twopass -> gf_group ) ; } vpx_clear_system_state ( ) ; vp9_zero ( next_frame ) ; mod_frame_err = calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ; gf_first_frame_err = mod_frame_err ; if ( arf_active_or_kf ) { <S2SV_ModEnd> <S2SV_ModStart> # if GROUP_ADAPTIVE_MAXQ gf_group_raw_error -= this_frame -> coded_error ; # endif gf_group_skip_pct -= this_frame -> intra_skip_pct ; gf_group_inactive_zone_rows -= this_frame -> inactive_zone_rows ; } mv_ratio_accumulator_thresh = ( cpi -> initial_height + cpi -> initial_width ) / 4.0 ; { int int_max_q = ( int ) ( vp9_convert_qindex_to_q ( twopass -> active_worst_quality , <S2SV_ModEnd> <S2SV_ModStart> bit_depth ) ) ; int int_lbq = ( int ) ( vp9_convert_qindex_to_q ( rc -> last_boosted_qindex , <S2SV_ModEnd> <S2SV_ModStart> bit_depth ) ) ; active_min_gf_interval = rc -> min_gf_interval + MIN ( 2 , int_max_q / 200 ) ; if ( active_min_gf_interval > rc -> max_gf_interval ) active_min_gf_interval = rc -> max_gf_interval ; if ( cpi -> multi_arf_allowed ) { active_max_gf_interval = rc -> max_gf_interval ; } else { active_max_gf_interval = 12 + MIN ( 4 , ( int_lbq / 6 ) ) ; if ( active_max_gf_interval < active_min_gf_interval ) active_max_gf_interval = active_min_gf_interval <S2SV_ModEnd> <S2SV_ModStart> if ( active_max_gf_interval < active_min_gf_interval ) active_max_gf_interval = active_min_gf_interval ; } } <S2SV_ModStart> twopass , oxcf , <S2SV_ModStart> # if GROUP_ADAPTIVE_MAXQ gf_group_raw_error += this_frame -> coded_error ; # endif gf_group_skip_pct += this_frame -> intra_skip_pct ; gf_group_inactive_zone_rows += this_frame -> inactive_zone_rows ; <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> zero_motion_accumulator = MIN ( zero_motion_accumulator , get_zero_motion_factor ( cpi , & next_frame ) ) ; <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , GF_MAX_BOOST <S2SV_ModEnd> <S2SV_ModStart> ( active_max_gf_interval + arf_active_or_kf ) && <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> >= active_min_gf_interval + arf_active_or_kf <S2SV_ModEnd> <S2SV_ModStart> BOOST_BREAKOUT <S2SV_ModEnd> <S2SV_ModStart> rc -> constrained_gf_group = ( i >= <S2SV_ModEnd> <S2SV_ModStart> ) ? 1 : 0 ; if ( allow_alt_ref && <S2SV_ModEnd> <S2SV_ModStart> cpi -> oxcf . lag_in_frames ) && ( i >= rc -> min_gf_interval ) ) { rc -> gfu_boost = calc_arf_boost ( cpi , 0 , ( i - 1 ) , ( i - 1 ) , & f_boost , & b_boost ) ; rc -> source_alt_ref_pending = 1 ; cpi -> multi_arf_enabled = ( cpi -> multi_arf_allowed && ( rc -> baseline_gf_interval >= 6 ) && ( zero_motion_accumulator < 0.995 ) ) ? 1 : 0 ; } else { rc -> gfu_boost = MAX ( ( int ) boost_score , MIN_ARF_GF_BOOST ) ; rc -> source_alt_ref_pending = 0 ; } rc -> baseline_gf_interval = i - ( is_key_frame || rc -> source_alt_ref_pending ) ; if ( is_two_pass_svc ( cpi ) && cpi -> svc . number_temporal_layers > 1 ) { int count = ( 1 << ( cpi -> svc . number_temporal_layers - 1 ) ) - 1 ; int new_gf_interval = ( rc -> baseline_gf_interval + count ) & ( ~ count ) ; int j ; for ( j = 0 ; j < new_gf_interval - rc -> baseline_gf_interval ; ++ j ) { <S2SV_ModEnd> <S2SV_ModStart> gf_group_err += calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ; # if GROUP_ADAPTIVE_MAXQ gf_group_raw_error += this_frame -> coded_error ; # endif gf_group_skip_pct += this_frame -> intra_skip_pct ; gf_group_inactive_zone_rows += this_frame -> inactive_zone_rows ; } <S2SV_ModEnd> <S2SV_ModStart> new_gf_interval ; } rc -> frames_till_gf_update_due = <S2SV_ModEnd> <S2SV_ModStart> ; reset_fpf_position ( twopass , start_pos ) ; gf_group_bits = calculate_total_gf_group_bits ( cpi , gf_group_err ) ; # if GROUP_ADAPTIVE_MAXQ if ( ( <S2SV_ModEnd> <S2SV_ModStart> rc_mode != VPX_Q ) && ( rc -> baseline_gf_interval > 1 ) ) { const int vbr_group_bits_per_frame = ( int ) ( gf_group_bits / rc -> baseline_gf_interval ) ; const double group_av_err = gf_group_raw_error / rc -> baseline_gf_interval ; const double group_av_skip_pct = gf_group_skip_pct / rc -> baseline_gf_interval ; const double group_av_inactive_zone = ( ( gf_group_inactive_zone_rows * 2 ) / ( rc -> baseline_gf_interval * ( double ) cm -> mb_rows ) ) ; int tmp_q ; double rc_factor = 1.0 ; if ( rc -> rate_error_estimate > 0 ) { rc_factor = MAX ( RC_FACTOR_MIN , ( double ) ( 100 - rc -> rate_error_estimate ) / 100.0 ) ; } else { rc_factor = MIN ( RC_FACTOR_MAX , ( double ) ( 100 - rc -> rate_error_estimate ) / 100.0 ) ; } tmp_q = get_twopass_worst_quality ( cpi , group_av_err , ( group_av_skip_pct + group_av_inactive_zone ) , vbr_group_bits_per_frame , twopass -> kfgroup_inter_fraction * rc_factor ) ; twopass -> active_worst_quality = MAX ( tmp_q , twopass -> active_worst_quality >> 1 <S2SV_ModEnd> <S2SV_ModStart> gf_arf_bits = calculate_boost_bits ( rc -> baseline_gf_interval , rc -> gfu_boost , gf_group_bits ) ; twopass -> kf_group_error_left -= ( int64_t ) gf_group_err ; if ( rc -> source_alt_ref_pending ) { gf_group_error_left = gf_group_err - mod_frame_err ; } else if ( is_key_frame == 0 ) { gf_group_error_left = gf_group_err - gf_first_frame_err ; } else { gf_group_error_left = gf_group_err ; } allocate_gf_group_bits ( cpi , gf_group_bits , gf_group_error_left , gf_arf_bits ) ; reset_fpf_position ( twopass , start_pos ) ; if <S2SV_ModEnd> <S2SV_ModStart> { twopass -> section_intra_rating = calculate_section_intra_ratio ( start_pos , twopass -> stats_in_end , rc -> baseline_gf_interval ) ; } if ( oxcf -> resize_mode == RESIZE_DYNAMIC ) { cpi -> rc . next_frame_size_selector = UNSCALED <S2SV_ModEnd> "
2993,<S2SV_StartBug> goto err_reprs_clean ; <S2SV_EndBug> <S2SV_StartBug> nfp_repr_free ( repr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( err ) { <S2SV_EndBug> ,<S2SV_ModStart> nfp_repr_free ( repr ) ; <S2SV_ModStart> kfree ( repr_priv ) ; <S2SV_ModStart> kfree ( repr_priv ) ; 
2994,"<S2SV_StartBug> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <S2SV_EndBug> ","<S2SV_ModStart> elems , e -> "
2995,<S2SV_StartBug> if ( sp -> sa_protocol != PX_PROTO_PPTP ) <S2SV_EndBug> ,<S2SV_ModStart> sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ; if ( 
2996,"<S2SV_StartBug> RING_FINAL_CHECK_FOR_REQUESTS ( & vif -> tx , work_to_do ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( work_to_do < 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( ret < 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , <S2SV_EndBug> <S2SV_StartBug> netbk_tx_err ( vif , & txreq , idx ) ; <S2SV_EndBug> <S2SV_StartBug> netbk_tx_err ( vif , & txreq , idx ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( vif -> tx . sring -> req_prod - vif -> tx . req_cons > XEN_NETIF_TX_RING_SIZE ) { netdev_err ( vif -> dev , ""Impossible<S2SV_blank>number<S2SV_blank>of<S2SV_blank>requests.<S2SV_blank>"" ""req_prod<S2SV_blank>%d,<S2SV_blank>req_cons<S2SV_blank>%d,<S2SV_blank>size<S2SV_blank>%ld\\n"" , vif -> tx . sring -> req_prod , vif -> tx . req_cons , XEN_NETIF_TX_RING_SIZE ) ; netbk_fatal_tx_err ( vif ) ; continue ; } <S2SV_ModStart> continue ; <S2SV_ModEnd> <S2SV_ModStart> continue ; <S2SV_ModEnd> <S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> netbk_fatal_tx_err ( vif <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
2997,"<S2SV_StartBug> ret = vfs_dedupe_file_range ( file , same ) ; <S2SV_EndBug> ",<S2SV_ModStart> same -> dest_count = count ; 
2998,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( * i == '\\\\' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , ""Backslash<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL."" ) ; return HTTP_BAD_REQUEST ; } "
2999,"<S2SV_StartBug> char * to , * repl ; <S2SV_EndBug> <S2SV_StartBug> if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { <S2SV_EndBug> <S2SV_StartBug> to = g . hname ; <S2SV_EndBug> <S2SV_StartBug> len = strlen ( g . hname ) ; <S2SV_EndBug> <S2SV_StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; <S2SV_EndBug> <S2SV_StartBug> g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( g . outf , to , len ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <S2SV_EndBug> ","<S2SV_ModStart> = g . inf , * sufx = """" ; size_t pre = 0 <S2SV_ModEnd> <S2SV_ModStart> ) { if ( <S2SV_ModEnd> <S2SV_ModStart> pre = justname ( g . inf ) - g . inf ; to = justname ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> to ) ; } else if ( <S2SV_ModEnd> <S2SV_ModStart> == 0 ) sufx = "".tar"" ; } else sufx = g . sufx ; <S2SV_ModEnd> <S2SV_ModStart> pre + len + strlen ( sufx ) <S2SV_ModEnd> <S2SV_ModStart> g . inf , pre ) ; memcpy <S2SV_ModEnd> <S2SV_ModStart> pre , to , len ) ; strcpy ( g . outf + pre + len , <S2SV_ModEnd> "
3000,"<S2SV_StartBug> if ( mi < 0 ) <S2SV_EndBug> <S2SV_StartBug> idev -> info -> mem [ mi ] . addr >> PAGE_SHIFT , <S2SV_EndBug> ",<S2SV_ModStart> struct uio_mem * mem ; <S2SV_ModStart> ) return - EINVAL ; mem = idev -> info -> mem + mi ; if ( vma -> vm_end - vma -> vm_start > mem -> size <S2SV_ModStart> mem -> <S2SV_ModEnd> 
3001,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ( UINT32_MAX - src -> width < ( x > 0 ? x : - x ) ) || ( UINT32_MAX - src -> height < ( y > 0 ? y : - y ) ) ) { # ifdef JBIG2_DEBUG jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , ""overflow<S2SV_blank>in<S2SV_blank>compose_image"" ) ; # endif return 0 ; } "
3002,"<S2SV_StartBug> mptctl_do_mpt_command ( struct mpt_ioctl_command karg , void __user * mfPtr ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> int iocnum , flagsLength ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <S2SV_EndBug> ","<S2SV_ModStart> MPT_ADAPTER * ioc , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3003,"<S2SV_StartBug> strcpy ( algo -> alg_name , auth -> alg_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> , sizeof ( algo -> alg_name ) "
3004,<S2SV_StartBug> u8 * output ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! ctx -> opid ) return GF_NON_COMPLIANT_BITSTREAM 
3005,<S2SV_StartBug> if ( type == HUB_INIT2 ) <S2SV_EndBug> <S2SV_StartBug> if ( type == HUB_INIT3 ) <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> || type == HUB_INIT3 ) { device_lock ( hub -> intfdev ) ; if ( hub -> disconnected ) { device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ; return ; } if ( type == HUB_INIT2 <S2SV_ModStart> goto init3 ; } kref_get ( & hub -> kref ) <S2SV_ModEnd> <S2SV_ModStart> device_unlock ( hub -> intfdev ) ; <S2SV_ModStart> if ( type == HUB_INIT2 || type == HUB_INIT3 ) device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ; "
3006,<S2SV_StartBug> param ++ ; <S2SV_EndBug> <S2SV_StartBug> while ( * param == '<S2SV_blank>' ) <S2SV_EndBug> <S2SV_StartBug> param ++ ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } 
3007,<S2SV_StartBug> if ( code == gcode ) <S2SV_EndBug> ,<S2SV_ModStart> && wordlist [ key ] . index >= 0 
3008,"<S2SV_StartBug> char buffer [ 4096 ] ; <S2SV_EndBug> <S2SV_StartBug> char * buf = buffer , * buf2 = buffer2 , * d , * d_url ; <S2SV_EndBug> <S2SV_StartBug> if ( name_len > sizeof ( buffer ) - 2 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> <S2SV_StartBug> if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) { <S2SV_EndBug> <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , * buf2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> efree ( buf ) ; <S2SV_ModEnd> <S2SV_ModStart> buf2 = estrndup ( value , value_len ) ; <S2SV_ModEnd> <S2SV_ModStart> efree ( buf ) ; efree ( buf2 ) ; <S2SV_ModEnd> "
3009,"<S2SV_StartBug> GetPixelIndex ( image , q ) , q ) ; <S2SV_EndBug> ","<S2SV_ModStart> ConstrainColormapIndex ( image , <S2SV_ModStart> ) , exception "
3010,<S2SV_StartBug> if ( cf_auth_type <= AUTH_TRUST ) { <S2SV_EndBug> ,"<S2SV_ModStart> ! client -> auth_user ) { disconnect_client ( client , true , ""client<S2SV_blank>password<S2SV_blank>pkt<S2SV_blank>before<S2SV_blank>startup<S2SV_blank>packet"" ) ; return false ; } if ( "
3011,"<S2SV_StartBug> BUFPUTSL ( ob , ""<q>"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct html_renderopt * options = opaque ; <S2SV_ModStart> if ( options -> flags & HTML_ESCAPE ) escape_html ( ob , text -> data , text -> size ) ; else "
3012,"<S2SV_StartBug> if ( cgroup && ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) { <S2SV_EndBug> ","<S2SV_ModStart> ) { if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) return - ENOENT ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3013,"<S2SV_StartBug> void validate_positive_rational ( const char * msg , <S2SV_EndBug> ",<S2SV_ModStart> static 
3014,<S2SV_StartBug> continue ; <S2SV_EndBug> ,<S2SV_ModStart> buflen ++ ; 
3015,"<S2SV_StartBug> fprintf ( out , ""[URL:<S2SV_blank>%s[StatusCode:<S2SV_blank>%u]"" , <S2SV_EndBug> <S2SV_StartBug> fprintf ( out , ""[ContentType:<S2SV_blank>%s]"" , flow -> http . content_type ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( out , ""[UserAgent:<S2SV_blank>%s]"" , flow -> http . user_agent ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""[URL:<S2SV_blank>%s][StatusCode:<S2SV_blank>%u]"" <S2SV_ModEnd> <S2SV_ModStart> ""[Content-Type:<S2SV_blank>%s]"" <S2SV_ModEnd> <S2SV_ModStart> ""[User-Agent:<S2SV_blank>%s]"" <S2SV_ModEnd> "
3016,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> indx , & data , 1 , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> u8 * buf ; int ret ; buf = kmemdup ( & data , 1 , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> kfree ( buf ) ; "
3017,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && in -> linesize [ plane ] 
3018,<S2SV_StartBug> if ( ( p -> flags & XFRM_STATE_ESN ) && ! rt ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> ,<S2SV_ModStart> struct xfrm_replay_state_esn * rs ; if <S2SV_ModEnd> <S2SV_ModStart> { if ( <S2SV_ModEnd> <S2SV_ModStart> rs = nla_data ( rt ) ; if ( rs -> bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof ( rs -> bmp [ 0 ] ) / 8 ) return - EINVAL ; if ( nla_len ( rt ) < xfrm_replay_state_esn_len ( rs ) && nla_len ( rt ) != sizeof ( * rs ) ) return - EINVAL ; } 
3019,"<S2SV_StartBug> static void mark_object ( struct object * obj , struct strbuf * path , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
3020,"<S2SV_StartBug> guchar * match ; <S2SV_EndBug> <S2SV_StartBug> gsize to_match = MIN ( left , buffer -> pos ) ; <S2SV_EndBug> <S2SV_StartBug> if ( memcmp ( buffer -> data , & AUTH_END_STRING [ client -> auth_end_offset ] , to_match ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> return match - buffer -> data + strlen ( AUTH_END_STRING ) ; <S2SV_EndBug> ","<S2SV_ModStart> goffset offset = 0 ; gsize original_size = client -> auth_buffer -> len ; g_byte_array_append ( client -> auth_buffer <S2SV_ModEnd> <S2SV_ModStart> data , buffer -> <S2SV_ModStart> while ( TRUE ) { guint8 * line_start = client -> auth_buffer <S2SV_ModEnd> <S2SV_ModStart> offset ; gsize remaining_data = client -> auth_buffer -> len - offset ; guint8 * line_end ; line_end = memmem ( line_start , remaining_data , AUTH_LINE_SENTINEL , strlen ( AUTH_LINE_SENTINEL ) ) ; if ( line_end ) { offset = ( line_end + strlen ( AUTH_LINE_SENTINEL ) - line_start ) ; if ( ! auth_line_is_valid ( line_start , line_end ) ) return FIND_AUTH_END_ABORT ; * line_end = 0 ; if ( auth_line_is_begin ( line_start ) ) return offset - original_size ; } else { g_byte_array_remove_range ( client -> auth_buffer , 0 , offset ) ; if ( client -> auth_buffer -> len >= 16 * 1024 ) return FIND_AUTH_END_ABORT ; return FIND_AUTH_END_CONTINUE ; } } <S2SV_ModEnd> "
3021,"<S2SV_StartBug> z . kind = 0 ; <S2SV_EndBug> <S2SV_StartBug> # define PARSE_STRING s = parse_field ( ndo , & parse , & parselen ) ; if ( ! s ) lose = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( lose ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int truncated = 0 ; <S2SV_ModStart> , & truncated ) ; if ( truncated ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> return ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|zephyr]<S2SV_blank>(%d)"" , length ) ) ; return ; "
3022,<S2SV_StartBug> if ( ! mp -> ports && ! mp -> mglist && <S2SV_EndBug> ,<S2SV_ModStart> mp -> timer_armed && 
3023,"<S2SV_StartBug> if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { <S2SV_EndBug> ","<S2SV_ModStart> memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteCanonEntry ) ) ; "
3024,"<S2SV_StartBug> st = decrease_reservation ( nr_pages , GFP_USER ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( si_mem_available ( ) < nr_pages ) return - ENOMEM ; 
3025,<S2SV_StartBug> p += 2 ; <S2SV_EndBug> <S2SV_StartBug> p += 3 ; <S2SV_EndBug> <S2SV_StartBug> p += 4 ; <S2SV_EndBug> <S2SV_StartBug> l = p [ 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 2 ) return - 1 ; <S2SV_ModStart> if ( len < 3 ) return - 1 ; <S2SV_ModStart> if ( len < 4 ) return - 1 ; <S2SV_ModStart> if ( len < 2 ) return - 1 ; 
3026,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> skb_free_datagram ( sk , skb ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } 
3027,"<S2SV_StartBug> p = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
3028,<S2SV_StartBug> for ( i = 1 ; i <= SYSTEM_ID_LEN ; i ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> int sysid_len ; sysid_len = SYSTEM_ID_LEN ; if ( sysid_len > id_len ) sysid_len = id_len ; <S2SV_ModStart> sysid_len <S2SV_ModEnd> 
3029,<S2SV_StartBug> line += PKT_LEN_SIZE ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ; 
3030,"<S2SV_StartBug> DBG_ENTER ( ""php_mysqlnd_rowp_read_text_protocol_aux"" ) ; <S2SV_EndBug> <S2SV_StartBug> unsigned long len = php_mysqlnd_net_field_length ( & p ) ; <S2SV_EndBug> ","<S2SV_ModStart> const zend_uchar * const packet_end = ( zend_uchar * ) row_buffer -> ptr + data_size ; <S2SV_ModStart> const <S2SV_ModStart> if ( len != MYSQLND_NULL_LENGTH && ( ( p + len ) > packet_end ) ) { php_error_docref ( NULL , E_WARNING , ""Malformed<S2SV_blank>server<S2SV_blank>packet.<S2SV_blank>Field<S2SV_blank>length<S2SV_blank>pointing<S2SV_blank>"" MYSQLND_SZ_T_SPEC ""<S2SV_blank>bytes<S2SV_blank>after<S2SV_blank>end<S2SV_blank>of<S2SV_blank>packet"" , ( p + len ) - packet_end - 1 ) ; DBG_RETURN ( FAIL ) ; } "
3031,<S2SV_StartBug> u8 odata [ 16 ] ; <S2SV_EndBug> ,<S2SV_ModStart> * odata = pctx -> odata ; u8 * idata = pctx -> idata <S2SV_ModEnd> 
3032,"<S2SV_StartBug> void * * p , void * end , void * obuf , size_t olen ) <S2SV_EndBug> <S2SV_StartBug> ret = ceph_decrypt2 ( secret , & head , & head_len , obuf , & olen , <S2SV_EndBug> ","<S2SV_ModStart> * <S2SV_ModStart> if ( * obuf == NULL ) { * obuf = kmalloc ( len , GFP_NOFS ) ; if ( ! * obuf ) return - ENOMEM ; olen = len ; } <S2SV_ModStart> * "
3033,<S2SV_StartBug> if ( name_len == 0 ) goto chunk_end ; <S2SV_EndBug> <S2SV_StartBug> READ_ENCINT ( length ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue 
3034,"<S2SV_StartBug> xim -> bytes_per_line * xim -> height , IPC_CREAT | 0777 ) ; <S2SV_EndBug> ",<S2SV_ModStart> 0600 <S2SV_ModEnd> 
3035,<S2SV_StartBug> if ( event -> attr . inherit || ! is_sampling_event ( event ) ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> struct perf_event_context * ctx ; int ret ; ctx = perf_event_ctx_lock <S2SV_ModEnd> <S2SV_ModStart> ret = _perf_event_refresh ( event , refresh ) ; perf_event_ctx_unlock ( event , ctx ) ; return ret <S2SV_ModEnd> "
3036,"<S2SV_StartBug> return udp_prot . setsockopt ( sk , level , optname , optval , optlen ) ; <S2SV_EndBug> ",<S2SV_ModStart> - EINVAL <S2SV_ModEnd> 
3037,<S2SV_StartBug> section -> frame = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> section -> sr_coded_error = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> section -> pcnt_neutral = 0.0 ; <S2SV_EndBug> ,<S2SV_ModStart> = 0.0 ; section -> weight <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = 0.0 ; section -> intra_skip_pct = 0.0 ; section -> inactive_zone_rows = 0.0 ; section -> inactive_zone_cols 
3038,<S2SV_StartBug> bool off_is_neg = off_reg -> smin_value < 0 ; <S2SV_EndBug> <S2SV_StartBug> alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; <S2SV_EndBug> ,<S2SV_ModStart> off_is_imm = tnum_is_const ( off_reg -> var_off ) ; bool <S2SV_ModStart> : 0 ; alu_state |= off_is_imm ? BPF_ALU_IMMEDIATE 
3039,"<S2SV_StartBug> while ( * end_ptr != \'\\""\' && * end_ptr && ++ len ) if ( * end_ptr ++ == '\\\\' ) end_ptr ++ ; <S2SV_EndBug> ",<S2SV_ModStart> { <S2SV_ModStart> { if ( * end_ptr == '\\0' ) { return 0 ; } end_ptr ++ ; } } <S2SV_ModEnd> 
3040,<S2SV_StartBug> if ( edge_port -> lsr_event ) { <S2SV_EndBug> ,<S2SV_ModStart> urb -> actual_length > 0 && 
3041,"<S2SV_StartBug> Rd_WP_DWORD ( image , & Rec . RecordLength ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; if ( Rec . RecordLength > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" "
3042,"<S2SV_StartBug> return reply_msg ( c , MSG_JOB_TOO_BIG ) ; <S2SV_EndBug> ","<S2SV_ModStart> skip ( c , body_size + 2 <S2SV_ModEnd> "
3043,<S2SV_StartBug> * d ++ = from_hex ( s [ 1 ] ) << 4 | from_hex ( s [ 2 ] ) ; <S2SV_EndBug> ,<S2SV_ModStart> char t <S2SV_ModEnd> <S2SV_ModStart> ) ; * d ++ = ( char ) ( ( isprint ( t ) ) ? t : '<S2SV_blank>' 
3044,<S2SV_StartBug> if ( buf -> pts == AV_NOPTS_VALUE ) { <S2SV_EndBug> ,<S2SV_ModStart> || av_fifo_size ( s -> fifo ) <= 0 
3045,"<S2SV_StartBug> if ( fscanf ( f , ""PG%[<S2SV_blank>\\t]%c%c%[<S2SV_blank>\\t+-]%d%[<S2SV_blank>\\t]%d%[<S2SV_blank>\\t]%d"" , temp , & endian1 , <S2SV_EndBug> ","<S2SV_ModStart> ""PG%31[<S2SV_blank>\\t]%c%c%31[<S2SV_blank>\\t+-]%d%31[<S2SV_blank>\\t]%d%31[<S2SV_blank>\\t]%d"" <S2SV_ModEnd> "
3046,<S2SV_StartBug> struct crypto_rng * rng = __crypto_rng_cast ( tfm ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3047,"<S2SV_StartBug> if ( value [ strlen ( value ) - 1 ] == ',' ) { <S2SV_EndBug> ",<S2SV_ModStart> * value == 0 || 
3048,"<S2SV_StartBug> if ( M_fs_perms_can_access ( path_new , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
3049,"<S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> ","<S2SV_ModStart> alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE "
3050,"<S2SV_StartBug> return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> int ret ; ret = scsi_verify_blk_ioctl ( bd , cmd ) ; if ( ret < 0 ) return ret ; "
3051,"<S2SV_StartBug> sc_debug ( card -> ctx , SC_LOG_DEBUG_NORMAL , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> if ( bufLen < 2 ) break ; <S2SV_ModStart> bufLen -= 2 ; 
3052,"<S2SV_StartBug> ptr = realloc ( priv -> EF_C_DevAut , len ) ; <S2SV_EndBug> <S2SV_StartBug> priv -> EF_C_DevAut_len = len ; <S2SV_EndBug> ",<S2SV_ModStart> if ( len > 0 ) { <S2SV_ModStart> } 
3053,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> horAcc16 ( tif , cp0 , cc ) ; <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return 
3054,<S2SV_StartBug> struct twopass_rc * const twopass = & cpi -> twopass ; <S2SV_EndBug> <S2SV_StartBug> FIRSTPASS_STATS this_frame_copy ; <S2SV_EndBug> <S2SV_StartBug> double this_frame_intra_error ; <S2SV_EndBug> <S2SV_StartBug> int is_spatial_svc = ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) ; <S2SV_EndBug> <S2SV_StartBug> lc = & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] ; <S2SV_EndBug> <S2SV_StartBug> cm -> current_video_frame ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc -> frames_till_gf_update_due == 0 ) { <S2SV_EndBug> ,"<S2SV_ModStart> TWO_PASS <S2SV_ModEnd> <S2SV_ModStart> ; GF_GROUP * const gf_group = & twopass -> gf_group <S2SV_ModStart> int target_rate ; LAYER_CONTEXT * const lc = is_two_pass_svc ( cpi ) ? & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] : 0 ; if ( lc != NULL ) { frames_left = ( int ) ( twopass -> total_stats . count - lc -> current_video_frame_in_layer ) ; } else { frames_left = ( int ) ( twopass -> total_stats . count - cm -> current_video_frame ) ; } if ( ! twopass -> stats_in ) return ; if ( gf_group -> update_type [ gf_group -> index ] == ARF_UPDATE ) { int target_rate ; configure_buffer_updates ( cpi ) ; target_rate = gf_group -> bit_allocation [ gf_group -> index ] ; target_rate = vp9_rc_clamp_pframe_target_size ( cpi , target_rate ) ; rc -> base_frame_target = target_rate ; cm -> frame_type = INTER_FRAME ; if ( lc != NULL ) { if ( cpi -> svc . spatial_layer_id == 0 ) { lc -> is_key_frame = 0 ; } else { lc -> is_key_frame = cpi -> svc . layer_context [ 0 ] . is_key_frame ; if ( lc -> is_key_frame ) cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ; } } if ( cpi -> sf . allow_partition_search_skip && cpi -> oxcf . pass == 2 && ( ! cpi -> use_svc || is_two_pass_svc ( cpi ) ) ) { cpi -> partition_search_skippable_frame = is_skippable_frame ( cpi ) ; } return ; } vpx_clear_system_state ( ) ; if ( cpi -> oxcf . rc_mode == VPX_Q ) { twopass -> active_worst_quality = cpi -> oxcf . cq_level ; } else if ( cm -> current_video_frame == 0 || ( lc != NULL && lc -> current_video_frame_in_layer == 0 ) ) { const int section_target_bandwidth = ( int ) ( twopass -> bits_left / frames_left ) ; const double section_length = twopass -> total_left_stats . count ; const double section_error = twopass -> total_left_stats . coded_error / section_length ; const double section_intra_skip = twopass -> total_left_stats . intra_skip_pct / section_length ; const double section_inactive_zone = ( twopass -> total_left_stats . inactive_zone_rows * 2 ) / ( ( double ) cm -> mb_rows * section_length ) ; const int tmp_q = get_twopass_worst_quality ( cpi , section_error , section_intra_skip + section_inactive_zone , section_target_bandwidth , DEFAULT_GRP_WEIGHT ) ; twopass -> active_worst_quality = tmp_q ; twopass -> baseline_active_worst_quality = tmp_q ; rc -> ni_av_qi = tmp_q ; rc -> last_q [ INTER_FRAME ] = tmp_q ; rc -> avg_q = vp9_convert_qindex_to_q ( tmp_q , cm -> bit_depth ) ; rc -> avg_frame_qindex [ INTER_FRAME ] = tmp_q ; rc -> last_q [ KEY_FRAME ] = ( tmp_q + cpi -> oxcf . best_allowed_q ) / 2 ; rc -> avg_frame_qindex [ KEY_FRAME ] = rc -> last_q [ KEY_FRAME ] ; } vp9_zero ( this_frame ) ; if ( EOF == input_stats ( twopass , & this_frame ) ) return ; if ( this_frame . intra_skip_pct >= FC_ANIMATION_THRESH ) twopass -> fr_content_type = FC_GRAPHICS_ANIMATION ; else twopass -> fr_content_type = FC_NORMAL ; if ( rc -> frames_to_key == 0 || ( cpi -> frame_flags & FRAMEFLAGS_KEY ) ) { <S2SV_ModStart> this_frame_copy = this_frame ; find_next_key_frame ( cpi , & this_frame ) ; this_frame = this_frame_copy ; } else { cm -> frame_type = INTER_FRAME ; } if ( lc != NULL ) { if ( <S2SV_ModEnd> <S2SV_ModStart> spatial_layer_id == 0 ) { lc -> is_key_frame = ( cm -> frame_type == KEY_FRAME ) ; if ( lc -> is_key_frame ) { cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ; lc -> frames_from_key_frame = 0 ; cpi -> svc . encode_intra_empty_frame = 1 ; } } else { cm -> frame_type = INTER_FRAME ; lc -> is_key_frame = <S2SV_ModEnd> <S2SV_ModStart> 0 ] . is_key_frame ; if ( lc -> is_key_frame ) { cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ; lc -> frames_from_key_frame = 0 ; } } } if ( rc -> frames_till_gf_update_due == 0 ) { define_gf_group ( cpi , & this_frame ) ; rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; if ( lc != NULL ) cpi -> refresh_golden_frame = 1 ; # if ARF_STATS_OUTPUT { FILE * fpfile ; fpfile = fopen ( ""arf.stt"" , ""a"" ) ; ++ arf_count ; fprintf ( fpfile , ""%10d<S2SV_blank>%10ld<S2SV_blank>%10d<S2SV_blank>%10d<S2SV_blank>%10ld\\n"" , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , rc -> kf_boost , arf_count , rc -> gfu_boost ) ; fclose ( fpfile ) ; } # endif } configure_buffer_updates ( cpi ) ; if ( cpi -> sf . allow_partition_search_skip && cpi -> oxcf . pass == 2 && ( ! cpi -> use_svc || is_two_pass_svc ( cpi ) ) ) { cpi -> partition_search_skippable_frame = is_skippable_frame ( cpi ) ; } target_rate = gf_group -> bit_allocation [ gf_group -> index ] ; if ( cpi -> common . frame_type == KEY_FRAME ) target_rate = vp9_rc_clamp_iframe_target_size ( cpi , target_rate ) ; else target_rate = vp9_rc_clamp_pframe_target_size ( cpi , target_rate ) ; rc -> base_frame_target = target_rate ; { const int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ; twopass -> mb_av_energy = log ( ( ( this_frame . intra_error * 256.0 ) / num_mbs ) + 1.0 ) ; } <S2SV_ModEnd> "
3055,<S2SV_StartBug> buf = g_malloc ( size ) ; <S2SV_EndBug> ,<S2SV_ModStart> g_malloc0 <S2SV_ModEnd> 
3056,"<S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> <S2SV_StartBug> index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ; <S2SV_EndBug> <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> if ( k < 0 ) continue <S2SV_ModEnd> 
3057,"<S2SV_StartBug> if ( ( ctxt -> mode == X86EMUL_MODE_PROT32 ) && ( efer & EFER_LMA ) <S2SV_EndBug> <S2SV_StartBug> switch ( ctxt -> mode ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> cs_sel = ( u16 ) msr_data ; <S2SV_EndBug> <S2SV_StartBug> ss_sel &= ~ SELECTOR_RPL_MASK ; <S2SV_EndBug> <S2SV_StartBug> if ( ctxt -> mode == X86EMUL_MODE_PROT64 || ( efer & EFER_LMA ) ) { <S2SV_EndBug> <S2SV_StartBug> ctxt -> _eip = msr_data ; <S2SV_EndBug> <S2SV_StartBug> * reg_write ( ctxt , VCPU_REGS_RSP ) = msr_data ; <S2SV_EndBug> ",<S2SV_ModStart> != X86EMUL_MODE_PROT64 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> & <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( efer & EFER_LMA ) ? msr_data : ( u32 ) <S2SV_ModStart> ( efer & EFER_LMA ) ? msr_data : ( u32 ) 
3058,<S2SV_StartBug> if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root > chm -> num_chunks ) { <S2SV_EndBug> <S2SV_StartBug> name = p ; p += name_len ; <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> <S2SV_ModStart> if ( name_len == 0 ) goto chunk_end ; 
3059,<S2SV_StartBug> return error ; <S2SV_EndBug> ,<S2SV_ModStart> < 0 ? error : 0 
3060,"<S2SV_StartBug> l2tp_bearer_cap_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> <S2SV_StartBug> const uint32_t * ptr = ( const uint32_t * ) dat ; <S2SV_EndBug> ","<S2SV_ModStart> , u_int length <S2SV_ModStart> if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } "
3061,<S2SV_StartBug> int delta_munlocked ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> delta_munlocked = - nr + pagevec_count ( & pvec_putback ) ; <S2SV_EndBug> ,<S2SV_ModStart> = - nr <S2SV_ModStart> else { delta_munlocked ++ ; } <S2SV_ModStart>  <S2SV_ModEnd> 
3062,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> count_mounts ( m -> mnt_ns , child ) <S2SV_ModEnd> "
3063,<S2SV_StartBug> for ( x = 0 ; x < ( ssize_t ) number_pixels ; x += 2 ) <S2SV_EndBug> ,<S2SV_ModStart> 4 <S2SV_ModEnd> 
3064,<S2SV_StartBug> update_db_bp_intercept ( & svm -> vcpu ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3065,"<S2SV_StartBug> if ( srp -> bio ) <S2SV_EndBug> <S2SV_StartBug> blk_end_request_all ( srp -> rq , - EIO ) ; <S2SV_EndBug> ",<S2SV_ModStart> { if ( srp -> rq -> cmd != srp -> rq -> __cmd ) kfree ( srp -> rq -> cmd ) ; <S2SV_ModStart> srp -> rq = NULL ; } 
3066,"<S2SV_StartBug> fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>.asoundrc<S2SV_blank>file\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> fs_logger2 ( ""clone"" , dest ) ; <S2SV_EndBug> ","<S2SV_ModStart> char * rp = realpath ( src , NULL ) ; if ( ! rp ) { <S2SV_ModStart> ""Error:<S2SV_blank>Cannot<S2SV_blank>access<S2SV_blank>%s\\n"" , src <S2SV_ModEnd> <S2SV_ModStart> if ( strncmp ( rp , cfg . homedir , strlen ( cfg . homedir ) ) != 0 ) { <S2SV_ModEnd> <S2SV_ModStart> ""Error:<S2SV_blank>.asoundrc<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>a<S2SV_blank>file<S2SV_blank>outside<S2SV_blank>home<S2SV_blank>directory\\n"" ) ; exit ( 1 ) ; } free ( rp ) ; } copy_file_as_user ( src , dest , getuid ( ) , getgid ( ) , 0644 ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3067,"<S2SV_StartBug> if ( zend_symtable_find ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P ( key ) + 1 , ( void * * ) & old_data ) == SUCCESS ) { <S2SV_EndBug> ",<S2SV_ModStart> zend_hash_find <S2SV_ModEnd> 
3068,"<S2SV_StartBug> rs . respond ( rs . arg , retval , NULL , NULL , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( retval == 0 ) rs . enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ; 
3069,<S2SV_StartBug> if ( PageDirty ( page ) ) { <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3070,<S2SV_StartBug> mask -> matte = MagickFalse ; <S2SV_EndBug> <S2SV_StartBug> channel_image = mask ; <S2SV_EndBug> ,<S2SV_ModStart> if ( mask != ( Image * ) NULL ) { <S2SV_ModStart> } 
3071,"<S2SV_StartBug> addresses = state -> endpoints ; <S2SV_EndBug> <S2SV_StartBug> while ( ( address = stok ( addresses , ""<S2SV_blank>\\t,"" , & tok ) ) != 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> for ( addresses = sclone ( <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart> ; addresses = tok ) { <S2SV_ModEnd> 
3072,<S2SV_StartBug> hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> sadb_msg_satype = SADB_SATYPE_UNSPEC ; hdr -> 
3073,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( pool ) ; 
3074,<S2SV_StartBug> align_get_bits ( gb ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0 
3075,"<S2SV_StartBug> list_for_each_entry_safe ( chain , nc , & ctx -> table -> chains , list ) { <S2SV_EndBug> <S2SV_StartBug> err = nft_delchain ( ctx ) ; <S2SV_EndBug> <S2SV_StartBug> list_for_each_entry_safe ( set , ns , & ctx -> table -> sets , list ) { <S2SV_EndBug> <S2SV_StartBug> if ( set -> flags & NFT_SET_ANONYMOUS && <S2SV_EndBug> ","<S2SV_ModStart> list_for_each_entry ( chain <S2SV_ModEnd> <S2SV_ModStart> } list_for_each_entry_safe ( set , ns , & ctx -> table -> sets , list ) { if ( set -> flags & NFT_SET_ANONYMOUS && ! list_empty ( & set -> bindings ) ) continue ; err = nft_delset ( ctx , set <S2SV_ModEnd> <S2SV_ModStart> chain , nc <S2SV_ModEnd> <S2SV_ModStart> chains <S2SV_ModEnd> <S2SV_ModStart> ctx -> chain = chain ; err = nft_delchain ( ctx <S2SV_ModEnd> "
3076,<S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , false "
3077,<S2SV_StartBug> free_uid ( group -> inotify_data . user ) ; <S2SV_EndBug> ,<S2SV_ModStart> atomic_dec ( & group -> inotify_data . user -> inotify_devs ) ; 
3078,<S2SV_StartBug> return ( ( Image * ) NULL ) ; <S2SV_EndBug> ,<S2SV_ModStart> break <S2SV_ModEnd> 
3079,"<S2SV_StartBug> length ; <S2SV_EndBug> <S2SV_StartBug> sun_pixels = sun_data ; <S2SV_EndBug> <S2SV_StartBug> ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> height , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( sun_info . type == RT_ENCODED ) <S2SV_ModStart>  <S2SV_ModEnd> "
3080,"<S2SV_StartBug> ret = scsi_disk_emulate_command ( r , r -> iov . iov_base ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
3081,<S2SV_StartBug> u16 offset = sizeof ( struct ipv6hdr ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( * * nexthdr ) { <S2SV_EndBug> <S2SV_StartBug> offset += ipv6_optlen ( exthdr ) ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned int <S2SV_ModEnd> <S2SV_ModStart> unsigned int len ; <S2SV_ModStart> len = ipv6_optlen ( exthdr ) ; if ( len + offset >= IPV6_MAXPLEN ) return - EINVAL ; offset += len <S2SV_ModEnd> 
3082,"<S2SV_StartBug> mpeg4_decode_profile_level ( s , gb ) ; <S2SV_EndBug> <S2SV_StartBug> ( s -> avctx -> level > 0 && s -> avctx -> level < 9 ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! s -> avctx -> bits_per_raw_sample ) { <S2SV_EndBug> ","<S2SV_ModStart> int profile , level ; <S2SV_ModStart> , & profile , & level ) ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> else if ( s -> studio_profile ) { avpriv_request_sample ( s -> avctx , ""Mixes<S2SV_blank>studio<S2SV_blank>and<S2SV_blank>non<S2SV_blank>studio<S2SV_blank>profile\\n"" ) ; return AVERROR_PATCHWELCOME ; } s -> avctx -> profile = profile ; s -> avctx -> level = level ; <S2SV_ModStart> av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ; "
3083,"<S2SV_StartBug> char err_msg [ 64 ] ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( err_msg , <S2SV_EndBug> <S2SV_StartBug> param_num , neatsvpv ( value , 0 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> * err_msg <S2SV_ModEnd> <S2SV_ModStart> err_msg = SvPVX ( sv_2mortal ( newSVpvf ( <S2SV_ModEnd> <S2SV_ModStart> ) ) 
3084,<S2SV_StartBug> if ( frame_end - frame < width + 3 ) <S2SV_EndBug> ,<S2SV_ModStart> 4 <S2SV_ModEnd> 
3085,<S2SV_StartBug> int check_fragments_for_errors ( VP8D_COMP * pbi ) <S2SV_EndBug> ,<S2SV_ModStart> static 
3086,"<S2SV_StartBug> for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( mask & 1 ) { <S2SV_EndBug> <S2SV_StartBug> ref_cnt_fb ( cm -> frame_bufs , & cm -> ref_frame_map [ ref_index ] , <S2SV_EndBug> <S2SV_StartBug> cm -> new_fb_idx ) ; <S2SV_EndBug> <S2SV_StartBug> if ( old_idx >= 0 && cm -> frame_bufs [ old_idx ] . ref_count == 0 ) <S2SV_EndBug> <S2SV_StartBug> cm -> frame_refs [ ref_index ] . idx = INT_MAX ; <S2SV_EndBug> ","<S2SV_ModStart> BufferPool * const pool = cm -> buffer_pool ; RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs ; lock_buffer_pool ( pool ) ; <S2SV_ModStart> const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; if ( <S2SV_ModEnd> <S2SV_ModStart> && old_idx >= 0 ) { decrease_ref_count ( old_idx , frame_bufs , pool ) ; } cm -> ref_frame_map [ ref_index ] = cm -> next_ref_frame_map [ ref_index ] ; ++ ref_index ; } for ( ; ref_index < REF_FRAMES && ! cm -> show_existing_frame ; ++ ref_index ) <S2SV_ModStart> decrease_ref_count ( old_idx , frame_bufs , pool ) ; cm -> ref_frame_map [ ref_index ] = cm -> next_ref_frame_map [ ref_index ] ; } unlock_buffer_pool ( pool ) ; pbi -> hold_ref_buf = 0 ; cm -> frame_to_show = get_frame_new_buffer ( cm ) ; if ( ! pbi -> frame_parallel_decode || ! cm -> show_frame ) { lock_buffer_pool ( pool ) ; -- frame_bufs [ <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; unlock_buffer_pool ( pool ) ; } <S2SV_ModEnd> <S2SV_ModStart> - 1 <S2SV_ModEnd> "
3087,<S2SV_StartBug> for ( s = 0 ; s < ns ; s ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && row < imagelength 
3088,<S2SV_StartBug> return in ; <S2SV_EndBug> ,<S2SV_ModStart> NULL <S2SV_ModEnd> 
3089,"<S2SV_StartBug> mutt_error ( ""%s"" , s + 3 ) ; <S2SV_EndBug> ",<S2SV_ModStart> 2 <S2SV_ModEnd> 
3090,<S2SV_StartBug> switch ( quantum_info -> depth ) <S2SV_EndBug> ,<S2SV_ModStart> pixel = 0 ; 
3091,"<S2SV_StartBug> vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end , <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * m = cm -> mi_grid_visible [ mi_row * cm -> mi_stride + mi_col ] ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_writer * w , <S2SV_ModEnd> <S2SV_ModStart> const TOKENEXTRA * const <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> td . <S2SV_ModStart> b_width_log2_lookup [ bsize ] <S2SV_ModEnd> <S2SV_ModStart> const MODE_INFO * m = NULL ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3092,"<S2SV_StartBug> safe_print ( value , valsz , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> safe_print ( value , valsz , ""\\"""" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank>\\\\\\""\'$`<>"" <S2SV_ModEnd> <S2SV_ModStart> ""\\""\\\\"" ) ; fputs ( ""\\"""" <S2SV_ModEnd> "
3093,<S2SV_StartBug> j = scantable [ idx ++ ] ; <S2SV_EndBug> <S2SV_StartBug> j = scantable [ idx ++ ] ; <S2SV_EndBug> <S2SV_StartBug> } else if ( group == 21 ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( idx > 63 ) return AVERROR_INVALIDDATA ; 
3094,"<S2SV_StartBug> int i , pktsz , ret ; <S2SV_EndBug> <S2SV_StartBug> dev_dbg ( dev , ""Checking<S2SV_blank>memory<S2SV_blank>size\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> i = 0x12345678 ; <S2SV_EndBug> <S2SV_StartBug> catc_write_mem ( catc , 0x7a80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> i = 0x87654321 ; <S2SV_EndBug> <S2SV_StartBug> catc_write_mem ( catc , 0xfa80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> catc_read_mem ( catc , 0x7a80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( i ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> u32 * buf ; int i ; <S2SV_ModStart> buf = kmalloc ( 4 , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; goto fail_free ; } * buf <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> * buf <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> * buf <S2SV_ModEnd> <S2SV_ModStart> kfree ( buf ) ; "
3095,<S2SV_StartBug> const unsigned char * old_name ; <S2SV_EndBug> <S2SV_StartBug> if ( source == target ) <S2SV_EndBug> <S2SV_StartBug> old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> struct name_snapshot old_name ; <S2SV_ModStart> take_dentry_name_snapshot ( & old_name , old_dentry ) ; dget ( new_dentry ) ; if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) lock_two_nondirectories ( source , target ) ; else if ( target ) inode_lock ( target ) ; error = - EBUSY ; if ( is_local_mountpoint ( old_dentry ) || is_local_mountpoint ( new_dentry ) ) goto out ; if ( max_links && new_dir != old_dir ) { error = - EMLINK ; if ( is_dir && ! new_is_dir && new_dir -> i_nlink >= max_links ) goto out ; if ( ( flags & RENAME_EXCHANGE ) && ! is_dir && new_is_dir && old_dir -> i_nlink >= max_links ) goto out ; } if ( is_dir && ! ( flags & RENAME_EXCHANGE ) && target ) shrink_dcache_parent ( new_dentry ) ; if ( ! is_dir ) { error = try_break_deleg ( source , delegated_inode ) ; if ( error ) goto out ; } if ( target && ! new_is_dir ) { error = try_break_deleg ( target , delegated_inode ) ; if ( error ) goto out ; } error = old_dir -> i_op -> rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; if ( error ) goto out ; if ( ! ( flags & RENAME_EXCHANGE ) && target ) { if ( is_dir ) target -> i_flags |= S_DEAD ; dont_mount ( new_dentry ) ; detach_mounts ( new_dentry ) ; } if ( ! ( old_dir -> i_sb -> s_type -> fs_flags & FS_RENAME_DOES_D_MOVE ) ) { if ( ! ( flags & RENAME_EXCHANGE ) ) d_move ( old_dentry , new_dentry ) ; else d_exchange ( old_dentry , new_dentry ) ; } out : if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) unlock_two_nondirectories ( source , target ) ; else if ( target ) inode_unlock ( target ) ; dput ( new_dentry ) ; if ( ! error ) { fsnotify_move ( old_dir , new_dir , old_name . name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ; if ( flags & RENAME_EXCHANGE ) { fsnotify_move ( new_dir , old_dir , <S2SV_ModEnd> <S2SV_ModStart> , new_is_dir , NULL , new_dentry ) ; } } release_dentry_name_snapshot ( & old_name <S2SV_ModEnd> "
3096,<S2SV_StartBug> if ( PageDirty ( page ) ) { <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3097,"<S2SV_StartBug> unix_insert_socket ( unix_sockets_unbound ( sk ) , sk ) ; <S2SV_EndBug> ","<S2SV_ModStart> init_waitqueue_func_entry ( & u -> peer_wake , unix_dgram_peer_wake_relay ) ; "
3098,<S2SV_StartBug> struct user_element * ue = kcontrol -> private_data ; <S2SV_EndBug> <S2SV_StartBug> return change ; <S2SV_EndBug> ,<S2SV_ModStart> ; mutex_lock ( & ue -> card -> user_ctl_lock ) <S2SV_ModStart> mutex_unlock ( & ue -> card -> user_ctl_lock ) ; 
3099,"<S2SV_StartBug> char * name ; <S2SV_EndBug> <S2SV_StartBug> if ( EVP_CipherInit_ex ( ctx , cipher , NULL , dummy_key , NULL , - 1 ) != 1 ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> NULL <S2SV_ModEnd> 
3100,"<S2SV_StartBug> NICK_REC * list ; <S2SV_EndBug> <S2SV_StartBug> if ( list == nick || list -> next == NULL ) { <S2SV_EndBug> <S2SV_StartBug> g_hash_table_insert ( channel -> nicks , nick -> next -> nick , <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , * newlist <S2SV_ModStart> ) { newlist = <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> <S2SV_ModStart> newlist = list ; <S2SV_ModStart> g_hash_table_remove ( channel -> nicks , nick -> nick ) ; if ( newlist != NULL ) { g_hash_table_insert ( channel -> nicks , newlist -> nick , newlist ) ; } "
3101,"<S2SV_StartBug> jas_matrix_t * jas_seq2d_create ( int xstart , int ystart , int xend , int yend ) <S2SV_EndBug> ","<S2SV_ModStart> jas_matind_t xstart , jas_matind_t ystart , jas_matind_t xend , jas_matind_t <S2SV_ModEnd> "
3102,"<S2SV_StartBug> imap_quote_string ( q_user , sizeof ( q_user ) , idata -> conn -> account . user ) ; <S2SV_EndBug> <S2SV_StartBug> imap_quote_string ( q_pass , sizeof ( q_pass ) , idata -> conn -> account . pass ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false <S2SV_ModStart> , false "
3103,<S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n"" , __func__ , dev -> bar [ i ] . type ) ; return <S2SV_ModEnd> "
3104,"<S2SV_StartBug> ut8 * buf = calloc ( to - from , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> r_buf_read_at ( bf -> buf , from , buf , to - from ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( to - needle ) > 5 ) { <S2SV_EndBug> <S2SV_StartBug> bool is_wide32 = needle + rc + 2 < to && ! w [ 0 ] && ! w [ 1 ] && ! w [ 2 ] && w [ 3 ] && ! w [ 4 ] ; <S2SV_EndBug> ",<S2SV_ModStart> int len = to - from ; <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> + rc <S2SV_ModStart> ( <S2SV_ModStart> ) && ( <S2SV_ModEnd> <S2SV_ModStart> ) 
3105,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
3106,<S2SV_StartBug> if ( ( int ) arg >= cdi -> capacity ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3107,"<S2SV_StartBug> int bytes_returned , name_len ; <S2SV_EndBug> ",<S2SV_ModStart> ; unsigned int <S2SV_ModEnd> 
3108,<S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ; <S2SV_EndBug> ,"<S2SV_ModStart> size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> alloc_size <S2SV_ModEnd> "
3109,"<S2SV_StartBug> ""Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>length<S2SV_blank>%"" PRIsize ""<S2SV_blank><<S2SV_blank>_%lu_<S2SV_blank><<S2SV_blank>%lu<S2SV_blank>(BT_SHB_INSANE_MAX)"" , <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank><<S2SV_blank>_%u_<S2SV_blank><<S2SV_blank>%u<S2SV_blank>(BT_SHB_INSANE_MAX)"" <S2SV_ModEnd> "
3110,<S2SV_StartBug> if ( bee -> ui -> ft_in_start ) { <S2SV_EndBug> ,<S2SV_ModStart> && bu 
3111,"<S2SV_StartBug> strcpy ( cat_enum . szPath , fileName ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( cat_enum . szRad1 , fileName ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( cat_enum . szRad1 , sep + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> sep = strchr ( cat_enum . szRad1 , '*' ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( cat_enum . szRad2 , sep + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> sep = strchr ( cat_enum . szRad2 , '%' ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sep ) { <S2SV_EndBug> ","<S2SV_ModStart> if ( strlen ( fileName ) >= sizeof <S2SV_ModEnd> <S2SV_ModStart> ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szPath <S2SV_ModStart> if ( strlen ( fileName ) >= sizeof <S2SV_ModEnd> <S2SV_ModStart> ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 <S2SV_ModStart> if ( strlen ( <S2SV_ModEnd> <S2SV_ModStart> >= sizeof <S2SV_ModEnd> <S2SV_ModStart> ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , ( <S2SV_ModEnd> <S2SV_ModStart> ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 , sep + 1 ) <S2SV_ModStart> } <S2SV_ModStart> szRad1 , '*' ) ; if ( strlen ( sep + 1 ) >= sizeof ( cat_enum . szRad2 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , ( sep + 1 ) ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad2 , sep + 1 ) ; sep [ 0 ] = 0 ; sep = strchr ( cat_enum . szRad2 <S2SV_ModEnd> <S2SV_ModStart> if ( strlen ( sep ) >= sizeof ( cat_enum . szOpt ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""Invalid<S2SV_blank>option:<S2SV_blank>%s.\\n"" , sep ) ) ; return GF_NOT_SUPPORTED ; } "
3112,"<S2SV_StartBug> TLV_TCHECK ( 8 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> 12 <S2SV_ModEnd> <S2SV_ModStart> ""%s"" , tstr <S2SV_ModEnd> "
3113,<S2SV_StartBug> hrtimer_cancel ( & stime -> hrt ) ; <S2SV_EndBug> ,<S2SV_ModStart> hrtimer_try_to_cancel <S2SV_ModEnd> 
3114,<S2SV_StartBug> const unsigned char * old_name ; <S2SV_EndBug> <S2SV_StartBug> if ( source == target ) <S2SV_EndBug> <S2SV_StartBug> old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> struct name_snapshot old_name ; <S2SV_ModStart> take_dentry_name_snapshot ( & old_name , old_dentry ) ; dget ( new_dentry ) ; if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) lock_two_nondirectories ( source , target ) ; else if ( target ) inode_lock ( target ) ; error = - EBUSY ; if ( is_local_mountpoint ( old_dentry ) || is_local_mountpoint ( new_dentry ) ) goto out ; if ( max_links && new_dir != old_dir ) { error = - EMLINK ; if ( is_dir && ! new_is_dir && new_dir -> i_nlink >= max_links ) goto out ; if ( ( flags & RENAME_EXCHANGE ) && ! is_dir && new_is_dir && old_dir -> i_nlink >= max_links ) goto out ; } if ( is_dir && ! ( flags & RENAME_EXCHANGE ) && target ) shrink_dcache_parent ( new_dentry ) ; if ( ! is_dir ) { error = try_break_deleg ( source , delegated_inode ) ; if ( error ) goto out ; } if ( target && ! new_is_dir ) { error = try_break_deleg ( target , delegated_inode ) ; if ( error ) goto out ; } error = old_dir -> i_op -> rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; if ( error ) goto out ; if ( ! ( flags & RENAME_EXCHANGE ) && target ) { if ( is_dir ) target -> i_flags |= S_DEAD ; dont_mount ( new_dentry ) ; detach_mounts ( new_dentry ) ; } if ( ! ( old_dir -> i_sb -> s_type -> fs_flags & FS_RENAME_DOES_D_MOVE ) ) { if ( ! ( flags & RENAME_EXCHANGE ) ) d_move ( old_dentry , new_dentry ) ; else d_exchange ( old_dentry , new_dentry ) ; } out : if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) unlock_two_nondirectories ( source , target ) ; else if ( target ) inode_unlock ( target ) ; dput ( new_dentry ) ; if ( ! error ) { fsnotify_move ( old_dir , new_dir , old_name . name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ; if ( flags & RENAME_EXCHANGE ) { fsnotify_move ( new_dir , old_dir , <S2SV_ModEnd> <S2SV_ModStart> , new_is_dir , NULL , new_dentry ) ; } } release_dentry_name_snapshot ( & old_name <S2SV_ModEnd> "
3115,"<S2SV_StartBug> return __blkdev_driver_ioctl ( fc -> dev -> bdev , fc -> dev -> mode , cmd , arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct dm_dev * dev = fc -> dev ; int r = 0 ; if <S2SV_ModEnd> <S2SV_ModStart> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( <S2SV_ModStart>  <S2SV_ModEnd> "
3116,"<S2SV_StartBug> snd_pcm_stream_unlock_irqrestore ( substream , flags ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> snd_pcm_stream_unlock_irqrestore ( substream , flags ) ; "
3117,"<S2SV_StartBug> void bpf_map_inc ( struct bpf_map * map , bool uref ) <S2SV_EndBug> <S2SV_StartBug> atomic_inc ( & map -> refcnt ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> struct bpf_map * <S2SV_ModEnd> <S2SV_ModStart> if ( atomic_inc_return ( & map -> refcnt ) > BPF_MAX_REFCNT ) { atomic_dec <S2SV_ModEnd> <S2SV_ModStart> return ERR_PTR ( - EBUSY ) ; } <S2SV_ModStart> return map ; 
3118,<S2SV_StartBug> struct pstore * ps = get_info ( store ) ; <S2SV_EndBug> <S2SV_StartBug> stride = ( ps -> exceptions_per_area + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ps -> next_free ++ ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; skip_metadata ( ps ) 
3119,"<S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
3120,"<S2SV_StartBug> return usb_control_msg ( dev -> udev , usb_rcvctrlpipe ( dev -> udev , 0 ) , <S2SV_EndBug> <S2SV_StartBug> indx , 0 , data , size , 500 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> void * buf ; int ret ; buf = kmalloc ( size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> if ( ret > 0 && ret <= size ) memcpy ( data , buf , ret ) ; kfree ( buf ) ; return ret ; "
3121,"
","
"
3122,"<S2SV_StartBug> static int decode_term_subexp ( vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_read_bit ( r ) ) <S2SV_EndBug> <S2SV_StartBug> return vp9_read_literal ( r , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_read_bit ( r ) ) <S2SV_EndBug> <S2SV_StartBug> return vp9_read_literal ( r , 4 ) + 16 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_read_bit ( r ) ) <S2SV_EndBug> <S2SV_StartBug> return vp9_read_literal ( r , 5 ) + 32 ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_read_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_read_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_read_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_read_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_read_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_read_literal <S2SV_ModEnd> 
3123,"<S2SV_StartBug> int best_filt_val = cm -> filter_level ; <S2SV_EndBug> <S2SV_StartBug> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <S2SV_EndBug> <S2SV_StartBug> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <S2SV_EndBug> <S2SV_StartBug> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> yv12_copy_partial_frame <S2SV_ModEnd> <S2SV_ModStart> yv12_copy_partial_frame <S2SV_ModEnd> <S2SV_ModStart> yv12_copy_partial_frame <S2SV_ModEnd> 
3124,<S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( opened & FILE_OPENED ) ) { <S2SV_EndBug> ,<S2SV_ModStart> out2 <S2SV_ModEnd> <S2SV_ModStart> out2 : 
3125,<S2SV_StartBug> value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned short ) ( value & 0xffff ) ) ; <S2SV_EndBug> <S2SV_StartBug> value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned short ) ( value & 0xffff ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned short ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> buffer <S2SV_ModEnd> <S2SV_ModStart> ; value |= <S2SV_ModEnd> <S2SV_ModStart> buffer [ 1 ] ; return <S2SV_ModStart>  <S2SV_ModEnd> 
3126,"<S2SV_StartBug> if ( M_fs_perms_can_access ( path_new , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
3127,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> alt = & gspca_dev -> dev -> actconfig -> intf_cache [ 0 ] -> altsetting [ 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart> struct usb_interface_cache * intfc ; <S2SV_ModStart> intfc = <S2SV_ModEnd> <S2SV_ModStart> ; if ( intfc -> num_altsetting < 2 ) return - ENODEV ; alt = & intfc <S2SV_ModStart> ; if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV 
3128,<S2SV_StartBug> if ( ! is_launcher ) <S2SV_EndBug> <S2SV_StartBug> if ( nautilus_file_can_execute ( file ) ) <S2SV_EndBug> ,"<S2SV_ModStart> g_autofree gchar * trusted = NULL ; <S2SV_ModStart> trusted = nautilus_file_get_metadata ( file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL ) ; <S2SV_ModStart> && trusted != NULL "
3129,"<S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> ThrowReaderException ( CorruptImageError , <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> ThrowDCMException <S2SV_ModEnd> 
3130,"<S2SV_StartBug> if ( ! copy_from_iter_full ( kbuf , len , from ) ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> return ret < 0 ? ret : len ; <S2SV_EndBug> ",<S2SV_ModStart> { kfree ( kbuf ) ; <S2SV_ModStart> } <S2SV_ModStart> kfree ( kbuf ) ; 
3131,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( clk_src ) ; 
3132,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> WaitForMessage ( client , 100000 ) ; <S2SV_EndBug> <S2SV_StartBug> WaitForMessage ( client , 100000 ) ; <S2SV_EndBug> ","<S2SV_ModStart> const int USECS_WAIT_PER_RETRY = 100000 ; int retries = 0 ; <S2SV_ModStart> if ( client -> readTimeout > 0 && ++ retries > ( client -> readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY ) ) { rfbClientLog ( ""Connection<S2SV_blank>timed<S2SV_blank>out\\n"" ) ; return FALSE ; } <S2SV_ModStart> USECS_WAIT_PER_RETRY <S2SV_ModEnd> <S2SV_ModStart> if ( client -> readTimeout > 0 && ++ retries > ( client -> readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY ) ) { rfbClientLog ( ""Connection<S2SV_blank>timed<S2SV_blank>out\\n"" ) ; return FALSE ; } <S2SV_ModStart> USECS_WAIT_PER_RETRY <S2SV_ModEnd> "
3133,<S2SV_StartBug> subobj_len = EXTRACT_16BITS ( obj_tptr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( subobj_len == 0 ) <S2SV_EndBug> ,<S2SV_ModStart> if ( total_subobj_len < 4 ) goto invalid ; <S2SV_ModStart> < 4 || subobj_len > total_subobj_len <S2SV_ModEnd> 
3134,"<S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> isoclns_print ( ndo , p , length , ndo -> ndo_snapend - p ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3135,"<S2SV_StartBug> xdr_free ( xdr_func , xdr_ptr ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
3136,"<S2SV_StartBug> c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> aligned_height = FFALIGN ( c -> height , 16 ) ; <S2SV_EndBug> ",<S2SV_ModStart> + 15 <S2SV_ModEnd> <S2SV_ModStart> * 3 ; aligned_height = <S2SV_ModEnd> <S2SV_ModStart> + 15 <S2SV_ModEnd> 
3137,<S2SV_StartBug> && ( ps_dec -> s_bit_stream . u4_offset <= ps_dec -> s_bit_stream . u4_max_offset ) ) <S2SV_EndBug> ,<S2SV_ModStart> < <S2SV_ModEnd> 
3138,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mode != inode -> i_mode ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error ) return error <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3139,"<S2SV_StartBug> SDev = cd -> device ; <S2SV_EndBug> <S2SV_StartBug> ( unsigned char * ) cgc -> sense , & sshdr , <S2SV_EndBug> ","<S2SV_ModStart> unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ; <S2SV_ModStart> ; if ( cgc -> sense ) senseptr = sense_buffer <S2SV_ModStart> senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( cgc -> sense ) memcpy ( cgc -> sense , sense_buffer , sizeof ( * <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> "
3140,<S2SV_StartBug> log_flush ( LOG_MODE_ERROR ) ; <S2SV_EndBug> ,<S2SV_ModStart> LOG_MODE_BUFFER <S2SV_ModEnd> 
3141,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ps_dec -> u2_cur_slice_num ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic != 0 ) <S2SV_EndBug> ,<S2SV_ModStart> ps_dec -> u4_first_slice_in_pic = 0 ; <S2SV_ModStart> if ( ps_dec -> u4_first_slice_in_pic != 0 ) { ps_dec -> ps_parse_cur_slice ++ ; <S2SV_ModStart> } <S2SV_ModEnd> 
3142,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> { return 0 ; } <S2SV_ModEnd> 
3143,<S2SV_StartBug> if ( ! vct_iscrlf ( * p ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( ; ! vct_iscrlf ( * p ) ; p ++ ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3144,"<S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> != c ) break 
3145,<S2SV_StartBug> lua_newtable ( L ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_decode_to_lua_array"" "
3146,<S2SV_StartBug> if ( tcp -> csty & J2K_CP_CSTY_SOP ) { <S2SV_EndBug> <S2SV_StartBug> if ( tcp -> csty & J2K_CP_CSTY_EPH ) { <S2SV_EndBug> ,"<S2SV_ModStart> if ( length < 6 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n"" , length , 6 ) ; } return OPJ_FALSE ; } <S2SV_ModStart> if ( length < 2 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n"" , length , 2 ) ; } return OPJ_FALSE ; } "
3147,"<S2SV_StartBug> ( void ) data ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ctx -> priv ) <S2SV_EndBug> <S2SV_StartBug> vpx_codec_mmap_t mmap ; <S2SV_EndBug> <S2SV_StartBug> vp8_init_ctx ( ctx , & mmap ) ; <S2SV_EndBug> <S2SV_StartBug> ctx -> priv -> alg_priv -> fragments . count = 0 ; <S2SV_EndBug> <S2SV_StartBug> ctx -> priv -> alg_priv -> fragments . enabled = <S2SV_EndBug> <S2SV_StartBug> ( ctx -> priv -> alg_priv -> base . init_flags & <S2SV_EndBug> <S2SV_StartBug> ctx -> priv -> alg_priv -> defer_alloc = 1 ; <S2SV_EndBug> <S2SV_StartBug> ( ctx -> priv -> alg_priv -> base . init_flags & <S2SV_EndBug> <S2SV_StartBug> ctx -> priv -> alg_priv -> yv12_frame_buffers . use_frame_threads = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> priv -> alg_priv -> yv12_frame_buffers . use_frame_threads && <S2SV_EndBug> <S2SV_StartBug> ( ( ctx -> priv -> alg_priv -> base . init_flags & <S2SV_EndBug> <S2SV_StartBug> VPX_CODEC_USE_ERROR_CONCEALMENT ) <S2SV_EndBug> <S2SV_StartBug> || ( ctx -> priv -> alg_priv -> base . init_flags & <S2SV_EndBug> ",<S2SV_ModStart> vpx_codec_alg_priv_t * priv = NULL ; <S2SV_ModStart> vpx_dsp_rtcd ( ) ; vpx_scale_rtcd ( ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; priv = ( vpx_codec_alg_priv_t * ) <S2SV_ModEnd> <S2SV_ModStart> ; priv <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart> } else { priv = ( vpx_codec_alg_priv_t * ) <S2SV_ModStart> ; } priv <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3148,<S2SV_StartBug> struct inode * inode = file_inode ( bprm -> file ) ; <S2SV_EndBug> <S2SV_StartBug> bprm -> cred -> euid = current_euid ( ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> bprm_fill_uid ( bprm ) ; <S2SV_ModEnd> 
3149,<S2SV_StartBug> if ( ( peer != NULL ) && ( type & EVP_PKT_SIGN ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3150,"<S2SV_StartBug> VP9_CONFIG * oxcf , <S2SV_EndBug> <S2SV_StartBug> oxcf -> profile = cfg -> g_profile ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> width = cfg -> g_w ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> bit_depth = extra_cfg -> bit_depth ; <S2SV_EndBug> <S2SV_StartBug> if ( oxcf -> framerate > 180 ) <S2SV_EndBug> <S2SV_StartBug> oxcf -> framerate = 30 ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> mode = MODE_GOODQUALITY ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> mode = MODE_FIRSTPASS ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> mode = MODE_SECONDPASS_BEST ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> end_usage = USAGE_LOCAL_FILE_PLAYBACK ; <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> rc_end_usage == VPX_CQ ) <S2SV_EndBug> <S2SV_StartBug> oxcf -> target_bandwidth = cfg -> rc_target_bitrate ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> best_allowed_q = q_trans [ cfg -> rc_min_quantizer ] ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> worst_allowed_q = q_trans [ cfg -> rc_max_quantizer ] ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> cq_level = q_trans [ extra_cfg -> cq_level ] ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> maximum_buffer_size = cfg -> rc_buf_sz ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> starting_buffer_level = cfg -> rc_buf_initial_sz ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> optimal_buffer_level = cfg -> rc_buf_optimal_sz ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> cpu_used = extra_cfg -> cpu_used ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> play_alternate = extra_cfg -> enable_auto_alt_ref ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> output_pkt_list = extra_cfg -> pkt_list ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> arnr_type = extra_cfg -> arnr_type ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> tile_columns = extra_cfg -> tile_columns ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> lossless = extra_cfg -> lossless ; <S2SV_EndBug> <S2SV_StartBug> if ( oxcf -> ss_number_layers > 1 ) { <S2SV_EndBug> <S2SV_StartBug> vp9_copy ( oxcf -> ss_target_bitrate , cfg -> ss_target_bitrate ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( oxcf -> ss_number_layers == 1 ) { <S2SV_EndBug> <S2SV_StartBug> oxcf -> ts_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ; <S2SV_EndBug> ","<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> const int is_vbr = cfg -> rc_end_usage == VPX_VBR ; int sl , tl ; <S2SV_ModStart> max_threads = ( int ) cfg -> g_threads ; oxcf -> <S2SV_ModStart> cfg -> g_bit_depth ; oxcf -> input_bit_depth = cfg -> g_input_bit_depth ; oxcf -> init_framerate <S2SV_ModEnd> <S2SV_ModStart> init_framerate <S2SV_ModEnd> <S2SV_ModStart> init_framerate = 30 ; oxcf -> mode = GOOD <S2SV_ModEnd> <S2SV_ModStart> pass = 0 <S2SV_ModEnd> <S2SV_ModStart> pass = 1 <S2SV_ModEnd> <S2SV_ModStart> pass = 2 <S2SV_ModEnd> <S2SV_ModStart> rc_mode = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 1000 * <S2SV_ModStart> rc_max_inter_bitrate_pct = extra_cfg -> rc_max_inter_bitrate_pct ; oxcf -> gf_cbr_boost_pct = extra_cfg -> gf_cbr_boost_pct ; oxcf -> best_allowed_q = extra_cfg -> lossless ? 0 : vp9_quantizer_to_qindex ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> extra_cfg -> lossless ? 0 : vp9_quantizer_to_qindex ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> vp9_quantizer_to_qindex ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> scaled_frame_width = cfg -> rc_scaled_width ; oxcf -> scaled_frame_height = cfg -> rc_scaled_height ; if ( cfg -> rc_resize_allowed == 1 ) { oxcf -> resize_mode = ( oxcf -> scaled_frame_width == 0 || oxcf -> scaled_frame_height == 0 ) ? RESIZE_DYNAMIC : RESIZE_FIXED ; } else { oxcf -> resize_mode = RESIZE_NONE ; } oxcf -> maximum_buffer_size_ms = is_vbr ? 240000 : <S2SV_ModEnd> <S2SV_ModStart> starting_buffer_level_ms = is_vbr ? 60000 : <S2SV_ModEnd> <S2SV_ModStart> optimal_buffer_level_ms = is_vbr ? 60000 : <S2SV_ModEnd> <S2SV_ModStart> speed = abs ( extra_cfg -> cpu_used ) <S2SV_ModEnd> <S2SV_ModStart> enable_auto_arf <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_FP_MB_STATS oxcf -> firstpass_mb_stats_in = cfg -> rc_firstpass_mb_stats_in ; # endif oxcf -> color_space = extra_cfg -> color_space <S2SV_ModEnd> <S2SV_ModStart> min_gf_interval = extra_cfg -> min_gf_interval ; oxcf -> max_gf_interval = extra_cfg -> max_gf_interval <S2SV_ModEnd> <S2SV_ModStart> content = extra_cfg -> content ; oxcf -> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> oxcf -> ts_number_layers = cfg -> ts_number_layers ; oxcf -> temporal_layering_mode = ( enum vp9e_temporal_layering_mode ) cfg -> temporal_layering_mode ; for ( sl = 0 ; sl < oxcf -> ss_number_layers ; ++ sl ) { # if CONFIG_SPATIAL_SVC oxcf -> ss_enable_auto_arf [ sl ] = cfg -> ss_enable_auto_alt_ref [ sl ] ; # endif for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { oxcf -> layer_target_bitrate [ sl * oxcf -> ts_number_layers + tl ] = 1000 * cfg -> layer_target_bitrate [ sl * oxcf -> ts_number_layers + tl ] ; } } if <S2SV_ModEnd> <S2SV_ModStart> == 1 && oxcf -> pass != 0 ) { oxcf -> ss_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ; # if CONFIG_SPATIAL_SVC oxcf -> ss_enable_auto_arf [ 0 ] = extra_cfg -> enable_auto_alt_ref ; # endif } if ( oxcf -> ts_number_layers <S2SV_ModStart> for ( tl = 0 ; tl < VPX_TS_MAX_LAYERS ; ++ tl ) { oxcf -> ts_rate_decimator [ tl ] = cfg -> ts_rate_decimator [ tl ] ? cfg -> ts_rate_decimator [ tl ] : 1 ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3151,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> indx , data , size , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> u8 * buf ; int ret ; buf = kmalloc ( size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> else if ( ret <= size ) memcpy ( data , buf , ret ) ; kfree ( buf ) ; "
3152,<S2SV_StartBug> if ( ! saw_digit ) <S2SV_EndBug> <S2SV_StartBug> goto invalid ; <S2SV_EndBug> <S2SV_StartBug> if ( * bp != '\\r' ) <S2SV_EndBug> <S2SV_StartBug> goto invalid ; <S2SV_EndBug> <S2SV_StartBug> if ( * bp != '\\n' ) <S2SV_EndBug> <S2SV_StartBug> goto invalid ; <S2SV_EndBug> <S2SV_StartBug> return ( - 2 ) ; <S2SV_EndBug> <S2SV_StartBug> return ( - 5 ) ; <S2SV_EndBug> ,<S2SV_ModStart> { bp ++ ; <S2SV_ModStart> } <S2SV_ModStart> { bp ++ ; <S2SV_ModStart> } <S2SV_ModStart> { bp ++ ; <S2SV_ModStart> } <S2SV_ModStart> * endp = bp ; <S2SV_ModStart> * endp = bp ; 
3153,<S2SV_StartBug> len = dp -> ip6r_len ; <S2SV_EndBug> ,<S2SV_ModStart> ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> ip6r_segleft ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
3154,"<S2SV_StartBug> size_t cnt = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( ( ! __libc_enable_secure <S2SV_EndBug> <S2SV_StartBug> && strncmp ( & name [ 1 ] , ""ORIGIN"" , 6 ) == 0 && ( len = 7 ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> && strncmp ( & name [ 2 ] , ""ORIGIN}"" , 7 ) == 0 && ( len = 9 ) != 0 ) <S2SV_EndBug> ","<S2SV_ModStart> const char * const start = name ; <S2SV_ModStart> strncmp ( & name [ 1 ] , ""ORIGIN}"" , 6 ) == 0 && ( ! __libc_enable_secure || ( ( name [ 7 ] == '\\0' || ( is_path && name [ 7 ] == ':' ) ) && ( name == start || ( is_path && name [ - 1 ] == ':' ) ) ) ) && ( len = 7 ) != 0 ) || ( <S2SV_ModEnd> <S2SV_ModStart> ""PLATFORM}"" , 8 ) == 0 && ( len = 9 ) != 0 ) ) && ( name [ len ] == '\\0' || name [ len ] == '/' || ( is_path && name [ len ] == ':' ) ) ) || ( name [ 1 ] == '{' && ( ( strncmp ( & name [ 2 ] , ""ORIGIN}"" , 7 ) == 0 && <S2SV_ModEnd> <S2SV_ModStart> || ( ( name [ 9 ] == '\\0' || ( is_path && name [ 9 ] == ':' ) ) && ( name == start || ( is_path && name [ - 1 ] == ':' ) ) ) ) <S2SV_ModEnd> "
3155,"<S2SV_StartBug> retval = generic_gss_oid_decompose ( minor_status , <S2SV_EndBug> ",<S2SV_ModStart> if ( ctx -> terminated || ! ctx -> established ) { * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; } 
3156,<S2SV_StartBug> ( 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) | ( 1u << AC_VECTOR 
3157,"<S2SV_StartBug> file = kmalloc ( sizeof ( * file ) , GFP_NOIO ) ; <S2SV_EndBug> ",<S2SV_ModStart> kzalloc <S2SV_ModEnd> 
3158,"<S2SV_StartBug> tags = stok ( sclone ( tags ) , ""<S2SV_blank>"" , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> ssplit <S2SV_ModEnd> 
3159,"<S2SV_StartBug> if ( ! memcmp ( buf + 5 , ""include"" , 7 ) ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( ! memcmp ( buf + 5 , ""exec"" , 4 ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ( len > 12 ) && <S2SV_ModStart> ( len > 9 ) && 
3160,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> keymap -> num_key_aliases = num_key_aliases ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } 
3161,<S2SV_StartBug> int nalloca ; <S2SV_EndBug> <S2SV_StartBug> if ( skip == 0 && glob_pattern_p ( pat ) == 0 ) <S2SV_EndBug> ,<S2SV_ModStart> hasglob ; int <S2SV_ModStart> hasglob = 0 ; <S2SV_ModStart> ( hasglob = <S2SV_ModStart> ) == 0 || hasglob == 2 <S2SV_ModEnd> 
3162,<S2SV_StartBug> if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) || * dp ++ != ( ( csum >> 16 ) & 0xff ) || * dp ++ != ( ( csum >> 24 ) & 0xff ) ) <S2SV_EndBug> <S2SV_StartBug> if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dp [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> dp [ 2 ] <S2SV_ModEnd> <S2SV_ModStart> dp [ 3 ] <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dp [ 1 ] <S2SV_ModEnd> 
3163,<S2SV_StartBug> & dec_tables ) ; <S2SV_EndBug> <S2SV_StartBug> & dec_tables ) ; <S2SV_EndBug> ,<S2SV_ModStart> dec_tables . T <S2SV_ModEnd> <S2SV_ModStart> dec_tables . T <S2SV_ModEnd> 
3164,"<S2SV_StartBug> int32_t sessionId , <S2SV_EndBug> <S2SV_StartBug> int32_t ioId , <S2SV_EndBug> ",<S2SV_ModStart> __unused <S2SV_ModStart> __unused 
3165,"<S2SV_StartBug> opt = xchg ( & np -> opt , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt ) <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ( __force struct ipv6_txoptions * * ) <S2SV_ModStart> { atomic_sub ( <S2SV_ModEnd> <S2SV_ModStart> , & sk -> sk_omem_alloc ) ; txopt_put ( opt <S2SV_ModStart> } "
3166,"<S2SV_StartBug> dec -> xstart = siz -> xoff ; <S2SV_EndBug> <S2SV_StartBug> dec -> numtiles = dec -> numhtiles * dec -> numvtiles ; <S2SV_EndBug> <S2SV_StartBug> for ( tileno = 0 , tile = dec -> tiles ; tileno < dec -> numtiles ; ++ tileno , <S2SV_EndBug> ","<S2SV_ModStart> size_t size ; <S2SV_ModStart> if ( ! jas_safe_size_mul ( <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , & size <S2SV_ModEnd> <S2SV_ModStart> dec -> numtiles = size ; JAS_DBGLOG ( 10 , ( ""numtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numhtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numvtiles<S2SV_blank>=<S2SV_blank>%d;\\n"" , dec -> numtiles , dec -> numhtiles , dec -> numvtiles ) ) ; if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) { return - 1 ; } "
3167,"<S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> != c ) break 
3168,<S2SV_StartBug> void ntlm_print_negotiate_flags ( UINT32 flags ) <S2SV_EndBug> ,<S2SV_ModStart> static 
3169,"<S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) <S2SV_EndBug> ",<S2SV_ModStart> && ps_stream -> u4_offset < ps_stream -> u4_max_offset 
3170,"<S2SV_StartBug> struct is_skippable_args args = { x , & result } ; <S2SV_EndBug> ",<S2SV_ModStart> -> plane [ plane ] . eobs 
3171,"<S2SV_StartBug> dev_data = pci_get_drvdata ( dev ) ; <S2SV_EndBug> <S2SV_StartBug> return pci_write_config_word ( dev , offset , value ) ; <S2SV_EndBug> ","<S2SV_ModStart> u16 val ; struct pci_cmd_info * cmd = data ; <S2SV_ModStart> cmd -> val = value ; if ( ! permissive && ( ! dev_data || ! dev_data -> permissive ) ) return 0 ; err = pci_read_config_word ( dev , offset , & val ) ; if ( err || val == value ) return err ; value &= PCI_COMMAND_GUEST ; value |= val & ~ PCI_COMMAND_GUEST ; "
3172,<S2SV_StartBug> yi . cfg . mask = 0xffffffff ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & yi , 0 , sizeof ( yi ) ) ; "
3173,<S2SV_StartBug> if ( last_sec > 0 && last_usec > 0 ) { <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> ,"<S2SV_ModStart> caplentoobig ) { printf ( ""\\n\\nCapture<S2SV_blank>file<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>damaged<S2SV_blank>or<S2SV_blank>corrupt.\\n"" ""Contains<S2SV_blank>packet<S2SV_blank>of<S2SV_blank>size<S2SV_blank>%u,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>snap<S2SV_blank>length<S2SV_blank>%u\\n"" , caplen , pcap_fh . snaplen ) ; close ( fd ) ; break ; } if ( <S2SV_ModStart> break <S2SV_ModEnd> "
3174,<S2SV_StartBug> tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; <S2SV_EndBug> <S2SV_StartBug> ptr -> server_entry_count = gf_bs_read_u8 ( bs ) ; <S2SV_EndBug> <S2SV_StartBug> tmp_strsize = ( u32 ) ptr -> size - 8 ; <S2SV_EndBug> <S2SV_StartBug> tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; <S2SV_EndBug> <S2SV_StartBug> ptr -> quality_entry_count = gf_bs_read_u8 ( bs ) ; <S2SV_EndBug> <S2SV_StartBug> tmp_strsize = ( u32 ) ptr -> size - 8 ; <S2SV_EndBug> <S2SV_StartBug> tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; <S2SV_EndBug> <S2SV_StartBug> tmp_strsize = ( u32 ) ptr -> size - 8 ; <S2SV_EndBug> <S2SV_StartBug> tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; <S2SV_EndBug> <S2SV_StartBug> tmp_strsize = ( u32 ) ptr -> size - 8 ; <S2SV_EndBug> <S2SV_StartBug> tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ptr -> fragment_run_table_count = gf_bs_read_u8 ( bs ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart> ISOM_DECREASE_SIZE ( ptr , 1 ) "
3175,<S2SV_StartBug> uint32_t sampleRate ; <S2SV_EndBug> <S2SV_StartBug> if ( ! config -> num_channels ) { <S2SV_EndBug> ,<S2SV_ModStart> = 0 <S2SV_ModStart> || ! config -> sample_rate 
3176,"<S2SV_StartBug> void ntlm_write_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> ",<S2SV_ModStart> static 
3177,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> pdo_row_ce -> unserialize = zend_class_unserialize_deny ; 
3178,<S2SV_StartBug> if ( ( ldblk > 9999 ) || ( ldblk < 0 ) ) <S2SV_EndBug> ,<S2SV_ModStart> EOFBlob ( image ) ) break ; if ( 
3179,<S2SV_StartBug> s32 smin_val = src_reg -> smin_value ; <S2SV_EndBug> <S2SV_StartBug> u32 umin_val = src_reg -> umin_value ; <S2SV_EndBug> <S2SV_StartBug> dst_reg -> s32_min_value = dst_reg -> umin_value ; <S2SV_EndBug> <S2SV_StartBug> dst_reg -> s32_max_value = dst_reg -> umax_value ; <S2SV_EndBug> ,<S2SV_ModStart> s32_min_value <S2SV_ModEnd> <S2SV_ModStart> u32_min_value <S2SV_ModEnd> <S2SV_ModStart> u32_min_value <S2SV_ModEnd> <S2SV_ModStart> u32_max_value <S2SV_ModEnd> 
3180,<S2SV_StartBug> if ( setpwnam ( ctl -> pw ) < 0 ) { <S2SV_EndBug> ,"<S2SV_ModStart> , "".chfn"" "
3181,<S2SV_StartBug> for ( row = 0 ; row < 6 ; row ++ ) <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> homo = ( char ( * ) [ TS ] [ TS ] ) ( buffer + TS * TS * ( ndir * 10 + 6 ) ) ; <S2SV_EndBug> <S2SV_StartBug> allhex [ row ] [ col ] [ 0 ] [ c ^ ( g * 2 & d ) ] = h + v * width ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> row -- ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( width < TS || height < TS ) throw LIBRAW_EXCEPTION_IO_CORRUPT ; <S2SV_ModStart> for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) for ( int k = 0 ; k < 2 ; k ++ ) for ( int l = 0 ; l < 8 ; l ++ ) allhex [ i ] [ j ] [ k ] [ l ] = 32700 ; <S2SV_ModStart> ; int minv = 0 , maxv = 0 , minh = 0 , maxh = 0 <S2SV_ModStart> minv = MIN ( v , minv ) ; maxv = MAX ( v , maxv ) ; minh = MIN ( v , minh ) ; maxh = MAX ( v , maxh ) ; <S2SV_ModStart> # ifdef LIBRAW_LIBRARY_BUILD for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) for ( int k = 0 ; k < 2 ; k ++ ) for ( int l = 0 ; l < 8 ; l ++ ) if ( allhex [ i ] [ j ] [ k ] [ l ] > maxh + maxv * width + 1 || allhex [ i ] [ j ] [ k ] [ l ] < minh + minv * width - 1 ) throw LIBRAW_EXCEPTION_IO_CORRUPT ; int retrycount = 0 ; # endif <S2SV_ModStart> { <S2SV_ModStart> # ifdef LIBRAW_LIBRARY_BUILD if ( retrycount ++ > width * height ) throw LIBRAW_EXCEPTION_IO_CORRUPT ; # endif } "
3182,<S2SV_StartBug> dlen -= 2 ; <S2SV_EndBug> ,<S2SV_ModStart> 3 <S2SV_ModEnd> 
3183,<S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> ,<S2SV_ModStart> key_is_positive <S2SV_ModEnd> 
3184,<S2SV_StartBug> assert ( bi != NULL ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ii -> ii_ioapic_irq > 0 ) ; <S2SV_EndBug> <S2SV_StartBug> ii -> ii_pirq_pin = pirq_alloc_pin ( dev ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( bi == NULL ) { pr_err ( ""%s:<S2SV_blank>pci<S2SV_blank>[%s]<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>bus<S2SV_blank>%d<S2SV_blank>info!\\n"" , __func__ , dev -> name , dev -> bus ) ; return ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3185,<S2SV_StartBug> bufsize = file -> size ; <S2SV_EndBug> ,"<S2SV_ModStart> MIN ( <S2SV_ModStart> , sizeof buf ) "
3186,"<S2SV_StartBug> write ( logfile_fd , data , length ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
3187,"<S2SV_StartBug> s_cmd -> command += ec -> cmd_offset ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_to_user ( arg , s_cmd , sizeof ( * s_cmd ) + u_cmd . insize ) ) <S2SV_EndBug> ",<S2SV_ModStart> if ( u_cmd . outsize != s_cmd -> outsize || u_cmd . insize != s_cmd -> insize ) { ret = - EINVAL ; goto exit ; } <S2SV_ModStart> s_cmd -> <S2SV_ModEnd> 
3188,<S2SV_StartBug> free ( ctx ) ; <S2SV_EndBug> ,<S2SV_ModStart> vpx_free <S2SV_ModEnd> 
3189,<S2SV_StartBug> if ( class == BPF_ALU || class == BPF_ALU64 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ,<S2SV_ModStart> env -> insn_aux_data [ insn_idx ] . seen = true ; <S2SV_ModStart> env -> insn_aux_data [ insn_idx ] . seen = true ; 
3190,<S2SV_StartBug> u1_num_mbs ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( u1_tfr_n_mb ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ps_dec -> u2_total_mbs_coded += u1_num_mbs ; 
3191,<S2SV_StartBug> return true ; <S2SV_EndBug> <S2SV_StartBug> return true ; <S2SV_EndBug> ,<S2SV_ModStart> ( * elem_rtrn != NULL && * field_rtrn != NULL ) <S2SV_ModEnd> <S2SV_ModStart> if ( expr -> array_ref . element != XKB_ATOM_NONE && * elem_rtrn == NULL ) return false ; if ( * field_rtrn == NULL ) return false ; 
3192,<S2SV_StartBug> if ( ! replay_esn || ! rp ) <S2SV_EndBug> <S2SV_StartBug> if ( xfrm_replay_state_esn_len ( replay_esn ) != <S2SV_EndBug> <S2SV_StartBug> xfrm_replay_state_esn_len ( up ) ) <S2SV_EndBug> ,<S2SV_ModStart> int ulen ; <S2SV_ModStart> ulen = xfrm_replay_state_esn_len ( up ) ; if ( nla_len ( rp ) < ulen || <S2SV_ModEnd> <S2SV_ModStart> ulen <S2SV_ModEnd> 
3193,"<S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int do_recon ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) ; <S2SV_EndBug> <S2SV_StartBug> int last_part_rate = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) <S2SV_EndBug> <S2SV_StartBug> partition = partition_lookup [ bsl ] [ bs_type ] ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> <S2SV_StartBug> if ( bsize == BLOCK_16X16 ) { <S2SV_EndBug> <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> * ( get_sb_partitioning ( x , bsize ) ) = bsize ; <S2SV_EndBug> <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & none_rate , & none_dist , bsize , <S2SV_EndBug> <S2SV_StartBug> if ( none_rate < INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> none_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ; <S2SV_EndBug> <S2SV_StartBug> none_rd = RDCOST ( x -> rdmult , x -> rddiv , none_rate , none_dist ) ; <S2SV_EndBug> <S2SV_StartBug> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> * ( get_sb_partitioning ( x , bsize ) ) = subsize ; <S2SV_EndBug> <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & last_part_rate , <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( last_part_rate != INT_MAX && <S2SV_EndBug> <S2SV_StartBug> int rt = 0 ; <S2SV_EndBug> <S2SV_StartBug> update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row + ( mi_step >> 1 ) , mi_col , & rt , & dt , <S2SV_EndBug> <S2SV_StartBug> subsize , get_block_context ( x , subsize ) , INT64_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rt == INT_MAX || dt == INT64_MAX ) { <S2SV_EndBug> <S2SV_StartBug> last_part_rate = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> last_part_rate += rt ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( last_part_rate != INT_MAX && <S2SV_EndBug> <S2SV_StartBug> int rt = 0 ; <S2SV_EndBug> <S2SV_StartBug> update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col + ( mi_step >> 1 ) , & rt , & dt , <S2SV_EndBug> <S2SV_StartBug> subsize , get_block_context ( x , subsize ) , INT64_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rt == INT_MAX || dt == INT64_MAX ) { <S2SV_EndBug> <S2SV_StartBug> last_part_rate = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> last_part_rate += rt ; <S2SV_EndBug> <S2SV_StartBug> last_part_rate = 0 ; <S2SV_EndBug> <S2SV_StartBug> int rt ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = i ; <S2SV_EndBug> <S2SV_StartBug> i != 3 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rt == INT_MAX || dt == INT64_MAX ) { <S2SV_EndBug> <S2SV_StartBug> last_part_rate = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> last_part_rate += rt ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( last_part_rate < INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> last_part_rate += x -> partition_cost [ pl ] [ partition ] ; <S2SV_EndBug> <S2SV_StartBug> last_part_rd = RDCOST ( x -> rdmult , x -> rddiv , last_part_rate , last_part_dist ) ; <S2SV_EndBug> <S2SV_StartBug> chosen_rate = 0 ; <S2SV_EndBug> <S2SV_StartBug> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> int rt = 0 ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , split_subsize ) = i ; <S2SV_EndBug> <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row + y_idx , mi_col + x_idx , & rt , & dt , <S2SV_EndBug> <S2SV_StartBug> if ( rt == INT_MAX || dt == INT64_MAX ) { <S2SV_EndBug> <S2SV_StartBug> chosen_rate = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> chosen_rate += rt ; <S2SV_EndBug> <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , 0 , <S2SV_EndBug> <S2SV_StartBug> split_subsize ) ; <S2SV_EndBug> <S2SV_StartBug> chosen_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ; <S2SV_EndBug> <S2SV_StartBug> if ( chosen_rate < INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> chosen_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; <S2SV_EndBug> <S2SV_StartBug> chosen_rd = RDCOST ( x -> rdmult , x -> rddiv , chosen_rate , chosen_dist ) ; <S2SV_EndBug> <S2SV_StartBug> * ( get_sb_partitioning ( x , bsize ) ) = subsize ; <S2SV_EndBug> <S2SV_StartBug> * ( get_sb_partitioning ( x , bsize ) ) = bsize ; <S2SV_EndBug> <S2SV_StartBug> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( chosen_rate < INT_MAX && chosen_dist < INT64_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) { <S2SV_EndBug> <S2SV_StartBug> * dist = chosen_dist ; <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> <S2SV_ModStart> , PC_TREE * pc_tree <S2SV_ModStart> TileInfo * const tile_info = & tile_data -> tile_info ; <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> b_width_log2_lookup [ bsize ] <S2SV_ModEnd> <S2SV_ModStart> RD_COST last_part_rdc , none_rdc , chosen_rdc <S2SV_ModEnd> <S2SV_ModStart> PICK_MODE_CONTEXT * ctx = & pc_tree -> none ; <S2SV_ModStart> vp9_rd_cost_reset ( & last_part_rdc ) ; vp9_rd_cost_reset ( & none_rdc ) ; vp9_rd_cost_reset ( & chosen_rdc ) ; <S2SV_ModStart> pc_tree -> partitioning = partition ; save_context ( x <S2SV_ModEnd> <S2SV_ModStart> && cpi -> oxcf . aq_mode <S2SV_ModStart> tile_info , x <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> partitioning = PARTITION_NONE <S2SV_ModEnd> <S2SV_ModStart> tile_data , x , mi_row , mi_col , & none_rdc , bsize , ctx <S2SV_ModEnd> <S2SV_ModStart> none_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> none_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> none_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> none_rdc . rate , none_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> x <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> partitioning = partition <S2SV_ModEnd> <S2SV_ModStart> tile_data , x , mi_row , mi_col , & last_part_rdc , bsize , ctx <S2SV_ModEnd> <S2SV_ModStart> rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , subsize , & pc_tree -> horizontal [ 0 ] , <S2SV_ModEnd> <S2SV_ModStart> last_part_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> RD_COST tmp_rdc ; PICK_MODE_CONTEXT * ctx = & pc_tree -> horizontal [ 0 ] ; vp9_rd_cost_init ( & tmp_rdc ) <S2SV_ModEnd> <S2SV_ModStart> td , ctx , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , ctx ) <S2SV_ModEnd> <S2SV_ModStart> tile_data , x , <S2SV_ModEnd> <S2SV_ModStart> tmp_rdc <S2SV_ModEnd> <S2SV_ModStart> & pc_tree -> horizontal [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> tmp_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> tmp_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> vp9_rd_cost_reset ( & last_part_rdc ) <S2SV_ModEnd> <S2SV_ModStart> last_part_rdc . rate += tmp_rdc . rate ; last_part_rdc . dist += tmp_rdc . dist ; last_part_rdc . rdcost += tmp_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , subsize , & pc_tree -> vertical [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> last_part_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> RD_COST tmp_rdc ; PICK_MODE_CONTEXT * ctx = & pc_tree -> vertical [ 0 ] ; vp9_rd_cost_init ( & tmp_rdc ) <S2SV_ModEnd> <S2SV_ModStart> td , ctx , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , ctx ) <S2SV_ModEnd> <S2SV_ModStart> tile_data , x , <S2SV_ModEnd> <S2SV_ModStart> tmp_rdc <S2SV_ModEnd> <S2SV_ModStart> & pc_tree -> vertical [ bsize > BLOCK_8X8 ] , <S2SV_ModEnd> <S2SV_ModStart> tmp_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> tmp_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> vp9_rd_cost_reset ( & last_part_rdc ) <S2SV_ModEnd> <S2SV_ModStart> last_part_rdc . rate += tmp_rdc . rate ; last_part_rdc . dist += tmp_rdc . dist ; last_part_rdc . rdcost += tmp_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> if ( bsize == BLOCK_8X8 ) { rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , subsize , pc_tree -> leaf_split [ 0 ] , INT64_MAX ) ; break ; } last_part_rdc . rate = 0 ; last_part_rdc . dist = 0 ; last_part_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> RD_COST tmp_rdc <S2SV_ModEnd> <S2SV_ModStart> vp9_rd_cost_init ( & tmp_rdc ) ; rd_use_partition ( cpi , td , tile_data , mi_8x8 + jj * bss * mis + ii * bss , tp , mi_row + y_idx , mi_col + x_idx , subsize , & tmp_rdc . rate , & tmp_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> , pc_tree -> split [ i ] ) ; if ( tmp_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> tmp_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> vp9_rd_cost_reset ( & last_part_rdc ) <S2SV_ModEnd> <S2SV_ModStart> last_part_rdc . rate += tmp_rdc . rate ; last_part_rdc . dist += tmp_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> break ; <S2SV_ModStart> last_part_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> last_part_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> last_part_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> last_part_rdc . rate , last_part_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> chosen_rdc . rate = 0 ; chosen_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> x <S2SV_ModEnd> <S2SV_ModStart> ; pc_tree -> partitioning = PARTITION_SPLIT <S2SV_ModStart> RD_COST tmp_rdc <S2SV_ModEnd> <S2SV_ModStart> save_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; pc_tree -> split [ i ] -> partitioning = PARTITION_NONE ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row + y_idx , mi_col + x_idx , & tmp_rdc , split_subsize , & pc_tree -> split [ i ] -> none , INT64_MAX ) ; restore_context ( x <S2SV_ModEnd> <S2SV_ModStart> if ( tmp_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> tmp_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> vp9_rd_cost_reset ( & chosen_rdc ) <S2SV_ModEnd> <S2SV_ModStart> chosen_rdc . rate += tmp_rdc . rate ; chosen_rdc . dist += tmp_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> td , tile_info <S2SV_ModEnd> <S2SV_ModStart> , pc_tree -> split [ i ] <S2SV_ModStart> chosen_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> chosen_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> chosen_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> chosen_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> chosen_rdc . rate , chosen_rdc . dist ) ; } } if ( last_part_rdc . rdcost < chosen_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> partitioning = partition ; chosen_rdc = last_part_rdc ; } if ( none_rdc . rdcost < chosen_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> partitioning = PARTITION_NONE ; chosen_rdc = none_rdc <S2SV_ModEnd> <S2SV_ModStart> x <S2SV_ModEnd> <S2SV_ModStart> chosen_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> chosen_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> encode_sb ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , bsize , pc_tree ) ; } * rate = chosen_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> chosen_rdc . dist <S2SV_ModEnd> "
3194,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>method=%s"" , len - 4 , <S2SV_EndBug> <S2SV_StartBug> if ( 1 < ndo -> ndo_vflag && 4 < len ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( ndo -> ndo_vflag && 4 < len ) { <S2SV_EndBug> <S2SV_StartBug> return ( const u_char * ) ext + len ; <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank>len=%u<S2SV_blank>method=%s"" <S2SV_ModEnd> <S2SV_ModStart> len > 4 ) { if ( <S2SV_ModEnd> <S2SV_ModStart> > 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } "
3195,"<S2SV_StartBug> unsigned int maxw , maxh , max ; <S2SV_EndBug> <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0U ; i < ( maxh & ~ ( unsigned int ) 1U ) ; i += 2U ) <S2SV_EndBug> <S2SV_StartBug> ny = y + maxw ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> <S2SV_StartBug> if ( j < maxw ) <S2SV_EndBug> <S2SV_StartBug> if ( i < maxh ) <S2SV_EndBug> <S2SV_StartBug> for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> <S2SV_StartBug> # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_EndBug> <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> <S2SV_StartBug> if ( g ) free ( g ) ; <S2SV_EndBug> <S2SV_StartBug> if ( b ) free ( b ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t maxw , maxh , max , offx , loopmaxw , offy , loopmaxh ; int offset , upb ; size_t i <S2SV_ModEnd> <S2SV_ModStart> size_t ) img -> comps [ 0 ] . w ; maxh = ( size_t ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ; d1 = g <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> d2 = b <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; offy = img -> y0 & 1U ; loopmaxh = maxh - offy ; if ( offy > 0U ) { size_t j ; for ( j = 0 ; j < maxw ; ++ j ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } } <S2SV_ModStart> loopmaxh <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t j ; <S2SV_ModStart> if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; } <S2SV_ModStart> loopmaxw <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> loopmaxw <S2SV_ModEnd> <S2SV_ModStart> loopmaxh ) { size_t j ; <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> <S2SV_ModStart> dx = img -> comps [ 0 ] . dx ; <S2SV_ModEnd> <S2SV_ModStart> dy = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3196,"<S2SV_StartBug> static void prefetch_table ( const volatile byte * tab , size_t len ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < len ; i += 8 * 32 ) <S2SV_EndBug> <S2SV_StartBug> ( void ) tab [ len - 1 ] ; <S2SV_EndBug> ",<S2SV_ModStart> inline <S2SV_ModStart> len - i >= 8 * 32 <S2SV_ModEnd> <S2SV_ModStart> for ( ; i < len ; i += 32 ) { ( void ) tab [ i ] ; } 
3197,"<S2SV_StartBug> ! DoReadFile ( infile , & ds64_chunk , chunk_header . ckSize , & bcount ) || <S2SV_EndBug> <S2SV_StartBug> bcount != chunk_header . ckSize ) { <S2SV_EndBug> <S2SV_StartBug> ! WavpackAddWrapper ( wpc , & ds64_chunk , chunk_header . ckSize ) ) { <S2SV_EndBug> ",<S2SV_ModStart> sizeof ( DS64Chunk ) <S2SV_ModEnd> <S2SV_ModStart> sizeof ( DS64Chunk ) <S2SV_ModEnd> <S2SV_ModStart> sizeof ( DS64Chunk ) <S2SV_ModEnd> 
3198,"<S2SV_StartBug> void * ptr = malloc ( num * size ) ; <S2SV_EndBug> <S2SV_StartBug> memset ( ptr , '\\0' , ( num * size ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; void * ptr ; <S2SV_ModEnd> <S2SV_ModStart> res <S2SV_ModEnd> <S2SV_ModStart> res <S2SV_ModEnd> "
3199,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! strcmp ( line , ""HASHSEED"" ) ) { conf . have_hashseed = 1 ; conf . hashseed = atoi ( val ) ; } else { conf . have_hashseed = 0 ; } "
3200,"<S2SV_StartBug> } else if ( cpkt . cptype == MT_CPTYPE_PASSWORD ) { <S2SV_EndBug> <S2SV_StartBug> syslog ( LOG_WARNING , _ ( ""(%d)<S2SV_blank>Unhandeled<S2SV_blank>control<S2SV_blank>packet<S2SV_blank>type:<S2SV_blank>%d"" ) , curconn -> seskey , cpkt . cptype ) ; <S2SV_EndBug> ","<S2SV_ModStart> && cpkt . length == 17 <S2SV_ModStart> ""(%d)<S2SV_blank>Unhandeled<S2SV_blank>control<S2SV_blank>packet<S2SV_blank>type:<S2SV_blank>%d,<S2SV_blank>length:<S2SV_blank>%d"" <S2SV_ModEnd> <S2SV_ModStart> , cpkt . length "
3201,<S2SV_StartBug> if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { <S2SV_EndBug> <S2SV_StartBug> if ( umax_val > 63 ) { <S2SV_EndBug> <S2SV_StartBug> if ( umax_val > 63 ) { <S2SV_EndBug> <S2SV_StartBug> __reg_deduce_bounds ( dst_reg ) ; <S2SV_EndBug> ,"<S2SV_ModStart> u64 insn_bitness = <S2SV_ModEnd> <S2SV_ModStart> == BPF_ALU64 ) ? 64 : 32 ; <S2SV_ModEnd> <S2SV_ModStart> >= insn_bitness <S2SV_ModEnd> <S2SV_ModStart> >= insn_bitness <S2SV_ModEnd> <S2SV_ModStart> if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } "
3202,"<S2SV_StartBug> ( void ) ReadBlobString ( image , text ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } "
3203,"<S2SV_StartBug> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) <S2SV_EndBug> <S2SV_StartBug> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; <S2SV_EndBug> <S2SV_StartBug> return ( DestroyImageList ( image ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> image -> colormap = ( PixelInfo * ) AcquireQuantumMemory ( <S2SV_ModEnd> <S2SV_ModStart> + 1 , sizeof ( * image -> colormap ) ) ; if ( image -> colormap == ( PixelInfo * ) NULL <S2SV_ModEnd> <S2SV_ModStart> if ( ( AcquireMagickResource ( WidthResource <S2SV_ModEnd> <S2SV_ModStart> ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> ) ThrowReaderException ( ImageError , ""WidthOrHeightExceedsLimit"" <S2SV_ModEnd> "
3204,"<S2SV_StartBug> ret = copy_to_user ( uattr , attr , usize ) ; <S2SV_EndBug> ",<S2SV_ModStart> attr -> size <S2SV_ModEnd> 
3205,"<S2SV_StartBug> if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { <S2SV_EndBug> ","<S2SV_ModStart> jas_alloc3 ( bufsize , numcols <S2SV_ModEnd> "
3206,"<S2SV_StartBug> sctp_sock_rfree ( skb ) ; <S2SV_EndBug> <S2SV_StartBug> sctp_skb_set_owner_r ( skb , newsk ) ; <S2SV_EndBug> <S2SV_StartBug> sctp_sock_rfree ( skb ) ; <S2SV_EndBug> <S2SV_StartBug> sctp_skb_set_owner_r ( skb , newsk ) ; <S2SV_EndBug> <S2SV_StartBug> sctp_clear_pd ( oldsk ) ; <S2SV_EndBug> ","<S2SV_ModStart> sctp_sock_rfree_frag <S2SV_ModEnd> <S2SV_ModStart> sctp_skb_set_owner_r_frag <S2SV_ModEnd> <S2SV_ModStart> sctp_sock_rfree_frag <S2SV_ModEnd> <S2SV_ModStart> sctp_skb_set_owner_r_frag <S2SV_ModEnd> <S2SV_ModStart> ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . reasm , tmp ) { sctp_sock_rfree_frag ( skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . lobby , tmp ) { sctp_sock_rfree_frag ( skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk "
3207,"<S2SV_StartBug> static void nsc_decode ( NSC_CONTEXT * context ) <S2SV_EndBug> <S2SV_StartBug> UINT16 rw = ROUND_UP_TO ( context -> width , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> BYTE shift = context -> ColorLossLevel - 1 ; <S2SV_EndBug> <S2SV_StartBug> BYTE * bmpdata = context -> BitmapData ; <S2SV_EndBug> <S2SV_StartBug> * bmpdata ++ = MINMAX ( b_val , 0 , 0xFF ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> ; BYTE shift ; BYTE * bmpdata ; size_t pos = 0 ; if ( ! context ) return FALSE ; rw <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! bmpdata ) return FALSE <S2SV_ModStart> if ( pos + 4 > context -> BitmapDataLength ) return FALSE ; pos += 4 ; <S2SV_ModStart> return TRUE ; 
3208,<S2SV_StartBug> dst [ y * linesize + x ] = clr ; <S2SV_EndBug> ,<S2SV_ModStart> if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ; 
3209,<S2SV_StartBug> return - 1 ; <S2SV_EndBug> ,<S2SV_ModStart> fclose ( mapf ) ; 
3210,"<S2SV_StartBug> if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL ) <S2SV_EndBug> ",<S2SV_ModStart> psf_allocate ( <S2SV_ModEnd> 
3211,<S2SV_StartBug> if ( ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) ) <S2SV_EndBug> <S2SV_StartBug> task -> task_state_flags |= SAS_TASK_STATE_ABORTED ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; } "
3212,<S2SV_StartBug> devc -> voc [ voice ] . panning = value ; <S2SV_EndBug> ,<S2SV_ModStart> if ( voice < 0 || voice >= devc -> nr_voice ) return ; 
3213,"<S2SV_StartBug> cib_remote_opaque_t * private = cib -> variant_opaque ; <S2SV_EndBug> <S2SV_StartBug> gnutls_bye ( * ( private -> command . session ) , GNUTLS_SHUT_RDWR ) ; <S2SV_EndBug> <S2SV_StartBug> gnutls_bye ( * ( private -> callback . session ) , GNUTLS_SHUT_RDWR ) ; <S2SV_EndBug> <S2SV_StartBug> gnutls_anon_free_client_credentials ( anon_cred_c ) ; <S2SV_EndBug> <S2SV_StartBug> gnutls_global_deinit ( ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( private -> command . session ) { <S2SV_ModStart> } if ( private -> callback . session ) { <S2SV_ModStart> } private -> command . session = NULL ; private -> callback . session = NULL ; if ( remote_gnutls_credentials_init ) { <S2SV_ModStart> remote_gnutls_credentials_init = FALSE ; } <S2SV_ModStart> if ( private -> command . socket ) { shutdown ( private -> command . socket , SHUT_RDWR ) ; close ( private -> command . socket ) ; } if ( private -> callback . socket ) { shutdown ( private -> callback . socket , SHUT_RDWR ) ; close ( private -> callback . socket ) ; } private -> command . socket = 0 ; private -> callback . socket = 0 ; free ( private -> command . recv_buf ) ; free ( private -> callback . recv_buf ) ; private -> command . recv_buf = NULL ; private -> callback . recv_buf = NULL ; "
3214,<S2SV_StartBug> if ( ! is_exception ( intr_info ) ) <S2SV_EndBug> ,<S2SV_ModStart> is_nmi <S2SV_ModEnd> 
3215,"<S2SV_StartBug> static int update_mv ( vp9_writer * w , const unsigned int ct [ 2 ] , vp9_prob * cur_p , <S2SV_EndBug> <S2SV_StartBug> vp9_prob upd_p ) { <S2SV_EndBug> <S2SV_StartBug> const vp9_prob new_p = get_binary_prob ( ct [ 0 ] , ct [ 1 ] ) | 1 ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , update , upd_p ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , new_p >> 1 , 7 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write_literal <S2SV_ModEnd> 
3216,"<S2SV_StartBug> defaultoptions ( & h ) ; <S2SV_EndBug> <S2SV_StartBug> luaL_checkstack ( L , 1 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pushnumber ( L , res ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pushnumber ( L , f ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pushnumber ( L , d ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! lua_isnumber ( L , - 1 ) ) <S2SV_EndBug> <S2SV_StartBug> luaL_error ( L , ""format<S2SV_blank>`c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pop ( L , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pushlstring ( L , data + pos , size ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pushlstring ( L , data + pos , size - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> return lua_gettop ( L ) - 2 ; <S2SV_EndBug> ","<S2SV_ModStart> int n = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 2 <S2SV_ModEnd> <S2SV_ModStart> n ++ ; <S2SV_ModStart> n ++ ; <S2SV_ModStart> n ++ ; <S2SV_ModStart> n == 0 || <S2SV_ModStart> ""format<S2SV_blank>\'c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" <S2SV_ModEnd> <S2SV_ModStart> n -- ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && pos <= ld - size , <S2SV_ModEnd> <S2SV_ModStart> ; n ++ <S2SV_ModStart> n ++ ; <S2SV_ModStart> n + 1 <S2SV_ModEnd> "
3217,<S2SV_StartBug> for ( i = 0 ; i < ctx -> msgcount ; i ++ ) <S2SV_EndBug> ,<S2SV_ModStart> if ( strlen ( line ) == 0 ) return - 1 ; 
3218,<S2SV_StartBug> int overflow_error = 0 ; <S2SV_EndBug> <S2SV_StartBug> res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( u = 0 ; u < line_length ; u ++ ) { <S2SV_EndBug> <S2SV_StartBug> res -> ContribRow [ u ] . Weights = ( double * ) gdMalloc ( windows_size * sizeof ( double ) ) ; <S2SV_EndBug> <S2SV_StartBug> u -- ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i <= u ; i ++ ) { <S2SV_EndBug> ,"<S2SV_ModStart> size_t weights_size ; if ( overflow2 ( windows_size , sizeof ( double ) ) ) { return NULL ; } else { weights_size = windows_size * sizeof ( double ) ; } res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ; if ( ! res ) { return NULL ; } res -> WindowSize = windows_size ; res -> LineLength = line_length ; if ( overflow2 ( line_length , sizeof ( ContributionType ) ) ) { gdFree ( res ) ; return NULL ; } res -> ContribRow = ( ContributionType * ) gdMalloc ( line_length * sizeof ( ContributionType ) ) ; if ( res -> ContribRow == NULL ) { gdFree ( res ) ; return NULL ; } for ( u <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> weights_size ) ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> < <S2SV_ModEnd> "
3219,<S2SV_StartBug> timer -> it_overrun += 1 << i ; <S2SV_EndBug> ,<S2SV_ModStart> 1LL <S2SV_ModEnd> 
3220,"<S2SV_StartBug> map = q -> bufs [ first ] -> map = kmalloc ( sizeof ( struct videobuf_mapping ) , GFP_KERNEL ) ; <S2SV_EndBug> ",<S2SV_ModStart> kzalloc <S2SV_ModEnd> 
3221,"<S2SV_StartBug> net_connect_ip_ssl ( ip , port , own_ip , server -> connrec -> ssl_cert , server -> connrec -> ssl_pkey , <S2SV_EndBug> ","<S2SV_ModStart> server -> connrec -> address , "
3222,"<S2SV_StartBug> static void write_segment_id ( vp9_writer * w , const struct segmentation * seg , <S2SV_EndBug> ",<S2SV_ModStart> vpx_writer <S2SV_ModEnd> 
3223,<S2SV_StartBug> FLACHeader hdr ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( last ) break ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( ctx -> in_error ) return GF_NON_COMPLIANT_BITSTREAM <S2SV_ModStart> GF_LOG ( GF_LOG_ERROR , GF_LOG_PARSER , ( ""[FLACDmx]<S2SV_blank>invalid<S2SV_blank>FLAC<S2SV_blank>magic\\n"" ) ) ; ctx -> in_error = GF_TRUE ; ctx -> flac_buffer_size = 0 ; if ( pck ) gf_filter_pid_drop_packet ( ctx -> ipid ) ; return GF_NON_COMPLIANT_BITSTREAM ; <S2SV_ModStart> ; } if ( ! dsi_end ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_PARSER , ( ""[FLACDmx]<S2SV_blank>invalid<S2SV_blank>FLAC<S2SV_blank>header\\n"" ) ) ; ctx -> in_error = GF_TRUE ; ctx -> flac_buffer_size = 0 ; if ( pck ) gf_filter_pid_drop_packet ( ctx -> ipid ) ; return GF_NON_COMPLIANT_BITSTREAM "
3224,<S2SV_StartBug> if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) ) <S2SV_EndBug> ,<S2SV_ModStart> ( CLONE_NEWUSER | CLONE_FS ) ) == ( CLONE_NEWUSER | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & 
3225,<S2SV_StartBug> struct dentry * dir ; <S2SV_EndBug> <S2SV_StartBug> ci = d_inode ( dir ) -> i_crypt_info ; <S2SV_EndBug> <S2SV_StartBug> dir_has_key = ( ci != NULL ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> d_inode ( dir ) -> i_crypt_info <S2SV_ModEnd> 
3226,<S2SV_StartBug> fp -> protocol = altsd -> bInterfaceProtocol ; <S2SV_EndBug> ,<S2SV_ModStart> if ( altsd -> bNumEndpoints < 1 ) { kfree ( fp ) ; kfree ( rate_table ) ; return - EINVAL ; } 
3227,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( ! uc_more_data_flag && ! i2_mb_skip_run && ( 0 == ( i2_cur_mb_addr & 1 ) ) ) { return ERROR_EOB_FLUSHBITS_T ; } 
3228,<S2SV_StartBug> if ( bad_format ( optarg ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( bad_format ( optarg ) ) { <S2SV_EndBug> ,<S2SV_ModStart> bad_format_axis ( optarg ) ) { <S2SV_ModEnd> <S2SV_ModStart> bad_format_axis ( optarg ) ) { <S2SV_ModEnd> 
3229,"<S2SV_StartBug> kvmclock_reset ( vcpu ) ; <S2SV_EndBug> <S2SV_StartBug> vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vcpu -> arch . time_offset & <S2SV_EndBug> <S2SV_StartBug> vcpu -> arch . time_page = <S2SV_EndBug> <S2SV_StartBug> gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ; <S2SV_EndBug> ","<S2SV_ModStart> u64 gpa_offset ; <S2SV_ModStart> gpa_offset <S2SV_ModEnd> <S2SV_ModStart> gpa_offset <S2SV_ModEnd> <S2SV_ModStart> if ( kvm_gfn_to_hva_cache_init <S2SV_ModEnd> <S2SV_ModStart> & vcpu -> arch . pv_time , data & ~ 1ULL ) ) vcpu -> arch . pv_time_enabled = false ; else vcpu -> arch . pv_time_enabled = true <S2SV_ModEnd> "
3230,"<S2SV_StartBug> unsigned v = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> f -> chroma_planes = get_rac ( c , state ) ; <S2SV_EndBug> <S2SV_StartBug> f -> chroma_h_shift = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> f -> chroma_v_shift = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> f -> transparency = get_rac ( c , state ) ; <S2SV_EndBug> ","<S2SV_ModStart> int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( f -> plane_count ) { if ( chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency ) { av_log ( f -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>change<S2SV_blank>of<S2SV_blank>global<S2SV_blank>parameters\\n"" ) ; return AVERROR_INVALIDDATA ; } } f -> chroma_planes = chroma_planes ; f -> chroma_h_shift = chroma_h_shift ; f -> chroma_v_shift = chroma_v_shift ; f -> transparency = transparency "
3231,"<S2SV_StartBug> usb_set_intfdata ( interface , dev ) ; <S2SV_EndBug> <S2SV_StartBug> exit : <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> usb_set_intfdata ( interface , dev ) ; retval = usb_register_dev ( interface , & tower_class ) ; if ( retval ) { dev_err ( idev , ""Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\n"" ) ; usb_set_intfdata ( interface , NULL ) ; goto error ; } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>"" ""%d<S2SV_blank>minor<S2SV_blank>%d\\n"" , ( dev -> minor - LEGO_USB_TOWER_MINOR_BASE ) , USB_MAJOR , dev -> minor ) ; "
3232,"<S2SV_StartBug> int i , length_modes , length_chars ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> old_length_chars , <S2SV_ModStart> ; old_length_chars = ( server -> prefix_chars ) ? strlen ( server -> prefix_chars ) : 0 <S2SV_ModStart> length_chars = ( server -> prefix_chars ) ? strlen ( server -> prefix_chars ) : 0 ; if ( server -> prefix_chars && ( length_chars != old_length_chars ) ) irc_nick_realloc_prefixes ( server , old_length_chars , length_chars ) ; "
3233,<S2SV_StartBug> snd_seq_timer_stop ( q -> timer ) ; <S2SV_EndBug> <S2SV_StartBug> snd_seq_timer_close ( q ) ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & q -> timer_mutex ) ; <S2SV_ModStart> ) ; mutex_unlock ( & q -> timer_mutex 
3234,<S2SV_StartBug> if ( _payload ) { <S2SV_EndBug> ,<S2SV_ModStart> plen <S2SV_ModEnd> 
3235,<S2SV_StartBug> struct address_space * mapping ; <S2SV_EndBug> <S2SV_StartBug> if ( mapping ) <S2SV_EndBug> ,<S2SV_ModStart> hugepage_subpool * spool = ( struct hugepage_subpool <S2SV_ModEnd> <S2SV_ModStart> hugepage_subpool_put_pages ( spool <S2SV_ModEnd> 
3236,"<S2SV_StartBug> struct sk_buff * skb ; <S2SV_EndBug> <S2SV_StartBug> if ( dump_one_state ( x , 0 , & info ) ) { <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> ",<S2SV_ModStart> ; int err <S2SV_ModStart> err = <S2SV_ModEnd> <S2SV_ModStart> ; if ( err <S2SV_ModStart> ERR_PTR ( err ) <S2SV_ModEnd> 
3237,<S2SV_StartBug> int n_read = r -> end - r -> begin ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned int actual_size = f -> blocksize_1 / 2 ; unsigned int limit_r_begin = r -> begin < actual_size ? r -> begin : actual_size ; unsigned int limit_r_end = r -> end < actual_size ? r -> end : actual_size ; <S2SV_ModStart> limit_r_end - limit_r_begin <S2SV_ModEnd> 
3238,<S2SV_StartBug> if ( length > 4 ) <S2SV_EndBug> <S2SV_StartBug> if ( length > 6 ) <S2SV_EndBug> ,<S2SV_ModStart> 5 <S2SV_ModEnd> <S2SV_ModStart> 7 <S2SV_ModEnd> 
3239,<S2SV_StartBug> uint32_t bcount ; <S2SV_EndBug> ,<S2SV_ModStart> ; CLEAR ( WaveHeader ) 
3240,<S2SV_StartBug> void unix_notinflight ( struct file * fp ) <S2SV_EndBug> <S2SV_StartBug> fp -> f_cred -> user -> unix_inflight -- ; <S2SV_EndBug> ,"<S2SV_ModStart> struct user_struct * user , <S2SV_ModStart>  <S2SV_ModEnd> "
3241,<S2SV_StartBug> if ( argReg >= regsz ) { <S2SV_EndBug> ,<S2SV_ModStart> > <S2SV_ModEnd> <S2SV_ModStart> return ; 
3242,"<S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; <S2SV_EndBug> <S2SV_StartBug> pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads , <S2SV_EndBug> <S2SV_StartBug> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> ","<S2SV_ModStart> rows ; rows = MagickMax ( GetImageListLength ( images ) , <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> rows , <S2SV_ModEnd> <S2SV_ModStart> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 <S2SV_ModEnd> <S2SV_ModStart> rows <S2SV_ModEnd> "
3243,<S2SV_StartBug> EVP_MD_CTX_init ( & ctx ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; return - 1 ; } "
3244,"<S2SV_StartBug> build_config ( char * prefix , struct server * server ) <S2SV_EndBug> <S2SV_StartBug> fprintf ( f , ""\\""password\\"":\\""%s\\"""" , server -> password ) ; <S2SV_EndBug> <S2SV_StartBug> if ( server -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , server -> method ) ; <S2SV_EndBug> ","<S2SV_ModStart> manager_ctx * manager , struct <S2SV_ModStart> ) ; if ( server -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , server -> method ) ; else if ( manager -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , manager -> method <S2SV_ModStart>  <S2SV_ModEnd> "
3245,<S2SV_StartBug> if ( ses -> server -> sign && ses -> server -> ops -> generate_signingkey ) { <S2SV_EndBug> <S2SV_StartBug> rc = ses -> server -> ops -> generate_signingkey ( ses ) ; <S2SV_EndBug> <S2SV_StartBug> goto keygen_exit ; <S2SV_EndBug> <S2SV_StartBug> keygen_exit : <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return rc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3246,<S2SV_StartBug> if ( type == HUB_INIT2 ) <S2SV_EndBug> <S2SV_StartBug> if ( type == HUB_INIT3 ) <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> || type == HUB_INIT3 ) { device_lock ( hub -> intfdev ) ; if ( hub -> disconnected ) { device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ; return ; } if ( type == HUB_INIT2 <S2SV_ModStart> goto init3 ; } kref_get ( & hub -> kref ) <S2SV_ModEnd> <S2SV_ModStart> device_unlock ( hub -> intfdev ) ; <S2SV_ModStart> if ( type == HUB_INIT2 || type == HUB_INIT3 ) device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ; "
3247,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> else kvm_iommu_unmap_pages ( kvm , & old ) ; "
3248,<S2SV_StartBug> unsigned char buffer [ 3 ] ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ,"<S2SV_ModStart> * buffer ; int ret ; buffer = kmalloc ( 3 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> kfree ( buffer ) ; "
3249,<S2SV_StartBug> const char * base ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3250,"<S2SV_StartBug> fprintf ( file , ""<S2SV_blank>%s=\\""%s\\"""" , tag -> bit_name , tag -> bit_val ) ; <S2SV_EndBug> ","<S2SV_ModStart> fputc ( '<S2SV_blank>' , file ) ; fputs ( <S2SV_ModEnd> <S2SV_ModStart> file ) ; fputc ( '=' , file ) ; save_quoted ( <S2SV_ModStart> , file "
3251,"<S2SV_StartBug> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <S2SV_EndBug> ","<S2SV_ModStart> js_doregexec ( J , <S2SV_ModEnd> "
3252,"<S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ldt , VCPU_SREG_LDTR , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ; <S2SV_EndBug> ","<S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> "
3253,"<S2SV_StartBug> int qindex , double rate_target_ratio ) { <S2SV_EndBug> <S2SV_StartBug> const int base_bits_per_mb = vp9_rc_bits_per_mb ( frame_type , qindex , 1.0 ) ; <S2SV_EndBug> <S2SV_StartBug> target_index = i ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_rc_bits_per_mb ( frame_type , i , 1.0 ) <= target_bits_per_mb ) <S2SV_EndBug> ","<S2SV_ModStart> , vpx_bit_depth_t bit_depth <S2SV_ModStart> , bit_depth <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , bit_depth <S2SV_ModStart> { target_index = i ; break ; } <S2SV_ModEnd> "
3254,"<S2SV_StartBug> strlcpy ( racomp . type , ""acomp"" , sizeof ( racomp . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> 
3255,"<S2SV_StartBug> s = strchr ( token , '?' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
3256,"<S2SV_StartBug> if ( ( datao + 8 < datao ) || ( datao + 8 < 8 ) || ( datao + 8 > buf_size ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) { <S2SV_EndBug> <S2SV_StartBug> ""ExifMnoteDataPentax"" , ""Short<S2SV_blank>MakerNote"" ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . tag = exif_get_short ( buf + o + 0 , n -> order ) + base ; <S2SV_EndBug> <S2SV_StartBug> if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) || <S2SV_EndBug> ","<S2SV_ModStart> CHECKOVERFLOW ( datao , buf_size , 8 <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataPentax"" , ""Short<S2SV_blank>MakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o + 0 , n -> order ) + base ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnotePentax"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_pentax_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components <S2SV_ModEnd> <S2SV_ModStart> ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( n -> entries [ tcount ] . format ) , n -> entries [ tcount ] . components <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataPentax"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>"" ""of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataPentax"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s <S2SV_ModEnd> "
3257,"<S2SV_StartBug> memcpy ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ",<S2SV_ModStart> mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> mutex_unlock ( & ue -> card -> user_ctl_lock ) ; 
3258,"<S2SV_StartBug> err = ops -> cee_peer_getpg ( netdev , & pg ) ; <S2SV_EndBug> <S2SV_StartBug> struct cee_pfc pfc ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( & pg , 0 , sizeof ( pg ) ) ; <S2SV_ModStart> ; memset ( & pfc , 0 , sizeof ( pfc ) ) "
3259,"<S2SV_StartBug> unsigned facility ; <S2SV_EndBug> <S2SV_StartBug> # ifdef _WITH_VRRP_ <S2SV_EndBug> <S2SV_StartBug> while ( longindex = - 1 , ( c = getopt_long ( argc , argv , "":vhlndDRS:f:p:i:mM::g::Gt::"" <S2SV_EndBug> <S2SV_StartBug> case 't' : <S2SV_EndBug> ","<S2SV_ModStart> ; mode_t new_umask_val <S2SV_ModStart> { ""umask"" , required_argument , NULL , 'u' } , <S2SV_ModStart> "":vhlndu:DRS:f:p:i:mM::g::Gt::"" <S2SV_ModEnd> <S2SV_ModStart> 'u' : new_umask_val = set_umask ( optarg ) ; if ( umask_cmdline ) umask_val = new_umask_val ; break ; case "
3260,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> match_data -> cmp = asymmetric_key_cmp ; 
3261,"<S2SV_StartBug> struct address_space * mapping = inode -> i_mapping ; <S2SV_EndBug> <S2SV_StartBug> if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) { <S2SV_EndBug> <S2SV_StartBug> truncate_pagecache_range ( inode , start , end - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> flags , mode ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem 
3262,"<S2SV_StartBug> ap_assert ( stream ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! stream -> has_response ) { <S2SV_EndBug> <S2SV_StartBug> return h2_stream_set_error ( stream , <S2SV_EndBug> <S2SV_StartBug> return h2_stream_set_error ( stream , <S2SV_EndBug> <S2SV_StartBug> HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE ) ; <S2SV_EndBug> ","<S2SV_ModStart> int error = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return APR_EINVAL ; } ++ stream -> request_headers_added ; <S2SV_ModStart> error = HTTP_REQUEST_URI_TOO_LARGE <S2SV_ModEnd> <S2SV_ModStart> error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE ; } if ( stream -> request_headers_added > stream -> session -> s -> limit_req_fields + 4 ) { if ( stream -> request_headers_added > stream -> session -> s -> limit_req_fields + 4 + 100 ) { return APR_ECONNRESET ; } ap_log_cerror ( APLOG_MARK , APLOG_TRACE1 , 0 , stream -> session -> c , ""h2_stream(%ld-%d):<S2SV_blank>too<S2SV_blank>many<S2SV_blank>header<S2SV_blank>lines"" , stream -> session -> id , stream -> id ) ; error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE ; } if ( h2_stream_is_scheduled ( stream ) ) { return add_trailer ( stream , name , nlen , value , vlen ) ; } else if ( error ) { <S2SV_ModStart> error <S2SV_ModEnd> "
3263,<S2SV_StartBug> if ( type == ARPHRD_ETHER ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; } 
3264,<S2SV_StartBug> pte_unmap ( page_table ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! vma -> vm_ops -> fault ) return VM_FAULT_SIGBUS 
3265,<S2SV_StartBug> if ( * p == FAC_CCITT_DEST_NSAP ) { <S2SV_EndBug> ,<S2SV_ModStart> l < 10 || l > 20 ) return - 1 ; if ( 
3266,<S2SV_StartBug> if ( cluster != fs -> clusters - 1 ) <S2SV_EndBug> ,<S2SV_ModStart> + <S2SV_ModEnd> 
3267,<S2SV_StartBug> GHashTableIter iter ; <S2SV_EndBug> ,"<S2SV_ModStart> value = get_map_string_item_or_NULL ( settings , ""PrivateReports"" ) ; if ( value ) { g_settings_privatereports = string_to_bool ( value ) ; remove_map_string_item ( settings , ""PrivateReports"" ) ; } "
3268,<S2SV_StartBug> if ( split_flag ) { <S2SV_EndBug> ,<S2SV_ModStart> && size >= MIN_BLOCK_SIZE 
3269,"<S2SV_StartBug> int size ; <S2SV_EndBug> <S2SV_StartBug> size = offsetof ( PATH , p [ 0 ] ) + sizeof ( path -> p [ 0 ] ) * npts ; <S2SV_EndBug> ","<S2SV_ModStart> ; int base_size <S2SV_ModStart> base_size = sizeof ( path -> <S2SV_ModEnd> <S2SV_ModStart> * npts ; size = offsetof ( PATH , <S2SV_ModEnd> <S2SV_ModStart> + base_size ; if ( base_size / npts != sizeof ( path -> p [ 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested"" ) ) ) <S2SV_ModEnd> "
3270,<S2SV_StartBug> ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error ) <S2SV_EndBug> ,<S2SV_ModStart> && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) 
3271,"<S2SV_StartBug> if ( optstr ) { <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" <S2SV_EndBug> <S2SV_StartBug> ""mincolors<S2SV_blank>%d\\n"" , info -> len , info -> width , info -> height , info -> numplanes , <S2SV_EndBug> <S2SV_StartBug> info -> depth , info -> enctype , info -> siz , info -> hres , info -> vres , <S2SV_EndBug> <S2SV_StartBug> info -> numcolors , info -> mincolors ) ) ; <S2SV_EndBug> <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> <S2SV_StartBug> jas_image_destroy ( image ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> ","<S2SV_ModStart> image = 0 ; info = 0 ; <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%ld;<S2SV_blank>width<S2SV_blank>%ld;<S2SV_blank>height<S2SV_blank>%ld;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%ld;<S2SV_blank>siz<S2SV_blank>%ld;<S2SV_blank>hres<S2SV_blank>%ld;<S2SV_blank>vres<S2SV_blank>%ld;<S2SV_blank>numcolors<S2SV_blank>%ld;<S2SV_blank>"" ""mincolors<S2SV_blank>%ld\\n"" , JAS_CAST ( long <S2SV_ModEnd> <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long , <S2SV_ModEnd> <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long , <S2SV_ModEnd> <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) ; if ( info -> width < 0 || info -> height < 0 || info -> numplanes < 0 || info -> depth < 0 || info -> siz < 0 || info -> hres < 0 || info -> vres < 0 ) { jas_eprintf ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\n"" ) ; goto error ; } <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error ; } <S2SV_ModStart> return image ; error : if ( info ) { bmp_info_destroy ( info ) ; } if ( image ) { <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> "
3272,<S2SV_StartBug> void * dllhandle ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( COM_CompareExtension ( name , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , name ) ; return NULL ; } "
3273,<S2SV_StartBug> ssize_t ret ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES 
3274,<S2SV_StartBug> if ( tag == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( len <= 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( n > sizeof ( size_t ) - 1 ) ) <S2SV_EndBug> <S2SV_StartBug> for ( len = 0 ; n > 0 ; n -- ) { <S2SV_EndBug> <S2SV_StartBug> dp += len ; <S2SV_EndBug> ,<S2SV_ModStart> ASN1_EOC <S2SV_ModEnd> <S2SV_ModStart> goto check_length ; <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> len = 0 ; for ( <S2SV_ModEnd> <S2SV_ModStart> check_length : if ( len > datalen - dp ) goto data_overrun_error ; 
3275,"<S2SV_StartBug> rinfo = kmalloc ( SZ_SG_REQ_INFO * SG_MAX_QUEUE , <S2SV_EndBug> ",<S2SV_ModStart> kzalloc <S2SV_ModEnd> 
3276,<S2SV_StartBug> if ( ! is_launcher ) <S2SV_EndBug> <S2SV_StartBug> if ( nautilus_file_can_execute ( file ) ) <S2SV_EndBug> ,"<S2SV_ModStart> g_autofree gchar * trusted = NULL ; <S2SV_ModStart> trusted = nautilus_file_get_metadata ( file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL ) ; <S2SV_ModStart> && trusted != NULL "
3277,<S2SV_StartBug> commonlen = COMPUTESIZE ( state . num ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( state . num > QUERYTYPEMAXITEMS ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>query<S2SV_blank>items<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , state . num , ( int ) QUERYTYPEMAXITEMS ) ) ) ; "
3278,"<S2SV_StartBug> r = do_write_pids ( fc -> pid , f -> controller , f -> cgroup , f -> file , localbuf ) ; <S2SV_EndBug> ","<S2SV_ModStart> fc -> uid , "
3279,"<S2SV_StartBug> void vp9_idct16x16_add ( const int16_t * input , uint8_t * dest , int stride , <S2SV_EndBug> <S2SV_StartBug> vp9_idct16x16_1_add ( input , dest , stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_idct16x16_10_add ( input , dest , stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_idct16x16_256_add ( input , dest , stride ) ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_idct16x16_1_add <S2SV_ModEnd> <S2SV_ModStart> vpx_idct16x16_10_add <S2SV_ModEnd> <S2SV_ModStart> vpx_idct16x16_256_add <S2SV_ModEnd> 
3280,"<S2SV_StartBug> uint8_t mus_event [ ] = { 0 , 0 , 0 , 0 } ; <S2SV_EndBug> <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mus_mdi , ( uint8_t * ) mus_event , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> # define MUS_SZ 4 <S2SV_ModStart> MUS_SZ <S2SV_ModStart> , MUS_SZ "
3281,<S2SV_StartBug> gdImagePtr im ; <S2SV_EndBug> ,"<S2SV_ModStart> check_file ( ""heap_overflow_1.tga"" ) ; check_file ( ""heap_overflow_2.tga"" <S2SV_ModEnd> "
3282,"<S2SV_StartBug> if ( rc < 0 ) <S2SV_EndBug> <S2SV_StartBug> dev_err ( & port -> dev , ""Reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed<S2SV_blank>(error<S2SV_blank>=<S2SV_blank>%d)\\n"" , <S2SV_EndBug> ","<S2SV_ModStart> != KLSI_STATUSBUF_LEN ) { <S2SV_ModEnd> <S2SV_ModStart> ""reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed:<S2SV_blank>%d\\n"" , rc ) ; if ( rc >= 0 ) rc = - EIO ; } <S2SV_ModEnd> "
3283,"<S2SV_StartBug> l_strnstart ( const char * tstr1 , u_int tl1 , const char * str2 , u_int l2 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ","<S2SV_ModStart> netdissect_options * ndo , <S2SV_ModStart> if ( ! ND_TTEST2 ( * str2 , tl1 ) ) { return 0 ; } "
3284,"<S2SV_StartBug> queue_remove_all ( att -> req_queue , NULL , NULL , disc_att_send_op ) ; <S2SV_EndBug> <S2SV_StartBug> queue_foreach ( att -> disconn_list , disconn_handler , INT_TO_PTR ( err ) ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> att -> in_disc = true ; queue_remove_all ( att -> req_queue , NULL , NULL , disc_att_send_op ) ; queue_remove_all ( att -> ind_queue , NULL , NULL , disc_att_send_op ) ; queue_remove_all ( att -> write_queue , NULL , NULL , disc_att_send_op ) ; att -> in_disc = false ; "
3285,"<S2SV_StartBug> int segment_id , vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ) { <S2SV_EndBug> <S2SV_StartBug> const int skip = vp9_read ( r , cm -> fc . skip_probs [ ctx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> segfeature_active <S2SV_ModEnd> <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> 
3286,"<S2SV_StartBug> return xfrm6_rcv_spi ( skb , spi ) ; <S2SV_EndBug> ",<S2SV_ModStart> > 0 ? : 0 
3287,<S2SV_StartBug> OPJ_UNUSED ( p_manager ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3288,<S2SV_StartBug> size_t mask = ( size_t ) self -> mt_mask ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3289,"<S2SV_StartBug> if ( ! ND_TTEST2 ( * tptr , 1 ) ) <S2SV_EndBug> ",<S2SV_ModStart> 2 <S2SV_ModEnd> 
3290,<S2SV_StartBug> ops -> destroy ( dev ) ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & kvm -> lock ) ; list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
3291,"<S2SV_StartBug> char * pin , * pout ; <S2SV_EndBug> ","<S2SV_ModStart> struct stream packet = * s ; if ( ( in_len < 0 ) || ( ( uint32 ) in_len >= ( RD_UINT32_MAX / 2 ) ) ) { logger ( Protocol , Error , ""rdp_in_unistr(),<S2SV_blank>length<S2SV_blank>of<S2SV_blank>unicode<S2SV_blank>data<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" ) ; abort ( ) ; } if ( ! s_check_rem ( s , in_len ) ) { rdp_protocol_error ( ""rdp_in_unistr(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>unicode<S2SV_blank>data<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } "
3292,<S2SV_StartBug> { size_t chanmap_size = psf -> sf . channels * sizeof ( psf -> channel_map [ 0 ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> SF_MIN ( <S2SV_ModStart> , layout_tag & 0xffff ) "
3293,"<S2SV_StartBug> } else if ( ! strncmp ( network_line , ""GET_DN<S2SV_blank>"" , strlen ( ""GET_DN<S2SV_blank>"" ) ) && msg_id != UINT32_MAX && network_client_get_version ( fd ) > 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> version > PROTOCOL_UNKNOWN && version < PROTOCOL_3 <S2SV_ModEnd> 
3294,<S2SV_StartBug> vp9_ppflags_t flags = { 0 } ; <S2SV_EndBug> ,<S2SV_ModStart> ; vp9_zero ( flags ) <S2SV_ModEnd> 
3295,<S2SV_StartBug> if ( ! addr || addr -> sa_family != AF_BLUETOOTH ) <S2SV_EndBug> ,<S2SV_ModStart> ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_sco ) 
3296,<S2SV_StartBug> # ifdef CONFIG_FUTEX <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( tsk -> robust_list ) ) <S2SV_EndBug> ,"<S2SV_ModStart> if ( group_dead ) tty_audit_exit ( ) ; if ( unlikely ( tsk -> audit_context ) ) audit_free ( tsk ) ; tsk -> exit_code = code ; taskstats_exit ( tsk , group_dead ) ; exit_mm ( tsk ) ; if ( group_dead ) acct_process ( ) ; trace_sched_process_exit ( tsk ) ; exit_sem ( tsk ) ; exit_files ( tsk ) ; exit_fs ( tsk ) ; check_stack_usage ( ) ; exit_thread ( ) ; cgroup_exit ( tsk , 1 ) ; exit_keys ( tsk ) ; if ( group_dead && tsk -> signal -> leader ) disassociate_ctty ( 1 ) ; module_put ( task_thread_info ( tsk ) -> exec_domain -> module ) ; if ( tsk -> binfmt ) module_put ( tsk -> binfmt -> module ) ; proc_exit_connector ( tsk ) ; exit_notify ( tsk , group_dead ) ; # ifdef CONFIG_NUMA mpol_put ( tsk -> mempolicy ) ; tsk -> mempolicy = NULL ; # endif <S2SV_ModStart>  <S2SV_ModEnd> "
3297,"<S2SV_StartBug> in_uint16_le ( s , type ) ; <S2SV_EndBug> <S2SV_StartBug> if ( status == CLIPRDR_ERROR ) <S2SV_EndBug> ","<S2SV_ModStart> struct stream packet = * s ; <S2SV_ModStart> ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cliprdr_process(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } if ( "
3298,<S2SV_StartBug> if ( ! mp -> ports && ! mp -> mglist && <S2SV_EndBug> ,<S2SV_ModStart> mp -> timer_armed && 
3299,<S2SV_StartBug> assert ( status != NULL ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( status == NULL ) status = ""UNKNOWN_REASON"" <S2SV_ModEnd> "
3300,"<S2SV_StartBug> netdev_dbg ( vif -> dev , ""GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\n"" , gso -> u . gso . type ) ; <S2SV_EndBug> ",<S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif 
3301,"<S2SV_StartBug> struct mb_cache_entry * ce = NULL ; <S2SV_EndBug> <S2SV_StartBug> int error = 0 ; <S2SV_EndBug> <S2SV_StartBug> ea_bdebug ( bh , ""refcount<S2SV_blank>now=0;<S2SV_blank>freeing"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> __u32 hash = le32_to_cpu ( BHDR ( bh ) -> h_hash ) ; <S2SV_ModStart> mb2_cache_entry_delete_block ( EXT4_GET_MB_CACHE ( inode ) , hash , bh -> b_blocknr <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3302,"<S2SV_StartBug> ( sctp_paramhdr_t * ) addip_hdr -> params , <S2SV_EndBug> ","<S2SV_ModStart> asconf_ack , false , <S2SV_ModEnd> "
3303,<S2SV_StartBug> for ( vma = mm -> mmap ; vma ; vma = vma -> vm_next ) <S2SV_EndBug> ,<S2SV_ModStart> VM_WARN_ON ( ! mmget_still_valid ( mm ) ) ; 
3304,"<S2SV_StartBug> ip_printroute ( ndo , cp , option_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( <S2SV_ModStart> == - 1 ) goto trunc 
3305,"<S2SV_StartBug> request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( buf2 ) <S2SV_ModStart> , sizeof ( buf2 ) "
3306,<S2SV_StartBug> unpack_streams += ( size_t ) f [ i ] . numUnpackStreams ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unpack_streams > SIZE_MAX - UMAX_ENTRY ) { return ( - 1 ) ; } 
3307,<S2SV_StartBug> char * tmpptr = key + strlen ( key ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3308,<S2SV_StartBug> atomic_inc ( & sb -> s_active ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ; 
3309,<S2SV_StartBug> sigev_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3310,"<S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> FRAME_CONTEXT * const fc = & cm -> fc ; <S2SV_EndBug> <S2SV_StartBug> encode_txfm_probs ( cm , & header_bc ) ; <S2SV_EndBug> <S2SV_StartBug> update_skip_probs ( cm , & header_bc ) ; <S2SV_EndBug> <S2SV_StartBug> prob_diff_update ( vp9_inter_mode_tree , cm -> fc . inter_mode_probs [ i ] , <S2SV_EndBug> <S2SV_StartBug> cm -> counts . inter_mode [ i ] , INTER_MODES , & header_bc ) ; <S2SV_EndBug> <S2SV_StartBug> update_switchable_interp_probs ( cm , & header_bc ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> counts . intra_inter [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> allow_comp_inter_inter ) { <S2SV_EndBug> <S2SV_StartBug> vp9_write_bit ( & header_bc , use_compound_pred ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_bit ( & header_bc , use_hybrid_pred ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> counts . comp_inter [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> counts . single_ref [ i ] [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> counts . single_ref [ i ] [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> counts . comp_ref [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> prob_diff_update ( vp9_intra_mode_tree , cm -> fc . y_mode_prob [ i ] , <S2SV_EndBug> <S2SV_StartBug> cm -> counts . y_mode [ i ] , INTRA_MODES , & header_bc ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> counts . partition [ i ] , PARTITION_TYPES , & header_bc ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_nmv_probs ( cm , cm -> allow_high_precision_mv , & header_bc ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_stop_encode ( & header_bc ) ; <S2SV_EndBug> ","<S2SV_ModStart> td . <S2SV_ModStart> cm -> fc ; FRAME_COUNTS * counts = cpi -> td . counts ; vpx_writer header_bc ; vpx_start_encode <S2SV_ModEnd> <S2SV_ModStart> , counts <S2SV_ModStart> , counts <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , counts <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> vpx_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_write_bit <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> , & counts -> mv <S2SV_ModStart> vpx_stop_encode <S2SV_ModEnd> "
3311,"<S2SV_StartBug> if ( packet -> payload_packet_len >= 40 ) { <S2SV_EndBug> <S2SV_StartBug> ovpn_payload += 2 ; <S2SV_EndBug> <S2SV_StartBug> htons ( packet -> udp -> source ) , htons ( packet -> udp -> dest ) , packet -> payload_packet_len ) ; <S2SV_EndBug> <S2SV_StartBug> ( ( packet -> payload_packet_len == 112 ) <S2SV_EndBug> <S2SV_StartBug> || ( ( packet -> payload_packet_len == 80 ) <S2SV_EndBug> <S2SV_StartBug> alen = ovpn_payload [ P_PACKET_ID_ARRAY_LEN_OFFSET ( hmac_size ) ] ; <S2SV_EndBug> <S2SV_StartBug> session_remote = ovpn_payload + P_PACKET_ID_ARRAY_LEN_OFFSET ( hmac_size ) + 1 + alen * 4 ; <S2SV_EndBug> <S2SV_StartBug> if ( memcmp ( flow -> ovpn_session_id , session_remote , 8 ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int16_t ovpn_payload_len = <S2SV_ModEnd> <S2SV_ModStart> ; if ( ovpn_payload_len <S2SV_ModStart> , ovpn_payload_len -= 2 ; <S2SV_ModStart> ovpn_payload_len <S2SV_ModEnd> <S2SV_ModStart> ovpn_payload_len <S2SV_ModEnd> <S2SV_ModStart> ovpn_payload_len <S2SV_ModEnd> <S2SV_ModStart> u_int16_t offset = P_PACKET_ID_ARRAY_LEN_OFFSET ( hmac_size ) ; <S2SV_ModStart> offset <S2SV_ModEnd> <S2SV_ModStart> offset += <S2SV_ModEnd> <S2SV_ModStart> ( offset + 8 ) <= ovpn_payload_len ) { session_remote = & ovpn_payload [ offset ] ; if ( <S2SV_ModStart> } else failed = 1 ; "
3312,<S2SV_StartBug> case 0x2f8 : <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3313,<S2SV_StartBug> return TRUE ; <S2SV_EndBug> ,<S2SV_ModStart> if ( iter -> start == iter -> end ) iter -> end = g_utf8_next_char ( iter -> end ) ; 
3314,<S2SV_StartBug> if ( ( data & ~ mask ) != PSW_USER_BITS ) <S2SV_EndBug> ,<S2SV_ModStart> ^ PSW_USER_BITS ) <S2SV_ModStart> return - EINVAL ; if ( ( data & PSW_MASK_ASC ) == PSW_ASC_HOME <S2SV_ModEnd> 
3315,"<S2SV_StartBug> vpx_memset ( & next_frame , 0 , sizeof ( next_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & first_frame , this_frame , sizeof ( * this_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & last_frame , this_frame , sizeof ( * this_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & tmp_frame , & first_frame , sizeof ( first_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> boost_score = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> int projected_buffer_level = ( int ) cpi -> buffer_level ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3316,"<S2SV_StartBug> const uint8_t * end , * ptr = avpkt -> data ; <S2SV_EndBug> <S2SV_StartBug> end = avpkt -> data + avpkt -> size ; <S2SV_EndBug> <S2SV_StartBug> while ( memcmp ( ptr , ""/*<S2SV_blank>XPM<S2SV_blank>*/"" , 9 ) && ptr < end - 9 ) <S2SV_EndBug> <S2SV_StartBug> size *= 94 ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ncolors ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> if ( ptr + cpp > end ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ptr += mod_strcspn ( ptr , ""\\"""" ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < avctx -> width ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> if ( ptr + cpp > end ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> av_fast_padded_malloc ( & x -> buf , & x -> buf_size , avpkt -> size ) ; if ( ! x -> buf ) return AVERROR ( ENOMEM ) ; memcpy ( x -> buf , avpkt -> data , avpkt -> size ) ; x -> buf [ avpkt -> size ] = 0 ; ptr = x -> buf ; end = x -> buf <S2SV_ModEnd> <S2SV_ModStart> end - ptr > 9 && <S2SV_ModStart> ) ptr ++ ; if ( end - ptr <= 9 <S2SV_ModEnd> <S2SV_ModStart> 95 <S2SV_ModEnd> <S2SV_ModStart> if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> end - ptr < cpp <S2SV_ModEnd> <S2SV_ModStart> if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> end - ptr < cpp <S2SV_ModEnd> "
3317,"<S2SV_StartBug> struct in6_addr * addr , uint32_t * ifindex ) <S2SV_EndBug> <S2SV_StartBug> unsigned char cbuf [ CMSG_SPACE ( sizeof ( struct in6_pktinfo ) ) ] ; <S2SV_EndBug> <S2SV_StartBug> if ( cmsghdr -> cmsg_level == IPPROTO_IPV6 && <S2SV_EndBug> <S2SV_StartBug> cmsghdr -> cmsg_type == IPV6_PKTINFO && <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , int * hoplimit <S2SV_ModStart> 2 * <S2SV_ModStart> != IPPROTO_IPV6 ) continue ; switch ( <S2SV_ModEnd> <S2SV_ModStart> ) { case IPV6_PKTINFO : if ( <S2SV_ModEnd> <S2SV_ModStart> break ; case IPV6_HOPLIMIT : if ( cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( int ) ) ) { int * val ; val = ( int * ) CMSG_DATA ( cmsghdr ) ; * hoplimit = * val ; } break ; } "
3318,"<S2SV_StartBug> if ( ep_loop_check ( ep , tfile ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> goto error_tgt_fput ; <S2SV_EndBug> ",<S2SV_ModStart> { clear_tfile_check_list ( ) ; <S2SV_ModStart> } 
3319,"<S2SV_StartBug> dprintk ( 2 , ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%d,vma=%08lx-%08lx]\\n"" , map , <S2SV_EndBug> ","<S2SV_ModStart> ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n"" <S2SV_ModEnd> "
3320,"<S2SV_StartBug> mlx4_dbg ( dev , ""Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\n"" , free ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( free < 0 ) { err = - ENOMEM ; goto out ; } 
3321,"<S2SV_StartBug> unsigned facility ; <S2SV_EndBug> <S2SV_StartBug> # ifdef _WITH_VRRP_ <S2SV_EndBug> <S2SV_StartBug> while ( longindex = - 1 , ( c = getopt_long ( argc , argv , "":vhlndDRS:f:p:i:mM::g::Gt::"" <S2SV_EndBug> <S2SV_StartBug> case 't' : <S2SV_EndBug> ","<S2SV_ModStart> ; mode_t new_umask_val <S2SV_ModStart> { ""umask"" , required_argument , NULL , 'u' } , <S2SV_ModStart> "":vhlndu:DRS:f:p:i:mM::g::Gt::"" <S2SV_ModEnd> <S2SV_ModStart> 'u' : new_umask_val = set_umask ( optarg ) ; if ( umask_cmdline ) umask_val = new_umask_val ; break ; case "
3322,"<S2SV_StartBug> strlcpy ( rakcipher . type , ""akcipher"" , sizeof ( rakcipher . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> 
3323,"<S2SV_StartBug> int x , y , pos ; <S2SV_EndBug> <S2SV_StartBug> if ( gdImageGetPixel ( image , x , y ) == fg ) { <S2SV_EndBug> ","<S2SV_ModStart> _gdImageWBMPCtx <S2SV_ModEnd> <S2SV_ModStart> fg , out <S2SV_ModEnd> "
3324,"<S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> int_mv arf_top_mv , gld_top_mv ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO mi_local = { { 0 } } ; <S2SV_EndBug> <S2SV_StartBug> int_mv arf_left_mv , gld_left_mv ; <S2SV_EndBug> <S2SV_StartBug> int gld_y_in_offset = gld_y_offset ; <S2SV_EndBug> <S2SV_StartBug> arf_left_mv . as_int = mb_stats -> ref [ ALTREF_FRAME ] . m . mv . as_int ; <S2SV_EndBug> ","<S2SV_ModStart> td . <S2SV_ModStart> MV gld_top_mv = { 0 , 0 } <S2SV_ModEnd> <S2SV_ModStart> ; vp9_zero ( mi_local ) <S2SV_ModEnd> <S2SV_ModStart> MV gld_left_mv = gld_top_mv <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> gld_left_mv <S2SV_ModEnd> <S2SV_ModStart> GOLDEN_FRAME <S2SV_ModEnd> <S2SV_ModStart> as_mv ; if ( mb_col == 0 ) { gld_top_mv = gld_left_mv <S2SV_ModEnd> "
3325,"<S2SV_StartBug> dfa * d1 = PyGrammar_FindDFA ( <S2SV_EndBug> <S2SV_StartBug> D ( printf ( ""<S2SV_blank>Push<S2SV_blank>...\\n"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; if ( nt == func_body_suite && ! ( ps -> p_flags & PyCF_TYPE_COMMENTS ) ) { D ( printf ( ""<S2SV_blank>[switch<S2SV_blank>func_body_suite<S2SV_blank>to<S2SV_blank>suite]"" ) ) ; nt = suite ; } d1 <S2SV_ModStart> ""<S2SV_blank>Push<S2SV_blank>\'%s\'\\n"" , d1 -> d_name <S2SV_ModEnd> "
3326,"<S2SV_StartBug> char buffer [ 64 ] = { '\\0' } , rdnSeqBuf [ 1024 ] = { '\\0' } ; <S2SV_EndBug> ",<S2SV_ModStart> 2048 <S2SV_ModEnd> 
3327,"<S2SV_StartBug> if ( ! php_var_unserialize ( & intern -> array , & p , s + buf_len , & var_hash TSRMLS_CC ) ) { <S2SV_EndBug> ",<S2SV_ModStart> || ( Z_TYPE_P ( intern -> array ) != IS_ARRAY && Z_TYPE_P ( intern -> array ) != IS_OBJECT ) ) { zval_ptr_dtor ( & intern -> array ) ; <S2SV_ModEnd> 
3328,"<S2SV_StartBug> if ( jp2_getuint16 ( in , & pclr -> numlutents ) || <S2SV_EndBug> ",<S2SV_ModStart> pclr -> bpc = 0 ; 
3329,"<S2SV_StartBug> FIRSTPASS_STATS * this_frame , <S2SV_EndBug> <S2SV_StartBug> double * this_frame_mv_in_out , <S2SV_EndBug> <S2SV_StartBug> double motion_pct ; <S2SV_EndBug> <S2SV_StartBug> * this_frame_mv_in_out = this_frame -> mv_in_out_count * motion_pct ; <S2SV_EndBug> <S2SV_StartBug> * mv_in_out_accumulator += this_frame -> mv_in_out_count * motion_pct ; <S2SV_EndBug> <S2SV_StartBug> * abs_mv_in_out_accumulator += fabs ( this_frame -> mv_in_out_count * motion_pct ) ; <S2SV_EndBug> <S2SV_StartBug> if ( motion_pct > 0.05 ) { <S2SV_EndBug> <S2SV_StartBug> const double this_frame_mvr_ratio = fabs ( this_frame -> mvr_abs ) / <S2SV_EndBug> <S2SV_StartBug> DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVr ) ) ; <S2SV_EndBug> <S2SV_StartBug> const double this_frame_mvc_ratio = fabs ( this_frame -> mvc_abs ) / <S2SV_EndBug> <S2SV_StartBug> DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVc ) ) ; <S2SV_EndBug> <S2SV_StartBug> * mv_ratio_accumulator += ( this_frame_mvr_ratio < this_frame -> mvr_abs ) <S2SV_EndBug> <S2SV_StartBug> ? ( this_frame_mvr_ratio * motion_pct ) <S2SV_EndBug> <S2SV_StartBug> * mv_ratio_accumulator += ( this_frame_mvc_ratio < this_frame -> mvc_abs ) <S2SV_EndBug> <S2SV_StartBug> ? ( this_frame_mvc_ratio * motion_pct ) <S2SV_EndBug> ",<S2SV_ModStart> const FIRSTPASS_STATS * stats <S2SV_ModEnd> <S2SV_ModStart> mv_in_out <S2SV_ModEnd> <S2SV_ModStart> const double pct = stats <S2SV_ModEnd> <S2SV_ModStart> mv_in_out = stats <S2SV_ModEnd> <S2SV_ModStart> pct <S2SV_ModEnd> <S2SV_ModStart> * mv_in_out <S2SV_ModEnd> <S2SV_ModStart> * mv_in_out <S2SV_ModEnd> <S2SV_ModStart> pct <S2SV_ModEnd> <S2SV_ModStart> mvr_ratio <S2SV_ModEnd> <S2SV_ModStart> stats <S2SV_ModEnd> <S2SV_ModStart> stats <S2SV_ModEnd> <S2SV_ModStart> mvc_ratio <S2SV_ModEnd> <S2SV_ModStart> stats <S2SV_ModEnd> <S2SV_ModStart> stats <S2SV_ModEnd> <S2SV_ModStart> pct * ( mvr_ratio < stats -> mvr_abs ? mvr_ratio : stats <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pct * ( mvc_ratio < stats -> mvc_abs ? mvc_ratio : stats <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3330,<S2SV_StartBug> ( ( flags & O_ACCMODE ) == O_WRONLY || <S2SV_EndBug> <S2SV_StartBug> ( flags & O_ACCMODE ) == O_RDWR ) ) { <S2SV_EndBug> ,<S2SV_ModStart> != O_RDONLY <S2SV_ModEnd> <S2SV_ModStart> ( O_CREAT | O_TRUNC ) ) != 0 <S2SV_ModEnd> 
3331,"<S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> ","<S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\""baz\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""foo\\""]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""bar\\""]<S2SV_blank>==<S2SV_blank>\\""bar\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\""dummy\\"")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""foo\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""bar\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> "
3332,"<S2SV_StartBug> char common_name [ FIELD_SIZE + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ; X509 * cert = SSL_get_peer_certificate ( tunnel -> ssl_handle ) ; if ( cert == NULL ) { log_error ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gateway<S2SV_blank>certificate.\\n"" ) ; return 1 ; } subj = X509_get_subject_name ( cert ) ; # ifdef HAVE_X509_CHECK_HOST if ( X509_check_host ( cert , tunnel -> config -> gateway_host , 0 , 0 , NULL ) == 1 ) cert_valid = 1 ; # else <S2SV_ModStart>  <S2SV_ModEnd> "
3333,<S2SV_StartBug> pipe -> curbuf = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> account_pipe_buffers ( pipe , pipe -> buffers , nr_pages ) ; "
3334,"<S2SV_StartBug> static char buf [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> buflen += snprintf ( buf + buflen , sizeof ( buf ) - buflen , ""%s%s"" , <S2SV_EndBug> <S2SV_StartBug> sepstr , lp -> s ) ; <S2SV_EndBug> <S2SV_StartBug> if ( buflen == 0 ) <S2SV_EndBug> ","<S2SV_ModStart> 1024 + 1 ] ; char * bufp = buf ; size_t space_left = sizeof ( buf ) , string_size <S2SV_ModEnd> <S2SV_ModStart> if ( space_left <= 1 ) return ( buf ) ; string_size = strlcpy ( bufp , sepstr , space_left ) ; if ( string_size >= space_left ) return ( buf ) ; bufp += string_size ; space_left -= string_size ; if ( space_left <= 1 ) return ( buf ) ; string_size = strlcpy ( bufp <S2SV_ModEnd> <S2SV_ModStart> , space_left ) ; if ( string_size >= space_left ) return ( buf ) ; bufp += string_size ; space_left -= string_size <S2SV_ModEnd> <S2SV_ModStart> bufp == buf <S2SV_ModEnd> "
3335,"<S2SV_StartBug> cpi -> framerate = ( double ) ( oxcf -> timebase . den ) / <S2SV_EndBug> <S2SV_StartBug> ( double ) ( oxcf -> timebase . num ) ; <S2SV_EndBug> <S2SV_StartBug> vp8_change_config ( cpi , oxcf ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( oxcf -> timebase . num > 0 ) { <S2SV_ModStart> } else { cpi -> framerate = 30 ; } <S2SV_ModStart> cpi -> ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> refresh_entropy_probs = 1 ; 
3336,"<S2SV_StartBug> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <S2SV_EndBug> ","<S2SV_ModStart> elems , e -> "
3337,<S2SV_StartBug> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! tmp ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; 
3338,"<S2SV_StartBug> static void rd_pick_sb_modes ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int * totalrate , int64_t * totaldist , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> double rdmult_ratio ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> x -> skip_recode = 0 ; <S2SV_EndBug> <S2SV_StartBug> x -> source_variance = get_sby_perpixel_variance ( cpi , x , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> mbmi -> segment_id = vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> rdmult_ratio = vp9_vaq_rdmult_ratio ( energy ) ; <S2SV_EndBug> <S2SV_StartBug> orig_rdmult = x -> rdmult ; <S2SV_EndBug> <S2SV_StartBug> const int mi_offset = mi_row * cm -> mi_cols + mi_col ; <S2SV_EndBug> <S2SV_StartBug> x -> rdmult += ( ( x -> rdmult * ( complexity - 128 ) ) / 256 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ) <S2SV_EndBug> <S2SV_StartBug> vp9_rd_pick_intra_mode_sb ( cpi , x , totalrate , totaldist , bsize , ctx , <S2SV_EndBug> <S2SV_StartBug> if ( bsize >= BLOCK_8X8 ) <S2SV_EndBug> <S2SV_StartBug> vp9_rd_pick_inter_mode_sb ( cpi , x , tile , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> totalrate , totaldist , bsize , ctx , best_rd ) ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> vp9_rd_pick_inter_mode_sub8x8 ( cpi , x , tile , mi_row , mi_col , totalrate , <S2SV_EndBug> <S2SV_StartBug> if ( aq_mode == VARIANCE_AQ ) { <S2SV_EndBug> <S2SV_StartBug> if ( * totalrate != INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( aq_mode == COMPLEXITY_AQ || aq_mode == CYCLIC_REFRESH_AQ ) { <S2SV_EndBug> ","<S2SV_ModStart> TileDataEnc * tile_data , MACROBLOCK * const x <S2SV_ModEnd> <S2SV_ModStart> RD_COST * rd_cost <S2SV_ModEnd> <S2SV_ModStart> TileInfo * const tile_info = & tile_data -> tile_info <S2SV_ModEnd> <S2SV_ModStart> vpx_clear_system_state ( ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tile_info , x <S2SV_ModEnd> <S2SV_ModStart> ctx -> skippable = 0 ; ctx -> pred_pixel_ready = 0 ; <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> vp9_high_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize , xd -> bd ) ; } else { x -> source_variance = vp9_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize ) ; } # else x -> source_variance = vp9_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize ) ; # endif orig_rdmult = x -> rdmult <S2SV_ModEnd> <S2SV_ModStart> get_segment_id <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = set_segment_rdmult ( cpi , x , mbmi -> segment_id <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = set_segment_rdmult ( cpi , x , mbmi -> segment_id <S2SV_ModEnd> <S2SV_ModStart> cyclic_refresh_segment_id_boosted ( get_segment_id <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> rd_cost , bsize , ctx , <S2SV_ModEnd> <S2SV_ModStart> { if ( segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) vp9_rd_pick_inter_mode_sb_seg_skip ( cpi , tile_data , x , rd_cost , bsize , ctx , best_rd ) ; else <S2SV_ModStart> tile_data , x <S2SV_ModEnd> <S2SV_ModStart> rd_cost <S2SV_ModEnd> <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> tile_data , x <S2SV_ModEnd> <S2SV_ModStart> rd_cost <S2SV_ModEnd> <S2SV_ModStart> } if ( ( rd_cost -> rate <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> ) && ( bsize >= BLOCK_16X16 ) && ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) ) { vp9_caq_select_segment ( cpi , x , bsize , mi_row , mi_col , rd_cost -> rate ) ; } x -> rdmult = orig_rdmult ; if ( rd_cost -> rate == INT_MAX ) rd_cost -> rdcost = INT64_MAX ; ctx -> rate = rd_cost -> rate ; ctx -> dist = rd_cost -> dist ; <S2SV_ModEnd> "
3339,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( s == 0 ) return ( ( void * ) NULL ) ; 
3340,<S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> ret = - EIO ; goto out <S2SV_ModEnd> <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> goto out ; } ret = brightness ; out : kfree ( data ) ; return ret <S2SV_ModEnd> "
3341,"<S2SV_StartBug> gboolean use_box_blur ; <S2SV_EndBug> <S2SV_StartBug> sy = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> if ( use_box_blur ) { <S2SV_EndBug> <S2SV_StartBug> col_buffer = g_new0 ( guchar , height * bpp * 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> gboolean use_box_blur ; if ( sx < 10.0 ) use_box_blur = FALSE ; else use_box_blur = TRUE ; <S2SV_ModStart> gboolean use_box_blur ; if ( sy < 10.0 ) use_box_blur = FALSE ; else use_box_blur = TRUE ; 
3342,<S2SV_StartBug> data -> l_head = NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> "
3343,"<S2SV_StartBug> if ( ssl_derive ( s , ckey , skey ) == 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> ckey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_INTERNAL_ERROR ) ; goto err ; } if ( "
3344,"<S2SV_StartBug> int transhdrlen , int mtu , unsigned int flags ) <S2SV_EndBug> <S2SV_StartBug> ipv6_select_ident ( & fhdr ) ; <S2SV_EndBug> ","<S2SV_ModStart> , struct rt6_info * rt <S2SV_ModStart> , rt "
3345,"<S2SV_StartBug> static int ion_handle_put ( struct ion_handle * handle ) <S2SV_EndBug> <S2SV_StartBug> ret = kref_put ( & handle -> ref , ion_handle_destroy ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ion_handle_put_nolock ( handle <S2SV_ModEnd> 
3346,"<S2SV_StartBug> WORD32 pu_skip_wd , pu_skip_ht ; <S2SV_EndBug> <S2SV_StartBug> ps_codec -> s_parse . i4_pic_pu_idx = i4_pic_pu_idx ; <S2SV_EndBug> <S2SV_StartBug> ps_codec -> s_parse . ps_tu ++ ; <S2SV_EndBug> <S2SV_StartBug> tu_t * ps_tu = ps_codec -> s_parse . ps_tu ; <S2SV_EndBug> ",<S2SV_ModStart> tu_coeff_data_reset_size ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ihevcd_set_ctb_skip ( ps_codec ) <S2SV_ModEnd> <S2SV_ModStart> ihevcd_set_ctb_skip ( ps_codec ) <S2SV_ModEnd> 
3347,<S2SV_StartBug> usleep ( 250000 ) ; <S2SV_EndBug> <S2SV_StartBug> usleep ( 250000 ) ; <S2SV_EndBug> ,<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
3348,"<S2SV_StartBug> int nmi , struct perf_sample_data * data , <S2SV_EndBug> <S2SV_StartBug> return perf_swevent_overflow ( event , 1 , nmi , data , regs ) ; <S2SV_EndBug> <S2SV_StartBug> perf_swevent_overflow ( event , 0 , nmi , data , regs ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3349,<S2SV_StartBug> return PTR_ERR ( tty ) ; <S2SV_EndBug> ,<S2SV_ModStart> tty_driver_kref_put ( driver ) ; 
3350,<S2SV_StartBug> convert_to_double_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> m1 [ i ] = Z_DVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_double_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> m2 [ i ] = Z_DVAL_PP ( tmp ) ; <S2SV_EndBug> ,<S2SV_ModStart> { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> <S2SV_ModStart> Z_DVAL ( dval ) ; } <S2SV_ModEnd> <S2SV_ModStart> { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> <S2SV_ModStart> Z_DVAL ( dval ) ; } <S2SV_ModEnd> 
3351,<S2SV_StartBug> int len ; <S2SV_EndBug> <S2SV_StartBug> len = ( int ) ( cp - ( ip_as_string + 1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len > ( int ) sizeof ( buf ) - 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3352,"<S2SV_StartBug> strcat ( line , buf ) ; <S2SV_EndBug> <S2SV_StartBug> strcat ( line , ""<S2SV_blank>"" ) ; <S2SV_EndBug> <S2SV_StartBug> line [ strlen ( line ) - 1 ] = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> strncat ( line , buf , sizeof line ) ; strncat <S2SV_ModEnd> <S2SV_ModStart> , sizeof line <S2SV_ModStart> ( sizeof <S2SV_ModEnd> <S2SV_ModStart> '\\0' ; line [ strlen ( line ) - 1 ] = "
3353,<S2SV_StartBug> drop_futex_key_refs ( & q -> key ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3354,<S2SV_StartBug> tread . event = SNDRV_TIMER_EVENT_EARLY ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & tread , 0 , sizeof ( tread ) ) ; "
3355,"<S2SV_StartBug> j = cJSON_CreateInt ( va_arg ( argp , int64_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> j = cJSON_CreateFloat ( va_arg ( argp , double ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> cJSON_CreateNumber <S2SV_ModEnd> <S2SV_ModStart> cJSON_CreateNumber <S2SV_ModEnd> 
3356,"<S2SV_StartBug> void options_free ( ) { <S2SV_EndBug> <S2SV_StartBug> parse_global_option ( CMD_FREE , NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int current ) { GLOBAL_OPTIONS * global = current ? & global_options : & new_global_options ; SERVICE_OPTIONS * service = current ? & service_options : & new_service_options ; <S2SV_ModEnd> <S2SV_ModStart> , global <S2SV_ModStart> CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_SECTIONS ] ) ; while ( service ) { SERVICE_OPTIONS * tmp = service ; service = service -> next ; tmp -> next = NULL ; service_free ( tmp ) ; } CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ; "
3357,"<S2SV_StartBug> ast_for_call ( struct compiling * c , const node * n , expr_ty func ) <S2SV_EndBug> <S2SV_StartBug> int i , nargs , nkeywords , ngens ; <S2SV_EndBug> <S2SV_StartBug> ngens = 0 ; <S2SV_EndBug> <S2SV_StartBug> ngens ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ngens > 1 || ( ngens && ( nargs || nkeywords ) ) ) { <S2SV_EndBug> ","<S2SV_ModStart> , bool allowgen <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { nargs ++ ; if ( ! allowgen ) { ast_error ( c , ch , ""invalid<S2SV_blank>syntax"" ) ; return NULL ; } if ( NCH ( n ) > 1 ) { ast_error ( c , ch , ""Generator<S2SV_blank>expression<S2SV_blank>must<S2SV_blank>be<S2SV_blank>parenthesized"" ) ; return NULL ; } } <S2SV_ModEnd> <S2SV_ModStart> args = _Ta3_asdl_seq_new ( nargs <S2SV_ModEnd> "
3358,<S2SV_StartBug> for ( k = passIC + 2 ; k < passIC + 2 + passInstructions [ passIC + 1 ] ; k ++ ) <S2SV_EndBug> ,<S2SV_ModStart> ( ( <S2SV_ModStart> ) && ( kk < input -> length ) ) 
3359,"<S2SV_StartBug> char combname [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( combname , L_BUF_SIZE , ""sel_comb_%dh"" , size ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( combname , L_BUF_SIZE , ""sel_comb_%dv"" , size ) ; <S2SV_EndBug> ",<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> 
3360,<S2SV_StartBug> idata -> state = IMAP_AUTHENTICATED ; <S2SV_EndBug> ,"<S2SV_ModStart> # if defined ( USE_SSL ) if ( ! idata -> conn -> ssf ) { if ( option ( OPTSSLFORCETLS ) || ( query_quadoption ( OPT_SSLSTARTTLS , _ ( ""Abort<S2SV_blank>unencrypted<S2SV_blank>PREAUTH<S2SV_blank>connection?"" ) ) != MUTT_NO ) ) { mutt_error _ ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ; mutt_sleep ( 1 ) ; goto err_close_conn ; } } # endif "
3361,"<S2SV_StartBug> return sprintf ( buf , ""%s\\n"" , pdev -> driver_override ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> ssize_t len ; device_lock ( dev ) ; len = <S2SV_ModEnd> <S2SV_ModStart> device_unlock ( dev ) ; return len ; 
3362,<S2SV_StartBug> cJSON * ref ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ref = cJSON_New_Item ( ) ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! ref ) <S2SV_ModEnd> 
3363,"<S2SV_StartBug> ext3_msg ( sb , ""error:<S2SV_blank>invalid<S2SV_blank>sb<S2SV_blank>specification:<S2SV_blank>%s"" , <S2SV_EndBug> ","<S2SV_ModStart> KERN_ERR , "
3364,"<S2SV_StartBug> fc . messages = mutt_mem_calloc ( last - first + 1 , sizeof ( unsigned char ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( fc . messages == NULL ) return - 1 
3365,<S2SV_StartBug> block_in_file = ( sector_t ) page -> index ; <S2SV_EndBug> <S2SV_StartBug> if ( ! PageUptodate ( page ) && ! cleancache_get_page ( page ) ) { <S2SV_EndBug> ,<S2SV_ModStart> page_index ( page ) <S2SV_ModEnd> <S2SV_ModStart> ( ! PageSwapCache ( page ) && <S2SV_ModStart> ) 
3366,"<S2SV_StartBug> vpx_memcpy ( cpi -> segment_feature_data , feature_data , sizeof ( cpi -> segment_feature_data ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> 
3367,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3368,"<S2SV_StartBug> if ( ( opt_len != mp_dss_len ( mdss , 1 ) && <S2SV_EndBug> <S2SV_StartBug> if ( mdss -> flags & MP_DSS_A ) { <S2SV_EndBug> <S2SV_StartBug> if ( mdss -> flags & MP_DSS_a ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( mdss -> flags & MP_DSS_m ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_16BITS ( opt ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len == mp_dss_len ( mdss , 1 ) ) <S2SV_EndBug> ","<S2SV_ModStart> opt_len < 4 ) return 0 ; if ( <S2SV_ModEnd> <S2SV_ModStart> opt_len -= 4 ; <S2SV_ModStart> if ( opt_len < 8 ) return 0 ; <S2SV_ModStart> opt_len -= 8 ; <S2SV_ModStart> if ( opt_len < 4 ) return 0 ; <S2SV_ModStart> opt_len -= 4 ; <S2SV_ModStart> if ( opt_len < 8 ) return 0 ; <S2SV_ModStart> opt_len -= 8 ; <S2SV_ModStart> if ( opt_len < 4 ) return 0 ; <S2SV_ModStart> opt_len -= 4 ; } if ( opt_len < 4 ) return 0 ; <S2SV_ModEnd> <S2SV_ModStart> opt_len -= 4 ; if ( opt_len < 2 ) return 0 ; <S2SV_ModStart> opt_len -= 2 ; if ( opt_len >= 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>csum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( opt ) ) ) ; opt_len -= 2 ; } } if ( opt_len != 0 ) return 0 ; return 1 <S2SV_ModEnd> "
3369,"<S2SV_StartBug> int hours , minutes , seconds ; <S2SV_EndBug> ",<S2SV_ModStart> int64_t <S2SV_ModEnd> 
3370,"<S2SV_StartBug> ( void ) & line ; <S2SV_EndBug> <S2SV_StartBug> if ( e >= b && ( size_t ) ( e - b ) <= CDF_SEC_SIZE ( h ) * sst -> sst_len ) <S2SV_EndBug> <S2SV_StartBug> CDF_SEC_SIZE ( h ) * sst -> sst_len , CDF_SEC_SIZE ( h ) , sst -> sst_len ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> size_t ss = sst -> sst_dirlen < h -> h_min_size_standard_stream ? CDF_SHORT_SEC_SIZE ( h ) : CDF_SEC_SIZE ( h ) ; <S2SV_ModStart> ss <S2SV_ModEnd> <S2SV_ModStart> ss <S2SV_ModEnd> <S2SV_ModStart> ss <S2SV_ModEnd> 
3371,<S2SV_StartBug> void fdct4_sse2 ( __m128i * in ) { <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug> ,<S2SV_ModStart> static <S2SV_ModStart> ( int16_t ) 
3372,<S2SV_StartBug> sbinfo -> max_blocks = config . nr_blocks ; <S2SV_EndBug> <S2SV_StartBug> sbinfo -> free_blocks = config . nr_blocks ; <S2SV_EndBug> <S2SV_StartBug> if ( ! inode ) <S2SV_EndBug> <S2SV_StartBug> root = d_alloc_root ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> kfree ( sbinfo ) ; <S2SV_EndBug> ,"<S2SV_ModStart> max_inodes = config . nr_inodes ; sbinfo -> free_inodes = config . nr_inodes ; sbinfo -> spool = NULL ; if ( <S2SV_ModEnd> <S2SV_ModStart> != - 1 ) { sbinfo -> spool = hugepage_new_subpool ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sbinfo -> spool <S2SV_ModEnd> <S2SV_ModStart> } sb -> s_maxbytes = MAX_LFS_FILESIZE ; sb -> s_blocksize = huge_page_size ( config . hstate ) ; sb -> s_blocksize_bits = huge_page_shift ( config . hstate ) ; sb -> s_magic = HUGETLBFS_MAGIC ; sb -> s_op = & hugetlbfs_ops ; sb -> s_time_gran = 1 ; inode = hugetlbfs_get_root ( sb , & config ) ; if ( ! inode ) goto out_free ; <S2SV_ModStart> if ( sbinfo -> spool ) kfree ( sbinfo -> spool ) ; "
3373,"
","
"
3374,"<S2SV_StartBug> status = enc624j600ReadReg ( interface , ENC624J600_REG_EIR ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_LINKIF ) ; <S2SV_EndBug> <S2SV_StartBug> value = enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) ; <S2SV_EndBug> <S2SV_StartBug> value = enc624j600ReadPhyReg ( interface , ENC624J600_PHY_REG_PHSTAT3 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( value & PHSTAT3_SPDDPX2 ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( status & EIR_PKTIF ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_PKTIF ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_EIE , EIE_LINKIE | EIE_PKTIE ) ; <S2SV_EndBug> ","<S2SV_ModStart> ENC624J600_EIR ) ; if ( ( status & ENC624J600_EIR_LINKIF <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EIR , ENC624J600_EIR_LINKIF <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ESTAT ) ; if ( ( value & ENC624J600_ESTAT_PHYLNK <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_PHSTAT3 ) ; if ( ( value & ENC624J600_PHSTAT3_SPDDPX1 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_PHSTAT3_SPDDPX2 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EIR_PKTIF <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EIR , ENC624J600_EIR_PKTIF <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EIE , ENC624J600_EIE_LINKIE | ENC624J600_EIE_PKTIE <S2SV_ModEnd> "
3375,<S2SV_StartBug> if ( ! esil ) <S2SV_EndBug> ,<S2SV_ModStart> { return ; } <S2SV_ModEnd> 
3376,"<S2SV_StartBug> int a = getnum ( L , fmt , MAXALIGN ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
3377,<S2SV_StartBug> int len ; <S2SV_EndBug> <S2SV_StartBug> len = ( int ) ( cp - ( ip_as_string + 1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len > ( int ) sizeof ( buf ) - 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3378,<S2SV_StartBug> addr -> addrtype = TIPC_ADDR_ID ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & addr -> addr , 0 , sizeof ( addr -> addr ) ) "
3379,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> break ; default : fastd_buffer_free ( buffer ) ; pr_debug ( ""received<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>invalid<S2SV_blank>type<S2SV_blank>from<S2SV_blank>%P[%I]"" , peer , remote_addr ) ; "
3380,"<S2SV_StartBug> assert_se ( touch_file ( path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) == 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> MODE_INVALID <S2SV_ModEnd> 
3381,<S2SV_StartBug> INST_HANDLER ( lds ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 4 ) { return ; } 
3382,<S2SV_StartBug> struct inet_sock * inet = inet_sk ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt && opt -> srr ) <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . <S2SV_ModEnd> "
3383,<S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> <S2SV_StartBug> * nbytes = le32_to_cpu ( rsp -> DataLength ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cifs_small_buf_release ( req ) ; 
3384,"<S2SV_StartBug> sdb_set ( s , ""DW_AT_comp_dir"" , name , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> if ( name > 1024 ) { <S2SV_ModStart> else { eprintf ( ""Invalid<S2SV_blank>string<S2SV_blank>pointer<S2SV_blank>at<S2SV_blank>%p\\n"" , name ) ; } } "
3385,"<S2SV_StartBug> char lbase [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char strbase [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char ltest [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char strtest [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> int nbase = sscanf ( lbase , ""%255[^\\r\\n]"" , strbase ) ; <S2SV_EndBug> <S2SV_StartBug> int ntest = sscanf ( ltest , ""%255[^\\r\\n]"" , strtest ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( nbase != 255 && ntest != 255 ) ; <S2SV_EndBug> ","<S2SV_ModStart> 512 <S2SV_ModEnd> <S2SV_ModStart> 512 <S2SV_ModEnd> <S2SV_ModStart> 512 <S2SV_ModEnd> <S2SV_ModStart> 512 <S2SV_ModEnd> <S2SV_ModStart> ""%511[^\\r\\n]"" <S2SV_ModEnd> <S2SV_ModStart> ""%511[^\\r\\n]"" <S2SV_ModEnd> <S2SV_ModStart> 511 <S2SV_ModEnd> <S2SV_ModStart> 511 <S2SV_ModEnd> "
3386,"<S2SV_StartBug> skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , <S2SV_EndBug> ",<S2SV_ModStart> msg -> msg_namelen = 0 ; 
3387,<S2SV_StartBug> if ( ( data & ~ mask ) != PSW_USER_BITS ) <S2SV_EndBug> ,<S2SV_ModStart> ^ PSW_USER_BITS ) <S2SV_ModStart> return - EINVAL ; if ( ( data & PSW_MASK_ASC ) == PSW_ASC_HOME <S2SV_ModEnd> 
3388,<S2SV_StartBug> struct net_device * dev = vif -> dev ; <S2SV_EndBug> <S2SV_StartBug> if ( netif_carrier_ok ( dev ) ) { <S2SV_EndBug> <S2SV_StartBug> xenvif_down ( vif ) ; <S2SV_EndBug> <S2SV_StartBug> rtnl_unlock ( ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vif -> <S2SV_ModEnd> <S2SV_ModStart> xenvif_carrier_off <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3389,<S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> ; xen_cpu_init_eoi ( cpu ) 
3390,<S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> abort ( ) <S2SV_ModEnd> 
3391,<S2SV_StartBug> struct IGDdatas * datas = ( struct IGDdatas * ) d ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( l >= MINIUPNPC_URL_MAXSIZE ) l = MINIUPNPC_URL_MAXSIZE - 1 
3392,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % ( 2 * stride ) ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horAcc16"" , ""%s"" , ""cc%(2*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; "
3393,<S2SV_StartBug> if ( filter [ i ] . jf ) <S2SV_EndBug> <S2SV_StartBug> t_offset += is_near ( f_offset ) ? 2 : 6 ; <S2SV_EndBug> ,<S2SV_ModStart> && f_offset <S2SV_ModStart> 5 <S2SV_ModEnd> 
3394,<S2SV_StartBug> int err = - EIO ; <S2SV_EndBug> <S2SV_StartBug> uint32_t pos ; <S2SV_EndBug> <S2SV_StartBug> if ( ! bh ) <S2SV_EndBug> <S2SV_StartBug> out : <S2SV_EndBug> <S2SV_StartBug> kunmap ( page ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( inode -> i_size > inode -> i_sb -> s_blocksize ) { err = - ENAMETOOLONG ; goto out_unmap ; } <S2SV_ModStart> { err = - EIO ; goto out_unlock_inode ; } <S2SV_ModEnd> <S2SV_ModStart> out_unlock_inode <S2SV_ModEnd> <S2SV_ModStart> out_unmap : 
3395,<S2SV_StartBug> io -> io_cleanup = port_cleanup ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> io -> io_cleanup = port_cleanup ; 
3396,"<S2SV_StartBug> assert ( ( size_t ) CDF_SHORT_SEC_SIZE ( h ) == len ) ; <S2SV_EndBug> <S2SV_StartBug> ( ( const char * ) sst -> sst_tab ) + CDF_SHORT_SEC_POS ( h , id ) , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t ss = <S2SV_ModEnd> <S2SV_ModStart> ; size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss <S2SV_ModStart> if ( sst -> sst_len < ( size_t ) id ) { DPRINTF ( ( ""bad<S2SV_blank>sector<S2SV_blank>id<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\\n"" , id , sst -> sst_len ) ) ; return - 1 ; } <S2SV_ModStart> pos <S2SV_ModEnd> "
3397,"<S2SV_StartBug> if ( ! io_end || ! size ) <S2SV_EndBug> <S2SV_StartBug> wq = EXT4_SB ( io_end -> inode -> i_sb ) -> dio_unwritten_wq ; <S2SV_EndBug> <S2SV_StartBug> list_add_tail ( & io_end -> list , <S2SV_EndBug> <S2SV_StartBug> & EXT4_I ( io_end -> inode ) -> i_completed_io_list ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned long flags ; struct ext4_inode_info * ei ; <S2SV_ModStart> io_end -> flag = EXT4_IO_UNWRITTEN ; <S2SV_ModStart> ei = EXT4_I ( io_end -> inode ) ; spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModStart> & ei -> i_completed_io_list ) ; spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags <S2SV_ModEnd> "
3398,"<S2SV_StartBug> err = aead_register_instance ( tmpl , inst ) ; <S2SV_EndBug> ",<S2SV_ModStart> inst -> free = pcrypt_free ; 
3399,"<S2SV_StartBug> if ( srp -> bio ) <S2SV_EndBug> <S2SV_StartBug> blk_end_request_all ( srp -> rq , - EIO ) ; <S2SV_EndBug> ",<S2SV_ModStart> { if ( srp -> rq -> cmd != srp -> rq -> __cmd ) kfree ( srp -> rq -> cmd ) ; <S2SV_ModStart> srp -> rq = NULL ; } 
3400,<S2SV_StartBug> if ( ! rc && cifs_sb -> prepathlen && tcon ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3401,"<S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> != c ) break 
3402,"<S2SV_StartBug> authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT , 0664 ) ; <S2SV_EndBug> <S2SV_StartBug> return retval ; <S2SV_EndBug> ",<S2SV_ModStart> | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY <S2SV_ModStart> if ( cfg -> is_custom_debug_file ) { fclose ( cfg -> debug_file ) ; } 
3403,"<S2SV_StartBug> static void nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 originalSize ) <S2SV_EndBug> <S2SV_StartBug> * out ++ = value ; <S2SV_EndBug> <S2SV_StartBug> FillMemory ( out , len , value ) ; <S2SV_EndBug> <S2SV_StartBug> * out ++ = value ; <S2SV_EndBug> ","<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> , UINT32 outSize <S2SV_ModStart> if ( outSize < 1 ) return FALSE ; outSize -- ; <S2SV_ModStart> if ( outSize < len ) return FALSE ; outSize -= len ; <S2SV_ModStart> if ( outSize < 1 ) return FALSE ; outSize -- ; * out ++ = value ; left -- ; } } if ( ( outSize < 4 ) || ( left < 4 ) ) return FALSE ; memcpy ( out , in , 4 ) ; return TRUE <S2SV_ModEnd> "
3404,"<S2SV_StartBug> static void InsertRow ( Image * image , ssize_t depth , unsigned char * p , ssize_t y , <S2SV_EndBug> <S2SV_StartBug> size_t bit ; ssize_t x ; <S2SV_EndBug> <S2SV_StartBug> register Quantum * q ; <S2SV_EndBug> <S2SV_StartBug> switch ( depth ) <S2SV_EndBug> <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ; <S2SV_EndBug> <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) <S2SV_EndBug> <S2SV_StartBug> index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ; <S2SV_EndBug> <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) SyncAuthenticPixels ( image , exception ) ; <S2SV_EndBug> <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> if ( q == ( Quantum * ) NULL ) <S2SV_EndBug> <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ; <S2SV_EndBug> <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> p ++ ; <S2SV_EndBug> <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> if ( q == ( Quantum * ) NULL ) <S2SV_EndBug> <S2SV_StartBug> index = ConstrainColormapIndex ( image , * p , exception ) ; <S2SV_EndBug> ","<S2SV_ModStart> MagickBooleanType <S2SV_ModEnd> <S2SV_ModStart> bpp <S2SV_ModEnd> <S2SV_ModStart> int bit ; Quantum index <S2SV_ModEnd> <S2SV_ModStart> * q ; ssize_t x ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) return ( MagickFalse ) <S2SV_ModEnd> <S2SV_ModStart> bpp <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> ssize_t ) ( <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> for ( x = 0 ; x < ( ( ssize_t ) <S2SV_ModEnd> <S2SV_ModStart> - 3 ) ; x += 4 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 <S2SV_ModEnd> <S2SV_ModStart> SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } break ; } case 4 : { <S2SV_ModEnd> <S2SV_ModStart> 4 ) & 0x0f <S2SV_ModEnd> <S2SV_ModStart> if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> ) & 0x0f <S2SV_ModEnd> <S2SV_ModStart> if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 0x0f <S2SV_ModEnd> <S2SV_ModStart> if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; <S2SV_ModStart> } <S2SV_ModEnd> <S2SV_ModStart> for ( x = 0 ; x < ( ssize_t ) <S2SV_ModEnd> <S2SV_ModStart> ; x ++ ) { index = ConstrainColormapIndex ( image , * p <S2SV_ModEnd> <S2SV_ModStart> SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } } break ; case 24 : <S2SV_ModEnd> <S2SV_ModStart> SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } if ( ! SyncAuthenticPixels ( image <S2SV_ModEnd> <S2SV_ModStart> ) return ( MagickFalse ) ; return ( MagickTrue ) ; <S2SV_ModEnd> "
3405,"<S2SV_StartBug> rc = - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) <S2SV_EndBug> <S2SV_StartBug> ipxitf_put ( ipxif ) ; <S2SV_EndBug> ","<S2SV_ModStart> 0 ; if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) rc = <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3406,<S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> < <S2SV_ModEnd> 
3407,<S2SV_StartBug> struct dentry * upper = ovl_dentry_upper ( dentry ) ; <S2SV_EndBug> <S2SV_StartBug> err = - ESTALE ; <S2SV_EndBug> <S2SV_StartBug> if ( upper -> d_parent == upperdir ) { <S2SV_EndBug> <S2SV_StartBug> dput ( upper ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> inode_unlock ( dir ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> upper = lookup_one_len ( dentry -> d_name . name , upperdir , dentry -> d_name . len ) ; err = PTR_ERR ( upper ) ; if ( IS_ERR ( upper ) ) goto out_unlock ; <S2SV_ModStart> == ovl_dentry_upper ( dentry ) ) { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dput ( upper ) ; <S2SV_ModStart> out_unlock : "
3408,<S2SV_StartBug> ctx = d -> log_ctx ; <S2SV_EndBug> ,<S2SV_ModStart> d -> log_file = eventfp ; 
3409,"<S2SV_StartBug> int udf_get_filename ( struct super_block * sb , uint8_t * sname , uint8_t * dname , <S2SV_EndBug> <S2SV_StartBug> int flen ) <S2SV_EndBug> <S2SV_StartBug> if ( udf_build_ustr_exact ( unifilename , sname , flen ) ) <S2SV_EndBug> <S2SV_StartBug> len = udf_translate_to_linux ( dname , filename -> u_name , filename -> u_len , <S2SV_EndBug> ","<S2SV_ModStart> int slen , <S2SV_ModStart> int dlen <S2SV_ModEnd> <S2SV_ModStart> slen <S2SV_ModEnd> <S2SV_ModStart> dlen , "
3410,<S2SV_StartBug> if ( transhdrlen ) { <S2SV_EndBug> <S2SV_StartBug> copy = datalen - transhdrlen - fraggap ; <S2SV_EndBug> ,"<S2SV_ModStart> copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; goto error ; } <S2SV_ModStart> if ( copy > 0 && getfrag ( from , data + transhdrlen <S2SV_ModEnd> "
3411,<S2SV_StartBug> unsigned int doffset = head_skb -> data - skb_mac_header ( head_skb ) ; <S2SV_EndBug> <S2SV_StartBug> pos += skb_headlen ( list_skb ) ; <S2SV_EndBug> <S2SV_StartBug> BUG_ON ( ! nfrags ) ; <S2SV_EndBug> <S2SV_StartBug> * nskb_frag = * frag ; <S2SV_EndBug> ,"<S2SV_ModStart> ; struct sk_buff * frag_skb = head_skb <S2SV_ModStart> frag_skb = list_skb ; <S2SV_ModStart> frag_skb = list_skb ; <S2SV_ModStart> if ( unlikely ( skb_orphan_frags ( frag_skb , GFP_ATOMIC ) ) ) goto err ; "
3412,<S2SV_StartBug> return in ; <S2SV_EndBug> ,<S2SV_ModStart> NULL <S2SV_ModEnd> 
3413,<S2SV_StartBug> if ( new_fs ) { <S2SV_EndBug> ,<S2SV_ModStart> new_ns -> mounts ++ ; 
3414,<S2SV_StartBug> gdFree ( tmp_im ) ; <S2SV_EndBug> ,<S2SV_ModStart> gdImageDestroy <S2SV_ModEnd> 
3415,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
3416,<S2SV_StartBug> if ( ! ( opt_len == 12 && flags & TH_SYN ) && <S2SV_EndBug> <S2SV_StartBug> ! ( opt_len == 24 && flags & TH_ACK ) ) <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) <S2SV_ModStart> ( <S2SV_ModStart> ) 
3417,"<S2SV_StartBug> ngx_int_t rc ; <S2SV_EndBug> <S2SV_StartBug> size_t size ; <S2SV_EndBug> <S2SV_StartBug> rc = ngx_http_lua_set_content_length_header ( sr , <S2SV_EndBug> <S2SV_StartBug> rc = ngx_http_lua_set_content_length_header ( sr , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> # if 1 <S2SV_EndBug> <S2SV_StartBug> if ( ngx_http_lua_copy_request_headers ( sr , r ) != NGX_OK ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int pr_not_chunked = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sr -> request_body = NULL ; } else { if ( ! r -> headers_in . chunked ) { pr_not_chunked = 1 ; } if ( sr -> request_body && sr -> request_body -> temp_file ) { if ( ngx_http_lua_copy_in_file_request_body ( sr ) <S2SV_ModEnd> <S2SV_ModStart> } } <S2SV_ModEnd> <S2SV_ModStart> , pr_not_chunked <S2SV_ModStart>  <S2SV_ModEnd> "
3418,"<S2SV_StartBug> ( void ) SetImageColorspace ( image , GRAYColorspace ) ; <S2SV_EndBug> ","<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
3419,<S2SV_StartBug> tcp_init_send_head ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> icsk -> icsk_ack . rcv_mss = TCP_MIN_MSS ; 
3420,"<S2SV_StartBug> for ( i = 0 ; i < count && strlen ( op -> txt ) + 10 < R_ASM_BUFSIZE ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> int optxtlen = strlen ( op -> txt ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d"" , def ) ; <S2SV_EndBug> ","<S2SV_ModStart> char * txt = op -> txt ; int txtLen = strlen ( op -> txt ) ; int txtLeft = R_ASM_BUFSIZE - txtLen ; txt += txtLen ; <S2SV_ModStart> txtLen <S2SV_ModEnd> <S2SV_ModStart> snprintf ( txt , txtLeft <S2SV_ModEnd> <S2SV_ModStart> txtLen = strlen ( txt ) ; txt += txtLen ; txtLeft -= txtLen ; <S2SV_ModStart> txt , txtLeft - 1 <S2SV_ModEnd> "
3421,"<S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
3422,"
","
"
3423,<S2SV_StartBug> int64_t i = 0 ; <S2SV_EndBug> <S2SV_StartBug> int isint = 1 ; <S2SV_EndBug> <S2SV_StartBug> f = ( f * 10.0 ) + ( * num - '0' ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( * num >= '0' && * num <= '9' ) ; <S2SV_EndBug> <S2SV_StartBug> isint = 0 ; <S2SV_EndBug> <S2SV_StartBug> ++ num ; <S2SV_EndBug> <S2SV_StartBug> else if ( * num == '-' ) { <S2SV_EndBug> <S2SV_StartBug> signsubscale = - 1 ; <S2SV_EndBug> <S2SV_StartBug> i = sign * i ; <S2SV_EndBug> <S2SV_StartBug> item -> valueint = i ; <S2SV_EndBug> ,"<S2SV_ModStart> double n = 0 , sign = 1 , scale <S2SV_ModEnd> <S2SV_ModStart> subscale = 0 , signsubscale = 1 ; if ( * num == '-' ) sign = - 1 , num ++ ; if ( * num == '0' ) num ++ ; if ( * num >= '1' && * num <= '9' ) do n = ( n * 10.0 ) + ( * num ++ - '0' ) ; while ( * num >= '0' && * num <= '9' ) ; if ( * num == '.' && num [ 1 ] >= '0' && num [ 1 ] <= '9' ) { num ++ ; do n = ( n <S2SV_ModEnd> <S2SV_ModStart> ++ - '0' ) , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> num ++ ; <S2SV_ModEnd> <S2SV_ModStart> num ++ ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , num ++ ; while ( * num >= '0' && * num <= '9' ) subscale = ( subscale * 10 ) + ( * num ++ - '0' ) ; } n <S2SV_ModEnd> <S2SV_ModStart> n * pow ( 10.0 , ( scale + subscale * signsubscale ) ) ; item -> valuedouble = n <S2SV_ModEnd> <S2SV_ModStart> ( int64_t ) n ; <S2SV_ModEnd> "
3424,<S2SV_StartBug> mutex_init ( & tu -> tread_sem ) ; <S2SV_EndBug> ,<S2SV_ModStart> ioctl_lock <S2SV_ModEnd> 
3425,"<S2SV_StartBug> vpx_memcpy ( & cpi -> common . lfc , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memmove ( dp , cpi -> partition_d [ i + 1 ] , cpi -> partition_sz [ i + 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> pack_tokens ( & cpi -> bc [ 1 ] , cpi -> tok , cpi -> tok_count ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memmove <S2SV_ModEnd> <S2SV_ModStart> vp8_pack_tokens <S2SV_ModEnd> 
3426,<S2SV_StartBug> * d ++ = from_hex ( s [ 1 ] ) << 4 | from_hex ( s [ 2 ] ) ; <S2SV_EndBug> ,<S2SV_ModStart> char t <S2SV_ModEnd> <S2SV_ModStart> ) ; * d ++ = ( char ) ( ( isprint ( t ) ) ? t : '<S2SV_blank>' 
3427,<S2SV_StartBug> value = ( unsigned int ) ( ( buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) | <S2SV_EndBug> <S2SV_StartBug> ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned int ) ( value & 0xffffffff ) ) ; <S2SV_EndBug> <S2SV_StartBug> value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ) | ( buffer [ 1 ] << 16 ) | <S2SV_EndBug> <S2SV_StartBug> ( buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned int ) ( value & 0xffffffff ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3428,<S2SV_StartBug> i ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { clear_bit ( WDM_OVERFLOW , & desc -> flags ) ; rv = - ENOBUFS ; goto err ; } "
3429,"<S2SV_StartBug> int n , length ; <S2SV_EndBug> <S2SV_StartBug> struct l2tp_dict_attr_t * da ; <S2SV_EndBug> <S2SV_StartBug> struct l2tp_attr_t * attr , * RV = NULL ; <S2SV_EndBug> <S2SV_StartBug> socklen_t len = sizeof ( addr ) ; <S2SV_EndBug> <S2SV_StartBug> struct msghdr msg ; <S2SV_EndBug> <S2SV_StartBug> struct cmsghdr * cmsg ; <S2SV_EndBug> <S2SV_StartBug> msg . msg_controllen = 128 ; <S2SV_EndBug> <S2SV_StartBug> n = recvfrom ( fd , buf , L2TP_MAX_PACKET_SIZE , 0 , & addr , & len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( n < 6 ) { <S2SV_EndBug> <S2SV_StartBug> if ( hdr -> T == 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( n < ntohs ( hdr -> length ) ) { <S2SV_EndBug> <S2SV_StartBug> log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>(%i/%i)\\n"" , n , ntohs ( hdr -> length ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( hdr -> ver == 2 ) { <S2SV_EndBug> <S2SV_StartBug> log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(L=0)\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( avp -> length > length ) { <S2SV_EndBug> <S2SV_StartBug> if ( conf_verbose ) <S2SV_EndBug> <S2SV_StartBug> log_warn ( ""l2tp:<S2SV_blank>unknown<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>M=%u)\\n"" , ntohs ( avp -> type ) , avp -> M ) ; <S2SV_EndBug> <S2SV_StartBug> if ( da -> M != - 1 && da -> M != avp -> M ) { <S2SV_EndBug> <S2SV_StartBug> if ( da -> H != - 1 && da -> H != avp -> H ) { <S2SV_EndBug> <S2SV_StartBug> if ( avp -> H ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> orig_avp_len = avp -> length ; <S2SV_EndBug> <S2SV_StartBug> attr -> attr = da ; <S2SV_EndBug> <S2SV_StartBug> attr -> M = avp -> M ; <S2SV_EndBug> <S2SV_StartBug> attr -> length = orig_avp_len - sizeof ( * avp ) ; <S2SV_EndBug> <S2SV_StartBug> ptr += avp -> length ; <S2SV_EndBug> <S2SV_StartBug> length -= avp -> length ; <S2SV_EndBug> ","<S2SV_ModStart> struct l2tp_packet_t * pack <S2SV_ModEnd> <S2SV_ModStart> l2tp_attr_t * <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> addr_len ; uint16_t orig_avp_len ; void * orig_avp_val ; uint8_t * buf , * ptr ; int n , length ; * p = NULL ; if ( pkt_info ) { <S2SV_ModEnd> <S2SV_ModStart> ; struct cmsghdr * cmsg <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sizeof ( msg_control ) <S2SV_ModEnd> <S2SV_ModStart> addr_len = sizeof ( addr ) ; <S2SV_ModStart> addr_len <S2SV_ModEnd> <S2SV_ModStart> sizeof ( * hdr ) <S2SV_ModEnd> <S2SV_ModStart> hdr -> flags = ntohs ( hdr -> flags ) ; if ( ! ( hdr -> flags & L2TP_FLAG_T ) <S2SV_ModEnd> <S2SV_ModStart> if ( ! ( hdr -> flags & L2TP_FLAG_L ) ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>control<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(L=0)\\n"" ) ; goto out_err_hdr ; } if ( ! ( hdr -> flags & L2TP_FLAG_S ) ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>control<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(S=0)\\n"" ) ; goto out_err_hdr ; } switch ( hdr -> flags & L2TP_VER_MASK ) { case 2 : if ( hdr -> flags & L2TP_FLAG_O ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>control<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(O=1)\\n"" ) ; goto out_err_hdr ; } break ; case 3 : break ; default : if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>%i<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n"" , hdr -> flags & L2TP_VER_MASK ) ; goto out_err_hdr ; } length = ntohs ( hdr -> length ) ; if ( length < sizeof ( * hdr ) ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>(%i/%zu)\\n"" , length , sizeof ( * hdr ) ) ; goto out_err_hdr ; } else <S2SV_ModStart> length ) <S2SV_ModEnd> <S2SV_ModStart> length ) <S2SV_ModEnd> <S2SV_ModStart> pack = mempool_alloc ( pack_pool ) ; if ( ! pack ) { log_emerg ( ""l2tp:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" ) ; goto out_err_hdr ; } memset ( pack , 0 , sizeof ( * pack ) ) ; INIT_LIST_HEAD ( & pack -> attrs ) ; memcpy ( & pack -> addr , & addr , sizeof ( addr ) ) ; memcpy ( & pack -> hdr , hdr , sizeof ( * hdr ) ) ; length -= sizeof ( * hdr ) ; while ( length > 0 ) { struct l2tp_dict_attr_t * da ; struct l2tp_attr_t * attr ; uint16_t avp_len ; if ( length < sizeof ( * avp ) <S2SV_ModEnd> <S2SV_ModStart> ""l2tp:<S2SV_blank>short<S2SV_blank>avp<S2SV_blank>received\\n"" ) ; goto out_err ; } <S2SV_ModEnd> <S2SV_ModStart> avp -> flags = ntohs ( avp -> flags ) ; avp_len = avp -> flags & L2TP_AVP_LEN_MASK ; if ( avp_len < sizeof ( * avp ) ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>avp<S2SV_blank>received\\n"" ) ; goto out_err ; } else if ( length < avp_len <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> ! ! ( avp -> flags & L2TP_AVP_FLAG_M ) ) ; } if ( ( avp -> flags & L2TP_AVP_FLAG_M ) <S2SV_ModEnd> <S2SV_ModStart> ! <S2SV_ModStart> ! ( avp -> flags & L2TP_AVP_FLAG_M ) ) { if ( conf_verbose ) { log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>M=%i,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%i)\\n"" , ntohs ( avp -> type ) , ! ! ( avp -> flags & L2TP_AVP_FLAG_M ) , da <S2SV_ModEnd> <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_ModStart> ! <S2SV_ModStart> ! ( avp -> flags & L2TP_AVP_FLAG_H ) ) { if ( conf_verbose ) { log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>H=%i,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%i)\\n"" , ntohs ( avp -> type ) , ! ! ( avp -> flags & L2TP_AVP_FLAG_H ) , da <S2SV_ModEnd> <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_ModStart> flags & L2TP_AVP_FLAG_H <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> avp_len <S2SV_ModEnd> <S2SV_ModStart> = mempool_alloc ( attr_pool ) ; memset ( attr , 0 , sizeof ( * attr ) ) ; attr <S2SV_ModStart> ! ! ( avp -> flags & L2TP_AVP_FLAG_M ) <S2SV_ModEnd> <S2SV_ModStart> ) ; list_add_tail ( & attr -> entry , & pack -> attrs <S2SV_ModStart> avp_len <S2SV_ModEnd> <S2SV_ModStart> avp_len <S2SV_ModEnd> "
3430,<S2SV_StartBug> port -> exists = false ; <S2SV_EndBug> <S2SV_StartBug> port -> serio = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> spin_lock_irq ( & i8042_lock ) ; <S2SV_ModStart> ; port -> serio = NULL ; spin_unlock_irq ( & i8042_lock ) <S2SV_ModStart>  <S2SV_ModEnd> 
3431,"<S2SV_StartBug> ret = security_file_permission ( file , MAY_READ ) ; <S2SV_EndBug> <S2SV_StartBug> ret = security_file_permission ( file , MAY_WRITE ) ; <S2SV_EndBug> <S2SV_StartBug> ret = security_file_permission ( file , MAY_READ ) ; <S2SV_EndBug> <S2SV_StartBug> ret = security_file_permission ( file , MAY_WRITE ) ; <S2SV_EndBug> ","<S2SV_ModStart> aio_setup_single_vector ( READ , file , <S2SV_ModEnd> <S2SV_ModStart> aio_setup_single_vector ( WRITE , file , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3432,<S2SV_StartBug> register const u_char * ep ; <S2SV_EndBug> <S2SV_StartBug> register const struct pim * pim = ( const struct pim * ) bp ; <S2SV_EndBug> <S2SV_StartBug> switch ( PIM_VER ( pim -> pim_typever ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( pim -> pim_typever ) ; <S2SV_ModStart> trunc : ND_PRINT ( ( ndo , ""[|pim]"" ) ) ; return ; "
3433,"<S2SV_StartBug> static int shash_no_setkey ( struct crypto_shash * tfm , const u8 * key , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
3434,"<S2SV_StartBug> char * p ; <S2SV_EndBug> <S2SV_StartBug> p = memchr ( str + 1 , ']' , str_len - 2 ) ; <S2SV_EndBug> <S2SV_StartBug> * portno = atoi ( p + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> * portno = atoi ( colon + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> return host ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> char * <S2SV_ModStart> , * e = NULL <S2SV_ModStart> strtol <S2SV_ModEnd> <S2SV_ModStart> , & e , 10 ) ; if ( e && * e ) { if ( get_err ) { * err = strpprintf ( 0 , ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>address<S2SV_blank>\\""%s\\"""" , str ) ; } return NULL ; } <S2SV_ModEnd> <S2SV_ModStart> char * e = NULL ; <S2SV_ModStart> strtol ( colon + 1 , & e , 10 ) ; if ( ! e || ! * e ) { return <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3435,"<S2SV_StartBug> ""truncated<S2SV_blank>dump<S2SV_blank>file;<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>read<S2SV_blank>%"" PRIsize ""<S2SV_blank>bytes,<S2SV_blank>only<S2SV_blank>got<S2SV_blank>%"" PRIsize , <S2SV_EndBug> ","<S2SV_ModStart> ""truncated<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file;<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>read<S2SV_blank>%"" <S2SV_ModEnd> "
3436,<S2SV_StartBug> if ( count < sizeof hdr ) <S2SV_EndBug> ,<S2SV_ModStart> WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ; if ( 
3437,"<S2SV_StartBug> file = fopen ( ""/tmp/keepalived.json"" , ""w"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> fopen_safe <S2SV_ModEnd> 
3438,"<S2SV_StartBug> ret = perf_output_begin ( & handle , event , read_event . header . size , 0 , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
3439,"<S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
3440,<S2SV_StartBug> iocb -> private = ext4_init_io_end ( inode ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , GFP_NOFS "
3441,"<S2SV_StartBug> gdImagePtr pim = 0 , tim = im ; <S2SV_EndBug> <S2SV_StartBug> pim = gdImageCreatePaletteFromTrueColor ( im , 1 , 256 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> _gdImageGifCtx <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3442,<S2SV_StartBug> if ( map_data ) <S2SV_EndBug> <S2SV_StartBug> rq -> bio = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ! iter_is_iovec ( iter ) ) goto fail ; if ( <S2SV_ModStart> fail : 
3443,<S2SV_StartBug> is_kvmppc_hv_enabled ( kvm ) ; <S2SV_EndBug> ,<S2SV_ModStart> hv_enabled <S2SV_ModEnd> 
3444,"<S2SV_StartBug> char group [ LONG_STRING ] ; <S2SV_EndBug> <S2SV_StartBug> if ( sscanf ( line , ""%s<S2SV_blank>"" ANUM ""<S2SV_blank>"" ANUM ""<S2SV_blank>%c<S2SV_blank>%[^\\n]"" , group , & last , & first , & mod , desc ) < 4 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> = """" <S2SV_ModStart> ""%1023s<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank>%c<S2SV_blank>%8191[^\\n]"" <S2SV_ModEnd> <S2SV_ModStart> { mutt_debug ( 4 , ""Cannot<S2SV_blank>parse<S2SV_blank>server<S2SV_blank>line:<S2SV_blank>%s\\n"" , line ) ; <S2SV_ModStart> } "
3445,"<S2SV_StartBug> AcquireNextImage ( image_info , image ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; "
3446,<S2SV_StartBug> if ( index > MAX_SUPPORTED_TV_TIMING ) <S2SV_EndBug> <S2SV_StartBug> if ( index > MAX_SUPPORTED_TV_TIMING_V1_2 ) <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> <S2SV_ModStart> >= <S2SV_ModEnd> 
3447,"<S2SV_StartBug> actd = ( vp8_variance16x16 ( yd , yd_stride , VP8_ZEROS , 0 , & sse ) + 128 ) >> 8 ; <S2SV_EndBug> <S2SV_StartBug> act = ( vp8_variance16x16 ( y , y_stride , VP8_ZEROS , 0 , & sse ) + 128 ) >> 8 ; <S2SV_EndBug> <S2SV_StartBug> sad = ( vp8_variance16x16 ( y , y_stride , yd , yd_stride , & sse ) ) ; <S2SV_EndBug> <S2SV_StartBug> vsad = ( vp8_variance8x8 ( v , uv_stride , vd , uvd_stride , & sse ) ) ; <S2SV_EndBug> <S2SV_StartBug> act = ( vp8_variance8x8 ( y , y_stride , VP8_ZEROS , 0 , & sse ) + 32 ) >> 6 ; <S2SV_EndBug> <S2SV_StartBug> sad = ( vp8_variance8x8 ( y , y_stride , yd , yd_stride , & sse ) ) ; <S2SV_EndBug> <S2SV_StartBug> usad = ( vp8_variance4x4 ( u , uv_stride , ud , uvd_stride , & sse ) ) ; <S2SV_EndBug> <S2SV_StartBug> vsad = ( vp8_variance4x4 ( v , uv_stride , vd , uvd_stride , & sse ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( udp , up , uvblksize ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( vdp , vp , uvblksize ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_variance16x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance16x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance16x16 ( y , y_stride , yd , yd_stride , & sse ) ; <S2SV_ModStart> sse + 128 ) >> 8 ; vpx_variance8x8 ( u , uv_stride , ud , uvd_stride , & sse ) ; usad = ( sse + 32 ) >> 6 ; vpx_variance8x8 ( v , uv_stride , vd , uvd_stride , & sse ) ; vsad = ( sse + 32 ) >> 6 ; # else sad = ( vpx_sad16x16 <S2SV_ModEnd> <S2SV_ModStart> ) + 128 ) >> 8 ; usad = ( vpx_sad8x8 ( u , uv_stride , ud , uvd_stride ) + 32 ) >> 6 ; vsad = ( vpx_sad8x8 ( v , uv_stride , vd , uvd_stride ) + 32 ) >> 6 ; # endif } else { actd = ( vpx_variance8x8 ( yd , yd_stride , VP8_ZEROS , 0 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_variance8x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance8x8 ( y , y_stride , yd , yd_stride , & sse ) ; <S2SV_ModStart> sse + 32 ) >> 6 ; vpx_variance4x4 ( u , uv_stride , ud , uvd_stride , & sse ) ; usad = ( sse + 8 ) >> 4 ; vpx_variance4x4 ( v , uv_stride , vd , uvd_stride , & sse ) ; vsad = ( sse + 8 ) >> 4 ; # else sad = ( vpx_sad8x8 <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> vpx_sad4x4 <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> vpx_sad4x4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> "
3448,<S2SV_StartBug> PRIMARY_DRAWING_ORDER_FIELD_BYTES [ orderInfo -> orderType ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> get_primary_drawing_order_field_bytes ( <S2SV_ModEnd> <S2SV_ModStart> , NULL ) <S2SV_ModEnd> "
3449,<S2SV_StartBug> return err ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree_skb ( skb ) ; return err ; } <S2SV_ModEnd> 
3450,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3451,<S2SV_StartBug> char temp [ 500 ] ; <S2SV_EndBug> <S2SV_StartBug> temp [ i ] = fgetc ( fp ) ; <S2SV_EndBug> ,"<S2SV_ModStart> int temp_size = 500 ; char * temp = malloc ( temp_size ) <S2SV_ModEnd> <S2SV_ModStart> if ( i >= temp_size ) { temp_size *= 2 ; temp = realloc ( temp , temp_size ) ; } "
3452,"<S2SV_StartBug> encode_share_access ( xdr , arg -> open_flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode <S2SV_ModEnd> 
3453,<S2SV_StartBug> av_freep ( & h -> DPB ) ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( h -> delayed_pic , 0 , sizeof ( h -> delayed_pic ) ) ; "
3454,<S2SV_StartBug> timr -> it_overrun += ( unsigned int ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3455,"<S2SV_StartBug> err = scm_send ( sock , msg , siocb -> scm ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false "
3456,<S2SV_StartBug> sctp_auth_key_put ( asoc -> asoc_shared_key ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3457,<S2SV_StartBug> return dcfg ; <S2SV_EndBug> ,<S2SV_ModStart> dcfg -> xml_external_entity = NOT_SET ; 
3458,"<S2SV_StartBug> pdf = calloc ( 1 , sizeof ( pdf_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> pdf -> name = malloc ( strlen ( n ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> pdf -> name = malloc ( strlen ( ""Unknown"" ) + 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> safe_calloc ( <S2SV_ModEnd> <S2SV_ModStart> safe_calloc <S2SV_ModEnd> <S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
3459,<S2SV_StartBug> if ( * off >= skb -> len ) { <S2SV_EndBug> ,<S2SV_ModStart> && skb -> len 
3460,"<S2SV_StartBug> size2 , mime ) ; <S2SV_EndBug> ",<S2SV_ModStart> NULL <S2SV_ModEnd> 
3461,<S2SV_StartBug> r -> rtm_flags |= RTM_F_NOTIFY ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT ) r -> rtm_flags |= RTCF_DOREDIRECT 
3462,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> _TIFFfree ( working_copy ) ; 
3463,<S2SV_StartBug> if ( indev != NULL ) { <S2SV_EndBug> ,<S2SV_ModStart> && indev -> ifa_list <S2SV_ModEnd> 
3464,"<S2SV_StartBug> truncate_pagecache ( inode , inode -> i_size ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_truncate ( inode ) ; <S2SV_EndBug> ",<S2SV_ModStart> down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem 
3465,"<S2SV_StartBug> int procfd ; <S2SV_EndBug> <S2SV_StartBug> pid_t to_cleanup_pid = pid ; <S2SV_EndBug> <S2SV_StartBug> status = 0 ; <S2SV_EndBug> <S2SV_StartBug> ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret != 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( options -> stdin_fd == 0 ) { <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" ) ; <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(2)"" ) ; <S2SV_EndBug> <S2SV_StartBug> shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; <S2SV_EndBug> <S2SV_StartBug> cleanup_error : <S2SV_EndBug> <S2SV_StartBug> procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY ) ; <S2SV_EndBug> <S2SV_StartBug> . procfd = procfd <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int procfd = - 1 ; <S2SV_ModStart> procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY | O_CLOEXEC ) ; if ( procfd < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc."" <S2SV_ModEnd> <S2SV_ModStart> status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status <S2SV_ModEnd> <S2SV_ModStart> status ) <S2SV_ModEnd> <S2SV_ModStart> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" <S2SV_ModEnd> <S2SV_ModStart> ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process"" ) ; goto cleanup_error ; } <S2SV_ModStart> ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>"" ""from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" <S2SV_ModEnd> <S2SV_ModStart> ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>"" ""initialization<S2SV_blank>(2):<S2SV_blank>%s."" , strerror ( errno ) <S2SV_ModEnd> <S2SV_ModStart> expected = 3 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>the<S2SV_blank>child<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>to<S2SV_blank>open<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(3):<S2SV_blank>%s."" , strerror ( errno ) ) ; goto cleanup_error ; } if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec , labelfd ; on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; labelfd = lsm_openat ( procfd , attached_pid , on_exec ) ; if ( labelfd < 0 ) goto cleanup_error ; ret = lxc_abstract_unix_send_fd ( ipc_sockets [ 0 ] , labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>send<S2SV_blank>child<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s."" , strerror ( errno ) ) ; goto cleanup_error ; } } <S2SV_ModStart> if ( procfd >= 0 ) close ( procfd ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3466,<S2SV_StartBug> rp [ 0 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> res -> nlimbs = ( msize == 1 && mod -> d [ 0 ] == 1 ) ? 0 : 1 ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( res -> nlimbs ) { if ( mpi_resize ( res , 1 ) < 0 ) goto enomem ; rp = res -> d ; rp [ 0 ] = 1 ; } "
3467,<S2SV_StartBug> if ( s -> s3 -> tmp . new_cipher -> algorithm2 & TLS1_STREAM_MAC ) <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ,<S2SV_ModStart> tlsext_use_etm ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ; else s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ; if ( s -> <S2SV_ModStart> if ( s -> tlsext_use_etm ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ; else s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ; 
3468,"<S2SV_StartBug> args -> count = min_t ( u32 , args -> count , PAGE_SIZE ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> 1 <S2SV_ModEnd> "
3469,<S2SV_StartBug> int valuelen = args -> valuelen ; <S2SV_EndBug> <S2SV_StartBug> ASSERT ( ! ( args -> flags & ATTR_KERNOVAL ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; ASSERT ( args -> rmtvaluelen == args -> valuelen ) ; valuelen = args -> rmtvaluelen 
3470,"<S2SV_StartBug> int openasuser ; <S2SV_EndBug> <S2SV_StartBug> int should_free_authpending_file = 0 ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , authfile_dir_len , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> cfg -> auth_file = buf ; <S2SV_EndBug> <S2SV_StartBug> openasuser = geteuid ( ) == 0 && cfg -> openasuser ; <S2SV_EndBug> <S2SV_StartBug> if ( openasuser ) { <S2SV_EndBug> <S2SV_StartBug> if ( seteuid ( pw_s . pw_uid ) ) { <S2SV_EndBug> <S2SV_StartBug> DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; <S2SV_EndBug> <S2SV_StartBug> DBG ( ""Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; <S2SV_EndBug> <S2SV_StartBug> if ( seteuid ( 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> DBG ( ""Switched<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> = 0 <S2SV_ModStart> ; PAM_MODUTIL_DEF_PRIVS ( privs ) <S2SV_ModStart> openasuser = geteuid ( ) == 0 ? 1 : 0 ; <S2SV_ModStart> if ( ! openasuser ) { DBG ( ""WARNING:<S2SV_blank>not<S2SV_blank>dropping<S2SV_blank>privileges<S2SV_blank>when<S2SV_blank>reading<S2SV_blank>%s,<S2SV_blank>please<S2SV_blank>"" ""consider<S2SV_blank>setting<S2SV_blank>openasuser=1<S2SV_blank>in<S2SV_blank>the<S2SV_blank>module<S2SV_blank>configuration"" <S2SV_ModEnd> <S2SV_ModStart> } } DBG ( ""Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , buf ) ; <S2SV_ModStart> if ( ! openasuser ) { openasuser <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> DBG ( ""Dropping<S2SV_blank>privileges"" ) ; if ( pam_modutil_drop_priv ( pamh , & privs , pw <S2SV_ModEnd> <S2SV_ModStart> pw -> <S2SV_ModEnd> <S2SV_ModStart> pw -> <S2SV_ModEnd> <S2SV_ModStart> pam_modutil_regain_priv ( pamh , & privs ) ) { DBG ( ""could<S2SV_blank>not<S2SV_blank>restore<S2SV_blank>privileges"" <S2SV_ModEnd> <S2SV_ModStart> ""Restored<S2SV_blank>privileges"" <S2SV_ModEnd> "
3471,<S2SV_StartBug> if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end && <S2SV_EndBug> <S2SV_StartBug> vma -> vm_userfaultfd_ctx . ctx != ctx ) ; <S2SV_EndBug> ,<S2SV_ModStart> ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ; <S2SV_ModStart> ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) 
3472,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> "
3473,<S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> sock * sk = asoc -> base . sk ; struct <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3474,<S2SV_StartBug> data -> l_head = NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> "
3475,"<S2SV_StartBug> ( void ) ReadBlobString ( image , text ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } "
3476,<S2SV_StartBug> struct user_struct * user = group -> inotify_data . user ; <S2SV_EndBug> <S2SV_StartBug> atomic_dec ( & user -> inotify_devs ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3477,"<S2SV_StartBug> * lastrow , <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) NULL ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , <S2SV_EndBug> <S2SV_StartBug> 2 * image -> columns ) , sizeof ( * lastrow ) ) ; <S2SV_EndBug> <S2SV_StartBug> one_row [ i + bit ] = lastrow [ i + bit ] ; <S2SV_EndBug> <S2SV_StartBug> ( void ) CopyMagickMemory ( lastrow , one_row , bytes_per_row ) ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> ",<S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row ) ) ; if ( last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> 
3478,<S2SV_StartBug> if ( retval ) { <S2SV_EndBug> ,<S2SV_ModStart> || pname_data . length == 0 || pname_data . data [ pname_data . length - 1 ] != '\\0' 
3479,"<S2SV_StartBug> static void mark_object ( struct object * obj , struct strbuf * path , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
3480,"<S2SV_StartBug> void kvm_lapic_set_vapic_addr ( struct kvm_vcpu * vcpu , gpa_t vapic_addr ) <S2SV_EndBug> <S2SV_StartBug> vcpu -> arch . apic -> vapic_addr = vapic_addr ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( vapic_addr ) { if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & <S2SV_ModStart> vapic_cache , vapic_addr , sizeof ( u32 ) ) ) return - EINVAL ; <S2SV_ModEnd> <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> vcpu -> arch . apic -> vapic_addr = vapic_addr ; return 0 ; } "
3481,"<S2SV_StartBug> int ctrl_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> if ( update_info ) { <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> pbi ) <S2SV_EndBug> <S2SV_StartBug> * update_info = ctx -> pbi -> refresh_frame_flags ; <S2SV_EndBug> <S2SV_StartBug> return VPX_CODEC_INVALID_PARAM ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ctx -> frame_parallel_decode ) { set_error_detail ( ctx , ""Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode"" ) ; return VPX_CODEC_INCAPABLE ; } if ( <S2SV_ModStart> frame_workers ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; <S2SV_ModEnd> <S2SV_ModStart> frame_worker_data <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> VPX_CODEC_ERROR <S2SV_ModEnd> <S2SV_ModStart> return VPX_CODEC_INVALID_PARAM ; } "
3482,<S2SV_StartBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) <S2SV_EndBug> ,<S2SV_ModStart> + <S2SV_ModEnd> <S2SV_ModStart> > vdev -> config_len ) { return ; } <S2SV_ModEnd> 
3483,"<S2SV_StartBug> * p_tx0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> tx0 + p * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x0 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x1 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y0 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ( OPJ_INT32 ) opj_uint_max <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ( OPJ_INT32 ) opj_uint_min <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ( OPJ_INT32 ) opj_uint_max <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ( OPJ_INT32 ) opj_uint_min <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> "
3484,<S2SV_StartBug> mm -> mmap_legacy_base = mmap_legacy_base ( random_factor ) ; <S2SV_EndBug> ,<S2SV_ModStart> TASK_UNMAPPED_BASE + random_factor <S2SV_ModEnd> 
3485,"<S2SV_StartBug> const int16_t * src , int16_t * dst , int src_stride ) { <S2SV_EndBug> <S2SV_StartBug> vp9_fdct32x32_rd ( src , dst , src_stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_fdct32x32 ( src , dst , src_stride ) ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_fdct32x32_rd <S2SV_ModEnd> <S2SV_ModStart> vpx_fdct32x32 <S2SV_ModEnd> 
3486,"<S2SV_StartBug> if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( line += 18 ; isspace ( * line ) ; line ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( ; line < last && isspace ( * line ) ; line ++ ) <S2SV_EndBug> <S2SV_StartBug> else if ( last >= line + 4 && isxdigit ( line [ 0 ] ) && isxdigit ( line [ 1 ] ) <S2SV_EndBug> <S2SV_StartBug> && isxdigit ( line [ 2 ] ) && isxdigit ( line [ 3 ] ) ) <S2SV_EndBug> ",<S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) 
3487,<S2SV_StartBug> gfp_mask = sk -> sk_allocation ; <S2SV_EndBug> <S2SV_StartBug> int npages ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> int npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ; err = - EMSGSIZE ; if ( npages > MAX_SKB_FRAGS ) goto failure ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3488,"<S2SV_StartBug> if ( ! ND_TTEST2 ( * ar_tpa ( ap ) , PROTO_LEN ( ap ) ) ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , TPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>%s"" , ipaddr_string ( ndo , SPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , <S2SV_EndBug> ","<S2SV_ModStart> TPA <S2SV_ModEnd> <S2SV_ModStart> ""who-has<S2SV_blank>"" ) ) ; tpaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank>tell<S2SV_blank>"" ) ) ; spaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> spaddr_print_ip ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>is-at<S2SV_blank>%s"" <S2SV_ModEnd> <S2SV_ModStart> ""%s<S2SV_blank>at<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ) ) ; tpaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> ""%s<S2SV_blank>at<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ) ) ; spaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> "
3489,<S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> int layer ; <S2SV_EndBug> <S2SV_StartBug> if ( svc -> number_temporal_layers > 1 ) { <S2SV_EndBug> <S2SV_StartBug> RATE_CONTROL * const lrc = & lc -> rc ; <S2SV_EndBug> <S2SV_StartBug> if ( svc -> number_temporal_layers > 1 ) { <S2SV_EndBug> <S2SV_StartBug> lc -> framerate = oxcf -> framerate / oxcf -> ts_rate_decimator [ layer ] ; <S2SV_EndBug> <S2SV_StartBug> lc -> framerate = oxcf -> framerate ; <S2SV_EndBug> <S2SV_StartBug> lrc -> av_per_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> sl , tl , layer = 0 , spatial_layer_target ; float bitrate_alloc = 1.0 ; if ( svc -> temporal_layering_mode != VP9E_TEMPORAL_LAYERING_MODE_NOLAYERING ) { for ( sl = 0 ; sl < oxcf -> ss_number_layers ; ++ sl ) { spatial_layer_target = 0 ; for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { layer = LAYER_IDS_TO_IDX ( sl , tl , oxcf -> ts_number_layers ) ; svc -> layer_context [ layer ] . target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; } layer = LAYER_IDS_TO_IDX ( sl , ( ( oxcf -> ts_number_layers - 1 ) < 0 ? 0 : ( oxcf -> ts_number_layers - 1 ) ) , oxcf -> ts_number_layers ) ; spatial_layer_target = svc -> layer_context [ layer ] . target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { LAYER_CONTEXT * const lc = & svc -> layer_context [ sl * oxcf -> ts_number_layers + tl ] ; RATE_CONTROL * const lrc = & lc -> rc ; lc -> spatial_layer_target_bandwidth = spatial_layer_target ; bitrate_alloc = ( float ) lc -> target_bandwidth / spatial_layer_target ; lrc -> starting_buffer_level = ( int64_t ) ( rc -> starting_buffer_level * bitrate_alloc ) ; lrc -> optimal_buffer_level = ( int64_t ) ( rc -> optimal_buffer_level * bitrate_alloc ) ; lrc -> maximum_buffer_size = ( int64_t ) ( rc -> maximum_buffer_size * bitrate_alloc ) ; lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lrc -> maximum_buffer_size ) ; lrc -> buffer_level = MIN ( lrc -> buffer_level , lrc -> maximum_buffer_size ) ; lc -> framerate = cpi -> framerate / oxcf -> ts_rate_decimator [ tl ] ; lrc -> avg_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; lrc -> max_frame_bandwidth = rc -> max_frame_bandwidth ; lrc -> worst_quality = rc -> worst_quality ; lrc -> best_quality = rc -> best_quality ; } } } else { int layer_end <S2SV_ModEnd> <S2SV_ModStart> && cpi -> oxcf . rc_mode == VPX_CBR <S2SV_ModStart> ; lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; bitrate_alloc = ( float ) lc -> target_bandwidth / target_bandwidth ; lrc -> starting_buffer_level = ( int64_t ) ( rc -> starting_buffer_level * bitrate_alloc ) ; lrc -> optimal_buffer_level = ( int64_t ) ( rc -> optimal_buffer_level * bitrate_alloc ) ; lrc -> maximum_buffer_size = ( int64_t ) ( rc -> maximum_buffer_size * bitrate_alloc ) ; lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lrc -> maximum_buffer_size ) ; lrc -> buffer_level = MIN ( lrc -> buffer_level , lrc -> maximum_buffer_size ) <S2SV_ModStart> && cpi -> oxcf . rc_mode == VPX_CBR <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> } "
3490,"<S2SV_StartBug> psf_binheader_readf ( psf , ""p"" , psf -> fileoffset ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ",<S2SV_ModStart> if ( psf -> fileoffset < psf -> filelength ) { <S2SV_ModStart> } ; 
3491,<S2SV_StartBug> dst_reg -> id = ptr_reg -> id ; <S2SV_EndBug> <S2SV_StartBug> __update_reg_bounds ( dst_reg ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL <S2SV_ModStart> if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ; "
3492,"<S2SV_StartBug> return ast_for_call ( c , CHILD ( n , 1 ) , left_expr ) ; <S2SV_EndBug> ","<S2SV_ModStart> , true "
3493,"<S2SV_StartBug> if ( ep_loop_check ( ep , tfile ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> goto error_tgt_fput ; <S2SV_EndBug> ",<S2SV_ModStart> { clear_tfile_check_list ( ) ; <S2SV_ModStart> } 
3494,<S2SV_StartBug> else if ( vcpu -> arch . apic_base & X2APIC_ENABLE ) { <S2SV_EndBug> ,<S2SV_ModStart> cpu_has_secondary_exec_ctrls ( ) && ( vmcs_read32 ( SECONDARY_VM_EXEC_CONTROL ) & SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE ) <S2SV_ModEnd> 
3495,<S2SV_StartBug> print_bpf_insn ( insn ) ; <S2SV_EndBug> ,"<S2SV_ModStart> env , "
3496,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> mono_reflection_shutdown ( ) ; 
3497,"<S2SV_StartBug> stlv_type = * ( tptr ++ ) ; <S2SV_EndBug> <S2SV_StartBug> len = len - 2 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> while ( tmp ) <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len ) <S2SV_ModStart> if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; <S2SV_ModStart> if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ; stlv_len = stlv_len <S2SV_ModStart> if ( stlv_len < 8 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> tptr += stlv_len ; len -= stlv_len ; "
3498,"<S2SV_StartBug> sidx = sizeof ( t_chunk_info ) * nc ; <S2SV_EndBug> <S2SV_StartBug> cidx = gdCalloc ( sidx , 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( overflow2 ( sidx , nc ) ) { goto fail1 ; } <S2SV_ModStart> if ( cidx == NULL ) { goto fail1 ; } "
3499,"<S2SV_StartBug> assert ( ( occ0 % rowsize ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> ( * sp -> decodepfunc ) ( tif , op0 , rowsize ) ; <S2SV_EndBug> ","<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""PredictorDecodeTile"" , ""%s"" , ""occ0%rowsize<S2SV_blank>!=<S2SV_blank>0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> if ( ! <S2SV_ModStart> ) return 0 "
3500,<S2SV_StartBug> goto out ; <S2SV_EndBug> ,<S2SV_ModStart> out2 <S2SV_ModEnd> 
3501,"<S2SV_StartBug> return ( xdr_opaque ( xdrs , * objp , size ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! <S2SV_ModEnd> <S2SV_ModStart> return FALSE ; if ( ( * objp ) [ size - 1 ] != '\\0' ) return FALSE ; if ( memchr ( * objp , '\\0' , size - 1 ) != NULL ) return FALSE ; return TRUE "
3502,"<S2SV_StartBug> u_char showspi , showdata , showsomedata ; <S2SV_EndBug> <S2SV_StartBug> showdata = 0 ; <S2SV_EndBug> <S2SV_StartBug> showsomedata = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( 3 < ndo -> ndo_vflag ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( showdata || ( showsomedata && ep - cp < 30 ) ) && cp < ep ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( showsomedata && cp < ep ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cp < ep ) { if ( <S2SV_ModEnd> <S2SV_ModStart> > 3 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } 
3503,"<S2SV_StartBug> status = dm9000ReadReg ( DM9000_REG_ISR ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_IMR , mask & ~ IMR_LNKCHGI ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & ISR_PT ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_ISR , ISR_PT ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_IMR , mask & ~ IMR_PRI ) ; <S2SV_EndBug> ","<S2SV_ModStart> DM9000_ISR ) ; if ( ( status & DM9000_ISR_LNKCHG ) != 0 ) { mask = dm9000ReadReg ( DM9000_IMR <S2SV_ModEnd> <S2SV_ModStart> DM9000_IMR <S2SV_ModEnd> <S2SV_ModStart> DM9000_IMR_LNKCHGI <S2SV_ModEnd> <S2SV_ModStart> DM9000_ISR_PT ) != 0 ) { if ( ( dm9000ReadReg ( DM9000_NSR ) & ( DM9000_NSR_TX2END | DM9000_NSR_TX1END ) ) != 0 <S2SV_ModEnd> <S2SV_ModStart> DM9000_ISR , DM9000_ISR_PT ) ; } if ( ( status & DM9000_ISR_PR ) != 0 ) { mask = dm9000ReadReg ( DM9000_IMR <S2SV_ModEnd> <S2SV_ModStart> DM9000_IMR <S2SV_ModEnd> <S2SV_ModStart> DM9000_IMR_PRI <S2SV_ModEnd> "
3504,<S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( s -> codec_id == AV_CODEC_ID_JV ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO ) { w_align = 8 ; h_align = 8 ; } <S2SV_ModStart> || s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO 
3505,"<S2SV_StartBug> ext4_show_quota_options ( seq , sb ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( test_opt ( sb , DIOREAD_NOLOCK ) ) seq_puts ( seq , "",dioread_nolock"" ) ; "
3506,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( rdp -> rc4_decrypt_key == NULL ) return FALSE ; 
3507,<S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug> ,<S2SV_ModStart> ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> 
3508,<S2SV_StartBug> comics_document -> selected_command = <S2SV_EndBug> <S2SV_StartBug> comics_document -> selected_command = <S2SV_EndBug> <S2SV_StartBug> comics_document -> selected_command = <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } else <S2SV_ModEnd> 
3509,<S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ,"<S2SV_ModStart> ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) "
3510,"<S2SV_StartBug> int i , pktsz , ret ; <S2SV_EndBug> <S2SV_StartBug> dev_dbg ( dev , ""Checking<S2SV_blank>memory<S2SV_blank>size\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> i = 0x12345678 ; <S2SV_EndBug> <S2SV_StartBug> catc_write_mem ( catc , 0x7a80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> i = 0x87654321 ; <S2SV_EndBug> <S2SV_StartBug> catc_write_mem ( catc , 0xfa80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> catc_read_mem ( catc , 0x7a80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( i ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> u32 * buf ; int i ; <S2SV_ModStart> buf = kmalloc ( 4 , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; goto fail_free ; } * buf <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> * buf <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> * buf <S2SV_ModEnd> <S2SV_ModStart> kfree ( buf ) ; "
3511,"<S2SV_StartBug> void * p = au -> reply_buf ; <S2SV_EndBug> <S2SV_StartBug> ret = ceph_x_decrypt ( & th -> session_key , & p , end , & reply , sizeof ( reply ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> preply = & reply ; void * <S2SV_ModStart> preply <S2SV_ModEnd> 
3512,"<S2SV_StartBug> cp += advance ; <S2SV_EndBug> <S2SV_StartBug> nh = * cp ; <S2SV_EndBug> <S2SV_StartBug> advance = rt6_print ( ndo , cp , ( const u_char * ) ip6 ) ; <S2SV_EndBug> <S2SV_StartBug> nh = * cp ; <S2SV_EndBug> <S2SV_StartBug> advance = ah_print ( ndo , cp ) ; <S2SV_EndBug> <S2SV_StartBug> nh = enh & 0xff ; <S2SV_EndBug> ",<S2SV_ModStart> if ( len < ( u_int ) advance ) goto trunc ; <S2SV_ModStart> if ( advance < 0 ) return ; <S2SV_ModStart> ND_TCHECK ( * cp ) ; <S2SV_ModStart> if ( advance < 0 ) return ; <S2SV_ModStart> ; if ( advance < 0 ) return <S2SV_ModStart> if ( advance < 0 ) return ; 
3513,<S2SV_StartBug> if ( p == q || size < 16 || size > 256 ) <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) || ( <S2SV_ModEnd> <S2SV_ModStart> ) || ( <S2SV_ModEnd> <S2SV_ModStart> ) 
3514,"<S2SV_StartBug> ""?"" , tptr [ 0 ] ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; ND_TCHECK ( tptr [ 1 ] 
3515,<S2SV_StartBug> jpc_tsfb_band_t bnds [ 64 ] ; <S2SV_EndBug> ,<S2SV_ModStart> JPC_MAXBANDS <S2SV_ModEnd> 
3516,<S2SV_StartBug> if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) ) <S2SV_EndBug> ,<S2SV_ModStart> validate_core_offset ( reg ) ) return - EINVAL ; if ( 
3517,<S2SV_StartBug> list_del ( & ti -> active_list ) ; <S2SV_EndBug> ,<S2SV_ModStart> list_del_init <S2SV_ModEnd> 
3518,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
3519,"<S2SV_StartBug> g_return_if_fail ( RS_IS_FILTER ( filter ) ) ; <S2SV_EndBug> <S2SV_StartBug> g_file_set_contents ( ""/tmp/rs-filter-graph"" , str -> str , str -> len , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( 0 != system ( ""dot<S2SV_blank>-Tpng<S2SV_blank>>/tmp/rs-filter-graph.png<S2SV_blank></tmp/rs-filter-graph"" ) ) <S2SV_EndBug> <S2SV_StartBug> if ( 0 != system ( ""gnome-open<S2SV_blank>/tmp/rs-filter-graph.png"" ) ) <S2SV_EndBug> <S2SV_StartBug> g_warning ( ""Calling<S2SV_blank>gnome-open<S2SV_blank>failed."" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; gchar * dot_filename ; gchar * png_filename ; gchar * command_line <S2SV_ModStart> dot_filename = g_strdup_printf ( ""/tmp/rs-filter-graph.%u"" , g_random_int ( ) ) ; png_filename = g_strdup_printf ( ""%s.%u.png"" , dot_filename , g_random_int ( ) ) ; g_file_set_contents ( dot_filename <S2SV_ModEnd> <S2SV_ModStart> command_line = g_strdup_printf ( ""dot<S2SV_blank>-Tpng<S2SV_blank>>%s<S2SV_blank><%s"" , png_filename , dot_filename ) ; <S2SV_ModStart> command_line <S2SV_ModEnd> <S2SV_ModStart> g_free ( command_line ) ; command_line = g_strdup_printf ( ""gnome-open<S2SV_blank>%s"" , png_filename ) ; <S2SV_ModStart> command_line <S2SV_ModEnd> <S2SV_ModStart> ) ; g_free ( command_line ) ; g_free ( dot_filename ) ; g_free ( png_filename "
3520,<S2SV_StartBug> return res ; <S2SV_EndBug> ,<S2SV_ModStart> cleanup : <S2SV_ModEnd> 
3521,<S2SV_StartBug> sb -> s_op = & ext2_sops ; <S2SV_EndBug> <S2SV_StartBug> percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ; <S2SV_EndBug> ,"<S2SV_ModStart> # ifdef CONFIG_EXT2_FS_XATTR sbi -> s_mb_cache = ext2_xattr_create_cache ( ) ; if ( ! sbi -> s_mb_cache ) { ext2_msg ( sb , KERN_ERR , ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>an<S2SV_blank>mb_cache"" ) ; goto failed_mount3 ; } # endif <S2SV_ModStart> if ( sbi -> s_mb_cache ) ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ; "
3522,"<S2SV_StartBug> ( IN_DEV_SHARED_MEDIA ( out_dev ) || <S2SV_EndBug> <S2SV_StartBug> inet_addr_onlink ( out_dev , saddr , FIB_RES_GW ( * res ) ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart> skb -> protocol == htons ( ETH_P_IP ) && <S2SV_ModStart> IPCB ( skb ) -> flags |= IPSKB_DOREDIRECT ; <S2SV_ModEnd> 
3523,<S2SV_StartBug> unsigned long kflags = key -> flags ; <S2SV_EndBug> <S2SV_StartBug> if ( kflags & ( 1 << KEY_FLAG_NEGATIVE ) ) { <S2SV_EndBug> <S2SV_StartBug> ctx -> result = ERR_PTR ( key -> reject_error ) ; <S2SV_EndBug> ,<S2SV_ModStart> READ_ONCE ( key -> flags ) ; short state = READ_ONCE ( key -> state ) <S2SV_ModEnd> <S2SV_ModStart> state < 0 ) { <S2SV_ModEnd> <S2SV_ModStart> state <S2SV_ModEnd> 
3524,<S2SV_StartBug> if ( avctx -> codec_id == AV_CODEC_ID_MPEG4 && avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) <S2SV_EndBug> ,<S2SV_ModStart> c -> mpeg4_studio_profile <S2SV_ModEnd> 
3525,<S2SV_StartBug> subsampling_dx = parameters -> subsampling_dx ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( image_height != 0 && image_width > 10000000 / image_height / numcomps ) { char ch ; OPJ_UINT64 expected_file_size = ( OPJ_UINT64 ) image_width * image_height * numcomps ; long curpos = ftell ( f ) ; if ( expected_file_size > ( OPJ_UINT64 ) INT_MAX ) { expected_file_size = ( OPJ_UINT64 ) INT_MAX ; } fseek ( f , ( long ) expected_file_size - 1 , SEEK_SET ) ; if ( fread ( & ch , 1 , 1 , f ) != 1 ) { fclose ( f ) ; return NULL ; } fseek ( f , curpos , SEEK_SET ) ; } "
3526,<S2SV_StartBug> dev -> product_id = le16_to_cpu ( udev -> descriptor . idProduct ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( iface_desc -> desc . bNumEndpoints < 1 ) { dev_err ( & interface -> dev , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n"" ) ; retval = - EINVAL ; goto error ; } "
3527,"<S2SV_StartBug> mask |= FS_EVENT_ON_CHILD ; <S2SV_EndBug> <S2SV_StartBug> if ( path ) <S2SV_EndBug> <S2SV_StartBug> dentry -> d_name . name , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> dentry -> d_name . name , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct name_snapshot name ; <S2SV_ModStart> take_dentry_name_snapshot ( & name , dentry ) ; <S2SV_ModStart> name <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> <S2SV_ModStart> ) ; release_dentry_name_snapshot ( & name "
3528,"<S2SV_StartBug> return udp_prot . getsockopt ( sk , level , optname , optval , optlen ) ; <S2SV_EndBug> ",<S2SV_ModStart> - EINVAL <S2SV_ModEnd> 
3529,"<S2SV_StartBug> memcpy ( data -> strval , * bnode , size ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! data -> strval ) { plist_free_data ( data ) ; PLIST_BIN_ERR ( ""%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>%"" PRIu64 ""<S2SV_blank>bytes\\n"" , __func__ , sizeof ( char ) * ( size + 1 ) ) ; return NULL ; } "
3530,"<S2SV_StartBug> mptctl_hp_targetinfo ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> hp_target_info_t karg ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <S2SV_EndBug> <S2SV_StartBug> ( ioc == NULL ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> MPT_ADAPTER * ioc , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> karg . hdr . id >= MPT_MAX_FC_DEVICES ) return - EINVAL ; dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_hp_targetinfo<S2SV_blank>called.\\n"" , ioc -> name ) ) ; if ( ( ioc -> bus_type == SAS ) || ( ioc -> bus_type == FC ) ) return 0 ; if ( ( ioc -> spi_data . sdp0length == 0 ) || ( ioc -> sh <S2SV_ModEnd> <S2SV_ModStart> return 0 ; if ( ioc -> sh -> host_no != karg . hdr . host ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3531,"<S2SV_StartBug> ++ v ; <S2SV_EndBug> <S2SV_StartBug> ( void ) __writev ( STDERR_FILENO , iov , 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( buf [ bufsize - 1 ] != '\\n' ) { <S2SV_ModStart> } <S2SV_ModStart> v - iov + 1 <S2SV_ModEnd> 
3532,<S2SV_StartBug> if ( xWantedSize > 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) ) <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> && ( ( xWantedSize + heapSTRUCT_SIZE ) > xWantedSize ) ) <S2SV_ModStart> + ( portBYTE_ALIGNMENT - ( xWantedSize <S2SV_ModStart> ) ) > xWantedSize <S2SV_ModEnd> <S2SV_ModStart> configASSERT ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 ) ; } else { xWantedSize = 0 ; } } else { xWantedSize = 0 ; <S2SV_ModEnd> <S2SV_ModStart> <= xFreeBytesRemaining <S2SV_ModEnd> 
3533,<S2SV_StartBug> if ( * t ++ != * q ++ ) return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> t >= tend ) return 0 ; if ( 
3534,"<S2SV_StartBug> static void nsc_encode_sse2 ( NSC_CONTEXT * context , const BYTE * data , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> return TRUE ; 
3535,"<S2SV_StartBug> static char temp [ NFSX_V3FHMAX + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( temp , sfsname , NFSX_V3FHMAX ) ; <S2SV_EndBug> <S2SV_StartBug> temp [ sizeof ( temp ) - 1 ] = '\\0' ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> u_int stringlen ; stringlen = len ; if ( stringlen > NFSX_V3FHMAX ) stringlen = NFSX_V3FHMAX ; <S2SV_ModStart> stringlen <S2SV_ModEnd> <S2SV_ModStart> stringlen <S2SV_ModEnd> 
3536,"<S2SV_StartBug> if ( recv ( fd , & cmd , sizeof ( cmd ) , MSG_WAITALL ) != sizeof ( cmd ) ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
3537,<S2SV_StartBug> bh -> b_bdev = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> clear_buffer_delay ( bh ) ; clear_buffer_unwritten ( bh ) ; 
3538,"<S2SV_StartBug> if ( JAS_CAST ( uint , jas_stream_write ( out , ( char * ) ppm -> data , ppm -> len ) ) != ppm -> len ) { <S2SV_EndBug> ",<S2SV_ModStart> jas_uint <S2SV_ModEnd> 
3539,"<S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( tm2interval ( tm , fsec , result ) != 0 ) <S2SV_EndBug> ","<S2SV_ModStart> > MAXDATELEN ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || ( DecodeInterval ( field , ftype , nf , & dtype , tm , & fsec ) != 0 && DecodeISO8601Interval ( str , & dtype , tm , & fsec ) != 0 ) ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ; if ( ! result ) return NULL ; if ( dtype != DTK_DELTA <S2SV_ModEnd> <S2SV_ModStart> free ( result ) ; return NULL ; } if ( tm2interval ( tm , fsec , result ) != 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3540,"<S2SV_StartBug> AsyncWith ( asdl_seq * items , asdl_seq * body , int lineno , int col_offset , int <S2SV_EndBug> <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug> ","<S2SV_ModStart> string type_comment , <S2SV_ModStart> v . AsyncWith . type_comment = type_comment ; p -> "
3541,<S2SV_StartBug> struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> struct xfrm_dump_info info ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cb -> args [ 0 ] ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3542,<S2SV_StartBug> case 'h' : <S2SV_EndBug> ,<S2SV_ModStart> # include < sslopt - case . h > 
3543,"<S2SV_StartBug> assert ( ( size_t ) CDF_SEC_SIZE ( h ) == len ) ; <S2SV_EndBug> <S2SV_StartBug> return cdf_read ( info , ( off_t ) CDF_SEC_POS ( h , id ) , <S2SV_EndBug> ","<S2SV_ModStart> size_t ss = <S2SV_ModEnd> <S2SV_ModStart> ; size_t pos = CDF_SEC_POS ( h , id ) ; assert ( ss <S2SV_ModStart> pos , <S2SV_ModEnd> "
3544,"<S2SV_StartBug> next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift ; <S2SV_EndBug> <S2SV_StartBug> calc_max_reserv ( ip , len , & max_bytes , & data_blocks , & ind_blocks ) ; <S2SV_EndBug> ","<S2SV_ModStart> loff_t max_chunk_size = UINT_MAX & bsize_mask ; <S2SV_ModStart> ( len > max_chunk_size ) ? max_chunk_size : len , <S2SV_ModEnd> "
3545,"<S2SV_StartBug> unsigned char signature [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> unsigned int siglen = sizeof signature ; <S2SV_EndBug> <S2SV_StartBug> if ( 1 != randomize ( pamh , challenge , sizeof challenge ) ) { <S2SV_EndBug> <S2SV_StartBug> err : <S2SV_EndBug> ",<S2SV_ModStart> * signature = NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> NULL == privkey ) goto err ; siglen = EVP_PKEY_size ( privkey ) ; if ( siglen <= 0 ) goto err ; signature = malloc ( siglen ) ; if ( NULL == signature ) goto err ; if ( <S2SV_ModStart> free ( signature ) ; 
3546,<S2SV_StartBug> atomic_dec ( & user -> inotify_devs ) ; <S2SV_EndBug> ,<S2SV_ModStart> fsnotify_put_group ( group ) ; 
3547,<S2SV_StartBug> put_device ( & dev -> dev ) ; <S2SV_EndBug> ,<S2SV_ModStart> cancel_autoload_drivers ( ) ; 
3548,"<S2SV_StartBug> uint32_t tag = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( tcm_tmr < 0 ) { <S2SV_EndBug> <S2SV_StartBug> rc = srpt_rx_mgmt_fn_tag ( send_ioctx , srp_tsk -> task_tag ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> unpacked_lun = srpt_unpack_lun ( ( uint8_t * ) & srp_tsk -> lun , sizeof ( srp_tsk -> lun ) ) ; rc = target_submit_tmr ( & send_ioctx -> cmd , sess , NULL , unpacked_lun , srp_tsk , tcm_tmr , GFP_KERNEL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3549,<S2SV_StartBug> case '\\r' : <S2SV_EndBug> ,"<S2SV_ModStart> \'""\' : case '\\\\' : case "
3550,<S2SV_StartBug> exit ( i ) ; <S2SV_EndBug> ,"<S2SV_ModStart> # ifdef HAVE_MKDTEMP if ( no_rc_dir && tmp_dir != rc_dir ) if ( rmdir ( tmp_dir ) != 0 ) { fprintf ( stderr , ""Can\'t<S2SV_blank>remove<S2SV_blank>temporary<S2SV_blank>directory<S2SV_blank>(%s)!\\n"" , tmp_dir ) ; exit ( 1 ) ; } # endif "
3551,"<S2SV_StartBug> vdev -> ctx = kzalloc ( nvec * sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ; <S2SV_EndBug> ","<S2SV_ModStart> kcalloc ( nvec , <S2SV_ModEnd> "
3552,<S2SV_StartBug> OPCODE_DESC * opcode_desc ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 2 ) { return NULL ; } 
3553,<S2SV_StartBug> int n_read = r -> end - r -> begin ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned int actual_size = rtype == 2 ? n * 2 : n ; unsigned int limit_r_begin = ( r -> begin < actual_size ? r -> begin : actual_size ) ; unsigned int limit_r_end = ( r -> end < actual_size ? r -> end : actual_size ) ; <S2SV_ModStart> limit_r_end - limit_r_begin <S2SV_ModEnd> 
3554,<S2SV_StartBug> if ( flags & __GFP_ZERO ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3555,"<S2SV_StartBug> goto out_nofree ; <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_name != NULL ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg -> msg_name , & sa , sizeof ( struct sockaddr_pn ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> sa ) ) ; * addr_len = sizeof ( sa ) ; } <S2SV_ModEnd> 
3556,<S2SV_StartBug> uint8_t * result ; <S2SV_EndBug> ,<S2SV_ModStart> if ( nbytes > LEVEL_3_MAX_HEADER_LEN ) { return NULL ; } 
3557,<S2SV_StartBug> for ( ; offset < ( MagickOffsetType ) cin . file . image_offset ; offset ++ ) <S2SV_EndBug> ,"<S2SV_ModStart> if ( ( ( MagickSizeType ) image -> columns * image -> rows ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; "
3558,<S2SV_StartBug> case 0x2f8 : <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3559,"<S2SV_StartBug> struct pending_tx_info * pending_tx_info = netbk -> pending_tx_info ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( err ) ) { <S2SV_EndBug> <S2SV_StartBug> netbk -> pending_ring [ index ] = pending_idx ; <S2SV_EndBug> <S2SV_StartBug> pending_ring_idx_t index ; <S2SV_EndBug> <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> <S2SV_StartBug> txp = & netbk -> pending_tx_info [ pending_idx ] . req ; <S2SV_EndBug> <S2SV_StartBug> index = pending_index ( netbk -> pending_prod ++ ) ; <S2SV_EndBug> <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> xen_netbk_idx_release ( netbk , pending_idx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , XEN_NETIF_RSP_OKAY <S2SV_ModStart> xen_netbk_idx_release ( netbk , pending_idx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , XEN_NETIF_RSP_OKAY <S2SV_ModStart> , XEN_NETIF_RSP_OKAY "
3560,"<S2SV_StartBug> args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ; <S2SV_EndBug> ",<S2SV_ModStart> rmtvaluelen = valuelen ; args . 
3561,"<S2SV_StartBug> hdr . w0 = be32_to_cpu ( buf [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> hdr . w1 = ntohl ( buf [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( len <= RFC2374_UNFRAG_HDR_SIZE ) return 0 ; <S2SV_ModStart> if ( len <= RFC2374_FRAG_HDR_SIZE ) return 0 ; <S2SV_ModStart> if ( fg_off + len > dg_size ) return 0 ; 
3562,<S2SV_StartBug> s = & pit_state -> channels [ addr ] ; <S2SV_EndBug> ,<S2SV_ModStart> if ( addr == 3 ) return 0 ; 
3563,"<S2SV_StartBug> fd = open ( authfile , O_RDONLY , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> else if ( fd >= 0 ) <S2SV_EndBug> ",<S2SV_ModStart> | O_CLOEXEC | O_NOCTTY <S2SV_ModEnd> <S2SV_ModStart> ; } else { fd = - 1 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> != - 1 <S2SV_ModEnd> 
3564,<S2SV_StartBug> buf = malloc ( sz + 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
3565,"<S2SV_StartBug> static mongo_message * mongo_message_create ( int len , int id , int responseTo , int op ) { <S2SV_EndBug> <S2SV_StartBug> mm -> head . len = len ; <S2SV_EndBug> ",<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> ( int ) 
3566,<S2SV_StartBug> for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( depth >= 64 ) break 
3567,<S2SV_StartBug> register struct enamemem * tp ; <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_name ) <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_name == NULL ) <S2SV_EndBug> <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> ,<S2SV_ModStart> bsnamemem <S2SV_ModEnd> <S2SV_ModStart> bs_name ) return ( tp -> bs_name ) ; tp -> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> 
3568,<S2SV_StartBug> i += 1 ; <S2SV_EndBug> ,<S2SV_ModStart> ++ <S2SV_ModEnd> 
3569,"<S2SV_StartBug> sk -> sk_sndbuf = max_t ( u32 , val * 2 , SOCK_MIN_SNDBUF ) ; <S2SV_EndBug> <S2SV_StartBug> sk -> sk_rcvbuf = max_t ( u32 , val * 2 , SOCK_MIN_RCVBUF ) ; <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int <S2SV_ModEnd> 
3570,"<S2SV_StartBug> memcpy ( data -> strval , * bnode , size ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! data -> strval ) { plist_free_data ( data ) ; PLIST_BIN_ERR ( ""%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>%"" PRIu64 ""<S2SV_blank>bytes\\n"" , __func__ , sizeof ( char ) * ( size + 1 ) ) ; return NULL ; } "
3571,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>CT:<S2SV_blank>%u"" , <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_32BITS ( obj_tptr ) ; 
3572,<S2SV_StartBug> bool slow ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * addr_len = sizeof ( * sin6 ) ; 
3573,<S2SV_StartBug> smb_ofile_t * of = NULL ; <S2SV_EndBug> <S2SV_StartBug> of = sr -> fid_ofile ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> smb_ofile_flush ( sr , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3574,<S2SV_StartBug> } else { <S2SV_EndBug> ,<S2SV_ModStart> rdev -> ena_pin = NULL ; return ; 
3575,"<S2SV_StartBug> int ntlm_read_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> <S2SV_StartBug> if ( ( fields -> BufferOffset + fields -> Len ) > Stream_Length ( s ) ) <S2SV_EndBug> ",<S2SV_ModStart> static <S2SV_ModStart> const UINT64 offset = ( UINT64 ) <S2SV_ModEnd> <S2SV_ModStart> ( UINT64 ) <S2SV_ModStart> ; if ( offset <S2SV_ModEnd> 
3576,<S2SV_StartBug> if ( rv < 0 ) <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree ( bmc ) ; <S2SV_ModStart> } 
3577,"<S2SV_StartBug> declen = mutt_b64_decode ( out2 , out1 ) ; <S2SV_EndBug> <S2SV_StartBug> declen = mutt_b64_decode ( out2 , out1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( out2 ) <S2SV_ModStart> , sizeof ( out2 ) "
3578,"<S2SV_StartBug> if ( poll ( & pfd , 1 , uipc_main . ch [ ch_id ] . read_poll_tmo_ms ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> n = recv ( fd , p_buf + n_read , len - n_read , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
3579,"<S2SV_StartBug> PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; <S2SV_EndBug> <S2SV_StartBug> q = p ; <S2SV_EndBug> <S2SV_StartBug> goto skip ; <S2SV_EndBug> <S2SV_StartBug> php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ; <S2SV_EndBug> <S2SV_StartBug> PS_ADD_VARL ( name , namelen ) ; <S2SV_EndBug> ",<S2SV_ModStart> int skip = 0 ; <S2SV_ModStart> ; skip = 0 <S2SV_ModStart> skip = 1 <S2SV_ModEnd> <S2SV_ModStart> if ( ! skip ) { <S2SV_ModStart> } <S2SV_ModStart> if ( ! skip ) { <S2SV_ModStart> } 
3580,"<S2SV_StartBug> status = enc28j60ReadReg ( interface , ENC28J60_REG_EIR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & EIR_LINKIF ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> enc28j60ReadPhyReg ( interface , ENC28J60_PHY_REG_PHIR ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_LINKIF ) ; <S2SV_EndBug> <S2SV_StartBug> value = enc28j60ReadPhyReg ( interface , ENC28J60_PHY_REG_PHSTAT2 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( value & PHSTAT2_LSTAT ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( status & EIR_PKTIF ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_PKTIF ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_EIE , EIE_LINKIE | EIE_PKTIE ) ; <S2SV_EndBug> ","<S2SV_ModStart> ENC28J60_EIR <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIR_LINKIF <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_PHIR <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIR , ENC28J60_EIR_LINKIF <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_PHSTAT2 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_PHSTAT2_LSTAT <S2SV_ModEnd> <S2SV_ModStart> enc28j60ReadReg ( interface , ENC28J60_EPKTCNT <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIR , ENC28J60_EIR_PKTIF <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIE , ENC28J60_EIE_LINKIE | ENC28J60_EIE_PKTIE <S2SV_ModEnd> "
3581,<S2SV_StartBug> linkname = archive_entry_hardlink ( a -> entry ) ; <S2SV_EndBug> <S2SV_StartBug> # else <S2SV_EndBug> ,"<S2SV_ModStart> char * linkname_copy ; struct archive_string error_string ; int error_number ; <S2SV_ModStart> archive_string_init ( & error_string ) ; linkname_copy = strdup ( linkname ) ; if ( linkname_copy == NULL ) { return ( EPERM ) ; } r = cleanup_pathname_fsobj ( linkname_copy , & error_number , & error_string , a -> flags ) ; if ( r != ARCHIVE_OK ) { archive_set_error ( & a -> archive , error_number , ""%s"" , error_string . s ) ; free ( linkname_copy ) ; return ( EPERM ) ; } r = check_symlinks_fsobj ( linkname_copy , & error_number , & error_string , a -> flags ) ; if ( r != ARCHIVE_OK ) { archive_set_error ( & a -> archive , error_number , ""%s"" , error_string . s ) ; free ( linkname_copy ) ; return ( EPERM ) ; } free ( linkname_copy ) ; "
3582,"<S2SV_StartBug> snprintf ( rcipher . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""cipher"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> ""cipher"" , sizeof ( rcipher . type ) <S2SV_ModEnd> "
3583,<S2SV_StartBug> kfree ( bprm ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( bprm -> interp != bprm -> filename ) kfree ( bprm -> interp ) ; 
3584,"<S2SV_StartBug> void vp9_iwht4x4_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) { <S2SV_EndBug> <S2SV_StartBug> vp9_iwht4x4_16_add ( input , dest , stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_iwht4x4_1_add ( input , dest , stride ) ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_iwht4x4_16_add <S2SV_ModEnd> <S2SV_ModStart> vpx_iwht4x4_1_add <S2SV_ModEnd> 
3585,"<S2SV_StartBug> BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( * vs > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ; 
3586,"
","
"
3587,"<S2SV_StartBug> struct ip_options * opt = inet -> opt ; <S2SV_EndBug> <S2SV_StartBug> rt = skb_rtable ( skb ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt && opt -> srr ) <S2SV_EndBug> <S2SV_StartBug> daddr = opt -> faddr ; <S2SV_EndBug> <S2SV_StartBug> if ( opt && opt -> is_strictroute && rt -> rt_dst != rt -> rt_gateway ) <S2SV_EndBug> <S2SV_StartBug> skb_push ( skb , sizeof ( struct iphdr ) + ( opt ? opt -> optlen : 0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt && opt -> optlen ) { <S2SV_EndBug> <S2SV_StartBug> iph -> ihl += opt -> optlen >> 2 ; <S2SV_EndBug> <S2SV_StartBug> ip_options_build ( skb , opt , inet -> inet_daddr , rt , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ip_options_rcu * inet_opt <S2SV_ModEnd> <S2SV_ModStart> inet_opt = rcu_dereference ( inet -> inet_opt ) ; <S2SV_ModStart> inet_opt && inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt && inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt ? inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt && inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> & inet_opt -> 
3588,<S2SV_StartBug> timr -> it_overrun = - 1 ; <S2SV_EndBug> <S2SV_StartBug> info -> si_overrun += timr -> it_overrun_last ; <S2SV_EndBug> ,"<S2SV_ModStart> 1LL <S2SV_ModEnd> <S2SV_ModStart> = timer_overrun_to_int ( timr , info -> si_overrun ) <S2SV_ModEnd> "
3589,<S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < memo -> mt_allocated ; ++ i ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> size_t 
3590,<S2SV_StartBug> if ( sk -> sk_protocol == IPPROTO_TCP ) <S2SV_EndBug> ,<S2SV_ModStart> && sk -> sk_type == SOCK_STREAM 
3591,"<S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( ret ) return ret <S2SV_ModEnd> "
3592,"<S2SV_StartBug> StreamTcpSetEvent ( p , STREAM_PKT_BROKEN_ACK ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; goto error 
3593,"<S2SV_StartBug> u8 obuf [ ] = { 0xde , 0 } ; <S2SV_EndBug> <S2SV_StartBug> state -> initialized = 1 ; <S2SV_EndBug> <S2SV_StartBug> return dvb_usb_generic_rw ( d , obuf , 2 , NULL , 0 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int ret = 0 <S2SV_ModEnd> <S2SV_ModStart> mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xde ; state -> data [ 1 ] = 0 ; <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & d -> data_mutex ) ; } return ret <S2SV_ModEnd> 
3594,<S2SV_StartBug> void unix_notinflight ( struct file * fp ) <S2SV_EndBug> <S2SV_StartBug> fp -> f_cred -> user -> unix_inflight -- ; <S2SV_EndBug> ,"<S2SV_ModStart> struct user_struct * user , <S2SV_ModStart>  <S2SV_ModEnd> "
3595,<S2SV_StartBug> # ifdef AUTOKEY <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3596,"<S2SV_StartBug> int expected_count = 1 + extra_count ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> radix_tree_replace_slot ( pslot , newpage ) ; <S2SV_EndBug> <S2SV_StartBug> __dec_zone_page_state ( page , NR_FILE_PAGES ) ; <S2SV_EndBug> <S2SV_StartBug> __inc_zone_page_state ( newpage , NR_FILE_PAGES ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! PageSwapCache ( page ) && PageSwapBacked ( page ) ) { <S2SV_EndBug> ","<S2SV_ModStart> struct zone * oldzone , * newzone ; int dirty ; <S2SV_ModStart> oldzone = page_zone ( page ) ; newzone = page_zone ( newpage ) ; <S2SV_ModStart> dirty = PageDirty ( page ) ; if ( dirty ) { ClearPageDirty ( page ) ; SetPageDirty ( newpage ) ; } <S2SV_ModStart> spin_unlock ( & mapping -> tree_lock ) ; if ( newzone != oldzone ) { __dec_zone_state ( oldzone <S2SV_ModEnd> <S2SV_ModStart> __inc_zone_state ( newzone <S2SV_ModEnd> <S2SV_ModStart> PageSwapBacked ( page ) && <S2SV_ModStart> ) { __dec_zone_state ( oldzone , NR_SHMEM ) ; __inc_zone_state ( newzone , NR_SHMEM ) ; } if ( dirty && mapping_cap_account_dirty ( mapping ) ) { __dec_zone_state ( oldzone , NR_FILE_DIRTY ) ; __inc_zone_state ( newzone , NR_FILE_DIRTY ) ; } } local_irq_enable ( <S2SV_ModEnd> "
3597,<S2SV_StartBug> struct futex_hash_bucket * hb ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3598,"<S2SV_StartBug> static char buf [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> buflen += snprintf ( buf + buflen , sizeof ( buf ) - buflen , ""%s%s"" , <S2SV_EndBug> <S2SV_StartBug> sepstr , lp -> s ) ; <S2SV_EndBug> <S2SV_StartBug> if ( buflen == 0 ) <S2SV_EndBug> ","<S2SV_ModStart> 1024 + 1 ] ; char * bufp = buf ; size_t space_left = sizeof ( buf ) , string_size <S2SV_ModEnd> <S2SV_ModStart> if ( space_left <= 1 ) return ( buf ) ; string_size = strlcpy ( bufp , sepstr , space_left ) ; if ( string_size >= space_left ) return ( buf ) ; bufp += string_size ; space_left -= string_size ; if ( space_left <= 1 ) return ( buf ) ; string_size = strlcpy ( bufp <S2SV_ModEnd> <S2SV_ModStart> , space_left ) ; if ( string_size >= space_left ) return ( buf ) ; bufp += string_size ; space_left -= string_size <S2SV_ModEnd> <S2SV_ModStart> bufp == buf <S2SV_ModEnd> "
3599,<S2SV_StartBug> length = extent ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) "
3600,"<S2SV_StartBug> if ( ( r = ssh_packet_set_compress_state ( ssh , m ) ) != 0 || <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
3601,<S2SV_StartBug> put_device ( & bus -> dev ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3602,<S2SV_StartBug> case RESPONSE_RUN : <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> GTK_RESPONSE_OK : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_set_metadata ( parameters -> file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL , ""yes"" ) ; nautilus_file_mark_desktop_file_executable ( file , parameters -> parent_window , TRUE , NULL , NULL ) ; nautilus_file_invalidate_all_attributes ( parameters -> file ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3603,"<S2SV_StartBug> fatal ( ""Failed<S2SV_blank>to<S2SV_blank>output<S2SV_blank>file<S2SV_blank>%s"" , name ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>output<S2SV_blank>file<S2SV_blank>\'%s\'"" <S2SV_ModEnd> "
3604,<S2SV_StartBug> int n = 0 ; <S2SV_EndBug> <S2SV_StartBug> sock = ap_get_conn_socket ( r -> connection ) ; <S2SV_EndBug> <S2SV_StartBug> lua_websocket_read ( L ) ; <S2SV_EndBug> ,<S2SV_ModStart> do_read = 1 ; int <S2SV_ModStart> ; while ( do_read ) { do_read = 0 <S2SV_ModStart> do_read = 1 ; } <S2SV_ModEnd> 
3605,"<S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) ( GetQuantumRange ( depth ) + 1 ) ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> pixel . red = scale [ pixel . red ] ; <S2SV_EndBug> <S2SV_StartBug> pixel . green = scale [ pixel . green ] ; <S2SV_EndBug> <S2SV_StartBug> pixel . blue = scale [ pixel . blue ] ; <S2SV_EndBug> ",<S2SV_ModStart> if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> <= <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( pixel . red <= GetQuantumRange ( depth ) ) <S2SV_ModStart> if ( pixel . green <= GetQuantumRange ( depth ) ) <S2SV_ModStart> if ( pixel . blue <= GetQuantumRange ( depth ) ) 
3606,"<S2SV_StartBug> if ( send ( client_socket_ , data , length , 0 ) == - 1 && errno == ECONNRESET ) { <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
3607,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> count_mounts ( m -> mnt_ns , child ) <S2SV_ModEnd> "
3608,<S2SV_StartBug> if ( p -> tokenpos == p -> tokenlen ) { <S2SV_EndBug> ,<S2SV_ModStart> >= ( <S2SV_ModEnd> <S2SV_ModStart> - 1 ) 
3609,<S2SV_StartBug> char fstr [ MAXDATELEN + 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart> 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> 
3610,"<S2SV_StartBug> p = parse_tags ( render_priv , p , args [ cnt ] . end , k ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( args [ cnt ] . end < end ) { <S2SV_ModStart> } else { assert ( q == end ) ; pwr = k ; q = p ; } 
3611,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3612,<S2SV_StartBug> size_t len = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> ; luaL_checkstack ( L , 3 , ""in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_map"" ) "
3613,"<S2SV_StartBug> xcfdata = ( XCFPixelInfo * ) AcquireQuantumMemory ( data_length , sizeof ( * xcfdata ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> MagickMax ( data_length , tile_image -> columns * tile_image -> rows ) <S2SV_ModEnd> "
3614,<S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * addr_len = sizeof ( * sin ) ; 
3615,<S2SV_StartBug> if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> is_two_pass_svc ( cpi ) <S2SV_ModEnd> 
3616,"<S2SV_StartBug> fc . messages = mutt_mem_calloc ( last - first + 1 , sizeof ( unsigned char ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( fc . messages == NULL ) return - 1 
3617,<S2SV_StartBug> if ( byte [ i ] & 0x40 ) <S2SV_EndBug> ,<S2SV_ModStart> && i > 0 
3618,"<S2SV_StartBug> return xfrm6_rcv_spi ( skb , spi ) ; <S2SV_EndBug> ",<S2SV_ModStart> > 0 ? : 0 
3619,<S2SV_StartBug> unix_notinflight ( scm -> fp -> fp [ i ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> user , scm -> fp -> "
3620,<S2SV_StartBug> the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> the_url <S2SV_ModEnd> 
3621,<S2SV_StartBug> u8 smac [ ETH_ALEN ] ; <S2SV_EndBug> <S2SV_StartBug> if ( is_iboe ) { <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & lock ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3622,"<S2SV_StartBug> u8 ip_proto = 0 ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return true ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> key_basic -> n_proto = proto ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> key_basic -> n_proto = proto ; <S2SV_EndBug> <S2SV_StartBug> if ( skb_flow_dissector_uses_key ( flow_dissector , <S2SV_EndBug> ","<S2SV_ModStart> ; bool ret = false <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_good <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_good ; } goto out_good <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_PORTS ) ) { key_ports = skb_flow_dissector_target ( flow_dissector , FLOW_DISSECTOR_KEY_PORTS , target_container ) ; key_ports -> ports = __skb_flow_get_ports ( skb , nhoff , ip_proto , data , hlen ) ; } out_good : ret = true ; out_bad : <S2SV_ModStart> return ret <S2SV_ModEnd> "
3623,"<S2SV_StartBug> * lastrow , <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) NULL ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , <S2SV_EndBug> <S2SV_StartBug> 2 * image -> columns ) , sizeof ( * lastrow ) ) ; <S2SV_EndBug> <S2SV_StartBug> one_row [ i + bit ] = lastrow [ i + bit ] ; <S2SV_EndBug> <S2SV_StartBug> ( void ) CopyMagickMemory ( lastrow , one_row , bytes_per_row ) ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> ",<S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row ) ) ; if ( last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> 
3624,"<S2SV_StartBug> dbg_hid ( ""%s,<S2SV_blank>size:%d\\n"" , __func__ , size ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) { dev_err ( & hdev -> dev , ""%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\n"" , __func__ , dj_report -> device_index ) ; return false ; } "
3625,"<S2SV_StartBug> int len ; <S2SV_EndBug> <S2SV_StartBug> imapc -> mailbox = curl_easy_unescape ( data , path , 0 , & len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! imapc -> mailbox ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return Curl_urldecode <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , NULL , TRUE ) <S2SV_ModEnd> "
3626,<S2SV_StartBug> bh -> b_bdev = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> clear_buffer_delay ( bh ) ; clear_buffer_unwritten ( bh ) ; 
3627,<S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> ,<S2SV_ModStart> q -> fq = NULL ; 
3628,"<S2SV_StartBug> int parse_rock_ridge_inode ( struct iso_directory_record * de , struct inode * inode ) <S2SV_EndBug> <S2SV_StartBug> int result = parse_rock_ridge_inode_internal ( de , inode , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> result = parse_rock_ridge_inode_internal ( de , inode , 14 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int relocated ) { int flags = relocated ? RR_RELOC_DE : 0 ; <S2SV_ModEnd> <S2SV_ModStart> flags <S2SV_ModEnd> <S2SV_ModStart> flags | RR_REGARD_XA <S2SV_ModEnd> "
3629,"<S2SV_StartBug> perror ( ""malloc<S2SV_blank>(ret)"" ) ; <S2SV_EndBug> <S2SV_StartBug> image_infos = ( struct dyld_cache_image_info * ) ( bin -> b -> buf + bin -> hdr . startaddr ) ; <S2SV_EndBug> <S2SV_StartBug> dyld_vmbase = * ( ut64 * ) ( bin -> b -> buf + bin -> hdr . baseaddroff ) ; <S2SV_EndBug> <S2SV_StartBug> if ( image_infos [ idx ] . pathFileOffset > bin -> size ) { <S2SV_EndBug> <S2SV_StartBug> eprintf ( ""corrupted<S2SV_blank>file\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> libname = ( char * ) ( bin -> b -> buf + image_infos [ idx ] . pathFileOffset ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int sz = bin -> nlibs * sizeof ( struct dyld_cache_image_info ) ; image_infos = malloc ( sz ) ; if ( ! image_infos ) { free ( ret ) ; return NULL ; } r_buf_read_at <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , ( ut8 * ) image_infos , sz <S2SV_ModStart> r_buf_read64le <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> int pfo = <S2SV_ModEnd> <S2SV_ModStart> ; if ( pfo < 0 || pfo <S2SV_ModStart> ""corrupted<S2SV_blank>file:<S2SV_blank>pathFileOffset<S2SV_blank>><S2SV_blank>bin->size<S2SV_blank>(%d)\\n"" , pfo <S2SV_ModEnd> <S2SV_ModStart> r_buf_read_string <S2SV_ModEnd> <S2SV_ModStart> , pfo , 64 <S2SV_ModEnd> "
3630,<S2SV_StartBug> static ssize_t aio_setup_single_vector ( struct kiocb * kiocb ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> kiocb -> ki_iovec -> iov_len = kiocb -> ki_left ; <S2SV_EndBug> ,"<S2SV_ModStart> int type , struct file * file , <S2SV_ModStart> int bytes ; bytes = rw_verify_area ( type , file , & kiocb -> ki_pos , kiocb -> ki_left ) ; if ( bytes < 0 ) return bytes ; <S2SV_ModStart> bytes <S2SV_ModEnd> "
3631,<S2SV_StartBug> struct snd_kcontrol * kctl ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( card -> last_numid >= UINT_MAX - count ) card -> last_numid = 0 
3632,<S2SV_StartBug> struct crypto_rng * rng = __crypto_rng_cast ( tfm ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3633,"<S2SV_StartBug> struct mount * m , * child ; <S2SV_EndBug> <S2SV_StartBug> source = get_source ( m , prev_dest_mnt , prev_src_mnt , & type ) ; <S2SV_EndBug> ",<S2SV_ModStart> user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ; struct <S2SV_ModStart> ; if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED 
3634,"<S2SV_StartBug> p -> src . buf = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , i , p -> src . stride ) ] ; <S2SV_EndBug> <S2SV_StartBug> pd -> pre [ 0 ] . buf = & pd -> pre [ 0 ] . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> <S2SV_StartBug> pd -> pre [ 1 ] . buf = & pd -> pre [ 1 ] . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> ",<S2SV_ModStart> vp9_raster_block_offset <S2SV_ModEnd> <S2SV_ModStart> vp9_raster_block_offset <S2SV_ModEnd> <S2SV_ModStart> vp9_raster_block_offset <S2SV_ModEnd> 
3635,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
3636,<S2SV_StartBug> ND_TCHECK ( * pptr ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ,"<S2SV_ModStart> tptr <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""[|esis]"" ) ) <S2SV_ModEnd> "
3637,"<S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rv ) <S2SV_EndBug> <S2SV_StartBug> fs_logger2 ( ""clone"" , dest ) ; <S2SV_EndBug> ",<S2SV_ModStart> copy_file_as_user <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3638,<S2SV_StartBug> gctx = group_leader -> ctx ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & gctx -> mutex ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & gctx -> mutex ) ; <S2SV_EndBug> ,"<S2SV_ModStart> __perf_event_ctx_lock_double ( group_leader , ctx <S2SV_ModEnd> <S2SV_ModStart> if ( ! ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) { if ( gctx != ctx ) { err = - EINVAL ; goto err_locked ; } else { perf_event_ctx_unlock ( group_leader , gctx ) ; move_group = 0 ; } } <S2SV_ModStart> perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> <S2SV_ModStart> perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> "
3639,"<S2SV_StartBug> void * * p , void * end , <S2SV_EndBug> <S2SV_StartBug> void * dp , * dend ; <S2SV_EndBug> <S2SV_StartBug> struct ceph_crypto_key old_key ; <S2SV_EndBug> <S2SV_StartBug> dlen = ceph_x_decrypt ( secret , p , end , dbuf , <S2SV_EndBug> <S2SV_StartBug> tp = ticket_buf ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ceph_decode_need ( p , end , dlen , bad ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dbuf = NULL ; void * <S2SV_ModStart> ; void * ticket_buf = NULL <S2SV_ModStart> & dbuf , 0 <S2SV_ModEnd> <S2SV_ModStart> if ( is_enc ) { dout ( ""<S2SV_blank>encrypted<S2SV_blank>ticket\\n"" ) ; dlen = ceph_x_decrypt ( & old_key , p , end , & ticket_buf , 0 <S2SV_ModEnd> <S2SV_ModStart> tp = ticket_buf ; <S2SV_ModStart> ticket_buf = kmalloc ( dlen , GFP_NOFS ) ; if ( ! ticket_buf ) { ret = - ENOMEM ; goto out ; } tp = ticket_buf ; <S2SV_ModStart> kfree ( ticket_buf ) ; kfree ( dbuf ) ; "
3640,"<S2SV_StartBug> stlv_type = * ( tptr ++ ) ; <S2SV_EndBug> <S2SV_StartBug> len = len - 2 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_MCID_MIN_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> tptr = tptr + sizeof ( struct isis_subtlv_spb_mcid ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( tptr ) , stlv_len ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_BVID_MIN_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len ) <S2SV_ModStart> if ( stlv_len < ISIS_SUBTLV_SPB_MCID_MIN_LEN ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> ISIS_SUBTLV_SPB_MCID_MIN_LEN ; len = len - ISIS_SUBTLV_SPB_MCID_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_MCID_MIN_LEN <S2SV_ModEnd> <S2SV_ModStart> if ( stlv_len < ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> stlv_len = stlv_len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ; <S2SV_ModStart> while ( stlv_len <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> stlv_len = stlv_len - ISIS_SUBTLV_SPB_BVID_MIN_LEN ; <S2SV_ModStart> tptr += stlv_len ; len -= stlv_len ; "
3641,<S2SV_StartBug> ctxt -> _eip = ctxt -> src . val ; <S2SV_EndBug> <S2SV_StartBug> ctxt -> _eip = ctxt -> src . val ; <S2SV_EndBug> ,"<S2SV_ModStart> rc = assign_eip_near ( ctxt , <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( rc != X86EMUL_CONTINUE ) break <S2SV_ModStart> rc = assign_eip_near ( ctxt , <S2SV_ModEnd> <S2SV_ModStart> ) "
3642,"<S2SV_StartBug> file_sb_list_add ( f , inode -> i_sb ) ; <S2SV_EndBug> <S2SV_StartBug> file_sb_list_del ( f ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3643,<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt != NULL && inet -> opt -> srr ) { <S2SV_EndBug> <S2SV_StartBug> nexthop = inet -> opt -> faddr ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt == NULL || ! inet -> opt -> srr ) <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt != NULL ) <S2SV_EndBug> ,"<S2SV_ModStart> ; struct ip_options_rcu * inet_opt <S2SV_ModStart> inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt <S2SV_ModEnd> <S2SV_ModStart> inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt <S2SV_ModEnd> <S2SV_ModStart> inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . <S2SV_ModEnd> "
3644,"<S2SV_StartBug> strcat ( line , buf ) ; <S2SV_EndBug> <S2SV_StartBug> strcat ( line , ""<S2SV_blank>"" ) ; <S2SV_EndBug> <S2SV_StartBug> line [ strlen ( line ) - 1 ] = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> strncat ( line , buf , sizeof line ) ; strncat <S2SV_ModEnd> <S2SV_ModStart> , sizeof line <S2SV_ModStart> ( sizeof <S2SV_ModEnd> <S2SV_ModStart> '\\0' ; line [ strlen ( line ) - 1 ] = "
3645,<S2SV_StartBug> int iskew = imagew - tilew ; <S2SV_EndBug> <S2SV_StartBug> if ( colb + tilew > imagew ) { <S2SV_EndBug> ,<S2SV_ModStart> int64 iskew = ( int64 ) imagew - ( int64 ) <S2SV_ModEnd> <S2SV_ModStart> > iskew <S2SV_ModEnd> 
3646,<S2SV_StartBug> if ( isLua ( L -> ci ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3647,<S2SV_StartBug> int remaining = s -> icy_metaint - s -> icy_data_read ; <S2SV_EndBug> ,<S2SV_ModStart> uint64_t remaining ; if ( s -> icy_metaint < s -> icy_data_read ) return AVERROR_INVALIDDATA ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3648,<S2SV_StartBug> if ( len < 5 ) <S2SV_EndBug> <S2SV_StartBug> return len ; <S2SV_EndBug> ,"<S2SV_ModStart> { # ifdef CONFIG_RETPOLINE WARN_ONCE ( ""Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>JMP<S2SV_blank>in<S2SV_blank>%ps\\n"" , ( void * ) addr ) ; # endif <S2SV_ModStart> } "
3649,"<S2SV_StartBug> ret = mount ( path , destpath , ""none"" , MS_BIND , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> safe_mount ( path , destpath , ""none"" , MS_BIND , NULL , conf -> rootfs . mount <S2SV_ModEnd> "
3650,"<S2SV_StartBug> const FRAME_TYPE frame_type = cm -> frame_type ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . auto_filter == 0 ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> vp8cx_pick_filter_level ( cpi -> Source , cpi ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> filter_level > 0 ) <S2SV_EndBug> ","<S2SV_ModStart> int update_any_ref_buffers = 1 ; if ( cpi -> common . refresh_last_frame == 0 && cpi -> common . refresh_golden_frame == 0 && cpi -> common . refresh_alt_ref_frame == 0 ) { update_any_ref_buffers = 0 ; } <S2SV_ModStart> { # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity && cm -> frame_type != KEY_FRAME ) { vp8cx_pick_filter_level_fast ( & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , cpi ) ; } else { vp8cx_pick_filter_level_fast ( <S2SV_ModEnd> <S2SV_ModStart> } # else vp8cx_pick_filter_level_fast ( cpi -> Source , cpi ) ; # endif } else { # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity && cm -> frame_type != KEY_FRAME ) { vp8cx_pick_filter_level ( & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , cpi ) ; } else { vp8cx_pick_filter_level ( <S2SV_ModEnd> <S2SV_ModStart> } # else vp8cx_pick_filter_level ( cpi -> Source , cpi ) ; # endif } <S2SV_ModStart> && update_any_ref_buffers "
3651,"<S2SV_StartBug> int vp8_denoiser_filter_neon ( YV12_BUFFER_CONFIG * mc_running_avg , <S2SV_EndBug> <S2SV_StartBug> unsigned char * sig = signal -> thismb ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 16 ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> int8x16_t v_sum_diff = vdupq_n_s8 ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( abs ( sum_diff ) > SUM_DIFF_THRESHOLD ) <S2SV_EndBug> <S2SV_StartBug> vp8_copy_mem16x16 ( running_avg -> y_buffer + y_offset , running_avg_y_stride , <S2SV_EndBug> <S2SV_StartBug> signal -> thismb , sig_stride ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned char * mc_running_avg_y , int mc_running_avg_y_stride , unsigned char * running_avg_y , int running_avg_y_stride , <S2SV_ModEnd> <S2SV_ModStart> , int sig_stride , unsigned int motion_magnitude , int increase_denoising ) { int shift_inc = ( increase_denoising && motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 1 : 0 ; const uint8x16_t v_level1_adjustment = vmovq_n_u8 ( ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 4 + shift_inc : 3 ) ; const uint8x16_t v_delta_level_1_and_2 = vdupq_n_u8 ( 1 ) ; const uint8x16_t v_delta_level_2_and_3 = vdupq_n_u8 ( 2 ) ; const uint8x16_t v_level1_threshold = vmovq_n_u8 ( 4 + shift_inc ) ; const uint8x16_t v_level2_threshold = vdupq_n_u8 ( 8 ) ; const uint8x16_t v_level3_threshold = vdupq_n_u8 ( 16 ) ; int64x2_t v_sum_diff_total = vdupq_n_s64 ( 0 ) ; int r <S2SV_ModEnd> <S2SV_ModStart> r <S2SV_ModEnd> <S2SV_ModStart> r <S2SV_ModEnd> <S2SV_ModStart> r ) { const uint8x16_t v_sig = vld1q_u8 ( sig ) ; const uint8x16_t v_mc_running_avg_y = vld1q_u8 ( mc_running_avg_y ) ; const uint8x16_t v_abs_diff = vabdq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_pos_mask = vcltq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_neg_mask = vcgtq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_level1_mask = vcleq_u8 ( v_level1_threshold , v_abs_diff ) ; const uint8x16_t v_level2_mask = vcleq_u8 ( v_level2_threshold , v_abs_diff ) ; const uint8x16_t v_level3_mask = vcleq_u8 ( v_level3_threshold , v_abs_diff ) ; const uint8x16_t v_level2_adjustment = vandq_u8 ( v_level2_mask , v_delta_level_1_and_2 ) ; const uint8x16_t v_level3_adjustment = vandq_u8 ( v_level3_mask , v_delta_level_2_and_3 ) ; const uint8x16_t v_level1and2_adjustment = vaddq_u8 ( v_level1_adjustment , v_level2_adjustment ) ; const uint8x16_t v_level1and2and3_adjustment = vaddq_u8 ( v_level1and2_adjustment , v_level3_adjustment ) ; const uint8x16_t v_abs_adjustment = vbslq_u8 ( v_level1_mask , v_level1and2and3_adjustment , v_abs_diff ) ; const uint8x16_t v_pos_adjustment = vandq_u8 ( v_diff_pos_mask , v_abs_adjustment ) ; const uint8x16_t v_neg_adjustment = vandq_u8 ( v_diff_neg_mask , v_abs_adjustment ) ; uint8x16_t v_running_avg_y = vqaddq_u8 ( v_sig , v_pos_adjustment ) ; v_running_avg_y = vqsubq_u8 ( v_running_avg_y , v_neg_adjustment ) ; vst1q_u8 ( running_avg_y , v_running_avg_y ) ; { const <S2SV_ModEnd> <S2SV_ModStart> vqsubq_s8 ( vreinterpretq_s8_u8 ( v_pos_adjustment ) , vreinterpretq_s8_u8 ( v_neg_adjustment ) ) ; const int16x8_t fe_dc_ba_98_76_54_32_10 = vpaddlq_s8 ( v_sum_diff ) ; const int32x4_t fedc_ba98_7654_3210 = vpaddlq_s16 ( fe_dc_ba_98_76_54_32_10 ) ; const int64x2_t fedcba98_76543210 = vpaddlq_s32 ( fedc_ba98_7654_3210 ) ; v_sum_diff_total = vqaddq_s64 ( v_sum_diff_total , fedcba98_76543210 ) <S2SV_ModEnd> <S2SV_ModStart> { int64x1_t x = vqadd_s64 ( vget_high_s64 ( v_sum_diff_total ) , vget_low_s64 ( v_sum_diff_total ) ) ; int sum_diff = vget_lane_s32 ( vabs_s32 ( vreinterpret_s32_s64 ( x ) ) , 0 ) ; int sum_diff_thresh = SUM_DIFF_THRESHOLD ; if ( increase_denoising ) sum_diff_thresh = SUM_DIFF_THRESHOLD_HIGH ; if ( sum_diff > sum_diff_thresh ) { int delta = ( ( sum_diff - sum_diff_thresh ) >> 8 ) + 1 ; if ( delta < 4 ) { const uint8x16_t k_delta = vmovq_n_u8 ( delta ) ; sig -= sig_stride * 16 ; mc_running_avg_y -= mc_running_avg_y_stride * 16 ; running_avg_y -= running_avg_y_stride * 16 ; for ( r = 0 ; r < 16 ; ++ r ) { uint8x16_t v_running_avg_y = vld1q_u8 ( running_avg_y ) ; const uint8x16_t v_sig = vld1q_u8 ( sig ) ; const uint8x16_t v_mc_running_avg_y = vld1q_u8 ( mc_running_avg_y ) ; const uint8x16_t v_abs_diff = vabdq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_pos_mask = vcltq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_neg_mask = vcgtq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_abs_adjustment = vminq_u8 ( v_abs_diff , ( k_delta ) ) ; const uint8x16_t v_pos_adjustment = vandq_u8 ( v_diff_pos_mask , v_abs_adjustment ) ; const uint8x16_t v_neg_adjustment = vandq_u8 ( v_diff_neg_mask , v_abs_adjustment ) ; v_running_avg_y = vqsubq_u8 ( v_running_avg_y , v_pos_adjustment ) ; v_running_avg_y = vqaddq_u8 ( v_running_avg_y , v_neg_adjustment ) ; vst1q_u8 ( running_avg_y , v_running_avg_y ) ; { const int8x16_t v_sum_diff = vqsubq_s8 ( vreinterpretq_s8_u8 ( v_neg_adjustment ) , vreinterpretq_s8_u8 ( v_pos_adjustment ) ) ; const int16x8_t fe_dc_ba_98_76_54_32_10 = vpaddlq_s8 ( v_sum_diff ) ; const int32x4_t fedc_ba98_7654_3210 = vpaddlq_s16 ( fe_dc_ba_98_76_54_32_10 ) ; const int64x2_t fedcba98_76543210 = vpaddlq_s32 ( fedc_ba98_7654_3210 ) ; v_sum_diff_total = vqaddq_s64 ( v_sum_diff_total , fedcba98_76543210 ) ; } sig += sig_stride ; mc_running_avg_y += mc_running_avg_y_stride ; running_avg_y += running_avg_y_stride ; } { x = vqadd_s64 ( vget_high_s64 ( v_sum_diff_total ) , vget_low_s64 ( v_sum_diff_total ) ) ; sum_diff = vget_lane_s32 ( vabs_s32 ( vreinterpret_s32_s64 ( x ) ) , 0 ) ; if ( sum_diff > sum_diff_thresh ) { <S2SV_ModEnd> <S2SV_ModStart> } } } else { return COPY_BLOCK ; } } } running_avg_y -= running_avg_y_stride * 16 ; sig -= sig_stride * 16 ; vp8_copy_mem16x16 ( running_avg_y <S2SV_ModEnd> <S2SV_ModStart> sig <S2SV_ModEnd> "
3652,"<S2SV_StartBug> if ( unlikely ( copied == 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> iov_iter_advance ( i , copied ) ; <S2SV_EndBug> ","<S2SV_ModStart> iov_iter_advance ( i , copied ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
3653,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> return TEE_SUCCESS ; <S2SV_EndBug> ,"<S2SV_ModStart> size_t req_size = 0 ; <S2SV_ModStart> if ( ADD_OVERFLOW ( mem -> offs , mem -> size , & req_size ) || mem -> mobj -> size < req_size ) return TEE_ERROR_SECURITY ; "
3654,"<S2SV_StartBug> gchar * filename ; <S2SV_EndBug> <S2SV_StartBug> filename = g_build_filename ( g_get_tmp_dir ( ) , ""gimp-test.xcf"" , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> = NULL ; gint file_handle <S2SV_ModStart> file_handle = g_file_open_tmp ( ""gimp-test-XXXXXX.xcf"" , & filename , NULL ) ; g_assert ( file_handle != - 1 ) ; close ( file_handle <S2SV_ModEnd> "
3655,"<S2SV_StartBug> xdr_free ( xdr_func , xdr_ptr ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
3656,"<S2SV_StartBug> if ( pos > CDF_SEC_SIZE ( h ) * sst -> sst_len ) { <S2SV_EndBug> <S2SV_StartBug> pos , CDF_SEC_SIZE ( h ) * sst -> sst_len ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> + len <S2SV_ModStart> + len 
3657,<S2SV_StartBug> for ( i = num_excl_chan ; i < num_excl_chan + 7 ; i ++ ) <S2SV_EndBug> ,<S2SV_ModStart> if ( i >= MAX_CHANNELS - num_excl_chan - 7 ) return n ; 
3658,"<S2SV_StartBug> int ctrl_id , <S2SV_EndBug> <S2SV_StartBug> vp8_decrypt_init * init = va_arg ( args , vp8_decrypt_init * ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_decrypt_init <S2SV_ModEnd> <S2SV_ModStart> vpx_decrypt_init <S2SV_ModEnd> 
3659,<S2SV_StartBug> zval_ptr_dtor ( value ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3660,"<S2SV_StartBug> if ( can_open_cached ( data -> state , data -> o_arg . open_flags & ( FMODE_READ | FMODE_WRITE | O_EXCL ) ) ) <S2SV_EndBug> ","<S2SV_ModStart> fmode , data -> o_arg . open_flags <S2SV_ModEnd> "
3661,<S2SV_StartBug> struct hci_filter * f = & hci_pi ( sk ) -> filter ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & uf , 0 , sizeof ( uf ) ) "
3662,"
","
"
3663,"<S2SV_StartBug> struct scatterlist sg [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> sg_init_one ( sg , buf , count ) ; <S2SV_EndBug> <S2SV_StartBug> return __send_to_port ( port , sg , 1 , count , ( void * ) buf , false ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ; void * data ; int ret <S2SV_ModStart> data = kmemdup ( buf , count , GFP_ATOMIC ) ; if ( ! data ) return - ENOMEM ; <S2SV_ModStart> data <S2SV_ModEnd> <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> data <S2SV_ModEnd> <S2SV_ModStart> kfree ( data ) ; return ret ; "
3664,"<S2SV_StartBug> metadatalength = GetDuration ( mp4 ) ; <S2SV_EndBug> <S2SV_StartBug> float in = 0.0 , out = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> uint32_t fourcc = GPMF_Key ( ms ) ; <S2SV_EndBug> <S2SV_StartBug> double rate = GetGPMFSampleRate ( mp4 , fourcc , GPMF_SAMPLE_RATE_PRECISE ) ; <S2SV_EndBug> <S2SV_StartBug> printf ( ""%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz\\n"" , PRINTF_4CC ( fourcc ) , rate ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( mp4 == 0 ) { printf ( ""error:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>MP4/MOV\\n"" , argv [ 1 ] ) ; return - 1 ; } <S2SV_ModStart> double <S2SV_ModEnd> <S2SV_ModStart> double in = 0.0 , out = 0.0 ; <S2SV_ModStart> , & in , & out ) ; printf ( ""%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz<S2SV_blank>(from<S2SV_blank>%f<S2SV_blank>to<S2SV_blank>%f)\\n"" <S2SV_ModEnd> <S2SV_ModStart> , in , out "
3665,<S2SV_StartBug> cur_logical ++ ; <S2SV_EndBug> ,<S2SV_ModStart> if ( buffer_uninit ( exbh ) ) set_buffer_uninit ( bh ) ; 
3666,"<S2SV_StartBug> return put_user ( tty -> ldisc -> ops -> num , ( int __user * ) p ) ; <S2SV_EndBug> ","<S2SV_ModStart> tiocgetd ( tty , <S2SV_ModEnd> "
3667,"<S2SV_StartBug> uint32_t track_size ; <S2SV_EndBug> <S2SV_StartBug> track_delta = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_EndBug> <S2SV_StartBug> track_size = * midi_data ++ << 24 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ << 16 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ << 8 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( midi_size < track_size ) { <S2SV_EndBug> <S2SV_StartBug> if ( track_size < 3 ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( midi_data [ track_size - 3 ] != 0xFF ) <S2SV_EndBug> <S2SV_StartBug> || ( midi_data [ track_size - 2 ] != 0x2F ) <S2SV_EndBug> <S2SV_StartBug> || ( midi_data [ track_size - 1 ] != 0x00 ) ) { <S2SV_EndBug> <S2SV_StartBug> midi_data += track_size ; <S2SV_EndBug> <S2SV_StartBug> midi_size -= track_size ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> goto NEXT_TRACK ; <S2SV_EndBug> <S2SV_StartBug> if ( * tracks [ i ] > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( * tracks [ i ] > 0x7f ) ; <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( * tracks [ i ] > 0x7f ) ; <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( mdi -> reverb ) return ( mdi ) ; <S2SV_EndBug> ","<S2SV_ModStart> uint8_t * * tracks ; uint32_t * track_size <S2SV_ModEnd> <S2SV_ModStart> track_size = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> track_size [ i ] = tmp_val ; midi_data += tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> track_size [ i ] -- ; <S2SV_ModStart> ; track_size [ i ] -- <S2SV_ModStart> track_size [ i ] , <S2SV_ModStart> track_size [ i ] -= 3 ; <S2SV_ModStart> track_size [ i ] -= setup_ret ; <S2SV_ModStart> if ( ! track_size [ i ] ) break ; <S2SV_ModStart> track_size [ i ] -- ; <S2SV_ModStart> if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_ModStart> ; track_size [ i ] -- <S2SV_ModStart> track_size [ i ] , <S2SV_ModStart> track_size [ i ] -= setup_ret ; <S2SV_ModStart> if ( ! track_size [ i ] ) break ; <S2SV_ModStart> track_size [ i ] -- ; <S2SV_ModStart> if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_ModStart> ; track_size [ i ] -- <S2SV_ModStart> free ( track_size ) ; "
3668,<S2SV_StartBug> if ( group_leader -> ctx -> type != ctx -> type ) <S2SV_EndBug> ,<S2SV_ModStart> task <S2SV_ModEnd> <S2SV_ModStart> task ) goto err_context ; if ( group_leader -> cpu != event -> cpu <S2SV_ModEnd> 
3669,"<S2SV_StartBug> ps_codec -> s_parse . i4_cur_slice_idx = MAX ( 0 , ( ps_codec -> s_parse . i4_cur_slice_idx - 1 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
3670,<S2SV_StartBug> struct br_mdb_entry entry ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & entry , 0 , sizeof ( entry ) ) "
3671,<S2SV_StartBug> free ( p ) ; <S2SV_EndBug> ,<S2SV_ModStart> * pp = p -> next ; 
3672,"<S2SV_StartBug> char * dbuf ; <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = process_one_ticket ( ac , secret , & p , end , <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> ret = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return ret ; } return 0 <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3673,"<S2SV_StartBug> int fit_config_verify_required_sigs ( const void * fit , int conf_noffset , <S2SV_EndBug> <S2SV_StartBug> int noffset ; <S2SV_EndBug> <S2SV_StartBug> const char * reqd_mode ; <S2SV_EndBug> ","<S2SV_ModStart> static <S2SV_ModStart> const char * name = fit_get_name ( fit , conf_noffset , NULL ) ; <S2SV_ModStart> if ( strchr ( name , '@' ) ) { printf ( ""Configuration<S2SV_blank>node<S2SV_blank>\'%s\'<S2SV_blank>contains<S2SV_blank>\'@\'\\n"" , name ) ; return - EPERM ; } "
3674,<S2SV_StartBug> void vp9_rc_init_minq_luts ( ) { <S2SV_EndBug> ,"<S2SV_ModStart> void ) { init_minq_luts ( kf_low_motion_minq_8 , kf_high_motion_minq_8 , arfgf_low_motion_minq_8 , arfgf_high_motion_minq_8 , inter_minq_8 , rtc_minq_8 , VPX_BITS_8 ) ; # if CONFIG_VP9_HIGHBITDEPTH init_minq_luts ( kf_low_motion_minq_10 , kf_high_motion_minq_10 , arfgf_low_motion_minq_10 , arfgf_high_motion_minq_10 , inter_minq_10 , rtc_minq_10 , VPX_BITS_10 ) ; init_minq_luts ( kf_low_motion_minq_12 , kf_high_motion_minq_12 , arfgf_low_motion_minq_12 , arfgf_high_motion_minq_12 , inter_minq_12 , rtc_minq_12 , VPX_BITS_12 ) ; # endif <S2SV_ModEnd> "
3675,<S2SV_StartBug> if ( log_mode != LOG_MODE_CONFIGURED || new_mode != LOG_MODE_ERROR ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3676,"<S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> ","<S2SV_ModStart> | CVAR_PROTECTED <S2SV_ModStart> if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; } "
3677,<S2SV_StartBug> if ( args -> buffer_count < 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> || args -> buffer_count > UINT_MAX / sizeof ( * exec2_list ) 
3678,"<S2SV_StartBug> p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ; <S2SV_EndBug> <S2SV_StartBug> pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , & unmounted ) ; <S2SV_EndBug> <S2SV_StartBug> umount_mnt ( p ) ; <S2SV_EndBug> <S2SV_StartBug> change_mnt_propagation ( p , MS_PRIVATE ) ; <S2SV_EndBug> ","<S2SV_ModStart> bool disconnect ; <S2SV_ModStart> disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_ModStart> disconnect ? & unmounted : NULL <S2SV_ModEnd> <S2SV_ModStart> if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { <S2SV_ModStart> } "
3679,"<S2SV_StartBug> if ( tmp_line [ tmp_line_len - 1 ] == '\\n' ) { <S2SV_EndBug> <S2SV_StartBug> if ( tmp_line [ tmp_line_len - 1 ] == '\\r' ) { <S2SV_EndBug> <S2SV_StartBug> # define CHECK_FOR_CNTRL_CHARS ( val ) { if ( val ) { unsigned char * s , * e ; int l ; l = php_url_decode ( val , strlen ( val ) ) ; s = ( unsigned char * ) val ; e = s + l ; while ( s < e ) { if ( iscntrl ( * s ) ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s"" , new_path ) ; goto out ; } s ++ ; } } } <S2SV_EndBug> ",<S2SV_ModStart> tmp_line_len >= 1 && <S2SV_ModStart> tmp_line_len >= 1 && <S2SV_ModStart> \\\n} <S2SV_ModEnd> 
3680,<S2SV_StartBug> char added ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3681,"<S2SV_StartBug> if ( disk != NULL ) { <S2SV_EndBug> <S2SV_StartBug> const int blocksize = 512 ; <S2SV_EndBug> <S2SV_StartBug> if ( bio ) iob = bio ; <S2SV_EndBug> <S2SV_StartBug> ret = iob -> read_at ( iob -> io , delta + ( blocksize * sector ) , <S2SV_EndBug> <S2SV_StartBug> ( ut8 * ) buf , size * blocksize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret == - 1 ) <S2SV_EndBug> <S2SV_StartBug> } else eprintf ( ""oops.<S2SV_blank>no<S2SV_blank>disk\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ! disk ) { eprintf ( ""oops.<S2SV_blank>no<S2SV_blank>disk\\n"" ) ; return 1 ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart>  <S2SV_ModEnd> "
3682,"<S2SV_StartBug> return put_user ( tty -> ldisc -> ops -> num , ( int __user * ) p ) ; <S2SV_EndBug> ","<S2SV_ModStart> tiocgetd ( tty , <S2SV_ModEnd> "
3683,<S2SV_StartBug> start = vma -> vm_start ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! mmget_still_valid ( mm ) ) return NULL ; 
3684,<S2SV_StartBug> error = ERROR_END_OF_STREAM ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> error = ERROR_FAILURE ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> } 
3685,"<S2SV_StartBug> vp9_writer residual_bc ; <S2SV_EndBug> <S2SV_StartBug> TOKENEXTRA * tok [ 4 ] [ 1 << 6 ] , * tok_end ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cm -> above_seg_context , 0 , sizeof ( * cm -> above_seg_context ) * <S2SV_EndBug> <S2SV_StartBug> tok [ 0 ] [ 0 ] = cpi -> tok ; <S2SV_EndBug> <S2SV_StartBug> tok_end = tok [ tile_row ] [ tile_col ] + cpi -> tok_count [ tile_row ] [ tile_col ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_start_encode ( & residual_bc , data_ptr + total_size + 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_start_encode ( & residual_bc , data_ptr + total_size ) ; <S2SV_EndBug> <S2SV_StartBug> write_modes ( cpi , & tile , & residual_bc , & tok [ tile_row ] [ tile_col ] , tok_end ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( tok [ tile_row ] [ tile_col ] == tok_end ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_stop_encode ( & residual_bc ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> for ( tile_row = 0 ; tile_row < tile_rows ; tile_row ++ ) { for ( tile_col = 0 ; tile_col < tile_cols ; tile_col ++ ) { int tile_idx = tile_row * tile_cols + tile_col ; TOKENEXTRA * tok = cpi -> tile_tok [ tile_row ] [ tile_col ] <S2SV_ModEnd> <S2SV_ModStart> cpi -> tile_tok [ tile_row ] [ tile_col ] + <S2SV_ModEnd> <S2SV_ModStart> vpx_start_encode <S2SV_ModEnd> <S2SV_ModStart> vpx_start_encode <S2SV_ModEnd> <S2SV_ModStart> cpi -> tile_data [ tile_idx ] . tile_info , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_stop_encode <S2SV_ModEnd> "
3686,<S2SV_StartBug> struct channel_info * info = <S2SV_EndBug> ,<S2SV_ModStart> ; if ( voice < 0 || voice >= devc -> nr_voice ) return ; if ( chn < 0 || chn > 15 ) return ; info 
3687,<S2SV_StartBug> for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) <S2SV_EndBug> ,<S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> 
3688,<S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * addr_len = sizeof ( * sin ) ; 
3689,"<S2SV_StartBug> static void reset_fpf_position ( struct twopass_rc * p , <S2SV_EndBug> ",<S2SV_ModStart> TWO_PASS <S2SV_ModEnd> 
3690,<S2SV_StartBug> if ( offset > ds || offset + 6 > ds ) { <S2SV_EndBug> ,<S2SV_ModStart> - 6 <S2SV_ModEnd> 
3691,<S2SV_StartBug> opt2 -> tot_len = tot_len ; <S2SV_EndBug> ,"<S2SV_ModStart> atomic_set ( & opt2 -> refcnt , 1 ) ; "
3692,"<S2SV_StartBug> if ( ( packetLength > INT_MAX ) || ! Stream_EnsureCapacity ( s , packetLength ) ) <S2SV_EndBug> ",<S2SV_ModStart> || ( packetLength < header ) 
3693,"<S2SV_StartBug> static struct fsnotify_group * inotify_new_group ( struct user_struct * user , unsigned int max_events ) <S2SV_EndBug> <S2SV_StartBug> group -> inotify_data . user = user ; <S2SV_EndBug> <S2SV_StartBug> group -> inotify_data . fa = NULL ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> fa = NULL <S2SV_ModEnd> <S2SV_ModStart> user = get_current_user ( ) ; if ( atomic_inc_return ( & group -> inotify_data . user -> inotify_devs ) > inotify_max_user_instances ) { fsnotify_put_group ( group ) ; return ERR_PTR ( - EMFILE ) ; } <S2SV_ModEnd> 
3694,<S2SV_StartBug> asoc -> peer . i = new -> peer . i ; <S2SV_EndBug> ,<S2SV_ModStart> auth_capable = new -> peer . auth_capable ; asoc -> peer . 
3695,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( length > 3 ) { <S2SV_EndBug> <S2SV_StartBug> print_string ( ndo , dat + 3 , length - 3 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( length < 3 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModStart> dat += 3 ; length -= 3 ; <S2SV_ModStart> != 0 <S2SV_ModEnd> <S2SV_ModStart> , length <S2SV_ModEnd> "
3696,<S2SV_StartBug> cur_token = * indx ; <S2SV_EndBug> <S2SV_StartBug> res = r ; <S2SV_EndBug> ,<S2SV_ModStart> clist * list ; <S2SV_ModStart> ; goto free_display_name ; } list = clist_new ( ) ; if ( list == NULL ) { res = MAILIMF_ERROR_MEMORY ; goto free_display_name ; } mailbox_list = mailimf_mailbox_list_new ( list ) ; if ( mailbox_list == NULL ) { res = MAILIMF_ERROR_MEMORY ; clist_free ( list ) 
3697,<S2SV_StartBug> kfree ( ubufs ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3698,"<S2SV_StartBug> void fdct16_sse2 ( __m128i * in0 , __m128i * in1 ) { <S2SV_EndBug> ",<S2SV_ModStart> static 
3699,<S2SV_StartBug> ACPI_FUNCTION_TRACE ( ns_terminate ) ; <S2SV_EndBug> <S2SV_StartBug> union acpi_operand_object * next ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; ACPI_FUNCTION_TRACE ( ns_terminate ) <S2SV_ModStart>  <S2SV_ModEnd> 
3700,<S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> { tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ; <S2SV_ModStart> } 
3701,<S2SV_StartBug> free ( ctx ) ; <S2SV_EndBug> ,<S2SV_ModStart> # if CONFIG_MULTITHREAD pthread_mutex_destroy ( & ctx -> buffer_pool -> pool_mutex ) ; # endif vpx_free ( ctx -> buffer_pool ) ; vpx_free <S2SV_ModEnd> 
3702,<S2SV_StartBug> bool is_drop_n_account = false ; <S2SV_EndBug> <S2SV_StartBug> if ( po -> has_vnet_hdr ) <S2SV_EndBug> <S2SV_StartBug> macoff = netoff - maclen ; <S2SV_EndBug> <S2SV_StartBug> if ( ( int ) snaplen < 0 ) <S2SV_EndBug> <S2SV_StartBug> snaplen = 0 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( po -> has_vnet_hdr ) { <S2SV_EndBug> ,<S2SV_ModStart> = false ; bool do_vnet <S2SV_ModStart> { <S2SV_ModStart> do_vnet = true ; } <S2SV_ModStart> { <S2SV_ModStart> do_vnet = false ; } <S2SV_ModStart> do_vnet = false ; <S2SV_ModStart> do_vnet <S2SV_ModEnd> 
3703,"<S2SV_StartBug> memcpy ( own_dir , ""."" , 2 ) ; <S2SV_EndBug> ","<S2SV_ModStart> # ifdef SUPER_SECURE memcpy ( own_dir , ""/dev/null/"" , 2 ) ; # else <S2SV_ModStart> # endif "
3704,"<S2SV_StartBug> static int can_open_delegated ( struct nfs_delegation * delegation , mode_t open_flags ) <S2SV_EndBug> <S2SV_StartBug> if ( ( delegation -> type & open_flags ) != open_flags ) <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode ) != fmode <S2SV_ModEnd> 
3705,"<S2SV_StartBug> unsigned short sel ; <S2SV_EndBug> <S2SV_StartBug> rc = load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) ; <S2SV_EndBug> <S2SV_StartBug> ctxt -> _eip = 0 ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> ","<S2SV_ModStart> , old_sel ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; u8 cpl = ctxt -> ops -> cpl ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_sel , & old_desc , NULL , VCPU_SREG_CS ) <S2SV_ModStart> __load_segment_descriptor <S2SV_ModEnd> <S2SV_ModStart> , cpl , false , & new_desc <S2SV_ModStart> rc = assign_eip_far ( ctxt <S2SV_ModEnd> <S2SV_ModStart> val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_sel , & old_desc , 0 , VCPU_SREG_CS <S2SV_ModEnd> <S2SV_ModStart> rc ; } return rc <S2SV_ModEnd> "
3706,"<S2SV_StartBug> static vpx_codec_err_t vp8_get_frame_corrupted ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> <S2SV_StartBug> * corrupted = pbi -> common . frame_to_show -> corrupted ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const YV12_BUFFER_CONFIG * const frame <S2SV_ModEnd> <S2SV_ModStart> ; if ( frame == NULL ) return VPX_CODEC_ERROR ; * corrupted = frame 
3707,"<S2SV_StartBug> char src [ PATH_MAX + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( src , dir , dir_len ) ; <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> if ( dir_len > PATH_MAX ) { uwsgi_log ( ""invalid<S2SV_blank>path<S2SV_blank>size:<S2SV_blank>%d<S2SV_blank>(max<S2SV_blank>%d)\\n"" , dir_len , PATH_MAX ) ; return NULL ; } char * src = uwsgi_concat2n ( <S2SV_ModEnd> <S2SV_ModStart> , """" , 0 ) <S2SV_ModEnd> <S2SV_ModStart> free ( src ) ; <S2SV_ModStart> free ( src ) ; "
3708,"<S2SV_StartBug> int index , count , i ; <S2SV_EndBug> <S2SV_StartBug> int index , count , i ; <S2SV_EndBug> ",<S2SV_ModStart> unsigned <S2SV_ModStart> unsigned 
3709,"<S2SV_StartBug> return mptctl_getiocinfo ( arg , _IOC_SIZE ( cmd ) ) ; <S2SV_EndBug> <S2SV_StartBug> return mptctl_gettargetinfo ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> return mptctl_readtest ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> return mptctl_eventquery ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> return mptctl_eventenable ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> return mptctl_eventreport ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> return mptctl_replace_fw ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> ret = mptctl_fw_download ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> ret = mptctl_mpt_command ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> ret = mptctl_do_reset ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> ret = mptctl_hp_hostinfo ( arg , _IOC_SIZE ( cmd ) ) ; <S2SV_EndBug> <S2SV_StartBug> ret = mptctl_hp_targetinfo ( arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> iocp , <S2SV_ModStart> iocp , <S2SV_ModStart> iocp , <S2SV_ModStart> iocp , <S2SV_ModStart> iocp , <S2SV_ModStart> iocp , <S2SV_ModStart> iocp , <S2SV_ModStart> iocp , <S2SV_ModStart> iocp , <S2SV_ModStart> iocp , <S2SV_ModStart> iocp , <S2SV_ModStart> iocp , "
3710,"<S2SV_StartBug> int xt_check_entry_offsets ( const void * base , <S2SV_EndBug> <S2SV_StartBug> const struct xt_entry_target * t ; <S2SV_EndBug> <S2SV_StartBug> const char * e = base ; <S2SV_EndBug> ","<S2SV_ModStart> , const char * elems <S2SV_ModStart> long size_of_base_struct = elems - ( const char * ) base ; <S2SV_ModStart> ; if ( target_offset < size_of_base_struct ) return - EINVAL "
3711,<S2SV_StartBug> goto end ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3712,<S2SV_StartBug> assert ( bidx <= PCI_BARMAX ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( pdi -> bar [ bidx ] . type == PCIBAR_MEM32 || <S2SV_EndBug> <S2SV_StartBug> pdi -> bar [ bidx ] . type == PCIBAR_MEM64 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( addr + size > <S2SV_ModEnd> <S2SV_ModStart> addr + <S2SV_ModEnd> <S2SV_ModStart> size ) { pr_err ( ""%s,<S2SV_blank>Out<S2SV_blank>of<S2SV_blank>emulated<S2SV_blank>memory<S2SV_blank>range\\n"" , __func__ ) ; return - ESRCH ; } <S2SV_ModEnd> "
3713,"<S2SV_StartBug> void jas_seq2d_bindsub ( jas_matrix_t * s , jas_matrix_t * s1 , int xstart , <S2SV_EndBug> ","<S2SV_ModStart> jas_matind_t xstart , jas_matind_t ystart , jas_matind_t xend , jas_matind_t <S2SV_ModEnd> "
3714,<S2SV_StartBug> INIT_LIST_HEAD ( & card -> controls ) ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_init ( & card -> user_ctl_lock ) ; 
3715,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
3716,"<S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . last_ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . last_mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
3717,<S2SV_StartBug> struct usb_serial * serial = port -> serial ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3718,"<S2SV_StartBug> UINT16 count ; <S2SV_EndBug> <S2SV_StartBug> newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate -> rectangles , <S2SV_EndBug> ",<S2SV_ModStart> UINT32 <S2SV_ModEnd> <S2SV_ModStart> BITMAP_DATA * 
3719,<S2SV_StartBug> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! tmp ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; 
3720,"<S2SV_StartBug> if ( ext_depth ( inode ) ) <S2SV_EndBug> <S2SV_StartBug> memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data , <S2SV_EndBug> <S2SV_StartBug> sizeof ( EXT4_I ( inode ) -> i_data ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t ext_size = 0 ; <S2SV_ModStart> ext_size = sizeof ( EXT4_I ( inode ) -> i_data ) ; <S2SV_ModStart> ext_size ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size <S2SV_ModEnd> "
3721,<S2SV_StartBug> newinet -> opt = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> inet_opt <S2SV_ModEnd> 
3722,"<S2SV_StartBug> return touch_file ( path , false , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> MODE_INVALID <S2SV_ModEnd> 
3723,"<S2SV_StartBug> error = scsi_nonblockable_ioctl ( sdp , cmd , p , <S2SV_EndBug> ","<S2SV_ModStart> scsi_verify_blk_ioctl ( bdev , cmd ) ; if ( error < 0 ) return error ; error = "
3724,<S2SV_StartBug> size += service_name_tlv_length ; <S2SV_EndBug> <S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! service_name_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; } 
3725,"<S2SV_StartBug> memcpy ( & p -> id , & x -> id , sizeof ( p -> id ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( p , 0 , sizeof ( * p ) ) ; "
3726,<S2SV_StartBug> frame_end : <S2SV_EndBug> ,<S2SV_ModStart> if ( ! s -> studio_profile ) 
3727,<S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> ,<S2SV_ModStart> = { 0 } 
3728,"<S2SV_StartBug> int vp9_compute_qdelta ( const RATE_CONTROL * rc , double qstart , double qtarget ) { <S2SV_EndBug> <S2SV_StartBug> if ( vp9_convert_qindex_to_q ( i ) >= qstart ) <S2SV_EndBug> <S2SV_StartBug> if ( vp9_convert_qindex_to_q ( i ) >= qtarget ) <S2SV_EndBug> ","<S2SV_ModStart> , vpx_bit_depth_t bit_depth <S2SV_ModStart> , bit_depth <S2SV_ModStart> , bit_depth "
3729,<S2SV_StartBug> const char * old_name ; <S2SV_EndBug> <S2SV_StartBug> old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ; <S2SV_EndBug> <S2SV_StartBug> fsnotify_oldname_free ( old_name ) ; <S2SV_EndBug> ,"<S2SV_ModStart> struct name_snapshot <S2SV_ModEnd> <S2SV_ModStart> take_dentry_name_snapshot ( & old_name , old_dentry ) ; error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ; if ( error ) { release_dentry_name_snapshot ( & old_name ) ; goto exit ; } d_move ( old_dentry , dentry ) ; fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name . name <S2SV_ModEnd> <S2SV_ModStart> release_dentry_name_snapshot ( & <S2SV_ModEnd> "
3730,"<S2SV_StartBug> static unsigned int XBMInteger ( Image * image , short int * hex_digits ) <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> return ( value ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> - 1 <S2SV_ModEnd> <S2SV_ModStart> - 1 <S2SV_ModEnd> <S2SV_ModStart> ( int ) 
3731,<S2SV_StartBug> uint16_t keylen ; <S2SV_EndBug> <S2SV_StartBug> uint16_t keylen ; <S2SV_EndBug> ,<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int <S2SV_ModEnd> 
3732,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3733,<S2SV_StartBug> if ( uniforms_offset < shader_rec_offset || <S2SV_EndBug> ,<S2SV_ModStart> shader_rec_offset < args -> bin_cl_size || 
3734,<S2SV_StartBug> if ( s ) { <S2SV_EndBug> <S2SV_StartBug> struct unix_sock * u = unix_sk ( s ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock ( & unix_gc_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> spin_lock ( & unix_gc_lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } fp -> f_cred -> user -> unix_inflight ++ ; <S2SV_ModStart>  <S2SV_ModEnd> 
3735,<S2SV_StartBug> newinet -> opt = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> inet_opt <S2SV_ModEnd> 
3736,"<S2SV_StartBug> dtls1_process_buffered_records ( s ) ; <S2SV_EndBug> <S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( <S2SV_ModStart> < 0 ) return - 1 <S2SV_ModStart> if ( <S2SV_ModStart> ) < 0 ) return - 1 ; dtls1_record_bitmap_update ( s , bitmap <S2SV_ModStart> dtls1_record_bitmap_update ( s , bitmap ) ; "
3737,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> atomic_set ( & opt2 -> refcnt , 1 ) ; "
3738,<S2SV_StartBug> key_pairs = palloc ( sizeof ( Pairs ) * key_count ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ; "
3739,"<S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 , <S2SV_EndBug> <S2SV_StartBug> int * totrate , int64_t * totdist ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; <S2SV_EndBug> <S2SV_StartBug> int rate = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> subsize = ( bsize >= BLOCK_8X8 ) ? mi_8x8 [ 0 ] -> mbmi . sb_type : BLOCK_4X4 ; <S2SV_EndBug> <S2SV_StartBug> switch ( partition ) { <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> if ( mi_col + hbs < cm -> mi_cols ) { <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col + hbs , <S2SV_EndBug> <S2SV_StartBug> if ( rate != INT_MAX && dist != INT64_MAX && <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> if ( mi_row + hbs < cm -> mi_rows ) { <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row + hbs , mi_col , <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> mic . mbmi = mi_8x8 [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> if ( rate != INT_MAX && dist != INT64_MAX && <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> subsize , output_enabled , totrate , totdist ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 + hbs , tp , <S2SV_EndBug> <S2SV_StartBug> & rate , & dist ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 + hbs * mis , tp , <S2SV_EndBug> <S2SV_StartBug> mi_row + hbs , mi_col , subsize , output_enabled , <S2SV_EndBug> <S2SV_StartBug> & rate , & dist ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( bsize == BLOCK_64X64 && output_enabled ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> RD_COST * dummy_cost , PC_TREE * pc_tree <S2SV_ModEnd> <S2SV_ModStart> TileInfo * tile_info = & tile_data -> tile_info ; <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> b_width_log2_lookup [ bsize ] <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> if ( output_enabled && bsize != BLOCK_4X4 ) { int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; td -> counts -> partition [ ctx ] [ partition ] ++ ; } <S2SV_ModStart> pc_tree -> none . pred_pixel_ready = 1 ; <S2SV_ModStart> tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> none ) ; pc_tree -> none . <S2SV_ModEnd> <S2SV_ModStart> ; pc_tree -> none . mbmi_ext = * x -> mbmi_ext ; pc_tree -> none . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> none . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none ) <S2SV_ModStart> pc_tree -> vertical [ 0 ] . pred_pixel_ready = 1 <S2SV_ModEnd> <S2SV_ModStart> tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> vertical [ 0 ] ) ; pc_tree -> vertical [ 0 ] . <S2SV_ModEnd> <S2SV_ModStart> ; pc_tree -> vertical [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 0 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] ) <S2SV_ModStart> && bsize > BLOCK_8X8 ) { pc_tree -> vertical [ 1 ] . pred_pixel_ready <S2SV_ModEnd> <S2SV_ModStart> tile_data , x , mi_row , mi_col + hbs , dummy_cost , subsize , & pc_tree -> vertical [ 1 ] ) ; pc_tree -> vertical [ 1 ] . <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> vertical [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 1 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] ) ; <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> horizontal [ 0 ] . pred_pixel_ready = 1 <S2SV_ModEnd> <S2SV_ModStart> tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> horizontal [ 0 ] ) ; pc_tree -> horizontal [ 0 ] . <S2SV_ModEnd> <S2SV_ModStart> ; pc_tree -> horizontal [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 0 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] ) <S2SV_ModStart> && bsize > BLOCK_8X8 ) { pc_tree -> horizontal [ 1 ] . pred_pixel_ready <S2SV_ModEnd> <S2SV_ModStart> tile_data , x , mi_row + hbs , mi_col , dummy_cost , subsize , & pc_tree -> horizontal [ 1 ] ) ; pc_tree -> horizontal [ 1 ] . <S2SV_ModEnd> <S2SV_ModStart> xd -> mi <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> horizontal [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 1 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] ) ; <S2SV_ModEnd> <S2SV_ModStart> if ( bsize == BLOCK_8X8 ) { nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , pc_tree -> leaf_split [ 0 ] ) ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> leaf_split [ 0 ] ) ; } else { <S2SV_ModEnd> <S2SV_ModStart> td , tile_data , mi <S2SV_ModEnd> <S2SV_ModStart> dummy_cost , pc_tree -> split [ 0 ] ) <S2SV_ModEnd> <S2SV_ModStart> td , tile_data , mi <S2SV_ModEnd> <S2SV_ModStart> dummy_cost , pc_tree -> split [ 1 ] ) ; nonrd_use_partition ( cpi , td , tile_data , mi + hbs * mis , tp , mi_row + hbs , mi_col , subsize , output_enabled , dummy_cost , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> <S2SV_ModStart> td , tile_data , mi <S2SV_ModEnd> <S2SV_ModStart> + hbs <S2SV_ModStart> + hbs <S2SV_ModStart> dummy_cost , pc_tree -> split [ 3 ] ) <S2SV_ModEnd> <S2SV_ModStart> 0 && <S2SV_ModStart> break ; <S2SV_ModStart> partition != PARTITION_SPLIT || bsize == BLOCK_8X8 ) update_partition_context ( xd , mi_row , mi_col , subsize <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3740,<S2SV_StartBug> * state = CCS_VALUE ; <S2SV_EndBug> ,<S2SV_ModStart> if ( * state != CCS_START ) 
3741,<S2SV_StartBug> assert ( n >= 0 && n < 32 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( n < 0 || n >= 32 ) { return EOF ; } <S2SV_ModEnd> 
3742,<S2SV_StartBug> nfcb_poll -> sensb_res_len = * data ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> min_t ( __u8 , <S2SV_ModStart> , NFC_SENSB_RES_MAXSIZE ) "
3743,"<S2SV_StartBug> GsmXSMPClient * client ; <S2SV_EndBug> <S2SV_StartBug> client = ice_conn -> context ; <S2SV_EndBug> <S2SV_StartBug> g_return_val_if_fail ( client != NULL , TRUE ) ; <S2SV_EndBug> <S2SV_StartBug> gsm_xsmp_client_connect ( client , sms_conn , mask_ret , callbacks_ret ) ; <S2SV_EndBug> ","<S2SV_ModStart> GsmClient * client ; GsmIceConnectionWatch * data <S2SV_ModEnd> <S2SV_ModStart> data <S2SV_ModEnd> <S2SV_ModStart> free_ice_connection_watch ( data ) ; client = gsm_xsmp_client_new ( ice_conn ) ; gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ; g_object_unref ( client <S2SV_ModEnd> <S2SV_ModStart> GSM_XSMP_CLIENT ( client ) <S2SV_ModEnd> "
3744,<S2SV_StartBug> if ( ( * name != '\\0' ) && ( * name != '#' ) ) <S2SV_EndBug> ,<S2SV_ModStart> count < 0 ) || ( ( size_t ) count > length ) ) { length = 0 ; continue ; } if ( ( 
3745,"<S2SV_StartBug> static void fadst4 ( const int16_t * input , int16_t * output ) { <S2SV_EndBug> <S2SV_StartBug> int x0 , x1 , x2 , x3 ; <S2SV_EndBug> <S2SV_StartBug> output [ 0 ] = fdct_round_shift ( s0 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 1 ] = fdct_round_shift ( s1 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 2 ] = fdct_round_shift ( s2 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 3 ] = fdct_round_shift ( s3 ) ; <S2SV_EndBug> ","<S2SV_ModStart> tran_low_t * input , tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t x0 , x1 , x2 , x3 ; tran_high_t <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) "
3746,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> INTL_CHECK_LOCALE_LEN ( slocale_len ) ; 
3747,<S2SV_StartBug> return true ; <S2SV_EndBug> ,<S2SV_ModStart> ( * field_rtrn != NULL ) <S2SV_ModEnd> 
3748,"<S2SV_StartBug> NetTxAncillary ancillary ; <S2SV_EndBug> <S2SV_StartBug> error = udpSendBuffer ( socket -> interface , & message -> srcIpAddr , <S2SV_EndBug> ",<S2SV_ModStart> NetInterface * interface ; <S2SV_ModStart> if ( message -> interface != NULL ) { interface = message -> interface ; } else { interface = socket -> interface ; } <S2SV_ModStart>  <S2SV_ModEnd> 
3749,<S2SV_StartBug> nexthdr = * prevhdr ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ; 
3750,"<S2SV_StartBug> len = args -> count = min ( args -> count , max_blocksize ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> 1 <S2SV_ModEnd> "
3751,"<S2SV_StartBug> set_exception_intercept ( svm , MC_VECTOR ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; set_exception_intercept ( svm , AC_VECTOR "
3752,"<S2SV_StartBug> if ( ! av_strstart ( proto_name , ""http"" , NULL ) && ! av_strstart ( proto_name , ""file"" , NULL ) ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""file"" , NULL ) ) { if ( strcmp ( c -> allowed_extensions , ""ALL"" ) && ! av_match_ext ( url , c -> allowed_extensions ) ) { av_log ( s , AV_LOG_ERROR , ""Filename<S2SV_blank>extension<S2SV_blank>of<S2SV_blank>\\\'%s\\\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>common<S2SV_blank>multimedia<S2SV_blank>extension,<S2SV_blank>blocked<S2SV_blank>for<S2SV_blank>security<S2SV_blank>reasons.\\n"" ""If<S2SV_blank>you<S2SV_blank>wish<S2SV_blank>to<S2SV_blank>override<S2SV_blank>this<S2SV_blank>adjust<S2SV_blank>allowed_extensions,<S2SV_blank>you<S2SV_blank>can<S2SV_blank>set<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\\\'ALL\\\'<S2SV_blank>to<S2SV_blank>allow<S2SV_blank>all\\n"" , url ) ; return AVERROR_INVALIDDATA ; } } else if ( av_strstart ( proto_name , <S2SV_ModStart> ) { ; } else <S2SV_ModEnd> "
3753,"<S2SV_StartBug> list_add ( & mnt -> mnt_list , & new_ns -> list ) ; <S2SV_EndBug> ",<S2SV_ModStart> new_ns -> mounts ++ ; 
3754,"<S2SV_StartBug> case VPX_IMG_FMT_I422 : <S2SV_EndBug> <S2SV_StartBug> case VPX_IMG_FMT_I444 : <S2SV_EndBug> <S2SV_StartBug> ""supported."" ) ; <S2SV_EndBug> ","<S2SV_ModStart> VPX_IMG_FMT_I42016 : break ; case <S2SV_ModStart> case VPX_IMG_FMT_I440 : if ( ctx -> cfg . g_profile != ( unsigned int ) PROFILE_1 ) { ERROR ( ""Invalid<S2SV_blank>image<S2SV_blank>format.<S2SV_blank>I422,<S2SV_blank>I444,<S2SV_blank>I440<S2SV_blank>images<S2SV_blank>are<S2SV_blank>"" ""not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile."" ) ; } break ; case VPX_IMG_FMT_I42216 : case VPX_IMG_FMT_I44416 : case VPX_IMG_FMT_I44016 : if ( ctx -> cfg . g_profile != ( unsigned int ) PROFILE_1 && ctx -> cfg . g_profile != ( unsigned int ) PROFILE_3 ) { ERROR ( ""Invalid<S2SV_blank>image<S2SV_blank>format.<S2SV_blank>16-bit<S2SV_blank>I422,<S2SV_blank>I444,<S2SV_blank>I440<S2SV_blank>images<S2SV_blank>are<S2SV_blank>"" ""not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile."" ) ; } <S2SV_ModStart> ; break "
3755,<S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> bail : free ( tmpbuf ) ; tmpbuf = NULL ; return - 1 ; 
3756,"<S2SV_StartBug> unsigned int maxfraglen , fragheaderlen ; <S2SV_EndBug> <S2SV_StartBug> int hh_len ; <S2SV_EndBug> <S2SV_StartBug> fragheaderlen , skb , rt ) ; <S2SV_EndBug> ","<S2SV_ModStart> , mtu <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , np -> pmtudisc == IPV6_PMTUDISC_PROBE "
3757,<S2SV_StartBug> return - ENOBUFS ; <S2SV_EndBug> ,<S2SV_ModStart> goto nla_put_failure <S2SV_ModEnd> 
3758,"<S2SV_StartBug> assert ( errno == ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> ""for<S2SV_blank>management<S2SV_blank>address"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; else log_warn ( ""lldp"" , ""too<S2SV_blank>large<S2SV_blank>management<S2SV_blank>address<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname "
3759,<S2SV_StartBug> char added ; <S2SV_EndBug> <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3760,"<S2SV_StartBug> if ( buf ) <S2SV_EndBug> <S2SV_StartBug> _copy_from_pages ( buf , pages , res . acl_data_offset , res . acl_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> { if ( res . acl_len > buflen ) { ret = - ERANGE ; goto out_free ; } <S2SV_ModStart> } 
3761,<S2SV_StartBug> if ( * p == '#' ) { <S2SV_EndBug> ,"<S2SV_ModStart> len = FFMIN ( FFMAX ( len , 0 ) , sizeof ( color_name ) - 1 ) ; "
3762,"<S2SV_StartBug> void nfs4_close_sync ( struct path * path , struct nfs4_state * state , mode_t mode ) <S2SV_EndBug> <S2SV_StartBug> __nfs4_close ( path , state , mode , 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> 
3763,<S2SV_StartBug> vpx_codec_err_t res = VPX_CODEC_OK ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> y_crop_width = img -> d_w ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> y_crop_height = img -> d_h ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> y_width = img -> d_w ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> y_height = img -> d_h ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> uv_width = ( 1 + yv12 -> y_width ) / 2 ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> uv_height = ( 1 + yv12 -> y_height ) / 2 ; <S2SV_EndBug> ,<S2SV_ModStart> const int y_w = img -> d_w ; const int y_h = img -> d_h ; const int uv_w = ( img -> d_w + 1 ) / 2 ; const int uv_h = ( img -> d_h + 1 ) / 2 ; <S2SV_ModStart> y_w <S2SV_ModEnd> <S2SV_ModStart> y_h <S2SV_ModEnd> <S2SV_ModStart> y_w <S2SV_ModEnd> <S2SV_ModStart> y_h ; yv12 -> uv_crop_width = uv_w ; yv12 -> uv_crop_height = uv_h <S2SV_ModEnd> <S2SV_ModStart> uv_w ; yv12 -> uv_height = uv_h ; yv12 -> y_stride = img -> stride [ VPX_PLANE_Y ] ; yv12 -> uv_stride = img -> stride [ VPX_PLANE_U ] ; yv12 -> border = ( img -> stride [ VPX_PLANE_Y ] - img -> w <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3764,<S2SV_StartBug> create_option_search_table ( ) ; <S2SV_EndBug> ,"<S2SV_ModStart> # ifdef HAVE_MKDTEMP tmp_dir = mkdtemp ( Strnew_m_charp ( tmp_dir , ""/w3m-XXXXXX"" , NULL ) -> ptr ) ; if ( tmp_dir == NULL ) tmp_dir = rc_dir ; # endif "
3765,<S2SV_StartBug> if ( tlen < oid_len ) { <S2SV_EndBug> ,<S2SV_ModStart> 1U + 
3766,"<S2SV_StartBug> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <S2SV_EndBug> ","<S2SV_ModStart> elems , e -> "
3767,<S2SV_StartBug> dpb_commands_t * ps_dpb_cmds = ps_dec -> ps_dpb_cmds ; <S2SV_EndBug> ,<S2SV_ModStart> & ( ps_dec -> s_dpb_cmds_scratch ) <S2SV_ModEnd> 
3768,"<S2SV_StartBug> static void iwl_sta_ucode_activate ( struct iwl_priv * priv , u8 sta_id ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( sta_id >= IWLAGN_STATION_COUNT ) { IWL_ERR ( priv , ""invalid<S2SV_blank>sta_id<S2SV_blank>%u"" , sta_id ) ; return - EINVAL ; } <S2SV_ModStart> return 0 ; "
3769,"<S2SV_StartBug> err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , <S2SV_EndBug> <S2SV_StartBug> rcu_read_unlock ( ) ; <S2SV_EndBug> ","<S2SV_ModStart> { if ( ! res . fi ) { err = fib_props [ res . type ] . error ; if ( ! err ) err = - EHOSTUNREACH ; <S2SV_ModEnd> <S2SV_ModStart> } err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ; } else { err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ; } if ( err < 0 ) goto errout_free ; "
3770,"<S2SV_StartBug> r = send ( p_dcb -> p_scb -> socket_id [ 1 ] , p_dcb -> p_rx_pkt , data_size , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
3771,"<S2SV_StartBug> if ( sk_filter ( sk , skb ) ) <S2SV_EndBug> <S2SV_StartBug> goto discard_and_relse ; <S2SV_EndBug> ",<S2SV_ModStart> tcp_filter <S2SV_ModEnd> <S2SV_ModStart> ; th = ( const struct tcphdr * ) skb -> data ; hdr = ipv6_hdr ( skb ) 
3772,<S2SV_StartBug> replen = hdr . replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1 ; <S2SV_EndBug> <S2SV_StartBug> encode_nops ( & hdr ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> xdr_set_scratch_buffer ( xdr , page_address ( args -> acl_scratch ) , PAGE_SIZE ) ; "
3773,"<S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> <S2SV_StartBug> __ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> current_cred ( ) <S2SV_ModEnd> 
3774,"<S2SV_StartBug> ret = sendmsg ( sock_fd , & msg , MSG_NOSIGNAL ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
3775,"<S2SV_StartBug> args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> 1 <S2SV_ModEnd> "
3776,"<S2SV_StartBug> vcpu = kvm_arch_vcpu_create ( kvm , id ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( id >= KVM_MAX_VCPUS ) return - EINVAL ; 
3777,<S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> ,<S2SV_ModStart> || ! SecIsValidHandle ( handle ) 
3778,<S2SV_StartBug> hdl -> client_state = HSM_COM_C_STATE_IN ; <S2SV_EndBug> ,<S2SV_ModStart> if ( mkstemp ( hdl -> c_path ) == - 1 ) { res = HSM_COM_PATH_ERR ; goto cleanup ; } 
3779,"<S2SV_StartBug> skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; <S2SV_EndBug> <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ",<S2SV_ModStart> msg -> msg_namelen = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> 
3780,"<S2SV_StartBug> gint reported_length_remaining ; <S2SV_EndBug> <S2SV_StartBug> dissector_try_uint ( wtap_encap_dissector_table , linktype , new_tvb , pinfo , top_tree ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; struct eth_phdr eth ; void * phdr <S2SV_ModStart> switch ( linktype ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdr = & eth ; break ; default : phdr = NULL ; break ; } dissector_try_uint_new <S2SV_ModEnd> <S2SV_ModStart> , TRUE , phdr "
3781,"<S2SV_StartBug> int16_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( tx_size ) { <S2SV_EndBug> <S2SV_StartBug> fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , <S2SV_EndBug> <S2SV_StartBug> p -> quant , p -> quant_shift , qcoeff , dqcoeff , <S2SV_EndBug> <S2SV_StartBug> pd -> dequant , p -> zbin_extra , eob , scan_order -> scan , <S2SV_EndBug> <S2SV_StartBug> vp9_fdct16x16 ( src_diff , coeff , diff_stride ) ; <S2SV_EndBug> <S2SV_StartBug> pd -> dequant , p -> zbin_extra , eob , <S2SV_EndBug> <S2SV_StartBug> vp9_fdct8x8 ( src_diff , coeff , diff_stride ) ; <S2SV_EndBug> <S2SV_StartBug> pd -> dequant , p -> zbin_extra , eob , <S2SV_EndBug> <S2SV_StartBug> vp9_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , <S2SV_EndBug> <S2SV_StartBug> pd -> dequant , p -> zbin_extra , eob , <S2SV_EndBug> <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> highbd_fdct32x32 <S2SV_ModEnd> <S2SV_ModStart> vpx_highbd_quantize_b_32x32 <S2SV_ModEnd> <S2SV_ModStart> dqcoeff , <S2SV_ModEnd> <S2SV_ModStart> eob , <S2SV_ModEnd> <S2SV_ModStart> vpx_highbd_fdct16x16 ( src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_highbd_fdct8x8 ( src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_highbd_quantize_b <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; } return ; } # endif switch ( tx_size ) { case TX_32X32 : fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; vpx_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; case TX_16X16 : vpx_fdct16x16 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; case TX_8X8 : vpx_fdct8x8 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; case TX_4X4 : x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; default : assert ( 0 ) ; break "
3782,<S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ( desc -> type & BIT ( 3 ) ) ) <S2SV_EndBug> <S2SV_StartBug> switch ( ( desc -> l << 1 ) | desc -> d ) { <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_desc ( & desc , sel ) <S2SV_ModEnd> <S2SV_ModStart> . <S2SV_ModEnd> <S2SV_ModStart> . <S2SV_ModEnd> <S2SV_ModStart> . <S2SV_ModEnd> "
3783,"<S2SV_StartBug> if ( ! headcount ) { <S2SV_EndBug> <S2SV_StartBug> msg . msg_iovlen = in ; <S2SV_EndBug> <S2SV_StartBug> sock_len , MSG_DONTWAIT | MSG_TRUNC ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( err != sock_len ) ) { <S2SV_EndBug> ","<S2SV_ModStart> unlikely ( headcount > UIO_MAXIOV ) ) { <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>len<S2SV_blank>%zd\\n"" , sock_len ) ; continue ; } if ( ! headcount ) { if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) { vhost_disable_notify ( & net -> dev , vq ) ; continue ; } break ; } if ( unlikely ( ( vhost_hlen ) ) ) move_iovec_hdr ( vq -> iov , nvq -> hdr , vhost_hlen , in ) ; else copy_iovec_hdr ( vq -> iov , nvq -> hdr , sock_hlen , in ) ; msg . msg_iovlen = in ; err = sock -> ops -> recvmsg ( NULL , sock , & msg , sock_len , MSG_DONTWAIT | MSG_TRUNC ) ; "
3784,<S2SV_StartBug> if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { <S2SV_EndBug> ,<S2SV_ModStart> strlen ( token ) > 4 && 
3785,"<S2SV_StartBug> size_t wcs_length = len ; <S2SV_EndBug> <S2SV_StartBug> if ( NULL == archive_wstring_ensure ( dest , dest -> length + wcs_length + 1 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( wcs_length == 0 ) { <S2SV_EndBug> <S2SV_StartBug> wcs_length = mbs_length ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> # if HAVE_MBRTOWC r = mbrtowc ( wcs , mbs , mbs_length , & shift_state ) ; # else r = mbtowc ( wcs , mbs , mbs_length ) ; # endif if ( r == ( size_t ) - 1 || r == ( size_t ) - 2 ) { ret_val = - 1 ; break ; } if ( r == 0 || r > mbs_length ) break ; wcs ++ ; mbs += r ; mbs_length -= r ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3786,"<S2SV_StartBug> timr -> it_overrun += ( unsigned int ) hrtimer_forward ( timer , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
3787,<S2SV_StartBug> newnp -> ipv6_ac_list = NULL ; <S2SV_EndBug> <S2SV_StartBug> newinet -> inet_opt = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ipv6_mc_list = NULL ; newnp -> <S2SV_ModStart> = NULL ; newnp -> ipv6_mc_list 
3788,"<S2SV_StartBug> int alt ; <S2SV_EndBug> <S2SV_StartBug> if ( alt < 0 ) <S2SV_EndBug> <S2SV_StartBug> intf -> altsetting [ 0 ] . desc . bInterfaceNumber , alt ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct usb_host_interface * <S2SV_ModEnd> <S2SV_ModStart> ! alt ) return - ENODEV <S2SV_ModEnd> <S2SV_ModStart> alt -> <S2SV_ModEnd> <S2SV_ModStart> -> desc . bAlternateSetting 
3789,"<S2SV_StartBug> # line 52 ""dt_test2.pgc"" <S2SV_EndBug> <S2SV_StartBug> # line 53 ""dt_test2.pgc"" <S2SV_EndBug> <S2SV_StartBug> # line 54 ""dt_test2.pgc"" <S2SV_EndBug> <S2SV_StartBug> # line 55 ""dt_test2.pgc"" <S2SV_EndBug> <S2SV_StartBug> # line 56 ""dt_test2.pgc"" <S2SV_EndBug> <S2SV_StartBug> # line 57 ""dt_test2.pgc"" <S2SV_EndBug> ",<S2SV_ModStart> 62 <S2SV_ModEnd> <S2SV_ModStart> 63 <S2SV_ModEnd> <S2SV_ModStart> 64 <S2SV_ModEnd> <S2SV_ModStart> 65 <S2SV_ModEnd> <S2SV_ModStart> 66 <S2SV_ModEnd> <S2SV_ModStart> 67 <S2SV_ModEnd> 
3790,"<S2SV_StartBug> ret = epoll_wait ( reactor -> epoll_fd , events , MAX_EVENTS , - 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
3791,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ofpact_finish_BUNDLE ( ofpacts , & bundle ) ; <S2SV_EndBug> ",<S2SV_ModStart> else { <S2SV_ModStart> } 
3792,"<S2SV_StartBug> char prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> char * type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( prefix != '+' && prefix != '-' && prefix != '=' ) { <S2SV_EndBug> <S2SV_StartBug> YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ; <S2SV_EndBug> <S2SV_StartBug> { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } <S2SV_EndBug> <S2SV_StartBug> { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; } <S2SV_EndBug> <S2SV_StartBug> case 237 : <S2SV_EndBug> <S2SV_StartBug> # line 1082 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1090 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1091 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1095 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1106 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1120 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1124 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1125 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1129 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1130 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1134 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1135 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1140 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1144 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1148 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1152 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1153 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1158 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1162 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1163 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1168 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1170 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1172 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1174 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1176 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3826 ""ntp_parser.c"" <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; switch ( <S2SV_ModEnd> <S2SV_ModStart> [ 0 ] ) { case '+' : case '-' : case '=' : prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ; type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) <S2SV_ModStart> break ; default : prefix = '=' ; type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ; } ( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ; YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ; } break ; case 216 : # line 1022 ""ntp_parser.y"" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 217 : # line 1027 ""ntp_parser.y"" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 227 : # line 1058 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 228 : # line 1059 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; } break ; case 229 : # line 1064 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 230 : # line 1066 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 231 : # line 1071 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( 'i' , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 233 : # line 1077 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_shorts ( '-' , ( yyvsp [ ( 2 ) - ( 5 ) ] . Integer ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Integer ) ) ; } break ; case 234 : # line 1081 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 <S2SV_ModEnd> <S2SV_ModStart> ) ; } break ; case 235 : # line 1082 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ; } break ; case 236 : # line 1086 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] <S2SV_ModEnd> <S2SV_ModStart> , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; } break ; case 237 : # line 1087 ""ntp_parser.y"" { ( yyval <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( yyvsp [ ( 1 ) - ( 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 1092 <S2SV_ModEnd> <S2SV_ModStart> 1100 <S2SV_ModEnd> <S2SV_ModStart> 1101 <S2SV_ModEnd> <S2SV_ModStart> 1105 <S2SV_ModEnd> <S2SV_ModStart> 1116 <S2SV_ModEnd> <S2SV_ModStart> 1130 <S2SV_ModEnd> <S2SV_ModStart> 1134 <S2SV_ModEnd> <S2SV_ModStart> 1135 <S2SV_ModEnd> <S2SV_ModStart> 1139 <S2SV_ModEnd> <S2SV_ModStart> 1140 <S2SV_ModEnd> <S2SV_ModStart> 1144 <S2SV_ModEnd> <S2SV_ModStart> 1145 <S2SV_ModEnd> <S2SV_ModStart> 1150 <S2SV_ModEnd> <S2SV_ModStart> 1154 <S2SV_ModEnd> <S2SV_ModStart> 1158 <S2SV_ModEnd> <S2SV_ModStart> 1162 <S2SV_ModEnd> <S2SV_ModStart> 1163 <S2SV_ModEnd> <S2SV_ModStart> 1168 <S2SV_ModEnd> <S2SV_ModStart> 1172 <S2SV_ModEnd> <S2SV_ModStart> 1173 <S2SV_ModEnd> <S2SV_ModStart> 1178 <S2SV_ModEnd> <S2SV_ModStart> 1180 <S2SV_ModEnd> <S2SV_ModStart> 1182 <S2SV_ModEnd> <S2SV_ModStart> 1184 <S2SV_ModEnd> <S2SV_ModStart> 1186 <S2SV_ModEnd> <S2SV_ModStart> 3836 <S2SV_ModEnd> "
3793,<S2SV_StartBug> blkif -> st_ds_req ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( err == - EOPNOTSUPP ) { <S2SV_EndBug> ,"<S2SV_ModStart> struct phys_req preq ; preq . sector_number = req -> u . discard . sector_number ; preq . nr_sects = req -> u . discard . nr_sectors ; err = xen_vbd_translate ( & preq , blkif , WRITE ) ; if ( err ) { pr_warn ( DRV_PFX ""access<S2SV_blank>denied:<S2SV_blank>DISCARD<S2SV_blank>[%llu->%llu]<S2SV_blank>on<S2SV_blank>dev=%04x\\n"" , preq . sector_number , preq . sector_number + preq . nr_sects , blkif -> vbd . pdevice ) ; goto fail_response ; } <S2SV_ModStart> fail_response : "
3794,<S2SV_StartBug> blkif -> st_ds_req ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( err == - EOPNOTSUPP ) { <S2SV_EndBug> ,"<S2SV_ModStart> struct phys_req preq ; preq . sector_number = req -> u . discard . sector_number ; preq . nr_sects = req -> u . discard . nr_sectors ; err = xen_vbd_translate ( & preq , blkif , WRITE ) ; if ( err ) { pr_warn ( DRV_PFX ""access<S2SV_blank>denied:<S2SV_blank>DISCARD<S2SV_blank>[%llu->%llu]<S2SV_blank>on<S2SV_blank>dev=%04x\\n"" , preq . sector_number , preq . sector_number + preq . nr_sects , blkif -> vbd . pdevice ) ; goto fail_response ; } <S2SV_ModStart> fail_response : "
3795,"<S2SV_StartBug> int nNew = sizeof ( char * ) * ( iArg + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> char const * * aNew = ( const char * * ) sqlite3_realloc ( ( void * ) aArg , nNew ) ; <S2SV_EndBug> ",<S2SV_ModStart> sqlite3_int64 <S2SV_ModEnd> <S2SV_ModStart> sqlite3_realloc64 <S2SV_ModEnd> 
3796,"<S2SV_StartBug> sprintf ( descriptor -> msg , ""\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" , <S2SV_EndBug> <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug> ","<S2SV_ModStart> ""\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" <S2SV_ModEnd> <S2SV_ModStart> intptr_t <S2SV_ModEnd> <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) "
3797,"<S2SV_StartBug> strncpy ( hid -> name , req -> name , 128 ) ; <S2SV_EndBug> ",<S2SV_ModStart> sizeof ( req -> name ) - 1 <S2SV_ModEnd> 
3798,"<S2SV_StartBug> handle_t * handle = NULL ; <S2SV_EndBug> <S2SV_StartBug> ext4_debug ( ""ext4_get_block_write:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>create<S2SV_blank>flag<S2SV_blank>%d\\n"" , <S2SV_EndBug> <S2SV_StartBug> create = EXT4_GET_BLOCKS_IO_CREATE_EXT ; <S2SV_EndBug> <S2SV_StartBug> ret = ext4_get_blocks ( handle , inode , iblock , max_blocks , bh_result , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> ext4_journal_current_handle ( ) <S2SV_ModEnd> <S2SV_ModStart> int started = 0 ; <S2SV_ModStart> if ( ! handle ) { <S2SV_ModStart> started = 1 ; } <S2SV_ModStart> if ( started ) 
3799,<S2SV_StartBug> uint32_t backup_handle ; <S2SV_EndBug> <S2SV_StartBug> if ( ret == 0 && res -> backup -> base . num_pages * PAGE_SIZE < <S2SV_EndBug> <S2SV_StartBug> goto out_unlock ; <S2SV_EndBug> ,<S2SV_ModStart> = 0 <S2SV_ModStart> ) { if ( <S2SV_ModEnd> <S2SV_ModStart> } else { backup_handle = req -> buffer_handle ; } 
3800,<S2SV_StartBug> if ( frame -> color_primaries != AVCOL_PRI_UNSPECIFIED ) <S2SV_EndBug> ,"<S2SV_ModStart> print_primaries ( w , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3801,"<S2SV_StartBug> ret = rtCborDecDynUTF8Str ( pCborCtxt , ub , ( char * * ) & utf8str ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret "
3802,"<S2SV_StartBug> ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , <S2SV_EndBug> ",<S2SV_ModStart> if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u2_total_mbs_coded == 0 ) ) prev_slice_err = 1 ; 
3803,<S2SV_StartBug> proto = EXTRACT_16BITS ( & p [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * ( p + 1 ) == 0x81 || <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> const u_char * bp = p ; if ( length < CHDLC_HDRLEN ) goto trunc ; ND_TCHECK2 ( * p , CHDLC_HDRLEN ) ; <S2SV_ModStart> length < 2 ) goto trunc ; ND_TCHECK_16BITS ( p ) ; if ( <S2SV_ModStart> trunc : ND_PRINT ( ( ndo , ""[|chdlc]"" ) ) ; return ndo -> ndo_snapend - bp ; "
3804,<S2SV_StartBug> if ( ! esil ) <S2SV_EndBug> ,<S2SV_ModStart> { return ; } <S2SV_ModEnd> 
3805,"<S2SV_StartBug> struct dentry * res ; <S2SV_EndBug> <S2SV_StartBug> state = nfs4_do_open ( dir , & path , nd -> intent . open . flags , & attr , cred ) ; <S2SV_EndBug> <S2SV_StartBug> nfs4_intent_set_file ( nd , & path , state ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; fmode_t fmode = nd -> intent . open . flags & ( FMODE_READ | FMODE_WRITE | FMODE_EXEC ) <S2SV_ModStart> fmode , <S2SV_ModStart> , fmode "
3806,"<S2SV_StartBug> static inline bool unconditional ( const struct arpt_arp * arp ) <S2SV_EndBug> <S2SV_StartBug> return memcmp ( arp , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug> ",<S2SV_ModStart> arpt_entry * e <S2SV_ModEnd> <S2SV_ModStart> e -> target_offset == sizeof ( struct arpt_entry ) && memcmp ( & e -> <S2SV_ModEnd> 
3807,<S2SV_StartBug> thread -> tp_value = childregs -> ARM_r3 ; <S2SV_EndBug> ,<S2SV_ModStart> [ 0 ] <S2SV_ModStart> ; thread -> tp_value [ 1 ] = get_tpuser ( ) 
3808,"<S2SV_StartBug> if ( options_file ( configuration_file , type , & section ) ) <S2SV_EndBug> <S2SV_StartBug> if ( init_section ( 1 , & section ) ) <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ","<S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> { s_log ( LOG_ERR , ""Configuration<S2SV_blank>failed"" ) ; options_free ( 0 ) ; <S2SV_ModStart> } "
3809,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( ! inode_owner_or_capable ( inode ) ) return - EACCES ; 
3810,<S2SV_StartBug> nName ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> nName = ( int ) strlen ( zName ) ; 
3811,"<S2SV_StartBug> if ( ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) ) { <S2SV_EndBug> ","<S2SV_ModStart> || ( ctx -> cb ) ( sx_sasl_cb_CHECK_MECH , ( void * ) mech , NULL , s , ctx -> cbarg ) != sx_sasl_ret_OK "
3812,<S2SV_StartBug> if ( is_file_hugepages ( shm_file ) ) <S2SV_EndBug> ,<S2SV_ModStart> shm_file == NULL ) { err = - EIDRM ; goto out_unlock0 ; } if ( 
3813,"<S2SV_StartBug> if ( nad_find_attr ( nad , 0 , - 1 , ""type"" , ""valid"" ) >= 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> && xhash_get ( out -> states , rkey ) == ( void * ) conn_INPROGRESS "
3814,"<S2SV_StartBug> if ( ! dump_dir_accessible_by_uid ( dirname , client_uid ) ) <S2SV_EndBug> ","<S2SV_ModStart> if ( g_settings_privatereports ) { struct stat statbuf ; if ( lstat ( dirname , & statbuf ) != 0 || ! S_ISDIR ( statbuf . st_mode ) ) { error_msg ( ""Path<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>directory"" , dirname ) ; return 404 ; } struct group * gr = getgrnam ( ""abrt"" ) ; if ( ! gr ) { error_msg ( ""Group<S2SV_blank>\'abrt\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist"" ) ; return 500 ; } if ( statbuf . st_uid != 0 || ! ( statbuf . st_gid == 0 || statbuf . st_gid == gr -> gr_gid ) || statbuf . st_mode & 07 ) { error_msg ( ""Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>root:abrt<S2SV_blank>or<S2SV_blank>others<S2SV_blank>are<S2SV_blank>not<S2SV_blank>restricted<S2SV_blank>from<S2SV_blank>access"" , dirname ) ; return 403 ; } struct dump_dir * dd = dd_opendir ( dirname , DD_OPEN_READONLY ) ; const bool complete = dd && problem_dump_dir_is_complete ( dd ) ; dd_close ( dd ) ; if ( complete ) { error_msg ( ""Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>processed"" , dirname ) ; return 403 ; } } else "
3815,"<S2SV_StartBug> if ( psf -> headindex >= SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> <S2SV_StartBug> return psf_fread ( ptr , 1 , bytes , psf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( psf -> headindex + bytes > SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> <S2SV_StartBug> if ( psf -> headindex + bytes > psf -> headend ) <S2SV_EndBug> <S2SV_StartBug> { count = psf_fread ( psf -> header + psf -> headend , 1 , bytes - ( psf -> headend - psf -> headindex ) , psf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( count != bytes - ( int ) ( psf -> headend - psf -> headindex ) ) <S2SV_EndBug> <S2SV_StartBug> psf -> headend += count ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( ptr , psf -> header + psf -> headindex , bytes ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += bytes ; <S2SV_EndBug> ","<S2SV_ModStart> header . indx + bytes >= <S2SV_ModEnd> <S2SV_ModStart> . len && psf_bump_header_allocation ( psf , bytes <S2SV_ModStart> count <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . end <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . end <S2SV_ModEnd> <S2SV_ModStart> header . end <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . end <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . end <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> "
3816,"<S2SV_StartBug> or_circuit_t * or_circ = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ! CIRCUIT_IS_ORIGIN ( circ ) ) <S2SV_EndBug> <S2SV_StartBug> or_circ = TO_OR_CIRCUIT ( circ ) ; <S2SV_EndBug> <S2SV_StartBug> relay_send_end_cell_from_edge ( rh . stream_id , circ , end_reason , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> END_STREAM_REASON_NOTDIRECTORY , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> END_STREAM_REASON_INTERNAL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> END_STREAM_REASON_EXITPOLICY , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> origin_circuit_t * origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ; <S2SV_EndBug> <S2SV_StartBug> origin_circ -> cpath -> prev ) ; <S2SV_EndBug> ",<S2SV_ModStart> = NULL ; origin_circuit_t * origin_circ = NULL ; crypt_path_t * layer_hint <S2SV_ModStart> { <S2SV_ModStart> } else { tor_assert ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) ; origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ; layer_hint = origin_circ -> cpath -> prev ; } <S2SV_ModStart> layer_hint <S2SV_ModEnd> <S2SV_ModStart> layer_hint <S2SV_ModEnd> <S2SV_ModStart> layer_hint <S2SV_ModEnd> <S2SV_ModStart> layer_hint <S2SV_ModEnd> <S2SV_ModStart> tor_assert ( origin_circ <S2SV_ModEnd> <S2SV_ModStart> layer_hint <S2SV_ModEnd> 
3817,"<S2SV_StartBug> for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> data [ i ] = jas_matrix_create ( 1 , jas_image_width ( image ) ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> z = ( z << 8 ) | c ; <S2SV_EndBug> ","<S2SV_ModStart> assert ( <S2SV_ModEnd> <S2SV_ModStart> <= 3 ) ; for ( i = 0 ; i < 3 ; ++ i ) { data [ i ] = 0 ; } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( ! ( <S2SV_ModEnd> <S2SV_ModStart> ) ) { goto error ; } <S2SV_ModEnd> <S2SV_ModStart> goto error ; } z = ( z << 8 ) | c ; nz += 8 ; } v = ( z >> ( nz - hdr -> depth ) ) & RAS_ONES ( hdr -> depth ) ; z &= RAS_ONES ( nz - hdr -> depth ) ; nz -= hdr -> depth ; if ( jas_image_numcmpts ( image ) == 3 ) { jas_matrix_setv ( data [ 0 ] , x , ( RAS_GETRED ( v ) ) ) ; jas_matrix_setv ( data [ 1 ] , x , ( RAS_GETGREEN ( v ) ) ) ; jas_matrix_setv ( data [ 2 ] , x , ( RAS_GETBLUE ( v ) ) ) ; } else { jas_matrix_setv ( data [ 0 ] , x , ( v ) ) ; } } if ( pad ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { goto error ; } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( jas_image_writecmpt ( image , i , 0 , y , hdr -> width , 1 , data [ i ] ) ) { goto error ; } } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; data [ i ] = 0 ; } return 0 ; error : for ( i = 0 ; i < 3 ; ++ i ) { if ( data [ i ] ) { jas_matrix_destroy ( data [ i ] ) ; } } <S2SV_ModStart>  <S2SV_ModEnd> "
3818,"<S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ",<S2SV_ModStart> ssplit <S2SV_ModEnd> 
3819,<S2SV_StartBug> struct cpuinfo_x86 * c ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM 
3820,"<S2SV_StartBug> ZeroMemory ( & credssp -> authInfo , sizeof ( SecBuffer ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; SecInvalidateHandle ( & credssp -> context 
3821,"<S2SV_StartBug> rc = fuse_dev_release ( inode , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> fuse_conn_put ( & cc -> fc ) ; 
3822,<S2SV_StartBug> return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ; <S2SV_EndBug> ,"<S2SV_ModStart> scat = & rm -> data . op_sg [ sg ] ; ret = <S2SV_ModEnd> <S2SV_ModStart> ; ret = min_t ( int , ret , scat -> length - conn -> c_xmit_data_off ) ; return ret "
3823,"<S2SV_StartBug> static int svc_log ( SvcContext * svc_ctx , int level , const char * fmt , ... ) { <S2SV_EndBug> <S2SV_StartBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <S2SV_EndBug> ",<S2SV_ModStart> SVC_LOG_LEVEL <S2SV_ModEnd> <S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> 
3824,<S2SV_StartBug> new_timer -> it_overrun = - 1 ; <S2SV_EndBug> ,<S2SV_ModStart> 1LL <S2SV_ModEnd> 
3825,"<S2SV_StartBug> int <S2SV_EndBug> <S2SV_StartBug> for ( i = 2 ; i < ( ssize_t ) ( argc - 1 ) ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> ( void ) fputc ( ( char ) c , output ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) fclose ( input ) ; <S2SV_EndBug> <S2SV_StartBug> return ( MagickTrue ) ; <S2SV_EndBug> ","<S2SV_ModStart> MagickBooleanType status ; <S2SV_ModStart> status = MagickTrue ; <S2SV_ModStart> { <S2SV_ModEnd> <S2SV_ModStart> if ( fputc ( ( char ) c , output ) != c ) status = MagickFalse ; <S2SV_ModStart> fclose ( input <S2SV_ModEnd> <S2SV_ModStart> remove_utf8 ( argv [ i ] ) ; } ( void ) fclose ( <S2SV_ModEnd> <S2SV_ModStart> status <S2SV_ModEnd> "
3826,<S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3827,"<S2SV_StartBug> priv -> base = devm_ioremap ( & pdev -> dev , r -> start , resource_size ( r ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! r ) return - EINVAL ; 
3828,"<S2SV_StartBug> ret = poll ( & pfd , 1 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> read ( pfd . fd , & buf , UIPC_FLUSH_BUFFER_SIZE ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
3829,<S2SV_StartBug> int i ; <S2SV_EndBug> ,<S2SV_ModStart> jas_matind_t i ; jas_matind_t <S2SV_ModEnd> 
3830,"<S2SV_StartBug> void ntlm_write_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> ",<S2SV_ModStart> static 
3831,<S2SV_StartBug> if ( report -> id == REPORT_KEY_STATE ) { <S2SV_EndBug> ,"<S2SV_ModStart> size > 64 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>picolcd<S2SV_blank>raw<S2SV_blank>event\\n"" , size ) ; return 0 ; } if ( "
3832,"<S2SV_StartBug> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
3833,"<S2SV_StartBug> if ( Stream_GetRemainingLength ( s ) < iconInfo -> cbBitsMask + iconInfo -> cbBitsColor ) <S2SV_EndBug> <S2SV_StartBug> Stream_Read ( s , iconInfo -> colorTable , iconInfo -> cbColorTable ) ; <S2SV_EndBug> <S2SV_StartBug> newBitMask = ( BYTE * ) realloc ( iconInfo -> bitsColor , iconInfo -> cbBitsColor ) ; <S2SV_EndBug> <S2SV_StartBug> Stream_Read ( s , iconInfo -> bitsColor , iconInfo -> cbBitsColor ) ; <S2SV_EndBug> ","<S2SV_ModStart> newBitMask = ( BYTE * ) realloc ( iconInfo -> bitsMask , iconInfo -> cbBitsMask ) ; if ( ! newBitMask ) { free ( iconInfo -> bitsMask ) ; iconInfo -> bitsMask = NULL ; return FALSE ; } iconInfo -> bitsMask = newBitMask ; <S2SV_ModStart> ) return FALSE <S2SV_ModEnd> <S2SV_ModStart> { if ( Stream_GetRemainingLength ( s ) < iconInfo -> cbColorTable ) return FALSE ; <S2SV_ModStart> } <S2SV_ModStart> if ( Stream_GetRemainingLength ( s ) < iconInfo -> cbBitsColor ) return FALSE ; "
3834,<S2SV_StartBug> meshdrlen = extract_mesh_header_length ( p + hdrlen ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( caplen < hdrlen + 1 ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return hdrlen ; } "
3835,<S2SV_StartBug> regs [ insn -> dst_reg ] . var_off = tnum_cast ( <S2SV_EndBug> <S2SV_StartBug> __update_reg_bounds ( & regs [ insn -> dst_reg ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> coerce_reg_to_size <S2SV_ModEnd> <S2SV_ModStart> , 4 "
3836,<S2SV_StartBug> skcipher -> setkey = alg -> setkey ; <S2SV_EndBug> ,<S2SV_ModStart> skcipher_setkey <S2SV_ModEnd> 
3837,"<S2SV_StartBug> void vp9_fwht4x4_c ( const int16_t * input , int16_t * output , int stride ) { <S2SV_EndBug> <S2SV_StartBug> int a1 , b1 , c1 , d1 , e1 ; <S2SV_EndBug> <S2SV_StartBug> const int16_t * ip = input ; <S2SV_EndBug> <S2SV_StartBug> int16_t * op = output ; <S2SV_EndBug> <S2SV_StartBug> a1 = ip [ 0 * stride ] ; <S2SV_EndBug> <S2SV_StartBug> d1 = ip [ 3 * stride ] ; <S2SV_EndBug> <S2SV_StartBug> op [ 0 ] = a1 ; <S2SV_EndBug> <S2SV_StartBug> op [ 8 ] = d1 ; <S2SV_EndBug> <S2SV_StartBug> op [ 12 ] = b1 ; <S2SV_EndBug> <S2SV_StartBug> op [ 0 ] = a1 * UNIT_QUANT_FACTOR ; <S2SV_EndBug> <S2SV_StartBug> op [ 1 ] = c1 * UNIT_QUANT_FACTOR ; <S2SV_EndBug> <S2SV_StartBug> op [ 2 ] = d1 * UNIT_QUANT_FACTOR ; <S2SV_EndBug> <S2SV_StartBug> op [ 3 ] = b1 * UNIT_QUANT_FACTOR ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> ip_pass0 <S2SV_ModEnd> <S2SV_ModStart> const tran_low_t * ip = NULL ; tran_low_t <S2SV_ModEnd> <S2SV_ModStart> ip_pass0 [ 0 * stride ] ; b1 = ip_pass0 [ 1 * stride ] ; c1 = ip_pass0 <S2SV_ModEnd> <S2SV_ModStart> ip_pass0 <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) a1 ; op [ 4 ] = ( tran_low_t ) <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) b1 ; ip_pass0 <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) ( <S2SV_ModStart> ) ; op [ 1 ] = ( tran_low_t ) ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> ( tran_low_t ) ( <S2SV_ModStart> ) <S2SV_ModStart> ( tran_low_t ) ( <S2SV_ModStart> ) 
3838,<S2SV_StartBug> struct sock * sk ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL 
3839,"<S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> <S2SV_StartBug> key -> reject_error = - error ; <S2SV_EndBug> ","<S2SV_ModStart> key -> state == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> <S2SV_ModStart> mark_key_instantiated ( key , - error <S2SV_ModEnd> "
3840,"<S2SV_StartBug> if ( current_entry + n > ( int ) c -> entries ) { return error ( f , VORBIS_invalid_setup ) ; } <S2SV_EndBug> <S2SV_StartBug> c -> lookup_values = lookup1_values ( c -> entries , c -> dimensions ) ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < g -> values ; ++ j ) <S2SV_EndBug> <S2SV_StartBug> m -> coupling_steps = get_bits ( f , 8 ) + 1 ; <S2SV_EndBug> ","<S2SV_ModStart> current_length >= 32 ) return error ( f , VORBIS_invalid_setup ) ; if ( <S2SV_ModStart> int values = lookup1_values ( c -> entries , c -> dimensions ) ; if ( values < 0 ) return error ( f , VORBIS_invalid_setup ) ; <S2SV_ModStart> ( uint32 ) values <S2SV_ModEnd> <S2SV_ModStart> - 1 ; ++ j ) if ( p [ j ] . x == p [ j + 1 ] . x ) return error ( f , VORBIS_invalid_setup ) ; for ( j = 0 ; j < g -> values <S2SV_ModStart> ; if ( m -> coupling_steps > f -> channels ) return error ( f , VORBIS_invalid_setup ) "
3841,<S2SV_StartBug> for ( i = 0 ; i < st -> duration ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } 
3842,<S2SV_StartBug> int kb ; <S2SV_EndBug> <S2SV_StartBug> kb = vt_default_utf8 ( ) != 0 ? K_UNICODE : K_XLATE ; <S2SV_EndBug> ,"<S2SV_ModStart> , r <S2SV_ModStart> ; r = vt_verify_kbmode ( fd ) ; if ( r == - EBUSY ) { log_debug_errno ( r , ""Keyboard<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>XLATE<S2SV_blank>or<S2SV_blank>UNICODE<S2SV_blank>mode,<S2SV_blank>not<S2SV_blank>resetting:<S2SV_blank>%m"" ) ; return 0 ; } else if ( r < 0 ) return r "
3843,"<S2SV_StartBug> ret = copy_to_user ( param , ptr , sizeof ( * ptr ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct floppy_raw_cmd cmd = * ptr ; cmd . next = NULL ; cmd . kernel_data = NULL ; <S2SV_ModStart> & cmd <S2SV_ModEnd> <S2SV_ModStart> cmd <S2SV_ModEnd> 
3844,<S2SV_StartBug> if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) <S2SV_EndBug> ,<S2SV_ModStart> ] || ! info -> attrs [ NFC_ATTR_TARGET_INDEX 
3845,"<S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) ) <S2SV_EndBug> <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) ) <S2SV_EndBug> <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) ) <S2SV_EndBug> <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) ) <S2SV_EndBug> ",<S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> <S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> <S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> <S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> 
3846,"<S2SV_StartBug> if ( strstr ( token , ""PM"" ) != NULL ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> if ( strchr ( token , 'd' ) != NULL ) <S2SV_EndBug> <S2SV_StartBug> if ( strchr ( token , 'w' ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrstr <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } if ( osStrchr <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } 
3847,<S2SV_StartBug> while ( tmp && alen < tmp ) { <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK2 ( * tptr , alen ) ; "
3848,"<S2SV_StartBug> char * mask2 , * mask_decoded , * mask_decoded2 , * mask_decoded3 , * mask_decoded4 ; <S2SV_EndBug> <S2SV_StartBug> mask_decoded = NULL ; <S2SV_EndBug> <S2SV_StartBug> mask2 = weechat_string_replace ( mask , dir_separator , ""\\01"" ) ; <S2SV_EndBug> <S2SV_StartBug> mask_decoded5 = malloc ( length ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! mask_decoded5 ) <S2SV_EndBug> <S2SV_StartBug> mask_decoded5 [ 0 ] = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> strftime ( mask_decoded5 , length - 1 , mask_decoded4 , date_tmp ) ; <S2SV_EndBug> <S2SV_StartBug> weechat_string_tolower ( mask_decoded5 ) ; <S2SV_EndBug> <S2SV_StartBug> mask , mask_decoded5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mask_decoded ) <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded ) ; <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded2 ) ; <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded3 ) ; <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded4 ) ; <S2SV_EndBug> <S2SV_StartBug> return mask_decoded5 ; <S2SV_EndBug> ","<S2SV_ModStart> mask3 , * mask4 , * mask5 , * mask6 , * mask7 <S2SV_ModEnd> <S2SV_ModStart> mask3 = NULL ; mask4 = NULL ; mask5 = NULL ; mask6 = NULL ; mask7 <S2SV_ModEnd> <S2SV_ModStart> length = strlen ( mask <S2SV_ModEnd> <S2SV_ModStart> mask2 <S2SV_ModEnd> <S2SV_ModStart> mask2 <S2SV_ModEnd> <S2SV_ModStart> mask2 <S2SV_ModEnd> <S2SV_ModStart> if ( strftime ( mask2 <S2SV_ModEnd> <S2SV_ModStart> mask <S2SV_ModEnd> <S2SV_ModStart> == 0 ) mask2 [ 0 ] = '\\0' ; mask3 = weechat_string_replace ( mask2 , dir_separator , ""\\01"" ) ; if ( ! mask3 ) goto end ; mask4 = weechat_buffer_string_replace_local_var ( buffer , mask3 ) ; if ( ! mask4 ) goto end ; mask5 = weechat_string_replace ( mask4 , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ; if ( ! mask5 ) goto end ; # ifdef __CYGWIN__ mask6 = weechat_string_replace ( mask5 , ""\\\\"" , weechat_config_string ( logger_config_file_replacement_char ) ) ; # else mask6 = strdup ( mask5 ) ; # endif if ( ! mask6 ) goto end ; mask7 = weechat_string_replace ( mask6 , ""\\01"" , dir_separator ) ; if ( ! mask7 ) goto end <S2SV_ModStart> mask7 <S2SV_ModEnd> <S2SV_ModStart> mask7 <S2SV_ModEnd> <S2SV_ModStart> mask3 <S2SV_ModEnd> <S2SV_ModStart> mask3 ) ; if ( mask4 <S2SV_ModEnd> <S2SV_ModStart> mask4 ) ; if ( mask5 <S2SV_ModEnd> <S2SV_ModStart> mask5 ) ; if ( mask6 <S2SV_ModEnd> <S2SV_ModStart> mask6 <S2SV_ModEnd> <S2SV_ModStart> mask7 <S2SV_ModEnd> "
3849,"<S2SV_StartBug> r_set_size ( op , size ) ; <S2SV_EndBug> <S2SV_StartBug> r_set_size ( op - 1 , ptr - op [ - 1 ] . value . bytes ) ; <S2SV_EndBug> <S2SV_StartBug> r_set_size ( op1 , count + ( ! forward ? ( size - 1 ) : 0 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> op -> tas . rsize = size <S2SV_ModEnd> <S2SV_ModStart> op [ - 3 ] . <S2SV_ModEnd> <S2SV_ModStart> if ( forward ) { op [ - 1 ] . tas . rsize = ptr - op [ - 1 ] . value . bytes ; op [ - 3 ] . tas . rsize = count ; } else { op [ - 1 ] . tas . rsize = count ; op [ - 3 ] . tas . rsize -= count + size ; } <S2SV_ModEnd> 
3850,"<S2SV_StartBug> char * method = manager -> method ; <S2SV_EndBug> <S2SV_StartBug> build_config ( working_dir , server ) ; <S2SV_EndBug> <S2SV_StartBug> ""%s<S2SV_blank>-m<S2SV_blank>%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%s.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%s.conf"" , <S2SV_EndBug> <S2SV_StartBug> executable , method , manager -> manager_address , <S2SV_EndBug> <S2SV_StartBug> working_dir , server -> port , working_dir , server -> port ) ; <S2SV_EndBug> ","<S2SV_ModStart> int i ; int port ; port = atoi ( server -> port ) <S2SV_ModEnd> <S2SV_ModStart> manager , server ) <S2SV_ModEnd> <S2SV_ModStart> ""%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%d.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%d.conf"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3851,"<S2SV_StartBug> struct sockaddr_rc * sa = ( struct sockaddr_rc * ) addr ; <S2SV_EndBug> <S2SV_StartBug> int chan = sa -> rc_channel ; <S2SV_EndBug> <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( chan && __rfcomm_get_listen_sock_by_addr ( chan , & sa -> rc_bdaddr ) ) { <S2SV_EndBug> <S2SV_StartBug> bacpy ( & rfcomm_pi ( sk ) -> src , & sa -> rc_bdaddr ) ; <S2SV_EndBug> <S2SV_StartBug> rfcomm_pi ( sk ) -> channel = chan ; <S2SV_EndBug> ","<S2SV_ModStart> sa <S2SV_ModEnd> <S2SV_ModStart> len , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memset ( & sa , 0 , sizeof ( sa ) ) ; len = min_t ( unsigned int , sizeof ( sa ) , addr_len ) ; memcpy ( & sa , addr , len ) ; BT_DBG ( ""sk<S2SV_blank>%p<S2SV_blank>%pMR"" , sk , & sa . rc_bdaddr ) ; <S2SV_ModStart> sa . rc_channel <S2SV_ModEnd> <S2SV_ModStart> sa . rc_channel , & sa . <S2SV_ModEnd> <S2SV_ModStart> . <S2SV_ModEnd> <S2SV_ModStart> sa . rc_channel <S2SV_ModEnd> "
3852,"<S2SV_StartBug> int open_debug_log ( void ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( debug_file_fp = fopen ( debug_file , ""a+"" ) ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> ( void ) fcntl ( fileno ( debug_file_fp ) , F_SETFD , FD_CLOEXEC ) ; <S2SV_EndBug> ","<S2SV_ModStart> int fh ; struct stat st ; <S2SV_ModStart> fh = open ( debug_file , O_RDWR | O_APPEND | O_CREAT | O_NOFOLLOW , S_IRUSR | S_IWUSR ) ) == - 1 ) return ERROR ; if ( ( debug_file_fp = fdopen ( fh <S2SV_ModEnd> <S2SV_ModStart> if ( ( fstat ( fh , & st ) ) == - 1 ) { debug_file_fp = NULL ; close ( fh ) ; return ERROR ; } if ( st . st_nlink != 1 || ( st . st_mode & S_IFMT ) != S_IFREG ) { debug_file_fp = NULL ; close ( fh ) ; return ERROR ; } <S2SV_ModStart> fh <S2SV_ModEnd> "
3853,<S2SV_StartBug> if ( gf -> file && gf -> file -> device ) <S2SV_EndBug> <S2SV_StartBug> free ( gf -> file -> device -> disk ) ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } 
3854,<S2SV_StartBug> if ( packet -> size + 4 + data_len > MT_PACKET_LEN ) { <S2SV_EndBug> ,<S2SV_ModStart> data_len > MT_PACKET_LEN - 4 - <S2SV_ModStart>  <S2SV_ModEnd> 
3855,<S2SV_StartBug> drop_cloexec ( data -> instance_id_fd ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; if ( data -> env_fd != - 1 ) drop_cloexec ( data -> env_fd 
3856,"<S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> <S2SV_StartBug> free_rsp_buf ( resp_buftype , rsp ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cifs_small_buf_release ( req ) ; 
3857,<S2SV_StartBug> return ms ; <S2SV_EndBug> ,<S2SV_ModStart> ms -> elf_notes_max = FILE_ELF_NOTES_MAX ; 
3858,"<S2SV_StartBug> if ( g_file_test ( filename , G_FILE_TEST_EXISTS ) || g_path_is_absolute ( filename ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
3859,<S2SV_StartBug> return error ; <S2SV_EndBug> ,<S2SV_ModStart> < 0 ? error : 0 
3860,<S2SV_StartBug> } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) <S2SV_EndBug> <S2SV_StartBug> ses -> server -> ops = & smb311_operations ; <S2SV_EndBug> ,<S2SV_ModStart> ses -> server -> vals = & smb21_values ; <S2SV_ModStart> { <S2SV_ModStart> ses -> server -> vals = & smb311_values ; } 
3861,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
3862,<S2SV_StartBug> int is_udplite = IS_UDPLITE ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( udp_lib_checksum_complete ( skb ) ) <S2SV_EndBug> <S2SV_StartBug> if ( skb_csum_unnecessary ( skb ) ) <S2SV_EndBug> ,<S2SV_ModStart> ; bool checksum_valid = false <S2SV_ModStart> checksum_valid = ! <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! checksum_valid <S2SV_ModStart> checksum_valid || 
3863,"<S2SV_StartBug> if ( ( strchr ( cp , '/' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) { <S2SV_EndBug> ","<S2SV_ModStart> * cp == '\\0' || <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> ""."" ) == 0 || strcmp ( cp , <S2SV_ModStart>  <S2SV_ModEnd> "
3864,"<S2SV_StartBug> uint32_t len ; <S2SV_EndBug> <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> <S2SV_StartBug> len = r -> sector_count * 512 ; <S2SV_EndBug> <S2SV_StartBug> DPRINTF ( ""Write<S2SV_blank>complete<S2SV_blank>tag=0x%x<S2SV_blank>more=%d\\n"" , r -> req . tag , len ) ; <S2SV_EndBug> <S2SV_StartBug> scsi_req_data ( & r -> req , len ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> qiov . size <S2SV_ModEnd> <S2SV_ModStart> scsi_init_iovec ( r ) <S2SV_ModEnd> <S2SV_ModStart> r -> qiov . size <S2SV_ModEnd> <S2SV_ModStart> r -> qiov . size <S2SV_ModEnd> 
3865,<S2SV_StartBug> data = malloc ( blk_sz * n_blks ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc ( <S2SV_ModEnd> 
3866,<S2SV_StartBug> if ( current -> mm ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> leave_mm ( smp_processor_id ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> smp_mb ( ) ; } 
3867,"<S2SV_StartBug> if ( ! drive || ! irp || ! irp -> input || ! irp -> output || ! irp -> Complete ) <S2SV_EndBug> <S2SV_StartBug> file = drive_get_file_by_id ( drive , irp -> FileId ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( ! drive_file_write ( file , Stream_Pointer ( irp -> input ) , Length ) ) <S2SV_EndBug> ","<S2SV_ModStart> void * ptr ; <S2SV_ModStart> ptr = Stream_Pointer ( irp -> input ) ; if ( ! Stream_SafeSeek ( irp -> input , Length ) ) return ERROR_INVALID_DATA ; <S2SV_ModStart> ptr <S2SV_ModEnd> "
3868,<S2SV_StartBug> if ( border < 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> || color < 0 
3869,<S2SV_StartBug> uint8_t * result ; <S2SV_EndBug> ,<S2SV_ModStart> if ( nbytes > LEVEL_3_MAX_HEADER_LEN ) { return NULL ; } 
3870,"<S2SV_StartBug> return __blkdev_driver_ioctl ( lc -> dev -> bdev , lc -> dev -> mode , cmd , arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct dm_dev * dev = lc -> dev ; int r = 0 ; if <S2SV_ModEnd> <S2SV_ModStart> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( <S2SV_ModStart>  <S2SV_ModEnd> "
3871,"<S2SV_StartBug> return vp9_segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ? 0 : eob_max ; <S2SV_EndBug> ",<S2SV_ModStart> segfeature_active <S2SV_ModEnd> 
3872,"<S2SV_StartBug> savesegment ( es , prev -> es ) ; <S2SV_EndBug> <S2SV_StartBug> loadsegment ( ds , next -> ds ) ; <S2SV_EndBug> ","<S2SV_ModStart> fs , fsindex ) ; savesegment ( gs , gsindex ) ; load_TLS ( next , cpu ) ; arch_end_context_switch ( next_p ) ; savesegment ( <S2SV_ModStart>  <S2SV_ModEnd> "
3873,<S2SV_StartBug> if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) <S2SV_EndBug> ,"<S2SV_ModStart> unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ; if ( "
3874,<S2SV_StartBug> goto fail ; <S2SV_EndBug> ,<S2SV_ModStart> ret = - EINVAL ; 
3875,"<S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> 
3876,"<S2SV_StartBug> struct sas_task * task = TO_SAS_TASK ( cmd ) ; <S2SV_EndBug> <S2SV_StartBug> scsi_eh_finish_cmd ( cmd , & sas_ha -> eh_done_q ) ; <S2SV_EndBug> ","<S2SV_ModStart> domain_device * dev = cmd_to_domain_dev ( cmd ) ; struct <S2SV_ModStart> if ( dev_is_sata ( dev ) ) { list_move_tail ( & cmd -> eh_entry , & sas_ha -> eh_ata_q ) ; return ; } "
3877,"<S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> pkt_len = parse_cosine_rec_hdr ( phdr , line , err , err_info ) ; <S2SV_EndBug> <S2SV_StartBug> return parse_cosine_hex_dump ( wth -> random_fh , phdr , pkt_len , buf , err , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return parse_cosine_packet <S2SV_ModEnd> <S2SV_ModStart> buf , line <S2SV_ModEnd> "
3878,"<S2SV_StartBug> args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> 1 <S2SV_ModEnd> "
3879,<S2SV_StartBug> kfree_skb ( skb ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3880,"<S2SV_StartBug> int lineno ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( tmp , & annotation , arena ) ; <S2SV_EndBug> <S2SV_StartBug> * out = arg ( arg , annotation , lineno , col_offset , end_lineno , end_col_offset , <S2SV_EndBug> ","<S2SV_ModStart> string type_comment ; <S2SV_ModStart> , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment <S2SV_ModStart> type_comment , "
3881,<S2SV_StartBug> cinfo . hci_handle = sco_pi ( sk ) -> conn -> hcon -> handle ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & cinfo , 0 , sizeof ( cinfo ) ) ; "
3882,"<S2SV_StartBug> const uint8_t * data_end = data + data_sz ; <S2SV_EndBug> <S2SV_StartBug> vpx_codec_err_t res = VPX_CODEC_OK ; <S2SV_EndBug> <S2SV_StartBug> int frames_this_pts , frame_count = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( data == NULL || data_sz == 0 ) <S2SV_EndBug> <S2SV_StartBug> return VPX_CODEC_INVALID_PARAM ; <S2SV_EndBug> <S2SV_StartBug> parse_superframe_index ( data , data_sz , sizes , & frames_this_pts ) ; <S2SV_EndBug> <S2SV_StartBug> const uint8_t marker = * data_start ; <S2SV_EndBug> ","<S2SV_ModStart> const <S2SV_ModStart> ; uint32_t frame_sizes <S2SV_ModEnd> <S2SV_ModStart> frame_count <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> { ctx -> flushed = 1 ; return VPX_CODEC_OK ; } ctx -> flushed = 0 ; if ( ctx -> frame_workers == NULL ) { const vpx_codec_err_t res = init_decoder ( ctx ) ; if ( res != VPX_CODEC_OK ) return res ; } res = vp9_parse_superframe_index <S2SV_ModEnd> <S2SV_ModStart> frame_sizes , & frame_count , ctx -> decrypt_cb , ctx -> decrypt_state ) ; if ( res != VPX_CODEC_OK ) return res ; if ( ctx -> frame_parallel_decode ) { if ( frame_count > 0 ) { int i ; for ( i = 0 ; i < frame_count ; ++ i ) { const uint8_t * data_start_copy = data_start ; const uint32_t frame_size = frame_sizes [ i ] ; if ( data_start < data || frame_size > ( uint32_t ) ( data_end - data_start ) ) { set_error_detail ( ctx , ""Invalid<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>in<S2SV_blank>index"" ) ; return VPX_CODEC_CORRUPT_FRAME ; } if ( ctx -> available_threads == 0 ) { if ( ctx -> num_cache_frames < FRAME_CACHE_SIZE ) { wait_worker_and_cache_frame ( ctx ) ; } else { set_error_detail ( ctx , ""Frame<S2SV_blank>output<S2SV_blank>cache<S2SV_blank>is<S2SV_blank>full."" ) ; return VPX_CODEC_ERROR ; } } res = decode_one ( ctx , & data_start_copy , frame_size , user_priv , deadline ) ; if ( res != VPX_CODEC_OK ) return res ; data_start += frame_size ; } } else { if ( ctx -> available_threads == 0 ) { if ( ctx -> num_cache_frames < FRAME_CACHE_SIZE ) { wait_worker_and_cache_frame ( ctx ) ; } else { set_error_detail ( ctx , ""Frame<S2SV_blank>output<S2SV_blank>cache<S2SV_blank>is<S2SV_blank>full."" ) ; return VPX_CODEC_ERROR ; } } res = decode_one ( ctx , & data , data_sz , user_priv , deadline ) ; if ( res != VPX_CODEC_OK ) return res ; } } else { if ( frame_count > 0 ) { int i ; for ( i = 0 ; i < frame_count ; ++ i ) { const uint8_t * data_start_copy = data_start ; const uint32_t frame_size = frame_sizes [ i ] ; vpx_codec_err_t res ; if ( data_start < data || frame_size > ( uint32_t ) ( data_end - data_start ) ) { set_error_detail ( ctx , ""Invalid<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>in<S2SV_blank>index"" ) ; return VPX_CODEC_CORRUPT_FRAME ; } res = decode_one ( ctx , & data_start_copy , frame_size , user_priv , deadline ) ; if ( res != VPX_CODEC_OK ) return res ; data_start += frame_size ; } } else { while ( data_start < data_end ) { const uint32_t frame_size = ( uint32_t ) ( data_end - data_start ) ; const vpx_codec_err_t res = decode_one ( ctx , & data_start , frame_size , user_priv , deadline ) ; if ( res != VPX_CODEC_OK ) return res ; while ( data_start < data_end <S2SV_ModEnd> <S2SV_ModStart> read_marker ( ctx -> decrypt_cb , ctx -> decrypt_state , data_start ) ; if ( marker ) break ; ++ data_start ; } } } } <S2SV_ModEnd> "
3883,"<S2SV_StartBug> opts = fcntl ( s , F_GETFL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( fcntl ( s , F_SETFL , opts ) < 0 ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
3884,<S2SV_StartBug> ( Rec2 . RecordLength - 2 - 2 ) / 3 ) <S2SV_EndBug> ,"<S2SV_ModStart> ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries "
3885,<S2SV_StartBug> unsigned int i ; <S2SV_EndBug> ,<S2SV_ModStart> ; bpcc -> bpcs = 0 
3886,"<S2SV_StartBug> assertEqualInt ( ARCHIVE_OK , archive_write_free ( a ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; assert ( 0 == unlink ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) ; failure ( ""Extracting<S2SV_blank>an<S2SV_blank>absolute<S2SV_blank>path<S2SV_blank>should<S2SV_blank>fail<S2SV_blank>here."" ) ; assertEqualInt ( ARCHIVE_FAILED , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileNotExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; "
3887,"<S2SV_StartBug> struct resv_map * reservations = vma_resv_map ( vma ) ; <S2SV_EndBug> <S2SV_StartBug> hugetlb_put_quota ( vma -> vm_file -> f_mapping , reserve ) ; <S2SV_EndBug> ",<S2SV_ModStart> ( vma ) ; struct hugepage_subpool * spool = subpool_vma <S2SV_ModStart> hugepage_subpool_put_pages ( spool <S2SV_ModEnd> 
3888,<S2SV_StartBug> szLineConv [ i ] = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( i >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; 
3889,<S2SV_StartBug> if ( rt -> rt_flags & RTCF_DOREDIRECT && ! opt -> srr && ! skb_sec_path ( skb ) ) <S2SV_EndBug> ,<S2SV_ModStart> IPCB ( skb ) -> flags & IPSKB_DOREDIRECT <S2SV_ModEnd> 
3890,"<S2SV_StartBug> long length , offset , size , at ; <S2SV_EndBug> <S2SV_StartBug> goto exit_toc ; <S2SV_EndBug> <S2SV_StartBug> cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>decompress<S2SV_blank>into<S2SV_blank>temp<S2SV_blank>file:\\n%s,<S2SV_blank>size<S2SV_blank>%li,\\n"" <S2SV_EndBug> <S2SV_StartBug> unsigned long in_remaining = length ; <S2SV_EndBug> <S2SV_StartBug> int lret ; <S2SV_EndBug> <S2SV_StartBug> cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:%s.\\n"" , <S2SV_EndBug> <S2SV_StartBug> length , at , errbuff ) ; <S2SV_EndBug> <S2SV_StartBug> unsigned long write_len ; <S2SV_EndBug> <S2SV_StartBug> write_len = MIN ( ( size_t ) ( ctx -> engine -> maxfilesize ) , ( size_t ) length ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( blockp = ( void * ) fmap_need_off_once ( map , at , length ) ) ) { <S2SV_EndBug> <S2SV_StartBug> cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:%s.\\n"" , <S2SV_EndBug> <S2SV_StartBug> xar_hash_update ( a_hash_ctx , blockp , length , a_hash ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cli_writen ( fd , blockp , write_len ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li.\\n"" , length , at ) ; <S2SV_EndBug> <S2SV_StartBug> cli_warnmsg ( ""cli_scanxar:<S2SV_blank>%u<S2SV_blank>checksum<S2SV_blank>errors<S2SV_blank>and<S2SV_blank>%u<S2SV_blank>extraction<S2SV_blank>errors,<S2SV_blank>use<S2SV_blank>--debug<S2SV_blank>for<S2SV_blank>more<S2SV_blank>info.\\n"" , <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> ; } if ( hdr . toc_length_decompressed != strm . total_out ) { cli_dbgmsg ( ""TOC<S2SV_blank>decompress<S2SV_blank>length<S2SV_blank>%"" PRIu64 ""<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>amount<S2SV_blank>decompressed<S2SV_blank>%lu\\n"" , hdr . toc_length_decompressed , strm . total_out ) ; toc [ strm . total_out ] = '\\0' ; hdr . toc_length_decompressed = strm . total_out <S2SV_ModStart> ""cli_scanxar:<S2SV_blank>decompress<S2SV_blank>into<S2SV_blank>temp<S2SV_blank>file:\\n%s,<S2SV_blank>size<S2SV_blank>%zu,\\n"" ""from<S2SV_blank>xar<S2SV_blank>heap<S2SV_blank>offset<S2SV_blank>%zu<S2SV_blank>length<S2SV_blank>%zu\\n"" <S2SV_ModEnd> <S2SV_ModStart> MIN ( length , map -> len - at ) <S2SV_ModEnd> <S2SV_ModStart> ; if ( length > in_remaining ) length = in_remaining <S2SV_ModStart> ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%i<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:%s.\\n"" , CLI_LZMA_HDR_SIZE <S2SV_ModEnd> <S2SV_ModStart> lz . avail_in <S2SV_ModEnd> <S2SV_ModStart> size_t writelen = MIN ( map -> len - at , length ) <S2SV_ModEnd> <S2SV_ModStart> writelen <S2SV_ModEnd> <S2SV_ModStart> writelen ) <S2SV_ModEnd> <S2SV_ModStart> writelen <S2SV_ModEnd> <S2SV_ModStart> ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%zu,<S2SV_blank>errno:%s.\\n"" , writelen <S2SV_ModEnd> <S2SV_ModStart> writelen <S2SV_ModEnd> <S2SV_ModStart> writelen <S2SV_ModEnd> <S2SV_ModStart> ""cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li.\\n"" , writelen <S2SV_ModEnd> <S2SV_ModStart> cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>%u<S2SV_blank>checksum<S2SV_blank>errors<S2SV_blank>and<S2SV_blank>%u<S2SV_blank>extraction<S2SV_blank>errors.\\n"" <S2SV_ModEnd> "
3891,<S2SV_StartBug> opt_type = * bp ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! ND_TTEST2 ( * bp , 2 ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|OPT]"" ) ) ; return ; } "
3892,"<S2SV_StartBug> spin_unlock_irqrestore ( & slave_active_lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> list_del_init ( & timeri -> ack_list ) ; list_del_init ( & timeri -> active_list ) ; 
3893,<S2SV_StartBug> uchar buf [ PGX_MAGICLEN ] ; <S2SV_EndBug> ,<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
3894,<S2SV_StartBug> for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( depth >= 64 ) <S2SV_EndBug> ,"<S2SV_ModStart> if ( ( max_value == 0 ) || ( max_value > 4294967295 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
3895,"<S2SV_StartBug> void * data , <S2SV_EndBug> <S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int mi_size ) { <S2SV_EndBug> <S2SV_StartBug> const int64_t threshold_multiplier = 25 ; <S2SV_EndBug> <S2SV_StartBug> if ( mi_col + block_width / 2 < cm -> mi_cols && <S2SV_EndBug> <S2SV_StartBug> set_block_size ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> vt . part_variances -> vert [ 0 ] . variance < threshold && <S2SV_EndBug> <S2SV_StartBug> set_block_size ( cpi , tile , mi_row , mi_col , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> set_block_size ( cpi , tile , mi_row , mi_col + block_width / 2 , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mi_col + block_width / 2 < cm -> mi_cols && <S2SV_EndBug> <S2SV_StartBug> set_block_size ( cpi , tile , mi_row , mi_col , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> set_block_size ( cpi , tile , mi_row + block_height / 2 , mi_col , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> MACROBLOCK * const x , MACROBLOCKD * const xd , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int64_t threshold , BLOCK_SIZE bsize_min , int force_split <S2SV_ModEnd> <S2SV_ModStart> int low_res = ( cm -> width <= 352 && cm -> height <= 288 ) <S2SV_ModEnd> <S2SV_ModStart> force_split == 1 ) return 0 ; if ( bsize == bsize_min ) { if ( low_res || cm -> frame_type == KEY_FRAME ) get_variance ( & vt . part_variances -> none ) ; if ( <S2SV_ModStart> x , xd , mi_row , mi_col , bsize ) ; return 1 ; } return 0 ; } else if ( bsize > bsize_min ) { if ( low_res || cm -> frame_type == KEY_FRAME ) get_variance ( & vt . part_variances -> none ) ; if ( cm -> frame_type == KEY_FRAME && ( bsize > BLOCK_32X32 || vt . part_variances -> none . variance > ( threshold << 4 ) ) ) { return 0 ; } if ( mi_col + block_width / 2 < cm -> mi_cols && <S2SV_ModEnd> <S2SV_ModStart> none <S2SV_ModEnd> <S2SV_ModStart> ) { set_block_size ( cpi , x , xd , mi_row , mi_col , bsize ) ; return 1 ; } if ( mi_row + block_height / 2 < cm -> mi_rows <S2SV_ModEnd> <S2SV_ModStart> get_variance ( & vt . part_variances -> vert [ 0 ] ) ; get_variance ( & vt . part_variances -> vert [ 1 ] ) ; if ( vt . part_variances -> vert [ 0 ] . variance < threshold && vt . part_variances -> vert [ 1 ] . variance < threshold && get_plane_block_size ( subsize , & xd -> plane [ 1 ] ) < BLOCK_INVALID ) { <S2SV_ModStart> x , xd <S2SV_ModEnd> <S2SV_ModStart> x , xd <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_variance ( & vt . part_variances -> horz [ 0 ] ) ; get_variance ( & vt . part_variances -> horz [ 1 ] ) ; if ( vt . part_variances -> horz [ 0 ] . variance < threshold && vt . part_variances -> horz [ 1 ] . variance < threshold && get_plane_block_size ( subsize , & xd -> plane [ 1 ] ) < BLOCK_INVALID ) { <S2SV_ModStart> x , xd <S2SV_ModEnd> <S2SV_ModStart> x , xd <S2SV_ModEnd> <S2SV_ModStart> } return 0 ; } "
3896,"<S2SV_StartBug> static void perf_event_output ( struct perf_event * event , int nmi , <S2SV_EndBug> <S2SV_StartBug> if ( perf_output_begin ( & handle , event , header . size , nmi , 1 ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3897,"<S2SV_StartBug> if ( sanity_check_area_boundary ( sbi , bh ) ) <S2SV_EndBug> ","<S2SV_ModStart> le32_to_cpu ( raw_super -> segment_count ) > F2FS_MAX_SEGMENT ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>segment<S2SV_blank>count<S2SV_blank>(%u)"" , le32_to_cpu ( raw_super -> segment_count ) ) ; return 1 ; } if ( "
3898,<S2SV_StartBug> ret = fscrypt_get_crypt_info ( dir ) ; <S2SV_EndBug> ,<S2SV_ModStart> fscrypt_get_encryption_info <S2SV_ModEnd> 
3899,<S2SV_StartBug> opts -> max_size = 0 ; <S2SV_EndBug> <S2SV_StartBug> opts -> max_size = atoi ( jas_tvparser_getval ( tvp ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> max_samples = 64 * JAS_MEBI <S2SV_ModEnd> <S2SV_ModStart> max_samples <S2SV_ModEnd> 
3900,<S2SV_StartBug> # ifdef _WITH_VRRP_ <S2SV_EndBug> ,"<S2SV_ModStart> fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-u,<S2SV_blank>--umask=MASK<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>umask<S2SV_blank>for<S2SV_blank>file<S2SV_blank>creation<S2SV_blank>(in<S2SV_blank>numeric<S2SV_blank>form)\\n"" ) ; "
3901,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( cpu_has_secondary_exec_ctrls ( ) ) { if ( kvm_vcpu_apicv_active ( vcpu ) ) vmcs_set_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; else vmcs_clear_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; } if ( cpu_has_vmx_msr_bitmap ( ) ) vmx_set_msr_bitmap ( vcpu ) ; "
3902,"<S2SV_StartBug> const VP9_CONFIG * oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> const int64_t diff = oxcf -> optimal_buffer_level - rc -> buffer_level ; <S2SV_EndBug> <S2SV_StartBug> const int64_t one_pct_bits = 1 + oxcf -> optimal_buffer_level / 100 ; <S2SV_EndBug> <S2SV_StartBug> int min_frame_target = MAX ( rc -> av_per_frame_bandwidth >> 4 , <S2SV_EndBug> <S2SV_StartBug> int target = rc -> av_per_frame_bandwidth ; <S2SV_EndBug> <S2SV_StartBug> if ( svc -> number_temporal_layers > 1 && <S2SV_EndBug> <S2SV_StartBug> const LAYER_CONTEXT * lc = & svc -> layer_context [ current_temporal_layer ] ; <S2SV_EndBug> <S2SV_StartBug> return MAX ( min_frame_target , target ) ; <S2SV_EndBug> ","<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> rc <S2SV_ModEnd> <S2SV_ModStart> rc <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> ; if ( oxcf -> gf_cbr_boost_pct ) { const int af_ratio_pct = oxcf -> gf_cbr_boost_pct + 100 ; target = cpi -> refresh_golden_frame ? ( rc -> avg_frame_bandwidth * rc -> baseline_gf_interval * af_ratio_pct ) / ( rc -> baseline_gf_interval * 100 + af_ratio_pct - 100 ) : ( rc -> avg_frame_bandwidth * rc -> baseline_gf_interval * 100 ) / ( rc -> baseline_gf_interval * 100 + af_ratio_pct - 100 ) ; } else { target = rc -> avg_frame_bandwidth ; } if ( is_one_pass_cbr_svc ( cpi ) ) { int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , svc -> temporal_layer_id , <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> layer <S2SV_ModEnd> <S2SV_ModStart> if ( oxcf -> rc_max_inter_bitrate_pct ) { const int max_rate = rc -> avg_frame_bandwidth * oxcf -> rc_max_inter_bitrate_pct / 100 ; target = MIN ( target , max_rate ) ; } "
3903,"<S2SV_StartBug> . dump = link -> dump , <S2SV_EndBug> ","<S2SV_ModStart> start = link -> start , . "
3904,<S2SV_StartBug> if ( ! ( mask & KADM5_ATTRIBUTES ) || <S2SV_EndBug> ,<S2SV_ModStart> password == NULL || 
3905,<S2SV_StartBug> struct address_space * mapping = page -> mapping ; <S2SV_EndBug> ,<S2SV_ModStart> page_file_mapping ( page ) <S2SV_ModEnd> 
3906,<S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> - 1 <S2SV_ModEnd> <S2SV_ModStart> if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> - 1 <S2SV_ModEnd> 
3907,"<S2SV_StartBug> rc = expandRegular ( fi , fn , psm , nodigest , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> 0 , "
3908,"<S2SV_StartBug> __mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { <S2SV_ModStart> insn -> imm ) ; } else { __mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ; } <S2SV_ModEnd> "
3909,<S2SV_StartBug> if ( ! * ptrptr && ! ( nmemb && size ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3910,"<S2SV_StartBug> rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , size , msg_flags , timeo ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> ; msg -> msg_namelen = 0 <S2SV_ModStart> msg -> msg_namelen = sizeof ( * sin ) ; 
3911,"<S2SV_StartBug> opt = flowlabel ? flowlabel -> opt : np -> opt ; <S2SV_EndBug> <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , opt , & final ) ; <S2SV_EndBug> ",<S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) <S2SV_ModStart> ) ; rcu_read_unlock ( 
3912,"<S2SV_StartBug> u8 obuf [ ] = { 0xde , 0 } ; <S2SV_EndBug> <S2SV_StartBug> state -> initialized = 1 ; <S2SV_EndBug> <S2SV_StartBug> return dvb_usb_generic_rw ( d , obuf , 2 , NULL , 0 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int ret = 0 <S2SV_ModEnd> <S2SV_ModStart> mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xde ; state -> data [ 1 ] = 0 ; <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & d -> data_mutex ) ; } return ret <S2SV_ModEnd> 
3913,"<S2SV_StartBug> const char * arch = info -> arch ; <S2SV_EndBug> <S2SV_StartBug> if ( info -> cpu && * info -> cpu ) { <S2SV_EndBug> <S2SV_StartBug> r_config_set ( r -> config , ""anal.cpu"" , info -> cpu ) ; <S2SV_EndBug> <S2SV_StartBug> r_core_bin_set_cur ( r , binfile ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strdup ( info -> arch ) ; char * cpu = info -> cpu ? strdup ( info -> cpu ) : NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; free ( cpu ) ; free ( arch 
3914,"<S2SV_StartBug> int ip_options_get ( struct net * net , struct ip_options * * optp , <S2SV_EndBug> <S2SV_StartBug> struct ip_options * opt = ip_options_get_alloc ( optlen ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( opt -> __data , data , optlen ) ; <S2SV_EndBug> ",<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> opt . 
3915,"<S2SV_StartBug> change = ue -> tlv_data_size != size ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> return - ENXIO ; <S2SV_EndBug> <S2SV_StartBug> if ( size < ue -> tlv_data_size ) <S2SV_EndBug> <S2SV_StartBug> return - ENOSPC ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_to_user ( tlv , ue -> tlv_data , ue -> tlv_data_size ) ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> mutex_unlock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> int ret = 0 ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto err_unlock ; } <S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto err_unlock ; } <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> err_unlock : mutex_unlock ( & ue -> card -> user_ctl_lock ) ; if ( ret ) return ret ; 
3916,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( map -> m_flags & EXT4_MAP_NEW && ! ( map -> m_flags & EXT4_MAP_UNWRITTEN ) && ! ( flags & EXT4_GET_BLOCKS_ZERO ) && ! IS_NOQUOTA ( inode ) && ext4_should_order_data ( inode ) ) { ret = ext4_jbd2_file_inode ( handle , inode ) ; if ( ret ) return ret ; } } return <S2SV_ModEnd> "
3917,<S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> <S2SV_StartBug> * nbytes = le32_to_cpu ( rsp -> DataLength ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cifs_small_buf_release ( req ) ; 
3918,"<S2SV_StartBug> struct net_device * dev = ( ( struct in_ifaddr * ) ptr ) -> ifa_dev -> dev ; <S2SV_EndBug> <S2SV_StartBug> netdev_notifier_info_init ( & info , dev ) ; <S2SV_EndBug> ",<S2SV_ModStart> in_device * idev <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( idev -> dead ) return NOTIFY_DONE ; <S2SV_ModStart> idev -> 
3919,<S2SV_StartBug> v |= ( c << 24 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> JAS_CAST ( uint_fast32_t , c ) <S2SV_ModEnd> "
3920,"<S2SV_StartBug> sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> SCTP_CMD_SET_ASOC <S2SV_ModEnd> 
3921,"<S2SV_StartBug> FILE * file ; <S2SV_EndBug> <S2SV_StartBug> file = fopen ( stats_file , ""w"" ) ; <S2SV_EndBug> <S2SV_StartBug> for ( e = LIST_HEAD ( l ) ; e ; ELEMENT_NEXT ( e ) ) { <S2SV_EndBug> ","<S2SV_ModStart> = fopen_safe <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! file ) { log_message ( LOG_INFO , ""Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)"" , stats_file , errno , strerror ( errno ) ) ; return ; } LIST_FOREACH ( vrrp_data -> vrrp , vrrp , e ) { <S2SV_ModEnd> "
3922,"<S2SV_StartBug> run_cmd ( int fd , ... ) <S2SV_EndBug> <S2SV_StartBug> char cmd [ 512 ] ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> strcpy ( cmd , EXEC ) ; <S2SV_EndBug> <S2SV_StartBug> fd_printf ( STDERR_FILENO , ""%s\\n"" , & cmd [ sizeof ( EXEC ) - 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> exit ( 42 ) ; <S2SV_EndBug> ","<S2SV_ModStart> const char * cmd , const char * args_extra <S2SV_ModEnd> <S2SV_ModStart> int argc ; char * argv [ RUNCMD_ARGS_MAX + 1 ] ; int r <S2SV_ModEnd> <S2SV_ModStart> argc = 0 ; r = split_quoted <S2SV_ModEnd> <S2SV_ModStart> & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , ""Cannot<S2SV_blank>parse<S2SV_blank>command\\n"" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } r = split_quoted ( args_extra , & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , ""Cannot<S2SV_blank>parse<S2SV_blank>extra<S2SV_blank>args\\n"" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } if ( argc < 1 ) { fd_printf ( STDERR_FILENO , ""No<S2SV_blank>command<S2SV_blank>given\\n"" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } argv [ argc ] = NULL ; fd_printf ( STDERR_FILENO , ""$<S2SV_blank>%s<S2SV_blank>%s\\n"" , cmd , args_extra ) ; establish_child_signal_handlers ( ) ; sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ; execvp ( argv [ 0 ] , argv ) ; <S2SV_ModEnd> <S2SV_ModStart> ""exec:<S2SV_blank>%s\\n"" , strerror ( errno ) <S2SV_ModEnd> <S2SV_ModStart> RUNCMD_EXEC_FAIL <S2SV_ModEnd> "
3923,"<S2SV_StartBug> build_config ( char * prefix , struct server * server ) <S2SV_EndBug> <S2SV_StartBug> fprintf ( f , ""\\""password\\"":\\""%s\\"""" , server -> password ) ; <S2SV_EndBug> <S2SV_StartBug> if ( server -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , server -> method ) ; <S2SV_EndBug> ","<S2SV_ModStart> manager_ctx * manager , struct <S2SV_ModStart> ) ; if ( server -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , server -> method ) ; else if ( manager -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , manager -> method <S2SV_ModStart>  <S2SV_ModEnd> "
3924,<S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> sysctl_head_finish ( head ) ; <S2SV_EndBug> ,<S2SV_ModStart> goto out <S2SV_ModEnd> <S2SV_ModStart> out : 
3925,"<S2SV_StartBug> char * dest , * src ; <S2SV_EndBug> <S2SV_StartBug> dest = src = a -> name ; <S2SV_EndBug> <S2SV_StartBug> if ( * src == '\\0' ) { <S2SV_EndBug> <S2SV_StartBug> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , <S2SV_EndBug> <S2SV_StartBug> # if defined ( __CYGWIN__ ) <S2SV_EndBug> <S2SV_StartBug> return ( ARCHIVE_FAILED ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct archive_string error_string ; int error_number ; int rc ; archive_string_init ( & error_string ) ; rc = cleanup_pathname_fsobj ( <S2SV_ModEnd> <S2SV_ModStart> , & error_number , & error_string , a -> flags ) <S2SV_ModStart> rc != ARCHIVE_OK <S2SV_ModEnd> <S2SV_ModStart> error_number , ""%s"" , error_string . s <S2SV_ModEnd> <S2SV_ModStart> archive_string_free ( & error_string <S2SV_ModEnd> <S2SV_ModStart> rc <S2SV_ModEnd> "
3926,<S2SV_StartBug> ps_dec -> s_high_profile . u1_scaling_present = 0 ; <S2SV_EndBug> <S2SV_StartBug> ps_dec -> u2_cur_slice_num = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> u2_cur_slice_num = 0 ; ps_dec -> <S2SV_ModStart>  <S2SV_ModEnd> 
3927,"<S2SV_StartBug> struct mb_cache * <S2SV_EndBug> <S2SV_StartBug> ext4_xattr_create_cache ( char * name ) <S2SV_EndBug> <S2SV_StartBug> return mb_cache_create ( name , HASH_BUCKET_BITS ) ; <S2SV_EndBug> ",<S2SV_ModStart> mb2_cache <S2SV_ModEnd> <S2SV_ModStart> void <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_create ( <S2SV_ModEnd> 
3928,<S2SV_StartBug> DEFiRet ; <S2SV_EndBug> <S2SV_StartBug> while ( 1 ) { <S2SV_EndBug> ,"<S2SV_ModStart> int bHaveUnprocessed ; DEFiRet ; do { bHaveUnprocessed = 0 ; for ( iStart = 0 ; iStart < pBatch -> nElem && pBatch -> pElem [ iStart ] . state == BATCH_STATE_DISC ; ++ iStart ) ; if ( iStart == pBatch -> nElem ) break ; <S2SV_ModEnd> <S2SV_ModStart> currRuleset = batchElemGetRuleset ( pBatch , iStart ) ; iNew = 0 ; for ( i = iStart ; i < pBatch -> nElem ; ++ i ) { if ( batchElemGetRuleset ( pBatch , i ) == currRuleset ) { snglRuleBatch . pElem [ iNew ] . pUsrp = pBatch -> pElem [ i ] . pUsrp ; snglRuleBatch . pElem [ iNew ] . state = pBatch -> pElem [ i ] . state ; ++ iNew ; pBatch -> pElem [ i ] . state = BATCH_STATE_DISC ; } else { bHaveUnprocessed = 1 ; } } snglRuleBatch . nElem = iNew ; batchSetSingleRuleset ( & snglRuleBatch , 1 ) ; processBatch ( & snglRuleBatch ) ; batchFree ( & snglRuleBatch ) ; } while ( bHaveUnprocessed == 1 <S2SV_ModEnd> "
3929,"<S2SV_StartBug> h -> emptyStreamBools = calloc ( ( size_t ) zip -> numFiles , <S2SV_EndBug> <S2SV_StartBug> h -> emptyFileBools = calloc ( empty_streams , <S2SV_EndBug> <S2SV_StartBug> h -> antiBools = calloc ( empty_streams , <S2SV_EndBug> <S2SV_StartBug> if ( ( ll & 1 ) || ll < zip -> numFiles * 4 ) <S2SV_EndBug> <S2SV_StartBug> h -> attrBools = calloc ( ( size_t ) zip -> numFiles , <S2SV_EndBug> ",<S2SV_ModStart> if ( h -> emptyStreamBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> if ( h -> emptyFileBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> if ( h -> antiBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> ) return ( - 1 ) ; if ( zip -> entry_names != NULL <S2SV_ModStart> if ( h -> attrBools != NULL ) return ( - 1 ) ; 
3930,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> ignore = fscanf ( fp , ""Rootname:<S2SV_blank>%s\\n"" , buf ) ; <S2SV_EndBug> <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> <S2SV_StartBug> ignore = fscanf ( fp , ""Commandfile<S2SV_blank>name:<S2SV_blank>%s\\n"" , buf ) ; <S2SV_EndBug> <S2SV_StartBug> ignore = fscanf ( fp , ""Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%s\\n"" , buf ) ; <S2SV_EndBug> ","<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> ""Rootname:<S2SV_blank>%511s\\n"" <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> ""Commandfile<S2SV_blank>name:<S2SV_blank>%511s\\n"" <S2SV_ModEnd> <S2SV_ModStart> ""Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%511s\\n"" <S2SV_ModEnd> "
3931,"<S2SV_StartBug> ngx_uint_t n , sec , min , hour , mday , mon , year , wday , days , leap ; <S2SV_EndBug> <S2SV_StartBug> n = ( ngx_uint_t ) t ; <S2SV_EndBug> <S2SV_StartBug> wday = ( 4 + days ) % 7 ; <S2SV_EndBug> <S2SV_StartBug> n %= 86400 ; <S2SV_EndBug> <S2SV_StartBug> n %= 3600 ; <S2SV_EndBug> <S2SV_StartBug> min = n / 60 ; <S2SV_EndBug> <S2SV_StartBug> sec = n % 60 ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( t < 0 ) { t = 0 ; } days = t <S2SV_ModEnd> <S2SV_ModStart> sec = t % 86400 ; <S2SV_ModStart> hour = sec <S2SV_ModEnd> <S2SV_ModStart> sec <S2SV_ModEnd> <S2SV_ModStart> sec <S2SV_ModEnd> <S2SV_ModStart> %= <S2SV_ModEnd> 
3932,<S2SV_StartBug> if ( tpgt > TL_TPGS_PER_HBA ) { <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> 
3933,"<S2SV_StartBug> int len ; <S2SV_EndBug> <S2SV_StartBug> if ( config . hostsocket != NULL ) <S2SV_EndBug> <S2SV_StartBug> len = snprintf ( config . prompt , sizeof ( config . prompt ) , ""redis<S2SV_blank>%s"" , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sds prompt = sdsempty ( ) ; <S2SV_ModStart> { prompt = sdscatfmt ( prompt , ""redis<S2SV_blank>%s"" , config . hostsocket ) ; } else { char addr [ 256 ] ; anetFormatAddr ( addr , sizeof ( addr ) , config . hostip , config . hostport ) ; prompt = sdscatlen ( prompt , addr , strlen ( addr ) ) ; } if ( config . dbnum != 0 ) prompt = sdscatfmt ( prompt , ""[%i]"" , config . dbnum ) ; prompt = sdscatlen ( prompt , ""><S2SV_blank>"" , 2 ) ; <S2SV_ModEnd> <S2SV_ModStart> ""%s"" , prompt ) ; sdsfree ( prompt <S2SV_ModEnd> "
3934,<S2SV_StartBug> total = le32_to_cpu ( raw_super -> segment_count ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( f2fs_cp_error ( sbi ) ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> unsigned int main_segs , blocks_per_seg ; int i ; <S2SV_ModStart> main_segs = le32_to_cpu ( raw_super -> segment_count_main ) ; blocks_per_seg = sbi -> blocks_per_seg ; for ( i = 0 ; i < NR_CURSEG_NODE_TYPE ; i ++ ) { if ( le32_to_cpu ( ckpt -> cur_node_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_node_blkoff [ i ] ) >= blocks_per_seg ) return 1 ; } for ( i = 0 ; i < NR_CURSEG_DATA_TYPE ; i ++ ) { if ( le32_to_cpu ( ckpt -> cur_data_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_data_blkoff [ i ] ) >= blocks_per_seg ) return 1 ; } "
3935,<S2SV_StartBug> __be16 type ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( NAPI_GRO_CB ( skb ) -> encap_mark ) goto out ; NAPI_GRO_CB ( skb ) -> encap_mark = 1 
3936,"<S2SV_StartBug> . dump = link -> dump , <S2SV_EndBug> ","<S2SV_ModStart> start = link -> start , . "
3937,"<S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! dev && capable ( CAP_NET_ADMIN ) ) <S2SV_EndBug> <S2SV_StartBug> request_module ( ""%s"" , name ) ; <S2SV_EndBug> ","<S2SV_ModStart> int no_module ; <S2SV_ModStart> no_module = ! dev ; if ( no_module <S2SV_ModEnd> <S2SV_ModStart> no_module = request_module ( ""netdev-%s"" , name ) ; if ( no_module && capable ( CAP_SYS_MODULE ) ) { if ( ! <S2SV_ModStart> ) pr_err ( ""Loading<S2SV_blank>kernel<S2SV_blank>module<S2SV_blank>for<S2SV_blank>a<S2SV_blank>network<S2SV_blank>device<S2SV_blank>"" ""with<S2SV_blank>CAP_SYS_MODULE<S2SV_blank>(deprecated).<S2SV_blank><S2SV_blank>Use<S2SV_blank>CAP_NET_ADMIN<S2SV_blank>and<S2SV_blank>alias<S2SV_blank>netdev-%s<S2SV_blank>"" ""instead\\n"" , name ) ; } } <S2SV_ModEnd> "
3938,<S2SV_StartBug> cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ; <S2SV_EndBug> <S2SV_StartBug> cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ; <S2SV_EndBug> ,<S2SV_ModStart> ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ; cpio -> extract_flags |= <S2SV_ModStart> ; cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS 
3939,"<S2SV_StartBug> if ( setting_MakeCompatCore && ulimit_c != 0 ) <S2SV_EndBug> <S2SV_StartBug> dd = dd_create_skeleton ( path , fsuid , DEFAULT_DUMP_DIR_MODE , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> const uid_t dduid = g_settings_privatereports ? 0 : fsuid ; <S2SV_ModStart> dduid <S2SV_ModEnd> 
3940,"<S2SV_StartBug> logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; <S2SV_EndBug> <S2SV_StartBug> quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; quantum_info = ( QuantumInfo * ) NULL <S2SV_ModStart> if ( quantum_info != ( QuantumInfo * ) NULL ) 
3941,"<S2SV_StartBug> static void update_open_stateflags ( struct nfs4_state * state , mode_t open_flags ) <S2SV_EndBug> <S2SV_StartBug> switch ( open_flags ) { <S2SV_EndBug> <S2SV_StartBug> nfs4_state_set_mode_locked ( state , state -> state | open_flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> 
3942,"<S2SV_StartBug> const uint8_t * * remainder_out , size_t * rlen_out ) <S2SV_EndBug> <S2SV_StartBug> p = asn1 ; <S2SV_EndBug> <S2SV_StartBug> ret = get_tag ( p , len , & t , & c , & clen , & p , & len ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int recursion <S2SV_ModStart> if ( recursion >= 32 ) return ASN1_OVERFLOW ; <S2SV_ModStart> , recursion + 1 "
3943,"<S2SV_StartBug> # define ThrowCUTReaderException ( severity , tag ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( severity , tag ) ; } <S2SV_EndBug> <S2SV_StartBug> offset = SeekBlob ( image , 6 , SEEK_SET ) ; <S2SV_EndBug> ","<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ; "
3944,<S2SV_StartBug> if ( code == gcode ) <S2SV_EndBug> ,<S2SV_ModStart> && wordlist [ key ] . index >= 0 
3945,<S2SV_StartBug> static void <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
3946,"<S2SV_StartBug> int copied , err ; <S2SV_EndBug> <S2SV_StartBug> sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_EndBug> <S2SV_StartBug> if ( sock -> type == SOCK_PACKET ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> copied = skb -> len ; <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_name ) <S2SV_EndBug> <S2SV_StartBug> msg -> msg_namelen ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } else { struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_ModEnd> <S2SV_ModStart> } memcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } "
3947,"<S2SV_StartBug> if ( uid_eq ( uid , current_fsuid ( ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( gid_eq ( gid , current_fsgid ( ) ) ) <S2SV_EndBug> ",<S2SV_ModStart> file -> f_cred -> fsuid <S2SV_ModEnd> <S2SV_ModStart> file -> f_cred -> fsgid <S2SV_ModEnd> 
3948,<S2SV_StartBug> char * ret ; <S2SV_EndBug> <S2SV_StartBug> if ( ptr [ strlen ( ptr ) - 1 ] == '\\n' ) <S2SV_EndBug> <S2SV_StartBug> ptr [ strlen ( ptr ) - 1 ] = '\\0' ; <S2SV_EndBug> ,<S2SV_ModStart> ; size_t len <S2SV_ModStart> len = <S2SV_ModEnd> <S2SV_ModStart> ; if ( len > 0 && ptr [ len <S2SV_ModStart> len <S2SV_ModEnd> 
3949,<S2SV_StartBug> fid -> udf . generation = inode -> i_generation ; <S2SV_EndBug> ,<S2SV_ModStart> parent_partref = 0 ; fid -> udf . 
3950,"<S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> <S2SV_StartBug> index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ; <S2SV_EndBug> <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> if ( k < 0 ) continue <S2SV_ModEnd> 
3951,<S2SV_StartBug> SEPARATE_ZVAL ( ( var ) ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_long ( * var ) ; <S2SV_EndBug> <S2SV_StartBug> points [ i ] . x = Z_LVAL_PP ( var ) ; <S2SV_EndBug> <S2SV_StartBug> SEPARATE_ZVAL ( var ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_long ( * var ) ; <S2SV_EndBug> <S2SV_StartBug> points [ i ] . y = Z_LVAL_PP ( var ) ; <S2SV_EndBug> <S2SV_StartBug> if ( filled ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( Z_TYPE_PP ( var ) != IS_LONG ) { zval lval ; lval = * * var ; zval_copy_ctor ( & lval <S2SV_ModEnd> <S2SV_ModStart> & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { points [ i ] . x = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( var ) != IS_LONG ) { zval lval ; lval = * * var ; zval_copy_ctor ( & lval <S2SV_ModEnd> <S2SV_ModStart> & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { points [ i ] . y = <S2SV_ModStart> } 
3952,"<S2SV_StartBug> gdImageGifCtx ( im , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! _gdImageGifCtx <S2SV_ModEnd> <S2SV_ModStart> ) { <S2SV_ModEnd> <S2SV_ModStart> } else { rv = NULL ; } 
3953,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> ( void ) mbmi ; 
3954,"<S2SV_StartBug> static inline bool unconditional ( const struct ipt_ip * ip ) <S2SV_EndBug> <S2SV_StartBug> return memcmp ( ip , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug> ",<S2SV_ModStart> ipt_entry * e <S2SV_ModEnd> <S2SV_ModStart> e -> target_offset == sizeof ( struct ipt_entry ) && memcmp ( & e -> <S2SV_ModEnd> 
3955,"<S2SV_StartBug> err = bnep_add_connection ( & ca , nsock ) ; <S2SV_EndBug> ",<S2SV_ModStart> ca . device [ sizeof ( ca . device ) - 1 ] = 0 ; 
3956,"<S2SV_StartBug> vpx_memset ( overlaps , 0 , sizeof ( MB_OVERLAP ) * mb_rows * mb_cols ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> 
3957,<S2SV_StartBug> const char need_to_append_dot = base_name [ base_len - 1 ] == '.' ? 0 : 1 ; <S2SV_EndBug> <S2SV_StartBug> struct search_domain * dom ; <S2SV_EndBug> ,<S2SV_ModStart> char need_to_append_dot ; struct search_domain * dom ; if ( ! base_len ) return NULL ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3958,<S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> <S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> <S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> <S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> ,<S2SV_ModStart> bailout <S2SV_ModEnd> <S2SV_ModStart> bailout <S2SV_ModEnd> <S2SV_ModStart> bailout <S2SV_ModEnd> <S2SV_ModStart> bailout <S2SV_ModEnd> 
3959,<S2SV_StartBug> if ( iter > CIPSO_V4_TAG_MAXCNT ) <S2SV_EndBug> <S2SV_StartBug> if ( iter < CIPSO_V4_TAG_MAXCNT ) <S2SV_EndBug> <S2SV_StartBug> doi_def -> tags [ iter ] = CIPSO_V4_TAG_INVALID ; <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> <S2SV_ModStart> while <S2SV_ModEnd> <S2SV_ModStart> ++ 
3960,"<S2SV_StartBug> ftpClientFormatCommand ( context , ""LIST"" , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> ftpClientFormatCommand ( context , ""LIST"" , path ) ; <S2SV_EndBug> ",<S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> } 
3961,"<S2SV_StartBug> if ( S_ISDIR ( fmode ) && S_ISLNK ( sb . st_mode ) && stat ( fn , & sb ) != 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> ) { struct stat dsb ; if ( stat ( fn , & dsb ) == 0 && S_ISDIR ( dsb . st_mode ) ) { uid_t fuid ; if ( sb . st_uid == 0 || ( rpmugUid ( rpmfilesFUser ( fi , ix ) , & fuid ) == 0 && sb . st_uid == fuid ) ) { sb = dsb ; } } <S2SV_ModEnd> "
3962,<S2SV_StartBug> req -> started = false ; <S2SV_EndBug> <S2SV_StartBug> if ( dep -> number > 1 ) <S2SV_EndBug> ,"<S2SV_ModStart> dwc3_gadget_del_and_unmap_request ( dep , req , status <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3963,<S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> ,<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> 
3964,<S2SV_StartBug> return - E_NOTHANDLED ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ninst == 0 ) return - E_INVALID 
3965,<S2SV_StartBug> return new_ns ; <S2SV_EndBug> ,<S2SV_ModStart> new_ns -> mounts = 0 ; new_ns -> pending_mounts = 0 ; 
3966,<S2SV_StartBug> # ifdef HAVE_OPENSSL <S2SV_EndBug> ,<S2SV_ModStart> SSL_SET_OPTIONS ( & mysql ) ; <S2SV_ModEnd> 
3967,<S2SV_StartBug> struct f2fs_sb_info * sbi = F2FS_I_SB ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! i_ext || ! i_ext -> len ) <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> ,"<S2SV_ModStart> bool ret = __f2fs_init_extent_tree ( inode , i_ext <S2SV_ModEnd> <S2SV_ModStart> F2FS_I ( inode ) -> extent_tree ) set_inode_flag ( inode , FI_NO_EXTENT <S2SV_ModEnd> <S2SV_ModStart> ret <S2SV_ModEnd> "
3968,"<S2SV_StartBug> size_t buf_size = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_pack ( msg -> msg_iov , ( int ) msg -> msg_iovlen , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ","<S2SV_ModStart> = 0 ; size_t data_size <S2SV_ModStart> , & data_size <S2SV_ModStart> ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } "
3969,"<S2SV_StartBug> ast_for_for_stmt ( struct compiling * c , const node * n , int is_async ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> type_comment , LINENO ( n ) , n -> n_col_offset , <S2SV_EndBug> ","<S2SV_ModStart> n0 , bool <S2SV_ModEnd> <S2SV_ModStart> const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; <S2SV_ModStart> n0 ) , n0 <S2SV_ModEnd> "
3970,<S2SV_StartBug> ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error ) <S2SV_EndBug> ,<S2SV_ModStart> && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) 
3971,"<S2SV_StartBug> if ( ! mx_is_imap ( path ) || imap_parse_path ( path , & mx ) || ! mx . mbox ) <S2SV_EndBug> <S2SV_StartBug> snprintf ( mbox , sizeof ( mbox ) , ""%smailboxes<S2SV_blank>\\""%s\\"""" , subscribe ? """" : ""un"" , path ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t len = 0 ; <S2SV_ModStart> len = <S2SV_ModStart> ""%smailboxes<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ) ; imap_quote_string ( mbox + len , sizeof ( mbox ) - len , path , true <S2SV_ModEnd> "
3972,<S2SV_StartBug> dsize += svbranch . len ; <S2SV_EndBug> ,<S2SV_ModStart> + 1 
3973,<S2SV_StartBug> length = icon_file . directory [ i ] . size ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( ~ length < 16 ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) "
3974,<S2SV_StartBug> if ( old -> curframe != cur -> curframe ) <S2SV_EndBug> ,<S2SV_ModStart> ) return false ; if ( old -> speculative && ! cur -> speculative 
3975,"<S2SV_StartBug> * image ; <S2SV_EndBug> <S2SV_StartBug> value , <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 0 ] . red = QuantumRange ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 0 ] . green = QuantumRange ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 0 ] . blue = QuantumRange ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 1 ] . red = ( Quantum ) 0 ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 1 ] . green = ( Quantum ) 0 ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 1 ] . blue = ( Quantum ) 0 ; <S2SV_EndBug> <S2SV_StartBug> value = XBMInteger ( image , hex_digits ) ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) ( value >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> value = XBMInteger ( image , hex_digits ) ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> <S2SV_StartBug> byte = ( size_t ) ( * p ++ ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; int c <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( MagickRealType ) <S2SV_ModStart> ( MagickRealType ) <S2SV_ModStart> ( MagickRealType ) <S2SV_ModStart> 0.0 <S2SV_ModEnd> <S2SV_ModStart> 0.0 <S2SV_ModEnd> <S2SV_ModStart> 0.0 <S2SV_ModEnd> <S2SV_ModStart> c <S2SV_ModEnd> <S2SV_ModStart> ; if ( c < 0 ) break <S2SV_ModStart> c <S2SV_ModEnd> <S2SV_ModStart> c <S2SV_ModEnd> <S2SV_ModStart> c <S2SV_ModEnd> <S2SV_ModStart> ; if ( c < 0 ) break <S2SV_ModStart> c ; } if ( EOFBlob ( image ) != MagickFalse ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) <S2SV_ModEnd> <S2SV_ModStart> unsigned int <S2SV_ModEnd> "
3976,"<S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> 1 , <S2SV_ModStart> 1 , <S2SV_ModStart> 0 , "
3977,<S2SV_StartBug> int rv ; <S2SV_EndBug> ,"<S2SV_ModStart> ; clear_bit ( WDM_OVERFLOW , & desc -> flags ) "
3978,<S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> sock * sk = asoc -> base . sk ; struct <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3979,"<S2SV_StartBug> unsigned int len ; <S2SV_EndBug> <S2SV_StartBug> fbdev = to_au1100fb_device ( fbi ) ; <S2SV_EndBug> <S2SV_StartBug> if ( io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return vm_iomap_memory <S2SV_ModEnd> <S2SV_ModStart> fbdev -> fb_phys , fbdev -> fb_len ) <S2SV_ModEnd> "
3980,"<S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 
3981,"<S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIE , EIE_INTIE ) ; <S2SV_EndBug> <S2SV_StartBug> status = enc28j60ReadReg ( interface , ENC28J60_REG_EIR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & EIR_LINKIF ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIE , EIE_LINKIE ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & EIR_PKTIF ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIE , EIE_PKTIE ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & ( EIR_TXIF | EIE_TXERIE ) ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_TXIF | EIE_TXERIE ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_EIE , EIE_INTIE ) ; <S2SV_EndBug> ","<S2SV_ModStart> ENC28J60_EIE , ENC28J60_EIE_INTIE <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIR <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIR_LINKIF <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIE , ENC28J60_EIE_LINKIE <S2SV_ModEnd> <S2SV_ModStart> enc28j60ReadReg ( interface , ENC28J60_EPKTCNT <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIE , ENC28J60_EIE_PKTIE <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIR_TXIF | ENC28J60_EIE_TXERIE <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIR , ENC28J60_EIR_TXIF | ENC28J60_EIE_TXERIE <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIE , ENC28J60_EIE_INTIE <S2SV_ModEnd> "
3982,<S2SV_StartBug> temp = ( struct sackhole * ) <S2SV_EndBug> <S2SV_StartBug> temp = ( struct sackhole * ) <S2SV_EndBug> ,<S2SV_ModStart> if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ; <S2SV_ModStart> if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ; 
3983,<S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug> ,<S2SV_ModStart> ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> 
3984,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
3985,"<S2SV_StartBug> static int t220_frontend_attach ( struct dvb_usb_adapter * d ) <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x86 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x80 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> msleep ( 50 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_EndBug> <S2SV_StartBug> d -> fe_adap [ 0 ] . fe = dvb_attach ( cxd2820r_attach , & cxd2820r_config , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( d -> fe_adap [ 0 ] . fe != NULL ) { <S2SV_EndBug> <S2SV_StartBug> if ( dvb_attach ( tda18271_attach , d -> fe_adap [ 0 ] . fe , 0x60 , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap , & tda18271_config ) ) { <S2SV_EndBug> ","<S2SV_ModStart> adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x87 ; state -> data [ 2 ] = 0x0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x86 ; state -> data [ 2 ] = 1 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data [ 1 ] = 0x80 ; state -> data <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> msleep ( 50 ) ; state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data [ 0 ] = 0x51 <S2SV_ModEnd> <S2SV_ModStart> , state -> data , 1 , state -> data <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
3986,"<S2SV_StartBug> if ( ! validate_event ( & fake_pmu , leader ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! validate_event ( & fake_pmu , sibling ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! validate_event ( & fake_pmu , event ) ) <S2SV_EndBug> ","<S2SV_ModStart> event -> pmu , <S2SV_ModStart> event -> pmu , <S2SV_ModStart> event -> pmu , "
3987,"<S2SV_StartBug> fd = open ( authfile , O_RDONLY , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> else if ( fd >= 0 ) <S2SV_EndBug> ",<S2SV_ModStart> | O_CLOEXEC | O_NOCTTY <S2SV_ModEnd> <S2SV_ModStart> ; } else { fd = - 1 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> != - 1 <S2SV_ModEnd> 
3988,<S2SV_StartBug> ether_setup ( dev ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING 
3989,"<S2SV_StartBug> if ( ACTION ( RUN ) ) <S2SV_EndBug> <S2SV_StartBug> handle_do_action ( req , res ) ; <S2SV_EndBug> <S2SV_StartBug> handle_action ( req , res ) ; <S2SV_EndBug> ","<S2SV_ModStart> RUNTIME ) ) handle_runtime_action ( req , res ) ; else if ( ACTION ( VIEWLOG ) ) do_viewlog <S2SV_ModEnd> <S2SV_ModStart> handle_doaction <S2SV_ModEnd> <S2SV_ModStart> handle_service_action <S2SV_ModEnd> "
3990,"<S2SV_StartBug> ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & kvm -> lock ) ; <S2SV_EndBug> <S2SV_StartBug> kvm_get_kvm ( kvm ) ; <S2SV_EndBug> ",<S2SV_ModStart> kvm_get_kvm ( kvm ) ; <S2SV_ModStart> kvm_put_kvm ( kvm ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
3991,<S2SV_StartBug> Z_STRVAL_P ( return_value ) = emalloc ( len + 1 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( len > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d"" , INT_MAX ) ; RETURN_FALSE ; } "
3992,"<S2SV_StartBug> for ( i = 0 ; i < count && strlen ( op -> txt ) + 10 < R_ASM_BUFSIZE ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> int optxtlen = strlen ( op -> txt ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d"" , def ) ; <S2SV_EndBug> ","<S2SV_ModStart> char * txt = op -> txt ; int txtLen = strlen ( op -> txt ) ; int txtLeft = R_ASM_BUFSIZE - txtLen ; txt += txtLen ; <S2SV_ModStart> txtLen <S2SV_ModEnd> <S2SV_ModStart> snprintf ( txt , txtLeft <S2SV_ModEnd> <S2SV_ModStart> txtLen = strlen ( txt ) ; txt += txtLen ; txtLeft -= txtLen ; <S2SV_ModStart> txt , txtLeft - 1 <S2SV_ModEnd> "
3993,<S2SV_StartBug> addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> ,<S2SV_ModStart> INADDR_LOOPBACK <S2SV_ModEnd> 
3994,"<S2SV_StartBug> while ( ! EOFBlob ( image ) ) <S2SV_EndBug> <S2SV_StartBug> if ( filepos != ( unsigned int ) filepos ) <S2SV_EndBug> <S2SV_StartBug> if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) > GetBlobSize ( image ) ) <S2SV_EndBug> <S2SV_StartBug> ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> filepos < GetBlobSize ( image ) && <S2SV_ModStart> > GetBlobSize ( image ) || filepos < 0 <S2SV_ModEnd> <S2SV_ModStart> >= <S2SV_ModEnd> <S2SV_ModStart> ) ; ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" "
3995,"<S2SV_StartBug> static UINT32 nsc_rle_encode ( BYTE * in , BYTE * out , UINT32 originalSize ) <S2SV_EndBug> ",<S2SV_ModStart> const 
3996,"<S2SV_StartBug> static void vp8_init_ctx ( vpx_codec_ctx_t * ctx , const vpx_codec_mmap_t * mmap ) <S2SV_EndBug> <S2SV_StartBug> ctx -> priv = mmap -> base ; <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> config . dec ) <S2SV_EndBug> <S2SV_StartBug> ctx -> priv -> alg_priv -> cfg = * ctx -> config . dec ; <S2SV_EndBug> <S2SV_StartBug> ctx -> config . dec = & ctx -> priv -> alg_priv -> cfg ; <S2SV_EndBug> ","<S2SV_ModStart> ) { vpx_codec_alg_priv_t * priv = ( vpx_codec_alg_priv_t * ) vpx_calloc ( 1 , sizeof ( * priv ) ) <S2SV_ModEnd> <S2SV_ModStart> ( vpx_codec_priv_t * ) priv <S2SV_ModEnd> <S2SV_ModStart> priv -> si . sz = sizeof ( priv -> si ) ; priv -> decrypt_cb = NULL ; priv -> decrypt_state = NULL ; <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> "
3997,"<S2SV_StartBug> int i , j , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ; <S2SV_EndBug> <S2SV_StartBug> uint16 bps , nstrips , planar , strips_per_sample ; <S2SV_EndBug> ","<S2SV_ModStart> bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ; uint32 j <S2SV_ModEnd> <S2SV_ModStart> planar ; uint32 nstrips ; uint32 <S2SV_ModEnd> "
3998,"<S2SV_StartBug> static int override_release ( char __user * release , int len ) <S2SV_EndBug> <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> char * rest = UTS_RELEASE ; <S2SV_EndBug> <S2SV_StartBug> unsigned v ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , len , ""2.6.%u%s"" , v , rest ) ; <S2SV_EndBug> <S2SV_StartBug> ret = copy_to_user ( release , buf , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> ; char buf [ 65 ] = { 0 } <S2SV_ModStart> ; size_t copy <S2SV_ModStart> copy = min ( sizeof ( buf ) , max_t ( size_t , 1 , len ) ) ; copy = scnprintf <S2SV_ModEnd> <S2SV_ModStart> copy <S2SV_ModEnd> <S2SV_ModStart> copy + 1 <S2SV_ModEnd> "
3999,"<S2SV_StartBug> pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ; <S2SV_EndBug> ",<S2SV_ModStart> PAGE_KERNEL <S2SV_ModEnd> 
4000,"<S2SV_StartBug> rc = foreach_nfs_shareopt ( shareopts , get_linux_shareopts_cb , <S2SV_EndBug> ",<S2SV_ModStart> foreach_shareopt <S2SV_ModEnd> 
4001,<S2SV_StartBug> ncomponents = bytestream2_get_be16u ( & s -> g ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( s -> image_offset_x || s -> image_offset_y ) { avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>image<S2SV_blank>offsets"" ) ; return AVERROR_PATCHWELCOME ; } "
4002,"<S2SV_StartBug> isoclns_print ( ndo , p , length , length ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
4003,<S2SV_StartBug> for ( i = num_excl_chan ; i < num_excl_chan + 7 ; i ++ ) <S2SV_EndBug> ,<S2SV_ModStart> if ( i >= MAX_CHANNELS - num_excl_chan - 7 ) return n ; 
4004,<S2SV_StartBug> if ( esd ) { <S2SV_EndBug> ,<S2SV_ModStart> && esd -> decoderConfig 
4005,"<S2SV_StartBug> mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <S2SV_EndBug> ",<S2SV_ModStart> cache_id ( <S2SV_ModStart> ) 
4006,<S2SV_StartBug> if ( val == 0 && sp -> do_auto_asconf ) { <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> spin_lock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; <S2SV_ModStart> spin_unlock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; 
4007,<S2SV_StartBug> char * authn_header = oidc_cfg_dir_authn_header ( r ) ; <S2SV_EndBug> ,<S2SV_ModStart> oidc_scrub_headers ( r ) ; 
4008,<S2SV_StartBug> char fnam [ PROCLEN ] ; <S2SV_EndBug> <S2SV_StartBug> char * line = NULL ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> if ( nextcg ) <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> c2 = get_pid_cgroup ( pid , contrl ) ; char * linecmp <S2SV_ModEnd> <S2SV_ModStart> return false <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> out : free ( c2 <S2SV_ModEnd> "
4009,"<S2SV_StartBug> if ( ( fd = open ( path_name , ( O_CREAT | O_APPEND | O_WRONLY ) , 0644 ) ) == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> error ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s"" , path_name , <S2SV_EndBug> ","<S2SV_ModStart> _open_as_other ( path_name , req <S2SV_ModEnd> <S2SV_ModStart> ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>Permission<S2SV_blank>denied"" , path_name <S2SV_ModEnd> "
4010,<S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ; <S2SV_EndBug> ,"<S2SV_ModStart> size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> alloc_size <S2SV_ModEnd> "
4011,"<S2SV_StartBug> static char * <S2SV_EndBug> <S2SV_StartBug> if ( enc == NULL ) <S2SV_EndBug> <S2SV_StartBug> char * dec = g_strdup ( enc ) ; <S2SV_EndBug> <S2SV_StartBug> g_base64_decode_inplace ( dec , & len ) ; <S2SV_EndBug> ",<S2SV_ModStart> gchar <S2SV_ModEnd> <S2SV_ModStart> gchar * dec ; gsize len ; <S2SV_ModStart> dec = ( gchar * ) g_base64_decode ( enc <S2SV_ModEnd> <S2SV_ModStart> if ( dec ) 
4012,<S2SV_StartBug> if ( socket -> interface != NULL ) <S2SV_EndBug> ,<S2SV_ModStart> if ( message -> interface != NULL ) { interface = message -> interface ; } else 
4013,<S2SV_StartBug> stripsperplane = ( ( td -> td_imagelength + rowsperstrip - 1 ) / rowsperstrip ) ; <S2SV_EndBug> ,"<S2SV_ModStart> TIFFhowmany_32_maxuint_compat <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> "
4014,<S2SV_StartBug> if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) ) <S2SV_EndBug> ,<S2SV_ModStart> validate_core_offset ( reg ) ) return - EINVAL ; if ( 
4015,"<S2SV_StartBug> safe_print ( value , valsz , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> safe_print ( value , valsz , ""\\"""" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank>\\\\\\""\'$`<>"" <S2SV_ModEnd> <S2SV_ModStart> ""\\""\\\\"" ) ; fputs ( ""\\"""" <S2SV_ModEnd> "
4016,<S2SV_StartBug> if ( ! SSL_USE_ETM ( s ) && mac_size != 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( SSL_USE_ETM ( s ) && mac_size != 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> SSL_WRITE_ETM <S2SV_ModEnd> <S2SV_ModStart> SSL_WRITE_ETM <S2SV_ModEnd> 
4017,"<S2SV_StartBug> static int read_frame_stats ( const struct twopass_rc * p , <S2SV_EndBug> <S2SV_StartBug> const FIRSTPASS_STATS * fps_ptr = p -> stats_in ; <S2SV_EndBug> <S2SV_StartBug> if ( offset >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( & fps_ptr [ offset ] >= p -> stats_in_end ) <S2SV_EndBug> <S2SV_StartBug> } else if ( offset < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( & fps_ptr [ offset ] < p -> stats_in_start ) <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ",<S2SV_ModStart> const FIRSTPASS_STATS * <S2SV_ModEnd> <S2SV_ModStart> TWO_PASS * p <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> && p -> stats_in + offset <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> && p -> stats_in + offset <S2SV_ModEnd> <S2SV_ModStart> ) { return NULL ; } return & p -> stats_in <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4018,<S2SV_StartBug> goto err_unregister_v4l2_dev ; <S2SV_EndBug> <S2SV_StartBug> err_unregister_v4l2_dev : <S2SV_EndBug> ,<S2SV_ModStart> err_free_controls <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4019,"<S2SV_StartBug> static vpx_codec_err_t vp8_set_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
4020,<S2SV_StartBug> if ( noblock ) <S2SV_EndBug> ,<S2SV_ModStart> cond_resched ( ) <S2SV_ModEnd> 
4021,"<S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> ",<S2SV_ModStart> key_is_positive ( key <S2SV_ModEnd> 
4022,"<S2SV_StartBug> for ( j = 0 ; j < len ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> av_log ( s , AV_LOG_DEBUG , ""%X"" , avio_r8 ( pb ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } 
4023,<S2SV_StartBug> if ( daddr == 0 || rs -> rs_bound_addr == 0 ) { <S2SV_EndBug> <S2SV_StartBug> ret = - ENOTCONN ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> lock_sock ( sk ) ; <S2SV_ModStart> release_sock ( sk ) ; <S2SV_ModStart> release_sock ( sk ) ; 
4024,<S2SV_StartBug> convert_to_double_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> m1 [ i ] = Z_DVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_double_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> m2 [ i ] = Z_DVAL_PP ( tmp ) ; <S2SV_EndBug> ,<S2SV_ModStart> { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> <S2SV_ModStart> Z_DVAL ( dval ) ; } <S2SV_ModEnd> <S2SV_ModStart> { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> <S2SV_ModStart> Z_DVAL ( dval ) ; } <S2SV_ModEnd> 
4025,<S2SV_StartBug> jas_stream_t * stream ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( stream = jas_stream_create ( ) ) ) { <S2SV_EndBug> <S2SV_StartBug> obj -> bufsize_ = 1024 ; <S2SV_EndBug> <S2SV_StartBug> obj -> bufsize_ = bufsize ; <S2SV_EndBug> <S2SV_StartBug> obj -> growable_ = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> char * new_buf ; size_t new_bufsize <S2SV_ModEnd> <S2SV_ModStart> bufsize < 0 ) { jas_deprecated ( ""negative<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>for<S2SV_blank>jas_stream_memopen"" ) ; } if ( buf && bufsize <= 0 ) { jas_eprintf ( ""Invalid<S2SV_blank>use<S2SV_blank>of<S2SV_blank>jas_stream_memopen<S2SV_blank>detected.\\n"" ) ; jas_deprecated ( ""A<S2SV_blank>user-provided<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>"" ""jas_stream_memopen<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>growable.\\n"" ) ; } <S2SV_ModEnd> <S2SV_ModStart> new_bufsize = 0 ; new_buf = 0 <S2SV_ModEnd> <S2SV_ModStart> new_bufsize <S2SV_ModEnd> <S2SV_ModStart> new_buf = buf ; } return jas_stream_memopen2 ( new_buf , new_bufsize ) <S2SV_ModEnd> "
4026,<S2SV_StartBug> if ( sk -> sk_protocol == IPPROTO_TCP ) <S2SV_EndBug> ,<S2SV_ModStart> && sk -> sk_type == SOCK_STREAM 
4027,<S2SV_StartBug> net -> dev_base_seq = 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> get_random_bytes ( & net -> hash_mix , sizeof ( u32 ) ) ; "
4028,<S2SV_StartBug> overrun = timr -> it_overrun_last ; <S2SV_EndBug> ,"<S2SV_ModStart> timer_overrun_to_int ( timr , 0 ) <S2SV_ModEnd> "
4029,"<S2SV_StartBug> if ( map && nmap ) { <S2SV_EndBug> <S2SV_StartBug> cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ep2 , map , nmap ) ; else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart>  <S2SV_ModEnd> "
4030,"<S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; <S2SV_EndBug> ","<S2SV_ModStart> uint32 length ; struct stream packet = * s <S2SV_ModEnd> <S2SV_ModStart> if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""mcs_parse_domain_params(),<S2SV_blank>consume<S2SV_blank>domain<S2SV_blank>params<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } "
4031,"<S2SV_StartBug> int fd = - 1 , ofd = - 1 , ret , ifindex = - 1 ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'."" , getpid ( ) ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'."" , pid ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( setns ( fd , 0 ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> close ( fd ) ; fd = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ifindex = if_nametoindex ( oldname ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> char ifname [ IFNAMSIZ ] , * namep = ifname ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> goto out_err ; <S2SV_EndBug> <S2SV_StartBug> if ( setns ( ofd , 0 ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> ","<S2SV_ModStart> uid_t ruid , suid , euid ; int fret = - 1 ; int fd = - 1 , ifindex <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> usernic_error ( <S2SV_ModEnd> <S2SV_ModStart> fret <S2SV_ModEnd> <S2SV_ModStart> usernic_error ( <S2SV_ModEnd> <S2SV_ModStart> goto do_partial_cleanup ; } ret = getresuid ( & ruid , & euid , & suid ) ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>real,<S2SV_blank>effective,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>"" ""user<S2SV_blank>IDs:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = <S2SV_ModEnd> <S2SV_ModStart> CLONE_NEWNET ) ; <S2SV_ModEnd> <S2SV_ModStart> fd = - 1 ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>the<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>of<S2SV_blank>"" ""the<S2SV_blank>container<S2SV_blank>with<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\n"" , pid , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = setresuid ( ruid , ruid , 0 ) ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>"" ""user<S2SV_blank>id<S2SV_blank>and<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>"" ""ID<S2SV_blank>to<S2SV_blank>0:<S2SV_blank>%s.\\n"" , ruid , strerror ( errno ) ) ; goto do_full_cleanup ; } <S2SV_ModEnd> <S2SV_ModStart> ifindex = if_nametoindex ( oldname ) ; <S2SV_ModStart> ifindex ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>netdev<S2SV_blank>index:<S2SV_blank>%s.\\n"" , strerror ( errno ) ) ; goto do_full_cleanup ; } } ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ; if ( ret < 0 ) { usernic_error ( ""Error<S2SV_blank>%d<S2SV_blank>renaming<S2SV_blank>netdev<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>container.\\n"" , ret , <S2SV_ModEnd> <S2SV_ModStart> ; goto do_full_cleanup <S2SV_ModEnd> <S2SV_ModStart> ; char <S2SV_ModEnd> <S2SV_ModStart> usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name:<S2SV_blank>%s.\\n"" , strerror ( errno ) ) ; goto do_full_cleanup <S2SV_ModEnd> <S2SV_ModStart> do_full_cleanup ; } fret = 0 ; do_full_cleanup : ret = setresuid ( ruid , euid , suid ) ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>restore<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>"" ""user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>"" ""ID<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>%s.\\n"" , ruid , euid , suid , strerror ( errno ) ) ; fret = - 1 ; } ret = <S2SV_ModEnd> <S2SV_ModStart> CLONE_NEWNET ) ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>original<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>"" ""of<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\n"" , ofd , strerror ( errno ) ) ; fret = - 1 ; } do_partial_cleanup : if ( fd >= 0 ) close ( fd ) ; close ( <S2SV_ModEnd> <S2SV_ModStart> fret <S2SV_ModEnd> "
4032,<S2SV_StartBug> for ( i = 0 ; i < pbi -> allocated_decoding_thread_count ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < pbi -> allocated_decoding_thread_count ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> ++ i <S2SV_ModEnd> <S2SV_ModStart> ++ i <S2SV_ModEnd> <S2SV_ModStart> vp8mt_de_alloc_temp_buffers ( pbi , pbi -> common . mb_rows ) ; "
4033,<S2SV_StartBug> if ( strlen ( parv [ 1 ] ) > 400 ) <S2SV_EndBug> ,"<S2SV_ModStart> ( parv [ 1 ] [ 0 ] == ':' ) || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) { sendto_one ( sptr , err_str ( ERR_CANNOTDOCOMMAND ) , me . name , ""*"" , ""AUTHENTICATE"" , ""Invalid<S2SV_blank>parameter"" ) ; return 0 ; } if ( "
4034,"<S2SV_StartBug> if ( strchr ( topicName , '#' ) == NULL && strchr ( topicName , '+' ) == NULL ) <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> 
4035,<S2SV_StartBug> struct dentry * dentry = path -> dentry ; <S2SV_EndBug> <S2SV_StartBug> struct inode * inode = dentry -> d_inode ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vfs_select_inode ( path -> <S2SV_ModEnd> <S2SV_ModStart> file -> f_path = * path ; <S2SV_ModEnd> 
4036,<S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> * data ; data = kmalloc ( 2 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> goto out ; <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> goto out ; } ret = snprintf ( buf , PAGE_SIZE , ""%s\\n"" , macro_mode ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> "
4037,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error < 0 ) <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl <S2SV_ModStart> ) return error <S2SV_ModEnd> "
4038,<S2SV_StartBug> ASSERT ( retval == 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( retval ) return retval ; args -> flags &= ~ ATTR_REPLACE <S2SV_ModEnd> 
4039,"<S2SV_StartBug> status = SetImageExtent ( screen , screen -> columns , screen -> rows , exception ) ; <S2SV_EndBug> <S2SV_StartBug> if ( image == ( Image * ) NULL ) <S2SV_EndBug> ","<S2SV_ModStart> if ( image == ( Image * ) NULL ) image = screen ; else AppendImageToList ( & image , screen ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
4040,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> int i , table_size ; <S2SV_EndBug> <S2SV_StartBug> assert ( dev -> msix . table != NULL ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! <S2SV_ModEnd> <S2SV_ModStart> ) { pr_err ( ""%s:<S2SV_blank>Cannot<S2SV_blank>alloc<S2SV_blank>memory!\\n"" , __func__ ) ; return - 1 ; } <S2SV_ModEnd> <S2SV_ModStart> return 0 ; "
4041,"<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> err = crypto_ahash_export ( req , state ) ; <S2SV_EndBug> <S2SV_StartBug> ctx2 -> more = 1 ; <S2SV_EndBug> ",<S2SV_ModStart> bool more ; <S2SV_ModStart> lock_sock ( sk ) ; more = ctx -> more ; err = more ? <S2SV_ModEnd> <S2SV_ModStart> : 0 ; release_sock ( sk ) <S2SV_ModStart> more ; if ( ! more ) return err <S2SV_ModEnd> 
4042,<S2SV_StartBug> case DB_VECTOR : <S2SV_EndBug> ,"<S2SV_ModStart> AC_VECTOR : kvm_queue_exception_e ( vcpu , AC_VECTOR , error_code ) ; return 1 ; case "
4043,<S2SV_StartBug> if ( x & ( 1 << i ) ) return i ; <S2SV_EndBug> ,<S2SV_ModStart> 1U << ( unsigned int ) <S2SV_ModEnd> 
4044,<S2SV_StartBug> if ( q > e ) { <S2SV_EndBug> ,"<S2SV_ModStart> < p ) { DPRINTF ( ( ""Wrapped<S2SV_blank>around<S2SV_blank>%p<S2SV_blank><<S2SV_blank>%p\\n"" , q , p ) ) ; goto out ; } if ( q "
4045,<S2SV_StartBug> struct completion * vfork_done = tsk -> vfork_done ; <S2SV_EndBug> ,<S2SV_ModStart> # ifdef CONFIG_FUTEX if ( unlikely ( tsk -> robust_list ) ) exit_robust_list ( tsk ) ; # ifdef CONFIG_COMPAT if ( unlikely ( tsk -> compat_robust_list ) ) compat_exit_robust_list ( tsk ) ; # endif # endif 
4046,"<S2SV_StartBug> rrd_set_error ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>imginfo"" ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
4047,<S2SV_StartBug> void * zmalloc ( size_t size ) { <S2SV_EndBug> ,<S2SV_ModStart> ASSERT_NO_SIZE_OVERFLOW ( size ) ; 
4048,<S2SV_StartBug> ret = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> key_put ( keyring ) ; 
4049,<S2SV_StartBug> pWTIntFrame -> numSamples = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> android_errorWriteLog ( 0x534e4554 , ""26366256"" ) ; "
4050,<S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> switch ( EXTRACT_16BITS ( bp ) ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } return ; <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( bp ) ; 
4051,<S2SV_StartBug> int fourcc_is_ivf ( const char detect [ 4 ] ) { <S2SV_EndBug> ,<S2SV_ModStart> static 
4052,<S2SV_StartBug> OPJ_UNUSED ( p_manager ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4053,<S2SV_StartBug> int ret ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( current_chrooted ( ) ) return - EPERM 
4054,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> GTextFieldSaved ( gt ) ; 
4055,<S2SV_StartBug> continue ; <S2SV_EndBug> ,<S2SV_ModStart> buflen ++ ; 
4056,<S2SV_StartBug> while ( len -- ) <S2SV_EndBug> <S2SV_StartBug> while ( len -- ) <S2SV_EndBug> ,<S2SV_ModStart> > 0 <S2SV_ModStart> > 0 
4057,"<S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( tim . bitmap , p + offset + 3 , tim . length - 3 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4058,"<S2SV_StartBug> type = * ( tptr ) ; <S2SV_EndBug> <S2SV_StartBug> subtype = * ( tptr + 4 ) ; <S2SV_EndBug> <S2SV_StartBug> tok2str ( eap_type_values , ""unknown"" , * ( tptr + 4 ) ) , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" , <S2SV_EndBug> <S2SV_StartBug> case EAP_TYPE_TLS : <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , <S2SV_EndBug> ","<S2SV_ModStart> ND_TCHECK_8BITS ( tptr ) ; <S2SV_ModStart> ) ; ND_TCHECK_16BITS ( tptr + 2 <S2SV_ModStart> ND_TCHECK_8BITS ( tptr + 4 ) ; <S2SV_ModStart> subtype ) , subtype <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_8BITS ( tptr + count ) ; <S2SV_ModStart> case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ; if ( subtype == EAP_TYPE_TTLS ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> ND_TCHECK_8BITS ( tptr + 5 ) ; <S2SV_ModStart> ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> ND_TCHECK_8BITS ( tptr + 5 ) ; "
4059,"<S2SV_StartBug> int lsm_set_label_at ( int procfd , int on_exec , char * lsm_label ) { <S2SV_EndBug> <S2SV_StartBug> int labelfd = - 1 ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> if ( on_exec ) { <S2SV_EndBug> <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( write ( labelfd , command , size + 1 ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label"" ) ; <S2SV_EndBug> <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( labelfd != - 1 ) <S2SV_EndBug> <S2SV_StartBug> close ( labelfd ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> static <S2SV_ModStart> lsm_labelfd <S2SV_ModEnd> <S2SV_ModStart> { int fret <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return 0 <S2SV_ModEnd> <S2SV_ModStart> return 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lsm_labelfd <S2SV_ModEnd> <S2SV_ModStart> ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label:<S2SV_blank>%s."" , command ) ; goto out ; } INFO ( ""Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s."" , command ) ; } else if ( strcmp ( name , ""SELinux"" ) == 0 ) { if ( write ( lsm_labelfd , lsm_label , strlen ( lsm_label ) + 1 ) < 0 ) { SYSERROR ( <S2SV_ModStart> goto out ; } INFO ( ""Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s."" , lsm_label ) ; } else <S2SV_ModEnd> <S2SV_ModStart> goto out ; } fret = 0 ; <S2SV_ModEnd> <S2SV_ModStart> lsm_labelfd <S2SV_ModEnd> <S2SV_ModStart> lsm_labelfd <S2SV_ModEnd> <S2SV_ModStart> fret <S2SV_ModEnd> "
4060,"<S2SV_StartBug> void ntlm_write_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> ",<S2SV_ModStart> static 
4061,"<S2SV_StartBug> if ( kvm_apic_get_reg ( apic , APIC_TMICT ) == 0 ) <S2SV_EndBug> ",<S2SV_ModStart> == 0 || apic -> lapic_timer . period 
4062,"<S2SV_StartBug> __clear_bit ( * old_keycode , dev -> keybit ) ; <S2SV_EndBug> <S2SV_StartBug> __set_bit ( ke -> keycode , dev -> keybit ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < dev -> keycodemax ; i ++ ) { <S2SV_EndBug> ","<S2SV_ModStart> if ( * old_keycode <= KEY_MAX ) { <S2SV_ModStart> for ( i = 0 ; i < dev -> keycodemax ; i ++ ) { if ( input_fetch_keycode ( dev , i ) == * old_keycode ) { __set_bit ( * old_keycode <S2SV_ModEnd> <S2SV_ModStart> break ; } } } __set_bit ( ke -> keycode , dev -> keybit ) ; return 0 ; <S2SV_ModEnd> "
4063,"<S2SV_StartBug> l2tp_accm_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> <S2SV_StartBug> ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> ","<S2SV_ModStart> , u_int length <S2SV_ModStart> if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } ptr ++ ; length -= 2 ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> <S2SV_ModStart> if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } "
4064,<S2SV_StartBug> if ( handle && ! ext4_handle_valid ( handle ) ) <S2SV_EndBug> <S2SV_StartBug> if ( sbi -> s_journal && ! handle ) <S2SV_EndBug> ,<S2SV_ModStart> ! EXT4_SB ( inode -> i_sb ) -> s_journal <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4065,"<S2SV_StartBug> if ( ++ l2cap_pi ( sk ) -> conf_retry < L2CAP_CONF_MAX_RETRIES ) { <S2SV_EndBug> <S2SV_StartBug> l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_CONF_REQ , <S2SV_EndBug> <S2SV_StartBug> goto done ; <S2SV_EndBug> ","<S2SV_ModStart> l2cap_pi ( sk ) -> num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP ) { int len = cmd -> len - sizeof ( * rsp ) ; char req [ 64 ] ; result = L2CAP_CONF_SUCCESS ; len = l2cap_parse_conf_rsp ( sk , rsp -> data , len , req , & result ) ; if ( len < 0 ) { struct l2cap_disconn_req req ; req . dcid = cpu_to_le16 ( l2cap_pi ( sk ) -> dcid ) ; req . scid = cpu_to_le16 ( l2cap_pi ( sk ) -> scid ) <S2SV_ModEnd> <S2SV_ModStart> L2CAP_DISCONN_REQ , sizeof ( req ) , & <S2SV_ModEnd> <S2SV_ModStart> ; } l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_CONF_REQ , len , req ) ; l2cap_pi ( sk ) -> num_conf_req ++ ; if ( result != L2CAP_CONF_SUCCESS ) goto done ; break "
4066,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> usb_conv_info -> class_data_type = USB_CONV_AUDIO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_AUDIO ) { return 0 ; 
4067,"<S2SV_StartBug> Stream_Read_UINT32 ( s , message -> NegotiateFlags ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( Stream_GetRemainingLength ( s ) < 4 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } "
4068,<S2SV_StartBug> if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ICANON ) { <S2SV_EndBug> ,<S2SV_ModStart> ( ICANON | EXTPROC ) <S2SV_ModEnd> 
4069,"<S2SV_StartBug> f = fopen ( filepath , ""rb"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""r"" <S2SV_ModEnd> "
4070,"<S2SV_StartBug> len = b - a ; <S2SV_EndBug> <S2SV_StartBug> err_ret -> text = ""with<S2SV_blank>Barry<S2SV_blank>as<S2SV_blank>BDFL,<S2SV_blank>use<S2SV_blank>\'<>\'<S2SV_blank>"" <S2SV_EndBug> <S2SV_StartBug> if ( a >= tok -> line_start ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> col_offset = - 1 ; <S2SV_EndBug> ",<S2SV_ModStart> ( a != NULL && b != NULL ) ? <S2SV_ModStart> : 0 <S2SV_ModStart> expected = NOTEQUAL <S2SV_ModEnd> <S2SV_ModStart> != NULL && a <S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> } 
4071,<S2SV_StartBug> snapend_save = ndo -> ndo_snapend ; <S2SV_EndBug> ,<S2SV_ModStart> ; ND_TCHECK_16BITS ( & ip -> ip_len ) 
4072,"<S2SV_StartBug> pid_t pid ; <S2SV_EndBug> <S2SV_StartBug> memset ( c_path , 0 , sizeof ( c_path ) ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( c_path , ""%s%s%d_C_%lu"" , HSM_FM_SCK_PREFIX , mgr_prefix , <S2SV_EndBug> <S2SV_StartBug> hdl -> instance , ( long unsigned ) pid ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""%s%s%d_C_XXXXXX"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4073,"<S2SV_StartBug> const u_char * p , const u_char * ep , <S2SV_EndBug> <S2SV_StartBug> if ( p [ 0 ] & 0x80 ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> if ( ep < p + totlen ) { <S2SV_EndBug> <S2SV_StartBug> return ep + 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""value="" ) ) ; <S2SV_EndBug> <S2SV_StartBug> rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , EXTRACT_16BITS ( & p [ 2 ] ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , EXTRACT_16BITS ( & p [ 2 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> return p + totlen ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ep2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <S2SV_ModStart> } if ( ep2 <S2SV_ModEnd> <S2SV_ModStart> ep2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( & p [ 0 ] ) ; <S2SV_ModStart> ) ; ND_TCHECK_16BITS ( & p [ 2 ] <S2SV_ModStart> { if ( ! <S2SV_ModStart> ) { ND_PRINT ( ( ndo , "")"" ) ) ; goto trunc ; } } <S2SV_ModEnd> <S2SV_ModStart> totlen - 4 ) ) ; if ( ! <S2SV_ModEnd> <S2SV_ModStart> totlen - 4 ) ) { <S2SV_ModEnd> <S2SV_ModStart> goto trunc ; } } ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_ModStart> trunc : return NULL ; "
4074,"<S2SV_StartBug> if ( cid <= 0 ) <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) <S2SV_EndBug> <S2SV_StartBug> return dctx -> remaining ; <S2SV_EndBug> ",<S2SV_ModStart> int remaining ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> 
4075,"<S2SV_StartBug> if ( mount ( ""proc"" , path , ""proc"" , 0 , NULL ) ) <S2SV_EndBug> ","<S2SV_ModStart> safe_mount <S2SV_ModEnd> <S2SV_ModStart> , rootfs ) < 0 <S2SV_ModEnd> "
4076,<S2SV_StartBug> ( ( flags & O_ACCMODE ) == O_WRONLY || <S2SV_EndBug> <S2SV_StartBug> ( flags & O_ACCMODE ) == O_RDWR ) ) { <S2SV_EndBug> ,<S2SV_ModStart> != O_RDONLY <S2SV_ModEnd> <S2SV_ModStart> ( O_CREAT | O_TRUNC ) ) != 0 <S2SV_ModEnd> 
4077,<S2SV_StartBug> if ( cmd & 0x01 ) off = * delta ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x02 ) off |= * delta ++ << 8UL ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x04 ) off |= * delta ++ << 16UL ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x08 ) off |= ( ( unsigned ) * delta ++ << 24UL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x10 ) len = * delta ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x20 ) len |= * delta ++ << 8UL ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x40 ) len |= * delta ++ << 16UL ; <S2SV_EndBug> <S2SV_StartBug> if ( ! len ) len = 0x10000 ; <S2SV_EndBug> ,"<S2SV_ModStart> # define ADD_DELTA ( o , shift ) { if ( delta < delta_end ) ( o ) |= ( ( unsigned ) <S2SV_ModEnd> <S2SV_ModStart> shift ) ; else goto fail ; } if ( cmd & 0x01 ) ADD_DELTA ( off , 0UL ) ; if ( cmd & 0x02 ) ADD_DELTA ( off , 8UL ) <S2SV_ModEnd> <S2SV_ModStart> ADD_DELTA ( off , 16UL ) <S2SV_ModEnd> <S2SV_ModStart> ADD_DELTA ( off , <S2SV_ModEnd> <S2SV_ModStart> ADD_DELTA ( len , 0UL ) <S2SV_ModEnd> <S2SV_ModStart> ADD_DELTA ( len , 8UL ) <S2SV_ModEnd> <S2SV_ModStart> ADD_DELTA ( len , 16UL ) <S2SV_ModEnd> <S2SV_ModStart> # undef ADD_DELTA "
4078,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( length > 2 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( length > 4 ) { <S2SV_EndBug> <S2SV_StartBug> print_string ( ndo , ( const u_char * ) ptr , length - 4 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModStart> ; length -= 2 <S2SV_ModStart> == 0 ) return ; if ( length < <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""<S2SV_blank>AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModStart> length -= 2 ; <S2SV_ModEnd> <S2SV_ModStart> == 0 ) return ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4079,"<S2SV_StartBug> KEY_ALLOC_IN_QUOTA , <S2SV_EndBug> <S2SV_StartBug> KEY_ALLOC_IN_QUOTA , <S2SV_EndBug> ",<S2SV_ModStart> KEY_ALLOC_UID_KEYRING | <S2SV_ModStart> KEY_ALLOC_UID_KEYRING | 
4080,"<S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>G"" , grayscale ) ; <S2SV_EndBug> <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>g"" , grayscale ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sendClean ( outputbuffer ) ; 
4081,"<S2SV_StartBug> if ( par == STROKING ) { outpos += sprintf ( outpos , ""<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>K"" ) ; } <S2SV_EndBug> <S2SV_StartBug> else { outpos += sprintf ( outpos , ""<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>k"" ) ; } <S2SV_EndBug> ",<S2SV_ModStart> send ( <S2SV_ModEnd> <S2SV_ModStart> send ( <S2SV_ModEnd> 
4082,<S2SV_StartBug> if ( inet -> opt && inet -> opt -> srr ) <S2SV_EndBug> ,"<S2SV_ModStart> struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . <S2SV_ModEnd> "
4083,"<S2SV_StartBug> sprintf ( op -> buf_asm , ""packed-switch-payload<S2SV_blank>%d,<S2SV_blank>%d"" , array_size , first_key ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( op -> buf_asm , ""sparse-switch-payload<S2SV_blank>%d"" , array_size ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i"" , vA ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#04hx"" , vA , sB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%"" PFMT64x , vA , vA + 1 , lB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>[%04x]"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%"" PFMT64x ""]"" , vA , vB , offset ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>thing+%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>%s"" , vC , vC + vA - 1 , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>class+%i"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>%s"" , vC , vC + vA - 1 , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>method+%i"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x"" , flag_str , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>class+%i"" , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x"" , flag_str , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>method+%i"" , vB ) ; <S2SV_EndBug> ","<S2SV_ModStart> snprintf <S2SV_ModEnd> <S2SV_ModStart> sizeof ( op -> buf_asm ) , <S2SV_ModStart> snprintf <S2SV_ModEnd> <S2SV_ModStart> , sizeof ( op -> buf_asm ) <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> "
4084,<S2SV_StartBug> skb_dst_force ( skb ) ; <S2SV_EndBug> ,<S2SV_ModStart> skb_set_err_queue ( skb ) ; 
4085,"<S2SV_StartBug> vpx_memcpy ( x -> pred_mv , ctx -> pred_mv , sizeof ( x -> pred_mv ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> 
4086,"<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> rc = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc == 0 ) <S2SV_EndBug> ","<S2SV_ModStart> ; rc = posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( rc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4087,<S2SV_StartBug> u32 data ; <S2SV_EndBug> <S2SV_StartBug> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> kvm_read_guest_cached ( vcpu -> kvm , & <S2SV_ModEnd> <S2SV_ModStart> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> "
4088,<S2SV_StartBug> cpuctx -> ctx . type = cpu_context ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4089,"<S2SV_StartBug> args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> 1 <S2SV_ModEnd> "
4090,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> return - ENOMEM ; } return <S2SV_ModEnd> 
4091,"<S2SV_StartBug> sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( pixels_length , <S2SV_EndBug> ",<S2SV_ModStart> + image -> rows 
4092,"<S2SV_StartBug> status = dm9000ReadReg ( DM9000_REG_ISR ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_ISR , ISR_LNKCHG ) ; <S2SV_EndBug> <S2SV_StartBug> status = dm9000ReadReg ( DM9000_REG_NSR ) ; <S2SV_EndBug> <S2SV_StartBug> status = dm9000ReadReg ( DM9000_REG_NCR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & ISR_PR ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_ISR , ISR_PR ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_IMR , IMR_PAR | IMR_LNKCHGI | IMR_PTI | IMR_PRI ) ; <S2SV_EndBug> ","<S2SV_ModStart> DM9000_ISR ) ; if ( ( status & DM9000_ISR_LNKCHG <S2SV_ModEnd> <S2SV_ModStart> DM9000_ISR , DM9000_ISR_LNKCHG <S2SV_ModEnd> <S2SV_ModStart> DM9000_NSR ) ; if ( ( status & DM9000_NSR_LINKST ) != 0 ) { if ( ( status & DM9000_NSR_SPEED <S2SV_ModEnd> <S2SV_ModStart> DM9000_NCR ) ; if ( ( status & DM9000_NCR_FDX <S2SV_ModEnd> <S2SV_ModStart> DM9000_ISR_PR <S2SV_ModEnd> <S2SV_ModStart> DM9000_ISR , DM9000_ISR_PR <S2SV_ModEnd> <S2SV_ModStart> DM9000_IMR , DM9000_IMR_PAR | DM9000_IMR_LNKCHGI | DM9000_IMR_PTI | DM9000_IMR_PRI <S2SV_ModEnd> "
4093,"<S2SV_StartBug> int index , count , i ; <S2SV_EndBug> <S2SV_StartBug> int index , count , i ; <S2SV_EndBug> ",<S2SV_ModStart> unsigned <S2SV_ModStart> unsigned 
4094,"<S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ; <S2SV_EndBug> <S2SV_StartBug> id = ip_idents_reserve ( hash , 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> static u32 ip6_idents_hashrnd_extra __read_mostly ; <S2SV_ModStart> ) ) ; net_get_random_once ( & ip6_idents_hashrnd_extra , sizeof ( ip6_idents_hashrnd_extra <S2SV_ModStart> hash = jhash_1word ( hash , ip6_idents_hashrnd_extra ) ; "
4095,<S2SV_StartBug> if ( p -> question -> n_keys != 1 ) <S2SV_EndBug> ,<S2SV_ModStart> ! p -> question ) return 0 ; if ( 
4096,<S2SV_StartBug> ASSERT ( retval == 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( retval ) return retval ; args -> flags &= ~ ATTR_REPLACE <S2SV_ModEnd> 
4097,"<S2SV_StartBug> static void encode_b_rt ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int output_enabled , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> update_state_rt ( cpi , get_block_context ( x , bsize ) , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> encode_superblock ( cpi , tp , output_enabled , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> update_stats ( cpi ) ; <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , <S2SV_ModStart> , PICK_MODE_CONTEXT * ctx <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , x <S2SV_ModStart> td , ctx <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 && output_enabled && cpi -> common . frame_type != KEY_FRAME ) { vp9_denoiser_denoise ( & cpi -> denoiser , x , mi_row , mi_col , MAX ( BLOCK_8X8 , bsize ) , ctx ) ; } # endif <S2SV_ModStart> , td <S2SV_ModStart> , ctx <S2SV_ModStart> & cpi -> common , td <S2SV_ModEnd> "
4098,"<S2SV_StartBug> u32 i , j , page_count = 0 , sg_per_table ; <S2SV_EndBug> <S2SV_StartBug> sg_table = rd_dev -> sg_table_array ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < rd_dev -> sg_table_count ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> kfree ( sg_table ) ; <S2SV_EndBug> ","<S2SV_ModStart> page_count <S2SV_ModEnd> <S2SV_ModStart> page_count = rd_release_sgl_table ( rd_dev , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4099,"<S2SV_StartBug> if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> arg = ( arg != NULL ) ? arg : """" ; "
4100,<S2SV_StartBug> auth . skb = chunk -> auth_chunk ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! net -> sctp . auth_enable || ! new_asoc -> peer . auth_capable ) { kfree_skb ( chunk -> auth_chunk ) ; sctp_association_free ( new_asoc ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } "
4101,"<S2SV_StartBug> static int64_t rd_pick_intra4x4block ( VP9_COMP * cpi , MACROBLOCK * x , int ib , <S2SV_EndBug> <S2SV_StartBug> MB_PREDICTION_MODE mode ; <S2SV_EndBug> <S2SV_StartBug> const uint8_t * src_init = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , ib , <S2SV_EndBug> <S2SV_StartBug> uint8_t * dst_init = & pd -> dst . buf [ raster_block_offset ( BLOCK_8X8 , ib , <S2SV_EndBug> <S2SV_StartBug> assert ( ib < 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( tl , l , sizeof ( tl ) ) ; <S2SV_EndBug> <S2SV_StartBug> xd -> mi [ 0 ] -> mbmi . tx_size = TX_4X4 ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( tempa , ta , sizeof ( ta ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( templ , tl , sizeof ( tl ) ) ; <S2SV_EndBug> <S2SV_StartBug> const int block = ib + idy * 2 + idx ; <S2SV_EndBug> <S2SV_StartBug> int16_t * const src_diff = raster_block_offset_int16 ( BLOCK_8X8 , block , <S2SV_EndBug> <S2SV_StartBug> int16_t * const coeff = BLOCK_OFFSET ( x -> plane [ 0 ] . coeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_predict_intra_block ( xd , block , 1 , <S2SV_EndBug> <S2SV_StartBug> dst , dst_stride , idx , idy , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_subtract_block ( 4 , 4 , src_diff , 8 , src , src_stride , dst , dst_stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_fwht4x4 ( src_diff , coeff , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> goto next ; <S2SV_EndBug> <S2SV_StartBug> p -> eobs [ block ] ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_fht4x4 ( src_diff , coeff , 8 , tx_type ) ; <S2SV_EndBug> <S2SV_StartBug> distortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , block ) , <S2SV_EndBug> <S2SV_StartBug> 16 , & unused ) >> 2 ; <S2SV_EndBug> <S2SV_StartBug> goto next ; <S2SV_EndBug> <S2SV_StartBug> dst , dst_stride , p -> eobs [ block ] ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( a , tempa , sizeof ( tempa ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( l , templ , sizeof ( templ ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( best_dst + idy * 8 , dst_init + idy * dst_stride , <S2SV_EndBug> <S2SV_StartBug> num_4x4_blocks_wide * 4 ) ; <S2SV_EndBug> <S2SV_StartBug> next : <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst_init + idy * dst_stride , best_dst + idy * 8 , <S2SV_EndBug> <S2SV_StartBug> num_4x4_blocks_wide * 4 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> row , int col , PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> row * 4 * src_stride + col * 4 <S2SV_ModEnd> <S2SV_ModStart> row * 4 * src_stride + col * 4 <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH uint16_t best_dst16 [ 8 * 8 ] ; # endif memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> ( row + idy ) <S2SV_ModEnd> <S2SV_ModStart> ( col + idx ) <S2SV_ModEnd> <S2SV_ModStart> vp9_raster_block_offset_int16 <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> col + idx , row + idy , 0 ) ; vpx_highbd_subtract_block <S2SV_ModEnd> <S2SV_ModStart> , xd -> bd <S2SV_ModStart> vp9_highbd_fwht4x4 <S2SV_ModEnd> <S2SV_ModStart> next_highbd ; vp9_highbd_iwht4x4_add <S2SV_ModEnd> <S2SV_ModStart> , xd -> bd <S2SV_ModStart> if ( tx_type == DCT_DCT ) vpx_highbd_fdct4x4 ( src_diff , coeff , 8 ) ; else vp9_highbd_fht4x4 <S2SV_ModEnd> <S2SV_ModStart> vp9_highbd_block_error ( <S2SV_ModEnd> <S2SV_ModStart> , xd -> bd <S2SV_ModStart> next_highbd ; vp9_highbd_iht4x4_add <S2SV_ModEnd> <S2SV_ModStart> , xd -> bd <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> { memcpy ( best_dst16 <S2SV_ModEnd> <S2SV_ModStart> CONVERT_TO_SHORTPTR ( <S2SV_ModStart> ) <S2SV_ModStart> * sizeof ( uint16_t ) <S2SV_ModStart> } next_highbd <S2SV_ModEnd> <S2SV_ModStart> { memcpy ( CONVERT_TO_SHORTPTR <S2SV_ModEnd> <S2SV_ModStart> ) , best_dst16 <S2SV_ModEnd> <S2SV_ModStart> * sizeof ( uint16_t ) ) ; } <S2SV_ModEnd> <S2SV_ModStart> # endif for ( mode = DC_PRED ; mode <= TM_PRED ; ++ mode ) { int64_t this_rd ; int ratey = 0 ; int64_t distortion = 0 ; int rate = bmode_costs [ mode ] ; if ( ! ( cpi -> sf . intra_y_mode_mask [ TX_4X4 ] & ( 1 << mode ) ) ) continue ; if ( cpi -> sf . mode_search_skip_flags & FLAG_SKIP_INTRA_DIRMISMATCH ) { if ( conditional_skipintra ( mode , * best_mode ) ) continue ; } memcpy ( tempa , ta , sizeof ( ta ) ) ; memcpy ( templ , tl , sizeof ( tl ) ) ; for ( idy = 0 ; idy < num_4x4_blocks_high ; ++ idy ) { for ( idx = 0 ; idx < num_4x4_blocks_wide ; ++ idx ) { const int block = ( row + idy ) * 2 + ( col + idx ) ; const uint8_t * const src = & src_init [ idx * 4 + idy * 4 * src_stride ] ; uint8_t * const dst = & dst_init [ idx * 4 + idy * 4 * dst_stride ] ; int16_t * const src_diff = vp9_raster_block_offset_int16 ( BLOCK_8X8 , block , p -> src_diff ) ; tran_low_t * const coeff = BLOCK_OFFSET ( x -> plane [ 0 ] . coeff , block ) ; xd -> mi [ 0 ] -> bmi [ block ] . as_mode = mode ; vp9_predict_intra_block ( xd , 1 , TX_4X4 , mode , x -> skip_encode ? src : dst , x -> skip_encode ? src_stride : dst_stride , dst , dst_stride , col + idx , row + idy , 0 ) ; vpx_subtract_block ( 4 , 4 , src_diff , 8 , src , src_stride , dst , dst_stride ) ; if ( xd -> lossless ) { const scan_order * so = & vp9_default_scan_orders [ TX_4X4 ] ; vp9_fwht4x4 ( src_diff , coeff , 8 ) ; vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ; ratey += cost_coeffs ( x , 0 , block , tempa + idx , templ + idy , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ; if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) goto next ; vp9_iwht4x4_add ( BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride , p -> eobs [ block ] ) ; } else { int64_t unused ; const TX_TYPE tx_type = get_tx_type_4x4 ( PLANE_TYPE_Y , xd , block ) ; const scan_order * so = & vp9_scan_orders [ TX_4X4 ] [ tx_type ] ; vp9_fht4x4 ( src_diff , coeff , 8 , tx_type ) ; vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ; ratey += cost_coeffs ( x , 0 , block , tempa + idx , templ + idy , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ; distortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , block ) , 16 , & unused ) >> 2 ; if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) goto next ; vp9_iht4x4_add ( tx_type , BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride , p -> eobs [ block ] ) ; } } } rate += ratey ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ; if ( this_rd < best_rd ) { * bestrate = rate ; * bestratey = ratey ; * bestdistortion = distortion ; best_rd = this_rd ; * best_mode = mode ; memcpy ( a , tempa , sizeof ( tempa ) ) ; memcpy ( l , templ , sizeof ( templ ) ) ; for ( idy = 0 ; idy < num_4x4_blocks_high * 4 ; ++ idy ) memcpy ( best_dst + idy * 8 , dst_init + idy * dst_stride , num_4x4_blocks_wide * 4 ) ; } next : { } } if ( best_rd >= rd_thresh || x -> skip_encode ) return best_rd ; for ( idy = 0 ; idy < num_4x4_blocks_high * 4 ; ++ idy ) memcpy ( dst_init + idy * dst_stride , best_dst + idy * 8 , num_4x4_blocks_wide * 4 ) ; return best_rd ; } "
4102,"<S2SV_StartBug> static void read_quant_matrix_ext ( MpegEncContext * s , GetBitContext * gb ) <S2SV_EndBug> <S2SV_StartBug> if ( get_bits1 ( gb ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 64 ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> if ( get_bits1 ( gb ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 64 ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> return 0 ; 
4103,<S2SV_StartBug> vp9_free_frame_buffers ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_free_internal_frame_buffers ( & cm -> int_frame_buffers ) ; <S2SV_EndBug> ,<S2SV_ModStart> vp9_free_context_buffers <S2SV_ModEnd> <S2SV_ModStart> vpx_free ( cm -> fc ) ; cm -> fc = NULL ; vpx_free ( cm -> frame_contexts ) ; cm -> frame_contexts = NULL <S2SV_ModEnd> 
4104,<S2SV_StartBug> if ( po -> fanout ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> lock_sock ( sk ) ; spin_lock ( & po -> bind_lock ) ; rcu_read_lock ( ) ; <S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto out_unlock ; } <S2SV_ModEnd> 
4105,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , icmp6_tstr <S2SV_ModEnd> "
4106,"<S2SV_StartBug> int read_frame ( struct VpxInputContext * input_ctx , vpx_image_t * img ) { <S2SV_EndBug> ",<S2SV_ModStart> static 
4107,<S2SV_StartBug> BUG_ON ( ! io ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; if ( io -> page ) put_page ( io -> page 
4108,"<S2SV_StartBug> void * shared_kaddr ; <S2SV_EndBug> <S2SV_StartBug> struct pvclock_vcpu_time_info * guest_hv_clock ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vcpu -> time_page ) <S2SV_EndBug> <S2SV_StartBug> shared_kaddr = kmap_atomic ( vcpu -> time_page ) ; <S2SV_EndBug> <S2SV_StartBug> pvclock_flags = ( guest_hv_clock -> flags & PVCLOCK_GUEST_STOPPED ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( shared_kaddr + vcpu -> time_offset , & vcpu -> hv_clock , <S2SV_EndBug> <S2SV_StartBug> kunmap_atomic ( shared_kaddr ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pv_time_enabled <S2SV_ModEnd> <S2SV_ModStart> if ( unlikely ( kvm_read_guest_cached ( v -> kvm , & vcpu -> pv_time , & guest_hv_clock , sizeof ( guest_hv_clock ) ) ) ) return 0 <S2SV_ModEnd> <S2SV_ModStart> . <S2SV_ModEnd> <S2SV_ModStart> kvm_write_guest_cached ( v -> kvm , & vcpu -> pv_time , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4109,"<S2SV_StartBug> # line 105 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1340 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 114 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1348 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 118 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; <S2SV_EndBug> <S2SV_StartBug> # line 1363 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 129 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> node = yr_re_node_create ( RE_NODE_EMPTY , NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> # line 1382 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 147 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1390 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 151 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1402 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 162 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1420 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 176 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1440 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 192 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1458 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 206 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1478 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 222 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1505 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 245 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1533 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 269 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1559 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 291 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1586 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 314 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1594 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 318 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1604 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 324 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1614 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 330 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1624 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 336 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1634 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 345 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1642 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 349 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1652 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 355 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1664 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 363 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1674 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 369 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1684 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 375 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1694 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 381 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1704 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 387 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1714 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 393 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1724 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 399 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1736 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1740 ""re_grammar.c"" <S2SV_EndBug> ","<S2SV_ModStart> 113 <S2SV_ModEnd> <S2SV_ModStart> 1348 <S2SV_ModEnd> <S2SV_ModStart> 122 <S2SV_ModEnd> <S2SV_ModStart> 1356 <S2SV_ModEnd> <S2SV_ModStart> 126 <S2SV_ModEnd> <S2SV_ModStart> incr_ast_levels ( ) ; <S2SV_ModStart> 1372 <S2SV_ModEnd> <S2SV_ModStart> 138 <S2SV_ModEnd> <S2SV_ModStart> incr_ast_levels ( ) ; <S2SV_ModStart> 1392 <S2SV_ModEnd> <S2SV_ModStart> 157 <S2SV_ModEnd> <S2SV_ModStart> 1400 <S2SV_ModEnd> <S2SV_ModStart> 161 ""re_grammar.y"" { incr_ast_levels ( ) ; <S2SV_ModEnd> <S2SV_ModStart> 1414 <S2SV_ModEnd> <S2SV_ModStart> 174 <S2SV_ModEnd> <S2SV_ModStart> 1432 <S2SV_ModEnd> <S2SV_ModStart> 188 <S2SV_ModEnd> <S2SV_ModStart> 1452 <S2SV_ModEnd> <S2SV_ModStart> 204 <S2SV_ModEnd> <S2SV_ModStart> 1470 <S2SV_ModEnd> <S2SV_ModStart> 218 <S2SV_ModEnd> <S2SV_ModStart> 1490 <S2SV_ModEnd> <S2SV_ModStart> 234 <S2SV_ModEnd> <S2SV_ModStart> 1517 <S2SV_ModEnd> <S2SV_ModStart> 257 <S2SV_ModEnd> <S2SV_ModStart> 1545 <S2SV_ModEnd> <S2SV_ModStart> 281 <S2SV_ModEnd> <S2SV_ModStart> 1571 <S2SV_ModEnd> <S2SV_ModStart> 303 <S2SV_ModEnd> <S2SV_ModStart> 1598 <S2SV_ModEnd> <S2SV_ModStart> 326 <S2SV_ModEnd> <S2SV_ModStart> 1606 <S2SV_ModEnd> <S2SV_ModStart> 330 <S2SV_ModEnd> <S2SV_ModStart> 1616 <S2SV_ModEnd> <S2SV_ModStart> 336 <S2SV_ModEnd> <S2SV_ModStart> 1626 <S2SV_ModEnd> <S2SV_ModStart> 342 <S2SV_ModEnd> <S2SV_ModStart> 1636 <S2SV_ModEnd> <S2SV_ModStart> 348 <S2SV_ModEnd> <S2SV_ModStart> 1646 <S2SV_ModEnd> <S2SV_ModStart> 357 ""re_grammar.y"" { incr_ast_levels ( ) ; <S2SV_ModEnd> <S2SV_ModStart> 1656 <S2SV_ModEnd> <S2SV_ModStart> 363 <S2SV_ModEnd> <S2SV_ModStart> 1666 <S2SV_ModEnd> <S2SV_ModStart> 369 <S2SV_ModEnd> <S2SV_ModStart> 1678 <S2SV_ModEnd> <S2SV_ModStart> 377 <S2SV_ModEnd> <S2SV_ModStart> 1688 <S2SV_ModEnd> <S2SV_ModStart> 383 <S2SV_ModEnd> <S2SV_ModStart> 1698 <S2SV_ModEnd> <S2SV_ModStart> 389 <S2SV_ModEnd> <S2SV_ModStart> 1708 <S2SV_ModEnd> <S2SV_ModStart> 395 <S2SV_ModEnd> <S2SV_ModStart> 1718 <S2SV_ModEnd> <S2SV_ModStart> 401 <S2SV_ModEnd> <S2SV_ModStart> 1728 <S2SV_ModEnd> <S2SV_ModStart> 407 <S2SV_ModEnd> <S2SV_ModStart> 1738 <S2SV_ModEnd> <S2SV_ModStart> 413 <S2SV_ModEnd> <S2SV_ModStart> 1750 <S2SV_ModEnd> <S2SV_ModStart> 1754 <S2SV_ModEnd> "
4110,<S2SV_StartBug> u32 now ; <S2SV_EndBug> <S2SV_StartBug> challenge_timestamp = now ; <S2SV_EndBug> <S2SV_StartBug> challenge_count = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> count , <S2SV_ModStart> u32 half = ( sysctl_tcp_challenge_ack_limit + 1 ) >> 1 ; <S2SV_ModStart> WRITE_ONCE ( challenge_count , half + prandom_u32_max ( sysctl_tcp_challenge_ack_limit ) ) ; } count = READ_ONCE ( challenge_count ) ; if ( count > 0 ) { WRITE_ONCE ( challenge_count , count - 1 ) ; <S2SV_ModEnd> "
4111,"<S2SV_StartBug> err = tfm -> seed ( tfm , seed , slen ) ; <S2SV_EndBug> ",<S2SV_ModStart> crypto_rng_alg ( tfm ) <S2SV_ModEnd> 
4112,<S2SV_StartBug> update_db_bp_intercept ( & svm -> vcpu ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4113,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( pool ) ; 
4114,<S2SV_StartBug> int tstype ) <S2SV_EndBug> <S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> serr -> ee . ee_info = tstype ; <S2SV_EndBug> ,"<S2SV_ModStart> , bool opt_stats <S2SV_ModStart> ; BUILD_BUG_ON ( sizeof ( struct sock_exterr_skb ) > sizeof ( skb -> cb ) ) <S2SV_ModStart> ; serr -> opt_stats = opt_stats "
4115,<S2SV_StartBug> switch ( c = ( * dis_getc ) ( stream ) ) <S2SV_EndBug> ,"<S2SV_ModStart> if ( count >= dis_umaxd ) { if ( count > dis_umaxd ) goto overflow ; if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) goto overflow ; } "
4116,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> dc -> vmsd = & vmstate_stellaris_enet ; 
4117,"<S2SV_StartBug> void vp9_first_pass ( VP9_COMP * cpi ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> const PICK_MODE_CONTEXT * ctx = & x -> sb64_context ; <S2SV_EndBug> <S2SV_StartBug> YV12_BUFFER_CONFIG * const lst_yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; <S2SV_EndBug> <S2SV_StartBug> int intrapenalty = 256 ; <S2SV_EndBug> <S2SV_StartBug> uint32_t lastmv_as_int = 0 ; <S2SV_EndBug> <S2SV_StartBug> const YV12_BUFFER_CONFIG * first_ref_buf = lst_yv12 ; <S2SV_EndBug> <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( scaled_ref_buf != NULL ) { <S2SV_EndBug> <S2SV_StartBug> first_ref_buf = scaled_ref_buf ; <S2SV_EndBug> <S2SV_StartBug> for ( mb_row = 0 ; mb_row < cm -> mb_rows ; ++ mb_row ) { <S2SV_EndBug> <S2SV_StartBug> int_mv best_ref_mv ; <S2SV_EndBug> <S2SV_StartBug> double error_weight = 1.0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) { <S2SV_EndBug> <S2SV_StartBug> intra_error += ( int64_t ) this_error ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> current_video_frame > 0 ) { <S2SV_EndBug> <S2SV_StartBug> int tmp_err , motion_error ; <S2SV_EndBug> <S2SV_StartBug> motion_error = zz_motion_search ( x ) ; <S2SV_EndBug> <S2SV_StartBug> mv . as_int = tmp_mv . as_int ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> current_video_frame > 1 && gld_yv12 != NULL ) { <S2SV_EndBug> <S2SV_StartBug> gf_motion_error = zz_motion_search ( x ) ; <S2SV_EndBug> <S2SV_StartBug> first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv . as_mv , <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) { <S2SV_EndBug> <S2SV_StartBug> best_ref_mv . as_int = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( this_error - intrapenalty ) * 9 <= motion_error * 10 ) && <S2SV_EndBug> <S2SV_StartBug> this_error < 2 * intrapenalty ) <S2SV_EndBug> <S2SV_StartBug> ++ neutral_count ; <S2SV_EndBug> <S2SV_StartBug> mv . as_mv . col *= 8 ; <S2SV_EndBug> <S2SV_StartBug> xd -> mi [ 0 ] -> mbmi . mv [ 0 ] = mv ; <S2SV_EndBug> <S2SV_StartBug> sum_mvr += mv . as_mv . row ; <S2SV_EndBug> <S2SV_StartBug> sum_mvr_abs += abs ( mv . as_mv . row ) ; <S2SV_EndBug> <S2SV_StartBug> sum_mvc += mv . as_mv . col ; <S2SV_EndBug> <S2SV_StartBug> sum_mvc_abs += abs ( mv . as_mv . col ) ; <S2SV_EndBug> <S2SV_StartBug> sum_mvrs += mv . as_mv . row * mv . as_mv . row ; <S2SV_EndBug> <S2SV_StartBug> sum_mvcs += mv . as_mv . col * mv . as_mv . col ; <S2SV_EndBug> <S2SV_StartBug> best_ref_mv . as_int = mv . as_int ; <S2SV_EndBug> <S2SV_StartBug> if ( mv . as_int != lastmv_as_int ) <S2SV_EndBug> <S2SV_StartBug> lastmv_as_int = mv . as_int ; <S2SV_EndBug> <S2SV_StartBug> if ( mv . as_mv . row > 0 ) <S2SV_EndBug> <S2SV_StartBug> else if ( mv . as_mv . row < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( mv . as_mv . row > 0 ) <S2SV_EndBug> <S2SV_StartBug> else if ( mv . as_mv . row < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( mv . as_mv . col > 0 ) <S2SV_EndBug> <S2SV_StartBug> else if ( mv . as_mv . col < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( mv . as_mv . col > 0 ) <S2SV_EndBug> <S2SV_StartBug> else if ( mv . as_mv . col < 0 ) <S2SV_EndBug> <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> <S2SV_StartBug> fps . frame = cm -> current_video_frame ; <S2SV_EndBug> <S2SV_StartBug> fps . spatial_layer_id = cpi -> svc . spatial_layer_id ; <S2SV_EndBug> <S2SV_StartBug> fps . intra_error = ( double ) ( intra_error >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> fps . pcnt_inter = ( double ) intercount / cm -> MBs ; <S2SV_EndBug> <S2SV_StartBug> fps . pcnt_second_ref = ( double ) second_ref_count / cm -> MBs ; <S2SV_EndBug> <S2SV_StartBug> fps . pcnt_neutral = ( double ) neutral_count / cm -> MBs ; <S2SV_EndBug> <S2SV_StartBug> fps . MVrv = ( ( double ) sum_mvrs - ( fps . MVr * fps . MVr / mvcount ) ) / mvcount ; <S2SV_EndBug> <S2SV_StartBug> fps . MVcv = ( ( double ) sum_mvcs - ( fps . MVc * fps . MVc / mvcount ) ) / mvcount ; <S2SV_EndBug> <S2SV_StartBug> fps . pcnt_motion = ( double ) mvcount / cm -> MBs ; <S2SV_EndBug> <S2SV_StartBug> fps . duration = ( double ) ( cpi -> source -> ts_end - cpi -> source -> ts_start ) ; <S2SV_EndBug> <S2SV_StartBug> accumulate_stats ( & twopass -> total_stats , & fps ) ; <S2SV_EndBug> <S2SV_StartBug> vp8_yv12_copy_frame ( lst_yv12 , gld_yv12 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) { <S2SV_EndBug> <S2SV_StartBug> swap_yv12 ( lst_yv12 , new_yv12 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> current_video_frame == 0 && gld_yv12 != NULL ) { <S2SV_EndBug> <S2SV_StartBug> vp8_yv12_copy_frame ( lst_yv12 , gld_yv12 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , const struct lookahead_entry * source <S2SV_ModStart> td . <S2SV_ModStart> cpi -> td . pc_root -> none <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> INTRA_MODE_PENALTY ; double neutral_count ; int intra_skip_count = 0 ; int image_data_start_row = INVALID_ROW <S2SV_ModEnd> <S2SV_ModStart> MV lastmv = { 0 , 0 } ; TWO_PASS <S2SV_ModEnd> <S2SV_ModStart> int recon_y_stride , recon_uv_stride , uv_mb_height ; YV12_BUFFER_CONFIG * const lst_yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; YV12_BUFFER_CONFIG * gld_yv12 = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; YV12_BUFFER_CONFIG * const new_yv12 = get_frame_new_buffer ( cm ) ; <S2SV_ModStart> LAYER_CONTEXT * const lc = is_two_pass_svc ( cpi ) ? & <S2SV_ModEnd> <S2SV_ModStart> layer_context [ cpi -> svc . spatial_layer_id ] : NULL ; double intra_factor ; double brightness_factor ; BufferPool * const pool = cm -> buffer_pool ; assert ( new_yv12 <S2SV_ModEnd> <S2SV_ModStart> ; assert ( ( lc != NULL ) || frame_is_intra_only ( cm ) || ( lst_yv12 != NULL ) ) ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { vp9_zero_array ( cpi -> twopass . frame_mb_stats_buf , cm -> initial_mbs ) ; } # endif vpx_clear_system_state ( ) ; intra_factor = 0.0 ; brightness_factor = 0.0 ; neutral_count = 0.0 ; set_first_pass_params ( cpi ) ; vp9_set_quantizer ( cm , find_fp_qindex ( cm -> bit_depth ) ) ; if ( lc != NULL ) { twopass = & lc -> twopass ; cpi -> lst_fb_idx = cpi -> svc . spatial_layer_id ; cpi -> ref_frame_flags = VP9_LAST_FLAG ; if ( cpi -> svc . number_spatial_layers + cpi -> svc . spatial_layer_id < REF_FRAMES ) { cpi -> gld_fb_idx = cpi -> svc . number_spatial_layers + cpi -> svc . spatial_layer_id ; cpi -> ref_frame_flags |= VP9_GOLD_FLAG ; cpi -> refresh_golden_frame = ( lc -> current_video_frame_in_layer == 0 ) ; } else { cpi -> refresh_golden_frame = 0 ; } if ( lc -> current_video_frame_in_layer == 0 ) cpi -> ref_frame_flags = 0 ; vp9_scale_references ( cpi ) ; if ( cpi -> ref_frame_flags & VP9_LAST_FLAG ) <S2SV_ModStart> vp9_get_scaled_ref_frame ( cpi , LAST_FRAME ) ; if ( first_ref_buf == NULL ) first_ref_buf = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; } if ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) { gld_yv12 = vp9_get_scaled_ref_frame ( cpi , GOLDEN_FRAME ) ; if ( gld_yv12 == NULL ) { gld_yv12 = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; } } else { gld_yv12 = NULL ; } set_ref_ptrs ( cm , xd , ( cpi -> ref_frame_flags & VP9_LAST_FLAG ) ? LAST_FRAME : NONE , ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) ? GOLDEN_FRAME : NONE ) ; cpi -> Source = vp9_scale_if_required ( cm , cpi -> un_scaled_source , & cpi -> scaled_source ) ; } vp9_setup_block_planes ( & x -> e_mbd , cm -> subsampling_x , cm -> subsampling_y ) ; vp9_setup_src_planes ( x , cpi -> Source , 0 , 0 ) ; vp9_setup_dst_planes ( xd -> plane , new_yv12 , 0 , 0 ) ; if ( ! frame_is_intra_only ( cm ) ) { vp9_setup_pre_planes ( xd , 0 , first_ref_buf , 0 , 0 , NULL ) ; } xd -> mi = cm -> mi_grid_visible ; xd -> mi [ 0 ] = cm -> mi <S2SV_ModEnd> <S2SV_ModStart> recon_y_stride = new_yv12 -> y_stride ; recon_uv_stride = new_yv12 -> uv_stride ; uv_mb_height = 16 >> ( new_yv12 -> y_height > new_yv12 -> uv_height ) ; <S2SV_ModStart> MV best_ref_mv = { 0 , 0 } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> double log_intra ; int level_sample ; # if CONFIG_FP_MB_STATS const int mb_index = mb_row * cm -> mb_cols + mb_col ; # endif vpx_clear_system_state <S2SV_ModEnd> <S2SV_ModStart> x -> skip_encode = 0 ; xd -> mi [ 0 ] -> mbmi . mode = DC_PRED ; xd -> mi [ 0 ] -> mbmi . tx_size = use_dc_pred ? ( bsize >= BLOCK_16X16 ? TX_16X16 : TX_8X8 ) : TX_4X4 ; vp9_encode_intra_block_plane ( x , bsize , 0 ) ; this_error = vpx_get_mb_ss ( x -> plane [ 0 ] . src_diff ) ; if ( this_error < UL_INTRA_THRESH ) { ++ intra_skip_count ; } else if ( ( mb_col > 0 ) && ( image_data_start_row == INVALID_ROW ) ) { image_data_start_row = mb_row ; } # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) { switch ( cm -> bit_depth ) { case VPX_BITS_8 : break ; case VPX_BITS_10 : this_error >>= 4 ; break ; case VPX_BITS_12 : this_error >>= 8 ; break ; default : assert ( 0 && ""cm->bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>"" ""VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12"" ) ; return ; } } # endif vpx_clear_system_state ( ) ; log_intra = log ( this_error + 1.0 ) ; if ( log_intra < 10.0 ) intra_factor += 1.0 + ( ( 10.0 - log_intra ) * 0.05 ) ; else intra_factor += 1.0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) level_sample = CONVERT_TO_SHORTPTR ( x -> plane [ 0 ] . src . buf ) [ 0 ] ; else level_sample = x -> plane [ 0 ] . src . buf [ 0 ] ; # else level_sample = x -> plane [ 0 ] . src . buf [ 0 ] ; # endif if ( ( level_sample < DARK_THRESH ) && ( log_intra < 9.0 ) ) brightness_factor += 1.0 + ( 0.01 * ( DARK_THRESH - level_sample ) ) ; else brightness_factor += 1.0 ; <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ; } # endif <S2SV_ModStart> ( lc == NULL && <S2SV_ModStart> || ( lc != NULL && lc -> current_video_frame_in_layer > 0 ) ) <S2SV_ModStart> , raw_motion_error ; MV mv = { 0 , 0 } , tmp_mv = { 0 , 0 } ; struct buf_2d unscaled_last_source_buf_2d <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] , xd -> bd ) ; } else { motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; } # else motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; # endif unscaled_last_source_buf_2d . buf = cpi -> unscaled_last_source -> y_buffer + recon_yoffset ; unscaled_last_source_buf_2d . stride = cpi -> unscaled_last_source -> y_stride ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { raw_motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d , xd -> bd ) ; } else { raw_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d ) ; } # else raw_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d ) ; # endif if ( raw_motion_error > 25 || lc != NULL ) { first_pass_motion_search ( cpi , x , & best_ref_mv , & mv , & motion_error ) ; if ( ! is_zero_mv ( & best_ref_mv ) ) { tmp_err = INT_MAX ; first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv , & tmp_err ) ; <S2SV_ModEnd> <S2SV_ModStart> = tmp_mv ; } } if ( ( ( lc == NULL && <S2SV_ModEnd> <S2SV_ModStart> ) || ( lc != NULL && lc -> current_video_frame_in_layer > 1 ) ) <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { gf_motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] , xd -> bd ) ; } else { gf_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; } # else gf_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; # endif <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } else { sr_coded_error += motion_error ; } best_ref_mv . row = 0 ; best_ref_mv . col = 0 ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ; cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_DCINTRA_MASK ; cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_ZERO_MASK ; if ( this_error > FPMB_ERROR_LARGE_TH ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_LARGE_MASK ; } else if ( this_error < FPMB_ERROR_SMALL_TH ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_SMALL_MASK ; } } # endif <S2SV_ModEnd> <S2SV_ModStart> vpx_clear_system_state ( ) ; <S2SV_ModStart> ( this_error < ( <S2SV_ModEnd> <S2SV_ModStart> ) ) { neutral_count += 1.0 ; } else if ( ( this_error > NCOUNT_INTRA_THRESH ) && ( this_error < ( NCOUNT_INTRA_FACTOR * motion_error ) ) ) { neutral_count += ( double ) motion_error / DOUBLE_DIVIDE_CHECK ( ( double ) this_error ) ; } mv <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> . as_mv <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = mv ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ; cpi -> twopass . frame_mb_stats_buf [ mb_index ] &= ~ FPMB_DCINTRA_MASK ; cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_ZERO_MASK ; if ( this_error > FPMB_ERROR_LARGE_TH ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_LARGE_MASK ; } else if ( this_error < FPMB_ERROR_SMALL_TH ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_SMALL_MASK ; } } # endif if ( ! is_zero_mv ( & mv ) <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] &= ~ FPMB_MOTION_ZERO_MASK ; <S2SV_ModStart> as_mv . col > 0 && mv . as_mv . col >= abs ( mv . as_mv . row ) ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_RIGHT_MASK ; } else if ( mv . as_mv . row < 0 && abs ( mv . as_mv . row ) >= abs ( mv . as_mv . col ) ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_UP_MASK ; } else if ( mv . as_mv . col < 0 && abs ( mv . as_mv . col ) >= abs ( mv . as_mv . row ) ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_LEFT_MASK ; } else { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_DOWN_MASK ; } } # endif if ( ! is_equal_mv ( & mv , & lastmv ) <S2SV_ModEnd> <S2SV_ModStart> lastmv = mv <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_clear_system_state ( ) ; } if ( ( image_data_start_row > cm -> mb_rows / 2 ) || ( image_data_start_row == INVALID_ROW ) ) { image_data_start_row = cm -> mb_rows / 2 ; } if ( image_data_start_row > 0 ) { intra_skip_count = MAX ( 0 , intra_skip_count - ( image_data_start_row * cm -> mb_cols * 2 ) ) ; } <S2SV_ModEnd> <S2SV_ModStart> const int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ; const double min_err = 200 * sqrt ( num_mbs ) ; intra_factor = intra_factor / ( double ) num_mbs ; brightness_factor = brightness_factor / ( double ) num_mbs ; fps . weight = intra_factor * brightness_factor ; fps . <S2SV_ModEnd> <S2SV_ModStart> ; fps . coded_error = ( double ) ( coded_error >> 8 ) + min_err ; fps . sr_coded_error = ( double ) ( sr_coded_error >> 8 ) + min_err <S2SV_ModStart> + min_err <S2SV_ModEnd> <S2SV_ModStart> num_mbs <S2SV_ModEnd> <S2SV_ModStart> num_mbs <S2SV_ModEnd> <S2SV_ModStart> num_mbs ; fps . intra_skip_pct = ( double ) intra_skip_count / num_mbs ; fps . inactive_zone_rows = ( double ) image_data_start_row ; fps . inactive_zone_cols = ( double ) 0 <S2SV_ModEnd> <S2SV_ModStart> ( ( double ) sum_mvr * sum_mvr <S2SV_ModEnd> <S2SV_ModStart> ( ( double ) sum_mvc * sum_mvc <S2SV_ModEnd> <S2SV_ModStart> num_mbs <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { output_fpmb_stats ( twopass -> frame_mb_stats_buf , cm , cpi -> output_pkt_list ) ; } # endif <S2SV_ModStart> ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> gld_fb_idx ] , cm -> ref_frame_map [ cpi -> lst_fb_idx ] <S2SV_ModEnd> <S2SV_ModStart> vpx_extend_frame_borders ( new_yv12 ) ; if ( lc != NULL <S2SV_ModEnd> <S2SV_ModStart> ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> lst_fb_idx ] , cm -> new_fb_idx ) ; } <S2SV_ModEnd> <S2SV_ModStart> cpi -> gld_fb_idx != INVALID_IDX && lc == <S2SV_ModEnd> <S2SV_ModStart> ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> gld_fb_idx ] , cm -> ref_frame_map [ cpi -> lst_fb_idx ] <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> use_svc ) vp9_inc_frame_in_layer ( cpi ) ; "
4118,<S2SV_StartBug> static const int16_t * filter = vp9_down2_symeven_half_filter ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4119,<S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> l2cap_pi ( sk ) -> num_conf_req ++ ; 
4120,<S2SV_StartBug> if ( user -> uid_keyring ) { <S2SV_EndBug> ,<S2SV_ModStart> && user -> session_keyring 
4121,<S2SV_StartBug> const int length ) { <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> 
4122,<S2SV_StartBug> efx -> mac_op -> update_stats ( efx ) ; <S2SV_EndBug> ,<S2SV_ModStart> net_dev -> gso_max_segs = EFX_TSO_MAX_SEGS ; 
4123,"<S2SV_StartBug> static void encode_frame ( vpx_codec_ctx_t * codec , <S2SV_EndBug> <S2SV_StartBug> VpxVideoWriter * writer ) { <S2SV_EndBug> <S2SV_StartBug> while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int got_pkts = 0 ; <S2SV_ModStart> got_pkts = 1 ; <S2SV_ModStart> return got_pkts ; 
4124,<S2SV_StartBug> if ( ! seig_entry -> key_info [ 0 ] ) <S2SV_EndBug> ,<S2SV_ModStart> seig_entry && 
4125,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4126,"<S2SV_StartBug> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> <S2SV_StartBug> i += verdef -> vd_next ; <S2SV_EndBug> ","<S2SV_ModStart> i >= 0 && <S2SV_ModStart> if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( ""Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n"" ) ; break ; } "
4127,"<S2SV_StartBug> int size ; <S2SV_EndBug> <S2SV_StartBug> size = offsetof ( PATH , p [ 0 ] ) + sizeof ( path -> p [ 0 ] ) * npts ; <S2SV_EndBug> ","<S2SV_ModStart> ; int base_size <S2SV_ModStart> base_size = sizeof ( path -> <S2SV_ModEnd> <S2SV_ModStart> * npts ; size = offsetof ( PATH , <S2SV_ModEnd> <S2SV_ModStart> + base_size ; if ( base_size / npts != sizeof ( path -> p [ 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested"" ) ) ) <S2SV_ModEnd> "
4128,<S2SV_StartBug> size = INT_MAX ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( unlikely ( ! access_ok ( VERIFY_WRITE , ubuf , size ) ) ) return - EFAULT "
4129,<S2SV_StartBug> mptctl_gettargetinfo ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> int * pdata ; <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,"<S2SV_ModStart> MPT_ADAPTER * ioc , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4130,<S2SV_StartBug> return in ; <S2SV_EndBug> ,<S2SV_ModStart> NULL <S2SV_ModEnd> 
4131,<S2SV_StartBug> if ( arg_seccomp_block_secondary ) <S2SV_EndBug> ,"<S2SV_ModStart> create_empty_dir_as_root ( RUN_SECCOMP_DIR , 0755 ) ; "
4132,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> dec_tables . counter_head ++ ; dec_tables . counter_tail ++ ; 
4133,"<S2SV_StartBug> hfs_bnode_read ( src_fd . bnode , & entry , src_fd . entryoffset , <S2SV_EndBug> ",<S2SV_ModStart> if ( src_fd . entrylength > sizeof ( entry ) || src_fd . entrylength < 0 ) { err = - EIO ; goto out ; } 
4134,"<S2SV_StartBug> flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( ! memcmp ( p , ff_asf_ext_stream_header , sizeof ( ff_asf_guid ) ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> if ( end - p >= ( sizeof ( ff_asf_guid ) * 3 + 26 ) ) { <S2SV_ModStart> } <S2SV_ModStart> if ( chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , ""Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%"" PRId64 ""<S2SV_blank>is<S2SV_blank>invalid)\\n"" , chunksize ) ; return AVERROR_INVALIDDATA ; } "
4135,<S2SV_StartBug> if ( ! authctxt -> valid ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( b = sshbuf_new ( ) ) == NULL ) <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; goto done ; } if ( "
4136,"<S2SV_StartBug> SEPARATE_ZVAL ( var2 ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_double ( * var2 ) ; <S2SV_EndBug> <S2SV_StartBug> matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( var2 ) ; <S2SV_EndBug> <S2SV_StartBug> php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> if ( Z_TYPE_PP <S2SV_ModEnd> <S2SV_ModStart> != IS_DOUBLE ) { zval dval ; dval = * * var ; zval_copy_ctor ( & dval ) <S2SV_ModStart> & dval ) ; matrix [ i ] [ j ] = ( float ) Z_DVAL ( dval ) ; } else { matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( <S2SV_ModEnd> <S2SV_ModStart> } } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix"" ) ; RETURN_FALSE ; } } } } res = gdImageConvolution ( im_src , matrix , <S2SV_ModEnd> <S2SV_ModStart> div , ( float ) offset ) ; if ( res ) { RETURN_TRUE <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4137,"<S2SV_StartBug> static inline void mcryptd_check_internal ( struct rtattr * * tb , u32 * type , <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> if ( ( algt -> type & CRYPTO_ALG_INTERNAL ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( algt -> mask & CRYPTO_ALG_INTERNAL ) ) <S2SV_EndBug> ",<S2SV_ModStart> bool <S2SV_ModEnd> <S2SV_ModStart> false ; * type |= <S2SV_ModEnd> <S2SV_ModStart> ; * mask |= algt -> mask & <S2SV_ModEnd> <S2SV_ModStart> * type & * <S2SV_ModEnd> <S2SV_ModStart> return true ; else return false <S2SV_ModEnd> 
4138,"<S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> xd -> mi = cm -> mi_grid_visible ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( cm -> counts ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( cpi -> coef_counts ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( cpi -> tx_stepdown_count ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( cpi -> rd_comp_pred_diff ) ; <S2SV_EndBug> <S2SV_StartBug> switch_lossless_mode ( cpi , cpi -> mb . e_mbd . lossless ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_initialize_me_consts ( cpi , cm -> base_qindex ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) <S2SV_EndBug> <S2SV_StartBug> cm -> prev_mi = get_prev_mi ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> PICK_MODE_CONTEXT * ctx = & cpi -> mb . sb64_context ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . partition_search_type == SOURCE_VAR_BASED_PARTITION && <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> const int tile_cols = 1 << cm -> log2_tile_cols ; <S2SV_EndBug> <S2SV_StartBug> encode_rd_sb_row ( cpi , & tile , mi_row , & tp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sf -> skip_encode_sb ) { <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * const td = & cpi -> td ; <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> RD_COUNTS * const rdc = & cpi -> td . rd_counts ; <S2SV_ModStart> * td <S2SV_ModEnd> <S2SV_ModStart> rdc <S2SV_ModEnd> <S2SV_ModStart> rdc -> comp_pred_diff <S2SV_ModEnd> <S2SV_ModStart> rdc -> filter_diff ) ; xd -> <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) x -> fwd_txm4x4 = xd -> lossless ? vp9_highbd_fwht4x4 : vpx_highbd_fdct4x4 ; else x -> fwd_txm4x4 = xd -> lossless ? vp9_fwht4x4 : vpx_fdct4x4 ; x -> highbd_itxm_add = xd -> lossless ? vp9_highbd_iwht4x4_add : vp9_highbd_idct4x4_add ; # else x -> fwd_txm4x4 = xd -> lossless ? vp9_fwht4x4 : vpx_fdct4x4 ; # endif x -> itxm_add = xd -> lossless ? vp9_iwht4x4_add : vp9_idct4x4_add ; if ( xd -> lossless ) x -> optimize = 0 ; cm -> tx_mode = select_tx_mode <S2SV_ModEnd> <S2SV_ModStart> xd <S2SV_ModEnd> <S2SV_ModStart> x , <S2SV_ModStart> cm -> use_prev_frame_mvs = ! cm -> error_resilient_mode && cm -> width == cm -> last_width && cm -> height == cm -> last_height && ! cm -> intra_only && cm -> last_show_frame <S2SV_ModEnd> <S2SV_ModStart> cm -> use_prev_frame_mvs ? cm -> prev_mip + cm -> mi_stride + 1 : NULL ; x -> quant_fp = cpi -> sf . use_quant_fp ; vp9_zero ( x -> skip_txfm <S2SV_ModEnd> <S2SV_ModStart> td . pc_root -> none <S2SV_ModEnd> <S2SV_ModStart> cm -> frame_type != KEY_FRAME && cpi -> rc . frames_since_golden == 0 && ! cpi -> use_svc ) cpi -> ref_frame_flags &= ( ~ VP9_GOLD_FLAG ) ; if ( sf -> <S2SV_ModEnd> <S2SV_ModStart> ) source_var_based_partition_search_method ( cpi ) ; <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { input_fpmb_stats ( & cpi -> twopass . firstpass_mb_stats , cm , & cpi -> twopass . this_frame_mb_stats ) ; } # endif if ( MIN ( cpi -> oxcf . max_threads , <S2SV_ModEnd> <S2SV_ModStart> ) > 1 ) vp9_encode_tiles_mt ( cpi <S2SV_ModEnd> <S2SV_ModStart> encode_tiles ( cpi ) ; <S2SV_ModEnd> <S2SV_ModStart> sf -> skip_encode_frame = sf -> skip_encode_sb ? get_skip_encode_frame ( cm , td ) : 0 ; <S2SV_ModEnd> "
4139,"<S2SV_StartBug> size_t input_size , <S2SV_EndBug> <S2SV_StartBug> # define prolog if ( bytes_matched >= max_bytes_matched ) { action = ACTION_KILL ; break ; } <S2SV_EndBug> <S2SV_StartBug> # define fail_if_error ( e ) switch ( e ) { case ERROR_INSUFFICIENT_MEMORY : return - 2 ; case ERROR_TOO_MANY_RE_FIBERS : return - 4 ; } <S2SV_EndBug> <S2SV_StartBug> input -= character_size ; <S2SV_EndBug> <S2SV_StartBug> max_bytes_matched = ( int ) yr_min ( input_size , RE_SCAN_LIMIT ) ; <S2SV_EndBug> <S2SV_StartBug> match = IS_WORD_CHAR ( * input ) ; <S2SV_EndBug> <S2SV_StartBug> match = ! IS_WORD_CHAR ( * input ) ; <S2SV_EndBug> <S2SV_StartBug> ! ( flags & RE_FLAGS_NOT_AT_START ) && <S2SV_EndBug> <S2SV_StartBug> match = TRUE ; <S2SV_EndBug> <S2SV_StartBug> match = TRUE ; <S2SV_EndBug> <S2SV_StartBug> else if ( IS_WORD_CHAR ( * ( input - input_incr ) ) != IS_WORD_CHAR ( * input ) ) <S2SV_EndBug> <S2SV_StartBug> kill = input_size > ( size_t ) bytes_matched ; <S2SV_EndBug> <S2SV_StartBug> kill = ( flags & RE_FLAGS_NOT_AT_START ) || ( bytes_matched != 0 ) ; <S2SV_EndBug> <S2SV_StartBug> input_size > ( size_t ) bytes_matched ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> <S2SV_ModStart> { if ( <S2SV_ModEnd> <S2SV_ModStart> || ( character_size == 2 && * ( input + 1 ) != 0 ) ) { action = ACTION_KILL ; break ; } <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> max_bytes_matched = ( int ) yr_min ( input_backwards_size , RE_SCAN_LIMIT ) ; <S2SV_ModStart> else { <S2SV_ModStart> input_forwards_size <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> <S2SV_ModStart> _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> <S2SV_ModStart> input_backwards_size < character_size ) { <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } else { assert ( input < input_data + input_forwards_size ) ; assert ( input >= input_data - input_backwards_size ) ; assert <S2SV_ModEnd> <S2SV_ModStart> < input_data + input_forwards_size ) ; assert ( input - input_incr >= input_data - input_backwards_size ) ; match = _yr_re_is_word_char ( input , character_size ) != _yr_re_is_word_char ( input - input_incr , character_size ) ; } <S2SV_ModEnd> <S2SV_ModStart> input_backwards_size <S2SV_ModEnd> <S2SV_ModStart> input_backwards_size > 0 <S2SV_ModEnd> <S2SV_ModStart> input_forwards_size <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4140,"<S2SV_StartBug> ALOGE ( ""b/26366256"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; android_errorWriteLog ( 0x534e4554 , ""26366256"" "
4141,<S2SV_StartBug> r = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4142,"<S2SV_StartBug> __be32 saddr , __be32 daddr , struct ip_options * opt ) <S2SV_EndBug> <S2SV_StartBug> skb_push ( skb , sizeof ( struct iphdr ) + ( opt ? opt -> optlen : 0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt && opt -> optlen ) { <S2SV_EndBug> <S2SV_StartBug> iph -> ihl += opt -> optlen >> 2 ; <S2SV_EndBug> <S2SV_StartBug> ip_options_build ( skb , opt , daddr , rt , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> & opt -> 
4143,<S2SV_StartBug> BUG_ON ( direction != ITER_PIPE ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; WARN_ON ( pipe -> nrbufs == pipe -> buffers 
4144,"<S2SV_StartBug> log_err ( ctx , ""Cannot<S2SV_blank>define<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>a<S2SV_blank>keymap<S2SV_blank>file\\n"" , <S2SV_EndBug> <S2SV_StartBug> xkb_file_type_to_string ( file -> file_type ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( file -> file_type == FILE_TYPE_GEOMETRY ) { log_vrb ( ctx , 1 , ""Geometry<S2SV_blank>sections<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported;<S2SV_blank>ignoring\\n"" ) ; } else { <S2SV_ModStart> } "
4145,"<S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> if ( length != 0x000a ) <S2SV_EndBug> <S2SV_StartBug> if ( ReadRectangle ( image , & frame ) == MagickFalse ) <S2SV_EndBug> <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> if ( length == 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( length > 154 ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <S2SV_EndBug> ","<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length <S2SV_ModStart> length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( <S2SV_ModStart> ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length <S2SV_ModStart> GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length > <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; "
4146,<S2SV_StartBug> # ifdef CONFIG_SMP <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4147,<S2SV_StartBug> get_page ( * page ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( ! try_get_page ( * page ) ) ) { ret = - ENOMEM ; goto unmap ; } <S2SV_ModEnd> 
4148,"<S2SV_StartBug> ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len ) ; <S2SV_EndBug> ","<S2SV_ModStart> , 0 "
4149,"<S2SV_StartBug> while ( nr > 0 ) { <S2SV_EndBug> <S2SV_StartBug> c = tty -> ops -> write ( tty , b , nr ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct n_tty_data * ldata = tty -> disc_data ; <S2SV_ModStart> mutex_lock ( & ldata -> output_lock ) ; <S2SV_ModStart> ) ; mutex_unlock ( & ldata -> output_lock 
4150,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
4151,<S2SV_StartBug> flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT | <S2SV_EndBug> <S2SV_StartBug> if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & inode -> i_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> if ( max_blocks > 0 ) { <S2SV_EndBug> ,"<S2SV_ModStart> mutex_lock ( & inode -> i_mutex ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! <S2SV_ModEnd> <S2SV_ModStart> && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; } flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ; if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_ModStart> if ( partial_begin || partial_end ) { ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ; if ( ret ) goto out_mutex <S2SV_ModEnd> <S2SV_ModStart> flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ; "
4152,"<S2SV_StartBug> prefetch_table ( ( const void * ) encT , sizeof ( encT ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> enc_tables . counter_head ++ ; enc_tables . counter_tail ++ ; <S2SV_ModStart> & enc_tables <S2SV_ModEnd> <S2SV_ModStart> enc_tables <S2SV_ModEnd> 
4153,"<S2SV_StartBug> memcpy ( buf + x , data , state -> xsize ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
4154,<S2SV_StartBug> gfp_mask = sk -> sk_allocation ; <S2SV_EndBug> <S2SV_StartBug> int npages ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> int npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ; err = - EMSGSIZE ; if ( npages > MAX_SKB_FRAGS ) goto failure ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4155,<S2SV_StartBug> if ( tcp_specified && settings . port != 0 && ! udp_specified ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4156,"<S2SV_StartBug> char * prime_arg1 , <S2SV_EndBug> <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> free ( prime_arg1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> = NULL , * prime_arg2 = NULL <S2SV_ModEnd> <S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : free ( prime_arg1 ) ; free ( prime_arg2 ) ; gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
4157,<S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> <S2SV_StartBug> p -> status = - EINVAL ; <S2SV_EndBug> ,"<S2SV_ModStart> < 0 || param2 <S2SV_ModStart> if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , ""32438598"" ) ; ALOGW ( ""\\tERROR<S2SV_blank>EQ_PARAM_BAND_LEVEL<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ; } <S2SV_ModStart> param2 < 0 || <S2SV_ModStart> if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , ""32436341"" ) ; ALOGW ( ""\\tERROR<S2SV_blank>EQ_PARAM_CENTER_FREQ<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ; } <S2SV_ModStart> param2 < 0 || <S2SV_ModStart> if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , ""32247948"" ) ; ALOGW ( ""\\tERROR<S2SV_blank>EQ_PARAM_BAND_FREQ_RANGE<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ; } "
4158,"<S2SV_StartBug> if ( ! nonce1 ) { <S2SV_EndBug> <S2SV_StartBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> <S2SV_StartBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> valid_hex ( nonce1 ) <S2SV_ModEnd> <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" <S2SV_ModEnd> <S2SV_ModStart> n2size < 2 || n2size > 16 <S2SV_ModEnd> <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" <S2SV_ModEnd> "
4159,"<S2SV_StartBug> if ( ( fd = open ( path_name , ( O_CREAT | O_APPEND | O_WRONLY ) , 0644 ) ) == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> error ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s"" , path_name , <S2SV_EndBug> ","<S2SV_ModStart> _open_as_other ( path_name , req <S2SV_ModEnd> <S2SV_ModStart> ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>Permission<S2SV_blank>denied"" , path_name <S2SV_ModEnd> "
4160,"<S2SV_StartBug> walk -> private += __mincore_unmapped_range ( addr , end , <S2SV_EndBug> ","<S2SV_ModStart> unsigned char * vec = walk -> private ; unsigned long nr = ( end - addr ) >> PAGE_SHIFT ; memset ( vec , 0 , nr ) ; <S2SV_ModStart> nr <S2SV_ModEnd> "
4161,"<S2SV_StartBug> if ( ! ( segment -> temporal_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> temporal_offset_entries ) ) ) || <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < segment -> nb_index_entries ; i ++ ) { <S2SV_EndBug> ",<S2SV_ModStart> segment -> nb_index_entries && length < 11 ) return AVERROR_INVALIDDATA ; if ( <S2SV_ModStart> if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; 
4162,"<S2SV_StartBug> void * zrealloc ( void * ptr , size_t size ) { <S2SV_EndBug> ",<S2SV_ModStart> ASSERT_NO_SIZE_OVERFLOW ( size ) ; 
4163,"<S2SV_StartBug> FRAME_CONTEXT * const fc = & cm -> fc ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_reader_init ( & r , data , partition_size ) ) <S2SV_EndBug> <S2SV_StartBug> return vp9_reader_has_error ( & r ) ; <S2SV_EndBug> ","<S2SV_ModStart> cm -> fc ; vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_reader_init <S2SV_ModEnd> <S2SV_ModStart> , pbi -> decrypt_cb , pbi -> decrypt_state <S2SV_ModStart> vpx_reader_has_error <S2SV_ModEnd> "
4164,<S2SV_StartBug> if ( numrows < 0 || numcols < 0 ) { <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> matrix -> datasize_ = numrows * numcols ; <S2SV_EndBug> <S2SV_StartBug> jas_matrix_destroy ( matrix ) ; <S2SV_EndBug> <S2SV_StartBug> jas_matrix_destroy ( matrix ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> size_t size ; matrix = 0 ; <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> 0 ; if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) { goto error ; } matrix -> datasize_ = size <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> error : if ( matrix ) { jas_matrix_destroy ( matrix ) ; } return 0 ; "
4165,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> else { matvar -> name [ tmp - 1 ] = '\\0' ; } 
4166,<S2SV_StartBug> * dst = * src ; <S2SV_EndBug> ,<S2SV_ModStart> __switch_to_tm ( src ) ; tm_recheckpoint_new_task ( src ) ; 
4167,"<S2SV_StartBug> int flags = fcntl ( semaphore -> fd , F_GETFL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( fcntl ( semaphore -> fd , F_SETFL , flags | O_NONBLOCK ) == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( fcntl ( semaphore -> fd , F_SETFL , flags ) == - 1 ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
4168,"<S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK ( bp -> bp_flags ) ; 
4169,"<S2SV_StartBug> int idx , ret = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; <S2SV_EndBug> <S2SV_StartBug> hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { <S2SV_EndBug> ","<S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> || hlist_empty ( <S2SV_ModEnd> <S2SV_ModStart> ) ) { pr_warn_once ( ""no<S2SV_blank>route<S2SV_blank>for<S2SV_blank>guest_irq<S2SV_blank>%u/%u<S2SV_blank>(broken<S2SV_blank>user<S2SV_blank>space?)\\n"" , guest_irq , irq_rt -> nr_rt_entries ) ; goto out ; } hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] "
4170,<S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> sock * sk = asoc -> base . sk ; struct <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4171,<S2SV_StartBug> if ( ( unsigned int ) arg >= cdi -> capacity ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4172,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4173,<S2SV_StartBug> struct mount * parent = ACCESS_ONCE ( mnt -> mnt_parent ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( dentry != vfsmnt -> mnt_root ) { bptr = * buffer ; blen = * buflen ; error = 3 ; break ; } 
4174,"<S2SV_StartBug> vcpu = kvm_arch_vcpu_create ( kvm , id ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( id >= KVM_MAX_VCPUS ) return - EINVAL ; 
4175,<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> ,<S2SV_ModStart> void 
4176,<S2SV_StartBug> ld -> bytes_left = ld -> buffer_size - words * 4 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ld -> buffer_size < words * 4 ) ld -> bytes_left = 0 ; else 
4177,"<S2SV_StartBug> SetImageColorspace ( image , GRAYColorspace ) ; <S2SV_EndBug> ","<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
4178,"<S2SV_StartBug> if ( strchr ( str , ':' ) ) <S2SV_EndBug> <S2SV_StartBug> if ( strchr ( str , '.' ) ) <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> != NULL <S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> != NULL 
4179,"<S2SV_StartBug> pfn = kvm_pin_pages ( slot , gfn , page_size ) ; <S2SV_EndBug> <S2SV_StartBug> kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_EndBug> ",<S2SV_ModStart> >> PAGE_SHIFT <S2SV_ModStart> >> PAGE_SHIFT 
4180,"<S2SV_StartBug> switch ( bank ) <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 | ECON1_BSEL0 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL0 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL0 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 | ECON1_BSEL0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( bank == BANK_0 ) { <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 | ENC28J60_ECON1_BSEL0 ) ; } else if ( bank == BANK_1 ) { <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ECON1 , ENC28J60_ECON1_BSEL0 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 ) ; } else if ( bank == BANK_2 ) { <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ECON1 , ENC28J60_ECON1_BSEL0 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 ) ; } else { <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 | ENC28J60_ECON1_BSEL0 ) <S2SV_ModEnd> "
4181,<S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff "
4182,"<S2SV_StartBug> c -> c_normalize_args = Py_BuildValue ( ""(sN)"" , ""NFKC"" , Py_None ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
4183,<S2SV_StartBug> if ( upid == - 1 ) <S2SV_EndBug> ,<S2SV_ModStart> INT_MIN ) return - ESRCH ; if ( upid == 
4184,"<S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> buffered_app_data ) , rr -> seq_num ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( <S2SV_ModStart> < 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } <S2SV_ModEnd> "
4185,"<S2SV_StartBug> pfkey_broadcast ( skb , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; <S2SV_EndBug> ",<S2SV_ModStart> hdr -> sadb_msg_reserved = 0 ; 
4186,"<S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> ",<S2SV_ModStart> rc = <S2SV_ModStart> rc = <S2SV_ModStart> rc = 
4187,<S2SV_StartBug> if ( current -> mm ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> leave_mm ( smp_processor_id ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> smp_mb ( ) ; } 
4188,"<S2SV_StartBug> static int conditional_skipintra ( MB_PREDICTION_MODE mode , <S2SV_EndBug> ","<S2SV_ModStart> PREDICTION_MODE mode , PREDICTION_MODE <S2SV_ModEnd> "
4189,<S2SV_StartBug> struct channel_info * info = <S2SV_EndBug> ,<S2SV_ModStart> ; if ( voice < 0 || voice >= devc -> nr_voice ) return ; if ( chn < 0 || chn > 15 ) return ; info 
4190,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> zend_object_store_ctor_failed ( * rval TSRMLS_CC ) ; 
4191,"<S2SV_StartBug> size_t copied , len , cur_len ; <S2SV_EndBug> <S2SV_StartBug> copied = min_t ( const size_t , cur_len , PAGE_SIZE ) ; <S2SV_EndBug> <S2SV_StartBug> 0 , copied ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> cur_len = save_len - cur_len ; <S2SV_EndBug> ","<S2SV_ModStart> bytes , <S2SV_ModStart> bytes <S2SV_ModEnd> <S2SV_ModStart> bytes <S2SV_ModEnd> <S2SV_ModStart> if ( copied < bytes ) break ; <S2SV_ModStart> ; if ( ! cur_len ) { for ( i = 0 ; i < nr_pages ; i ++ ) put_page ( wdata -> pages [ i ] ) ; kfree ( wdata ) ; rc = - EFAULT ; break ; } for ( ; nr_pages > i + 1 ; nr_pages -- ) put_page ( wdata -> pages [ nr_pages - 1 ] ) "
4192,<S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> * tl_data_head = NULL ; 
4193,"<S2SV_StartBug> static void write_inter_mode ( vp9_writer * w , MB_PREDICTION_MODE mode , <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * probs ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> 
4194,"<S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> <S2SV_StartBug> pr_info ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> 
4195,"<S2SV_StartBug> int i , j , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ; <S2SV_EndBug> <S2SV_StartBug> uint16 bps , nstrips , planar , strips_per_sample ; <S2SV_EndBug> ","<S2SV_ModStart> bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ; uint32 j <S2SV_ModEnd> <S2SV_ModStart> planar ; uint32 nstrips ; uint32 <S2SV_ModEnd> "
4196,<S2SV_StartBug> int i ; <S2SV_EndBug> ,<S2SV_ModStart> jas_matind_t i ; jas_matind_t <S2SV_ModEnd> 
4197,"<S2SV_StartBug> size_t count , const uint64_t clsid [ 2 ] ) <S2SV_EndBug> <S2SV_StartBug> if ( ! NOTMIME ( ms ) ) <S2SV_EndBug> <S2SV_StartBug> str = cdf_clsid_to_mime ( clsid , clsid2mime ) ; <S2SV_EndBug> ",<S2SV_ModStart> cdf_directory_t * root_storage <S2SV_ModEnd> <S2SV_ModStart> && root_storage <S2SV_ModStart> root_storage -> d_storage_uuid <S2SV_ModEnd> 
4198,<S2SV_StartBug> numbers [ argc ++ ] = ( unsigned long ) mtree_atol ( & p ) ; <S2SV_EndBug> <S2SV_StartBug> if ( argc > MAX_PACK_ARGS ) { <S2SV_EndBug> ,"<S2SV_ModStart> if ( argc >= MAX_PACK_ARGS ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Too<S2SV_blank>many<S2SV_blank>arguments"" ) ; return ARCHIVE_WARN ; } <S2SV_ModStart>  <S2SV_ModEnd> "
4199,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
4200,<S2SV_StartBug> if ( ( msr -> msc_reqbody_spilltodisk ) <S2SV_EndBug> ,<S2SV_ModStart> ) && ( msr -> txcfg -> reqbody_buffering != REQUEST_BODY_FORCEBUF_ON 
4201,"<S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> buffered_app_data ) , rr -> seq_num ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( <S2SV_ModStart> < 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } <S2SV_ModEnd> "
4202,"<S2SV_StartBug> parse_global_option ( CMD_SET_DEFAULTS , NULL , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> & new_global_options , "
4203,<S2SV_StartBug> char fnam [ PROCLEN ] ; <S2SV_EndBug> <S2SV_StartBug> char * line = NULL ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> if ( nextcg ) <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> c2 = get_pid_cgroup ( pid , contrl ) ; char * linecmp <S2SV_ModEnd> <S2SV_ModStart> return false <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> out : free ( c2 <S2SV_ModEnd> "
4204,<S2SV_StartBug> if ( x < sx ) { <S2SV_EndBug> <S2SV_StartBug> j = x * size + b ; <S2SV_EndBug> <S2SV_StartBug> if ( y < sy && x < sx ) { <S2SV_EndBug> <S2SV_StartBug> j = ( ( x * sy + y ) * size ) + b ; <S2SV_EndBug> <S2SV_StartBug> if ( z < sz && y < sy && x < sx ) { <S2SV_EndBug> <S2SV_StartBug> ( ( char * ) data -> data ) [ j ] = output [ i ] ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( j >= 0 && j < elements * size ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( j >= 0 && j < elements * size ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( j >= 0 && j < elements * size ) { 
4205,"<S2SV_StartBug> uint32_t off = offset , tmp , finish ; <S2SV_EndBug> <S2SV_StartBug> finish = fru -> size ; <S2SV_EndBug> <S2SV_StartBug> offset + length , finish - offset ) ; <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> memcpy ( ( frubuf + off ) - offset , rsp -> data + 1 , tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp == 0 && off < finish ) <S2SV_EndBug> ","<S2SV_ModStart> ; uint32_t tmp , finish ; uint32_t size_left_in_buffer <S2SV_ModEnd> <S2SV_ModStart> memset ( frubuf + fru -> size , 0 , length - fru -> size ) ; <S2SV_ModStart> ; length = finish - offset <S2SV_ModStart> size_left_in_buffer = length ; <S2SV_ModStart> if ( rsp -> data_len < 1 || tmp > rsp -> data_len - 1 || tmp > size_left_in_buffer ) { printf ( ""<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>buffer<S2SV_blank>size"" ) ; return - 1 ; } <S2SV_ModStart> size_left_in_buffer -= tmp ; "
4206,<S2SV_StartBug> g -> head <= 0 || <S2SV_EndBug> ,<S2SV_ModStart> 0 || ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 
4207,<S2SV_StartBug> if ( ret ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> ptr -> kernel_data = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ptr -> next = NULL ; ptr -> buffer_length = 0 ; ptr -> kernel_data = NULL ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4208,"<S2SV_StartBug> int64_t target_end = s -> end_off ? s -> end_off : s -> filesize ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ! s -> willclose || s -> chunksize < 0 ) && <S2SV_EndBug> <S2SV_StartBug> if ( ! len && ( ! s -> willclose || s -> chunksize < 0 ) && <S2SV_EndBug> <S2SV_StartBug> ""Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%"" PRId64 "",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%"" PRId64 ""\\n"" , <S2SV_EndBug> ","<S2SV_ModStart> uint64_t <S2SV_ModEnd> <S2SV_ModStart> == UINT64_MAX ) <S2SV_ModEnd> <S2SV_ModStart> == UINT64_MAX ) && s -> off < <S2SV_ModEnd> <S2SV_ModStart> PRIu64 "",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%"" PRIu64 <S2SV_ModEnd> "
4209,<S2SV_StartBug> name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ; <S2SV_EndBug> ,<S2SV_ModStart> rmtvaluelen <S2SV_ModEnd> 
4210,"<S2SV_StartBug> bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ++ rs -> cont_loops >= RR_MAX_CE_ENTRIES ) goto out ; 
4211,"<S2SV_StartBug> vp8_mse16x16 ( orig + col , orig_stride , <S2SV_EndBug> ",<S2SV_ModStart> vpx_mse16x16 <S2SV_ModEnd> 
4212,<S2SV_StartBug> if ( * rsize >= 74 && <S2SV_EndBug> <S2SV_StartBug> rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 && <S2SV_EndBug> ,"<S2SV_ModStart> 75 && rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 && rdesc [ 63 ] == 0x19 && rdesc [ 64 ] == 0x08 && rdesc [ 65 ] == 0x29 && rdesc [ 66 ] == 0x0f && rdesc [ 71 ] == 0x75 && rdesc [ 72 ] == 0x08 && rdesc [ 73 ] == 0x95 && rdesc [ 74 ] == 0x01 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Kye/Genius<S2SV_blank>Ergo<S2SV_blank>Mouse<S2SV_blank>"" ""report<S2SV_blank>descriptor\\n"" ) ; <S2SV_ModEnd> <S2SV_ModStart> = 0x09 ; rdesc [ 64 ] = 0x04 ; rdesc [ 66 ] = 0x07 ; rdesc [ 72 ] = 0x01 ; rdesc [ 74 ] = 0x08 <S2SV_ModEnd> "
4213,<S2SV_StartBug> attrs = malloc ( sizeof ( TEE_Attribute ) * attr_count ) ; <S2SV_EndBug> ,"<S2SV_ModStart> size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , attr_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> alloc_size <S2SV_ModEnd> "
4214,"<S2SV_StartBug> char buf [ sz_rfbSetEncodingsMsg + MAX_ENCODINGS * 4 ] ; <S2SV_EndBug> <S2SV_StartBug> rfbSetEncodingsMsg * se = ( rfbSetEncodingsMsg * ) buf ; <S2SV_EndBug> <S2SV_StartBug> uint32_t * encs = ( uint32_t * ) ( & buf [ sz_rfbSetEncodingsMsg ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! WriteToRFBServer ( client , buf , len ) ) return FALSE ; <S2SV_EndBug> ",<S2SV_ModStart> union { char bytes <S2SV_ModEnd> <S2SV_ModStart> msg ; } buf ; rfbSetEncodingsMsg * se = & buf . msg <S2SV_ModEnd> <S2SV_ModStart> . bytes <S2SV_ModStart> . bytes 
4215,"<S2SV_StartBug> off_t pos = sys -> tell ( fh ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! fn ) return MSPACK_ERR_NOMEMORY ; <S2SV_EndBug> <S2SV_StartBug> hdr -> filename = fn ; <S2SV_EndBug> <S2SV_StartBug> if ( sys -> read ( fh , & buf [ 0 ] , 9 ) != 9 ) return MSPACK_ERR_READ ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 9 ; i ++ , fn ++ ) if ( ! ( * fn = buf [ i ] ) ) break ; <S2SV_EndBug> <S2SV_StartBug> pos += ( i < 9 ) ? i + 1 : 9 ; <S2SV_EndBug> <S2SV_StartBug> return MSPACK_ERR_SEEK ; <S2SV_EndBug> <S2SV_StartBug> if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 4 ; i ++ , fn ++ ) if ( ! ( * fn = buf [ i ] ) ) break ; <S2SV_EndBug> <S2SV_StartBug> pos += ( i < 4 ) ? i + 1 : 4 ; <S2SV_EndBug> <S2SV_StartBug> return MSPACK_ERR_SEEK ; <S2SV_EndBug> ","<S2SV_ModStart> int len <S2SV_ModEnd> <S2SV_ModStart> ( hdr -> filename = fn ) ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( len = <S2SV_ModStart> ) < 2 <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> ) if ( ! ( * fn ++ <S2SV_ModEnd> <S2SV_ModStart> if ( i == 9 && buf [ 8 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( <S2SV_ModEnd> <S2SV_ModStart> - len ) , MSPACK_SYS_SEEK_CUR <S2SV_ModEnd> <S2SV_ModStart> ; fn -- <S2SV_ModStart> ( len = <S2SV_ModStart> ) < 2 <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> ) if ( ! ( * fn ++ <S2SV_ModEnd> <S2SV_ModStart> if ( i == 4 && buf [ 3 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( <S2SV_ModEnd> <S2SV_ModStart> - len ) , MSPACK_SYS_SEEK_CUR <S2SV_ModEnd> <S2SV_ModStart> ; fn -- "
4216,<S2SV_StartBug> case NPPVformValue : <S2SV_EndBug> <S2SV_StartBug> type = RPC_TYPE_BOOLEAN ; <S2SV_EndBug> ,<S2SV_ModStart> : case NPPVpluginNativeAccessibleAtkPlugId <S2SV_ModStart> case NPPVpluginUrlRequestsDisplayedBool : case NPPVpluginWantsAllNetworkStreams : case NPPVpluginCancelSrcStream : case NPPVSupportsAdvancedKeyHandling : 
4217,<S2SV_StartBug> unsigned int i ; <S2SV_EndBug> ,<S2SV_ModStart> ; bpcc -> bpcs = 0 
4218,"<S2SV_StartBug> return print_value ( item , 0 , 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , 0 "
4219,"<S2SV_StartBug> int i , ubits = BN_num_bits ( u ) , vbits = BN_num_bits ( v ) , <S2SV_EndBug> <S2SV_StartBug> if ( ubits <= BN_BITS2 && udp [ 0 ] == 1 ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ",<S2SV_ModStart> ; int <S2SV_ModEnd> <S2SV_ModStart> ; int <S2SV_ModEnd> <S2SV_ModStart> ; int <S2SV_ModEnd> <S2SV_ModStart> ) { if ( <S2SV_ModEnd> <S2SV_ModStart> 0 ) goto err ; if ( udp [ 0 ] == <S2SV_ModStart> } 
4220,<S2SV_StartBug> if ( setpwnam ( pw ) < 0 ) <S2SV_EndBug> ,"<S2SV_ModStart> , "".chsh"" "
4221,"<S2SV_StartBug> int namelen = strlen ( name ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> <S2SV_StartBug> data ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ! size ) <S2SV_EndBug> <S2SV_StartBug> if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { <S2SV_EndBug> <S2SV_StartBug> snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> GetByteContext gb <S2SV_ModEnd> <S2SV_ModStart> data >= data_end <S2SV_ModEnd> <S2SV_ModStart> bytestream2_init ( & gb , data , data_end - <S2SV_ModEnd> <S2SV_ModStart> return amf_get_field_value2 ( & gb <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> "
4222,<S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; } 
4223,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> [ plane ] && in -> linesize 
4224,"<S2SV_StartBug> int pidfd = creat ( pid_file , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <S2SV_EndBug> ","<S2SV_ModStart> open ( pid_file , O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC <S2SV_ModEnd> "
4225,"<S2SV_StartBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys/net"" , ""%r/proc/net"" , NULL , MS_BIND , NULL } , <S2SV_EndBug> <S2SV_StartBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/net"" , ""%r/proc/sys/net"" , NULL , MS_MOVE , NULL } , <S2SV_EndBug> <S2SV_StartBug> r = mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%r/proc/tty"" <S2SV_ModEnd> <S2SV_ModStart> ""%r/proc/tty"" <S2SV_ModEnd> <S2SV_ModStart> safe_mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options , conf -> rootfs . path ? conf -> rootfs . mount : NULL <S2SV_ModEnd> "
4226,"<S2SV_StartBug> PyDict_SetItemString ( d , ""_fields"" , empty_tuple ) < 0 || <S2SV_EndBug> <S2SV_StartBug> PyDict_SetItemString ( d , ""_attributes"" , empty_tuple ) < 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> _PyDict_SetItemId <S2SV_ModEnd> <S2SV_ModStart> & PyId__fields <S2SV_ModEnd> <S2SV_ModStart> _PyDict_SetItemId <S2SV_ModEnd> <S2SV_ModStart> & PyId__attributes <S2SV_ModEnd> 
4227,<S2SV_StartBug> if ( <S2SV_EndBug> ,<S2SV_ModStart> p -> replacement_session_keyring = NULL ; 
4228,<S2SV_StartBug> value = ( unsigned short ) ( buffer [ 0 ] << 8 ) ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( unsigned short ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4229,<S2SV_StartBug> dsize += svbranch . len ; <S2SV_EndBug> ,<S2SV_ModStart> + 1 
4230,<S2SV_StartBug> if ( ! chip -> num_interfaces ) <S2SV_EndBug> <S2SV_StartBug> atomic_dec ( & chip -> active ) ; <S2SV_EndBug> ,<S2SV_ModStart> atomic_dec ( & chip -> active ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
4231,"<S2SV_StartBug> separator = strchr ( line , ':' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
4232,"<S2SV_StartBug> memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( up , 0 , sizeof ( * up ) ) ; "
4233,"<S2SV_StartBug> static void encode_share_access ( struct xdr_stream * xdr , int open_flags ) <S2SV_EndBug> <S2SV_StartBug> switch ( open_flags & ( FMODE_READ | FMODE_WRITE ) ) { <S2SV_EndBug> <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> WRITE32 ( 0 <S2SV_ModEnd> 
4234,"<S2SV_StartBug> if ( ! headcount ) { <S2SV_EndBug> <S2SV_StartBug> msg . msg_iovlen = in ; <S2SV_EndBug> <S2SV_StartBug> sock_len , MSG_DONTWAIT | MSG_TRUNC ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( err != sock_len ) ) { <S2SV_EndBug> ","<S2SV_ModStart> unlikely ( headcount > UIO_MAXIOV ) ) { <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>len<S2SV_blank>%zd\\n"" , sock_len ) ; continue ; } if ( ! headcount ) { if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) { vhost_disable_notify ( & net -> dev , vq ) ; continue ; } break ; } if ( unlikely ( ( vhost_hlen ) ) ) move_iovec_hdr ( vq -> iov , nvq -> hdr , vhost_hlen , in ) ; else copy_iovec_hdr ( vq -> iov , nvq -> hdr , sock_hlen , in ) ; msg . msg_iovlen = in ; err = sock -> ops -> recvmsg ( NULL , sock , & msg , sock_len , MSG_DONTWAIT | MSG_TRUNC ) ; "
4235,"<S2SV_StartBug> name . name = buf ; <S2SV_EndBug> <S2SV_StartBug> err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> err = - EINVAL ; if ( size != sizeof ( outarg ) + <S2SV_ModEnd> <S2SV_ModStart> goto err ; name . name = buf ; name . len = outarg . namelen ; err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) "
4236,<S2SV_StartBug> trust_data . dwUIChoice = WTD_UI_ALL ; <S2SV_EndBug> <S2SV_StartBug> return r ; <S2SV_EndBug> ,"<S2SV_ModStart> WTD_UI_NONE <S2SV_ModEnd> <S2SV_ModStart> switch ( r ) { case ERROR_SUCCESS : break ; case TRUST_E_NOSIGNATURE : uprintf ( ""PKI:<S2SV_blank>File<S2SV_blank>does<S2SV_blank>not<S2SV_blank>appear<S2SV_blank>to<S2SV_blank>be<S2SV_blank>signed:<S2SV_blank>%s"" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_284 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; default : uprintf ( ""PKI:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>validate<S2SV_blank>signature:<S2SV_blank>%s"" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_240 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; } "
4237,<S2SV_StartBug> len = ( ms -> c . len += 20 ) * sizeof ( * ms -> c . li ) ; <S2SV_EndBug> ,<S2SV_ModStart> = 20 + level <S2SV_ModEnd> 
4238,"<S2SV_StartBug> pid_t child ; <S2SV_EndBug> <S2SV_StartBug> tmpdir = mkdtemp ( template ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mount ( ""/proc/self/fd"" , tmpdir , NULL , MS_BIND , NULL ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> fuse_log ( FUSE_LOG_ERR , ""mount(/proc/self/fd,<S2SV_blank>%s,<S2SV_blank>MS_BIND):<S2SV_blank>%m\\n"" , <S2SV_EndBug> <S2SV_StartBug> lo -> proc_self_fd = open ( tmpdir , O_PATH ) ; <S2SV_EndBug> <S2SV_StartBug> fuse_log ( FUSE_LOG_ERR , ""open(%s,<S2SV_blank>O_PATH):<S2SV_blank>%m\\n"" , tmpdir ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""/proc"" <S2SV_ModEnd> <S2SV_ModStart> ""mount(/proc/self/fd,<S2SV_blank>MS_BIND):<S2SV_blank>%m\\n"" <S2SV_ModEnd> <S2SV_ModStart> ""/proc"" <S2SV_ModEnd> <S2SV_ModStart> ""open(/proc,<S2SV_blank>O_PATH):<S2SV_blank>%m\\n"" ) ; exit ( 1 <S2SV_ModEnd> "
4239,<S2SV_StartBug> int c_sz ; <S2SV_EndBug> <S2SV_StartBug> _img -> bps = _y4m -> vpx_bps ; <S2SV_EndBug> <S2SV_StartBug> pic_sz = _y4m -> pic_w * _y4m -> pic_h ; <S2SV_EndBug> <S2SV_StartBug> c_h = ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ; <S2SV_EndBug> <S2SV_StartBug> _img -> stride [ PLANE_Y ] = _img -> stride [ PLANE_ALPHA ] = _y4m -> pic_w ; <S2SV_EndBug> <S2SV_StartBug> _img -> stride [ PLANE_U ] = _img -> stride [ PLANE_V ] = c_w ; <S2SV_EndBug> <S2SV_StartBug> _img -> planes [ PLANE_Y ] = _y4m -> dst_buf ; <S2SV_EndBug> <S2SV_StartBug> _img -> planes [ PLANE_U ] = _y4m -> dst_buf + pic_sz ; <S2SV_EndBug> <S2SV_StartBug> _img -> planes [ PLANE_V ] = _y4m -> dst_buf + pic_sz + c_sz ; <S2SV_EndBug> <S2SV_StartBug> _img -> planes [ PLANE_ALPHA ] = _y4m -> dst_buf + pic_sz + 2 * c_sz ; <S2SV_EndBug> ,<S2SV_ModStart> ; int bytes_per_sample = _y4m -> bit_depth > 8 ? 2 : 1 <S2SV_ModStart> bps <S2SV_ModEnd> <S2SV_ModStart> * bytes_per_sample <S2SV_ModStart> c_w *= bytes_per_sample ; <S2SV_ModStart> VPX_PLANE_Y <S2SV_ModEnd> <S2SV_ModStart> VPX_PLANE_ALPHA ] = <S2SV_ModEnd> <S2SV_ModStart> * bytes_per_sample <S2SV_ModStart> VPX_PLANE_U <S2SV_ModEnd> <S2SV_ModStart> VPX_PLANE_V <S2SV_ModEnd> <S2SV_ModStart> VPX_PLANE_Y <S2SV_ModEnd> <S2SV_ModStart> VPX_PLANE_U <S2SV_ModEnd> <S2SV_ModStart> VPX_PLANE_V <S2SV_ModEnd> <S2SV_ModStart> VPX_PLANE_ALPHA <S2SV_ModEnd> 
4240,"<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_lock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4241,"<S2SV_StartBug> ( void ) CopyMagickMemory ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> 
4242,"<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_lock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4243,"<S2SV_StartBug> WORD32 i ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < BUF_MGR_MAX_CNT ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , i , BUF_MGR_REF ) ; <S2SV_EndBug> ","<S2SV_ModStart> , j <S2SV_ModStart> j = 0 ; j < ps_codec -> i4_max_dpb_size ; j <S2SV_ModEnd> <S2SV_ModStart> j <S2SV_ModEnd> "
4244,<S2SV_StartBug> sraSpanRemove ( sraSpan * span ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> span ) { if ( <S2SV_ModStart> } 
4245,<S2SV_StartBug> prog [ N ] . pred = NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! N ) { ret = - EINVAL ; parse_error ( pe , FILT_ERR_NO_FILTER , ptr - str ) ; goto out_free ; } "
4246,<S2SV_StartBug> return ret ; <S2SV_EndBug> <S2SV_StartBug> if ( s -> ref ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( ret == 1 ) { ret = AVERROR_INVALIDDATA ; goto fail ; } <S2SV_ModStart>  <S2SV_ModEnd> 
4247,"<S2SV_StartBug> nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { <S2SV_EndBug> <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug> ",<S2SV_ModStart> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
4248,<S2SV_StartBug> static inline __u32 dccp_v6_init_sequence ( struct sk_buff * skb ) <S2SV_EndBug> ,<S2SV_ModStart> __u64 <S2SV_ModEnd> 
4249,<S2SV_StartBug> task -> tk_priority = task_setup_data -> priority - RPC_PRIORITY_LOW ; <S2SV_EndBug> ,<S2SV_ModStart> tk_rebind_retry = 2 ; task -> 
4250,"<S2SV_StartBug> expr_ty returns ; <S2SV_EndBug> <S2SV_StartBug> * out = FunctionDef ( name , args , body , decorator_list , returns , lineno , <S2SV_EndBug> <S2SV_StartBug> expr_ty returns ; <S2SV_EndBug> <S2SV_StartBug> * out = AsyncFunctionDef ( name , args , body , decorator_list , returns , <S2SV_EndBug> <S2SV_StartBug> lineno , col_offset , end_lineno , end_col_offset , <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_LookupAttrId ( obj , & PyId_targets , & tmp ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> * out = Assign ( targets , value , lineno , col_offset , end_lineno , <S2SV_EndBug> <S2SV_StartBug> asdl_seq * orelse ; <S2SV_EndBug> <S2SV_StartBug> * out = For ( target , iter , body , orelse , lineno , col_offset , end_lineno , <S2SV_EndBug> <S2SV_StartBug> asdl_seq * orelse ; <S2SV_EndBug> <S2SV_StartBug> * out = AsyncFor ( target , iter , body , orelse , lineno , col_offset , <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_LookupAttrId ( obj , & PyId_items , & tmp ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> * out = With ( items , body , lineno , col_offset , end_lineno , <S2SV_EndBug> <S2SV_StartBug> asdl_seq * body ; <S2SV_EndBug> <S2SV_StartBug> * out = AsyncWith ( items , body , lineno , col_offset , end_lineno , <S2SV_EndBug> ","<S2SV_ModStart> ; string type_comment <S2SV_ModStart> if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> type_comment , <S2SV_ModStart> ; string type_comment <S2SV_ModStart> if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> type_comment , <S2SV_ModStart> string type_comment ; <S2SV_ModStart> if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> type_comment , <S2SV_ModStart> ; string type_comment <S2SV_ModStart> if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> type_comment , <S2SV_ModStart> ; string type_comment <S2SV_ModStart> if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> type_comment , <S2SV_ModStart> string type_comment ; <S2SV_ModStart> if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> , type_comment <S2SV_ModStart> ; string type_comment <S2SV_ModStart> if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> type_comment , "
4251,<S2SV_StartBug> if ( s -> width != avctx -> width && s -> height != avctx -> height ) { <S2SV_EndBug> ,<S2SV_ModStart> || <S2SV_ModEnd> 
4252,<S2SV_StartBug> struct list_head tmplist ; <S2SV_EndBug> <S2SV_StartBug> if ( oldsp -> do_auto_asconf ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sctp_copy_descendant <S2SV_ModEnd> 
4253,"<S2SV_StartBug> struct snd_ctl_elem_id id ; <S2SV_EndBug> <S2SV_StartBug> up_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> for ( idx = 0 ; idx < kcontrol -> count ; idx ++ , id . index ++ , id . numid ++ ) <S2SV_EndBug> ",<S2SV_ModStart> ; unsigned int count <S2SV_ModStart> count = kcontrol -> count ; <S2SV_ModStart>  <S2SV_ModEnd> 
4254,"<S2SV_StartBug> if ( nelements == 0 ) { <S2SV_EndBug> <S2SV_StartBug> DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\n"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , <S2SV_EndBug> ","<S2SV_ModStart> > CDF_ELEMENT_LIMIT || nelements <S2SV_ModStart> ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4255,<S2SV_StartBug> disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( ( ( how & UMOUNT_CONNECTED ) && mnt_has_parent ( p ) && ( p -> mnt_parent -> mnt . mnt_flags & MNT_UMOUNT ) ) || <S2SV_ModStart> ) 
4256,"<S2SV_StartBug> uint16_t numChannels , chansSpecified , chanMask = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( numChannels < chansSpecified || numChannels < 1 ) { <S2SV_EndBug> <S2SV_StartBug> total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; <S2SV_EndBug> ","<S2SV_ModStart> = 0 <S2SV_ModStart> || numChannels > 256 <S2SV_ModStart> if ( ! config -> num_channels ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } "
4257,"<S2SV_StartBug> BIGNUM a , c , d , e ; <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> BN_bntest_rand ( & a , 40 + i * 10 , 0 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> a . neg = rand_neg ( ) ; <S2SV_EndBug> <S2SV_StartBug> BN_sqr ( & c , & a , ctx ) ; <S2SV_EndBug> <S2SV_StartBug> BN_print ( bp , & a ) ; <S2SV_EndBug> <S2SV_StartBug> BN_print ( bp , & a ) ; <S2SV_EndBug> <S2SV_StartBug> BN_print ( bp , & c ) ; <S2SV_EndBug> <S2SV_StartBug> BN_div ( & d , & e , & c , & a , ctx ) ; <S2SV_EndBug> <S2SV_StartBug> BN_sub ( & d , & d , & a ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! BN_is_zero ( & d ) || ! BN_is_zero ( & e ) ) <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed!\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> * a , * c , * d , * <S2SV_ModEnd> <S2SV_ModStart> , ret = 0 ; a = BN_new ( ) ; c = BN_new ( ) ; d = BN_new ( ) ; e = BN_new ( ) ; if ( a == NULL || c == NULL || d == NULL || e == NULL ) { goto err ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> c , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> d , e , c , <S2SV_ModEnd> <S2SV_ModStart> d , d , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> e ) ) { fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed!\\n"" ) ; goto err ; } } BN_hex2bn ( & a , ""80000000000000008000000000000001FFFFFFFFFFFFFFFE0000000000000000"" ) ; BN_sqr ( c , a , ctx ) ; if ( bp != NULL ) { if ( ! results ) { BN_print ( bp , a ) ; BIO_puts ( bp , ""<S2SV_blank>*<S2SV_blank>"" ) ; BN_print ( bp , a ) ; BIO_puts ( bp , ""<S2SV_blank>-<S2SV_blank>"" ) ; } BN_print ( bp , c ) ; BIO_puts ( bp , ""\\n"" ) ; } BN_mul ( d , a , a , ctx ) ; if ( BN_cmp ( c , d <S2SV_ModEnd> <S2SV_ModStart> ""Square<S2SV_blank>test<S2SV_blank>failed:<S2SV_blank>BN_sqr<S2SV_blank>and<S2SV_blank>BN_mul<S2SV_blank>produce<S2SV_blank>"" ""different<S2SV_blank>results!\\n"" ) ; goto err ; } BN_hex2bn ( & a , ""80000000000000000000000080000001FFFFFFFE000000000000000000000000"" ) ; BN_sqr ( c , a , ctx ) ; if ( bp != NULL ) { if ( ! results ) { BN_print ( bp , a ) ; BIO_puts ( bp , ""<S2SV_blank>*<S2SV_blank>"" ) ; BN_print ( bp , a ) ; BIO_puts ( bp , ""<S2SV_blank>-<S2SV_blank>"" ) ; } BN_print ( bp , c ) ; BIO_puts ( bp , ""\\n"" ) ; } BN_mul ( d , a , a , ctx ) ; if ( BN_cmp ( c , d ) ) { fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed:<S2SV_blank>BN_sqr<S2SV_blank>and<S2SV_blank>BN_mul<S2SV_blank>produce<S2SV_blank>"" ""different<S2SV_blank>results!\\n"" ) ; goto err ; } ret = 1 ; err : if ( a != NULL ) BN_free ( a ) ; if ( c != NULL ) BN_free ( c ) ; if ( d != NULL ) BN_free ( d ) ; if ( e != NULL ) BN_free ( e <S2SV_ModEnd> <S2SV_ModStart> ret <S2SV_ModEnd> "
4258,"<S2SV_StartBug> ptime -> day % 32 , short_months [ ( ptime -> month - 1 ) % 12 ] , <S2SV_EndBug> <S2SV_StartBug> ptime -> day % 32 , short_months [ ( ptime -> month - 1 ) % 12 ] , <S2SV_EndBug> <S2SV_StartBug> ptime -> day % 32 , short_months [ ( ptime -> month - 1 ) % 12 ] , <S2SV_EndBug> ",<S2SV_ModStart> 1U <S2SV_ModEnd> <S2SV_ModStart> 1U <S2SV_ModEnd> <S2SV_ModStart> 1U <S2SV_ModEnd> 
4259,<S2SV_StartBug> if ( verify_vc_kbmode ( fd_d ) < 0 ) <S2SV_EndBug> ,<S2SV_ModStart> vt_verify_kbmode <S2SV_ModEnd> 
4260,<S2SV_StartBug> if ( rdf_parser -> uri_filter ) <S2SV_EndBug> ,"<S2SV_ModStart> raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ; "
4261,<S2SV_StartBug> fpm_globals . max_requests = wp -> config -> pm_max_requests ; <S2SV_EndBug> ,<S2SV_ModStart> ; fpm_globals . listening_socket = dup ( wp -> listening_socket ) 
4262,<S2SV_StartBug> goto retry ; <S2SV_EndBug> ,"<S2SV_ModStart> err = fuse_verify_ioctl_iov ( in_iov , in_iovs ) ; if ( err ) goto out ; err = fuse_verify_ioctl_iov ( out_iov , out_iovs ) ; if ( err ) goto out ; "
4263,"<S2SV_StartBug> fprintf ( file , ""<S2SV_blank>%s=\\""%s\\"""" , tag -> bit_name , tag -> bit_val ) ; <S2SV_EndBug> ","<S2SV_ModStart> fputc ( '<S2SV_blank>' , file ) ; fputs ( <S2SV_ModEnd> <S2SV_ModStart> file ) ; fputc ( '=' , file ) ; save_quoted ( <S2SV_ModStart> , file "
4264,"<S2SV_StartBug> for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> <S2SV_StartBug> if ( vdaux < 1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> ",<S2SV_ModStart> end - <S2SV_ModStart> > i <S2SV_ModEnd> <S2SV_ModStart> || ( char * ) UINTPTR_MAX - vstart < vdaux <S2SV_ModStart> end - vstart < <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> end - vstart < <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4265,<S2SV_StartBug> next_input = input + i * input_incr ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> ip = next_opcode ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; next_input = input + i * input_incr <S2SV_ModStart> bytes_matched = yr_min ( bytes_matched , max_bytes_matched ) ; "
4266,<S2SV_StartBug> random_ether_addr ( dev -> dev_addr ) ; <S2SV_EndBug> ,<S2SV_ModStart> dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; 
4267,"<S2SV_StartBug> near_sad [ 1 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - 16 , xd -> dst . y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 0 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 , xd -> dst . y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 0 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 , xd -> dst . y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 1 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - 16 , xd -> dst . y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 2 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 - 16 , xd -> dst . y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 4 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer - pre_y_stride * 16 , pre_y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 5 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer - 16 , pre_y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 3 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer , pre_y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 6 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer + 16 , pre_y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 7 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer + pre_y_stride * 16 , pre_y_stride , UINT_MAX ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4268,<S2SV_StartBug> out_dqrele : <S2SV_EndBug> ,"<S2SV_ModStart> xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ; "
4269,<S2SV_StartBug> static void parse_input ( h2o_http2_conn_t * conn ) <S2SV_EndBug> <S2SV_StartBug> close_connection ( conn ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModStart> return 0 ; 
4270,"<S2SV_StartBug> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , <S2SV_EndBug> <S2SV_StartBug> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , <S2SV_EndBug> <S2SV_StartBug> data + offset , <S2SV_EndBug> ","<S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> offset , data_size - "
4271,"<S2SV_StartBug> if ( ! av_strstart ( proto_name , ""http"" , NULL ) && ! av_strstart ( proto_name , ""file"" , NULL ) ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""file"" , NULL ) ) { if ( strcmp ( c -> allowed_extensions , ""ALL"" ) && ! av_match_ext ( url , c -> allowed_extensions ) ) { av_log ( s , AV_LOG_ERROR , ""Filename<S2SV_blank>extension<S2SV_blank>of<S2SV_blank>\\\'%s\\\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>common<S2SV_blank>multimedia<S2SV_blank>extension,<S2SV_blank>blocked<S2SV_blank>for<S2SV_blank>security<S2SV_blank>reasons.\\n"" ""If<S2SV_blank>you<S2SV_blank>wish<S2SV_blank>to<S2SV_blank>override<S2SV_blank>this<S2SV_blank>adjust<S2SV_blank>allowed_extensions,<S2SV_blank>you<S2SV_blank>can<S2SV_blank>set<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\\\'ALL\\\'<S2SV_blank>to<S2SV_blank>allow<S2SV_blank>all\\n"" , url ) ; return AVERROR_INVALIDDATA ; } } else if ( av_strstart ( proto_name , <S2SV_ModStart> ) { ; } else <S2SV_ModEnd> "
4272,<S2SV_StartBug> while ( buflen > 0 ) { <S2SV_EndBug> <S2SV_StartBug> return union_desc ; <S2SV_EndBug> ,"<S2SV_ModStart> >= sizeof ( * union_desc ) ) { union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bLength > buflen ) { dev_err ( & intf -> dev , ""Too<S2SV_blank>large<S2SV_blank>descriptor\\n"" ) ; return NULL ; } <S2SV_ModEnd> <S2SV_ModStart> if ( union_desc -> bLength >= sizeof ( * union_desc ) ) return union_desc ; dev_err ( & intf -> dev , ""Union<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>short<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%zd\\n)"" , union_desc -> bLength , sizeof ( * union_desc ) ) ; return NULL <S2SV_ModEnd> "
4273,"<S2SV_StartBug> i += 2 ; <S2SV_EndBug> <S2SV_StartBug> ( i + 2 == NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == COMMA ) ) { <S2SV_EndBug> <S2SV_StartBug> res = handle_keywordonly_args ( c , n , i , <S2SV_EndBug> <S2SV_StartBug> i += 3 ; <S2SV_EndBug> <S2SV_StartBug> i += 3 ; <S2SV_EndBug> ","<S2SV_ModStart> 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 <S2SV_ModEnd> <S2SV_ModStart> ( <S2SV_ModStart> || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) <S2SV_ModStart> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { ast_error ( c , CHILD ( n , i ) , ""bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment"" ) ; return NULL ; } <S2SV_ModStart> 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; if ( ! vararg -> type_comment ) return NULL ; i += 1 ; } <S2SV_ModEnd> <S2SV_ModStart> 2 ; if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) return NULL ; i += 1 <S2SV_ModEnd> "
4274,<S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> { tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ; <S2SV_ModStart> } 
4275,<S2SV_StartBug> ASSERT ( redir_index < IOAPIC_NUM_PINS ) ; <S2SV_EndBug> <S2SV_StartBug> redir_content = ioapic -> redirtbl [ redir_index ] . bits ; <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; else redir_content = ~ 0ULL 
4276,"<S2SV_StartBug> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> 
4277,"<S2SV_StartBug> if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> goto out_errno ; <S2SV_EndBug> <S2SV_StartBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_default , <S2SV_EndBug> ","<S2SV_ModStart> error = fh_want_write ( fh ) ; if ( error ) <S2SV_ModEnd> <S2SV_ModStart> fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access <S2SV_ModEnd> <S2SV_ModStart> out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT <S2SV_ModEnd> <S2SV_ModStart> ) ; out_drop_lock : fh_unlock ( fh ) ; <S2SV_ModEnd> "
4278,<S2SV_StartBug> pvc . sap_family = AF_ATMPVC ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & pvc , 0 , sizeof ( pvc ) ) ; "
4279,<S2SV_StartBug> cancel_delayed_work_sync ( & ln -> grace_period_end ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4280,"<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_lock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4281,<S2SV_StartBug> kfree ( resp ) ; <S2SV_EndBug> ,<S2SV_ModStart> req ) ; kfree ( 
4282,"<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4283,"<S2SV_StartBug> netdev_dbg ( vif -> dev , ""Need<S2SV_blank>more<S2SV_blank>frags\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Too<S2SV_blank>many<S2SV_blank>frags\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Frags<S2SV_blank>galore\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\n"" , <S2SV_EndBug> <S2SV_StartBug> txp -> offset , txp -> size ) ; <S2SV_EndBug> ","<S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> netdev_err ( vif -> dev , ""Frag<S2SV_blank>is<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>frame.\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> <S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif "
4284,<S2SV_StartBug> const struct aodv_hello * ah ; <S2SV_EndBug> <S2SV_StartBug> goto trunc ; <S2SV_EndBug> ,"<S2SV_ModStart> ; ND_TCHECK ( * ep ) <S2SV_ModStart> if ( ep -> length < 4 ) { ND_PRINT ( ( ndo , ""\\n\\text<S2SV_blank>HELLO<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>length<S2SV_blank>%u"" , ep -> length ) ) ; break ; } "
4285,<S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock 
4286,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> DeleteCriticalSection ( & reference_queue_mutex ) ; 
4287,"<S2SV_StartBug> char * ksep , * vsep , * val ; <S2SV_EndBug> <S2SV_StartBug> vsep = memchr ( var -> ptr , '&' , var -> end - var -> ptr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! eof ) { <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ","<S2SV_ModStart> start , * <S2SV_ModStart> start = var -> ptr + var -> already_scanned ; <S2SV_ModStart> start <S2SV_ModEnd> <S2SV_ModStart> start <S2SV_ModEnd> <S2SV_ModStart> var -> already_scanned = var -> end - var -> ptr ; <S2SV_ModStart> var -> already_scanned = 0 ; "
4288,"<S2SV_StartBug> strncpy ( szSec , opt_string , sepIdx ) ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( szKey , sep , sepIdx ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( szVal , sep2 + 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( sepIdx >= sizeof ( szSec ) ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n"" , opt_string ) ; return ; } <S2SV_ModStart> if ( sepIdx >= sizeof ( szKey ) ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>key<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n"" , opt_string ) ; return ; } <S2SV_ModStart> if ( strlen ( <S2SV_ModEnd> <S2SV_ModStart> >= sizeof ( szVal ) ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>value<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n"" , opt_string ) ; return ; } strcpy ( szVal , sep2 + 1 ) "
4289,<S2SV_StartBug> out_put : <S2SV_EndBug> <S2SV_StartBug> return datagrams ; <S2SV_EndBug> <S2SV_StartBug> return datagrams ; <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( err == 0 ) goto out_put ; if ( datagrams <S2SV_ModEnd> <S2SV_ModStart> { datagrams = err ; goto out_put ; } <S2SV_ModEnd> <S2SV_ModStart> out_put : fput_light ( sock -> file , fput_needed ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
4290,<S2SV_StartBug> message -> srcIpAddr = queueItem -> srcIpAddr ; <S2SV_EndBug> ,<S2SV_ModStart> interface = queueItem -> interface ; message -> 
4291,"<S2SV_StartBug> int hns_nic_net_xmit_hw ( struct net_device * ndev , <S2SV_EndBug> <S2SV_StartBug> wmb ( ) ; <S2SV_EndBug> ",<S2SV_ModStart> netdev_tx_t <S2SV_ModEnd> <S2SV_ModStart> netif_trans_update ( ndev ) ; ndev -> stats . tx_bytes += skb -> len ; ndev -> stats . tx_packets ++ ; 
4292,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % stride ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horDiff8"" , ""%s"" , ""(cc%stride)!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; "
4293,"<S2SV_StartBug> vma_stop ( priv , vma ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! IS_ERR ( vma ) ) 
4294,"<S2SV_StartBug> if ( ! sock || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret > 0 ) <S2SV_EndBug> ","<S2SV_ModStart> size_t data_size = 0 ; <S2SV_ModStart> , & data_size <S2SV_ModStart> ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ( ssize_t ) ( data_size ) ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( ret > "
4295,"<S2SV_StartBug> slapi_pblock_get ( pb , SLAPI_PB_RESULT_TEXT , & pbtext ) ; <S2SV_EndBug> ",<S2SV_ModStart> SLAPI_RESULT_TEXT <S2SV_ModEnd> 
4296,"<S2SV_StartBug> if ( jas_init ( ) ) { <S2SV_EndBug> <S2SV_StartBug> infile = 0 ; <S2SV_EndBug> <S2SV_StartBug> case OPT_MAXMEM : <S2SV_EndBug> <S2SV_StartBug> if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( numcmpts = jas_image_numcmpts ( image ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) { <S2SV_EndBug> <S2SV_StartBug> printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n"" , fmtname , numcmpts , width , height , depth , ( long ) jas_image_rawsize ( image ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t max_samples ; char optstr [ 32 ] ; <S2SV_ModStart> max_samples = 64 * JAS_MEBI ; <S2SV_ModStart> OPT_MAXSAMPLES : max_samples = strtoull ( jas_optarg , 0 , 10 ) ; break ; case <S2SV_ModStart> snprintf ( optstr , sizeof ( optstr ) , ""max_samples=%-zu"" , max_samples ) ; <S2SV_ModStart> optstr <S2SV_ModEnd> <S2SV_ModStart> fmtname = jas_image_fmttostr ( fmtid ) ) ) { jas_eprintf ( ""format<S2SV_blank>name<S2SV_blank>lookup<S2SV_blank>failed\\n"" ) ; return EXIT_FAILURE ; } if ( ! ( <S2SV_ModStart> printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n"" , fmtname <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( long , <S2SV_ModEnd> <S2SV_ModStart> ) "
4297,"<S2SV_StartBug> static void update_state ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> const struct segmentation * const seg = & cm -> seg ; <S2SV_EndBug> <S2SV_StartBug> if ( seg -> enabled && output_enabled ) { <S2SV_EndBug> <S2SV_StartBug> vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) { <S2SV_EndBug> <S2SV_StartBug> mi_row , mi_col , bsize , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize < BLOCK_32X32 ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( x -> zcoeff_blk [ mbmi -> tx_size ] , ctx -> zcoeff_blk , <S2SV_EndBug> <S2SV_StartBug> sizeof ( uint8_t ) * ctx -> num_4x4_blk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) { <S2SV_EndBug> <S2SV_StartBug> vp9_update_mv_count ( cm , xd ) ; <S2SV_EndBug> <S2SV_StartBug> ++ cm -> counts . switchable_interp [ ctx ] [ mbmi -> interp_filter ] ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_comp_pred_diff [ SINGLE_REFERENCE ] += ctx -> single_pred_diff ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_comp_pred_diff [ COMPOUND_REFERENCE ] += ctx -> comp_pred_diff ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_comp_pred_diff [ REFERENCE_MODE_SELECT ] += ctx -> hybrid_pred_diff ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_filter_diff [ i ] += ctx -> best_filter_diff [ i ] ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , <S2SV_ModStart> RD_COUNTS * const rdc = & td -> rd_counts ; <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> ; const int bw = num_8x8_blocks_wide_lookup [ mi -> mbmi . sb_type ] ; const int bh = num_8x8_blocks_high_lookup [ mi -> mbmi . sb_type ] ; const int x_mis = MIN ( bw , cm -> mi_cols - mi_col ) ; const int y_mis = MIN ( bh , cm -> mi_rows - mi_row ) ; MV_REF * const frame_mvs = cm -> cur_frame -> mvs + mi_row * cm -> mi_cols + mi_col ; int w , h <S2SV_ModStart> * x -> mbmi_ext = ctx -> mbmi_ext ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_segment_id <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ctx -> rate , ctx -> dist , x -> skip <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> ctx -> zcoeff_blk [ 0 ] <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> td -> counts -> <S2SV_ModEnd> <S2SV_ModStart> rdc -> comp_pred_diff <S2SV_ModEnd> <S2SV_ModStart> rdc -> comp_pred_diff <S2SV_ModEnd> <S2SV_ModStart> rdc -> comp_pred_diff <S2SV_ModEnd> <S2SV_ModStart> rdc -> filter_diff <S2SV_ModEnd> <S2SV_ModStart> for ( h = 0 ; h < y_mis ; ++ h ) { MV_REF * const frame_mv = frame_mvs + h * cm -> mi_cols ; for ( w = 0 ; w < x_mis ; ++ w ) { MV_REF * const mv = frame_mv + w ; mv -> ref_frame [ 0 ] = mi -> mbmi . ref_frame [ 0 ] ; mv -> ref_frame [ 1 ] = mi -> mbmi . ref_frame [ 1 ] ; mv -> mv [ 0 ] . as_int = mi -> mbmi . mv [ 0 ] . as_int ; mv -> mv [ 1 ] . as_int = mi -> mbmi . mv [ 1 ] . as_int ; } } "
4298,"<S2SV_StartBug> int x , y , pos ; <S2SV_EndBug> <S2SV_StartBug> if ( gdImageGetPixel ( image , x , y ) == fg ) { <S2SV_EndBug> ","<S2SV_ModStart> _gdImageWBMPCtx <S2SV_ModEnd> <S2SV_ModStart> fg , out <S2SV_ModEnd> "
4299,"<S2SV_StartBug> oidc_util_get_request_parameter ( r , OIDC_REDIRECT_URI_REQUEST_LOGOUT , & url ) ; <S2SV_EndBug> <S2SV_StartBug> const char * error_description = NULL ; <S2SV_EndBug> <S2SV_StartBug> ""Malformed<S2SV_blank>URL"" , error_description , <S2SV_EndBug> ","<S2SV_ModStart> char * error_str = NULL ; char * error_description = NULL ; <S2SV_ModStart> if ( oidc_validate_post_logout_url ( r , url , & error_str , & error_description ) == FALSE ) { <S2SV_ModEnd> <S2SV_ModStart> error_str , error_description , HTTP_BAD_REQUEST <S2SV_ModEnd> "
4300,"<S2SV_StartBug> uint16 bitspersample , samplesperpixel = 1 ; <S2SV_EndBug> ",<S2SV_ModStart> = 1 
4301,"<S2SV_StartBug> int error ; <S2SV_EndBug> <S2SV_StartBug> error = pci_emul_add_msicap ( dev , PCI_EMUL_MSI_MSGS ) ; <S2SV_EndBug> <S2SV_StartBug> error = pci_emul_alloc_bar ( dev , 0 , PCIBAR_IO , DIOSZ ) ; <S2SV_EndBug> <S2SV_StartBug> error = pci_emul_alloc_bar ( dev , 1 , PCIBAR_MEM32 , DMEMSZ ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( error == 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4302,"<S2SV_StartBug> ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; <S2SV_EndBug> ",<S2SV_ModStart> ASN1_F_ASN1_ITEM_VERIFY <S2SV_ModEnd> 
4303,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } else if ( ctx -> might_cancel ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> spin_lock ( & ctx -> cancel_lock ) ; <S2SV_ModStart> { __timerfd_remove_cancel <S2SV_ModEnd> <S2SV_ModStart> spin_unlock ( & ctx -> cancel_lock ) ; 
4304,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> case EGRESS_VLAN_NAME : <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; * data && i < length ; i ++ , data ++ ) <S2SV_EndBug> ","<S2SV_ModStart> goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> goto trunc ; if ( * data ) ND_PRINT ( ( ndo , ""Tag[%u]<S2SV_blank>"" , * data ) ) ; else ND_PRINT ( ( ndo , ""Tag[Unused]<S2SV_blank>"" ) ) ; data ++ ; length -- ; } <S2SV_ModEnd> <S2SV_ModStart> if ( length < 1 ) goto trunc ; <S2SV_ModStart> i < length && * data <S2SV_ModEnd> "
4305,<S2SV_StartBug> as -> length + len * 2 + 1 ) == NULL ) <S2SV_EndBug> ,"<S2SV_ModStart> max ( <S2SV_ModStart> , ( size_t ) MB_CUR_MAX ) "
4306,"<S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( tm2interval ( tm , fsec , result ) != 0 ) <S2SV_EndBug> ","<S2SV_ModStart> > MAXDATELEN ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || ( DecodeInterval ( field , ftype , nf , & dtype , tm , & fsec ) != 0 && DecodeISO8601Interval ( str , & dtype , tm , & fsec ) != 0 ) ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ; if ( ! result ) return NULL ; if ( dtype != DTK_DELTA <S2SV_ModEnd> <S2SV_ModStart> free ( result ) ; return NULL ; } if ( tm2interval ( tm , fsec , result ) != 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4307,<S2SV_StartBug> sas_port_delete ( phy -> port ) ; <S2SV_EndBug> ,"<S2SV_ModStart> list_add_tail ( & phy -> port -> del_list , & parent -> port -> sas_port_del_list <S2SV_ModEnd> "
4308,"<S2SV_StartBug> log_err ( ctx , ""Cannot<S2SV_blank>define<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>a<S2SV_blank>keymap<S2SV_blank>file\\n"" , <S2SV_EndBug> <S2SV_StartBug> xkb_file_type_to_string ( file -> file_type ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( file -> file_type == FILE_TYPE_GEOMETRY ) { log_vrb ( ctx , 1 , ""Geometry<S2SV_blank>sections<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported;<S2SV_blank>ignoring\\n"" ) ; } else { <S2SV_ModStart> } "
4309,<S2SV_StartBug> vpx_scale_rtcd ( ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4310,"<S2SV_StartBug> static VALUE from_document ( VALUE klass , VALUE document ) <S2SV_EndBug> <S2SV_StartBug> Data_Get_Struct ( document , xmlDoc , doc ) ; <S2SV_EndBug> <S2SV_StartBug> doc = doc -> doc ; <S2SV_EndBug> <S2SV_StartBug> return rb_schema ; <S2SV_EndBug> ","<S2SV_ModStart> int argc , VALUE * argv , VALUE klass ) { VALUE document ; VALUE parse_options ; int parse_options_int ; <S2SV_ModEnd> <S2SV_ModStart> int scanned_args = 0 ; scanned_args = rb_scan_args ( argc , argv , ""11"" , & document , & parse_options ) ; <S2SV_ModStart> ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( ""ParseOptions"" ) ) , rb_intern ( ""DEFAULT_SCHEMA"" ) ) ; } parse_options_int = ( int ) NUM2INT ( rb_funcall ( parse_options , rb_intern ( ""to_i"" ) , 0 ) ) <S2SV_ModStart> rb_iv_set ( rb_schema , ""@parse_options"" , parse_options ) ; "
4311,<S2SV_StartBug> usb_unanchor_urb ( urb ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( urb ) ; usb_free_urb 
4312,"<S2SV_StartBug> int fd = accept ( socket -> fd , NULL , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
4313,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> list_for_each_entry ( event , & current -> perf_event_list , owner_entry ) <S2SV_EndBug> <S2SV_StartBug> perf_event_for_each_child ( event , perf_event_enable ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct perf_event_context * ctx ; <S2SV_ModStart> { ctx = perf_event_ctx_lock ( event ) ; <S2SV_ModStart> _perf_event_enable ) ; perf_event_ctx_unlock ( event , ctx ) ; } <S2SV_ModEnd> "
4314,<S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> <S2SV_StartBug> return get_desc_base ( desc ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_desc ( & desc , sel ) <S2SV_ModEnd> <S2SV_ModStart> & "
4315,"<S2SV_StartBug> if ( ( strchr ( cp , '/' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) { <S2SV_EndBug> ","<S2SV_ModStart> * cp == '\\0' || <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> ""."" ) == 0 || strcmp ( cp , <S2SV_ModStart>  <S2SV_ModEnd> "
4316,"<S2SV_StartBug> pfd . events = POLLIN ; <S2SV_EndBug> <S2SV_StartBug> len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len < 0 ) { <S2SV_EndBug> <S2SV_StartBug> syslog ( LOG_ERR , ""recv<S2SV_blank>failed;<S2SV_blank>error:%d"" , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; socklen_t addr_l = sizeof ( addr ) ; <S2SV_ModStart> recvfrom <S2SV_ModEnd> <S2SV_ModStart> , addr_p , & addr_l <S2SV_ModStart> || addr . nl_pid <S2SV_ModStart> ""recvfrom<S2SV_blank>failed;<S2SV_blank>pid:%u<S2SV_blank>error:%d<S2SV_blank>%s"" , addr . nl_pid , errno , strerror ( errno ) <S2SV_ModEnd> "
4317,"<S2SV_StartBug> gss_buffer_desc client_name , service_name ; <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> <S2SV_StartBug> exit_func : <S2SV_EndBug> ",<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : <S2SV_ModStart>  <S2SV_ModEnd> 
4318,<S2SV_StartBug> int data_len = elt -> length - <S2SV_EndBug> <S2SV_StartBug> sizeof ( struct oz_get_desc_rsp ) + 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> u16 offs , total_size ; u8 data_len ; if ( elt -> length < sizeof ( struct oz_get_desc_rsp ) - 1 ) break ; <S2SV_ModEnd> <S2SV_ModStart> ( <S2SV_ModStart> ) - 1 ) ; offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , ""USB_REQ_GET_DESCRIPTOR<S2SV_blank>-<S2SV_blank>cnf\\n"" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_SET_INTERFACE_RSP : { struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_VENDOR_CLASS_RSP : { struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp <S2SV_ModStart>  <S2SV_ModEnd> "
4319,"<S2SV_StartBug> struct nfs4_state_owner * sp , int flags , <S2SV_EndBug> <S2SV_StartBug> p -> o_arg . open_flags = flags , <S2SV_EndBug> ","<S2SV_ModStart> , fmode_t fmode <S2SV_ModStart> ; p -> o_arg . fmode = fmode & ( FMODE_READ | FMODE_WRITE ) ; <S2SV_ModEnd> "
4320,<S2SV_StartBug> int err = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( ! net_eq ( current -> nsproxy -> net_ns , sock_net ( sk ) ) ) return - EINVAL "
4321,"<S2SV_StartBug> struct page * pages [ NFS4ACL_MAXPAGES ] ; <S2SV_EndBug> <S2SV_StartBug> struct page * localpage = NULL ; <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> <S2SV_StartBug> if ( res . acl_len > args . acl_len ) <S2SV_EndBug> <S2SV_StartBug> nfs4_write_cached_acl ( inode , NULL , res . acl_len ) ; <S2SV_EndBug> <S2SV_StartBug> nfs4_write_cached_acl ( inode , resp_buf , res . acl_len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( res . acl_len > buflen ) <S2SV_EndBug> <S2SV_StartBug> if ( localpage ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( buf , resp_buf , res . acl_len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( localpage ) <S2SV_EndBug> <S2SV_StartBug> __free_page ( localpage ) ; <S2SV_EndBug> ","<S2SV_ModStart> = { NULL , } <S2SV_ModStart> int ret = - ENOMEM , npages , i , acl_len = 0 ; npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; if ( npages == 0 ) npages = 1 ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } if ( npages > 1 ) { args . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! args . acl_scratch ) goto out_free ; } args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; if ( buf <S2SV_ModEnd> <S2SV_ModStart> res . acl_flags |= NFS4_ACL_LEN_REQUEST ; resp_buf = page_address ( pages [ 0 ] ) ; dprintk ( ""%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%ld<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%ld\\n"" , __func__ , buf , buflen , npages , args . acl_len ) ; <S2SV_ModEnd> <S2SV_ModStart> acl_len = res . acl_len - res . acl_data_offset ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> + res . acl_data_offset , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> _copy_from_pages <S2SV_ModEnd> <S2SV_ModStart> pages , res . acl_data_offset , res . acl_len ) ; } ret = <S2SV_ModEnd> <S2SV_ModStart> for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] <S2SV_ModEnd> <S2SV_ModStart> pages [ i ] ) ; if ( args . acl_scratch ) __free_page ( args . acl_scratch <S2SV_ModEnd> "
4322,"<S2SV_StartBug> struct ip_options * opt ; <S2SV_EndBug> <S2SV_StartBug> opt = inet_sk ( sk ) -> opt ; <S2SV_EndBug> <S2SV_StartBug> if ( opt == NULL || opt -> cipso == 0 ) <S2SV_EndBug> <S2SV_StartBug> return cipso_v4_getattr ( opt -> __data + opt -> cipso - sizeof ( struct iphdr ) , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> int res = - ENOMSG ; rcu_read_lock ( ) ; opt = rcu_dereference ( <S2SV_ModEnd> <S2SV_ModStart> inet_opt ) <S2SV_ModEnd> <S2SV_ModStart> && opt -> opt . cipso ) res = <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> rcu_read_unlock ( ) ; return res ; 
4323,<S2SV_StartBug> replen = hdr . replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1 ; <S2SV_EndBug> <S2SV_StartBug> encode_nops ( & hdr ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> xdr_set_scratch_buffer ( xdr , page_address ( args -> acl_scratch ) , PAGE_SIZE ) ; "
4324,<S2SV_StartBug> char common_name [ FIELD_SIZE + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> FIELD_SIZE ) == 0 ) <S2SV_EndBug> ,<S2SV_ModStart> if ( validate_hostname ( <S2SV_ModEnd> <S2SV_ModStart> cert ) == MatchFound <S2SV_ModEnd> 
4325,<S2SV_StartBug> task -> tk_priority = task_setup_data -> priority - RPC_PRIORITY_LOW ; <S2SV_EndBug> ,<S2SV_ModStart> tk_rebind_retry = 2 ; task -> 
4326,<S2SV_StartBug> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ; <S2SV_EndBug> <S2SV_StartBug> if ( ses -> server -> sign ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> | NTLMSSP_NEGOTIATE_SEAL <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4327,"<S2SV_StartBug> vpx_memset ( & bsi , 0 , sizeof ( bsi ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> 
4328,<S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> ,<S2SV_ModStart> l > ( unsigned ) ( <S2SV_ModEnd> <S2SV_ModStart> - p ) <S2SV_ModStart> l > ( unsigned ) ( <S2SV_ModEnd> <S2SV_ModStart> - p ) <S2SV_ModStart> l > ( unsigned ) ( <S2SV_ModEnd> <S2SV_ModStart> - p ) <S2SV_ModStart> l > ( unsigned ) ( <S2SV_ModEnd> <S2SV_ModStart> - p ) 
4329,<S2SV_StartBug> vhost_net_ubuf_put_and_wait ( oldubufs ) ; <S2SV_EndBug> <S2SV_StartBug> vhost_net_ubuf_put_and_wait ( ubufs ) ; <S2SV_EndBug> ,<S2SV_ModStart> vhost_net_ubuf_put_wait_and_free <S2SV_ModEnd> <S2SV_ModStart> vhost_net_ubuf_put_wait_and_free <S2SV_ModEnd> 
4330,"<S2SV_StartBug> vpx_memset ( cpi -> active_map , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) { vp8_denoiser_free ( & cpi -> denoiser ) ; vp8_denoiser_allocate ( & cpi -> denoiser , width , height , cm -> mb_rows , cm -> mb_cols , cpi -> oxcf . noise_sensitivity ) ; } # endif "
4331,"<S2SV_StartBug> jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> jpc_iict ( tile -> tcomps [ 0 ] . data , tile -> tcomps [ 1 ] . data , <S2SV_EndBug> ","<S2SV_ModStart> ) ; return - 1 ; } if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\n"" <S2SV_ModStart> if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\n"" ) ; return - 1 ; } "
4332,<S2SV_StartBug> outpos += <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sendClean ( outputbuffer ) ; 
4333,<S2SV_StartBug> if ( class == - 1 ) { <S2SV_EndBug> ,"<S2SV_ModStart> || class == CLIENT_TYPE_MASTER ) { err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class:<S2SV_blank>the<S2SV_blank>user<S2SV_blank>specified<S2SV_blank>"" ""an<S2SV_blank>invalid<S2SV_blank>one,<S2SV_blank>or<S2SV_blank>\'master\'<S2SV_blank>which<S2SV_blank>has<S2SV_blank>no<S2SV_blank>buffer<S2SV_blank>limits."" <S2SV_ModEnd> "
4334,"<S2SV_StartBug> while ( * end_ptr != \'\\""\' && * end_ptr && ++ len ) if ( * end_ptr ++ == '\\\\' ) end_ptr ++ ; <S2SV_EndBug> ",<S2SV_ModStart> { <S2SV_ModStart> { if ( * end_ptr == '\\0' ) { return 0 ; } end_ptr ++ ; } } <S2SV_ModEnd> 
4335,"<S2SV_StartBug> sk_wait_data ( sk , & timeo , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) break ; 
4336,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( inode_capable ( inode , CAP_FOWNER ) ) <S2SV_EndBug> ","<S2SV_ModStart> struct user_namespace * ns ; <S2SV_ModStart> ns = current_user_ns ( ) ; if ( ns_capable ( ns , CAP_FOWNER ) && kuid_has_mapping ( ns , inode -> i_uid <S2SV_ModEnd> "
4337,<S2SV_StartBug> if ( ! fs_searchpaths ) <S2SV_EndBug> <S2SV_StartBug> for ( search = fs_searchpaths ; search ; search = search -> next ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> qboolean isLocalConfig ; <S2SV_ModStart> isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> if ( isLocalConfig && search -> pack ) continue ; "
4338,"<S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> assert ( profile < MAX_PROFILES ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , profile & 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , profile >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> switch ( profile ) { case PROFILE_0 : vpx_wb_write_literal ( wb , 0 , 2 ) ; break ; case PROFILE_1 : vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> 2 , 2 ) ; break ; case PROFILE_2 : vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> 1 , 2 ) ; break ; case PROFILE_3 : vpx_wb_write_literal ( wb , 6 , 3 ) ; break ; default : assert ( 0 <S2SV_ModEnd> <S2SV_ModStart> } "
4339,<S2SV_StartBug> if ( ! unconditional ( & e -> arp ) ) <S2SV_EndBug> ,<S2SV_ModStart> e <S2SV_ModEnd> 
4340,<S2SV_StartBug> struct IGDdatas * datas = ( struct IGDdatas * ) d ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( l >= MINIUPNPC_URL_MAXSIZE ) l = MINIUPNPC_URL_MAXSIZE - 1 
4341,"<S2SV_StartBug> if ( PyDict_SetItemString ( d , ""mod"" , ( PyObject * ) mod_type ) < 0 ) return NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( PyDict_SetItemString ( d , ""Suite"" , ( PyObject * ) Suite_type ) < 0 ) return <S2SV_EndBug> <S2SV_StartBug> if ( PyDict_SetItemString ( d , ""withitem"" , ( PyObject * ) withitem_type ) < 0 ) <S2SV_EndBug> ","<S2SV_ModStart> PyModule_AddIntMacro ( m , PyCF_TYPE_COMMENTS ) < 0 ) return NULL ; if ( <S2SV_ModStart> ""FunctionType"" , ( PyObject * ) FunctionType_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , <S2SV_ModStart> ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""type_ignore"" , ( PyObject * ) type_ignore_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""TypeIgnore"" , ( PyObject * ) TypeIgnore_type "
4342,"<S2SV_StartBug> l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ; <S2SV_EndBug> <S2SV_StartBug> opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ; 
4343,"<S2SV_StartBug> L3 = emitjump ( J , F , OP_JUMP ) ; <S2SV_EndBug> ","<S2SV_ModStart> emit ( J , F , OP_ENDTRY ) ; "
4344,"<S2SV_StartBug> unsigned int depth ) { <S2SV_EndBug> <S2SV_StartBug> unsigned int i ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_alloc_frame_buffer ( & ctx -> buf [ i ] . img , <S2SV_EndBug> <S2SV_StartBug> VP9_ENC_BORDER_IN_PIXELS ) ) <S2SV_EndBug> ","<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif <S2SV_ModStart> const int legacy_byte_alignment = 0 ; <S2SV_ModStart> vpx_alloc_frame_buffer <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , legacy_byte_alignment <S2SV_ModEnd> "
4345,<S2SV_StartBug> if ( err ) <S2SV_EndBug> <S2SV_StartBug> goto err_cqwq ; <S2SV_EndBug> ,<S2SV_ModStart> { kvfree ( in ) ; <S2SV_ModStart> } 
4346,<S2SV_StartBug> if ( ! mp -> ports && ! mp -> mglist && <S2SV_EndBug> ,<S2SV_ModStart> mp -> timer_armed && 
4347,"<S2SV_StartBug> static ext4_io_end_t * ext4_init_io_end ( struct inode * inode ) <S2SV_EndBug> <S2SV_StartBug> io = kmalloc ( sizeof ( * io ) , GFP_NOFS ) ; <S2SV_EndBug> <S2SV_StartBug> io -> error = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> , gfp_t flags <S2SV_ModStart> flags <S2SV_ModEnd> <S2SV_ModStart> page = NULL <S2SV_ModEnd> "
4348,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( _TIFFReadEncodedStripAndAllocBuffer ( tif , <S2SV_EndBug> <S2SV_StartBug> ( ( row + img -> row_offset ) % rowsperstrip + nrowsub ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> ","<S2SV_ModStart> uint32 temp ; <S2SV_ModStart> temp = ( row + img -> row_offset ) % rowsperstrip + nrowsub ; if ( scanline > 0 && temp > ( size_t ) ( TIFF_TMSIZE_T_MAX / scanline ) ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , ""Integer<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>gtStripContig"" ) ; return 0 ; } <S2SV_ModStart> temp <S2SV_ModEnd> "
4349,<S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4350,"<S2SV_StartBug> int copied , error = - EINVAL ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
4351,<S2SV_StartBug> if ( count >= 4 ) { <S2SV_EndBug> ,<S2SV_ModStart> > <S2SV_ModEnd> 
4352,"<S2SV_StartBug> const int pw = 4 * num_4x4_blocks_wide_lookup [ bsize ] ; <S2SV_EndBug> <S2SV_StartBug> uint8_t * second_pred = vpx_memalign ( 16 , pw * ph * sizeof ( uint8_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> const InterpKernel * kernel = vp9_get_interp_kernel ( mbmi -> interp_filter ) ; <S2SV_EndBug> <S2SV_StartBug> struct buf_2d scaled_first_yv12 = xd -> plane [ 0 ] . pre [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> for ( ref = 0 ; ref < 2 ; ++ ref ) { <S2SV_EndBug> <S2SV_StartBug> ref_mv [ ref ] = mbmi -> ref_mvs [ refs [ ref ] ] [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> for ( ite = 0 ; ite < 4 ; ite ++ ) { <S2SV_EndBug> <S2SV_StartBug> int_mv tmp_mv ; <S2SV_EndBug> <S2SV_StartBug> vp9_build_inter_predictor ( ref_yv12 [ ! id ] . buf , <S2SV_EndBug> <S2SV_StartBug> & xd -> block_refs [ ! id ] -> sf , <S2SV_EndBug> <S2SV_StartBug> tmp_mv . as_int = frame_mv [ refs [ id ] ] . as_int ; <S2SV_EndBug> <S2SV_StartBug> tmp_mv . as_mv . row >>= 3 ; <S2SV_EndBug> <S2SV_StartBug> bestsme = vp9_refining_search_8p_c ( x , & tmp_mv . as_mv , sadpb , <S2SV_EndBug> <S2SV_StartBug> bestsme = vp9_get_mvpred_av_var ( x , & tmp_mv . as_mv , & ref_mv [ id ] . as_mv , <S2SV_EndBug> <S2SV_StartBug> bestsme = cpi -> find_fractional_mv_step_comp ( <S2SV_EndBug> <S2SV_StartBug> x , & tmp_mv . as_mv , <S2SV_EndBug> <S2SV_StartBug> & ref_mv [ id ] . as_mv , <S2SV_EndBug> <S2SV_StartBug> 0 , cpi -> sf . subpel_iters_per_step , <S2SV_EndBug> <S2SV_StartBug> xd -> plane [ 0 ] . pre [ 0 ] = scaled_first_yv12 ; <S2SV_EndBug> <S2SV_StartBug> frame_mv [ refs [ id ] ] . as_int = tmp_mv . as_int ; <S2SV_EndBug> <S2SV_StartBug> & mbmi -> ref_mvs [ refs [ ref ] ] [ 0 ] . as_mv , <S2SV_EndBug> <S2SV_StartBug> vpx_free ( second_pred ) ; <S2SV_EndBug> ","<S2SV_ModStart> VP9_COMMON * const cm = & cpi -> common ; const <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vp9_filter_kernels [ <S2SV_ModEnd> <S2SV_ModStart> ] ; struct scale_factors sf <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , second_pred_alloc_16 [ 64 * 64 ] ) ; uint8_t * second_pred ; # else DECLARE_ALIGNED ( 16 , uint8_t , second_pred [ 64 * 64 ] ) ; # endif <S2SV_ModStart> x -> mbmi_ext <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH vp9_setup_scale_factors_for_frame ( & sf , cm -> width , cm -> height , cm -> width , cm -> height , cm -> use_highbitdepth ) ; # else vp9_setup_scale_factors_for_frame ( & sf , cm -> width , cm -> height , cm -> width , cm -> height ) ; # endif <S2SV_ModStart> MV <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { second_pred = CONVERT_TO_BYTEPTR ( second_pred_alloc_16 ) ; vp9_highbd_build_inter_predictor ( ref_yv12 [ ! id ] . buf , ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE , xd -> bd ) ; } else { second_pred = ( uint8_t * ) second_pred_alloc_16 ; <S2SV_ModStart> sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ; } # else vp9_build_inter_predictor ( ref_yv12 [ ! id ] . buf , ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ; # endif if ( id ) xd -> <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> as_mv ; tmp_mv <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , sadpb , search_range , & cpi -> fn_ptr [ bsize ] , & ref_mv [ id ] <S2SV_ModStart> second_pred <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> find_fractional_mv_step <S2SV_ModEnd> <S2SV_ModStart> , & ref_mv [ id ] <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mv . subpel_iters_per_step , NULL , <S2SV_ModEnd> <S2SV_ModStart> ref_yv12 [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> as_mv = tmp_mv <S2SV_ModEnd> <S2SV_ModStart> x -> mbmi_ext <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4353,<S2SV_StartBug> if ( ( tot_len - offset - 4 ) < bodyLength ) { <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) ) 
4354,<S2SV_StartBug> v -> count = c ; <S2SV_EndBug> <S2SV_StartBug> if ( c > 0 ) <S2SV_EndBug> ,<S2SV_ModStart> log2_count <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4355,"<S2SV_StartBug> if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , <S2SV_EndBug> <S2SV_StartBug> if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , <S2SV_EndBug> ","<S2SV_ModStart> p_total_data_size , <S2SV_ModStart> p_total_data_size , "
4356,"<S2SV_StartBug> void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name ) <S2SV_EndBug> ",<S2SV_ModStart> static 
4357,<S2SV_StartBug> dst [ dst_byte_offset ] = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4358,"<S2SV_StartBug> ret = copy_to_user ( uattr , attr , usize ) ; <S2SV_EndBug> ",<S2SV_ModStart> attr -> size <S2SV_ModEnd> 
4359,<S2SV_StartBug> ulong tmp ; <S2SV_EndBug> ,<S2SV_ModStart> jas_ulong <S2SV_ModEnd> 
4360,<S2SV_StartBug> assert ( ops != NULL ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( error == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( error == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( error == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ops != NULL ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! ops ) { pr_warn ( ""No<S2SV_blank>driver<S2SV_blank>for<S2SV_blank>device<S2SV_blank>[%s]\\n"" , fi -> fi_name ) ; continue ; } <S2SV_ModEnd> <S2SV_ModStart> if ( error != 0 ) goto pci_emul_init_fail <S2SV_ModEnd> <S2SV_ModStart> if ( error != 0 ) goto pci_emul_init_fail <S2SV_ModEnd> <S2SV_ModStart> if ( error != 0 ) goto pci_emul_init_fail <S2SV_ModEnd> <S2SV_ModStart> if ( ! ops ) { pr_warn ( ""No<S2SV_blank>driver<S2SV_blank>for<S2SV_blank>device<S2SV_blank>[%s]\\n"" , fi -> fi_name ) ; continue ; } <S2SV_ModEnd> "
4361,"<S2SV_StartBug> BN_ULONG t1 , t2 ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
4362,"<S2SV_StartBug> for ( j = 0 ; j < len ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> av_log ( s , AV_LOG_DEBUG , ""%X"" , avio_r8 ( pb ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } 
4363,"
","
"
4364,<S2SV_StartBug> if ( ! ( ast -> sub_ctx = avformat_alloc_context ( ) ) ) <S2SV_EndBug> ,"<S2SV_ModStart> strcmp ( sub_demuxer -> name , ""srt"" ) && strcmp ( sub_demuxer -> name , ""ass"" ) ) goto error ; if ( "
4365,"<S2SV_StartBug> unsigned char * const seg_map = cpi -> segmentation_map ; <S2SV_EndBug> <S2SV_StartBug> const int apply_cyclic_refresh = apply_cyclic_refresh_bitrate ( cm , rc ) ; <S2SV_EndBug> <S2SV_StartBug> ( cpi -> svc . temporal_layer_id > 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_type == KEY_FRAME ) <S2SV_EndBug> <S2SV_StartBug> cr -> sb_index = 0 ; <S2SV_EndBug> <S2SV_StartBug> int i , block_count , bl_index , sb_rows , sb_cols , sbs_in_frame ; <S2SV_EndBug> <S2SV_StartBug> const float rate_ratio_qdelta = 2.0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_set_segdata ( seg , 1 , SEG_LVL_ALT_Q , qindex_delta ) ; <S2SV_EndBug> <S2SV_StartBug> sb_cols = ( cm -> mi_cols + MI_BLOCK_SIZE - 1 ) / MI_BLOCK_SIZE ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( cm -> current_video_frame == 0 ) cr -> low_content_avg = 0.0 <S2SV_ModStart> || ( cpi -> svc . spatial_layer_id > 0 ) ) { unsigned char * const seg_map = cpi -> segmentation_map ; memset <S2SV_ModEnd> <S2SV_ModStart> { memset ( cr -> last_coded_q_map , MAXQ , cm -> mi_rows * cm -> mi_cols * sizeof ( * cr -> last_coded_q_map ) ) ; <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> double q = vp9_convert_qindex_to_q ( cm -> base_qindex , cm -> bit_depth ) ; vpx_clear_system_state ( ) ; cr -> thresh_rate_sb = ( ( int64_t ) ( rc -> sb64_target_rate ) << 8 ) << 2 ; cr -> thresh_dist_sb = ( ( int64_t ) ( q * q ) ) << 2 ; vp9_enable_segmentation ( & cm -> seg ) ; vp9_clearall_segfeatures ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vp9_disable_segfeature ( seg , CR_SEGMENT_ID_BASE , SEG_LVL_ALT_Q ) ; vp9_enable_segfeature ( seg , CR_SEGMENT_ID_BOOST1 , SEG_LVL_ALT_Q ) ; vp9_enable_segfeature ( seg , CR_SEGMENT_ID_BOOST2 , SEG_LVL_ALT_Q ) ; qindex_delta = compute_deltaq ( cpi , cm -> base_qindex , cr -> rate_ratio_qdelta ) ; cr -> qindex_delta [ 1 ] = qindex_delta <S2SV_ModEnd> <S2SV_ModStart> CR_SEGMENT_ID_BOOST1 <S2SV_ModEnd> <S2SV_ModStart> qindex_delta = compute_deltaq ( cpi , cm -> base_qindex , MIN ( CR_MAX_RATE_TARGET_RATIO , 0.1 * cr -> rate_boost_fac * cr -> rate_ratio_qdelta ) ) ; cr -> qindex_delta [ 2 ] = qindex_delta ; vp9_set_segdata ( seg , CR_SEGMENT_ID_BOOST2 , SEG_LVL_ALT_Q , qindex_delta ) ; cyclic_refresh_update_map ( cpi ) <S2SV_ModEnd> "
4366,"<S2SV_StartBug> bitmap_zero ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPUS ) ; <S2SV_EndBug> ",<S2SV_ModStart> KVM_MAX_VCPU_ID <S2SV_ModEnd> 
4367,"<S2SV_StartBug> ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; <S2SV_EndBug> <S2SV_StartBug> quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_EndBug> ",<S2SV_ModStart> quantum_info = ( QuantumInfo * ) NULL ; <S2SV_ModStart> if ( quantum_info != ( QuantumInfo * ) NULL ) 
4368,<S2SV_StartBug> interface = intf -> cur_altsetting ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( interface -> desc . bNumEndpoints < 1 ) return - EINVAL 
4369,"<S2SV_StartBug> register u_int length = h -> len ; <S2SV_EndBug> <S2SV_StartBug> return ( chdlc_print ( ndo , p , length ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart> h -> len <S2SV_ModEnd> 
4370,<S2SV_StartBug> if ( block ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4371,"<S2SV_StartBug> hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset , <S2SV_EndBug> <S2SV_StartBug> hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset , <S2SV_EndBug> ",<S2SV_ModStart> if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) { err = - EIO ; goto out ; } <S2SV_ModStart> if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) { err = - EIO ; goto out ; } 
4372,"<S2SV_StartBug> dec -> xstart = siz -> xoff ; <S2SV_EndBug> <S2SV_StartBug> dec -> numtiles = dec -> numhtiles * dec -> numvtiles ; <S2SV_EndBug> <S2SV_StartBug> for ( tileno = 0 , tile = dec -> tiles ; tileno < dec -> numtiles ; ++ tileno , <S2SV_EndBug> ","<S2SV_ModStart> size_t size ; <S2SV_ModStart> if ( ! jas_safe_size_mul ( <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , & size <S2SV_ModEnd> <S2SV_ModStart> dec -> numtiles = size ; JAS_DBGLOG ( 10 , ( ""numtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numhtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numvtiles<S2SV_blank>=<S2SV_blank>%d;\\n"" , dec -> numtiles , dec -> numhtiles , dec -> numvtiles ) ) ; if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) { return - 1 ; } "
4373,<S2SV_StartBug> tfrc . tfrctx_x = hc -> tx_x ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & tfrc , 0 , sizeof ( tfrc ) ) ; "
4374,<S2SV_StartBug> assert ( addrsize <= LLDPD_MGMT_MAXADDRSIZE ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4375,"<S2SV_StartBug> if ( jp2_getuint16 ( in , & pclr -> numlutents ) || <S2SV_EndBug> ",<S2SV_ModStart> pclr -> bpc = 0 ; 
4376,<S2SV_StartBug> if ( item_num > 65536 ) { <S2SV_EndBug> ,<S2SV_ModStart> || item_num < 0 
4377,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""gnuplot<S2SV_blank>%s"" , cmdname ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""wgnuplot<S2SV_blank>%s"" , cmdname ) ; <S2SV_EndBug> ",<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> 
4378,"<S2SV_StartBug> dprintk ( 2 , ""vm_close<S2SV_blank>%p<S2SV_blank>[count=%d,vma=%08lx-%08lx]\\n"" , map , <S2SV_EndBug> ","<S2SV_ModStart> ""vm_close<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n"" <S2SV_ModEnd> "
4379,"<S2SV_StartBug> run_cmd ( int fd , ... ) <S2SV_EndBug> <S2SV_StartBug> char cmd [ 512 ] ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> strcpy ( cmd , EXEC ) ; <S2SV_EndBug> <S2SV_StartBug> fd_printf ( STDERR_FILENO , ""%s\\n"" , & cmd [ sizeof ( EXEC ) - 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> exit ( 42 ) ; <S2SV_EndBug> ","<S2SV_ModStart> const char * cmd , const char * args_extra <S2SV_ModEnd> <S2SV_ModStart> int argc ; char * argv [ RUNCMD_ARGS_MAX + 1 ] ; int r <S2SV_ModEnd> <S2SV_ModStart> argc = 0 ; r = split_quoted <S2SV_ModEnd> <S2SV_ModStart> & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , ""Cannot<S2SV_blank>parse<S2SV_blank>command\\n"" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } r = split_quoted ( args_extra , & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , ""Cannot<S2SV_blank>parse<S2SV_blank>extra<S2SV_blank>args\\n"" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } if ( argc < 1 ) { fd_printf ( STDERR_FILENO , ""No<S2SV_blank>command<S2SV_blank>given\\n"" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } argv [ argc ] = NULL ; fd_printf ( STDERR_FILENO , ""$<S2SV_blank>%s<S2SV_blank>%s\\n"" , cmd , args_extra ) ; establish_child_signal_handlers ( ) ; sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ; execvp ( argv [ 0 ] , argv ) ; <S2SV_ModEnd> <S2SV_ModStart> ""exec:<S2SV_blank>%s\\n"" , strerror ( errno ) <S2SV_ModEnd> <S2SV_ModStart> RUNCMD_EXEC_FAIL <S2SV_ModEnd> "
4380,<S2SV_StartBug> aio_free_ring ( ctx ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4381,"<S2SV_StartBug> if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { <S2SV_EndBug> ","<S2SV_ModStart> siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) { jas_eprintf ( ""all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\n"" ) ; return - 1 ; } if ( "
4382,"<S2SV_StartBug> char * driver_override , * old = pdev -> driver_override , * cp ; <S2SV_EndBug> <S2SV_StartBug> if ( strlen ( driver_override ) ) { <S2SV_EndBug> <S2SV_StartBug> kfree ( old ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> device_lock ( dev ) ; old = pdev -> driver_override ; <S2SV_ModStart> device_unlock ( dev ) ; 
4383,"<S2SV_StartBug> save_text_from_text_view ( GTK_TEXT_VIEW ( textview ) , item_name ) ; <S2SV_EndBug> ",<S2SV_ModStart> { <S2SV_ModStart> problem_data_reload_from_dump_dir ( ) ; update_gui_state_from_problem_data ( 0 ) ; } 
4384,<S2SV_StartBug> root_storage -> d_storage_uuid ) ) < 0 ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4385,"<S2SV_StartBug> & msg -> addrto , & msg -> ifindex ) ; <S2SV_EndBug> <S2SV_StartBug> dbg ( ndp , ""rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> str_in6_addr ( & msg -> addrto ) , msg -> ifindex ) ; <S2SV_EndBug> ","<S2SV_ModStart> , & msg -> hoplimit <S2SV_ModStart> ""rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u,<S2SV_blank>hoplimit:<S2SV_blank>%d"" <S2SV_ModEnd> <S2SV_ModStart> , msg -> hoplimit ) ; if ( msg -> hoplimit != 255 ) { warn ( ndp , ""ignoring<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>bad<S2SV_blank>hop<S2SV_blank>limit<S2SV_blank>(%d)"" , msg -> hoplimit ) ; err = 0 ; goto free_msg ; } <S2SV_ModEnd> "
4386,"<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> ret = xen_pcibk_read_config_word ( dev , offset , value , data ) ; <S2SV_EndBug> <S2SV_StartBug> * value |= PCI_COMMAND_IO ; <S2SV_EndBug> ",<S2SV_ModStart> ret = pci_read_config_word <S2SV_ModEnd> <S2SV_ModStart> ) ; const struct pci_cmd_info * cmd = data ; * value &= PCI_COMMAND_GUEST ; <S2SV_ModEnd> <S2SV_ModStart> cmd -> val & ~ PCI_COMMAND_GUEST ; <S2SV_ModEnd> 
4387,"<S2SV_StartBug> static MB_PREDICTION_MODE read_intra_mode ( vp9_reader * r , const vp9_prob * p ) { <S2SV_EndBug> <S2SV_StartBug> return ( MB_PREDICTION_MODE ) vp9_read_tree ( r , vp9_intra_mode_tree , p ) ; <S2SV_EndBug> ",<S2SV_ModStart> PREDICTION_MODE read_intra_mode ( vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE ) vpx_read_tree <S2SV_ModEnd> 
4388,<S2SV_StartBug> struct mlx5_ib_create_qp_resp resp ; <S2SV_EndBug> ,<S2SV_ModStart> = { } 
4389,"<S2SV_StartBug> vpx_memcpy ( x -> fc . ymode_prob , vp8_ymode_prob , sizeof ( vp8_ymode_prob ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( x -> fc . uv_mode_prob , vp8_uv_mode_prob , sizeof ( vp8_uv_mode_prob ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( x -> fc . sub_mv_ref_prob , sub_mv_ref_prob , sizeof ( sub_mv_ref_prob ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
4390,"<S2SV_StartBug> hlist_add_head ( & mp -> mglist , & br -> mglist ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( hlist_unhashed ( & mp -> mglist ) ) 
4391,"<S2SV_StartBug> if ( ( ret = av_image_check_size ( s -> width , s -> height , 0 , avctx ) ) < 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> ff_set_dimensions ( avctx , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4392,"<S2SV_StartBug> DPRINTF ( 4 , ( ""enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\'%s%s\'\\n"" , <S2SV_EndBug> <S2SV_StartBug> filegen_flag = filegen -> flag ; <S2SV_EndBug> ","<S2SV_ModStart> if ( NULL == filegen ) { msyslog ( LOG_ERR , ""stats<S2SV_blank>%s<S2SV_blank>unrecognized"" , filegen_string ) ; continue ; } <S2SV_ModStart> if ( NULL == filegen ) { msyslog ( LOG_ERR , ""filegen<S2SV_blank>category<S2SV_blank>\'%s\'<S2SV_blank>unrecognized"" , filegen_file ) ; continue ; } "
4393,<S2SV_StartBug> if ( ( flags & FOLL_WRITE ) && ! pte_write ( pte ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> can_follow_write_pte ( pte , flags <S2SV_ModEnd> "
4394,<S2SV_StartBug> kfree ( ubufs ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4395,"<S2SV_StartBug> static int read_intra_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd , <S2SV_EndBug> <S2SV_StartBug> struct segmentation * const seg = & cm -> seg ; <S2SV_EndBug> <S2SV_StartBug> if ( ! seg -> update_map ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ; <S2SV_EndBug> ","<S2SV_ModStart> int mi_offset , int x_mis , int y_mis , vpx_reader <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { copy_segment_id ( cm , cm -> last_frame_seg_map , cm -> current_frame_seg_map , mi_offset , x_mis , y_mis ) ; <S2SV_ModStart> } <S2SV_ModStart> mi_offset , x_mis , y_mis <S2SV_ModEnd> "
4396,"<S2SV_StartBug> ext2_xattr_cache_insert ( struct buffer_head * bh ) <S2SV_EndBug> <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_alloc ( ext2_xattr_cache , GFP_NOFS ) ; <S2SV_EndBug> <S2SV_StartBug> error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_free ( ce ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]<S2SV_blank>(%d<S2SV_blank>cache<S2SV_blank>entries)"" , ( int ) hash , <S2SV_EndBug> ","<S2SV_ModStart> struct mb2_cache * cache , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> error = mb2_cache_entry_create ( cache , GFP_NOFS , hash <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""inserting<S2SV_blank>[%x]"" <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> "
4397,"<S2SV_StartBug> # define COPY_PORT ( dest , src ) do { int i ; for ( i = 0 ; i < ARRAY_SIZE ( src -> read_urbs ) ; ++ i ) { dest -> read_urbs [ i ] = src -> read_urbs [ i ] ; dest -> read_urbs [ i ] -> context = dest ; dest -> bulk_in_buffers [ i ] = src -> bulk_in_buffers [ i ] ; } dest -> read_urb = src -> read_urb ; dest -> bulk_in_endpointAddress = src -> bulk_in_endpointAddress ; dest -> bulk_in_buffer = src -> bulk_in_buffer ; dest -> bulk_in_size = src -> bulk_in_size ; dest -> interrupt_in_urb = src -> interrupt_in_urb ; dest -> interrupt_in_urb -> context = dest ; dest -> interrupt_in_endpointAddress = src -> interrupt_in_endpointAddress ; dest -> interrupt_in_buffer = src -> interrupt_in_buffer ; } while ( 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( serial -> num_bulk_in < 2 || serial -> num_interrupt_in < 2 ) { dev_err ( & serial -> interface -> dev , ""missing<S2SV_blank>endpoints\\n"" ) ; return - ENODEV ; } "
4398,"<S2SV_StartBug> VP9_COMMON * const cm = & pbi -> common ; <S2SV_EndBug> <S2SV_StartBug> vp9_remove_common ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_free ( pbi -> lf_worker . data1 ) ; <S2SV_EndBug> <S2SV_StartBug> VP9Worker * const worker = & pbi -> tile_workers [ i ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_worker_end ( worker ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_free ( worker -> data1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_free ( worker -> data2 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( pbi -> num_tile_workers ) { <S2SV_EndBug> <S2SV_StartBug> vp9_loop_filter_dealloc ( & pbi -> lf_row_sync , sb_rows ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_get_worker_interface ( ) -> end <S2SV_ModEnd> <S2SV_ModStart> ) ; vpx_free ( pbi -> tile_data <S2SV_ModStart> VPxWorker <S2SV_ModEnd> <S2SV_ModStart> vpx_get_worker_interface ( ) -> end <S2SV_ModEnd> <S2SV_ModStart> } vpx_free ( pbi -> tile_worker_data <S2SV_ModEnd> <S2SV_ModStart> pbi -> tile_worker_info ) ; <S2SV_ModEnd> <S2SV_ModStart> > 0 ) { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4399,"<S2SV_StartBug> char * fpath = NULL , * cgdir = NULL , * controller ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""rmdir:<S2SV_blank>verifying<S2SV_blank>access<S2SV_blank>to<S2SV_blank>%s:%s<S2SV_blank>(req<S2SV_blank>path<S2SV_blank>%s)\\n"" , <S2SV_EndBug> <S2SV_StartBug> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! cgfs_remove ( controller , cgroup ) ) { <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> , * next = NULL <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> & next ) ) { if ( ! fpath || strcmp ( next , fpath ) == 0 ) ret = - EBUSY ; else ret = - ENOENT ; goto out ; } if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY <S2SV_ModEnd> <S2SV_ModStart> caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { ret = - EACCES ; goto out ; } if ( ! <S2SV_ModStart> free ( next ) ; "
4400,"<S2SV_StartBug> if ( dec -> ihdr -> data . ihdr . numcmpts != JAS_CAST ( uint , <S2SV_EndBug> <S2SV_StartBug> for ( i = 1 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> if ( dec -> bpcc -> data . bpcc . numcmpts != JAS_CAST ( uint , jas_image_numcmpts ( <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; <S2SV_EndBug> <S2SV_StartBug> JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dec -> cmap -> data . cmap . ents [ i ] . cmptno >= JAS_CAST ( uint , <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { <S2SV_EndBug> ",<S2SV_ModStart> jas_uint <S2SV_ModEnd> <S2SV_ModStart> jas_uint <S2SV_ModEnd> <S2SV_ModStart> jas_uint <S2SV_ModEnd> <S2SV_ModStart> jas_uint <S2SV_ModEnd> <S2SV_ModStart> jas_uint <S2SV_ModEnd> <S2SV_ModStart> jas_uint <S2SV_ModEnd> <S2SV_ModStart> jas_uint <S2SV_ModEnd> 
4401,"<S2SV_StartBug> return ( tsfb -> numlvls > 0 ) ? jpc_tsfb_synthesize2 ( tsfb , <S2SV_EndBug> ",<S2SV_ModStart> && jas_seq2d_size ( a ) 
4402,<S2SV_StartBug> spin_lock_init ( & port -> phy_list_lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> INIT_LIST_HEAD ( & port -> sas_port_del_list ) ; 
4403,<S2SV_StartBug> if ( ret || cm_id -> device -> node_type != RDMA_NODE_IB_CA ) <S2SV_EndBug> ,<S2SV_ModStart> ! cm_id -> device || 
4404,"<S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> ",<S2SV_ModStart> _dh <S2SV_ModEnd> 
4405,"<S2SV_StartBug> lua_pushvalue ( L , i ) ; <S2SV_EndBug> ","<S2SV_ModStart> luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_check"" ) ; "
4406,<S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> ,<S2SV_ModStart> pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> 
4407,<S2SV_StartBug> r = vapic_enter ( vcpu ) ; <S2SV_EndBug> <S2SV_StartBug> vapic_exit ( vcpu ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4408,"<S2SV_StartBug> guint pkt_len ; <S2SV_EndBug> <S2SV_StartBug> num_items_scanned = sscanf ( line + 64 , ""LEN=%9u"" , & pkt_len ) ; <S2SV_EndBug> <S2SV_StartBug> * err_info = g_strdup ( ""toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> int pkt_len , <S2SV_ModEnd> <S2SV_ModStart> ""LEN=%9d"" <S2SV_ModEnd> <S2SV_ModStart> ) ; return FALSE ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" "
4409,<S2SV_StartBug> struct llc_pktinfo info ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & info , 0 , sizeof ( info ) ) "
4410,"<S2SV_StartBug> unsigned int len ; <S2SV_EndBug> <S2SV_StartBug> struct au1200fb_device * fbdev = info -> par ; <S2SV_EndBug> <S2SV_StartBug> return io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vm_iomap_memory <S2SV_ModEnd> <S2SV_ModStart> fbdev -> fb_phys , fbdev -> fb_len <S2SV_ModEnd> "
4411,"<S2SV_StartBug> rpc_delay ( task , 3 * HZ ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( task -> tk_rebind_retry == 0 ) break ; task -> tk_rebind_retry -- ; 
4412,"<S2SV_StartBug> __mincore_unmapped_range ( addr , end , vma , vec ) ; <S2SV_EndBug> <S2SV_StartBug> __mincore_unmapped_range ( addr , addr + PAGE_SIZE , <S2SV_EndBug> <S2SV_StartBug> if ( non_swap_entry ( entry ) ) { <S2SV_EndBug> ","<S2SV_ModStart> memset ( vec , 1 , nr <S2SV_ModEnd> <S2SV_ModStart> * vec = 0 <S2SV_ModEnd> <S2SV_ModStart> * vec = ! ! <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> "
4413,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> rdp -> nego -> transport -> credssp = NULL ; 
4414,"<S2SV_StartBug> exfat_error ( ""exFAT<S2SV_blank>file<S2SV_blank>system<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits > 25 ) <S2SV_EndBug> ","<S2SV_ModStart> ) ; return - EIO ; } if ( ef -> sb -> sector_bits < 9 ) { exfat_close ( ef -> dev ) ; exfat_error ( ""too<S2SV_blank>small<S2SV_blank>sector<S2SV_blank>size:<S2SV_blank>2^%hhd"" , ef -> sb -> sector_bits ) ; free ( ef -> sb ) ; return - EIO ; } if ( ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits > 25 ) { exfat_close ( ef -> dev ) ; exfat_error ( ""too<S2SV_blank>big<S2SV_blank>cluster<S2SV_blank>size:<S2SV_blank>2^(%hhd+%hhd)"" , ef -> sb -> sector_bits , ef -> sb -> spc_bits ) ; free ( ef -> sb <S2SV_ModStart>  <S2SV_ModEnd> "
4415,"<S2SV_StartBug> exo_job_info_message ( EXO_JOB ( job ) , g_file_info_get_display_name ( info ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , "
4416,<S2SV_StartBug> if ( is_file_hugepages ( shm_file ) ) <S2SV_EndBug> ,<S2SV_ModStart> shm_file == NULL ) { err = - EIDRM ; goto out_unlock0 ; } if ( 
4417,<S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> ,<S2SV_ModStart> ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> 
4418,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & line , 0 , sizeof ( line ) ) ; "
4419,<S2SV_StartBug> if ( ! ( opt_len == 12 && flags & TH_SYN ) && <S2SV_EndBug> <S2SV_StartBug> ! ( opt_len == 24 && flags & TH_ACK ) ) <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) <S2SV_ModStart> ( <S2SV_ModStart> ) 
4420,<S2SV_StartBug> && ( ( ( packet -> payload [ 0 ] == 0x07 ) && ( packet -> payload [ 1 ] == 0xff ) && ( packet -> payload [ 2 ] == 0x00 ) ) <S2SV_EndBug> ,<S2SV_ModStart> payload_packet_len >= 3 && packet -> 
4421,"<S2SV_StartBug> strcpy ( the_url , url_arg ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! e ) strcpy ( the_url , gf_dm_sess_get_cache_name ( sess ) ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( the_url , ""MP4Client<S2SV_blank>"" GPAC_FULL_VERSION ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { fprintf ( stderr , ""Input<S2SV_blank>url<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>truncating<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>chars.\\n"" , url_arg , ( int ) ( sizeof ( the_url ) - 1 ) ) ; strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; } else { <S2SV_ModStart> } <S2SV_ModStart> { strncpy <S2SV_ModEnd> <S2SV_ModStart> , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; } <S2SV_ModEnd> <S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <S2SV_ModEnd> "
4422,<S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ; "
4423,"<S2SV_StartBug> int res ; <S2SV_EndBug> <S2SV_StartBug> const void * data ; <S2SV_EndBug> <S2SV_StartBug> u_int32_t vendor ; <S2SV_EndBug> <S2SV_StartBug> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""s"" , & data , & len ) == FAILURE ) { <S2SV_EndBug> <S2SV_StartBug> res = rad_get_vendor_attr ( & vendor , & data , ( size_t * ) & len ) ; <S2SV_EndBug> <S2SV_StartBug> add_assoc_long ( return_value , ""attr"" , res ) ; <S2SV_EndBug> <S2SV_StartBug> add_assoc_stringl ( return_value , ""data"" , ( char * ) data , len , 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , * raw <S2SV_ModStart> ; unsigned char type ; size_t data_len <S2SV_ModStart> raw <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> type , & data , & data_len , raw , len ) <S2SV_ModEnd> <S2SV_ModStart> type <S2SV_ModEnd> <S2SV_ModStart> data_len <S2SV_ModEnd> "
4424,"<S2SV_StartBug> sas_unregister_dev ( port , dev ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; sas_destruct_devices ( port 
4425,"<S2SV_StartBug> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> mark_key_instantiated ( key , 0 <S2SV_ModEnd> "
4426,"<S2SV_StartBug> static void rd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int mi_col , BLOCK_SIZE bsize , int * rate , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> int this_rate , sum_rate = 0 , best_rate = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> int partition_none_allowed = ! force_horz_split && ! force_vert_split ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> <S2SV_StartBug> num_8x8_blocks_high_lookup [ bsize ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize == BLOCK_16X16 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> partition_none_allowed &= ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> <S2SV_StartBug> partition_horz_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> <S2SV_StartBug> partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> <S2SV_StartBug> do_split &= bsize > cpi -> sf . min_partition_size ; <S2SV_EndBug> <S2SV_StartBug> save_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . disable_split_var_thresh && partition_none_allowed ) { <S2SV_EndBug> <S2SV_StartBug> if ( source_variancey < cpi -> sf . disable_split_var_thresh / 2 ) <S2SV_EndBug> <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , bsize , <S2SV_EndBug> <S2SV_StartBug> this_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ; <S2SV_EndBug> <S2SV_StartBug> int64_t stop_thresh = 4096 ; <S2SV_EndBug> <S2SV_StartBug> * ( get_sb_partitioning ( x , bsize ) ) = bsize ; <S2SV_EndBug> <S2SV_StartBug> stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> e_mbd . lossless && best_rd < stop_thresh_rd ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> in_active_map ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 4 && sum_rd < best_rd ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = i ; <S2SV_EndBug> <S2SV_StartBug> rd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , subsize , <S2SV_EndBug> <S2SV_StartBug> & this_rate , & this_dist , i != 3 , best_rd - sum_rd ) ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> <S2SV_StartBug> sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> <S2SV_StartBug> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( partition_horz_allowed && do_rect ) { <S2SV_EndBug> <S2SV_StartBug> subsize = get_subsize ( bsize , PARTITION_HORZ ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> pred_interp_filter = <S2SV_EndBug> <S2SV_StartBug> if ( sum_rd < best_rd && mi_row + mi_step < cm -> mi_rows ) { <S2SV_EndBug> <S2SV_StartBug> update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> pred_interp_filter = <S2SV_EndBug> <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row + mi_step , mi_col , & this_rate , <S2SV_EndBug> <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> <S2SV_StartBug> subsize = get_subsize ( bsize , PARTITION_VERT ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> pred_interp_filter = <S2SV_EndBug> <S2SV_StartBug> if ( sum_rd < best_rd && mi_col + mi_step < cm -> mi_cols ) { <S2SV_EndBug> <S2SV_StartBug> update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> pred_interp_filter = <S2SV_EndBug> <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col + mi_step , & this_rate , <S2SV_EndBug> <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> <S2SV_StartBug> if ( best_rate < INT_MAX && best_dist < INT64_MAX && do_recon ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) { <S2SV_EndBug> <S2SV_StartBug> best_rate ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( best_rate < INT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( best_dist < INT64_MAX ) ; <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> <S2SV_ModStart> int mi_col , <S2SV_ModEnd> <S2SV_ModStart> RD_COST * rd_cost , int64_t best_rd , PC_TREE * pc_tree <S2SV_ModEnd> <S2SV_ModStart> TileInfo * const tile_info = & tile_data -> tile_info ; <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> & pc_tree -> none <S2SV_ModEnd> <S2SV_ModStart> RD_COST this_rdc , sum_rdc , best_rdc <S2SV_ModEnd> <S2SV_ModStart> BLOCK_SIZE min_size = x -> min_partition_size ; BLOCK_SIZE max_size = x -> max_partition_size ; # if CONFIG_FP_MB_STATS unsigned int src_diff_var = UINT_MAX ; int none_complexity = 0 ; # endif <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; vp9_rd_cost_init ( & this_rdc ) ; vp9_rd_cost_init ( & sum_rdc ) ; vp9_rd_cost_reset ( & best_rdc ) ; best_rdc . rdcost = best_rd ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize <S2SV_ModStart> && cpi -> oxcf . aq_mode ) <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> sf . cb_partition_search && bsize == BLOCK_16X16 ) { int cb_partition_search_ctrl = ( ( pc_tree -> index == 0 || pc_tree -> index == 3 ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 ; if ( cb_partition_search_ctrl && bsize > min_size && bsize < max_size ) set_partition_range ( cm , xd , mi_row , mi_col , bsize , & min_size , & max_size <S2SV_ModEnd> <S2SV_ModStart> max_size && bsize >= min_size <S2SV_ModEnd> <S2SV_ModStart> max_size && bsize > min_size <S2SV_ModEnd> <S2SV_ModStart> max_size && bsize > min_size <S2SV_ModEnd> <S2SV_ModStart> min_size <S2SV_ModEnd> <S2SV_ModStart> x <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; src_diff_var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , bsize ) ; } # endif # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats && bsize >= BLOCK_32X32 && do_split && partition_none_allowed && src_diff_var > 4 && cm -> base_qindex < qindex_split_threshold_lookup [ bsize ] ) { int mb_row = mi_row >> 1 ; int mb_col = mi_col >> 1 ; int mb_row_end = MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ; int mb_col_end = MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ; int r , c ; for ( r = mb_row ; r < mb_row_end ; r ++ ) { for ( c = mb_col ; c < mb_col_end ; c ++ ) { const int mb_index = r * cm -> mb_cols + c ; MOTION_DIRECTION this_mv ; MOTION_DIRECTION right_mv ; MOTION_DIRECTION bottom_mv ; this_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index ] ) ; if ( c != mb_col_end - 1 ) { right_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + 1 ] ) ; none_complexity += get_motion_inconsistency ( this_mv , right_mv ) ; } if ( r != mb_row_end - 1 ) { bottom_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + cm -> mb_cols ] ) ; none_complexity += get_motion_inconsistency ( this_mv , bottom_mv ) ; } } } if ( none_complexity > complexity_16x16_blocks_threshold [ bsize ] ) { partition_none_allowed <S2SV_ModEnd> <S2SV_ModStart> } } # endif <S2SV_ModEnd> <S2SV_ModStart> tile_data , x , mi_row , mi_col , & this_rdc , bsize , ctx , best_rdc . rdcost ) ; if ( this_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> this_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> this_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> this_rdc . rate , this_rdc . dist ) ; } if ( this_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> dist_breakout_thr = cpi -> sf . partition_search_breakout_dist_thr ; int rate_breakout_thr = cpi -> sf . partition_search_breakout_rate_thr ; best_rdc = this_rdc <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> partitioning = PARTITION_NONE ; dist_breakout_thr <S2SV_ModEnd> <S2SV_ModStart> rate_breakout_thr *= num_pels_log2_lookup [ bsize ] ; if ( ! x -> e_mbd . lossless && ( ctx -> skippable && best_rdc . dist < dist_breakout_thr && best_rdc . rate < rate_breakout_thr ) ) { do_split = 0 ; do_rect = 0 ; } # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats && do_split != 0 && cm -> base_qindex > qindex_skip_threshold_lookup [ bsize ] ) { int mb_row = mi_row >> 1 ; int mb_col = mi_col >> 1 ; int mb_row_end = MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ; int mb_col_end = MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ; int r , c ; int skip = 1 ; for ( r = mb_row ; r < mb_row_end ; r ++ ) { for ( c = mb_col ; c < mb_col_end ; c ++ ) { const int mb_index = r * cm -> mb_cols + c <S2SV_ModEnd> <S2SV_ModStart> ( cpi -> twopass . this_frame_mb_stats [ mb_index ] & FPMB_MOTION_ZERO_MASK ) || ! ( cpi -> twopass . this_frame_mb_stats [ mb_index ] & FPMB_ERROR_SMALL_MASK ) ) { skip = 0 ; break ; } } if ( skip == 0 ) { break ; } } if ( skip ) { if ( src_diff_var == UINT_MAX ) { set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; src_diff_var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , bsize ) ; } if ( src_diff_var < 8 <S2SV_ModEnd> <S2SV_ModStart> # endif } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } if ( cpi -> sf . adaptive_motion_search ) store_pred_mv ( x , ctx ) ; if ( do_split ) { subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; if ( bsize == BLOCK_8X8 ) { i = 4 ; if ( cpi -> sf . adaptive_pred_interp_filter && partition_none_allowed ) pc_tree -> leaf_split [ 0 ] -> pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , pc_tree -> leaf_split [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rate == INT_MAX ) sum_rdc . rdcost = INT64_MAX ; } else { <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; pc_tree -> split [ i ] -> index = i <S2SV_ModEnd> <S2SV_ModStart> td , tile_data <S2SV_ModEnd> <S2SV_ModStart> this_rdc , best_rdc . rdcost - sum_rdc . rdcost , pc_tree -> split [ i ] ) ; if ( this_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> break ; <S2SV_ModStart> sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } } if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_SPLIT <S2SV_ModEnd> <S2SV_ModStart> x <S2SV_ModEnd> <S2SV_ModStart> ( do_rect || vp9_active_h_edge ( cpi , mi_row , mi_step ) ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> horizontal [ 0 ] . pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> horizontal [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> && bsize > BLOCK_8X8 ) { PICK_MODE_CONTEXT * ctx = & pc_tree -> horizontal [ 0 ] ; <S2SV_ModEnd> <S2SV_ModStart> td , ctx , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , ctx ) <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> horizontal [ 1 ] . <S2SV_ModEnd> <S2SV_ModStart> tile_data , x <S2SV_ModEnd> <S2SV_ModStart> this_rdc , subsize , & pc_tree -> horizontal [ 1 ] , best_rdc . rdcost - sum_rdc . rdcost ) ; if ( this_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_HORZ ] ; sum_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_HORZ ; } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } if ( partition_vert_allowed && ( do_rect || vp9_active_v_edge ( cpi , mi_col , mi_step ) ) ) { subsize <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> vertical [ 0 ] . pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> vertical [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> && bsize > BLOCK_8X8 <S2SV_ModStart> td , & pc_tree -> vertical [ 0 ] , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , & pc_tree -> vertical [ 0 ] ) <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> vertical [ 1 ] . <S2SV_ModEnd> <S2SV_ModStart> tile_data , x <S2SV_ModEnd> <S2SV_ModStart> this_rdc , subsize , & pc_tree -> vertical [ 1 ] , best_rdc . rdcost - sum_rdc . rdcost ) ; if ( this_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_VERT ] ; sum_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_VERT ; } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } ( void ) best_rd ; * rd_cost = best_rdc ; if ( best_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> best_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> index != 3 <S2SV_ModEnd> <S2SV_ModStart> encode_sb ( cpi , td , tile_info , tp <S2SV_ModEnd> <S2SV_ModStart> bsize , pc_tree <S2SV_ModEnd> <S2SV_ModStart> best_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> best_rdc . dist <S2SV_ModEnd> "
4427,<S2SV_StartBug> event_data -> snk_config = <S2SV_EndBug> ,<S2SV_ModStart> cpu = cpumask_first ( mask ) ; 
4428,<S2SV_StartBug> daddy = malloc ( sizeof ( creator_template ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
4429,"<S2SV_StartBug> # ifndef _MSC_VER <S2SV_EndBug> <S2SV_StartBug> char fpath [ grub_strlen ( currpath ) + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> * currfound = currnode ; <S2SV_EndBug> <S2SV_StartBug> return grub_error ( GRUB_ERR_BAD_FILE_TYPE , ""not<S2SV_blank>a<S2SV_blank>directory"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( grub_errno ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> return grub_error ( GRUB_ERR_SYMLINK_LOOP , <S2SV_EndBug> <S2SV_StartBug> free_node ( oldnode , c ) ; <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return grub_error ( GRUB_ERR_FILE_NOT_FOUND , ""file<S2SV_blank>not<S2SV_blank>found"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> char * fpath = grub_malloc ( <S2SV_ModEnd> <S2SV_ModStart> ) ; char * name = fpath ; char * next ; enum grub_fshelp_filetype type = GRUB_FSHELP_DIR ; grub_fshelp_node_t currnode = currroot ; grub_fshelp_node_t oldnode = currroot ; c -> currroot = currroot ; grub_strncpy ( fpath , currpath , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; free ( fpath ) <S2SV_ModStart> free ( fpath ) ; <S2SV_ModStart> { free ( fpath ) ; <S2SV_ModStart> } <S2SV_ModStart> free ( fpath ) ; <S2SV_ModStart> ) ; free ( fpath <S2SV_ModStart> free ( fpath ) ; <S2SV_ModStart> free ( fpath ) ; <S2SV_ModStart> free ( fpath ) ; "
4430,<S2SV_StartBug> int error ; <S2SV_EndBug> ,"<S2SV_ModStart> unsigned int inode_size = EXT4_INODE_SIZE ( inode -> i_sb ) ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; int error ; if ( ( EXT4_GOOD_OLD_INODE_SIZE + ei -> i_extra_isize > inode_size ) || ( ei -> i_extra_isize & 3 ) ) { EXT4_ERROR_INODE ( inode , ""bad<S2SV_blank>extra_isize<S2SV_blank>%u<S2SV_blank>(inode<S2SV_blank>size<S2SV_blank>%u)"" , ei -> i_extra_isize , EXT4_INODE_SIZE ( inode -> i_sb ) ) ; return - EFSCORRUPTED ; } if ( ( new_extra_isize < ei -> i_extra_isize ) || ( new_extra_isize < 4 ) || ( new_extra_isize > inode_size - EXT4_GOOD_OLD_INODE_SIZE ) ) return - EINVAL <S2SV_ModEnd> "
4431,<S2SV_StartBug> if ( track -> timescale > UINT16_MAX ) { <S2SV_EndBug> ,<S2SV_ModStart> || ! track -> par -> channels 
4432,<S2SV_StartBug> const struct oe_sockaddr * dest_add = <S2SV_EndBug> <S2SV_StartBug> ( const struct oe_sockaddr * ) arg5 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( <S2SV_ModEnd> 
4433,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
4434,<S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4435,"<S2SV_StartBug> ext3_msg ( sb , ""error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>journal<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%ld"" , <S2SV_EndBug> ","<S2SV_ModStart> KERN_ERR , "
4436,<S2SV_StartBug> sr -> bytes_to_send = finfo . size ; <S2SV_EndBug> ,<S2SV_ModStart> fd_is_fdt = MK_FALSE ; sr -> 
4437,<S2SV_StartBug> hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> sadb_msg_satype = SADB_SATYPE_UNSPEC ; hdr -> 
4438,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( rc -> uwbd . task ) 
4439,"<S2SV_StartBug> u64 rem ; <S2SV_EndBug> <S2SV_StartBug> sgi_clock_offset . tv_sec = tp -> tv_sec - div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> ",<S2SV_ModStart> u32 <S2SV_ModEnd> <S2SV_ModStart> div_u64_rem <S2SV_ModEnd> 
4440,"<S2SV_StartBug> int disable_inter_mode_mask , int this_mode , int ref_frame , <S2SV_EndBug> <S2SV_StartBug> frame_mv [ this_mode ] [ second_ref_frame ] . as_int == 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> int rfc = mode_context [ ref_frame ] ; <S2SV_EndBug> <S2SV_StartBug> if ( second_ref_frame == NONE ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frame ] . as_int == 0 ) || <S2SV_EndBug> <S2SV_StartBug> ( c3 >= c1 && frame_mv [ NEARMV ] [ ref_frame ] . as_int == 0 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frame ] . as_int == 0 && <S2SV_EndBug> <S2SV_StartBug> ( c3 >= c1 && frame_mv [ NEARMV ] [ ref_frame ] . as_int == 0 && <S2SV_EndBug> ","<S2SV_ModStart> int this_mode , const MV_REFERENCE_FRAME ref_frames [ 2 ] ) { if ( ( this_mode == NEARMV || this_mode == NEARESTMV || this_mode == ZEROMV ) && frame_mv [ this_mode ] [ ref_frames [ 0 ] ] . as_int == 0 && ( ref_frames [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> ref_frames [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> ref_frames [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> ref_frames [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> ref_frames [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> ref_frames [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> ref_frames [ 0 ] ] . as_int == 0 && frame_mv [ NEARESTMV ] [ ref_frames [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> ref_frames [ 0 ] ] . as_int == 0 && frame_mv [ NEARMV ] [ ref_frames [ 1 ] <S2SV_ModEnd> "
4441,"<S2SV_StartBug> value = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( msg -> oob ) { <S2SV_EndBug> <S2SV_StartBug> nbits = bits & 7 ; <S2SV_EndBug> <S2SV_StartBug> Huff_offsetReceive ( msgHuff . decompressor . tree , & get , msg -> data , & msg -> bit ) ; <S2SV_EndBug> <S2SV_StartBug> value |= ( get << ( i + nbits ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( msg -> readcount > msg -> cursize ) { return 0 ; } <S2SV_ModStart> if ( msg -> readcount + ( bits >> 3 ) > msg -> cursize ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <S2SV_ModStart> if ( msg -> bit + nbits > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <S2SV_ModStart> , msg -> cursize << 3 <S2SV_ModStart> if ( msg -> bit > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } "
4442,"<S2SV_StartBug> dictionary * iniparser_load ( const char * ininame ) <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""iniparser:<S2SV_blank>syntax<S2SV_blank>error<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(%d):\\n"" , <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""-><S2SV_blank>%s\\n"" , line ) ; <S2SV_EndBug> ","<S2SV_ModStart> , load_options options <S2SV_ModStart> if ( options & HIDE_ERRORED_LINE_CONTENT ) { <S2SV_ModStart> ""iniparser:<S2SV_blank>syntax<S2SV_blank>error<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(%d)\\n"" , ininame , lineno ) ; } else { fprintf ( stderr , <S2SV_ModStart> } "
4443,"<S2SV_StartBug> struct strbuf * path , const char * name , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
4444,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""(alt-CoA:<S2SV_blank>%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_128BITS ( & bp [ i + 2 ] ) ; 
4445,"<S2SV_StartBug> memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( up , 0 , sizeof ( * up ) ) ; "
4446,"<S2SV_StartBug> fprintf ( fp , ""%s=%s\\n"" , key , value ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( strchr ( value , '\\n' ) ) die ( ""credential<S2SV_blank>value<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>contains<S2SV_blank>newline"" , key ) ; "
4447,"<S2SV_StartBug> end = strchr ( * value + 1 , \'""\' ) ; <S2SV_EndBug> <S2SV_StartBug> end ++ ; <S2SV_EndBug> ","<S2SV_ModStart> char * p = end = <S2SV_ModEnd> <S2SV_ModStart> ; while ( * p ) { if ( * p == '\\\\' ) { p ++ ; * end = * p ; } else { * end = * p ; if ( * p == \'""\' ) break ; } p ++ ; end ++ ; } if ( * end != \'""\' <S2SV_ModEnd> <S2SV_ModStart> = ++ p <S2SV_ModEnd> "
4448,"<S2SV_StartBug> static const char * parse_string ( cJSON * item , const char * str ) <S2SV_EndBug> <S2SV_StartBug> const char * ptr = str + 1 ; <S2SV_EndBug> <S2SV_StartBug> ep = str ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> while ( * ptr != \'\\""\' && * ptr && ++ len ) <S2SV_EndBug> <S2SV_StartBug> if ( * ptr ++ == '\\\\' ) <S2SV_EndBug> <S2SV_StartBug> ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( out = ( char * ) cJSON_malloc ( len + 1 ) ) ) <S2SV_EndBug> <S2SV_StartBug> while ( * ptr != \'\\""\' && * ptr ) { <S2SV_EndBug> <S2SV_StartBug> sscanf ( ptr + 1 , ""%4x"" , & uc ) ; <S2SV_EndBug> <S2SV_StartBug> ptr += 4 ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( uc >= 0xD800 && uc <= 0xDBFF ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> sscanf ( ptr + 3 , ""%4x"" , & uc2 ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> uc = 0x10000 | ( ( uc & 0x3FF ) << 10 ) | ( uc2 & 0x3FF ) ; <S2SV_EndBug> <S2SV_StartBug> len = 1 ; <S2SV_EndBug> <S2SV_StartBug> ++ ptr ; <S2SV_EndBug> <S2SV_StartBug> ++ ptr ; <S2SV_EndBug> ","<S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> * ep ) { const char * ptr = str + 1 , * end_ptr = str + 1 ; char * ptr2 ; char * <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModStart> return 0 ; <S2SV_ModEnd> <S2SV_ModStart> end_ptr <S2SV_ModEnd> <S2SV_ModStart> end_ptr <S2SV_ModEnd> <S2SV_ModStart> if ( * end_ptr <S2SV_ModEnd> <S2SV_ModStart> end_ptr ++ ; out = ( char * ) cJSON_malloc ( len + 1 ) <S2SV_ModEnd> <S2SV_ModStart> out ) return 0 ; item -> valuestring <S2SV_ModEnd> <S2SV_ModStart> item -> type = cJSON_String ; ptr = str + 1 ; ptr2 = out ; while ( ptr < end_ptr ) <S2SV_ModEnd> <S2SV_ModStart> uc = parse_hex4 ( ptr + 1 ) ; <S2SV_ModEnd> <S2SV_ModStart> if ( ptr >= end_ptr ) { * ep = str ; return 0 ; } <S2SV_ModStart> { * ep = str ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> { if ( ptr + 6 > end_ptr ) { * ep = str ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> { * ep = str ; return 0 ; } uc2 = parse_hex4 <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart> { * ep = str ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> + ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> len = 1 ; <S2SV_ModEnd> <S2SV_ModStart> ptr ++ <S2SV_ModEnd> <S2SV_ModStart> ptr ++ <S2SV_ModEnd> "
4449,"<S2SV_StartBug> bestsad = fn_ptr -> sdf ( what , what_stride , in_what , in_what_stride , UINT_MAX ) <S2SV_EndBug> <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4450,<S2SV_StartBug> u8 opcode = BPF_OP ( insn -> code ) ; <S2SV_EndBug> <S2SV_StartBug> if ( known && ( ptr_reg -> off + smin_val == <S2SV_EndBug> <S2SV_StartBug> if ( dst_reg == off_reg ) { <S2SV_EndBug> ,"<S2SV_ModStart> ; int ret <S2SV_ModStart> ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\n"" , dst ) ; return ret ; } <S2SV_ModStart> ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\n"" , dst ) ; return ret ; } "
4451,"<S2SV_StartBug> psurvival = sweepgen ( L , g , & g -> allgc , g -> survival ) ; <S2SV_EndBug> ",<S2SV_ModStart> g -> gcstate = GCSswpallgc ; 
4452,<S2SV_StartBug> static unsigned int stack_maxrandom_size ( void ) <S2SV_EndBug> <S2SV_StartBug> unsigned int max = 0 ; <S2SV_EndBug> <S2SV_StartBug> max = ( ( - 1U ) & STACK_RND_MASK ) << PAGE_SHIFT ; <S2SV_EndBug> ,<S2SV_ModStart> long <S2SV_ModEnd> <S2SV_ModStart> long <S2SV_ModEnd> <S2SV_ModStart> 1UL <S2SV_ModEnd> 
4453,"<S2SV_StartBug> for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst , src , src_ybc -> y_width ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst , src , src_ybc -> uv_width ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst , src , src_ybc -> uv_width ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( src_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) { assert ( dst_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) ; <S2SV_ModStart> memcpy_short_addr <S2SV_ModEnd> <S2SV_ModStart> memcpy_short_addr <S2SV_ModEnd> <S2SV_ModStart> memcpy_short_addr <S2SV_ModEnd> <S2SV_ModStart> return ; } else { assert ( ! ( dst_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) ) ; } # endif for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) { memcpy ( dst , src , src_ybc -> y_width ) ; src += src_ybc -> y_stride ; dst += dst_ybc -> y_stride ; } src = src_ybc -> u_buffer ; dst = dst_ybc -> u_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { memcpy ( dst , src , src_ybc -> uv_width ) ; src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; } src = src_ybc -> v_buffer ; dst = dst_ybc -> v_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { memcpy ( dst , src , src_ybc -> uv_width ) ; src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; } vp8_yv12_extend_frame_borders_c ( dst_ybc ) ; "
4454,<S2SV_StartBug> s -> chunksize = - 1 ; <S2SV_EndBug> ,<S2SV_ModStart> UINT64_MAX <S2SV_ModEnd> 
4455,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( void ) ctx ; ( void ) args ; 
4456,<S2SV_StartBug> while ( lp -> s != NULL ) { <S2SV_EndBug> <S2SV_StartBug> l2info -> bundle = l2info -> cookie [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> l2info -> bundle = l2info -> cookie [ 1 ] ; <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> ND_TCHECK2 ( p [ 0 ] , 2 ) ; <S2SV_ModStart> ND_TCHECK2 ( p [ 0 ] , 2 ) ; "
4457,<S2SV_StartBug> if ( ! last_pic_droppable && h0 -> cur_pic_ptr -> tf . owner == h0 -> avctx ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4458,"<S2SV_StartBug> case 'l' : RBININFO ( ""libs"" , R_CORE_BIN_ACC_LIBS , NULL , obj ? r_list_length ( obj -> libs ) : 0 ) ; break ; <S2SV_EndBug> <S2SV_StartBug> case 'i' : RBININFO ( ""imports"" , R_CORE_BIN_ACC_IMPORTS , NULL , obj ? r_list_length ( obj -> imports ) : 0 ) ; break ; <S2SV_EndBug> ",<S2SV_ModStart> { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; <S2SV_ModStart> } <S2SV_ModStart> { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; <S2SV_ModStart> } 
4459,"<S2SV_StartBug> int mi_row , int mi_col , vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> const BLOCK_SIZE bsize = mbmi -> sb_type ; <S2SV_EndBug> <S2SV_StartBug> predicted_segment_id = vp9_get_segment_id ( cm , cm -> last_frame_seg_map , <S2SV_EndBug> <S2SV_StartBug> if ( ! seg -> update_map ) <S2SV_EndBug> <S2SV_StartBug> if ( seg -> temporal_update ) { <S2SV_EndBug> <S2SV_StartBug> const vp9_prob pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ; <S2SV_EndBug> <S2SV_StartBug> mbmi -> seg_id_predicted = vp9_read ( r , pred_prob ) ; <S2SV_EndBug> <S2SV_StartBug> set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> int predicted_segment_id , segment_id ; const int mi_offset = mi_row * cm -> mi_cols + mi_col ; const int bw = xd -> plane [ 0 ] . n4_w >> 1 ; const int bh = xd -> plane [ 0 ] . n4_h >> 1 ; const int x_mis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int y_mis = MIN ( cm -> mi_rows - mi_row , bh ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ? dec_get_segment_id ( cm , cm -> last_frame_seg_map , mi_offset , x_mis , y_mis ) : 0 <S2SV_ModEnd> <S2SV_ModStart> { copy_segment_id ( cm , cm -> last_frame_seg_map , cm -> current_frame_seg_map , mi_offset , x_mis , y_mis ) ; <S2SV_ModStart> } <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> mi_offset , x_mis , y_mis <S2SV_ModEnd> "
4460,"<S2SV_StartBug> int i , len ; <S2SV_EndBug> <S2SV_StartBug> const char __user * p ; <S2SV_EndBug> <S2SV_StartBug> audit_log_format ( * ab , ""argc=%d"" , context -> execve . argc ) ; <S2SV_EndBug> <S2SV_StartBug> buf = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! buf ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < context -> execve . argc ; i ++ ) { <S2SV_EndBug> ","<S2SV_ModStart> long len_max ; long len_rem ; long len_full ; long len_buf ; long len_abuf ; long len_tmp ; bool require_data ; bool encode ; unsigned int iter ; unsigned int arg ; char * buf_head ; char * buf <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> char abuf [ 96 ] ; WARN_ON_ONCE ( MAX_EXECVE_AUDIT_LEN > 7500 ) ; len_max = MAX_EXECVE_AUDIT_LEN ; buf_head = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ; if ( ! buf_head ) { audit_panic ( ""out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>argv<S2SV_blank>string"" ) ; return ; } buf = buf_head ; <S2SV_ModStart> len_rem = len_max ; len_buf = 0 ; len_full = 0 ; require_data = true ; encode = false ; iter = 0 ; arg = 0 ; do { if ( len_full == 0 ) len_full = strnlen_user ( p , MAX_ARG_STRLEN ) - 1 ; if ( require_data ) { if ( buf != buf_head ) { memmove ( buf_head , buf , len_buf ) ; buf = buf_head ; } len_tmp = strncpy_from_user ( & buf_head [ len_buf ] , p , len_max - len_buf ) ; if ( len_tmp == - EFAULT ) { send_sig ( SIGKILL , current , 0 ) ; goto out ; } else if ( len_tmp == ( len_max - len_buf ) ) { require_data = true ; encode = true ; len_full = len_full * 2 ; p += len_tmp ; } else { require_data = false ; if ( ! encode ) encode = audit_string_contains_control ( buf , len_tmp ) ; if ( len_full < len_max ) len_full = ( encode ? len_tmp * 2 : len_tmp ) ; p += len_tmp + 1 ; } len_buf += len_tmp ; buf_head [ len_buf ] = '\\0' ; len_abuf = ( encode ? len_buf * 2 : len_buf + 2 ) ; } if ( len_buf > 0 ) { if ( ( sizeof ( abuf ) + 8 ) > len_rem ) { len_rem = len_max ; audit_log_end ( * ab ) ; * ab = audit_log_start ( context , GFP_KERNEL , AUDIT_EXECVE <S2SV_ModEnd> <S2SV_ModStart> * ab ) goto out ; } len_tmp = 0 ; if ( require_data || ( iter > 0 ) || ( ( len_abuf + sizeof ( abuf ) ) > len_rem ) ) { if ( iter == 0 ) { len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d_len=%lu"" , arg , len_full ) ; } len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d[%d]="" , arg , iter ++ ) ; } else len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d="" , arg ) ; WARN_ON ( len_tmp >= sizeof ( abuf ) ) ; abuf [ sizeof ( abuf ) - 1 ] = '\\0' ; audit_log_format ( * ab , ""%s"" , abuf ) ; len_rem -= len_tmp ; len_tmp = len_buf ; if ( encode ) { if ( len_abuf > len_rem ) len_tmp = len_rem / 2 ; audit_log_n_hex ( * ab , buf , len_tmp ) ; len_rem -= len_tmp * 2 ; len_abuf -= len_tmp * 2 ; } else { if ( len_abuf > len_rem ) len_tmp = len_rem - 2 ; audit_log_n_string ( * ab , buf , len_tmp ) ; len_rem -= len_tmp + 2 ; len_abuf -= len_tmp ; } len_buf -= len_tmp ; buf += len_tmp ; } if ( ( len_buf == 0 ) && ! require_data ) { arg ++ ; iter = 0 ; len_full = 0 ; require_data = true ; encode = false ; } } while ( arg <S2SV_ModEnd> <S2SV_ModStart> ) ; out : kfree ( buf_head <S2SV_ModEnd> "
4461,"<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_lock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4462,"<S2SV_StartBug> if ( JAS_CAST ( ulong , jas_stream_tell ( tmpstream ) ) != ms -> len ) { <S2SV_EndBug> ",<S2SV_ModStart> jas_ulong <S2SV_ModEnd> 
4463,<S2SV_StartBug> int i ; <S2SV_EndBug> ,"<S2SV_ModStart> ; account_pipe_buffers ( pipe , pipe -> buffers , 0 ) ; free_uid ( pipe -> user ) "
4464,"<S2SV_StartBug> dd_create_basic_files ( dd , fsuid , ( rootdir && strcmp ( rootdir , ""/"" ) != 0 ) ? rootdir : NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
4465,"<S2SV_StartBug> double GetGPMFSampleRate ( size_t handle , uint32_t fourcc , uint32_t flags ) <S2SV_EndBug> <S2SV_StartBug> double rate = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> indexcount > 3 ) <S2SV_EndBug> <S2SV_StartBug> testend -- ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> uint32_t * payload = GetPayload ( handle , NULL , teststart ) ; <S2SV_EndBug> <S2SV_StartBug> uint32_t payloadsize = GetPayloadSize ( handle , teststart ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret != GPMF_OK ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> payload = GetPayload ( handle , payload , teststart ) ; <S2SV_EndBug> <S2SV_StartBug> payloadsize = GetPayloadSize ( handle , teststart ) ; <S2SV_EndBug> <S2SV_StartBug> ret = GPMF_Init ( ms , payload , payloadsize ) ; <S2SV_EndBug> <S2SV_StartBug> uint32_t samples = GPMF_Repeat ( ms ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( flags & GPMF_SAMPLE_RATE_PRECISE ) && GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) ) <S2SV_EndBug> <S2SV_StartBug> goto cleanup ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> uint32_t * repeatarray = malloc ( mp4 -> indexcount * 4 + 4 ) ; <S2SV_EndBug> <S2SV_StartBug> for ( payloadpos = teststart ; payloadpos < testend ; payloadcount ++ , payloadpos ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( GPMF_OK == GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) <S2SV_EndBug> <S2SV_StartBug> float in , out ; <S2SV_EndBug> <S2SV_StartBug> GetPayloadTime ( handle , payloadpos , & in , & out ) ; <S2SV_EndBug> <S2SV_StartBug> uint32_t repeat = GPMF_Repeat ( ms ) ; <S2SV_EndBug> <S2SV_StartBug> float in , out ; <S2SV_EndBug> <S2SV_StartBug> GetPayloadTime ( handle , payloadpos , & in , & out ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> top += ( ( double ) out - meanX ) * ( ( double ) repeatarray [ payloadpos ] - meanY ) ; <S2SV_EndBug> <S2SV_StartBug> bot += ( ( double ) out - meanX ) * ( ( double ) out - meanX ) ; <S2SV_EndBug> <S2SV_StartBug> # if 0 <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> printf ( ""%c%c%c%c<S2SV_blank>start<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>(%.3fms)\\n"" , PRINTF_4CC ( fourcc ) , intercept , 1000.0 * intercept / slope ) ; <S2SV_EndBug> <S2SV_StartBug> goto cleanup ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , double * firstsampletime , double * lastsampletime <S2SV_ModStart> ; uint32_t * payload ; uint32_t payloadsize ; int32_t ret <S2SV_ModStart> payload = GetPayload ( handle , NULL , teststart ) ; payloadsize = GetPayloadSize ( handle , teststart ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ; if ( ret != GPMF_OK ) goto cleanup ; { uint64_t minimumtimestamp = 0 ; uint64_t starttimestamp = 0 ; uint64_t endtimestamp = 0 ; uint32_t startsamples = 0 ; uint32_t endsamples = 0 ; double intercept = 0.0 ; while ( teststart < <S2SV_ModEnd> <S2SV_ModStart> && ret == GPMF_OK && GPMF_OK != GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) <S2SV_ModEnd> <S2SV_ModStart> payload = GetPayload ( handle , payload , teststart ) ; payloadsize = GetPayloadSize ( handle , teststart ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ; } if ( ret == GPMF_OK && payload ) { uint32_t samples = GPMF_PayloadSampleCount ( ms ) ; GPMF_stream find_stream ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) ) startsamples = BYTESWAP32 ( * ( uint32_t * ) GPMF_RawData ( & find_stream ) ) - samples ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TIME_STAMP , GPMF_CURRENT_LEVEL ) ) starttimestamp = BYTESWAP64 ( * ( uint64_t * ) GPMF_RawData ( & find_stream ) ) ; if ( starttimestamp ) { GPMF_stream any_stream ; GPMF_Init ( & any_stream , payload , payloadsize ) ; minimumtimestamp = starttimestamp ; while ( GPMF_OK == GPMF_FindNext ( & any_stream , GPMF_KEY_TIME_STAMP , GPMF_RECURSE_LEVELS ) ) { uint64_t timestamp = BYTESWAP64 ( * ( uint64_t * ) GPMF_RawData ( & any_stream ) ) ; if ( timestamp < minimumtimestamp ) minimumtimestamp = timestamp ; } } testend = mp4 -> indexcount ; do { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> payload , testend ) ; <S2SV_ModEnd> <S2SV_ModStart> testend ) ; <S2SV_ModEnd> <S2SV_ModStart> } while ( testend > 0 <S2SV_ModEnd> <S2SV_ModStart> ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) ) endsamples = BYTESWAP32 ( * ( uint32_t * ) GPMF_RawData ( & find_stream ) ) ; else { uint32_t i ; for ( i = teststart ; i <= testend ; i ++ ) { <S2SV_ModEnd> <S2SV_ModStart> i <S2SV_ModEnd> <S2SV_ModStart> i ) ; if ( GPMF_OK == <S2SV_ModEnd> <S2SV_ModStart> ) if ( GPMF_OK == GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) endsamples += GPMF_PayloadSampleCount ( ms ) ; } } if ( starttimestamp != 0 <S2SV_ModEnd> <S2SV_ModStart> last_samples = GPMF_PayloadSampleCount ( ms ) ; uint32_t totaltimestamped_samples = endsamples - last_samples - startsamples ; double time_stamp_scale = 1000000000.0 ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TIME_STAMP , GPMF_CURRENT_LEVEL ) ) endtimestamp = BYTESWAP64 ( * ( uint64_t * ) GPMF_RawData <S2SV_ModEnd> <S2SV_ModStart> ) ) ; if ( endtimestamp ) { double approxrate = 0.0 ; if ( endsamples > startsamples ) approxrate <S2SV_ModEnd> <S2SV_ModStart> if ( approxrate == 0.0 ) approxrate <S2SV_ModEnd> <S2SV_ModStart> while ( time_stamp_scale >= 1 ) { rate = ( double ) ( totaltimestamped_samples ) / ( ( double ) ( endtimestamp - starttimestamp ) / time_stamp_scale ) ; if ( rate * 0.9 < approxrate && approxrate < rate * 1.1 ) break ; time_stamp_scale *= 0.1 ; } if ( time_stamp_scale < 1.0 ) rate = 0.0 ; intercept = ( ( ( double ) minimumtimestamp - ( double ) starttimestamp ) / time_stamp_scale ) * rate ; } } if ( rate == 0.0 ) { if ( ! ( flags & GPMF_SAMPLE_RATE_PRECISE ) ) { if ( endsamples > startsamples ) rate = ( double ) ( endsamples - startsamples ) / ( mp4 -> metadatalength * ( ( double ) ( testend - teststart + 1 ) ) / ( double ) <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( rate == 0.0 ) rate = ( double ) ( samples ) / ( mp4 -> metadatalength * ( ( double ) ( testend - teststart + 1 ) ) / ( double ) mp4 -> indexcount ) ; double in , out ; if ( GPMF_OK == GetPayloadTime ( handle , teststart , & in , & out ) ) intercept = ( double ) - in * rate ; } else { uint32_t payloadpos = 0 , payloadcount = 0 ; double slope , top = 0.0 , bot = 0.0 , meanX = 0 , meanY = 0 ; uint32_t * repeatarray = malloc ( mp4 -> indexcount <S2SV_ModStart> <= testend ; payloadpos ++ ) { payload = GetPayload ( handle , payload , payloadpos ) ; payloadsize = GetPayloadSize ( handle , payloadpos ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ; if ( ret != GPMF_OK ) goto cleanup ; if ( GPMF_OK == GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) { GPMF_stream find_stream2 ; GPMF_CopyState ( ms , & find_stream2 ) ; payloadcount ++ <S2SV_ModEnd> <S2SV_ModStart> & find_stream2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> double <S2SV_ModEnd> <S2SV_ModStart> if ( GPMF_OK == <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> GPMF_PayloadSampleCount <S2SV_ModEnd> <S2SV_ModStart> double <S2SV_ModEnd> <S2SV_ModStart> if ( GPMF_OK == <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> else { <S2SV_ModEnd> <S2SV_ModStart> = 0 ; } } if ( repeatarray ) { meanY /= ( double ) payloadcount ; meanX /= ( double ) payloadcount ; for ( payloadpos = teststart ; payloadpos <= testend ; payloadpos ++ ) { double in , out ; if ( repeatarray [ payloadpos ] && GPMF_OK == GetPayloadTime ( handle , payloadpos , & in , & out ) ) { top += ( ( double ) out - meanX ) * ( ( double ) repeatarray [ payloadpos ] <S2SV_ModStart> } <S2SV_ModStart> rate = slope ; intercept = meanY - slope * meanX ; <S2SV_ModStart> printf ( ""%c%c%c%c<S2SV_blank>start<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>(%.3fms)<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f\\n"" <S2SV_ModEnd> <S2SV_ModStart> , rate ) ; printf ( ""%c%c%c%c<S2SV_blank>first<S2SV_blank>sample<S2SV_blank>at<S2SV_blank>time<S2SV_blank>%.3fms\\n"" , PRINTF_4CC ( fourcc ) , - 1000.0 * intercept / slope ) ; # endif <S2SV_ModEnd> <S2SV_ModStart> } } if ( firstsampletime && lastsampletime ) { uint32_t endpayload = mp4 -> indexcount ; do { endpayload -- ; payload = GetPayload ( handle , payload , endpayload ) ; payloadsize = GetPayloadSize ( handle , endpayload ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ; } while ( endpayload > 0 && GPMF_OK != GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) ; if ( endpayload > 0 && ret == GPMF_OK ) { uint32_t totalsamples = endsamples - startsamples ; float timo = 0.0 ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TIME_OFFSET , GPMF_CURRENT_LEVEL ) ) GPMF_FormattedData ( & find_stream , & timo , 4 , 0 , 1 ) ; double first , last ; first = - intercept / rate - timo ; last = first + ( double ) totalsamples / rate ; if ( firstsampletime ) * firstsampletime = first ; if ( lastsampletime ) * lastsampletime = last ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4466,<S2SV_StartBug> r1 . event = event ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & r1 , 0 , sizeof ( r1 ) ) ; "
4467,<S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit ) { <S2SV_EndBug> ,<S2SV_ModStart> limit || ( unsigned char * ) e + e -> next_offset > 
4468,"<S2SV_StartBug> int old_bin_num , bin_num ; <S2SV_EndBug> <S2SV_StartBug> bin_num = ZEND_MM_SMALL_SIZE_TO_BIN ( size ) ; <S2SV_EndBug> <S2SV_StartBug> return ptr ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( size <= ZEND_MM_MAX_SMALL_SIZE ) { int <S2SV_ModStart> } 
4469,<S2SV_StartBug> int hstartcol ; <S2SV_EndBug> <S2SV_StartBug> hstartcol = ( numrows + 1 - parity ) >> 1 ; <S2SV_EndBug> <S2SV_StartBug> m = numrows - hstartcol ; <S2SV_EndBug> <S2SV_StartBug> dstptr = & a [ hstartcol * stride ] ; <S2SV_EndBug> ,<S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> hstartrow <S2SV_ModEnd> 
4470,"<S2SV_StartBug> unsigned long cs ; <S2SV_EndBug> <S2SV_StartBug> rc = emulate_pop ( ctxt , & ctxt -> _eip , ctxt -> op_bytes ) ; <S2SV_EndBug> <S2SV_StartBug> return rc ; <S2SV_EndBug> <S2SV_StartBug> rc = load_segment_descriptor ( ctxt , ( u16 ) cs , VCPU_SREG_CS ) ; <S2SV_EndBug> ","<S2SV_ModStart> eip , cs ; u16 old_cs <S2SV_ModEnd> <S2SV_ModStart> struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , VCPU_SREG_CS ) ; <S2SV_ModStart> eip <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> __load_segment_descriptor <S2SV_ModEnd> <S2SV_ModStart> , 0 , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_far ( ctxt , eip , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; } <S2SV_ModEnd> "
4471,<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ; 
4472,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> <S2SV_StartBug> exit_func : <S2SV_EndBug> ",<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : <S2SV_ModStart>  <S2SV_ModEnd> 
4473,<S2SV_StartBug> psf_close_rsrc ( psf ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; free ( psf -> header . ptr 
4474,<S2SV_StartBug> int is_valid ; <S2SV_EndBug> <S2SV_StartBug> giterr_clear ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> = ( error == GIT_OK ) <S2SV_ModStart>  <S2SV_ModEnd> 
4475,"<S2SV_StartBug> hmp_data = hmp_chunk [ i ] + chunk_length [ i ] ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( ( setup_ret = _WM_SetupMidiEvent ( hmp_mdi , hmp_chunk [ i ] , 0 ) ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chunk_end [ i ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( * hmp_chunk [ i ] < 0x80 ) { <S2SV_EndBug> <S2SV_StartBug> chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( * hmp_chunk [ i ] < 0x80 ) ; <S2SV_EndBug> <S2SV_StartBug> chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ; <S2SV_EndBug> <S2SV_StartBug> hmp_chunk [ i ] ++ ; <S2SV_EndBug> ","<S2SV_ModStart> [ i ] ; chunk_length [ i ] -= chunk_ofs <S2SV_ModStart> chunk_length [ i ] -= 3 ; <S2SV_ModStart> [ i ] , chunk_length <S2SV_ModStart> ; chunk_length [ i ] -= 3 <S2SV_ModStart> chunk_length [ i ] -= setup_ret ; <S2SV_ModStart> chunk_length [ i ] && <S2SV_ModStart> if ( ! chunk_length [ i ] ) break ; <S2SV_ModStart> chunk_length [ i ] -- ; <S2SV_ModStart> if ( ! chunk_length [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmp_end ; } <S2SV_ModStart> ; chunk_length [ i ] -- "
4476,"<S2SV_StartBug> c_t = tvb_get_bits8 ( tvb , tb_bit_off , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> macinf -> lchid [ j + chan ] = c_t + 1 ; <S2SV_EndBug> <S2SV_StartBug> macinf -> content [ j + chan ] = lchId_type_table [ c_t + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> rlcinf -> mode [ j + chan ] = lchId_rlc_map [ c_t + 1 ] ; <S2SV_EndBug> ",<S2SV_ModStart> ( <S2SV_ModStart> + 1 ) % 0xf <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4477,"<S2SV_StartBug> struct sctp_sockaddr_entry * laddr ; <S2SV_EndBug> <S2SV_StartBug> __u8 matchlen = 0 ; <S2SV_EndBug> <S2SV_StartBug> dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ; <S2SV_EndBug> <S2SV_StartBug> dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ; <S2SV_EndBug> ","<S2SV_ModStart> ipv6_pinfo * np = inet6_sk ( sk ) ; struct <S2SV_ModStart> struct in6_addr * final_p , final ; <S2SV_ModStart> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_ModStart> final_p <S2SV_ModEnd> <S2SV_ModStart> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_ModStart> final_p <S2SV_ModEnd> "
4478,"<S2SV_StartBug> r = conv_encoding ( ci -> pattern_enc , ci -> target_enc , pattern , pattern_end , <S2SV_EndBug> ",<S2SV_ModStart> return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION <S2SV_ModEnd> 
4479,<S2SV_StartBug> long start ; <S2SV_EndBug> <S2SV_StartBug> char * header ; <S2SV_EndBug> <S2SV_StartBug> start = ftell ( fp ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = safe_calloc ( <S2SV_ModEnd> <S2SV_ModStart> long 
4480,<S2SV_StartBug> number_planes_filled * sizeof ( * pixels ) ) ; <S2SV_EndBug> <S2SV_StartBug> pixel_info_length = image -> columns * image -> rows * number_planes_filled ; <S2SV_EndBug> ,"<S2SV_ModStart> MagickMax ( number_planes_filled , 4 ) <S2SV_ModEnd> <S2SV_ModStart> MagickMax ( number_planes_filled , 4 ) <S2SV_ModEnd> "
4481,<S2SV_StartBug> if ( len < 20 ) <S2SV_EndBug> ,"<S2SV_ModStart> 32 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]"" <S2SV_ModEnd> "
4482,<S2SV_StartBug> if ( data -> multi_easy ) <S2SV_EndBug> <S2SV_StartBug> curl_multi_cleanup ( data -> multi_easy ) ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> data -> multi_easy = NULL ; } 
4483,"
","
"
4484,"<S2SV_StartBug> res = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> ",<S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) 
4485,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( clk_src ) ; 
4486,"<S2SV_StartBug> vpx_memset ( upred_ptr , expected_udc , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( vpred_ptr , expected_vdc , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( upred_ptr , uabove_row , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( vpred_ptr , vabove_row , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( upred_ptr , uleft_col [ i ] , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( vpred_ptr , vleft_col [ i ] , 8 ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
4487,<S2SV_StartBug> if ( ctxt -> rip_relative ) <S2SV_EndBug> ,<S2SV_ModStart> && likely ( ctxt -> memopp ) 
4488,"<S2SV_StartBug> security_decrypt ( s -> p , length , rdp ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) return FALSE 
4489,"<S2SV_StartBug> control_interface = usb_ifnum_to_if ( usb_dev , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( ! data_interface || ! control_interface ) return - ENODEV 
4490,"<S2SV_StartBug> o = 2 ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < nelements ; j ++ , i ++ ) { <S2SV_EndBug> ","<S2SV_ModStart> if ( nelements == 0 ) { DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\n"" ) ) ; goto out ; } <S2SV_ModStart> && i < sh . sh_properties ; <S2SV_ModEnd> "
4491,"<S2SV_StartBug> static int <S2SV_EndBug> <S2SV_StartBug> rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , u_int indent ) <S2SV_EndBug> <S2SV_StartBug> pdu_header = ( const rpki_rtr_pdu * ) tptr ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_EndBug> <S2SV_StartBug> pdu_type , pdu_len ) ) ; <S2SV_EndBug> <S2SV_StartBug> case RPKI_RTR_END_OF_DATA_PDU : <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case RPKI_RTR_CACHE_RESPONSE_PDU : <S2SV_EndBug> <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_ipv4_prefix * ) tptr ; <S2SV_EndBug> <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_ipv6_prefix * ) tptr ; <S2SV_EndBug> <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_error_report * ) tptr ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , encapsulated_pdu_length ) ; <S2SV_EndBug> <S2SV_StartBug> tptr += sizeof ( * pdu ) ; <S2SV_EndBug> <S2SV_StartBug> if ( encapsulated_pdu_length && <S2SV_EndBug> <S2SV_StartBug> if ( rpki_rtr_pdu_print ( ndo , tptr , indent + 2 ) ) <S2SV_EndBug> <S2SV_StartBug> tlen -= encapsulated_pdu_length ; <S2SV_EndBug> <S2SV_StartBug> text_length = 0 ; <S2SV_EndBug> <S2SV_StartBug> text_length = EXTRACT_32BITS ( tptr ) ; <S2SV_EndBug> <S2SV_StartBug> tlen -= 4 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , text_length ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ","<S2SV_ModStart> u_int <S2SV_ModEnd> <S2SV_ModStart> const u_int len , const u_char recurse , const <S2SV_ModStart> ND_TCHECK_8BITS ( tptr ) ; if ( * tptr != 0 ) { ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u<S2SV_blank>(unknown)"" , indent_string ( 8 ) , * tptr ) ) ; return len ; } if ( len < sizeof ( rpki_rtr_pdu ) ) { ND_PRINT ( ( ndo , ""(%u<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>few<S2SV_blank>to<S2SV_blank>decode)"" , len ) ) ; goto invalid ; } ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( pdu_len < sizeof ( rpki_rtr_pdu ) || pdu_len > len ) goto invalid <S2SV_ModStart> if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModStart> if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModStart> if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 12 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 24 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> tlen = sizeof ( rpki_rtr_pdu ) ; if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) ; <S2SV_ModStart> tlen += 4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) { if ( pdu_len < tlen + encapsulated_pdu_length ) goto invalid ; if ( ! recurse ) { ND_TCHECK2 ( * tptr , tlen + encapsulated_pdu_length ) ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> + tlen , encapsulated_pdu_length , 0 <S2SV_ModStart> ; } tlen <S2SV_ModEnd> <S2SV_ModStart> } if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> + tlen ) ; tlen <S2SV_ModEnd> <S2SV_ModStart> if ( text_length ) { if ( pdu_len < tlen + text_length ) goto invalid ; ND_PRINT ( ( ndo , ""%sError<S2SV_blank>text:<S2SV_blank>"" , indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo , tptr + tlen , text_length , ndo -> ndo_snapend ) ) goto trunc ; } } break ; default : <S2SV_ModEnd> <S2SV_ModStart> pdu_len ) ; <S2SV_ModEnd> <S2SV_ModStart> pdu_len ; invalid : ND_PRINT ( ( ndo , ""%s"" , istr ) ) ; ND_TCHECK2 ( * tptr , len ) ; return len <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""\\n\\t%s"" , tstr ) ) ; return len <S2SV_ModEnd> "
4492,<S2SV_StartBug> xstep = picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn + <S2SV_EndBug> <S2SV_StartBug> ystep = picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn + <S2SV_EndBug> <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) <S2SV_EndBug> <S2SV_StartBug> || ! ( pi -> x % ( 1 << rpx ) ) ) && <S2SV_EndBug> <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) <S2SV_EndBug> <S2SV_StartBug> || ! ( pi -> y % ( 1 << rpy ) ) ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> "
4493,"<S2SV_StartBug> if ( pack -> hdr . ver == 2 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> log_ppp_debug ( ""<S2SV_blank>Ns=%u<S2SV_blank>Nr=%u"" , ntohs ( pack -> hdr . Ns ) , ntohs ( pack -> hdr . Nr ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> switch ( pack -> hdr . flags & L2TP_VER_MASK ) { case 2 : <S2SV_ModEnd> <S2SV_ModStart> break ; case 3 : <S2SV_ModEnd> <S2SV_ModStart> ; break ; default : print ( ""[L2TP<S2SV_blank>unknown<S2SV_blank>version]\\n"" ) ; return "
4494,"<S2SV_StartBug> if ( ( st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbprincipalkey"" , <S2SV_EndBug> <S2SV_StartBug> LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ) != 0 ) <S2SV_EndBug> ",<S2SV_ModStart> bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } if ( bersecretkey [ 0 ] != NULL || ! create_standalone_prinicipal ) { <S2SV_ModEnd> <S2SV_ModStart> ; if ( st != 0 ) goto cleanup ; } <S2SV_ModEnd> 
4495,"<S2SV_StartBug> puts ( ""Copyright<S2SV_blank>(c)<S2SV_blank>2011,<S2SV_blank>Oracle<S2SV_blank>and/or<S2SV_blank>its<S2SV_blank>affiliates.<S2SV_blank>"" <S2SV_EndBug> ","<S2SV_ModStart> ""Copyright<S2SV_blank>(c)<S2SV_blank>2011,<S2SV_blank>2015,<S2SV_blank>Oracle<S2SV_blank>and/or<S2SV_blank>its<S2SV_blank>affiliates.<S2SV_blank>"" <S2SV_ModEnd> "
4496,"<S2SV_StartBug> char * r = pool_alloc ( strlen ( s ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( r , s ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t len = strlen ( s ) + 1 ; <S2SV_ModStart> len ) ; memcpy <S2SV_ModEnd> <S2SV_ModStart> , len "
4497,<S2SV_StartBug> if ( size_left && size_left < 4 ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4498,"<S2SV_StartBug> OPJ_UINT32 * p_data_written , <S2SV_EndBug> <S2SV_StartBug> opj_write_bytes ( p_data , J2K_MS_SOT , <S2SV_EndBug> ","<S2SV_ModStart> p_total_data_size , OPJ_UINT32 <S2SV_ModStart> if ( p_total_data_size < 12 ) { opj_event_msg ( p_manager , EVT_ERROR , ""Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOT<S2SV_blank>marker\\n"" ) ; return OPJ_FALSE ; } "
4499,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> kvm_pit_load_count ( kvm , 0 , ps -> channels [ 0 ] . count , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> int i ; <S2SV_ModStart> for ( i = 0 ; i < 3 ; i ++ ) <S2SV_ModStart> i <S2SV_ModEnd> <S2SV_ModStart> i <S2SV_ModEnd> 
4500,"<S2SV_StartBug> if ( utimes ( vect [ 0 ] , tv ) == - 1 ) <S2SV_EndBug> ",<S2SV_ModStart> ( void ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4501,"<S2SV_StartBug> timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; <S2SV_EndBug> ",<S2SV_ModStart> m -> msg_namelen = 0 ; 
4502,"<S2SV_StartBug> inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ; <S2SV_EndBug> ","<S2SV_ModStart> s -> s_stack_depth = path . dentry -> d_sb -> s_stack_depth + 1 ; rc = - EINVAL ; if ( s -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( ""eCryptfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n"" ) ; goto out_free ; } "
4503,<S2SV_StartBug> } else if ( options . compression == COMP_DELAYED ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4504,"<S2SV_StartBug> struct flowi4 fl4 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! __sk_dst_get ( sk ) || __sk_dst_check ( sk , 0 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! IS_ERR ( rt ) ) <S2SV_EndBug> <S2SV_StartBug> __sk_dst_set ( sk , & rt -> dst ) ; <S2SV_EndBug> ","<S2SV_ModStart> dst_entry * dst ; struct <S2SV_ModStart> rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; <S2SV_ModStart> dst || ! dst -> obsolete || dst -> ops -> check ( dst <S2SV_ModEnd> <S2SV_ModStart> { rcu_read_unlock ( ) ; return ; } <S2SV_ModEnd> <S2SV_ModStart> dst = <S2SV_ModEnd> <S2SV_ModStart> ? <S2SV_ModEnd> <S2SV_ModStart> dst : NULL ; sk_dst_set ( sk , "
4505,"<S2SV_StartBug> num = port >= 0 ? port : 0 ; <S2SV_EndBug> <S2SV_StartBug> write_unlock_irqrestore ( & client -> ports_lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & client -> ports_mutex ) ; <S2SV_EndBug> ","<S2SV_ModStart> snd_use_lock_use ( & new_port -> use_lock ) ; <S2SV_ModStart> sprintf ( new_port -> name , ""port-%d"" , num ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
4506,"<S2SV_StartBug> return usb_control_msg ( dev -> udev , usb_rcvctrlpipe ( dev -> udev , 0 ) , <S2SV_EndBug> <S2SV_StartBug> indx , 0 , data , size , 500 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> void * buf ; int ret ; buf = kmalloc ( size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> if ( ret > 0 && ret <= size ) memcpy ( data , buf , ret ) ; kfree ( buf ) ; return ret ; "
4507,"<S2SV_StartBug> if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> <S2SV_StartBug> l_row -- ; <S2SV_EndBug> ",<S2SV_ModStart> 3 == <S2SV_ModStart> && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> <S2SV_ModStart> LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ; 
4508,"<S2SV_StartBug> struct ip_options * opt = NULL ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( opt -> __data , buf , buf_len ) ; <S2SV_EndBug> <S2SV_StartBug> opt -> optlen = opt_len ; <S2SV_EndBug> <S2SV_StartBug> opt -> cipso = sizeof ( struct iphdr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sk_inet -> is_icsk ) { <S2SV_EndBug> <S2SV_StartBug> if ( sk_inet -> opt ) <S2SV_EndBug> <S2SV_StartBug> sk_conn -> icsk_ext_hdr_len -= sk_inet -> opt -> optlen ; <S2SV_EndBug> <S2SV_StartBug> sk_conn -> icsk_ext_hdr_len += opt -> optlen ; <S2SV_EndBug> <S2SV_StartBug> opt = xchg ( & sk_inet -> opt , opt ) ; <S2SV_EndBug> ","<S2SV_ModStart> ip_options_rcu * old , <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> old = rcu_dereference_protected ( sk_inet -> inet_opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> old <S2SV_ModEnd> <S2SV_ModStart> old -> opt . <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> rcu_assign_pointer ( sk_inet -> inet_opt , opt ) ; if ( old ) call_rcu ( & old -> rcu , opt_kfree_rcu <S2SV_ModEnd> "
4509,"<S2SV_StartBug> int zero_bits = * in & 0x07 ; <S2SV_EndBug> <S2SV_StartBug> size_t octets_left = inlen - 1 ; <S2SV_EndBug> <S2SV_StartBug> int i , count = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> i , count = 0 ; int zero_bits ; size_t octets_left ; if ( outlen < octets_left ) return SC_ERROR_BUFFER_TOO_SMALL ; if ( inlen < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> in ++ ; memset ( outbuf , 0 , outlen ) ; while ( octets_left ) { int bits_to_go ; * out = 0 ; if ( octets_left == 1 ) bits_to_go = 8 - zero_bits ; else bits_to_go = 8 ; if ( invert ) for ( i = 0 ; i < bits_to_go ; i ++ ) { * out |= ( ( * in >> ( 7 - i ) ) & 1 ) << i ; } else { * out = * in ; } out ++ ; in ++ ; octets_left -- ; count ++ ; } return ( count * 8 <S2SV_ModEnd> "
4510,"<S2SV_StartBug> & len , & iovec , compat ) ; <S2SV_EndBug> <S2SV_StartBug> len , iovec ) ; <S2SV_EndBug> <S2SV_StartBug> iov_iter_init ( & iter , rw , iovec , nr_segs , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> , & iter <S2SV_ModStart> , & iter <S2SV_ModStart> ret = iter_op ( req , & iter ) ; } else { ret = rw_op ( req , iter . iov , iter . <S2SV_ModEnd> "
4511,"<S2SV_StartBug> unsigned char signature [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> unsigned int siglen = sizeof signature ; <S2SV_EndBug> <S2SV_StartBug> if ( 1 != randomize ( pamh , challenge , sizeof challenge ) ) { <S2SV_EndBug> <S2SV_StartBug> err : <S2SV_EndBug> ",<S2SV_ModStart> * signature = NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> NULL == privkey ) goto err ; siglen = EVP_PKEY_size ( privkey ) ; if ( siglen <= 0 ) goto err ; signature = malloc ( siglen ) ; if ( NULL == signature ) goto err ; if ( <S2SV_ModStart> free ( signature ) ; 
4512,<S2SV_StartBug> kfree ( init_name ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( rv && new_smi -> io . io_cleanup ) { new_smi -> io . io_cleanup ( & new_smi -> io ) ; new_smi -> io . io_cleanup = NULL ; } 
4513,"<S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , lf -> filter_level , 6 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , lf -> sharpness_level , 3 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , lf -> mode_ref_delta_enabled ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , lf -> mode_ref_delta_update ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , changed ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , abs ( delta ) & 0x3F , 6 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , delta < 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , changed ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , abs ( delta ) & 0x3F , 6 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , delta < 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> 
4514,"<S2SV_StartBug> char * header , * c ; <S2SV_EndBug> <S2SV_StartBug> header = get_header ( fp ) ; <S2SV_EndBug> <S2SV_StartBug> ( c + strlen ( ""%PDF-M.m"" ) + 2 ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; const char * c <S2SV_ModStart> ( c + 6 ) [ 0 ] == '.' ) && isdigit ( ( c + 5 ) [ 0 ] ) && isdigit ( ( c + 7 ) [ 0 ] <S2SV_ModEnd> 
4515,"<S2SV_StartBug> struct in6_addr * saddr = NULL , * final_p , final ; <S2SV_EndBug> <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> if ( np -> opt != NULL ) <S2SV_EndBug> <S2SV_StartBug> icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen + <S2SV_EndBug> <S2SV_StartBug> np -> opt -> opt_nflen ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; struct ipv6_txoptions * opt <S2SV_ModStart> opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> opt <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4516,"<S2SV_StartBug> isoclns_print ( ndo , p , length , length ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
4517,"<S2SV_StartBug> strncpy ( szFileName , sizeof ( szFileName ) - 5 , pszFileName ) ; <S2SV_EndBug> ","<S2SV_ModStart> pszFileName , <S2SV_ModStart>  <S2SV_ModEnd> "
4518,"<S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ",<S2SV_ModStart> ssplit <S2SV_ModEnd> 
4519,"<S2SV_StartBug> u_char * b , * s , * t , c ; <S2SV_EndBug> <S2SV_StartBug> b = ( uint8_t * ) malloc ( length ) ; <S2SV_EndBug> <S2SV_StartBug> for ( s = ( u_char * ) p , t = b , i = length ; i > 0 ; i -- ) { <S2SV_EndBug> <S2SV_StartBug> if ( i > 1 ) { <S2SV_EndBug> <S2SV_StartBug> c = * s ++ ^ 0x20 ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; const u_char * s <S2SV_ModStart> u_char <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && ND_TTEST ( * s ) <S2SV_ModStart> <= 1 || ! ND_TTEST ( * s ) ) break ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4520,<S2SV_StartBug> WORD16 i2_level_arr [ 4 ] ; <S2SV_EndBug> ,<S2SV_ModStart> ai2_level_arr [ 7 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> 
4521,<S2SV_StartBug> mutex_lock ( & src_ctx -> mutex ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & src_ctx -> mutex ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> mutex_lock_double ( & src_ctx -> mutex , & dst_ctx <S2SV_ModEnd> <S2SV_ModStart> synchronize_rcu ( <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & src_ctx -> mutex ) ; "
4522,<S2SV_StartBug> atomic_inc ( & prog -> aux -> refcnt ) ; <S2SV_EndBug> ,<S2SV_ModStart> prog = bpf_prog_inc ( prog <S2SV_ModEnd> 
4523,"<S2SV_StartBug> static INLINE void write_buffer_8x8 ( int16_t * output , __m128i * res , int stride ) { <S2SV_EndBug> <S2SV_StartBug> _mm_store_si128 ( ( __m128i * ) ( output + 0 * stride ) , res [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> _mm_store_si128 ( ( __m128i * ) ( output + 1 * stride ) , res [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> _mm_store_si128 ( ( __m128i * ) ( output + 2 * stride ) , res [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> _mm_store_si128 ( ( __m128i * ) ( output + 3 * stride ) , res [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> _mm_store_si128 ( ( __m128i * ) ( output + 4 * stride ) , res [ 4 ] ) ; <S2SV_EndBug> <S2SV_StartBug> _mm_store_si128 ( ( __m128i * ) ( output + 5 * stride ) , res [ 5 ] ) ; <S2SV_EndBug> <S2SV_StartBug> _mm_store_si128 ( ( __m128i * ) ( output + 6 * stride ) , res [ 6 ] ) ; <S2SV_EndBug> <S2SV_StartBug> _mm_store_si128 ( ( __m128i * ) ( output + 7 * stride ) , res [ 7 ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> store_output ( & res [ 0 ] , <S2SV_ModEnd> <S2SV_ModStart> ) ; store_output ( & res [ 1 ] , <S2SV_ModEnd> <S2SV_ModStart> ) ; store_output ( & res [ 2 ] , <S2SV_ModEnd> <S2SV_ModStart> ) ; store_output ( & res [ 3 ] , <S2SV_ModEnd> <S2SV_ModStart> ) ; store_output ( & res [ 4 ] , <S2SV_ModEnd> <S2SV_ModStart> ) ; store_output ( & res [ 5 ] , <S2SV_ModEnd> <S2SV_ModStart> ) ; store_output ( & res [ 6 ] , <S2SV_ModEnd> <S2SV_ModStart> ) ; store_output ( & res [ 7 ] , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4524,<S2SV_StartBug> same_page : <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( page_count ( page ) <= 0 ) ) { if ( pages ) { spin_unlock ( ptl ) ; remainder = 0 ; err = - ENOMEM ; break ; } } 
4525,<S2SV_StartBug> if ( bin -> methods [ i ] . class_id > bin -> header . types_size - 1 ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4526,<S2SV_StartBug> uint32_t pkg_size = RPC_PKG_HEAD_SIZE + pkg -> ext_size + pkg -> body_size ; <S2SV_EndBug> <S2SV_StartBug> assert ( send_buf != NULL ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( pkg -> body_size > RPC_PKG_MAX_BODY_SIZE ) { return - 1 ; } pkg_size <S2SV_ModStart> if ( send_buf == NULL ) { return - 1 ; } <S2SV_ModEnd> 
4527,"<S2SV_StartBug> update_read_synchronize ( update , s ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) goto fail 
4528,<S2SV_StartBug> * p == SSL3_MT_CLIENT_HELLO ) && <S2SV_EndBug> ,<S2SV_ModStart> s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] <S2SV_ModEnd> 
4529,"<S2SV_StartBug> ND_TCHECK ( pptr [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> plen -= 32 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( pptr [ 1 ] , ( plen + 7 ) / 8 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & route_target , & pptr [ 1 ] , ( plen + 7 ) / 8 ) ; <S2SV_EndBug> <S2SV_StartBug> as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + 1 ) ) , <S2SV_EndBug> ","<S2SV_ModStart> char asbuf [ sizeof ( astostr ) ] ; <S2SV_ModStart> ND_TCHECK_32BITS ( pptr + 1 ) ; as_printf ( ndo , asbuf , sizeof ( asbuf ) , EXTRACT_32BITS ( pptr + 1 ) ) ; <S2SV_ModStart> 5 <S2SV_ModEnd> <S2SV_ModStart> 5 <S2SV_ModEnd> <S2SV_ModStart> asbuf <S2SV_ModEnd> "
4530,"<S2SV_StartBug> static void consume_one_event ( unsigned cpu , <S2SV_EndBug> <S2SV_StartBug> unsigned priority , unsigned long * ready , <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( drop ) ) <S2SV_EndBug> <S2SV_StartBug> handle_irq_for_port ( port ) ; <S2SV_EndBug> ","<S2SV_ModStart> , struct evtchn_loop_ctrl * ctrl <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ! ctrl <S2SV_ModEnd> <S2SV_ModStart> , ctrl "
4531,<S2SV_StartBug> cstate = 0 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth || <S2SV_EndBug> ,"<S2SV_ModStart> siz -> comps = 0 ; <S2SV_ModStart> goto error ; } if ( ! siz -> width || ! siz -> height ) { jas_eprintf ( ""reference<S2SV_blank>grid<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\n"" ) ; goto error ; } if ( ! siz -> tilewidth || ! siz -> tileheight ) { jas_eprintf ( ""tile<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\n"" ) ; goto error ; } if ( ! siz -> numcomps || siz -> numcomps > 16384 ) { jas_eprintf ( ""number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( siz -> xoff >= siz -> width ) { jas_eprintf ( ""XOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( siz -> yoff >= siz -> height ) { jas_eprintf ( ""YOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( siz -> tilexoff > siz -> xoff || siz -> tilexoff + siz -> tilewidth <= siz -> xoff ) { jas_eprintf ( ""XTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( siz -> tileyoff > siz -> yoff || siz -> tileyoff + siz -> tileheight <= siz -> yoff ) { jas_eprintf ( ""YTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { goto error ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { goto error ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . hsamp ) ; goto error ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . vsamp ) ; goto error ; } siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { goto error ; } return 0 ; error : if ( siz -> comps ) { jas_free ( siz -> comps ) ; } <S2SV_ModStart>  <S2SV_ModEnd> "
4532,<S2SV_StartBug> if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( chunk -> chunk_end < skb_tail_pointer ( chunk -> skb ) ) { <S2SV_EndBug> <S2SV_StartBug> sctp_chunk_free ( chunk ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> + sizeof ( sctp_chunkhdr_t ) <S2SV_ModStart> chunk -> pdiscard = 1 ; chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( ""+++sctp_inq_pop+++<S2SV_blank>chunk:%p[%s],<S2SV_blank>length:%d,<S2SV_blank>skb->len:%d\\n"" , chunk , sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return <S2SV_ModEnd> "
4533,<S2SV_StartBug> last_id = ntohs ( * pid ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( plen < 0 ) return 0 ; 
4534,"<S2SV_StartBug> ci_debug_printf ( 2 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>Sending<S2SV_blank>request<S2SV_blank>to<S2SV_blank>chained<S2SV_blank>program:<S2SV_blank>%s\\n"" , squidguard ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( sgfpw , ""%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\n"" , httpinf . url , clientip , username , httpinf . method ) ; <S2SV_EndBug> <S2SV_StartBug> fflush ( sgfpw ) ; <S2SV_EndBug> ","<S2SV_ModStart> char * rbuff = NULL ; <S2SV_ModStart> rbuff = replace ( httpinf . url , ""%"" , ""%25"" ) ; <S2SV_ModStart> rbuff <S2SV_ModEnd> <S2SV_ModStart> ) ; xfree ( rbuff "
4535,<S2SV_StartBug> if ( ! values [ k ] . name ) <S2SV_EndBug> ,<S2SV_ModStart> { continue ; } <S2SV_ModEnd> 
4536,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4537,"<S2SV_StartBug> encT ) ; <S2SV_EndBug> <S2SV_StartBug> return _gcry_aes_arm_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , encT ) ; <S2SV_EndBug> ",<S2SV_ModStart> enc_tables . T <S2SV_ModEnd> <S2SV_ModStart> enc_tables . T <S2SV_ModEnd> 
4538,<S2SV_StartBug> rect . x = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . y = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . width = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . height = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . x = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . y = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . width = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . height = <S2SV_ModStart> } 
4539,<S2SV_StartBug> if ( s -> width != avctx -> width && s -> height != avctx -> height ) { <S2SV_EndBug> ,<S2SV_ModStart> || <S2SV_ModEnd> 
4540,<S2SV_StartBug> if ( length == 1 && bp [ 0 ] == 0xff ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK ( bp [ 0 ] ) ; <S2SV_ModStart> ND_TCHECK ( bp [ 3 ] ) ; 
4541,"<S2SV_StartBug> if ( sizeof ( content_type ) - 1 == klen && 0 == strncasecmp ( key , content_type , sizeof ( content_type ) - 1 ) ) { <S2SV_EndBug> <S2SV_StartBug> rb_hash_aset ( hh , content_type_val , rb_str_new ( val , vlen ) ) ; <S2SV_EndBug> <S2SV_StartBug> rb_hash_aset ( hh , content_length_val , rb_str_new ( val , vlen ) ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( hkey , ""HTTP_"" ) ; <S2SV_EndBug> <S2SV_StartBug> rb_hash_aset ( hh , rb_str_new ( hkey , klen + 5 ) , sval ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> VALUE v ; <S2SV_ModStart> if ( Qnil == ( v = rb_hash_lookup2 ( hh , content_type_val , Qnil ) ) ) { <S2SV_ModStart> } else { volatile VALUE a = rb_ary_new ( ) ; rb_ary_push ( a , v ) ; rb_ary_push ( a , rb_str_new ( val , vlen ) ) ; rb_hash_aset ( hh , content_type_val , a ) ; } <S2SV_ModStart> if ( Qnil == ( v = rb_hash_lookup2 ( hh , content_length_val , Qnil ) ) ) { <S2SV_ModStart> } else { rb_raise ( rb_eArgError , ""Multiple<S2SV_blank>Content-Length<S2SV_blank>headers."" ) ; } <S2SV_ModStart> volatile VALUE kval ; <S2SV_ModStart> kval = <S2SV_ModEnd> <S2SV_ModStart> ; if ( Qnil == ( v = rb_hash_lookup2 ( hh , kval , Qnil ) ) ) { rb_hash_aset ( hh , kval <S2SV_ModStart> else { volatile VALUE a = rb_ary_new ( ) ; rb_ary_push ( a , v ) ; rb_ary_push ( a , sval ) ; rb_hash_aset ( hh , kval , a ) ; } } "
4542,"<S2SV_StartBug> # define ThrowCUTReaderException ( severity , tag ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( severity , tag ) ; } <S2SV_EndBug> <S2SV_StartBug> offset = SeekBlob ( image , 6 , SEEK_SET ) ; <S2SV_EndBug> ","<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ; "
4543,"<S2SV_StartBug> archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC , <S2SV_EndBug> <S2SV_StartBug> ARCHIVE_STATE_DATA , ""archive_write_data"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> const size_t max_write = INT_MAX ; <S2SV_ModStart> ; if ( s > max_write ) s = max_write 
4544,<S2SV_StartBug> if ( 0 == ps_dec -> u4_frm_buf_stride ) <S2SV_EndBug> <S2SV_StartBug> else if ( ( u2_width > ps_dec -> u2_create_max_width ) <S2SV_EndBug> <S2SV_StartBug> || ( u2_height > ps_dec -> u2_create_max_height ) ) <S2SV_EndBug> <S2SV_StartBug> return e_error ; <S2SV_EndBug> ,<S2SV_ModStart> } else { <S2SV_ModStart> i4_pic_count ) { return ( IMPEG2D_ERROR_CODES_T ) IMPEG2D_FRM_HDR_DECODE_ERR ; } else if ( ( u2_width > ps_dec -> u2_create_max_width ) || ( u2_height > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error <S2SV_ModEnd> <S2SV_ModStart> ps_dec -> u2_horizontal_size < MIN_WIDTH <S2SV_ModEnd> <S2SV_ModStart> ps_dec -> u2_vertical_size < MIN_HEIGHT ) ) { return IMPEG2D_UNSUPPORTED_DIMENSIONS <S2SV_ModEnd> <S2SV_ModStart> ; } if ( ( ps_dec -> u2_horizontal_size < MIN_WIDTH ) || ( ps_dec -> u2_vertical_size < MIN_HEIGHT ) ) { return IMPEG2D_UNSUPPORTED_DIMENSIONS 
4545,<S2SV_StartBug> xstep = picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn + <S2SV_EndBug> <S2SV_StartBug> ystep = picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn + <S2SV_EndBug> <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) <S2SV_EndBug> <S2SV_StartBug> || ! ( pi -> x % ( 1 << rpx ) ) ) && <S2SV_EndBug> <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) <S2SV_EndBug> <S2SV_StartBug> || ! ( pi -> y % ( 1 << rpy ) ) ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> "
4546,<S2SV_StartBug> if ( p -> tcph -> th_flags & TH_RST ) { <S2SV_EndBug> ,"<S2SV_ModStart> StateSynSentValidateTimestamp ( ssn , p ) == false ) return - 1 ; if ( "
4547,<S2SV_StartBug> int result = RLC_OK ; <S2SV_EndBug> <S2SV_StartBug> if ( ! bn_is_zero ( t ) ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> <S2SV_StartBug> if ( pad != RSA_PAD ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> RLC_ERR ; bn_t t ; RLC_TRY { bn_null ( t ) ; bn_new ( t ) ; switch ( operation ) { case RSA_ENC : case RSA_SIG : case RSA_SIG_HASH : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; bn_lsh ( m , m , m_len * 8 ) ; result = RLC_OK <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> == <S2SV_ModEnd> <S2SV_ModStart> RLC_OK <S2SV_ModEnd> <S2SV_ModStart> } "
4548,<S2SV_StartBug> if ( ! unconditional ( & e -> arp ) ) <S2SV_EndBug> ,<S2SV_ModStart> e <S2SV_ModEnd> 
4549,"<S2SV_StartBug> char buf [ sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2 ] ; <S2SV_EndBug> <S2SV_StartBug> rfbSetColourMapEntriesMsg * scme = ( rfbSetColourMapEntriesMsg * ) buf ; <S2SV_EndBug> <S2SV_StartBug> uint16_t * rgb = ( uint16_t * ) ( & buf [ sz_rfbSetColourMapEntriesMsg ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rfbWriteExact ( cl , buf , len ) < 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> union { char bytes <S2SV_ModEnd> <S2SV_ModStart> msg ; } buf ; rfbSetColourMapEntriesMsg * scme = & buf . msg <S2SV_ModEnd> <S2SV_ModStart> . bytes <S2SV_ModStart> . bytes 
4550,<S2SV_StartBug> char key [ 32 ] = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> if ( vdaux < 1 || vstart + vdaux < vstart ) { <S2SV_EndBug> <S2SV_StartBug> vstart += vdaux ; <S2SV_EndBug> <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> ,<S2SV_ModStart> size_t vstart_off = i ; <S2SV_ModStart> shdr -> sh_size - vstart_off < vdaux <S2SV_ModEnd> <S2SV_ModStart> += vdaux ; vstart_off <S2SV_ModStart> vstart_off += aux . vda_next ; 
4551,<S2SV_StartBug> if ( current -> active_mm != mm ) <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> ,<S2SV_ModStart> { smp_mb ( ) ; <S2SV_ModStart> } <S2SV_ModStart> smp_mb ( ) ; 
4552,<S2SV_StartBug> spin_lock_bh ( & g_cdev . lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( count > sizeof ( ei -> data ) - sizeof ( * elt ) - sizeof ( * app_hdr ) ) return - EINVAL ; 
4553,"<S2SV_StartBug> free_ep_req ( midi -> out_ep , req ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( req -> buf != NULL ) 
4554,"<S2SV_StartBug> net_connect_ip_ssl ( ip , port , own_ip , server -> connrec -> ssl_cert , server -> connrec -> ssl_pkey , <S2SV_EndBug> ","<S2SV_ModStart> server -> connrec -> address , "
4555,"<S2SV_StartBug> if ( frame_is_intra_only ( cm ) ) { <S2SV_EndBug> <S2SV_StartBug> double last_boosted_q = vp9_convert_qindex_to_q ( qindex ) ; <S2SV_EndBug> <S2SV_StartBug> ( last_boosted_q * 0.75 ) ) ; <S2SV_EndBug> <S2SV_StartBug> active_best_quality = get_active_quality ( rc -> avg_frame_qindex [ KEY_FRAME ] , <S2SV_EndBug> <S2SV_StartBug> rc -> kf_boost , <S2SV_EndBug> <S2SV_StartBug> q_val = vp9_convert_qindex_to_q ( active_best_quality ) ; <S2SV_EndBug> <S2SV_StartBug> q_val * q_adj_factor ) ; <S2SV_EndBug> <S2SV_StartBug> active_best_quality = get_active_quality ( <S2SV_EndBug> <S2SV_StartBug> active_best_quality = inter_minq [ rc -> avg_frame_qindex [ INTER_FRAME ] ] ; <S2SV_EndBug> <S2SV_StartBug> active_best_quality = inter_minq [ active_worst_quality ] ; <S2SV_EndBug> <S2SV_StartBug> active_best_quality = inter_minq [ rc -> avg_frame_qindex [ KEY_FRAME ] ] ; <S2SV_EndBug> <S2SV_StartBug> active_best_quality = inter_minq [ active_worst_quality ] ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced ) { <S2SV_EndBug> <S2SV_StartBug> * top_index = ( active_worst_quality + active_best_quality * 3 ) / 4 ; <S2SV_EndBug> ","<S2SV_ModStart> int * rtc_minq ; ASSIGN_MINQ_TABLE ( cm -> bit_depth , rtc_minq ) ; <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> get_kf_active_quality ( rc , <S2SV_ModEnd> <S2SV_ModStart> cm -> bit_depth <S2SV_ModEnd> <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> get_gf_active_quality ( rc , q , cm -> bit_depth <S2SV_ModEnd> <S2SV_ModStart> rtc_minq <S2SV_ModEnd> <S2SV_ModStart> rtc_minq <S2SV_ModEnd> <S2SV_ModStart> rtc_minq <S2SV_ModEnd> <S2SV_ModStart> rtc_minq <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> { int qdelta = 0 ; vpx_clear_system_state ( ) ; qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 2.0 , cm -> bit_depth ) ; * top_index = active_worst_quality + qdelta ; * top_index = ( * top_index > * bottom_index ) ? * top_index : * bottom_index <S2SV_ModEnd> "
4556,"<S2SV_StartBug> size_t addr_incr = MIN ( CORE_MMU_USER_CODE_SIZE , <S2SV_EndBug> <S2SV_StartBug> if ( ADD_OVERFLOW ( uaddr , len , & a ) ) <S2SV_EndBug> <S2SV_StartBug> for ( a = uaddr ; a < ( uaddr + len ) ; a += addr_incr ) { <S2SV_EndBug> ","<S2SV_ModStart> uaddr_t end_addr = 0 ; <S2SV_ModStart> end_addr <S2SV_ModEnd> <S2SV_ModStart> ROUNDDOWN ( uaddr , addr_incr ) <S2SV_ModEnd> <S2SV_ModStart> end_addr <S2SV_ModEnd> "
4557,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> 
4558,"<S2SV_StartBug> old_cs = get_segment_selector ( ctxt , VCPU_SREG_CS ) ; <S2SV_EndBug> <S2SV_StartBug> if ( load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) ) <S2SV_EndBug> <S2SV_StartBug> ctxt -> _eip = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; int cpl = ctxt -> ops -> cpl ( ctxt ) ; old_eip = ctxt -> _eip ; ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rc = __load_segment_descriptor <S2SV_ModEnd> <S2SV_ModStart> , cpl , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE <S2SV_ModEnd> <S2SV_ModStart> rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_cs ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_eip ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; return rc ; fail : ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; return rc <S2SV_ModEnd> "
4559,"<S2SV_StartBug> UINT16 count ; <S2SV_EndBug> <S2SV_StartBug> newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate -> rectangles , <S2SV_EndBug> ",<S2SV_ModStart> UINT32 <S2SV_ModEnd> <S2SV_ModStart> BITMAP_DATA * 
4560,"<S2SV_StartBug> if ( buf ) <S2SV_EndBug> <S2SV_StartBug> grub_memcpy ( buf , data + pos + real_offset , len ) ; <S2SV_EndBug> ",<S2SV_ModStart> { if ( pos + real_offset + len >= size ) { grub_errno = GRUB_ERR_BAD_FS ; return grub_errno ; } <S2SV_ModStart> } 
4561,<S2SV_StartBug> void * dllhandle ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( COM_CompareExtension ( name , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , name ) ; return NULL ; } "
4562,<S2SV_StartBug> if ( chunk_num > chm -> num_chunks ) return NULL ; <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> 
4563,<S2SV_StartBug> if ( ! el ) <S2SV_EndBug> ,"<S2SV_ModStart> { if ( c -> rbytes > 1024 ) { char * ptr = c -> rcurr ; while ( * ptr == '<S2SV_blank>' ) { ++ ptr ; } if ( strcmp ( ptr , ""get<S2SV_blank>"" ) && strcmp ( ptr , ""gets<S2SV_blank>"" ) ) { conn_set_state ( c , conn_closing ) ; return 1 ; } } return 0 ; } <S2SV_ModEnd> "
4564,"<S2SV_StartBug> rc -> uwbd . task = kthread_run ( uwbd , rc , ""uwbd"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc -> uwbd . task == NULL ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> struct task_struct * <S2SV_ModEnd> <S2SV_ModStart> IS_ERR ( task ) ) { <S2SV_ModStart> = NULL ; <S2SV_ModEnd> <S2SV_ModStart> } else { rc -> uwbd . task = task ; <S2SV_ModEnd> <S2SV_ModStart> } 
4565,<S2SV_StartBug> start = vma -> vm_start ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! mmget_still_valid ( mm ) ) return NULL ; 
4566,<S2SV_StartBug> unix_inflight ( scm -> fp -> fp [ i ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> user , scm -> fp -> "
4567,"<S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_arg ) ) { <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_identifier ( tmp , & arg , arena ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( tmp , & annotation , arena ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_string ( tmp , & type_comment , arena ) ; <S2SV_EndBug> ","<S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""arg\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ; return 1 ; } else { int res ; res = obj2ast_identifier ( tmp , & arg , arena ) ; if ( res != 0 <S2SV_ModEnd> <S2SV_ModStart> Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_annotation , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; annotation = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & annotation <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 <S2SV_ModEnd> <S2SV_ModStart> Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ; return 1 ; } else { int res ; res = obj2ast_int ( tmp , & lineno <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""col_offset\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ; return 1 ; } else { int res ; res = obj2ast_int ( tmp , & col_offset , arena ) ; if ( res != 0 <S2SV_ModEnd> <S2SV_ModStart> Py_CLEAR ( tmp ) <S2SV_ModEnd> "
4568,"<S2SV_StartBug> int count , i ; <S2SV_EndBug> ",<S2SV_ModStart> unsigned 
4569,"<S2SV_StartBug> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <S2SV_EndBug> ","<S2SV_ModStart> elems , e -> "
4570,"<S2SV_StartBug> stat ( options -> in_file , & filestats ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( filestats . st_size < 8 ) { printf ( ""ERROR:<S2SV_blank>Input<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>contain<S2SV_blank>valid<S2SV_blank>plist<S2SV_blank>data.\\n"" ) ; return - 1 ; } "
4571,<S2SV_StartBug> if ( client -> priv -> protocol_timeout ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4572,"<S2SV_StartBug> checkstackp ( L , nextra , where ) ; <S2SV_EndBug> ",<S2SV_ModStart> checkstackGCp <S2SV_ModEnd> 
4573,"<S2SV_StartBug> const MODE_INFO * above_mi = xd -> mi [ - xd -> mi_stride ] ; <S2SV_EndBug> <S2SV_StartBug> const MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ; <S2SV_EndBug> <S2SV_StartBug> const int * bmode_costs = mb -> mbmode_cost ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( t_above , xd -> plane [ 0 ] . above_context , sizeof ( t_above ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( t_left , xd -> plane [ 0 ] . left_context , sizeof ( t_left ) ) ; <S2SV_EndBug> <S2SV_StartBug> MB_PREDICTION_MODE best_mode = DC_PRED ; <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , i ) ; <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , i ) ; <S2SV_EndBug> <S2SV_StartBug> bmode_costs = mb -> y_mode_costs [ A ] [ L ] ; <S2SV_EndBug> ","<S2SV_ModStart> above_mi <S2SV_ModEnd> <S2SV_ModStart> left_mi <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> cpi -> y_mode_costs [ A ] [ L ] ; } this_rd = rd_pick_intra4x4block ( cpi , mb , idy , idx <S2SV_ModEnd> "
4574,"<S2SV_StartBug> if ( strcmp ( ptr , ""get<S2SV_blank>"" ) && strcmp ( ptr , ""gets<S2SV_blank>"" ) ) { <S2SV_EndBug> ","<S2SV_ModStart> ptr - c -> rcurr > 100 || ( strncmp ( ptr , ""get<S2SV_blank>"" , 4 ) && strncmp <S2SV_ModEnd> <S2SV_ModStart> , 5 ) "
4575,"<S2SV_StartBug> int64_t index_pts = FFMAX ( av_rescale ( itime , i , 10000 ) - asf -> hdr . preroll , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( avio_feof ( s -> pb ) ) { ret = AVERROR_INVALIDDATA ; goto end ; } 
4576,<S2SV_StartBug> static int udp_push_pending_frames ( struct sock * sk ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4577,<S2SV_StartBug> for ( pass = 0 ; pass < 10 ; pass ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> || image 
4578,<S2SV_StartBug> if ( source == target ) <S2SV_EndBug> ,"<S2SV_ModStart> vfs_select_inode ( old_dentry , 0 ) == vfs_select_inode ( new_dentry , 0 ) <S2SV_ModEnd> "
4579,"<S2SV_StartBug> bool tsonly ; <S2SV_EndBug> <S2SV_StartBug> sk -> sk_type == SOCK_STREAM ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , tstype ) ; <S2SV_EndBug> ","<S2SV_ModStart> , opt_stats = false <S2SV_ModStart> { <S2SV_ModStart> opt_stats = true ; } <S2SV_ModStart> , opt_stats "
4580,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> _TIFFfree ( working_copy ) ; 
4581,<S2SV_StartBug> struct loop_device * lo = disk -> private_data ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & lo -> lo_ctl_mutex ) ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & loop_index_mutex ) ; __lo_release ( <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart> loop_index_mutex <S2SV_ModEnd> 
4582,<S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug> ,<S2SV_ModStart> ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> 
4583,<S2SV_StartBug> for ( plane = 0 ; inpic -> data [ plane ] && plane < 4 ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && inpic -> data [ plane ] && inpic -> linesize [ plane ] 
4584,"<S2SV_StartBug> re -> flags | RE_FLAGS_SCAN , <S2SV_EndBug> ","<S2SV_ModStart> 0 , "
4585,"<S2SV_StartBug> ikev1_attr_print ( netdissect_options * ndo , const u_char * p , const u_char * ep ) <S2SV_EndBug> <S2SV_StartBug> if ( p [ 0 ] & 0x80 ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> if ( ep < p + totlen ) { <S2SV_EndBug> <S2SV_StartBug> return ep + 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , EXTRACT_16BITS ( & p [ 2 ] ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , EXTRACT_16BITS ( & p [ 2 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> return p + totlen ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ep2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <S2SV_ModStart> } if ( ep2 <S2SV_ModEnd> <S2SV_ModStart> ep2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( & p [ 0 ] ) ; <S2SV_ModStart> if ( ! <S2SV_ModStart> ) { ND_PRINT ( ( ndo , "")"" ) ) ; goto trunc ; } <S2SV_ModEnd> <S2SV_ModStart> totlen - 4 ) ) ; if ( ! <S2SV_ModEnd> <S2SV_ModStart> totlen - 4 ) ) { <S2SV_ModEnd> <S2SV_ModStart> goto trunc ; } } ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_ModStart> trunc : return NULL ; "
4586,"<S2SV_StartBug> ( * sp -> decodepfunc ) ( tif , op0 , occ0 ) ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ",<S2SV_ModStart> return <S2SV_ModStart>  <S2SV_ModEnd> 
4587,"<S2SV_StartBug> inl = i2d ( data , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; goto err ; } "
4588,"<S2SV_StartBug> . match_data . cmp = type -> match , <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> ",<S2SV_ModStart> key_default_cmp <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4589,"<S2SV_StartBug> if ( insn -> code != ( BPF_JMP | BPF_CALL ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! bpf_map_ptr_unpriv ( aux ) ) <S2SV_EndBug> <S2SV_StartBug> if ( bpf_map_ptr_poisoned ( aux ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( prog -> jit_requested && BITS_PER_LONG == 64 && <S2SV_EndBug> <S2SV_StartBug> if ( bpf_map_ptr_poisoned ( aux ) ) <S2SV_EndBug> <S2SV_StartBug> goto patch_call_imm ; <S2SV_EndBug> <S2SV_StartBug> ops = map_ptr -> ops ; <S2SV_EndBug> <S2SV_StartBug> cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ; <S2SV_EndBug> <S2SV_StartBug> BUILD_BUG_ON ( ! __same_type ( ops -> map_lookup_elem , <S2SV_EndBug> ","<S2SV_ModStart> == ( BPF_ALU64 | BPF_ADD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_SUB | BPF_X ) ) { const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X ; const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X ; struct bpf_insn insn_buf [ 16 ] ; struct bpf_insn * patch = & insn_buf [ 0 ] ; bool issrc , isneg ; u32 off_reg <S2SV_ModEnd> <S2SV_ModStart> aux -> alu_state <S2SV_ModEnd> <S2SV_ModStart> isneg = aux -> alu_state & BPF_ALU_NEG_VALUE ; issrc = ( aux -> alu_state & BPF_ALU_SANITIZE ) == BPF_ALU_SANITIZE_SRC ; off_reg = issrc ? insn -> src_reg : insn -> dst_reg ; if ( isneg ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; * patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit - 1 ) ; * patch ++ = BPF_ALU64_REG ( BPF_SUB , BPF_REG_AX , off_reg ) ; * patch ++ = BPF_ALU64_REG ( BPF_OR , BPF_REG_AX , off_reg ) ; * patch ++ = BPF_ALU64_IMM ( BPF_NEG , BPF_REG_AX , 0 ) ; * patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ; if ( issrc ) { * patch ++ = BPF_ALU64_REG ( BPF_AND , BPF_REG_AX , off_reg ) ; insn -> src_reg = BPF_REG_AX ; } else { * patch ++ = BPF_ALU64_REG ( BPF_AND , off_reg , BPF_REG_AX ) ; } if ( isneg ) insn -> code = insn -> code == code_add ? code_sub : code_add ; * patch ++ = * insn ; if ( issrc && isneg ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; cnt = patch - insn_buf <S2SV_ModEnd> <S2SV_ModStart> insn -> code != ( BPF_JMP | BPF_CALL ) ) continue ; if ( insn -> src_reg == BPF_PSEUDO_CALL ) continue ; if ( insn -> imm == BPF_FUNC_get_route_realm ) prog -> dst_needed = 1 ; if ( insn -> imm == BPF_FUNC_get_prandom_u32 ) bpf_user_rnd_init_once ( ) ; if ( insn -> imm == BPF_FUNC_override_return ) prog -> kprobe_override = 1 ; if ( insn -> imm == BPF_FUNC_tail_call ) { prog -> cb_access = 1 ; env -> prog -> aux -> stack_depth = MAX_BPF_STACK ; env -> prog -> aux -> max_pkt_offset = MAX_PACKET_OFF ; insn -> imm = 0 ; insn -> code = BPF_JMP | BPF_TAIL_CALL ; <S2SV_ModEnd> <S2SV_ModStart> ! bpf_map_ptr_unpriv ( aux ) ) continue ; if ( <S2SV_ModStart> { verbose ( env , ""tail_call<S2SV_blank>abusing<S2SV_blank>map_ptr\\n"" ) ; return - EINVAL ; } <S2SV_ModEnd> <S2SV_ModStart> insn_buf [ 0 ] = BPF_JMP_IMM ( BPF_JGE , BPF_REG_3 , map_ptr -> max_entries , 2 ) ; insn_buf [ 1 ] = BPF_ALU32_IMM ( BPF_AND , BPF_REG_3 , container_of <S2SV_ModEnd> <S2SV_ModStart> struct bpf_array , map ) -> index_mask ) ; insn_buf [ 2 ] = * insn ; cnt = 3 ; <S2SV_ModEnd> <S2SV_ModStart> if ( prog -> jit_requested && BITS_PER_LONG == 64 && ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem ) ) { aux = & env -> insn_aux_data [ i + delta ] ; if ( bpf_map_ptr_poisoned ( aux ) ) goto patch_call_imm ; map_ptr = BPF_MAP_PTR ( aux -> map_state ) ; ops = map_ptr -> ops ; if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) { cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ; if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env , ""bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\n"" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } "
4590,<S2SV_StartBug> iterator = rfbGetClientIterator ( rfbScreen ) ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( ( char * ) & sct , 0 , sizeof ( sct ) ) ; "
4591,"<S2SV_StartBug> if ( Stream_GetRemainingLength ( s ) < 2 ) <S2SV_EndBug> <S2SV_StartBug> Stream_Read_UINT16 ( s , * length ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * length == 0x8000 ) <S2SV_EndBug> <S2SV_StartBug> rdp_read_flow_control_pdu ( s , type ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( size_t ) * length - 2 ) > Stream_GetRemainingLength ( s ) ) <S2SV_EndBug> <S2SV_StartBug> if ( * length > 4 ) <S2SV_EndBug> ",<S2SV_ModStart> UINT16 len ; <S2SV_ModStart> len ) ; * length = len <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> if ( ! <S2SV_ModStart> ) return FALSE <S2SV_ModStart> len < 4 ) || ( ( len <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> len <S2SV_ModEnd> 
4592,"<S2SV_StartBug> err = ioctl ( sk , SIOCGIFHWADDR , & ifr ) ; <S2SV_EndBug> <S2SV_StartBug> err = ioctl ( sk , SIOCSIFHWADDR , ( caddr_t ) & ifr ) ; <S2SV_EndBug> <S2SV_StartBug> err = ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
4593,"<S2SV_StartBug> int get_down2_steps ( int in_length , int out_length ) { <S2SV_EndBug> ",<S2SV_ModStart> static 
4594,<S2SV_StartBug> if ( * rsize >= 17 && rdesc [ 11 ] == 0x3c && rdesc [ 12 ] == 0x02 ) { <S2SV_EndBug> ,<S2SV_ModStart> 18 <S2SV_ModEnd> 
4595,<S2SV_StartBug> prefix = report [ i ] ; <S2SV_EndBug> <S2SV_StartBug> case 3 : <S2SV_EndBug> ,"<S2SV_ModStart> ++ ] ; size = ( 1U << PREF_SIZE ( prefix ) ) >> 1 ; if ( i + size > length ) { dev_err ( ddev , ""Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>(need<S2SV_blank>%d,<S2SV_blank>have<S2SV_blank>%d)\\n"" , i + size , length ) ; break ; } <S2SV_ModEnd> <S2SV_ModStart> 4 : <S2SV_ModEnd> "
4596,<S2SV_StartBug> # ifndef PGEN <S2SV_EndBug> ,<S2SV_ModStart> if ( * flags & PyPARSE_TYPE_COMMENTS ) { tok -> type_comments = 1 ; } 
4597,"<S2SV_StartBug> static void set_segment_id ( VP9_COMMON * cm , BLOCK_SIZE bsize , <S2SV_EndBug> <S2SV_StartBug> const int mi_offset = mi_row * cm -> mi_cols + mi_col ; <S2SV_EndBug> <S2SV_StartBug> for ( y = 0 ; y < ymis ; y ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( x = 0 ; x < xmis ; x ++ ) <S2SV_EndBug> <S2SV_StartBug> cm -> last_frame_seg_map [ mi_offset + y * cm -> mi_cols + x ] = segment_id ; <S2SV_EndBug> ","<S2SV_ModStart> int mi_offset , int x_mis , int y_mis <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> y_mis <S2SV_ModEnd> <S2SV_ModStart> x_mis <S2SV_ModEnd> <S2SV_ModStart> current_frame_seg_map <S2SV_ModEnd> "
4598,"<S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> <S2SV_StartBug> key -> reject_error = - error ; <S2SV_EndBug> ","<S2SV_ModStart> key -> state == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> <S2SV_ModStart> mark_key_instantiated ( key , - error <S2SV_ModEnd> "
4599,"<S2SV_StartBug> size_t i , maxcount ; <S2SV_EndBug> <S2SV_StartBug> ssi -> si_count = CDF_TOLE2 ( si -> si_count ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < CDF_TOLE4 ( si -> si_count ) ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> info , count , & maxcount ) == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> CDF_TOLE4 <S2SV_ModEnd> <S2SV_ModStart> if ( cdf_read_property_info ( sst , h , CDF_TOLE4 ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4600,<S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 1 ) <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> . ptr [ <S2SV_ModEnd> <S2SV_ModStart> . indx <S2SV_ModEnd> 
4601,"
","
"
4602,"<S2SV_StartBug> Total += vp8_mse16x16 ( src + j , source -> y_stride , <S2SV_EndBug> ",<S2SV_ModStart> vpx_mse16x16 <S2SV_ModEnd> 
4603,<S2SV_StartBug> calldata -> arg . open_flags = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> fmode <S2SV_ModEnd> 
4604,"<S2SV_StartBug> ext4_io_end_t * io ; <S2SV_EndBug> <S2SV_StartBug> if ( list_empty ( & EXT4_I ( inode ) -> i_completed_io_list ) ) <S2SV_EndBug> <S2SV_StartBug> while ( ! list_empty ( & EXT4_I ( inode ) -> i_completed_io_list ) ) { <S2SV_EndBug> <S2SV_StartBug> io = list_entry ( EXT4_I ( inode ) -> i_completed_io_list . next , <S2SV_EndBug> <S2SV_StartBug> ret = ext4_end_io_nolock ( io ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ret2 < 0 ) ? ret2 : 0 ; <S2SV_EndBug> ","<S2SV_ModStart> ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; unsigned long flags <S2SV_ModStart> ei <S2SV_ModEnd> <S2SV_ModStart> spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModStart> ei <S2SV_ModEnd> <S2SV_ModStart> ei <S2SV_ModEnd> <S2SV_ModStart> spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModStart> ) ; spin_lock_irqsave ( & ei -> i_completed_io_lock , flags <S2SV_ModStart> spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ; "
4605,"<S2SV_StartBug> unsigned char type , void * * ptr ) <S2SV_EndBug> <S2SV_StartBug> if ( header -> bLength < 2 ) { <S2SV_EndBug> <S2SV_StartBug> if ( header -> bDescriptorType == type ) { <S2SV_EndBug> ","<S2SV_ModStart> , size_t minsize <S2SV_ModStart> || header -> bLength > size <S2SV_ModStart> && header -> bLength >= minsize "
4606,"<S2SV_StartBug> sprintf ( outfilename , ""%s_%05d.j2k"" , argv [ 2 ] , snum ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing\\n"" , outfilename ) ; <S2SV_EndBug> ","<S2SV_ModStart> { int num = snprintf <S2SV_ModEnd> <S2SV_ModStart> sizeof ( outfilename ) , <S2SV_ModStart> snum ) ; if ( num >= sizeof ( outfilename ) ) { fprintf ( stderr , ""maximum<S2SV_blank>length<S2SV_blank>of<S2SV_blank>output<S2SV_blank>prefix<S2SV_blank>exceeded\\n"" ) ; free ( frame_codestream ) ; return 1 ; } } <S2SV_ModEnd> <S2SV_ModStart> ) ; free ( frame_codestream "
4607,"<S2SV_StartBug> if ( j >= length ) return - 1 ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( cp , packet + j , label_len ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( j + label_len > length ) return - 1 ; 
4608,"<S2SV_StartBug> if ( l_strnstart ( ""MSG"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""RPY<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""ERR<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""ANS<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""NUL<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""SEQ<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""END"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> ","<S2SV_ModStart> ndo , <S2SV_ModStart> ndo , <S2SV_ModStart> ndo , <S2SV_ModStart> ndo , <S2SV_ModStart> ndo , <S2SV_ModStart> ndo , <S2SV_ModStart> ndo , "
4609,<S2SV_StartBug> subsampling_dx = parameters -> subsampling_dx ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( image_height != 0 && image_width > 10000000 / image_height / numcomps ) { char ch ; OPJ_UINT64 expected_file_size = ( OPJ_UINT64 ) image_width * image_height * numcomps ; long curpos = ftell ( f ) ; if ( expected_file_size > ( OPJ_UINT64 ) INT_MAX ) { expected_file_size = ( OPJ_UINT64 ) INT_MAX ; } fseek ( f , ( long ) expected_file_size - 1 , SEEK_SET ) ; if ( fread ( & ch , 1 , 1 , f ) != 1 ) { fclose ( f ) ; return NULL ; } fseek ( f , curpos , SEEK_SET ) ; } "
4610,"<S2SV_StartBug> snprintf ( rcomp . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""compression"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> ""compression"" , sizeof ( rcomp . type ) <S2SV_ModEnd> "
4611,"<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_lock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4612,<S2SV_StartBug> var = vp8_variance16x16 <S2SV_EndBug> ,<S2SV_ModStart> vpx_variance16x16 <S2SV_ModEnd> 
4613,"<S2SV_StartBug> int mongo_env_read_socket ( mongo * conn , void * buf , int len ) { <S2SV_EndBug> <S2SV_StartBug> int sent = recv ( conn -> sock , cbuf , len , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> 
4614,<S2SV_StartBug> char added ; <S2SV_EndBug> <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4615,<S2SV_StartBug> vpx_free ( cr ) ; <S2SV_EndBug> ,<S2SV_ModStart> -> last_coded_q_map ) ; vpx_free ( cr 
4616,<S2SV_StartBug> return in ; <S2SV_EndBug> ,<S2SV_ModStart> NULL <S2SV_ModEnd> 
4617,<S2SV_StartBug> value [ n ] >= min && value [ n ] <= max && <S2SV_EndBug> <S2SV_StartBug> && field -> usage [ field -> value [ n ] - min ] . hid <S2SV_EndBug> <S2SV_StartBug> && field -> usage [ value [ n ] - min ] . hid <S2SV_EndBug> ,<S2SV_ModStart> && value [ n ] - min < field -> maxusage <S2SV_ModStart> value [ n ] - min < field -> maxusage && field -> <S2SV_ModStart> value [ n ] - min < field -> maxusage && 
4618,<S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) <S2SV_EndBug> ,<S2SV_ModStart> 4 <S2SV_ModEnd> 
4619,<S2SV_StartBug> if ( nbytes < sizeof ( * hwrpb ) ) <S2SV_EndBug> ,<S2SV_ModStart> > <S2SV_ModEnd> 
4620,"<S2SV_StartBug> list_del ( & key -> graveyard_link ) ; <S2SV_EndBug> <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && <S2SV_EndBug> <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) <S2SV_EndBug> ",<S2SV_ModStart> short state = key -> state ; <S2SV_ModStart> state == KEY_IS_POSITIVE && <S2SV_ModEnd> <S2SV_ModStart> state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> 
4621,<S2SV_StartBug> PCI_DMA_FROMDEVICE ) ) <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree_skb ( skb ) ; <S2SV_ModStart> } 
4622,<S2SV_StartBug> assert ( bi != NULL ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( bi == NULL ) { pr_err ( ""%s:<S2SV_blank>pci<S2SV_blank>[%s]<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>bus<S2SV_blank>%d<S2SV_blank>info!\\n"" , __func__ , dev -> name , dev -> bus ) ; return ; } <S2SV_ModEnd> "
4623,"<S2SV_StartBug> if ( mount ( console -> name , path , ""none"" , MS_BIND , 0 ) ) { <S2SV_EndBug> ","<S2SV_ModStart> safe_mount ( console -> name , path , ""none"" , MS_BIND , 0 , rootfs -> mount <S2SV_ModEnd> "
4624,<S2SV_StartBug> if ( wp -> listening_socket != STDIN_FILENO ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4625,<S2SV_StartBug> scratch = newscratch = malloc ( 2 * data -> set . buffer_size ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> UPLOAD_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> DEBUGASSERT ( UPLOAD_BUFSIZE >= nread ) ; 
4626,"<S2SV_StartBug> struct vp9_ref_frame ref ; <S2SV_EndBug> <S2SV_StartBug> vpx_codec_control ( & stream -> encoder , VP9_GET_REFERENCE , & ref ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_codec_control ( & stream -> decoder , VP9_GET_REFERENCE , & ref ) ; <S2SV_EndBug> <S2SV_StartBug> find_mismatch ( & enc_img , & dec_img , y , u , v ) ; <S2SV_EndBug> ","<S2SV_ModStart> ref_enc , ref_dec ; ref_enc <S2SV_ModEnd> <S2SV_ModStart> ref_dec . idx = 0 ; <S2SV_ModStart> ref_enc ) ; enc_img = ref_enc <S2SV_ModEnd> <S2SV_ModStart> ref_dec ) ; dec_img = ref_dec . img ; # if CONFIG_VP9_HIGHBITDEPTH if ( ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) != ( dec_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ) { if ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { vpx_img_alloc ( & enc_img , enc_img . fmt - VPX_IMG_FMT_HIGHBITDEPTH , enc_img . d_w , enc_img . d_h , 16 ) ; vpx_img_truncate_16_to_8 ( & enc_img , & ref_enc . img ) ; } if ( dec_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { vpx_img_alloc ( & dec_img , dec_img . fmt - VPX_IMG_FMT_HIGHBITDEPTH , dec_img . d_w , dec_img . d_h , 16 ) ; vpx_img_truncate_16_to_8 ( & dec_img , & ref_dec . img ) ; } } # endif <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { find_mismatch_high ( & enc_img , & dec_img , y , u , v ) ; } else { <S2SV_ModStart> } # else find_mismatch ( & enc_img , & dec_img , y , u , v ) ; # endif "
4627,"<S2SV_StartBug> static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * image ) <S2SV_EndBug> <S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> GetMagickPixelPacket ( image , & pixels [ i ] [ j ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> images ) { const Image * next ; <S2SV_ModEnd> <S2SV_ModStart> columns , <S2SV_ModStart> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> images <S2SV_ModEnd> "
4628,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> horDiff16 ( tif , cp0 , cc ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( ! <S2SV_ModStart> ) return 0 <S2SV_ModStart> return 1 ; 
4629,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> hrtimer_try_to_cancel ( & stime -> hrt ) ; 
4630,<S2SV_StartBug> if ( f -> map & ( 1 << rec ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> rec >= f -> num ) { ldm_error ( ""REC<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>NUM<S2SV_blank>value<S2SV_blank>(%d)"" , rec , f -> num ) ; return false ; } if ( "
4631,"<S2SV_StartBug> static void estimate_ref_frame_costs ( VP9_COMP * cpi , int segment_id , <S2SV_EndBug> <S2SV_StartBug> vp9_prob * comp_mode_p ) { <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ref_costs_comp , 0 , MAX_REF_FRAMES * sizeof ( * ref_costs_comp ) ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob intra_inter_p = vp9_get_intra_inter_prob ( cm , xd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob comp_inter_p = 128 ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob ref_single_p1 = vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob ref_single_p2 = vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob ref_comp_p = vp9_get_pred_prob_comp_ref_p ( cm , xd ) ; <S2SV_EndBug> ","<S2SV_ModStart> const VP9_COMMON * cm , const MACROBLOCKD * xd , <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> int seg_ref_active = segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ; if ( seg_ref_active ) { memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> "
4632,"<S2SV_StartBug> int i , j ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> # ifdef TEST_SUPPLEMENTAL_SUPERFRAME_DATA uint8_t marker_test = 0xc0 ; int mag_test = 2 ; int frames_test = 4 ; int index_sz_test = 2 + mag_test * frames_test ; marker_test |= frames_test - 1 ; marker_test |= ( mag_test - 1 ) << 3 ; * x ++ = marker_test ; for ( i = 0 ; i < mag_test * frames_test ; ++ i ) * x ++ = 0 ; * x ++ = marker_test ; ctx -> pending_cx_data_sz += index_sz_test ; printf ( ""Added<S2SV_blank>supplemental<S2SV_blank>superframe<S2SV_blank>data\\n"" ) ; # endif <S2SV_ModStart> # ifdef TEST_SUPPLEMENTAL_SUPERFRAME_DATA index_sz += index_sz_test ; # endif "
4633,<S2SV_StartBug> if ( c -> chunk_size == 0 ) <S2SV_EndBug> <S2SV_StartBug> else { <S2SV_EndBug> ,<S2SV_ModStart> <= 0 ) { c -> chunk_size = 0 ; goto fail ; } <S2SV_ModEnd> <S2SV_ModStart> av_assert0 ( len <= c -> chunk_size ) ; 
4634,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> { ND_TCHECK ( <S2SV_ModEnd> <S2SV_ModStart> ; ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } <S2SV_ModEnd> "
4635,<S2SV_StartBug> struct f2fs_sb_info * sbi = F2FS_I_SB ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! i_ext || ! i_ext -> len ) <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> ,"<S2SV_ModStart> bool ret = __f2fs_init_extent_tree ( inode , i_ext <S2SV_ModEnd> <S2SV_ModStart> F2FS_I ( inode ) -> extent_tree ) set_inode_flag ( inode , FI_NO_EXTENT <S2SV_ModEnd> <S2SV_ModStart> ret <S2SV_ModEnd> "
4636,"<S2SV_StartBug> # define PCDGetBits ( n ) { sum = ( sum << n ) & 0xffffffff ; bits -= n ; while ( bits <= 24 ) { if ( p >= ( buffer + 0x800 ) ) { count = ReadBlob ( image , 0x800 , buffer ) ; p = buffer ; } sum |= ( ( unsigned int ) ( * p ) << ( 24 - bits ) ) ; bits += 8 ; p ++ ; } } <S2SV_EndBug> <S2SV_StartBug> ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , <S2SV_EndBug> <S2SV_StartBug> buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> for ( j = 0 ; j < i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ; <S2SV_ModStart> ) ; for ( j = 0 ; j <= i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] 
4637,"<S2SV_StartBug> int i , y ; <S2SV_EndBug> <S2SV_StartBug> fwrite ( buf , 1 , w , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH const int bytes_per_sample = ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) ; # else const int bytes_per_sample = 1 ; # endif <S2SV_ModStart> bytes_per_sample <S2SV_ModEnd> 
4638,<S2SV_StartBug> uint8_t clear_buffer [ 9 ] ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ( profile >= 2 && data_sz <= 1 ) || data_sz < 1 ) <S2SV_EndBug> <S2SV_StartBug> if ( data_sz <= 8 ) <S2SV_EndBug> ,<S2SV_ModStart> 10 <S2SV_ModEnd> <S2SV_ModStart> if ( data_sz < 1 ) return VPX_CODEC_UNSUP_BITSTREAM ; <S2SV_ModStart> vpx_rb_read_bit ( & rb ) ) { if ( profile > <S2SV_ModEnd> <S2SV_ModStart> < 2 ) return VPX_CODEC_UNSUP_BITSTREAM ; <S2SV_ModEnd> <S2SV_ModStart> < 10 <S2SV_ModEnd> 
4639,<S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> read_config_file ( ) ; <S2SV_EndBug> <S2SV_StartBug> umask ( 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> umask ( 022 ) ; <S2SV_ModStart> global_data -> umask = umask_val ; <S2SV_ModStart>  <S2SV_ModEnd> 
4640,"<S2SV_StartBug> ut8 * directory_base ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( int ) obj -> hdr -> number_of_streams ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> entry = ( struct minidump_directory * ) ( directory_base + ( i * sizeof ( struct minidump_directory ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> r_bin_mdmp_init_directory_entry ( obj , entry ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct minidump_directory entry <S2SV_ModEnd> <S2SV_ModStart> ut64 rvadir = obj -> hdr -> stream_directory_rva ; <S2SV_ModStart> ut32 delta = <S2SV_ModEnd> <S2SV_ModStart> ; int r = r_buf_read_at ( obj -> b , rvadir + delta , ( ut8 * ) & entry , sizeof ( struct minidump_directory <S2SV_ModStart> if ( r ) { <S2SV_ModStart> & <S2SV_ModStart> } "
4641,"<S2SV_StartBug> Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; return ; } if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) { Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".cfg\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" "
4642,<S2SV_StartBug> return MS_FALSE ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( strchr ( timestring , '\\'' ) || strchr ( timestring , '\\\\' ) ) { msSetError ( MS_MISCERR , ""Invalid<S2SV_blank>time<S2SV_blank>filter."" , ""msPostGISLayerSetTimeFilter()"" ) ; return MS_FALSE ; } "
4643,<S2SV_StartBug> struct kvm_lapic * apic = vcpu -> arch . apic ; <S2SV_EndBug> <S2SV_StartBug> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> kvm_write_guest_cached ( vcpu -> kvm , & <S2SV_ModEnd> <S2SV_ModStart> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> "
4644,<S2SV_StartBug> gint * ac ; <S2SV_EndBug> ,<S2SV_ModStart> ; g_assert ( box_width > 0 ) 
4645,<S2SV_StartBug> struct tcp_sock_t * tcp_socket ; <S2SV_EndBug> <S2SV_StartBug> while ( ( tcp_socket = tcp_open ( desired_port ) ) == NULL && <S2SV_EndBug> <S2SV_StartBug> g_options . only_desired_port == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> uint16_t real_port = tcp_port_number_get ( tcp_socket ) ; <S2SV_EndBug> <S2SV_StartBug> uint16_t pid ; <S2SV_EndBug> <S2SV_StartBug> args -> tcp = tcp_conn_accept ( tcp_socket ) ; <S2SV_EndBug> <S2SV_StartBug> cleanup_usb : <S2SV_EndBug> ,"<S2SV_ModStart> = NULL , * tcp6_socket = NULL ; for ( ; ; ) { <S2SV_ModEnd> <S2SV_ModStart> ; tcp6_socket = tcp6_open ( desired_port ) ; if ( tcp_socket || tcp6_socket || <S2SV_ModEnd> <S2SV_ModStart> ) break ; <S2SV_ModEnd> <S2SV_ModStart> NOTE ( ""Access<S2SV_blank>to<S2SV_blank>desired<S2SV_blank>port<S2SV_blank>failed,<S2SV_blank>trying<S2SV_blank>alternative<S2SV_blank>port<S2SV_blank>%d"" , desired_port ) ; } if ( tcp_socket == NULL && tcp6_socket <S2SV_ModEnd> <S2SV_ModStart> ; if ( tcp_socket ) real_port <S2SV_ModStart> ) ; else real_port = tcp_port_number_get ( tcp6_socket <S2SV_ModStart> NOTE ( ""Port:<S2SV_blank>%d,<S2SV_blank>IPv4<S2SV_blank>%savailable,<S2SV_blank>IPv6<S2SV_blank>%savailable"" , real_port , tcp_socket ? """" : ""not<S2SV_blank>"" , tcp6_socket ? """" : ""not<S2SV_blank>"" ) ; <S2SV_ModStart> tcp_conn_select ( tcp_socket , tcp6_socket <S2SV_ModEnd> <S2SV_ModStart> if ( tcp6_socket != NULL ) tcp_close ( tcp6_socket ) ; "
4646,<S2SV_StartBug> static int done ; <S2SV_EndBug> <S2SV_StartBug> for ( c = 'a' ; c <= 'z' ; c ++ ) <S2SV_EndBug> ,<S2SV_ModStart> = 0 <S2SV_ModStart> 0 ; c < CHAR_SET_SIZE ; ++ c ) if ( ISALNUM ( c ) <S2SV_ModEnd> 
4647,"<S2SV_StartBug> YV12_BUFFER_CONFIG * golden_ref = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( frame_stats -> mb_stats , 0 , <S2SV_EndBug> <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; assert ( golden_ref != NULL <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> vpx_clear_system_state <S2SV_ModEnd> 
4648,<S2SV_StartBug> dev -> product_id = le16_to_cpu ( udev -> descriptor . idProduct ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( iface_desc -> desc . bNumEndpoints < 1 ) { dev_err ( & interface -> dev , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n"" ) ; retval = - EINVAL ; goto error ; } "
4649,"<S2SV_StartBug> exit_client ( client_p , client_p , client_p , ""Mixing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>protocol"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; return 0 ; } if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) { exit_client ( client_p , client_p , client_p , ""Malformed<S2SV_blank>AUTHENTICATE"" "
4650,"<S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( rsvp_obj_ctype ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps"" , <S2SV_EndBug> ",<S2SV_ModStart> switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; 
4651,<S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_namelen >= sizeof ( struct sockaddr_mISDN ) ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_namelen ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> msg_name ) { struct sockaddr_mISDN * maddr = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = sizeof ( * maddr ) <S2SV_ModEnd> 
4652,"<S2SV_StartBug> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> mark_key_instantiated ( key , 0 <S2SV_ModEnd> "
4653,"<S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> ","<S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) , & final ) ; rcu_read_unlock ( <S2SV_ModEnd> "
4654,<S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_namelen >= sizeof ( struct sockaddr_mISDN ) ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_namelen ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> msg_name ) { struct sockaddr_mISDN * maddr = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = sizeof ( * maddr ) <S2SV_ModEnd> 
4655,<S2SV_StartBug> bool slow ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * addr_len = sizeof ( * sin ) ; 
4656,<S2SV_StartBug> register const struct hello6 * hellop = ( const struct hello6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; ND_TCHECK_32BITS ( & hellop -> hello_options 
4657,"<S2SV_StartBug> case 0 : <S2SV_EndBug> <S2SV_StartBug> ( intmax_t ) rsrc -> uncompressed_size ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( mp , p , bytes_avail ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( rsrc -> uncompressed_size != rsrc -> compressed_size ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Malformed<S2SV_blank>OS<S2SV_blank>X<S2SV_blank>metadata<S2SV_blank>entry:<S2SV_blank>inconsistent<S2SV_blank>size"" ) ; return ( ARCHIVE_FATAL ) ; } <S2SV_ModStart> ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> compressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes"" , ( intmax_t ) rsrc -> compressed_size <S2SV_ModStart> if ( ( size_t ) bytes_avail > metadata_bytes ) bytes_avail = metadata_bytes ; "
4658,<S2SV_StartBug> for ( i = 0 ; i < oxcf -> number_of_layers ; i ++ ) <S2SV_EndBug> ,<S2SV_ModStart> && i < VPX_TS_MAX_LAYERS ; ++ i <S2SV_ModEnd> 
4659,"<S2SV_StartBug> return aa_audit ( AUDIT_APPARMOR_DENIED , NULL , GFP_KERNEL , <S2SV_EndBug> ","<S2SV_ModStart> __aa_current_profile ( ) , GFP_KERNEL , & sa , NULL <S2SV_ModEnd> "
4660,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>MTU<S2SV_blank>size<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 4 ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( tlv_len < 6 ) { return hexdump ; } 
4661,"<S2SV_StartBug> res = ctx -> iface -> dec . set_fb_fn ( ctx -> priv -> alg_priv , cb_get , cb_release , <S2SV_EndBug> ",<S2SV_ModStart> get_alg_priv ( ctx ) <S2SV_ModEnd> 
4662,"<S2SV_StartBug> int res , ret ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( uaddr == uaddr2 ) return - EINVAL 
4663,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> tty -> disc_data = NULL ; tty -> receive_room = 0 ; 
4664,<S2SV_StartBug> if ( n <= 0 ) return ( n ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4665,<S2SV_StartBug> newsk -> sk_mark = inet_rsk ( req ) -> ir_mark ; <S2SV_EndBug> ,<S2SV_ModStart> inet_sk ( newsk ) -> mc_list = NULL ; 
4666,<S2SV_StartBug> BUG_ON ( sk != asoc -> base . sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> goto do_error 
4667,<S2SV_StartBug> dlen -= 2 ; <S2SV_EndBug> ,<S2SV_ModStart> 3 <S2SV_ModEnd> 
4668,"<S2SV_StartBug> ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; <S2SV_EndBug> ","<S2SV_ModStart> ep2 <S2SV_ModEnd> <S2SV_ModStart> if ( cp == NULL ) { ND_PRINT ( ( ndo , "")"" ) ) ; goto trunc ; } "
4669,"<S2SV_StartBug> static void fdct8 ( const int16_t * input , int16_t * output ) { <S2SV_EndBug> <S2SV_StartBug> int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; <S2SV_EndBug> <S2SV_StartBug> int t0 , t1 , t2 , t3 ; <S2SV_EndBug> <S2SV_StartBug> output [ 0 ] = fdct_round_shift ( t0 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 2 ] = fdct_round_shift ( t2 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 4 ] = fdct_round_shift ( t1 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 6 ] = fdct_round_shift ( t3 ) ; <S2SV_EndBug> <S2SV_StartBug> t2 = fdct_round_shift ( t0 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 1 ] = fdct_round_shift ( t0 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 3 ] = fdct_round_shift ( t2 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 5 ] = fdct_round_shift ( t1 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 7 ] = fdct_round_shift ( t3 ) ; <S2SV_EndBug> ","<S2SV_ModStart> tran_low_t * input , tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t t0 , t1 , t2 , t3 ; tran_high_t <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) fdct_round_shift ( t0 ) ; t3 = ( tran_low_t ) <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) "
4670,"<S2SV_StartBug> size2 , mime ) ; <S2SV_EndBug> ",<S2SV_ModStart> NULL <S2SV_ModEnd> 
4671,<S2SV_StartBug> name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ; <S2SV_EndBug> ,<S2SV_ModStart> rmtvaluelen <S2SV_ModEnd> 
4672,"<S2SV_StartBug> int mi_row , int mi_col , vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> const MODE_INFO * above_mi = xd -> mi [ - cm -> mi_stride ] ; <S2SV_EndBug> <S2SV_StartBug> const MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ; <S2SV_EndBug> <S2SV_StartBug> mbmi -> segment_id = read_intra_segment_id ( cm , xd , mi_row , mi_col , r ) ; <S2SV_EndBug> <S2SV_StartBug> mbmi -> tx_size = read_tx_size ( cm , xd , cm -> tx_mode , bsize , 1 , r ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> above_mi <S2SV_ModEnd> <S2SV_ModStart> left_mi <S2SV_ModEnd> <S2SV_ModStart> const int mi_offset = mi_row * cm -> mi_cols + mi_col ; const int bw = xd -> plane [ 0 ] . n4_w >> 1 ; const int bh = xd -> plane [ 0 ] . n4_h >> 1 ; const int x_mis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int y_mis = MIN ( cm -> mi_rows - mi_row , bh ) ; <S2SV_ModStart> mi_offset , x_mis , y_mis <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4673,"
","
"
4674,<S2SV_StartBug> if ( len <= 0 ) <S2SV_EndBug> <S2SV_StartBug> len -= bytes ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned short prev_bi_vcnt = bio -> bi_vcnt ; <S2SV_ModStart> if ( bio -> bi_vcnt == prev_bi_vcnt ) put_page ( pages [ j ] ) ; 
4675,"<S2SV_StartBug> length ; <S2SV_EndBug> <S2SV_StartBug> sun_pixels = sun_data ; <S2SV_EndBug> <S2SV_StartBug> ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> height , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( sun_info . type == RT_ENCODED ) <S2SV_ModStart>  <S2SV_ModEnd> "
4676,"<S2SV_StartBug> if ( pos >= GDT_ENTRY_TLS_ENTRIES * sizeof ( struct user_desc ) || <S2SV_EndBug> <S2SV_StartBug> set_tls_desc ( target , <S2SV_EndBug> ",<S2SV_ModStart> int i ; <S2SV_ModStart> for ( i = 0 ; i < count / sizeof ( struct user_desc ) ; i ++ ) if ( ! tls_desc_okay ( info + i ) ) return - EINVAL ; 
4677,"<S2SV_StartBug> blkcnt = xfs_attr3_rmt_blocks ( mp , args -> valuelen ) ; <S2SV_EndBug> <S2SV_StartBug> valuelen = args -> valuelen ; <S2SV_EndBug> ",<S2SV_ModStart> rmtvaluelen <S2SV_ModEnd> <S2SV_ModStart> rmtvaluelen <S2SV_ModEnd> 
4678,"<S2SV_StartBug> set_exception_intercept ( svm , AC_VECTOR ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; set_exception_intercept ( svm , DB_VECTOR "
4679,<S2SV_StartBug> H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ; <S2SV_EndBug> ,<S2SV_ModStart> ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; 
4680,"<S2SV_StartBug> COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! COM_CompareExtension ( filename , "".txt"" ) ) { Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".txt\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" ) ; return ; } "
4681,<S2SV_StartBug> int strindex = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> 
4682,<S2SV_StartBug> if ( old -> curframe != cur -> curframe ) <S2SV_EndBug> ,<S2SV_ModStart> ) return false ; if ( old -> speculative && ! cur -> speculative 
4683,"<S2SV_StartBug> set_exception_intercept ( svm , AC_VECTOR ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; set_exception_intercept ( svm , DB_VECTOR "
4684,"<S2SV_StartBug> if ( insn -> code != ( BPF_JMP | BPF_CALL ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! bpf_map_ptr_unpriv ( aux ) ) <S2SV_EndBug> <S2SV_StartBug> if ( bpf_map_ptr_poisoned ( aux ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( prog -> jit_requested && BITS_PER_LONG == 64 && <S2SV_EndBug> <S2SV_StartBug> if ( bpf_map_ptr_poisoned ( aux ) ) <S2SV_EndBug> <S2SV_StartBug> goto patch_call_imm ; <S2SV_EndBug> <S2SV_StartBug> ops = map_ptr -> ops ; <S2SV_EndBug> <S2SV_StartBug> cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ; <S2SV_EndBug> <S2SV_StartBug> BUILD_BUG_ON ( ! __same_type ( ops -> map_lookup_elem , <S2SV_EndBug> ","<S2SV_ModStart> == ( BPF_ALU64 | BPF_ADD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_SUB | BPF_X ) ) { const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X ; const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X ; struct bpf_insn insn_buf [ 16 ] ; struct bpf_insn * patch = & insn_buf [ 0 ] ; bool issrc , isneg ; u32 off_reg <S2SV_ModEnd> <S2SV_ModStart> aux -> alu_state <S2SV_ModEnd> <S2SV_ModStart> isneg = aux -> alu_state & BPF_ALU_NEG_VALUE ; issrc = ( aux -> alu_state & BPF_ALU_SANITIZE ) == BPF_ALU_SANITIZE_SRC ; off_reg = issrc ? insn -> src_reg : insn -> dst_reg ; if ( isneg ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; * patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit - 1 ) ; * patch ++ = BPF_ALU64_REG ( BPF_SUB , BPF_REG_AX , off_reg ) ; * patch ++ = BPF_ALU64_REG ( BPF_OR , BPF_REG_AX , off_reg ) ; * patch ++ = BPF_ALU64_IMM ( BPF_NEG , BPF_REG_AX , 0 ) ; * patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ; if ( issrc ) { * patch ++ = BPF_ALU64_REG ( BPF_AND , BPF_REG_AX , off_reg ) ; insn -> src_reg = BPF_REG_AX ; } else { * patch ++ = BPF_ALU64_REG ( BPF_AND , off_reg , BPF_REG_AX ) ; } if ( isneg ) insn -> code = insn -> code == code_add ? code_sub : code_add ; * patch ++ = * insn ; if ( issrc && isneg ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; cnt = patch - insn_buf <S2SV_ModEnd> <S2SV_ModStart> insn -> code != ( BPF_JMP | BPF_CALL ) ) continue ; if ( insn -> src_reg == BPF_PSEUDO_CALL ) continue ; if ( insn -> imm == BPF_FUNC_get_route_realm ) prog -> dst_needed = 1 ; if ( insn -> imm == BPF_FUNC_get_prandom_u32 ) bpf_user_rnd_init_once ( ) ; if ( insn -> imm == BPF_FUNC_override_return ) prog -> kprobe_override = 1 ; if ( insn -> imm == BPF_FUNC_tail_call ) { prog -> cb_access = 1 ; env -> prog -> aux -> stack_depth = MAX_BPF_STACK ; env -> prog -> aux -> max_pkt_offset = MAX_PACKET_OFF ; insn -> imm = 0 ; insn -> code = BPF_JMP | BPF_TAIL_CALL ; <S2SV_ModEnd> <S2SV_ModStart> ! bpf_map_ptr_unpriv ( aux ) ) continue ; if ( <S2SV_ModStart> { verbose ( env , ""tail_call<S2SV_blank>abusing<S2SV_blank>map_ptr\\n"" ) ; return - EINVAL ; } <S2SV_ModEnd> <S2SV_ModStart> insn_buf [ 0 ] = BPF_JMP_IMM ( BPF_JGE , BPF_REG_3 , map_ptr -> max_entries , 2 ) ; insn_buf [ 1 ] = BPF_ALU32_IMM ( BPF_AND , BPF_REG_3 , container_of <S2SV_ModEnd> <S2SV_ModStart> struct bpf_array , map ) -> index_mask ) ; insn_buf [ 2 ] = * insn ; cnt = 3 ; <S2SV_ModEnd> <S2SV_ModStart> if ( prog -> jit_requested && BITS_PER_LONG == 64 && ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem ) ) { aux = & env -> insn_aux_data [ i + delta ] ; if ( bpf_map_ptr_poisoned ( aux ) ) goto patch_call_imm ; map_ptr = BPF_MAP_PTR ( aux -> map_state ) ; ops = map_ptr -> ops ; if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) { cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ; if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env , ""bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\n"" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } "
4685,<S2SV_StartBug> context . Xtogo = i -> width ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\n"" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\n"" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\n"" ) ; # endif i -> posY = i -> parent -> height - i -> height ; } "
4686,<S2SV_StartBug> # if CONFIG_MEM_MANAGER <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart> free <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4687,"<S2SV_StartBug> if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> apply_printer_defaults ( printer , job ) ; <S2SV_EndBug> ","<S2SV_ModStart> attr = ippFindAttribute ( con -> request , ""requesting-user-name"" , IPP_TAG_NAME ) ; if ( attr && ! ippValidateAttribute ( attr ) ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Bad<S2SV_blank>requesting-user-name<S2SV_blank>value:<S2SV_blank>%s"" ) , cupsLastErrorString ( ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } <S2SV_ModStart>  <S2SV_ModEnd> "
4688,<S2SV_StartBug> client -> desktopName = malloc ( ( uint64_t ) client -> si . nameLength + 1 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( client -> si . nameLength > 1 << 20 ) { rfbClientErr ( ""Too<S2SV_blank>big<S2SV_blank>desktop<S2SV_blank>name<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\n"" , ( unsigned int ) client -> si . nameLength ) ; return FALSE ; } <S2SV_ModStart>  <S2SV_ModEnd> "
4689,<S2SV_StartBug> size_t <S2SV_EndBug> <S2SV_StartBug> value = ( size_t ) ( buffer [ 0 ] << 24 ) ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 1 ] << 16 ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 2 ] << 8 ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 3 ] ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffffffff ) ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned int <S2SV_ModEnd> <S2SV_ModStart> unsigned int ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( unsigned int ) <S2SV_ModStart> ( unsigned int ) <S2SV_ModStart> ( unsigned int ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4690,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>%u)"" , <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; 
4691,<S2SV_StartBug> char added ; <S2SV_EndBug> <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4692,"<S2SV_StartBug> flush_dcache_page ( page ) ; <S2SV_EndBug> <S2SV_StartBug> iov_iter_advance ( ii , tmp ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; iov_iter_advance ( ii , tmp <S2SV_ModStart>  <S2SV_ModEnd> "
4693,<S2SV_StartBug> if ( namelen > 32 ) <S2SV_EndBug> ,<S2SV_ModStart> len <S2SV_ModEnd> 
4694,"<S2SV_StartBug> return mount_entry_on_generic ( mntent , path ) ; <S2SV_EndBug> ","<S2SV_ModStart> , rootfs -> mount "
4695,<S2SV_StartBug> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <S2SV_EndBug> <S2SV_StartBug> || pReplyData == NULL || * replySize != sizeof ( int ) ) { <S2SV_EndBug> <S2SV_StartBug> pReplyData == NULL || <S2SV_EndBug> <S2SV_StartBug> || pReplyData == NULL || * replySize != ( int ) sizeof ( int32_t ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <S2SV_EndBug> ,<S2SV_ModStart> replySize == NULL || <S2SV_ModStart> == NULL || replySize <S2SV_ModStart> == NULL || replySize <S2SV_ModStart> replySize == NULL || <S2SV_ModStart> replySize == NULL || <S2SV_ModStart> == NULL || replySize 
4696,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4697,<S2SV_StartBug> if ( debug ) { <S2SV_EndBug> <S2SV_StartBug> if ( d -> msg_len > ( CX24116_ARGLEN - CX24116_DISEQC_MSGOFS ) ) <S2SV_EndBug> ,<S2SV_ModStart> d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ; if ( <S2SV_ModStart>  <S2SV_ModEnd> 
4698,"<S2SV_StartBug> tlen = len - sizeof ( struct eigrp_common_header ) ; <S2SV_EndBug> <S2SV_StartBug> tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>holdtime:<S2SV_blank>%us,<S2SV_blank>k1<S2SV_blank>%u,<S2SV_blank>k2<S2SV_blank>%u,<S2SV_blank>k3<S2SV_blank>%u,<S2SV_blank>k4<S2SV_blank>%u,<S2SV_blank>k5<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IOS<S2SV_blank>version:<S2SV_blank>%u.%u,<S2SV_blank>EIGRP<S2SV_blank>version<S2SV_blank>%u.%u"" , <S2SV_EndBug> <S2SV_StartBug> bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ; <S2SV_EndBug> <S2SV_StartBug> bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-range:<S2SV_blank>%u-%u,<S2SV_blank>Router-ID<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" , <S2SV_EndBug> ","<S2SV_ModStart> if ( len < sizeof ( struct eigrp_common_header ) ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , tok2str ( eigrp_opcode_values , ""unknown<S2SV_blank>(%u)"" , eigrp_com_header -> opcode ) , len , ( u_int ) sizeof ( struct eigrp_common_header ) ) ) ; return ; } <S2SV_ModStart> if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) sizeof ( struct eigrp_tlv_header ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) ) ) ; break ; } "
4699,"<S2SV_StartBug> strncpy ( szSec , opt_string , sepIdx ) ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( szKey , sep , sepIdx ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( szVal , sep2 + 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( sepIdx >= sizeof ( szSec ) ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n"" , opt_string ) ; return ; } <S2SV_ModStart> if ( sepIdx >= sizeof ( szKey ) ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>key<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n"" , opt_string ) ; return ; } <S2SV_ModStart> if ( strlen ( <S2SV_ModEnd> <S2SV_ModStart> >= sizeof ( szVal ) ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>value<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n"" , opt_string ) ; return ; } strcpy ( szVal , sep2 + 1 ) "
4700,<S2SV_StartBug> if ( size_bmp > BMP_HEADER_SIZE ) { <S2SV_EndBug> ,<S2SV_ModStart> && size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE 
4701,<S2SV_StartBug> switch ( pc -> componentType ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case 5 : <S2SV_EndBug> <S2SV_StartBug> elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ; <S2SV_EndBug> ,<S2SV_ModStart> elen += sizeof ( struct pathComponent ) ; <S2SV_ModStart> { elen += pc -> lengthComponentIdent ; break ; } <S2SV_ModEnd> <S2SV_ModStart> elen += pc -> lengthComponentIdent ; if ( elen > fromlen ) return - EIO ; <S2SV_ModStart>  <S2SV_ModEnd> 
4702,<S2SV_StartBug> if ( refill_pi_state_cache ( ) ) <S2SV_EndBug> <S2SV_StartBug> goto out_put_key1 ; <S2SV_EndBug> ,"<S2SV_ModStart> uaddr1 == uaddr2 ) return - EINVAL ; if ( <S2SV_ModStart> if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; } "
4703,<S2SV_StartBug> if ( key_is_instantiated ( keyring ) ) { <S2SV_EndBug> ,<S2SV_ModStart> key_is_positive <S2SV_ModEnd> 
4704,<S2SV_StartBug> pairs = palloc ( ncolumns * sizeof ( Pairs ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> Assert ( ncolumns <= MaxTupleAttributeNumber ) ; 
4705,"<S2SV_StartBug> uint16_t n ; <S2SV_EndBug> <S2SV_StartBug> Enc28j60Context * context ; <S2SV_EndBug> <S2SV_StartBug> if ( enc28j60ReadReg ( interface , ENC28J60_REG_EPKTCNT ) ) <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERDPTH , MSB ( context -> nextPacket ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ReadBuffer ( interface , ( uint8_t * ) & context -> nextPacket , sizeof ( uint16_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & RSV_RECEIVED_OK ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> n = MIN ( n , ETH_MAX_FRAME_SIZE ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ReadBuffer ( interface , context -> rxBuffer , n ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTL , LSB ( ENC28J60_RX_BUFFER_STOP ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTH , MSB ( ENC28J60_RX_BUFFER_STOP ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTL , LSB ( context -> nextPacket - 1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTH , MSB ( context -> nextPacket - 1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON2 , ECON2_PKTDEC ) ; <S2SV_EndBug> <S2SV_StartBug> nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ; <S2SV_EndBug> ","<S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> uint8_t header [ 6 ] ; <S2SV_ModStart> ENC28J60_EPKTCNT ) != 0 ) { enc28j60WriteReg ( interface , ENC28J60_ERDPTL <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ERDPTH <S2SV_ModEnd> <S2SV_ModStart> header <S2SV_ModEnd> <S2SV_ModStart> header ) ) ; context -> nextPacket = LOAD16LE ( header ) ; length = LOAD16LE ( header + 2 ) ; status = LOAD16LE ( header + 4 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_RSV_RECEIVED_OK <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ERXRDPTL <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ERXRDPTH <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ERXRDPTL <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ERXRDPTH <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ECON2 , ENC28J60_ECON2_PKTDEC <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> "
4706,"<S2SV_StartBug> cleanup_free char * base_path = NULL ; <S2SV_EndBug> <S2SV_StartBug> base_path = xasprintf ( ""/run/user/%d/.bubblewrap"" , real_uid ) ; <S2SV_EndBug> ","<S2SV_ModStart> const <S2SV_ModEnd> <S2SV_ModStart> ""/tmp"" ; <S2SV_ModEnd> "
4707,<S2SV_StartBug> if ( rh . command == RELAY_COMMAND_BEGIN_DIR ) { <S2SV_EndBug> ,<S2SV_ModStart> && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED 
4708,<S2SV_StartBug> for ( i = 0 ; i < name_len ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> int name_len ; <S2SV_EndBug> ,"<S2SV_ModStart> avio_skip ( pb , name_len <S2SV_ModEnd> <S2SV_ModStart> ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA "
4709,<S2SV_StartBug> * head = NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> giterr_set_str ( GITERR_NET , ""Invalid<S2SV_blank>empty<S2SV_blank>packet"" ) ; return GIT_ERROR <S2SV_ModEnd> "
4710,"<S2SV_StartBug> int xmkstemp ( char * * tmpname , char * dir ) <S2SV_EndBug> <S2SV_StartBug> char * tmpenv ; <S2SV_EndBug> <S2SV_StartBug> if ( dir != NULL ) <S2SV_EndBug> <S2SV_StartBug> tmpenv = dir ; <S2SV_EndBug> <S2SV_StartBug> if ( tmpenv ) <S2SV_EndBug> <S2SV_StartBug> program_invocation_short_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> const <S2SV_ModStart> , const char * prefix <S2SV_ModStart> const <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ? dir : <S2SV_ModEnd> <S2SV_ModStart> ! tmpenv ) tmpenv = _PATH_TMP ; <S2SV_ModEnd> <S2SV_ModStart> prefix <S2SV_ModEnd> "
4711,<S2SV_StartBug> if ( length < sizeof ( DhcpMessage ) ) <S2SV_EndBug> ,<S2SV_ModStart> || <S2SV_ModEnd> 
4712,"<S2SV_StartBug> if ( ! revs -> blob_objects ) <S2SV_EndBug> <S2SV_StartBug> show ( obj , path , name , cb_data ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> size_t pathlen ; <S2SV_ModStart> pathlen = path -> len ; strbuf_addstr ( path , name ) ; <S2SV_ModStart> -> buf <S2SV_ModEnd> <S2SV_ModStart> strbuf_setlen ( path , pathlen ) ; "
4713,<S2SV_StartBug> if ( len > BUFSIZE + sizeof ( struct nbd_reply ) ) <S2SV_EndBug> ,<S2SV_ModStart> - <S2SV_ModEnd> 
4714,"<S2SV_StartBug> static void __nfs4_close ( struct path * path , struct nfs4_state * state , mode_t mode , int wait ) <S2SV_EndBug> <S2SV_StartBug> int newstate ; <S2SV_EndBug> <S2SV_StartBug> switch ( mode & ( FMODE_READ | FMODE_WRITE ) ) { <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode_t <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> 
4715,<S2SV_StartBug> tread . event = SNDRV_TIMER_EVENT_EARLY ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & tread , 0 , sizeof ( tread ) ) ; "
4716,<S2SV_StartBug> if ( sock_owned_by_user ( sk ) ) { <S2SV_EndBug> ,<S2SV_ModStart> sk != rcvr -> sk ) { sctp_bh_unlock_sock ( sk ) ; sk = rcvr -> sk ; sctp_bh_lock_sock ( sk ) ; } if ( 
4717,"<S2SV_StartBug> ""?"" , tptr [ 0 ] ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; ND_TCHECK ( tptr [ 1 ] 
4718,"<S2SV_StartBug> return chg ; <S2SV_EndBug> <S2SV_StartBug> return - ENOSPC ; <S2SV_EndBug> <S2SV_StartBug> ret = hugetlb_acct_memory ( h , chg ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> { ret = chg ; goto out_err ; } <S2SV_ModEnd> <S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto out_err ; } <S2SV_ModStart> goto out_err <S2SV_ModEnd> <S2SV_ModStart> out_err : resv_map_put ( vma ) ; return ret ; 
4719,<S2SV_StartBug> CLEANUP_FREE char * * lines = NULL ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> free ( lines ) ; 
4720,<S2SV_StartBug> perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) ) <S2SV_EndBug> ,<S2SV_ModStart> perf_paranoid_tracepoint_raw <S2SV_ModEnd> 
4721,"<S2SV_StartBug> case 'c' : return getnum ( L , fmt , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> int sz = getnum ( L , fmt , sizeof ( int ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4722,<S2SV_StartBug> return evtchn_to_irq [ EVTCHN_ROW ( evtchn ) ] [ EVTCHN_COL ( evtchn ) ] ; <S2SV_EndBug> ,<S2SV_ModStart> READ_ONCE ( <S2SV_ModStart> ) 
4723,"<S2SV_StartBug> static int do_16x16_motion_search ( VP9_COMP * cpi , const int_mv * ref_mv , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> int_mv tmp_mv ; <S2SV_EndBug> <S2SV_StartBug> xd -> plane [ 0 ] . pre [ 0 ] . buf , xd -> plane [ 0 ] . pre [ 0 ] . stride , <S2SV_EndBug> <S2SV_StartBug> tmp_err = do_16x16_motion_iteration ( cpi , & ref_mv -> as_mv , & tmp_mv . as_mv , <S2SV_EndBug> ","<S2SV_ModStart> MV * ref_mv , int_mv * <S2SV_ModEnd> <S2SV_ModStart> td . <S2SV_ModStart> MV tmp_mv ; err = vpx_sad16x16 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ref_mv , & tmp_mv , mb_row , mb_col ) ; if ( tmp_err < err ) { err = tmp_err ; dst_mv -> as_mv = tmp_mv ; } if ( ref_mv -> row != 0 || ref_mv -> col != 0 ) { unsigned int tmp_err ; MV zero_ref_mv = { 0 , 0 } , tmp_mv ; tmp_err = do_16x16_motion_iteration ( cpi , & zero_ref_mv , & tmp_mv , mb_row , mb_col ) ; if ( tmp_err < err ) { dst_mv -> as_mv = tmp_mv <S2SV_ModEnd> "
4724,<S2SV_StartBug> ackNum ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( segment -> flags & TCP_FLAG_FIN ) <S2SV_EndBug> <S2SV_StartBug> ackNum ++ ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } 
4725,<S2SV_StartBug> struct snd_timer_user * tu ; <S2SV_EndBug> <S2SV_StartBug> switch ( cmd ) { <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & tu -> tread_sem ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & tu -> tread_sem ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> long ret <S2SV_ModEnd> <S2SV_ModStart> ioctl_lock ) ; ret = __snd_timer_user_ioctl ( file , cmd , arg ) <S2SV_ModEnd> <S2SV_ModStart> ioctl_lock <S2SV_ModEnd> <S2SV_ModStart> ret <S2SV_ModEnd> "
4726,<S2SV_StartBug> if ( options . compression ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4727,<S2SV_StartBug> in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( <S2SV_ModStart> < <S2SV_ModEnd> <S2SV_ModStart> ) { in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ; } else { ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>Got<S2SV_blank>route<S2SV_blank>advertisement<S2SV_blank>with<S2SV_blank>lower<S2SV_blank>hop_limit<S2SV_blank>than<S2SV_blank>current\\n"" ) ; } <S2SV_ModEnd> "
4728,"<S2SV_StartBug> v . val = test_bit ( SOCK_PASSCRED , & sock -> flags ) ? 1 : 0 ; <S2SV_EndBug> <S2SV_StartBug> v . val = test_bit ( SOCK_PASSSEC , & sock -> flags ) ? 1 : 0 ; <S2SV_EndBug> ",<S2SV_ModStart> ! ! <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ! ! <S2SV_ModStart>  <S2SV_ModEnd> 
4729,<S2SV_StartBug> if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) <S2SV_EndBug> ,<S2SV_ModStart> ] || ! info -> attrs [ NFC_ATTR_TARGET_INDEX 
4730,<S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> sock * sk = asoc -> base . sk ; struct <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4731,<S2SV_StartBug> xmalloc ( size_t size ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> void * ptr = malloc ( size ) ; <S2SV_EndBug> ,"<S2SV_ModStart> num , size_t <S2SV_ModStart> size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> res <S2SV_ModEnd> "
4732,<S2SV_StartBug> sys -> free ( lzx -> inbuf ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( lzx -> inbuf ) <S2SV_ModStart> if ( lzx -> window ) 
4733,<S2SV_StartBug> if ( NAPI_GRO_CB ( skb ) -> udp_mark || <S2SV_EndBug> <S2SV_StartBug> NAPI_GRO_CB ( skb ) -> udp_mark = 1 ; <S2SV_EndBug> ,<S2SV_ModStart> encap_mark <S2SV_ModEnd> <S2SV_ModStart> encap_mark <S2SV_ModEnd> 
4734,"<S2SV_StartBug> MB_PREDICTION_MODE mode ; <S2SV_EndBug> <S2SV_StartBug> int64_t this_distortion , this_sse ; <S2SV_EndBug> <S2SV_StartBug> super_block_uvrd ( cpi , x , & this_rate_tokenonly , <S2SV_EndBug> <S2SV_StartBug> & this_distortion , & s , & this_sse , bsize , best_rd ) ; <S2SV_EndBug> <S2SV_StartBug> x -> intra_uv_mode_cost [ cpi -> common . frame_type ] [ mode ] ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> select_txfm_size ) { <S2SV_EndBug> ","<S2SV_ModStart> PREDICTION_MODE mode ; PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> ; memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) <S2SV_ModStart> if ( ! <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> select_tx_size ) swap_block_ptr ( x , ctx , 2 , 0 , 1 , MAX_MB_PLANE ) ; <S2SV_ModEnd> "
4735,"<S2SV_StartBug> if ( exists_not_none ( obj , & PyId_arg ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_arg ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_identifier ( tmp , & arg , arena ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ","<S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; arg = NULL ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_identifier ( tmp , & arg , arena ) ; if ( res != 0 <S2SV_ModEnd> <S2SV_ModStart> Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>keyword"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & value <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4736,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( ! enable ) { wake_up_interruptible ( & sunkbd -> wait ) ; cancel_work_sync ( & sunkbd -> tq ) ; } 
4737,"<S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> ",<S2SV_ModStart> _dh <S2SV_ModEnd> 
4738,"<S2SV_StartBug> static int read_fragment_table ( long long * directory_table_end ) <S2SV_EndBug> <S2SV_StartBug> int bytes = SQUASHFS_FRAGMENT_BYTES ( sBlk . s . fragments ) ; <S2SV_EndBug> <S2SV_StartBug> int indexes = SQUASHFS_FRAGMENT_INDEXES ( sBlk . s . fragments ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sBlk . s . fragments == 0 ) { <S2SV_EndBug> <S2SV_StartBug> SQUASHFS_FRAGMENT_INDEX_BYTES ( sBlk . s . fragments ) , <S2SV_EndBug> <S2SV_StartBug> * directory_table_end = fragment_table_index [ 0 ] ; <S2SV_EndBug> ","<S2SV_ModStart> table_start <S2SV_ModEnd> <S2SV_ModStart> long long <S2SV_ModEnd> <S2SV_ModStart> ( long long ) <S2SV_ModStart> ( long long ) sBlk . s . fragments ) ; int length = SQUASHFS_FRAGMENT_INDEX_BYTES ( ( long long ) sBlk . s . fragments ) ; long long * fragment_table_index ; if ( length != ( * table_start - sBlk . s . fragment_table_start ) ) { ERROR ( ""read_fragment_table:<S2SV_blank>Bad<S2SV_blank>fragment<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; return FALSE ; } <S2SV_ModEnd> <S2SV_ModStart> fragment_table_index = alloc_index_table ( indexes ) ; <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> table_start <S2SV_ModEnd> "
4739,<S2SV_StartBug> assert ( numcolors <= RAS_CMAP_MAXSIZ ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( numcolors > RAS_CMAP_MAXSIZ ) { return - 1 ; } <S2SV_ModEnd> 
4740,"<S2SV_StartBug> sprintf ( efbuf , ""REG_%s"" , name ) ; <S2SV_EndBug> ","<S2SV_ModStart> snprintf ( efbuf , sizeof ( efbuf ) <S2SV_ModEnd> "
4741,<S2SV_StartBug> dlen -= 2 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( dlen < 2 ) break ; <S2SV_ModStart>  <S2SV_ModEnd> 
4742,<S2SV_StartBug> nfcb_poll -> sensb_res_len = * data ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> min_t ( __u8 , <S2SV_ModStart> , NFC_SENSB_RES_MAXSIZE ) "
4743,"<S2SV_StartBug> unsigned int maxfraglen , fragheaderlen ; <S2SV_EndBug> <S2SV_StartBug> int hh_len ; <S2SV_EndBug> <S2SV_StartBug> fragheaderlen , skb , rt ) ; <S2SV_EndBug> ","<S2SV_ModStart> , mtu <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , np -> pmtudisc == IPV6_PMTUDISC_PROBE "
4744,"<S2SV_StartBug> uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ; <S2SV_EndBug> <S2SV_StartBug> WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || <S2SV_EndBug> ","<S2SV_ModStart> = 0 , desc_chunk <S2SV_ModStart> ; desc_chunk = 1 <S2SV_ModStart> desc_chunk || ! "
4745,"<S2SV_StartBug> static int cost_segmap ( int * segcounts , vp9_prob * probs ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_prob <S2SV_ModEnd> 
4746,<S2SV_StartBug> motion_pct = this_frame -> pcnt_motion ; <S2SV_EndBug> ,<S2SV_ModStart> ( void ) cpi ; 
4747,"<S2SV_StartBug> char extbuf [ sizeof ( c -> binary_header ) + BIN_MAX_EXTLEN ] ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( extbuf + sizeof ( c -> binary_header ) , c -> rcurr + sizeof ( c -> binary_header ) , extlen ) ; <S2SV_EndBug> ",<S2SV_ModStart> + 1 <S2SV_ModStart> extlen > BIN_MAX_EXTLEN ? BIN_MAX_EXTLEN : 
4748,<S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( int ) 
4749,<S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) <S2SV_EndBug> <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; } <S2SV_ModEnd> <S2SV_ModStart> * num "
4750,<S2SV_StartBug> offset = tbl -> indent ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( tbl -> indent < 0 ) tbl -> indent = 0 ; <S2SV_ModStart> if ( offset < 0 ) offset = 0 ; 
4751,<S2SV_StartBug> ut32 len = sec -> payload_len ; <S2SV_EndBug> <S2SV_StartBug> while ( i < len && r < count ) { <S2SV_EndBug> <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data ; <S2SV_ModStart> && len < buflen <S2SV_ModStart> goto beach <S2SV_ModEnd> <S2SV_ModStart> goto beach <S2SV_ModEnd> <S2SV_ModStart> goto beach <S2SV_ModEnd> <S2SV_ModStart> beach : free ( ptr ) ; return ret ; 
4752,<S2SV_StartBug> default : <S2SV_EndBug> ,<S2SV_ModStart> case MAGIC_PARAM_ELF_NOTES_MAX : ms -> elf_notes_max = * ( const size_t * ) val ; return 0 ; 
4753,"<S2SV_StartBug> tr_variantInitDict ( & node -> sorted , n ) ; <S2SV_EndBug> <S2SV_StartBug> node -> sorted . val . l . vals [ i ] = * tmp [ i ] . val ; <S2SV_EndBug> <S2SV_StartBug> node -> sorted . val . l . count = n ; <S2SV_EndBug> <S2SV_StartBug> node -> v = & node -> sorted ; <S2SV_EndBug> <S2SV_StartBug> node -> v = v ; <S2SV_EndBug> ","<S2SV_ModStart> node -> sorted = tr_new ( tr_variant , 1 ) ; tr_variantInitDict ( <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> v = <S2SV_ModEnd> <S2SV_ModStart> sorted = NULL ; } node -> v = v ; <S2SV_ModEnd> "
4754,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> 
4755,"<S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; ( void ) ResetMagickMemory ( global_colormap , 0 , 3 * MagickMax ( global_colors , 256 ) * sizeof ( * global_colormap ) "
4756,"<S2SV_StartBug> dl = kmalloc ( size , GFP_KERNEL ) ; <S2SV_EndBug> ",<S2SV_ModStart> kzalloc <S2SV_ModEnd> 
4757,<S2SV_StartBug> enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ; <S2SV_EndBug> <S2SV_StartBug> rs -> respond = respond ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; rs -> enc_tkt_reply = enc_tkt_reply 
4758,<S2SV_StartBug> void <S2SV_EndBug> ,<S2SV_ModStart> static 
4759,<S2SV_StartBug> if ( msg -> has_data_length && len > 0 ) { <S2SV_EndBug> <S2SV_StartBug> return len < 256 ? ( uint8_t ) len : 0 ; <S2SV_EndBug> ,<S2SV_ModStart> && len < 256 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4760,<S2SV_StartBug> # ifdef HAVE_OPENSSL <S2SV_EndBug> ,<S2SV_ModStart> SSL_SET_OPTIONS ( mysql ) ; <S2SV_ModEnd> 
4761,"<S2SV_StartBug> int ffmax , parent_len ; <S2SV_EndBug> <S2SV_StartBug> r = idr_start ( a , idr , isoent -> children . cnt , ffmax , 6 , 2 , & rb_ops ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( int ) ( l = np -> file -> basename_utf16 . length ) > ffmax ) <S2SV_EndBug> <S2SV_StartBug> if ( ( int ) np -> file -> basename_utf16 . length > ffmax ) { <S2SV_EndBug> <S2SV_StartBug> if ( parent_len + np -> mb_len > 240 ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( int ) l == ffmax ) <S2SV_EndBug> <S2SV_StartBug> else if ( ( int ) l == ffmax - 2 ) <S2SV_EndBug> <S2SV_StartBug> else if ( ( int ) l == ffmax - 4 ) <S2SV_EndBug> ",<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> ( int ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> > 240 || <S2SV_ModEnd> <S2SV_ModStart> || parent_len + np -> mb_len > 240 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4762,"<S2SV_StartBug> vpx_memcpy ( cpi -> active_map , map , rows * cols ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> 
4763,<S2SV_StartBug> bool disconnect ; <S2SV_EndBug> <S2SV_StartBug> __touch_mnt_namespace ( p -> mnt_ns ) ; <S2SV_EndBug> ,<S2SV_ModStart> struct mnt_namespace * ns ; <S2SV_ModStart> ns = p -> mnt_ns ; if ( ns ) { ns -> mounts -- ; __touch_mnt_namespace ( ns ) ; } <S2SV_ModEnd> 
4764,"<S2SV_StartBug> static void show_object ( struct object * object , struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , void * data ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> 
4765,<S2SV_StartBug> switch ( bsize ) { <S2SV_EndBug> <S2SV_StartBug> node -> split [ i ] = & vt -> split [ i ] ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> node -> part_variances = NULL ; <S2SV_ModStart> . part_variances . none ; break ; } case BLOCK_4X4 : { v4x4 * vt = ( v4x4 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) node -> split [ i ] = & vt -> split [ i ] <S2SV_ModStart> break ; 
4766,<S2SV_StartBug> case NPNVSupportsWindowless : <S2SV_EndBug> ,<S2SV_ModStart> : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling 
4767,"<S2SV_StartBug> vpx_memset ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst_ptr1 + extend_left , src_ptr1 , w ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst_ptr1 , src_ptr1 , linesize ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst_ptr2 , src_ptr2 , linesize ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memcpy ( dst_ptr1 + extend_left , src_ptr1 , w ) ; memset <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> "
4768,<S2SV_StartBug> if ( ! object || object -> list . length != 2 || ! object -> list . objects [ 0 ] || object -> list . objects [ 1 ] -> list . length != 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> || ! object -> list . objects [ 0 ] || ! object -> list . objects [ 1 ] || <S2SV_ModEnd> 
4769,<S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug> <S2SV_StartBug> IP6CB ( skb ) -> iif ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; * addr_len = sizeof ( * sin6 
4770,<S2SV_StartBug> data = dm9000ReadReg ( DM9000_REG_MRCMDX ) ; <S2SV_EndBug> <S2SV_StartBug> DM9000_INDEX_REG = DM9000_REG_MRCMDX1 ; <S2SV_EndBug> <S2SV_StartBug> DM9000_INDEX_REG = DM9000_REG_MRCMD ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & ( RSR_LCS | RSR_RWTO | RSR_PLE | RSR_AE | RSR_CE | RSR_FOE ) ) == 0 ) <S2SV_EndBug> ,<S2SV_ModStart> DM9000_MRCMDX <S2SV_ModEnd> <S2SV_ModStart> DM9000_MRCMDX1 <S2SV_ModEnd> <S2SV_ModStart> DM9000_MRCMD <S2SV_ModEnd> <S2SV_ModStart> DM9000_RSR_LCS | DM9000_RSR_RWTO | DM9000_RSR_PLE | DM9000_RSR_AE | DM9000_RSR_CE | DM9000_RSR_FOE <S2SV_ModEnd> 
4771,"<S2SV_StartBug> if ( nposargs + nkwonlyargs > 255 ) { <S2SV_EndBug> <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { <S2SV_EndBug> <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4772,<S2SV_StartBug> return SECURE_ELEMENT_ERROR_NPE ; <S2SV_EndBug> ,<S2SV_ModStart> ; } if ( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE ) { return SECURE_ELEMENT_ERROR_BUF_SIZE 
4773,<S2SV_StartBug> if ( nlmsg_len ( nlh ) < sizeof ( struct nfgenmsg ) || <S2SV_EndBug> ,<S2SV_ModStart> nlh -> nlmsg_len < NLMSG_HDRLEN || skb -> len < nlh -> nlmsg_len || <S2SV_ModStart> ) { nfnl_err_reset ( & err_list ) ; status |= NFNL_BATCH_FAILURE ; goto done <S2SV_ModEnd> 
4774,<S2SV_StartBug> length = cap -> bLength ; <S2SV_EndBug> ,<S2SV_ModStart> if ( total_len < sizeof ( * cap ) || total_len < <S2SV_ModEnd> <S2SV_ModStart> ) { dev -> bos -> desc -> bNumDeviceCaps = i ; break ; } length = cap -> bLength <S2SV_ModEnd> 
4775,<S2SV_StartBug> if ( ape -> totalframes > UINT_MAX / sizeof ( APEFrame ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> ! ape -> totalframes ) { av_log ( s , AV_LOG_ERROR , ""No<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>the<S2SV_blank>file!\\n"" ) ; return AVERROR ( EINVAL ) ; } if ( "
4776,"<S2SV_StartBug> static int prob_diff_update_cost ( vp9_prob newp , vp9_prob oldp ) { <S2SV_EndBug> ","<S2SV_ModStart> vpx_prob newp , vpx_prob <S2SV_ModEnd> "
4777,<S2SV_StartBug> for ( i = 0 ; i < frame_count ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> chunk_size [ i ] = avio_rl32 ( pb ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < frame_count ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> chunk_offset [ i ] = avio_rl32 ( pb ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < frame_count ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < frame_count ; i ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } <S2SV_ModStart> { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } <S2SV_ModStart> { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } 
4778,"<S2SV_StartBug> key = getDirective ( line , & value ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ( <S2SV_ModStart> ) == 0 ) { continue ; } <S2SV_ModEnd> 
4779,<S2SV_StartBug> } else if ( ctx -> pbi == NULL ) { <S2SV_EndBug> ,<S2SV_ModStart> frame_workers <S2SV_ModEnd> 
4780,"<S2SV_StartBug> env -> used_maps [ env -> used_map_cnt ++ ] = map ; <S2SV_EndBug> <S2SV_StartBug> bpf_map_inc ( map , false ) ; <S2SV_EndBug> ","<S2SV_ModStart> map = bpf_map_inc ( map , false ) ; if ( IS_ERR ( map ) ) { fdput ( f ) ; return PTR_ERR ( map ) ; } <S2SV_ModStart>  <S2SV_ModEnd> "
4781,<S2SV_StartBug> if ( ! index_key . type -> match || ! index_key . type -> instantiate || <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4782,<S2SV_StartBug> if ( * p != IAC ) <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK ( * p ) ; 
4783,<S2SV_StartBug> daddy = malloc ( sizeof ( creator_template ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
4784,"<S2SV_StartBug> int start [ ] = { Py_file_input , Py_eval_input , Py_single_input } ; <S2SV_EndBug> <S2SV_StartBug> ~ ( PyCF_MASK | PyCF_MASK_OBSOLETE | PyCF_DONT_IMPLY_DEDENT | PyCF_ONLY_AST ) ) <S2SV_EndBug> <S2SV_StartBug> else { <S2SV_EndBug> <S2SV_StartBug> ""compile()<S2SV_blank>mode<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'exec\',<S2SV_blank>\'eval\'<S2SV_blank>or<S2SV_blank>\'single\'"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> , Py_func_type_input <S2SV_ModStart> | PyCF_TYPE_COMMENTS <S2SV_ModStart> if ( strcmp ( mode , ""func_type"" ) == 0 ) { if ( ! ( flags & PyCF_ONLY_AST ) ) <S2SV_ModStart> ""compile()<S2SV_blank>mode<S2SV_blank>\'func_type\'<S2SV_blank>requires<S2SV_blank>flag<S2SV_blank>PyCF_ONLY_AST"" ) ; goto error ; } compile_mode = 3 ; } else { const char * msg ; if ( flags & PyCF_ONLY_AST ) msg = ""compile()<S2SV_blank>mode<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'exec\',<S2SV_blank>\'eval\',<S2SV_blank>\'single\'<S2SV_blank>or<S2SV_blank>\'func_type\'"" ; else msg = ""compile()<S2SV_blank>mode<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'exec\',<S2SV_blank>\'eval\'<S2SV_blank>or<S2SV_blank>\'single\'"" ; PyErr_SetString ( PyExc_ValueError , msg <S2SV_ModEnd> "
4785,"<S2SV_StartBug> char * outname = create_output_name ( ( unsigned char * ) f [ i ] -> filename , NULL , 0 , 1 , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4786,<S2SV_StartBug> if ( size < 6 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> 5 + 1 <S2SV_ModEnd> <S2SV_ModStart> for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , ""DEADBEEF"" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , ""%2.0f"" , 1.6314159265358979e+125 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , ""163141592653589790215729350939528493057529598899734151772468186268423257777068536614838678161083520756952076273094236944990208"" ) == 0 ) ; ASSERT ( length == 126 ) ; if ( size < 126 + 1 ) ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & ""DEADBEEF"" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; } "
4787,"<S2SV_StartBug> char combname [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( combname , L_BUF_SIZE , ""sel_comb_%dh"" , size ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( combname , L_BUF_SIZE , ""sel_comb_%dv"" , size ) ; <S2SV_EndBug> ",<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> 
4788,"<S2SV_StartBug> static void update_switchable_interp_probs ( VP9_COMMON * cm , vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> cm -> fc . switchable_interp_prob [ j ] , <S2SV_EndBug> <S2SV_StartBug> cm -> counts . switchable_interp [ j ] , SWITCHABLE_FILTERS , w ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_writer * w , FRAME_COUNTS * counts <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> "
4789,"<S2SV_StartBug> err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX , <S2SV_EndBug> <S2SV_StartBug> attrs [ TIPC_NLA_SOCK ] , <S2SV_EndBug> <S2SV_StartBug> tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ; <S2SV_EndBug> <S2SV_StartBug> lock_sock ( & tsk -> sk ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX , attrs [ TIPC_NLA_SOCK ] , tipc_nl_sock_policy ) ; if ( err ) return err ; if ( ! sock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ; } if ( done ) return 0 ; tsk = tipc_sk_lookup ( net , tsk_portid ) ; if ( ! tsk ) return - EINVAL ; "
4790,"<S2SV_StartBug> truncate_pagecache ( inode , ioffset ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> goto out_dio ; <S2SV_EndBug> <S2SV_StartBug> out_dio : <S2SV_EndBug> ",<S2SV_ModStart> ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> out_mmap <S2SV_ModEnd> <S2SV_ModStart> out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModEnd> 
4791,"<S2SV_StartBug> name . name = buf ; <S2SV_EndBug> <S2SV_StartBug> err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> err = - EINVAL ; if ( size != sizeof ( outarg ) + <S2SV_ModEnd> <S2SV_ModStart> goto err ; name . name = buf ; name . len = outarg . namelen ; err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) "
4792,<S2SV_StartBug> if ( ( int ) arg >= cdi -> capacity ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4793,<S2SV_StartBug> nfca_poll -> rats_res_len = * data ++ ; <S2SV_EndBug> <S2SV_StartBug> nfcb_poll -> attrib_res_len = * data ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> min_t ( __u8 , <S2SV_ModStart> , 20 ) <S2SV_ModStart> min_t ( __u8 , <S2SV_ModStart> , 50 ) "
4794,<S2SV_StartBug> r1 . event = SNDRV_TIMER_EVENT_RESOLUTION ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & r1 , 0 , sizeof ( r1 ) ) ; "
4795,"<S2SV_StartBug> set_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ; <S2SV_EndBug> <S2SV_StartBug> clear_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ; <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return err ; } set_bit <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4796,"<S2SV_StartBug> vpx_memset ( xd -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( ( pbi -> mt_yabove_row [ mb_row + 1 ] + 32 + mb_col * 16 ) , ( xd -> dst . y_buffer + 15 * recon_y_stride ) , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( ( pbi -> mt_uabove_row [ mb_row + 1 ] + 16 + mb_col * 8 ) , ( xd -> dst . u_buffer + 7 * recon_uv_stride ) , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( ( pbi -> mt_vabove_row [ mb_row + 1 ] + 16 + mb_col * 8 ) , ( xd -> dst . v_buffer + 7 * recon_uv_stride ) , 8 ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
4797,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> result = PyObject_CallFunction ( ( PyObject * ) & PyType_Type , ""s(O){sOss}"" , <S2SV_EndBug> <S2SV_StartBug> type , base , ""_fields"" , fnames , ""__module__"" , ""_ast3"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> _Py_IDENTIFIER ( __module__ ) ; _Py_IDENTIFIER ( _ast3 ) ; <S2SV_ModStart> ""s(O){OOOO}"" <S2SV_ModEnd> <S2SV_ModStart> _PyUnicode_FromId ( & PyId__fields ) <S2SV_ModEnd> <S2SV_ModStart> _PyUnicode_FromId ( & PyId___module__ ) , _PyUnicode_FromId ( & PyId__ast3 ) <S2SV_ModEnd> "
4798,<S2SV_StartBug> count = be32_to_cpu ( aclp -> acl_cnt ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED 
4799,<S2SV_StartBug> sh -> first_slice_in_pic_flag = get_bits1 ( gb ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( s -> ref && sh -> first_slice_in_pic_flag ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\n"" ) ; return 1 ; } "
4800,"<S2SV_StartBug> * outlen = utf8s_to_utf16s ( name , len , ( wchar_t * ) outname ) ; <S2SV_EndBug> ","<S2SV_ModStart> UTF16_HOST_ENDIAN , <S2SV_ModStart> , FAT_LFN_LEN + 2 "
4801,<S2SV_StartBug> else if ( rc == - ENODATA ) <S2SV_EndBug> <S2SV_StartBug> return rc ; <S2SV_EndBug> ,<S2SV_ModStart> && inode -> i_op -> removexattr ) { <S2SV_ModEnd> <S2SV_ModStart> } 
4802,"<S2SV_StartBug> const char * path ) <S2SV_EndBug> <S2SV_StartBug> mntflags , mntdata , optional ) ; <S2SV_EndBug> ","<S2SV_ModStart> , const char * rootfs <S2SV_ModStart> , rootfs "
4803,"<S2SV_StartBug> static int tile_worker_hook ( void * arg1 , void * arg2 ) { <S2SV_EndBug> <S2SV_StartBug> TileWorkerData * const tile_data = ( TileWorkerData * ) arg1 ; <S2SV_EndBug> <S2SV_StartBug> const TileInfo * const tile = ( TileInfo * ) arg2 ; <S2SV_EndBug> <S2SV_StartBug> int mi_row , mi_col ; <S2SV_EndBug> <S2SV_StartBug> decode_partition ( tile_data -> cm , & tile_data -> xd , tile , <S2SV_EndBug> <S2SV_StartBug> mi_row , mi_col , & tile_data -> bit_reader , BLOCK_64X64 ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ) { <S2SV_ModEnd> <S2SV_ModStart> ; if ( setjmp ( tile_data -> error_info . jmp ) ) { tile_data -> error_info . setjmp = 0 ; tile_data -> xd . corrupted = 1 ; return 0 ; } tile_data -> error_info . setjmp = 1 ; tile_data -> xd . error_info = & tile_data -> error_info <S2SV_ModStart> pbi <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , 4 "
4804,<S2SV_StartBug> section -> intra_error -= frame -> intra_error ; <S2SV_EndBug> <S2SV_StartBug> section -> ssim_weighted_pred_err -= frame -> ssim_weighted_pred_err ; <S2SV_EndBug> <S2SV_StartBug> section -> pcnt_neutral -= frame -> pcnt_neutral ; <S2SV_EndBug> ,<S2SV_ModStart> weight -= frame -> weight ; section -> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; section -> intra_skip_pct -= frame -> intra_skip_pct ; section -> inactive_zone_rows -= frame -> inactive_zone_rows ; section -> inactive_zone_cols -= frame -> inactive_zone_cols 
4805,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> return - EACCES ; 
4806,"<S2SV_StartBug> if ( mount ( hostpath , path , 0 , MS_BIND , NULL ) != 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> safe_mount ( hostpath , path , 0 , MS_BIND , NULL , rootfs -> path ? rootfs -> mount : <S2SV_ModEnd> "
4807,"<S2SV_StartBug> id = ipc_addid ( & shm_ids ( ns ) , & shp -> shm_perm , ns -> shm_ctlmni ) ; <S2SV_EndBug> <S2SV_StartBug> shp -> shm_cprid = task_tgid_vnr ( current ) ; <S2SV_EndBug> ",<S2SV_ModStart> shp -> shm_cprid = task_tgid_vnr ( current ) ; shp -> shm_lprid = 0 ; shp -> shm_atim = shp -> shm_dtim = 0 ; shp -> shm_ctim = get_seconds ( ) ; shp -> shm_segsz = size ; shp -> shm_nattch = 0 ; shp -> shm_file = file ; shp -> shm_creator = current ; <S2SV_ModStart>  <S2SV_ModEnd> 
4808,<S2SV_StartBug> uint32_t vsize = avio_rb32 ( pb ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA 
4809,"<S2SV_StartBug> status = decode_getacl ( xdr , rqstp , & res -> acl_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> res <S2SV_ModEnd> 
4810,<S2SV_StartBug> assert ( bus >= 0 && bus < MAXBUSES ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4811,<S2SV_StartBug> if ( ( plen == 0 ) || ( offset + plen > length ) ) <S2SV_EndBug> ,<S2SV_ModStart> < sizeof ( struct sctp_paramhdr ) <S2SV_ModEnd> 
4812,"<S2SV_StartBug> mem_free ( gr . gr_ctx . value , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & min_stat , & gd -> checksum ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4813,"<S2SV_StartBug> int v , i ; <S2SV_EndBug> <S2SV_StartBug> ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) ) <S2SV_EndBug> ","<S2SV_ModStart> if ( ! ( s -> state & PNG_IHDR ) ) { av_log ( avctx , AV_LOG_ERROR , ""trns<S2SV_blank>before<S2SV_blank>IHDR\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( s -> state & PNG_IDAT ) { av_log ( avctx , AV_LOG_ERROR , ""trns<S2SV_blank>after<S2SV_blank>IDAT\\n"" ) ; return AVERROR_INVALIDDATA ; } <S2SV_ModStart> || s -> bit_depth == 1 "
4814,"<S2SV_StartBug> struct mb_cache * <S2SV_EndBug> <S2SV_StartBug> ext4_xattr_create_cache ( char * name ) <S2SV_EndBug> <S2SV_StartBug> return mb_cache_create ( name , HASH_BUCKET_BITS ) ; <S2SV_EndBug> ",<S2SV_ModStart> mb2_cache <S2SV_ModEnd> <S2SV_ModStart> void <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_create ( <S2SV_ModEnd> 
4815,"<S2SV_StartBug> u64 rem ; <S2SV_EndBug> <S2SV_StartBug> sgi_clock_offset . tv_sec = tp -> tv_sec - div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> ",<S2SV_ModStart> u32 <S2SV_ModEnd> <S2SV_ModStart> div_u64_rem <S2SV_ModEnd> 
4816,"<S2SV_StartBug> p_fm_config_conx_hdlt hdl ; <S2SV_EndBug> <S2SV_StartBug> goto die_clean ; <S2SV_EndBug> <S2SV_StartBug> goto die_clean ; <S2SV_EndBug> <S2SV_StartBug> return commandList [ i ] . cmdPtr ( hdl , commandList [ i ] . mgr , ( argc - optind ) , & argv [ optind ] ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> die_clean : <S2SV_EndBug> <S2SV_StartBug> return res ; <S2SV_EndBug> ",<S2SV_ModStart> = NULL <S2SV_ModStart> cleanup <S2SV_ModEnd> <S2SV_ModStart> cleanup <S2SV_ModEnd> <S2SV_ModStart> res = <S2SV_ModEnd> <S2SV_ModStart> goto cleanup ; <S2SV_ModStart> cleanup : if ( hdl ) { if ( hdl -> sm_hdl ) { if ( hdl -> sm_hdl -> c_path [ 0 ] ) unlink ( hdl -> sm_hdl -> c_path ) ; } if ( hdl -> pm_hdl ) { if ( hdl -> pm_hdl -> c_path [ 0 ] ) unlink ( hdl -> pm_hdl -> c_path ) ; } if ( hdl -> fe_hdl ) { if ( hdl -> fe_hdl -> c_path [ 0 ] ) unlink ( hdl -> fe_hdl -> c_path ) ; } <S2SV_ModEnd> <S2SV_ModStart> } 
4817,"<S2SV_StartBug> next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift ; <S2SV_EndBug> <S2SV_StartBug> calc_max_reserv ( ip , len , & max_bytes , & data_blocks , & ind_blocks ) ; <S2SV_EndBug> ","<S2SV_ModStart> loff_t max_chunk_size = UINT_MAX & bsize_mask ; <S2SV_ModStart> ( len > max_chunk_size ) ? max_chunk_size : len , <S2SV_ModEnd> "
4818,"<S2SV_StartBug> if ( optlen == 4 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>optlen<S2SV_blank>!=<S2SV_blank>4"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( optlen == 4 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>optlen<S2SV_blank>!=<S2SV_blank>4"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> 6 <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank>[optlen<S2SV_blank>!=<S2SV_blank>6]"" <S2SV_ModEnd> <S2SV_ModStart> switch ( optlen ) { case 6 : ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; break ; case 8 : ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(elapsed<S2SV_blank>time<S2SV_blank>%u)"" , EXTRACT_16BITS ( option + 6 ) ) ) ; break ; case 10 : ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(elapsed<S2SV_blank>time<S2SV_blank>%u)"" , EXTRACT_32BITS ( option + 6 ) ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>[optlen<S2SV_blank>!=<S2SV_blank>6<S2SV_blank>or<S2SV_blank>8<S2SV_blank>or<S2SV_blank>10]"" ) ) ; break ; } break ; case 43 : if ( optlen == 6 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ; else <S2SV_ModStart> EXTRACT_16BITS <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank>[optlen<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>or<S2SV_blank>6]"" <S2SV_ModEnd> "
4819,"<S2SV_StartBug> if ( opt_len != 4 ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>(extra?)<S2SV_blank>%d"" , EXTRACT_16BITS ( bp ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 16 ) { <S2SV_EndBug> <S2SV_StartBug> bp += sizeof ( uint32_t ) ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= 16 ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len < sizeof ( uint32_t ) ) { <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= sizeof ( uint32_t ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 8 ) { <S2SV_EndBug> <S2SV_StartBug> seq = EXTRACT_32BITS ( bp ) ; <S2SV_EndBug> <S2SV_StartBug> bp += sizeof ( uint32_t ) ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= 8 ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 12 ) { <S2SV_EndBug> <S2SV_StartBug> bp += 2 ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= 12 ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 12 ) { <S2SV_EndBug> <S2SV_StartBug> bp += 2 ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= 12 ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 4 + sizeof ( struct in_addr ) ) { <S2SV_EndBug> <S2SV_StartBug> opts_len -= 4 + sizeof ( struct in_addr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 4 + sizeof ( struct in6_addr ) ) { <S2SV_EndBug> <S2SV_StartBug> opts_len -= 4 + sizeof ( struct in6_addr ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>REDIRECT<S2SV_blank>%s"" , nla_buf ) ) ; <S2SV_EndBug> <S2SV_StartBug> case PGM_OPT_PARITY_PRM : <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 8 ) { <S2SV_EndBug> <S2SV_StartBug> bp += 2 ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= 8 ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len != 8 ) { <S2SV_EndBug> <S2SV_StartBug> bp += 2 ; <S2SV_EndBug> <S2SV_StartBug> opts_len -= 8 ; <S2SV_EndBug> ","<S2SV_ModStart> # define PGM_OPT_LENGTH_LEN ( 2 + 2 ) <S2SV_ModStart> PGM_OPT_LENGTH_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_LENGTH_LEN ) ) ; return ; } ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>(extra?)<S2SV_blank>%d"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; opts_len -= PGM_OPT_LENGTH_LEN ; break ; case PGM_OPT_FRAGMENT : # define PGM_OPT_FRAGMENT_LEN ( 2 + 2 + 4 + 4 + 4 ) if ( opt_len != PGM_OPT_FRAGMENT_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FRAGMENT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_FRAGMENT_LEN <S2SV_ModEnd> <S2SV_ModStart> bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>FRAG<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>off<S2SV_blank>%u<S2SV_blank>len<S2SV_blank>%u"" , seq , offset , len ) ) ; opts_len -= PGM_OPT_FRAGMENT_LEN ; break ; case PGM_OPT_NAK_LIST : bp += 2 ; opt_len -= 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>NAK<S2SV_blank>LIST"" ) ) ; while ( opt_len ) { if ( opt_len < 4 ) { ND_PRINT ( ( ndo , ""[Option<S2SV_blank>length<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4]"" ) ) ; return ; } ND_TCHECK2 ( * bp , 4 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; opt_len -= 4 <S2SV_ModEnd> <S2SV_ModStart> } break ; case PGM_OPT_JOIN : # define PGM_OPT_JOIN_LEN ( 2 + 2 + 4 ) <S2SV_ModEnd> <S2SV_ModStart> PGM_OPT_JOIN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_JOIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_JOIN_LEN <S2SV_ModEnd> <S2SV_ModStart> 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>JOIN<S2SV_blank>%u"" , seq <S2SV_ModEnd> <S2SV_ModStart> PGM_OPT_JOIN_LEN ; break ; case PGM_OPT_NAK_BO_IVL : # define PGM_OPT_NAK_BO_IVL_LEN ( 2 + 2 + 4 + 4 ) <S2SV_ModEnd> <S2SV_ModStart> != PGM_OPT_NAK_BO_IVL_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_IVL<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NAK_BO_IVL_LEN <S2SV_ModEnd> <S2SV_ModStart> bp += 2 ; offset = <S2SV_ModEnd> <S2SV_ModStart> ; bp += 4 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>ivlseq<S2SV_blank>%u"" , offset , seq ) <S2SV_ModEnd> <S2SV_ModStart> PGM_OPT_NAK_BO_IVL_LEN ; break ; case PGM_OPT_NAK_BO_RNG : # define PGM_OPT_NAK_BO_RNG_LEN ( 2 + 2 + 4 + 4 ) <S2SV_ModEnd> <S2SV_ModStart> PGM_OPT_NAK_BO_RNG_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_RNG<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NAK_BO_RNG_LEN <S2SV_ModEnd> <S2SV_ModStart> offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; <S2SV_ModStart> 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>min<S2SV_blank>%u"" , offset <S2SV_ModEnd> <S2SV_ModStart> PGM_OPT_NAK_BO_RNG_LEN ; break ; case PGM_OPT_REDIRECT : # define PGM_OPT_REDIRECT_FIXED_LEN ( 2 + 2 + 2 + 2 ) <S2SV_ModEnd> <S2SV_ModStart> < PGM_OPT_REDIRECT_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN ) ) ; return ; } bp += 2 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr <S2SV_ModEnd> <S2SV_ModStart> PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 <S2SV_ModEnd> <S2SV_ModStart> PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , PGM_OPT_REDIRECT_FIXED_LEN <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr <S2SV_ModEnd> <S2SV_ModStart> PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>REDIRECT<S2SV_blank>%s"" , nla_buf ) ) ; break ; case PGM_OPT_PARITY_PRM : # define PGM_OPT_PARITY_PRM_LEN ( 2 + 2 + 4 ) <S2SV_ModEnd> <S2SV_ModStart> PGM_OPT_PARITY_PRM_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_PRM<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_PARITY_PRM_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>MAXTGS<S2SV_blank>%u"" , len ) <S2SV_ModEnd> <S2SV_ModStart> PGM_OPT_PARITY_PRM_LEN ; break ; case PGM_OPT_PARITY_GRP : # define PGM_OPT_PARITY_GRP_LEN ( 2 + 2 + 4 ) <S2SV_ModEnd> <S2SV_ModStart> PGM_OPT_PARITY_GRP_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_GRP<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_PARITY_GRP_LEN ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>GROUP<S2SV_blank>%u"" , seq ) <S2SV_ModEnd> <S2SV_ModStart> PGM_OPT_PARITY_GRP_LEN ; break ; case PGM_OPT_CURR_TGSIZE : # define PGM_OPT_CURR_TGSIZE_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_CURR_TGSIZE_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_CURR_TGSIZE<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_CURR_TGSIZE_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>ATGS<S2SV_blank>%u"" , len ) ) ; opts_len -= PGM_OPT_CURR_TGSIZE_LEN ; break ; case PGM_OPT_NBR_UNREACH : # define PGM_OPT_NBR_UNREACH_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_NBR_UNREACH_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NBR_UNREACH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NBR_UNREACH_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>NBR_UNREACH"" ) ) ; opts_len -= PGM_OPT_NBR_UNREACH_LEN ; break ; case PGM_OPT_PATH_NLA : ND_PRINT ( ( ndo , ""<S2SV_blank>PATH_NLA<S2SV_blank>[%d]"" , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_SYN : # define PGM_OPT_SYN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_SYN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_SYN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_SYN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>SYN"" ) ) ; opts_len -= PGM_OPT_SYN_LEN ; break ; case PGM_OPT_FIN : # define PGM_OPT_FIN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_FIN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_FIN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>FIN"" ) ) ; opts_len -= PGM_OPT_FIN_LEN ; break ; case PGM_OPT_RST : # define PGM_OPT_RST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_RST_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_RST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_RST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>RST"" ) ) ; opts_len -= PGM_OPT_RST_LEN ; break ; case PGM_OPT_CR : ND_PRINT ( ( ndo , ""<S2SV_blank>CR"" ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_CRQST : # define PGM_OPT_CRQST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_CRQST_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_CRQST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_CRQST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>CRQST"" ) ) ; opts_len -= PGM_OPT_CRQST_LEN ; break ; case PGM_OPT_PGMCC_DATA : # define PGM_OPT_PGMCC_DATA_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) if ( opt_len < PGM_OPT_PGMCC_DATA_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank>PGMCC<S2SV_blank>DATA<S2SV_blank>%u<S2SV_blank>%s"" , offset <S2SV_ModEnd> <S2SV_ModStart> PGM_OPT_PGMCC_FEEDBACK : # define PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) <S2SV_ModEnd> <S2SV_ModStart> < PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>PGM_OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr <S2SV_ModEnd> <S2SV_ModStart> PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 <S2SV_ModEnd> <S2SV_ModStart> PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr <S2SV_ModEnd> <S2SV_ModStart> PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <S2SV_ModEnd> "
4820,<S2SV_StartBug> static void cancel_att_send_op ( struct att_send_op * op ) <S2SV_EndBug> ,<S2SV_ModStart> void * data ) { <S2SV_ModStart> = data ; <S2SV_ModEnd> 
4821,<S2SV_StartBug> for ( i = 0 ; i < sec -> size ; i += 4 ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < sec -> size ; i += 8 ) { <S2SV_EndBug> ,<S2SV_ModStart> ( i + 3 ) <S2SV_ModEnd> <S2SV_ModStart> ( i + 7 ) <S2SV_ModEnd> 
4822,<S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( cache -> free_total < NW_CACHE_MAX_SIZE ) <S2SV_ModStart> else { free ( obj ) ; } 
4823,<S2SV_StartBug> jpc_tsfb_band_t bnds [ 64 ] ; <S2SV_EndBug> ,<S2SV_ModStart> JPC_MAXBANDS <S2SV_ModEnd> 
4824,"<S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> ","<S2SV_ModStart> , XEN_NETIF_RSP_OKAY "
4825,<S2SV_StartBug> g_clear_object ( & client -> proxy ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; g_byte_array_free ( client -> auth_buffer , TRUE "
4826,"<S2SV_StartBug> if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> ",<S2SV_ModStart> 3 == <S2SV_ModStart> && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> 
4827,"<S2SV_StartBug> if ( jas_stream_copy ( out , tmpstream , box -> len - JP2_BOX_HDRLEN ( false ) ) ) { <S2SV_EndBug> ","<S2SV_ModStart> jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n"" ) ; "
4828,<S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> <S2SV_StartBug> pbi -> common . error . error_code = VPX_CODEC_OK ; <S2SV_EndBug> <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> <S2SV_StartBug> return retcode ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( void ) size ; ( void ) source ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vp8_clear_system_state ( ) ; 
4829,"<S2SV_StartBug> truncate_pagecache ( inode , ioffset ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> goto out_dio ; <S2SV_EndBug> <S2SV_StartBug> out_dio : <S2SV_EndBug> ",<S2SV_ModStart> ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> out_mmap <S2SV_ModEnd> <S2SV_ModStart> out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModEnd> 
4830,<S2SV_StartBug> ACPI_FUNCTION_TRACE ( NsTerminate ) ; <S2SV_EndBug> <S2SV_StartBug> ACPI_OPERAND_OBJECT * Next ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; ACPI_FUNCTION_TRACE ( NsTerminate ) <S2SV_ModStart>  <S2SV_ModEnd> 
4831,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> 
4832,<S2SV_StartBug> outpos += <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sendClean ( outputbuffer ) ; 
4833,"<S2SV_StartBug> dm9000WriteReg ( DM9000_REG_MAR0 + i , hashTable [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000ReadReg ( DM9000_REG_MAR0 ) , dm9000ReadReg ( DM9000_REG_MAR1 ) , <S2SV_EndBug> ","<S2SV_ModStart> DM9000_MAR0 <S2SV_ModEnd> <S2SV_ModStart> DM9000_MAR0 ) , dm9000ReadReg ( DM9000_MAR1 ) , dm9000ReadReg ( DM9000_MAR2 ) , dm9000ReadReg ( DM9000_MAR3 ) , dm9000ReadReg ( DM9000_MAR4 ) , dm9000ReadReg ( DM9000_MAR5 ) , dm9000ReadReg ( DM9000_MAR6 ) , dm9000ReadReg ( DM9000_MAR7 <S2SV_ModEnd> "
4834,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( args -> rmtblkno ) { <S2SV_EndBug> ,<S2SV_ModStart> args -> rmtvaluelen2 = args -> rmtvaluelen ; args -> rmtblkno = 0 ; args -> rmtblkcnt = 0 ; args -> rmtvaluelen = 0 ; <S2SV_ModStart> args -> rmtvaluelen = args -> rmtvaluelen2 ; 
4835,"<S2SV_StartBug> parse_field ( netdissect_options * ndo , const char * * pptr , int * len ) <S2SV_EndBug> <S2SV_StartBug> if ( * len <= 0 || ! pptr || ! * pptr ) <S2SV_EndBug> <S2SV_StartBug> while ( * pptr <= ( const char * ) ndo -> ndo_snapend && * len >= 0 && * * pptr ) { <S2SV_EndBug> <S2SV_StartBug> if ( * len < 0 || * pptr > ( const char * ) ndo -> ndo_snapend ) <S2SV_EndBug> ","<S2SV_ModStart> , int * truncated <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> for ( ; ; ) { if ( * len == 0 ) { return NULL ; } if ( ! ND_TTEST ( <S2SV_ModEnd> <S2SV_ModStart> ) { * truncated = 1 ; return NULL ; } if ( * * pptr == '\\0' ) { break ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4836,"<S2SV_StartBug> size_t addr_incr = MIN ( CORE_MMU_USER_CODE_SIZE , <S2SV_EndBug> <S2SV_StartBug> if ( ADD_OVERFLOW ( uaddr , len , & a ) ) <S2SV_EndBug> <S2SV_StartBug> for ( a = uaddr ; a < ( uaddr + len ) ; a += addr_incr ) { <S2SV_EndBug> ","<S2SV_ModStart> uaddr_t end_addr = 0 ; <S2SV_ModStart> end_addr <S2SV_ModEnd> <S2SV_ModStart> ROUNDDOWN ( uaddr , addr_incr ) <S2SV_ModEnd> <S2SV_ModStart> end_addr <S2SV_ModEnd> "
4837,<S2SV_StartBug> size_t data_size = <S2SV_EndBug> <S2SV_StartBug> entry . count ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( validate_and_calculate_camera_metadata_entry_data_size ( & data_size , <S2SV_ModEnd> <S2SV_ModStart> != OK ) { ALOGE ( ""%s:<S2SV_blank>Entry<S2SV_blank>data<S2SV_blank>size<S2SV_blank>is<S2SV_blank>invalid.<S2SV_blank>type:<S2SV_blank>%u<S2SV_blank>count:<S2SV_blank>%u"" , __FUNCTION__ , entry . type , entry . count ) ; return ERROR ; } <S2SV_ModEnd> "
4838,<S2SV_StartBug> temp = EXTRACT_32BITS ( bp ) ; <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK_32BITS ( bp ) ; 
4839,"<S2SV_StartBug> static char * mongo_data_append ( char * start , const void * data , int len ) { <S2SV_EndBug> ",<S2SV_ModStart> size_t <S2SV_ModEnd> 
4840,<S2SV_StartBug> mmu_notifier_mm_init ( mm ) ; <S2SV_EndBug> ,"<S2SV_ModStart> RCU_INIT_POINTER ( mm -> exe_file , NULL ) ; "
4841,"<S2SV_StartBug> * outlen = utf8s_to_utf16s ( name , len , ( wchar_t * ) outname ) ; <S2SV_EndBug> ","<S2SV_ModStart> UTF16_HOST_ENDIAN , <S2SV_ModStart> , FAT_LFN_LEN + 2 "
4842,"<S2SV_StartBug> int max_intra_size_pct ; <S2SV_EndBug> <S2SV_StartBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <S2SV_EndBug> <S2SV_StartBug> res = parse_quantizer_values ( svc_ctx , si -> quantizers , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> res = parse_quantizer_values ( svc_ctx , si -> quantizers_keyframe , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( si -> quantizer_keyframe , si -> quantizer , sizeof ( si -> quantizer ) ) ; <S2SV_EndBug> <S2SV_StartBug> res = parse_options ( svc_ctx , si -> options ) ; <S2SV_EndBug> <S2SV_StartBug> res = vpx_codec_enc_init ( codec_ctx , iface , enc_cfg , VPX_CODEC_USE_PSNR ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_codec_control ( codec_ctx , VP9E_SET_SVC , 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int i ; SvcInternal_t <S2SV_ModEnd> <S2SV_ModStart> if ( svc_ctx -> temporal_layering_mode == 3 ) { svc_ctx -> temporal_layers = 3 ; } else if ( svc_ctx -> temporal_layering_mode == 2 ) { svc_ctx -> temporal_layers = 2 ; } for ( i = 0 ; i < VPX_SS_MAX_LAYERS ; ++ i ) { si -> svc_params . max_quantizers [ i ] = MAX_QUANTIZER ; si -> svc_params . min_quantizers [ i ] = 0 ; si -> svc_params . scaling_factor_num [ i ] = DEFAULT_SCALE_FACTORS_NUM [ i ] ; si -> svc_params . scaling_factor_den [ i ] = DEFAULT_SCALE_FACTORS_DEN [ i ] ; } res = parse_options ( svc_ctx , si -> options <S2SV_ModEnd> <S2SV_ModStart> if ( svc_ctx -> spatial_layers < 1 ) svc_ctx -> spatial_layers = 1 ; if ( svc_ctx -> spatial_layers > VPX_SS_MAX_LAYERS ) svc_ctx -> spatial_layers = VPX_SS_MAX_LAYERS ; if ( svc_ctx -> temporal_layers < 1 ) svc_ctx -> temporal_layers = 1 ; if ( svc_ctx -> temporal_layers > VPX_TS_MAX_LAYERS ) svc_ctx -> temporal_layers = VPX_TS_MAX_LAYERS ; if ( svc_ctx -> temporal_layers * svc_ctx -> spatial_layers > VPX_MAX_LAYERS ) { svc_log ( svc_ctx , SVC_LOG_ERROR , ""spatial<S2SV_blank>layers<S2SV_blank>*<S2SV_blank>temporal<S2SV_blank>layers<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>number<S2SV_blank>of<S2SV_blank>"" ""allowed<S2SV_blank>layers<S2SV_blank>of<S2SV_blank>%d\\n"" , svc_ctx -> spatial_layers * svc_ctx -> temporal_layers , ( int ) VPX_MAX_LAYERS ) ; return VPX_CODEC_INVALID_PARAM ; } assign_layer_bitrates ( svc_ctx , enc_cfg ) ; # if CONFIG_SPATIAL_SVC for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) enc_cfg -> ss_enable_auto_alt_ref [ i ] = si -> enable_auto_alt_ref [ i ] ; # endif if ( svc_ctx -> temporal_layers > 1 ) { int i ; for ( i = 0 ; i < svc_ctx -> temporal_layers ; ++ i ) { enc_cfg -> ts_target_bitrate [ i ] = enc_cfg -> rc_target_bitrate / svc_ctx -> temporal_layers ; enc_cfg -> ts_rate_decimator [ i ] = 1 << ( svc_ctx -> temporal_layers - 1 - i ) ; } } if ( svc_ctx -> threads ) enc_cfg -> g_threads = svc_ctx -> threads ; enc_cfg -> ss_number_layers = svc_ctx -> spatial_layers ; enc_cfg -> ts_number_layers = svc_ctx -> temporal_layers ; if ( enc_cfg -> rc_end_usage == VPX_CBR ) { enc_cfg -> rc_resize_allowed = 0 ; enc_cfg -> rc_min_quantizer = 2 ; enc_cfg -> rc_max_quantizer = 63 ; enc_cfg -> rc_undershoot_pct = 50 ; enc_cfg -> rc_overshoot_pct = 50 ; enc_cfg -> rc_buf_initial_sz = 20 ; enc_cfg -> rc_buf_optimal_sz = 600 ; enc_cfg -> rc_buf_sz = 1000 ; } if ( enc_cfg -> g_error_resilient == 0 && si -> use_multiple_frame_contexts == 0 ) enc_cfg -> g_error_resilient = 1 ; res = vpx_codec_enc_init ( codec_ctx , iface , enc_cfg , VPX_CODEC_USE_PSNR <S2SV_ModEnd> <S2SV_ModStart> { svc_log ( svc_ctx , SVC_LOG_ERROR , ""svc_enc_init<S2SV_blank>error\\n"" ) ; <S2SV_ModEnd> <S2SV_ModStart> } vpx_codec_control <S2SV_ModEnd> <S2SV_ModStart> VP9E_SET_SVC , 1 ) ; <S2SV_ModEnd> <S2SV_ModStart> VP9E_SET_SVC_PARAMETERS , & si -> svc_params <S2SV_ModEnd> "
4843,"<S2SV_StartBug> ldblk , sizeof ( * BImgBuff ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> + 1 
4844,<S2SV_StartBug> if ( mk_security_check_url ( sr -> uri ) < 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> uri_processed <S2SV_ModEnd> 
4845,"<S2SV_StartBug> char * ksep , * vsep , * val ; <S2SV_EndBug> <S2SV_StartBug> vsep = memchr ( var -> ptr , '&' , var -> end - var -> ptr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! eof ) { <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ","<S2SV_ModStart> start , * <S2SV_ModStart> start = var -> ptr + var -> already_scanned ; <S2SV_ModStart> start <S2SV_ModEnd> <S2SV_ModStart> start <S2SV_ModEnd> <S2SV_ModStart> var -> already_scanned = var -> end - var -> ptr ; <S2SV_ModStart> var -> already_scanned = 0 ; "
4846,"<S2SV_StartBug> if ( strchr ( page , '/' ) ) <S2SV_EndBug> ",<S2SV_ModStart> ! page_name_is_good ( page <S2SV_ModEnd> 
4847,"<S2SV_StartBug> entries = kmalloc ( sizeof ( * entries ) * cmap -> len , GFP_KERNEL ) ; <S2SV_EndBug> ","<S2SV_ModStart> kmalloc_array ( cmap -> len , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> "
4848,<S2SV_StartBug> const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ; <S2SV_EndBug> ,<S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> 
4849,"<S2SV_StartBug> int procfd = payload -> procfd ; <S2SV_EndBug> <S2SV_StartBug> uid_t new_uid ; <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0)"" ) ; <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1)"" ) ; <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>final<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(2)"" ) ; <S2SV_EndBug> <S2SV_StartBug> rexit ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ""gainable<S2SV_blank>privileges."" ) ; <S2SV_EndBug> <S2SV_StartBug> on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( lsm_set_label_at ( procfd , on_exec , init_ctx -> lsm_label ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> rexit ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> rexit ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> close ( procfd ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int lsm_labelfd ; <S2SV_ModStart> ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0):<S2SV_blank>%s."" , strerror ( errno ) <S2SV_ModEnd> <S2SV_ModStart> ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1):<S2SV_blank>%s."" , strerror ( errno ) <S2SV_ModEnd> <S2SV_ModStart> ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>message<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>"" ""that<S2SV_blank>it<S2SV_blank>is<S2SV_blank>done<S2SV_blank>pre-initializing<S2SV_blank>(2):<S2SV_blank>%s"" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModEnd> <S2SV_ModStart> shutdown ( ipc_socket , SHUT_RDWR ) ; <S2SV_ModStart> ) ; } status = 3 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>set<S2SV_blank>up<S2SV_blank>LSM<S2SV_blank>labels<S2SV_blank>(3):<S2SV_blank>%s."" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 <S2SV_ModStart> ret = lxc_abstract_unix_recv_fd ( ipc_socket , & lsm_labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s."" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> lsm_labelfd <S2SV_ModEnd> <S2SV_ModStart> SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label."" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; close ( lsm_labelfd ) ; rexit ( - 1 ) ; } close ( lsm_labelfd ) ; <S2SV_ModEnd> <S2SV_ModStart> shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4850,"<S2SV_StartBug> int64_t vp9_pick_inter_mode ( VP9_COMP * cpi , MACROBLOCK * x , <S2SV_EndBug> <S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> MB_PREDICTION_MODE this_mode , best_mode = ZEROMV ; <S2SV_EndBug> <S2SV_StartBug> MV_REFERENCE_FRAME ref_frame , best_ref_frame = LAST_FRAME ; <S2SV_EndBug> <S2SV_StartBug> int64_t best_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> int intra_cost_penalty = 20 * vp9_dc_quant ( cm -> base_qindex , cm -> y_dc_delta_q ) ; <S2SV_EndBug> <S2SV_StartBug> intra_cost_penalty , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> const int * const rd_threshes = cpi -> rd_threshes [ segment_id ] [ bsize ] ; <S2SV_EndBug> <S2SV_StartBug> const int * const rd_thresh_freq_fact = cpi -> rd_thresh_freq_fact [ bsize ] ; <S2SV_EndBug> <S2SV_StartBug> INTERP_FILTER filter_ref = SWITCHABLE ; <S2SV_EndBug> <S2SV_StartBug> EIGHTTAP : cpi -> common . interp_filter ; <S2SV_EndBug> <S2SV_StartBug> mbmi -> segment_id = segment_id ; <S2SV_EndBug> <S2SV_StartBug> for ( ref_frame = LAST_FRAME ; ref_frame <= LAST_FRAME ; ++ ref_frame ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) ) <S2SV_EndBug> <S2SV_StartBug> xd -> plane [ 0 ] . pre [ 0 ] = yv12_mb [ ref_frame ] [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( ref_frame == LAST_FRAME ) { <S2SV_EndBug> <S2SV_StartBug> ( 1 << INTER_OFFSET ( this_mode ) ) ) <S2SV_EndBug> <S2SV_StartBug> int rate_mode = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( this_rd < ( int64_t ) ( 1 << num_pels_log2_lookup [ bsize ] ) ) <S2SV_EndBug> <S2SV_StartBug> & frame_mv [ NEWMV ] [ ref_frame ] , & rate_mv ) ; <S2SV_EndBug> <S2SV_StartBug> if ( frame_mv [ NEWMV ] [ ref_frame ] . as_int == INVALID_MV ) <S2SV_EndBug> <S2SV_StartBug> if ( this_mode != NEARESTMV ) <S2SV_EndBug> <S2SV_StartBug> mbmi -> mv [ 0 ] . as_int = frame_mv [ this_mode ] [ ref_frame ] . as_int ; <S2SV_EndBug> <S2SV_StartBug> ( ( mbmi -> mv [ 0 ] . as_mv . row & 0x07 ) != 0 || <S2SV_EndBug> <S2SV_StartBug> mbmi -> interp_filter = EIGHTTAP ; <S2SV_EndBug> <S2SV_StartBug> model_rd_for_sb_y ( cpi , bsize , x , xd , & pf_rate [ EIGHTTAP ] , <S2SV_EndBug> <S2SV_StartBug> & pf_dist [ EIGHTTAP ] ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_get_switchable_rate ( x ) + pf_rate [ EIGHTTAP ] , <S2SV_EndBug> <S2SV_StartBug> model_rd_for_sb_y ( cpi , bsize , x , xd , & rate , & dist ) ; <S2SV_EndBug> <S2SV_StartBug> rate += x -> inter_mode_cost [ mbmi -> mode_context [ ref_frame ] ] <S2SV_EndBug> <S2SV_StartBug> best_ref_frame = ref_frame ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> mbmi -> ref_frame [ 0 ] = best_ref_frame ; <S2SV_EndBug> <S2SV_StartBug> if ( best_rd > inter_mode_thresh ) { <S2SV_EndBug> <S2SV_StartBug> vp9_predict_intra_block ( xd , 0 , b_width_log2 ( bsize ) , <S2SV_EndBug> <S2SV_StartBug> rate += intra_cost_penalty ; <S2SV_EndBug> <S2SV_StartBug> this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , dist ) ; <S2SV_EndBug> <S2SV_StartBug> if ( this_rd + intra_mode_cost < best_rd ) { <S2SV_EndBug> ","<S2SV_ModStart> void <S2SV_ModEnd> <S2SV_ModStart> TileDataEnc * tile_data , int mi_row , int mi_col , RD_COST * rd_cost , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) { VP9_COMMON * const cm = & cpi -> common ; SPEED_FEATURES * const sf = & cpi -> sf ; <S2SV_ModEnd> <S2SV_ModStart> tile_info = & tile_data -> tile_info ; MACROBLOCKD * const <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> ; MV_REFERENCE_FRAME usable_ref_frame ; TX_SIZE best_tx_size = TX_SIZES <S2SV_ModStart> RD_COST this_rdc , best_rdc ; uint8_t skip_txfm = SKIP_TXFM_NONE , best_mode_skip_txfm = SKIP_TXFM_NONE ; unsigned int var_y = UINT_MAX ; unsigned int sse_y = UINT_MAX ; const int reduction_fac = ( bsize <= BLOCK_16X16 ) ? ( ( bsize <= BLOCK_8X8 ) ? 4 : 2 ) : 0 ; const <S2SV_ModEnd> <S2SV_ModStart> vp9_get_intra_cost_penalty ( <S2SV_ModEnd> <S2SV_ModStart> , cm -> bit_depth ) >> reduction_fac <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rd . threshes [ mbmi -> <S2SV_ModEnd> <S2SV_ModStart> tile_data -> thresh_freq_fact <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; const int bsl = mi_width_log2_lookup [ bsize ] ; const int pred_filter_search = cm -> <S2SV_ModEnd> <S2SV_ModStart> ( ( ( mi_row + mi_col ) >> bsl ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 : 0 ; int const_motion [ MAX_REF_FRAMES ] = { 0 } ; const int bh = num_4x4_blocks_high_lookup [ bsize ] << 2 ; const int bw = num_4x4_blocks_wide_lookup [ bsize ] << 2 ; PRED_BUFFER tmp [ 4 ] ; DECLARE_ALIGNED ( 16 , uint8_t , pred_buf [ 3 * 64 * 64 ] ) ; # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , pred_buf_16 [ 3 * 64 * 64 ] ) ; # endif struct buf_2d orig_dst = pd -> dst ; PRED_BUFFER * best_pred = NULL ; PRED_BUFFER * this_mode_pred = NULL ; const int pixels_in_block = bh * bw ; int reuse_inter_pred = cpi -> sf . reuse_inter_pred_sby && ctx -> pred_pixel_ready ; int ref_frame_skip_mask = 0 ; int idx ; int best_pred_sad = INT_MAX ; int best_early_term = 0 ; int ref_frame_cost [ MAX_REF_FRAMES ] ; init_ref_frame_cost ( cm , xd , ref_frame_cost ) ; if ( reuse_inter_pred ) { int i ; for ( i = 0 ; i < 3 ; i ++ ) { # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) tmp [ i ] . data = CONVERT_TO_BYTEPTR ( & pred_buf_16 [ pixels_in_block * i ] ) ; else tmp [ i ] . data = & pred_buf [ pixels_in_block * i ] ; # else tmp [ i ] . data = & pred_buf [ pixels_in_block * i ] ; # endif tmp [ i ] . stride = bw ; tmp [ i ] . in_use = 0 ; } tmp [ 3 ] . data = pd -> dst . buf ; tmp [ 3 ] . stride = pd -> dst . stride ; tmp [ 3 ] . in_use = 0 ; } x -> skip_encode = cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ; x <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> else filter_ref = cm -> interp_filter ; vp9_rd_cost_reset ( & best_rdc ) ; vp9_rd_cost_reset ( rd_cost ) ; mbmi -> sb_type = bsize ; mbmi -> ref_frame [ 0 ] = NONE ; mbmi -> ref_frame [ 1 ] = NONE ; mbmi -> tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cm -> tx_mode ] ) ; # if CONFIG_VP9_TEMPORAL_DENOISING vp9_denoiser_reset_frame_stats ( ctx ) ; # endif if ( cpi -> rc . frames_since_golden == 0 && ! cpi -> use_svc ) { usable_ref_frame = LAST_FRAME ; } else { usable_ref_frame = GOLDEN_FRAME ; } <S2SV_ModStart> usable_ref_frame <S2SV_ModEnd> <S2SV_ModStart> const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , ref_frame ) ; x -> pred_mv_sad [ ref_frame ] = INT_MAX ; frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ; frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ; if ( ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) && ( yv12 != NULL ) ) { int_mv * const candidates = x -> mbmi_ext -> ref_mvs [ ref_frame ] ; const struct scale_factors * const sf = & cm -> frame_refs [ ref_frame - 1 ] . sf ; vp9_setup_pred_block ( xd , yv12_mb [ ref_frame ] , yv12 , mi_row , mi_col , sf , sf ) ; if ( cm -> use_prev_frame_mvs ) vp9_find_mv_refs ( cm , xd , xd -> mi [ 0 ] , ref_frame , candidates , mi_row , mi_col , NULL , NULL , x -> mbmi_ext -> mode_context ) ; else const_motion [ ref_frame ] = mv_refs_rt ( cm , x , xd , tile_info , xd -> mi [ 0 ] , ref_frame , candidates , mi_row , mi_col ) ; vp9_find_best_ref_mvs ( xd , cm -> allow_high_precision_mv , candidates , & frame_mv [ NEARESTMV ] [ ref_frame ] , & frame_mv [ NEARMV ] [ ref_frame ] ) ; <S2SV_ModStart> vp9_is_scaled ( sf ) && bsize >= BLOCK_8X8 ) vp9_mv_pred ( cpi , x , yv12_mb [ ref_frame ] [ 0 ] . buf , yv12 -> y_stride , ref_frame , bsize ) ; } else { ref_frame_skip_mask |= ( 1 << ref_frame ) ; } } for ( idx = 0 ; idx < RT_INTER_MODES ; ++ idx ) { int rate_mv = 0 ; int mode_rd_thresh ; int mode_index ; int i ; int64_t this_sse ; int is_skippable ; int this_early_term = 0 ; PREDICTION_MODE this_mode = ref_mode_set [ idx ] . pred_mode ; if ( cpi -> use_svc ) this_mode = ref_mode_set_svc [ idx ] . pred_mode ; if ( ! ( cpi -> sf . inter_mode_mask [ bsize ] & ( 1 << this_mode ) ) ) continue ; ref_frame = ref_mode_set [ idx ] . ref_frame ; if ( cpi -> use_svc ) ref_frame = ref_mode_set_svc [ idx ] . ref_frame ; if ( ! <S2SV_ModStart> if ( const_motion [ ref_frame ] && this_mode == NEARMV ) continue ; i = <S2SV_ModEnd> <S2SV_ModStart> ? GOLDEN_FRAME : LAST_FRAME ; if ( ( cpi -> ref_frame_flags & flag_list [ i ] ) && sf -> reference_masking ) if ( x -> pred_mv_sad [ ref_frame ] > ( x -> pred_mv_sad [ i ] << 1 ) ) ref_frame_skip_mask |= <S2SV_ModEnd> <S2SV_ModStart> ref_frame ) ; if ( ref_frame_skip_mask & ( 1 << ref_frame ) ) continue ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) xd -> plane [ i ] . pre [ 0 ] = yv12_mb [ ref_frame ] [ i ] ; mbmi -> ref_frame [ 0 ] = ref_frame ; set_ref_ptrs ( cm , xd , ref_frame , NONE ) ; mode_index = mode_idx [ ref_frame ] [ <S2SV_ModStart> ] ; mode_rd_thresh = best_mode_skip_txfm ? rd_threshes [ mode_index ] << 1 : rd_threshes [ mode_index ] ; if ( rd_less_than_thresh ( best_rdc . rdcost , mode_rd_thresh , rd_thresh_freq_fact [ mode_index ] ) <S2SV_ModEnd> <S2SV_ModStart> if ( ref_frame > LAST_FRAME && ! cpi -> use_svc ) { int tmp_sad ; int dis , cost_list [ 5 ] ; if ( bsize < BLOCK_16X16 ) continue ; tmp_sad = vp9_int_pro_motion_estimation ( cpi , x , bsize , mi_row , mi_col ) ; if ( tmp_sad > x -> pred_mv_sad [ LAST_FRAME ] ) continue ; if ( tmp_sad + ( num_pels_log2_lookup [ bsize ] << 4 ) > best_pred_sad ) continue ; frame_mv [ NEWMV ] [ ref_frame ] . as_int = mbmi -> mv [ 0 ] . as_int ; rate_mv = vp9_mv_bit_cost ( & frame_mv [ NEWMV ] [ ref_frame ] . as_mv , & x -> mbmi_ext -> ref_mvs [ ref_frame ] [ 0 ] . as_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; frame_mv [ NEWMV ] [ ref_frame ] . as_mv . row >>= 3 ; frame_mv [ NEWMV ] [ ref_frame ] . as_mv . col >>= 3 ; cpi -> find_fractional_mv_step ( x , & frame_mv [ NEWMV ] [ ref_frame ] . as_mv , & x -> mbmi_ext -> ref_mvs [ ref_frame ] [ 0 ] . as_mv , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr <S2SV_ModEnd> <S2SV_ModStart> , cpi -> sf . mv . subpel_force_stop , cpi -> sf . mv . subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , x -> nmvjointcost , x -> mvcost , & dis , & x -> pred_sse [ ref_frame ] , NULL , 0 , 0 ) ; } else if ( ! combined_motion_search ( cpi , x , bsize , mi_row , mi_col , & frame_mv [ NEWMV ] [ ref_frame ] , & rate_mv , best_rdc . rdcost ) ) { continue ; } } if ( this_mode == NEWMV && ref_frame == LAST_FRAME && frame_mv [ NEWMV ] [ LAST_FRAME ] . as_int != INVALID_MV ) { const int pre_stride = xd -> plane [ 0 ] . pre [ 0 ] . stride ; const uint8_t * const pre_buf = xd -> plane [ 0 ] . pre [ 0 ] . buf + ( frame_mv [ NEWMV ] [ LAST_FRAME ] . as_mv . row >> 3 ) * pre_stride + ( frame_mv [ NEWMV ] [ LAST_FRAME ] . as_mv . col >> 3 ) ; best_pred_sad = cpi -> fn_ptr [ bsize ] . sdf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , pre_buf , pre_stride ) ; x -> pred_mv_sad [ LAST_FRAME ] = best_pred_sad ; } if ( cpi -> use_svc ) { if ( this_mode == NEWMV && ref_frame == GOLDEN_FRAME && <S2SV_ModEnd> <S2SV_ModStart> GOLDEN_FRAME ] . as_int != INVALID_MV ) { const int pre_stride = xd -> plane [ 0 ] . pre [ 0 ] . stride ; const uint8_t * const pre_buf = xd -> plane [ 0 ] . pre [ 0 ] . buf + <S2SV_ModEnd> <S2SV_ModStart> GOLDEN_FRAME ] . as_mv . row >> 3 ) * pre_stride + ( frame_mv [ NEWMV ] [ GOLDEN_FRAME ] . as_mv . col >> 3 ) ; best_pred_sad = cpi -> fn_ptr [ bsize ] . sdf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , pre_buf , pre_stride ) ; x -> pred_mv_sad [ GOLDEN_FRAME ] = best_pred_sad ; } <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> if ( reuse_inter_pred ) { if ( ! this_mode_pred ) { this_mode_pred = & tmp [ 3 ] ; } else { this_mode_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ; pd -> dst . buf = this_mode_pred -> data ; pd -> dst . stride = bw ; } } <S2SV_ModStart> pred_filter_search && ( ref_frame == LAST_FRAME || ( ref_frame == GOLDEN_FRAME && cpi -> use_svc ) ) && ( <S2SV_ModStart> | mbmi -> mv [ 0 ] . as_mv . col ) <S2SV_ModStart> ) ) { <S2SV_ModEnd> <S2SV_ModStart> unsigned int pf_var [ 3 ] ; unsigned int pf_sse [ 3 ] ; TX_SIZE pf_tx_size [ 3 ] ; int64_t best_cost = INT64_MAX ; INTERP_FILTER best_filter = SWITCHABLE , filter ; PRED_BUFFER * current_pred = this_mode_pred ; for ( filter = EIGHTTAP ; filter <= EIGHTTAP_SMOOTH ; ++ filter ) { int64_t cost ; <S2SV_ModStart> filter <S2SV_ModEnd> <S2SV_ModStart> filter ] , <S2SV_ModEnd> <S2SV_ModStart> filter ] , & pf_var [ filter ] , & pf_sse [ filter ] ) ; pf_rate [ filter ] += vp9_get_switchable_rate ( cpi , xd ) ; cost <S2SV_ModEnd> <S2SV_ModStart> pf_rate [ filter ] , pf_dist [ filter ] ) ; pf_tx_size [ filter ] = mbmi -> tx_size ; if ( cost < best_cost ) { best_filter = filter ; best_cost = cost ; skip_txfm = x -> skip_txfm [ 0 ] ; if ( reuse_inter_pred ) { if ( this_mode_pred != current_pred ) { free_pred_buffer ( this_mode_pred ) ; this_mode_pred = current_pred ; } if ( filter < EIGHTTAP_SHARP ) { current_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ; pd -> dst . buf = current_pred -> data ; pd -> dst . stride = bw ; } } } } if ( reuse_inter_pred && this_mode_pred != current_pred ) free_pred_buffer ( current_pred ) ; mbmi -> interp_filter = best_filter ; mbmi -> tx_size = pf_tx_size [ best_filter ] ; this_rdc . rate = pf_rate [ best_filter ] ; this_rdc . dist = pf_dist [ best_filter ] ; var_y = pf_var [ best_filter ] ; sse_y = pf_sse [ best_filter ] ; x -> skip_txfm [ 0 ] = skip_txfm ; if ( reuse_inter_pred ) { pd -> dst . buf = this_mode_pred -> data ; pd -> dst . stride = this_mode_pred -> stride ; } <S2SV_ModEnd> <S2SV_ModStart> if ( bsize > BLOCK_32X32 && ! cyclic_refresh_segment_id_boosted ( xd -> mi [ 0 ] -> mbmi . segment_id ) && cm -> base_qindex ) { model_rd_for_sb_y_large ( cpi , bsize , x , xd , & this_rdc . rate , & this_rdc . dist , & var_y , & sse_y , mi_row , mi_col , & this_early_term ) ; } else { <S2SV_ModStart> this_rdc . <S2SV_ModStart> this_rdc . dist , & var_y , & sse_y ) ; } } if ( ! this_early_term ) { this_sse = ( int64_t ) sse_y ; block_yrd ( cpi , x , & this_rdc . rate , & this_rdc . dist , & is_skippable , & this_sse , 0 , bsize , MIN ( mbmi -> tx_size , TX_16X16 ) ) ; x -> skip_txfm [ 0 ] = is_skippable ; if ( is_skippable ) { this_rdc . rate = vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; } else { if ( RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) < RDCOST ( x -> rdmult , x -> rddiv , 0 , this_sse ) ) { this_rdc . rate += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; } else { this_rdc . rate = vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; this_rdc . dist = this_sse ; x -> skip_txfm [ 0 ] = SKIP_TXFM_AC_DC ; } } if ( cm -> interp_filter == SWITCHABLE ) { if ( ( mbmi -> mv [ 0 ] . as_mv . row | mbmi -> mv [ 0 ] . as_mv . col ) & 0x07 ) this_rdc . rate += vp9_get_switchable_rate ( cpi , xd ) ; } } else { this_rdc . rate += cm -> interp_filter == SWITCHABLE ? vp9_get_switchable_rate ( cpi , xd ) : 0 ; this_rdc . rate += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; } if ( x -> color_sensitivity [ 0 ] || x -> color_sensitivity [ 1 ] ) { int uv_rate = 0 ; int64_t uv_dist = 0 ; if ( x -> color_sensitivity [ 0 ] ) vp9_build_inter_predictors_sbp ( xd , mi_row , mi_col , bsize , 1 ) ; if ( x -> color_sensitivity [ 1 ] ) vp9_build_inter_predictors_sbp ( xd , mi_row , mi_col , bsize , 2 ) ; model_rd_for_sb_uv ( cpi , bsize , x , xd , & uv_rate , & uv_dist , & var_y , & sse_y ) ; this_rdc . rate += uv_rate ; this_rdc . dist += uv_dist ; } this_rdc . <S2SV_ModEnd> <S2SV_ModStart> this_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> x -> mbmi_ext -> mode_context [ ref_frame ] ] [ INTER_OFFSET ( this_mode ) ] ; this_rdc . rate += ref_frame_cost [ ref_frame ] ; this_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) ; if ( cpi -> allow_encode_breakout ) { encode_breakout_test ( cpi , x , bsize , mi_row , mi_col , ref_frame , this_mode , var_y , sse_y , yv12_mb , & this_rdc . rate , & this_rdc . dist ) ; if ( x -> skip ) { this_rdc . rate += rate_mv ; this_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) ; } } # if CONFIG_VP9_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) vp9_denoiser_update_frame_stats ( mbmi , sse_y , this_mode , ctx ) ; # else ( void ) ctx ; # endif if ( this_rdc . rdcost < best_rdc . rdcost || x -> skip ) { best_rdc = this_rdc <S2SV_ModEnd> <S2SV_ModStart> best_tx_size = mbmi -> tx_size ; <S2SV_ModStart> best_mode_skip_txfm = x -> skip_txfm [ 0 ] ; best_early_term = this_early_term ; if ( reuse_inter_pred ) { free_pred_buffer ( best_pred ) ; best_pred = this_mode_pred ; } } else { if ( reuse_inter_pred ) free_pred_buffer ( this_mode_pred ) ; } if ( x -> skip ) break ; if ( best_early_term && idx > 0 ) { x -> skip = 1 ; break ; <S2SV_ModEnd> <S2SV_ModStart> tx_size = best_tx_size ; mbmi -> <S2SV_ModStart> x -> skip_txfm [ 0 ] = best_mode_skip_txfm ; if ( best_rdc . rdcost == INT64_MAX || ( ! x -> skip && best_rdc . rdcost > inter_mode_thresh && bsize <= cpi -> sf . max_intra_bsize ) ) { struct estimate_block_intra_args args = { cpi , x , DC_PRED , 0 , 0 } ; const TX_SIZE intra_tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ; int i ; TX_SIZE best_intra_tx_size = TX_SIZES ; if ( reuse_inter_pred && best_pred != NULL ) { if ( best_pred -> data == orig_dst . buf ) { this_mode_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) vpx_highbd_convolve_copy ( best_pred -> data , best_pred -> stride , this_mode_pred -> data , this_mode_pred -> stride , NULL , 0 , NULL , 0 , bw , bh , xd -> bd ) ; else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , this_mode_pred -> data , this_mode_pred -> stride , NULL , 0 , NULL , 0 , bw , bh ) ; # else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , this_mode_pred -> data , this_mode_pred -> stride , NULL , 0 , NULL , 0 , bw , bh ) ; # endif best_pred = this_mode_pred ; } } pd -> dst = orig_dst ; for ( i = 0 ; i < 4 ; ++ i ) { const PREDICTION_MODE this_mode = intra_mode_list [ i ] ; THR_MODES mode_index = mode_idx [ INTRA_FRAME ] [ mode_offset ( this_mode ) ] ; int mode_rd_thresh = rd_threshes [ mode_index ] ; if ( ! ( ( 1 << this_mode ) & cpi -> sf . intra_y_mode_bsize_mask [ bsize ] ) ) continue ; if ( rd_less_than_thresh ( best_rdc . rdcost , mode_rd_thresh , rd_thresh_freq_fact [ mode_index ] ) ) continue ; mbmi -> mode = this_mode ; mbmi -> ref_frame [ 0 ] = INTRA_FRAME ; args . mode = this_mode ; args . rate = 0 ; args . dist = 0 ; mbmi -> tx_size = intra_tx_size ; vp9_foreach_transformed_block_in_plane <S2SV_ModEnd> <S2SV_ModStart> bsize , 0 , estimate_block_intra , & args ) ; this_rdc . rate = args . rate ; this_rdc . dist = args . dist ; this_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> this_rdc . rate += ref_frame_cost [ INTRA_FRAME ] ; this_rdc . <S2SV_ModStart> this_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> this_rdc . rate , this_rdc . <S2SV_ModEnd> <S2SV_ModStart> this_rdc . rdcost < best_rdc . rdcost ) { best_rdc = this_rdc ; best_mode = this_mode ; best_intra_tx_size = mbmi -> tx_size ; best_ref_frame = INTRA_FRAME ; mbmi -> uv_mode = this_mode ; mbmi -> mv [ 0 ] . as_int = INVALID_MV ; best_mode_skip_txfm = x -> skip_txfm [ 0 ] ; } } if ( best_ref_frame != INTRA_FRAME ) { mbmi -> tx_size = best_tx_size ; } else { mbmi -> tx_size = best_intra_tx_size ; } } pd -> dst = orig_dst ; mbmi -> mode = best_mode ; mbmi -> ref_frame [ 0 ] = best_ref_frame ; x -> skip_txfm [ 0 ] = best_mode_skip_txfm ; if ( reuse_inter_pred && best_pred != NULL ) { if ( best_pred -> data != orig_dst . buf && is_inter_mode ( mbmi -> mode ) ) { # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) vpx_highbd_convolve_copy ( best_pred -> data , best_pred -> stride , pd -> dst . buf , pd -> dst . stride , NULL , 0 , NULL , 0 , bw , bh , xd -> bd ) ; else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , pd -> dst . buf , pd -> dst . stride , NULL , 0 , NULL , 0 , bw , bh ) ; # else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , pd -> dst . buf , pd -> dst . stride , NULL , 0 , NULL , 0 , bw , bh ) ; # endif } } if ( cpi -> sf . adaptive_rd_thresh ) { THR_MODES best_mode_idx = mode_idx [ best_ref_frame ] [ mode_offset ( mbmi -> mode ) ] ; if ( best_ref_frame == INTRA_FRAME ) { int intra_modes = sizeof ( intra_mode_list ) / sizeof ( PREDICTION_MODE ) ; int i ; for ( i = 0 ; i < intra_modes ; i ++ ) { update_thresh_freq_fact ( cpi , tile_data , bsize , INTRA_FRAME , best_mode_idx , intra_mode_list [ i ] ) ; } } else { for ( ref_frame = LAST_FRAME ; ref_frame <= GOLDEN_FRAME ; ++ ref_frame ) { PREDICTION_MODE this_mode ; if ( best_ref_frame != ref_frame ) continue ; for ( this_mode = NEARESTMV ; this_mode <= NEWMV ; ++ this_mode ) { update_thresh_freq_fact ( cpi , tile_data , bsize , ref_frame , best_mode_idx , this_mode ) ; } } } } * rd_cost = best_rdc <S2SV_ModEnd> "
4851,<S2SV_StartBug> int r ; <S2SV_EndBug> <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug> ,"<S2SV_ModStart> , dontmax = 0 <S2SV_ModStart> if ( ( st . st_mode & S_IFREG ) == 0 || st . st_size <= 0 ) { st . st_size = 64 * 1024 ; dontmax = 1 ; } if ( ( r = sshbuf_allocate ( blob , st . st_size ) ) != 0 || ( dontmax && ( r = sshbuf_set_max_size ( blob , st . st_size ) ) != 0 ) ) return r ; "
4852,"<S2SV_StartBug> timr -> it_overrun += ( int ) kc -> timer_forward ( timr , now ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
4853,"<S2SV_StartBug> while ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) <S2SV_EndBug> <S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) <S2SV_EndBug> ",<S2SV_ModStart> ( <S2SV_ModStart> ) && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) <S2SV_ModStart> && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) 
4854,<S2SV_StartBug> return rold -> umin_value == 0 && <S2SV_EndBug> ,<S2SV_ModStart> false <S2SV_ModEnd> 
4855,"<S2SV_StartBug> memcpy ( & p -> id , & x -> id , sizeof ( p -> id ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( p , 0 , sizeof ( * p ) ) ; "
4856,<S2SV_StartBug> ipv6_select_ident ( fh ) ; <S2SV_EndBug> <S2SV_StartBug> ipv6_select_ident ( fh ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , rt <S2SV_ModStart> , rt "
4857,<S2SV_StartBug> if ( strlen ( parv [ 1 ] ) > 400 ) <S2SV_EndBug> ,"<S2SV_ModStart> ( parv [ 1 ] [ 0 ] == ':' ) || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) { sendto_one ( sptr , err_str ( ERR_CANNOTDOCOMMAND ) , me . name , ""*"" , ""AUTHENTICATE"" , ""Invalid<S2SV_blank>parameter"" ) ; return 0 ; } if ( "
4858,"<S2SV_StartBug> void ptrace_triggered ( struct perf_event * bp , int nmi , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
4859,"<S2SV_StartBug> if ( g_environ_getenv ( bwrap -> envp , ""LD_LIBRARY_PATH"" ) != NULL ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
4860,<S2SV_StartBug> return ; <S2SV_EndBug> ,<S2SV_ModStart> 0 
4861,"<S2SV_StartBug> code = validate_as_request ( kdc_active_realm , request , * princ , <S2SV_EndBug> ","<S2SV_ModStart> princ -> pw_expiration = 0 ; clear ( princ -> attributes , KRB5_KDB_REQUIRES_PWCHANGE ) ; "
4862,"<S2SV_StartBug> static void read_frame_reference_mode_probs ( VP9_COMMON * cm , vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> FRAME_CONTEXT * const fc = & cm -> fc ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4863,"<S2SV_StartBug> struct sockaddr_rc * sa = ( struct sockaddr_rc * ) addr ; <S2SV_EndBug> <S2SV_StartBug> int chan = sa -> rc_channel ; <S2SV_EndBug> <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( chan && __rfcomm_get_listen_sock_by_addr ( chan , & sa -> rc_bdaddr ) ) { <S2SV_EndBug> <S2SV_StartBug> bacpy ( & rfcomm_pi ( sk ) -> src , & sa -> rc_bdaddr ) ; <S2SV_EndBug> <S2SV_StartBug> rfcomm_pi ( sk ) -> channel = chan ; <S2SV_EndBug> ","<S2SV_ModStart> sa <S2SV_ModEnd> <S2SV_ModStart> len , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memset ( & sa , 0 , sizeof ( sa ) ) ; len = min_t ( unsigned int , sizeof ( sa ) , addr_len ) ; memcpy ( & sa , addr , len ) ; BT_DBG ( ""sk<S2SV_blank>%p<S2SV_blank>%pMR"" , sk , & sa . rc_bdaddr ) ; <S2SV_ModStart> sa . rc_channel <S2SV_ModEnd> <S2SV_ModStart> sa . rc_channel , & sa . <S2SV_ModEnd> <S2SV_ModStart> . <S2SV_ModEnd> <S2SV_ModStart> sa . rc_channel <S2SV_ModEnd> "
4864,<S2SV_StartBug> switch ( quantum_info -> depth ) <S2SV_EndBug> ,<S2SV_ModStart> pixel = 0 ; 
4865,"<S2SV_StartBug> ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) <S2SV_EndBug> ",<S2SV_ModStart> key_read_state ( key ) == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> 
4866,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> 
4867,"<S2SV_StartBug> if ( update_fragments ( ctx , data , data_sz , & res ) <= 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( ! res && ctx -> defer_alloc ) <S2SV_EndBug> <S2SV_StartBug> if ( ! res && ! ctx -> decoder_init ) <S2SV_EndBug> <S2SV_StartBug> ctx -> yv12_frame_buffers . pbi [ 0 ] -> decrypt_cb = ctx -> decrypt_cb ; <S2SV_EndBug> <S2SV_StartBug> ctx -> yv12_frame_buffers . pbi [ 0 ] -> decrypt_state = ctx -> decrypt_state ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> ",<S2SV_ModStart> ! ctx -> fragments . enabled && ( data == NULL && data_sz == 0 ) ) { return 0 ; } if ( <S2SV_ModStart> ! <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> decoder_init = 1 ; } if ( ctx -> decoder_init ) { ctx -> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vp8_clear_system_state ( ) ; 
4868,<S2SV_StartBug> client -> auth_user = client -> db -> auth_user ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4869,"<S2SV_StartBug> in_what_stride , UINT_MAX ) <S2SV_EndBug> <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4870,"<S2SV_StartBug> revisionId = enc28j60ReadReg ( interface , ENC28J60_REG_EREVID ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ECOCON , 0x00 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR2 , interface -> macAddr . b [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR3 , interface -> macAddr . b [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR4 , interface -> macAddr . b [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR5 , interface -> macAddr . b [ 4 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR6 , interface -> macAddr . b [ 5 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXSTL , LSB ( ENC28J60_RX_BUFFER_START ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXSTH , MSB ( ENC28J60_RX_BUFFER_START ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXNDL , LSB ( ENC28J60_RX_BUFFER_STOP ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXNDH , MSB ( ENC28J60_RX_BUFFER_STOP ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTL , LSB ( ENC28J60_RX_BUFFER_STOP ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTH , MSB ( ENC28J60_RX_BUFFER_STOP ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXFCON , ERXFCON_UCEN | <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MACON3 , MACON3_PADCFG ( 1 ) | <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MACON3 , MACON3_PADCFG ( 1 ) | <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MACON4 , MACON4_DEFER ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MAMXFLH , MSB ( ETH_MAX_FRAME_SIZE ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MABBIPG , 0x15 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MABBIPG , 0x12 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MAIPGL , 0x12 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHCON1 , PHCON1_PDPXMD ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHCON1 , 0x0000 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHCON2 , PHCON2_HDLDIS ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHLCON , <S2SV_EndBug> <S2SV_StartBug> enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHIE , <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_RXEN ) ; <S2SV_EndBug> ","<S2SV_ModStart> ENC28J60_EREVID <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ECOCON , ENC28J60_ECOCON_COCON_DISABLED ) ; enc28j60WriteReg ( interface , ENC28J60_MAADR5 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MAADR4 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MAADR3 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MAADR2 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MAADR1 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MAADR0 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ERXSTL <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ERXSTH <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ERXNDL <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ERXNDH <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ERXRDPTL <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ERXRDPTH <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ERXFCON , ENC28J60_ERXFCON_UCEN | ENC28J60_ERXFCON_CRCEN | ENC28J60_ERXFCON_HTEN | ENC28J60_ERXFCON_BCEN ) ; enc28j60WriteReg ( interface , ENC28J60_EHT0 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT1 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT2 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT3 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT4 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT5 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT6 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT7 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_MACON2 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_MACON1 , ENC28J60_MACON1_TXPAUS | ENC28J60_MACON1_RXPAUS | ENC28J60_MACON1_MARXEN <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MACON3 , ENC28J60_MACON3_PADCFG_AUTO | ENC28J60_MACON3_TXCRCEN | ENC28J60_MACON3_FRMLNEN | ENC28J60_MACON3_FULDPX <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MACON3 , ENC28J60_MACON3_PADCFG_AUTO | ENC28J60_MACON3_TXCRCEN | ENC28J60_MACON3_FRMLNEN <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MACON4 , ENC28J60_MACON4_DEFER ) ; enc28j60WriteReg ( interface , ENC28J60_MAMXFLL <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MAMXFLH <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MABBIPG , ENC28J60_MABBIPG_DEFAULT_FD <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MABBIPG , ENC28J60_MABBIPG_DEFAULT_HD <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MAIPGL , ENC28J60_MAIPGL_DEFAULT ) ; enc28j60WriteReg ( interface , ENC28J60_MAIPGH , ENC28J60_MAIPGH_DEFAULT ) ; enc28j60WriteReg ( interface , ENC28J60_MACLCON2 , ENC28J60_MACLCON2_COLWIN_DEFAULT <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_PHCON1 , ENC28J60_PHCON1_PDPXMD <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_PHCON1 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_PHCON2 , ENC28J60_PHCON2_HDLDIS <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_PHLCON , ENC28J60_PHLCON_LACFG_LINK | ENC28J60_PHLCON_LBCFG_TX_RX | ENC28J60_PHLCON_LFRQ_40_MS | ENC28J60_PHLCON_STRCH ) ; enc28j60WriteReg ( interface , ENC28J60_EIR , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EIE , ENC28J60_EIE_INTIE | ENC28J60_EIE_PKTIE | ENC28J60_EIE_LINKIE | ENC28J60_EIE_TXIE | ENC28J60_EIE_TXERIE <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_PHIE , ENC28J60_PHIE_PLNKIE | ENC28J60_PHIE_PGEIE <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ECON1 , ENC28J60_ECON1_RXEN <S2SV_ModEnd> "
4871,<S2SV_StartBug> if ( sum != 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK_16BITS ( & dp -> icmp_cksum ) ; 
4872,<S2SV_StartBug> if ( * ( unsigned char * ) data > 1 ) <S2SV_EndBug> ,<S2SV_ModStart> datalen != 1 ) return - EINVAL ; if ( 
4873,"<S2SV_StartBug> kvm_arch_flush_shadow_memslot ( kvm , slot ) ; <S2SV_EndBug> <S2SV_StartBug> goto out_free ; <S2SV_EndBug> <S2SV_StartBug> if ( ! npages ) { <S2SV_EndBug> <S2SV_StartBug> out_free : <S2SV_EndBug> ","<S2SV_ModStart> kvm_iommu_unmap_pages ( kvm , & old ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_slots ; } if ( <S2SV_ModStart> out_slots : kfree ( slots ) ; "
4874,<S2SV_StartBug> if ( ! asoc -> temp ) { <S2SV_EndBug> ,<S2SV_ModStart> list_empty ( & asoc -> asocs ) <S2SV_ModEnd> 
4875,"<S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> fs , VCPU_SREG_FS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> gs , VCPU_SREG_GS , cpl , true ) ; <S2SV_EndBug> ","<S2SV_ModStart> cpl , true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> "
4876,"<S2SV_StartBug> tlv = cp + i ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 2 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( i + 2 > length ) return - 1 ; <S2SV_ModStart> ; if ( i + 2 + optlen > length ) return - 1 
4877,<S2SV_StartBug> av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
4878,<S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug> ,<S2SV_ModStart> mb2_cache <S2SV_ModEnd> 
4879,<S2SV_StartBug> value = ( unsigned int ) ( ( buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) | <S2SV_EndBug> <S2SV_StartBug> ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffffffff ) ; <S2SV_EndBug> <S2SV_StartBug> value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ) | ( buffer [ 1 ] << 16 ) | <S2SV_EndBug> <S2SV_StartBug> ( buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffffffff ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4880,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % ( bps * stride ) ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""fpAcc"" , ""%s"" , ""cc%(bps*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModStart> return 1 ; "
4881,"<S2SV_StartBug> _Py_IDENTIFIER ( _fields ) ; <S2SV_EndBug> <S2SV_StartBug> fields = _PyObject_GetAttrId ( ( PyObject * ) Py_TYPE ( self ) , & PyId__fields ) ; <S2SV_EndBug> <S2SV_StartBug> if ( PyTuple_GET_SIZE ( args ) > 0 ) { <S2SV_EndBug> <S2SV_StartBug> PyErr_Format ( PyExc_TypeError , ""%.400s<S2SV_blank>constructor<S2SV_blank>takes<S2SV_blank>%s"" <S2SV_EndBug> <S2SV_StartBug> Py_TYPE ( self ) -> tp_name , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & fields ) < 0 ) { goto cleanup ; } <S2SV_ModEnd> <S2SV_ModStart> numfields < <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""%.400s<S2SV_blank>constructor<S2SV_blank>takes<S2SV_blank>at<S2SV_blank>most<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4882,"<S2SV_StartBug> static void encode_frame ( vpx_codec_ctx_t * codec , <S2SV_EndBug> <S2SV_StartBug> VpxVideoWriter * writer ) { <S2SV_EndBug> <S2SV_StartBug> while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int got_pkts = 0 ; <S2SV_ModStart> got_pkts = 1 ; <S2SV_ModStart> return got_pkts ; 
4883,<S2SV_StartBug> value = ( unsigned int ) ( ( buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) | <S2SV_EndBug> <S2SV_StartBug> ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffffffff ) ; <S2SV_EndBug> <S2SV_StartBug> value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ) | ( buffer [ 1 ] << 16 ) | <S2SV_EndBug> <S2SV_StartBug> ( buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffffffff ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4884,<S2SV_StartBug> rp [ 0 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> res -> nlimbs = ( msize == 1 && mod -> d [ 0 ] == 1 ) ? 0 : 1 ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( res -> nlimbs ) { if ( mpi_resize ( res , 1 ) < 0 ) goto enomem ; rp = res -> d ; rp [ 0 ] = 1 ; } "
4885,<S2SV_StartBug> free ( name ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! strcmp ( key , ""path"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_PATH , ""disallowed<S2SV_blank>submodule<S2SV_blank>path:<S2SV_blank>%s"" , value ) ; "
4886,<S2SV_StartBug> sizeof ( * pList ) + ( 2 * pList -> nExpr - 1 ) * sizeof ( pList -> a [ 0 ] ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( sqlite3_int64 ) 
4887,"<S2SV_StartBug> vpx_memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
4888,"<S2SV_StartBug> mc -> id = idr_alloc ( & multicast_idr , mc , 0 , 0 , GFP_KERNEL ) ; <S2SV_EndBug> ",<S2SV_ModStart> NULL <S2SV_ModEnd> 
4889,"<S2SV_StartBug> void vp9_cond_prob_diff_update ( vp9_writer * w , vp9_prob * oldp , <S2SV_EndBug> <S2SV_StartBug> const vp9_prob upd = DIFF_UPDATE_PROB ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob newp = get_binary_prob ( ct [ 0 ] , ct [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , 1 , upd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , 0 , upd ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> 
4890,"<S2SV_StartBug> static u32 ip6_proxy_idents_hashrnd __read_mostly ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip6_proxy_idents_hashrnd , <S2SV_EndBug> <S2SV_StartBug> id = __ipv6_select_ident ( net , ip6_proxy_idents_hashrnd , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4891,"<S2SV_StartBug> static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb ) <S2SV_EndBug> <S2SV_StartBug> s -> avctx -> level = get_bits ( gb , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( s -> avctx -> profile == 0 && s -> avctx -> level == 8 ) { <S2SV_EndBug> <S2SV_StartBug> s -> avctx -> level = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> , int * profile , int * level ) { * <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModEnd> "
4892,<S2SV_StartBug> # undef _ <S2SV_EndBug> ,<S2SV_ModStart> _ ( NPPVpluginUrlRequestsDisplayedBool ) ; _ ( NPPVpluginWantsAllNetworkStreams ) ; _ ( NPPVpluginNativeAccessibleAtkPlugId ) ; _ ( NPPVpluginCancelSrcStream ) ; _ ( NPPVSupportsAdvancedKeyHandling ) ; 
4893,<S2SV_StartBug> return LAST_FRAME ; <S2SV_EndBug> <S2SV_StartBug> return GOLDEN_FRAME ; <S2SV_EndBug> ,<S2SV_ModStart> GOLDEN_FRAME <S2SV_ModEnd> <S2SV_ModStart> LAST_FRAME <S2SV_ModEnd> 
4894,"<S2SV_StartBug> zend_throw_error ( exception_ce , message ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , "
4895,<S2SV_StartBug> ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <S2SV_EndBug> ,<S2SV_ModStart> SKB_EXT_ERR ( skb ) -> opt_stats <S2SV_ModEnd> 
4896,"<S2SV_StartBug> # line 496 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 861 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 558 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 855 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 607 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 708 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> if ( incomplete_class ) { <S2SV_EndBug> <S2SV_StartBug> # line 785 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 699 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> return object_common2 ( UNSERIALIZE_PASSTHRU , <S2SV_EndBug> <S2SV_StartBug> object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ) ; <S2SV_EndBug> <S2SV_StartBug> # line 819 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 678 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 861 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 643 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 917 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 610 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 971 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 600 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1069 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 585 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1143 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 558 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1197 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 551 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1212 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 544 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1222 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 521 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1268 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 500 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1312 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 863 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> ","<S2SV_ModStart> 501 <S2SV_ModEnd> <S2SV_ModStart> 875 <S2SV_ModEnd> <S2SV_ModStart> 563 <S2SV_ModEnd> <S2SV_ModStart> 869 <S2SV_ModEnd> <S2SV_ModStart> 612 <S2SV_ModEnd> <S2SV_ModStart> 717 <S2SV_ModEnd> <S2SV_ModStart> elements < 0 ) { efree ( class_name ) ; return 0 ; } if ( <S2SV_ModStart> 795 <S2SV_ModEnd> <S2SV_ModStart> 704 ""ext/standard/var_unserializer.re"" { long elements ; <S2SV_ModEnd> <S2SV_ModStart> elements = object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ; if ( elements < 0 ) { return 0 ; } <S2SV_ModStart> elements <S2SV_ModEnd> <S2SV_ModStart> 833 <S2SV_ModEnd> <S2SV_ModStart> 683 <S2SV_ModEnd> <S2SV_ModStart> 875 <S2SV_ModEnd> <S2SV_ModStart> 648 <S2SV_ModEnd> <S2SV_ModStart> 931 <S2SV_ModEnd> <S2SV_ModStart> 615 <S2SV_ModEnd> <S2SV_ModStart> 985 <S2SV_ModEnd> <S2SV_ModStart> 605 <S2SV_ModEnd> <S2SV_ModStart> 1083 <S2SV_ModEnd> <S2SV_ModStart> 590 <S2SV_ModEnd> <S2SV_ModStart> 1157 <S2SV_ModEnd> <S2SV_ModStart> 563 <S2SV_ModEnd> <S2SV_ModStart> 1211 <S2SV_ModEnd> <S2SV_ModStart> 556 <S2SV_ModEnd> <S2SV_ModStart> 1226 <S2SV_ModEnd> <S2SV_ModStart> 549 <S2SV_ModEnd> <S2SV_ModStart> 1236 <S2SV_ModEnd> <S2SV_ModStart> 526 <S2SV_ModEnd> <S2SV_ModStart> 1282 <S2SV_ModEnd> <S2SV_ModStart> 505 <S2SV_ModEnd> <S2SV_ModStart> 1326 <S2SV_ModEnd> <S2SV_ModStart> 877 <S2SV_ModEnd> "
4897,<S2SV_StartBug> char buf [ 32 ] ; <S2SV_EndBug> <S2SV_StartBug> char buf [ 100 ] ; <S2SV_EndBug> ,<S2SV_ModStart> 100 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4898,<S2SV_StartBug> ENSURE_BITS ( 16 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( bits_left == 0 ) <S2SV_ModStart>  <S2SV_ModEnd> 
4899,"<S2SV_StartBug> if ( strchr ( ""!#$%&\'*+-.^_`|~"" , c ) ) <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
4900,<S2SV_StartBug> bh -> b_size = map . m_len << inode -> i_blkbits ; <S2SV_EndBug> ,<S2SV_ModStart> ( u64 ) 
4901,"<S2SV_StartBug> gint64 offset ; <S2SV_EndBug> <S2SV_StartBug> pkt_len = parse_cosine_rec_hdr ( & wth -> phdr , line , err , err_info ) ; <S2SV_EndBug> <S2SV_StartBug> return parse_cosine_hex_dump ( wth -> fh , & wth -> phdr , pkt_len , <S2SV_EndBug> <S2SV_StartBug> wth -> frame_buffer , err , err_info ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return parse_cosine_packet <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , line "
4902,"<S2SV_StartBug> char buf [ DN_BUF_LEN ] ; <S2SV_EndBug> <S2SV_StartBug> X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , buf , & bufsize , <S2SV_EndBug> <S2SV_StartBug> md -> subject_dn = strdup ( buf ) ; <S2SV_EndBug> <S2SV_StartBug> X509_NAME_oneline_ex ( X509_get_issuer_name ( cert ) , buf , & bufsize , <S2SV_EndBug> <S2SV_StartBug> md -> issuer_dn = strdup ( buf ) ; <S2SV_EndBug> ","<S2SV_ModStart> * md_out = NULL ; md = calloc ( 1 , sizeof ( <S2SV_ModEnd> <S2SV_ModStart> ret = rfc2253_name <S2SV_ModEnd> <S2SV_ModStart> & <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( ret ) goto cleanup ; ret = rfc2253_name <S2SV_ModEnd> <S2SV_ModStart> & <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( ret ) goto cleanup ; <S2SV_ModEnd> "
4903,<S2SV_StartBug> align_get_bits ( gb ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0 
4904,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = cdc_ncm_bind_common ( dev , intf , CDC_NCM_DATA_ALTSETTING_NCM , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> usbnet_link_change ( dev , 0 , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4905,"
","
"
4906,"<S2SV_StartBug> Total += vp8_mse16x16 ( src + j , source -> y_stride , dst + j , dest -> y_stride , & sse ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_mse16x16 <S2SV_ModEnd> 
4907,<S2SV_StartBug> } else if ( event -> type == et_char ) { <S2SV_EndBug> ,"<S2SV_ModStart> et_controlevent && event -> u . control . subtype == et_textchanged ) { sd -> fv -> script_unsaved = ! GTextFieldIsEmpty ( GWidgetGetControl ( sd -> gw , CID_Script ) ) ; } else if ( event -> type == et_controlevent && event -> u . control . subtype == et_save ) { sd -> fv -> script_unsaved = false ; } else if ( event -> type == "
4908,"<S2SV_StartBug> buflen = MIN ( buflen , buf_size ) ; <S2SV_EndBug> ",<S2SV_ModStart> - 8 
4909,"<S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ",<S2SV_ModStart> ssplit <S2SV_ModEnd> 
4910,<S2SV_StartBug> stripsperplane = ( ( td -> td_imagelength + rowsperstrip - 1 ) / rowsperstrip ) ; <S2SV_EndBug> ,"<S2SV_ModStart> TIFFhowmany_32_maxuint_compat <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> "
4911,"<S2SV_StartBug> int hstartcol ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> hstartcol = ( numrows + 1 - parity ) >> 1 ; <S2SV_EndBug> <S2SV_StartBug> m = numrows - hstartcol ; <S2SV_EndBug> <S2SV_StartBug> dstptr = & a [ hstartcol * stride ] ; <S2SV_EndBug> ","<S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> jas_alloc3 <S2SV_ModEnd> <S2SV_ModStart> JPC_QMFB_COLGRPSIZE , <S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> hstartrow <S2SV_ModEnd> "
4912,"<S2SV_StartBug> int x , y , i ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( tilemap = malloc ( x_size * y_size * sizeof ( struct map_tile ) ) ) ) <S2SV_EndBug> ",<S2SV_ModStart> size_t tilemap_size ; <S2SV_ModStart> tilemap_size = <S2SV_ModEnd> <S2SV_ModStart> ; if ( x_size == 0 || tilemap_size / x_size / sizeof ( struct map_tile ) != y_size || ! ( tilemap = malloc ( tilemap_size 
4913,"<S2SV_StartBug> u_int16_t port ; <S2SV_EndBug> <S2SV_StartBug> unsigned int ret ; <S2SV_EndBug> <S2SV_StartBug> nf_ct_helper_log ( skb , exp -> master , ""all<S2SV_blank>ports<S2SV_blank>in<S2SV_blank>use"" ) ; <S2SV_EndBug> <S2SV_StartBug> ret = nf_nat_mangle_tcp_packet ( skb , exp -> master , ctinfo , <S2SV_EndBug> <S2SV_StartBug> nf_ct_helper_log ( skb , exp -> master , ""cannot<S2SV_blank>mangle<S2SV_blank>packet"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct nf_conn * ct = exp -> master ; union nf_inet_addr newaddr ; <S2SV_ModStart> ; newaddr = ct -> tuplehash [ IP_CT_DIR_REPLY ] . tuple . dst . u3 <S2SV_ModStart> ct <S2SV_ModEnd> <S2SV_ModStart> snprintf ( buffer , sizeof ( buffer ) , ""%u<S2SV_blank>%u"" , ntohl ( newaddr . ip ) , port ) ; pr_debug ( ""nf_nat_irc:<S2SV_blank>inserting<S2SV_blank>\'%s\'<S2SV_blank>==<S2SV_blank>%pI4,<S2SV_blank>port<S2SV_blank>%u\\n"" , buffer , & newaddr . ip , port ) ; <S2SV_ModStart> ct <S2SV_ModEnd> <S2SV_ModStart> ct <S2SV_ModEnd> "
4914,"<S2SV_StartBug> args -> count = ntohl ( * p ++ ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 <S2SV_ModStart> 1 <S2SV_ModEnd> "
4915,"<S2SV_StartBug> int nmi , struct perf_sample_data * data , <S2SV_EndBug> <S2SV_StartBug> if ( __perf_event_overflow ( event , nmi , throttle , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4916,"<S2SV_StartBug> static INLINE void write_buffer_4x4 ( int16_t * output , __m128i * res ) { <S2SV_EndBug> <S2SV_StartBug> _mm_store_si128 ( ( __m128i * ) ( output + 0 * 8 ) , out01 ) ; <S2SV_EndBug> <S2SV_StartBug> _mm_store_si128 ( ( __m128i * ) ( output + 1 * 8 ) , out23 ) ; <S2SV_EndBug> ","<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> store_output ( & out01 , <S2SV_ModEnd> <S2SV_ModStart> ) ; store_output ( & out23 , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4917,<S2SV_StartBug> if ( image -> numcomps < 4 ) return ; <S2SV_EndBug> ,"<S2SV_ModStart> ( <S2SV_ModStart> || ( image -> comps [ 0 ] . dx != image -> comps [ 1 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 2 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 3 ] . dx ) || ( image -> comps [ 0 ] . dy != image -> comps [ 1 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 2 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 3 ] . dy ) ) { fprintf ( stderr , ""%s:%d:color_cmyk_to_rgb\\n\\tCAN<S2SV_blank>NOT<S2SV_blank>CONVERT\\n"" , __FILE__ , __LINE__ ) ; return ; } <S2SV_ModEnd> "
4918,<S2SV_StartBug> trust_data . dwUIChoice = WTD_UI_ALL ; <S2SV_EndBug> <S2SV_StartBug> return r ; <S2SV_EndBug> ,"<S2SV_ModStart> WTD_UI_NONE <S2SV_ModEnd> <S2SV_ModStart> switch ( r ) { case ERROR_SUCCESS : break ; case TRUST_E_NOSIGNATURE : uprintf ( ""PKI:<S2SV_blank>File<S2SV_blank>does<S2SV_blank>not<S2SV_blank>appear<S2SV_blank>to<S2SV_blank>be<S2SV_blank>signed:<S2SV_blank>%s"" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_284 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; default : uprintf ( ""PKI:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>validate<S2SV_blank>signature:<S2SV_blank>%s"" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_240 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; } "
4919,<S2SV_StartBug> for ( col = 0 ; col < imagewidth ; col += tw ) { <S2SV_EndBug> ,<S2SV_ModStart> && colb < imagew 
4920,<S2SV_StartBug> return 1 ; <S2SV_EndBug> ,<S2SV_ModStart> case EXIT_REASON_INVEPT : 
4921,<S2SV_StartBug> sc -> drefs = av_mallocz ( entries * sizeof ( * sc -> drefs ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> drefs_count = 0 ; sc -> 
4922,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> zend_object_store_ctor_failed ( * rval TSRMLS_CC ) ; 
4923,"<S2SV_StartBug> ( void ) ReadBlobString ( image , text ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } "
4924,<S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> <S2SV_StartBug> write_lock ( & cluster -> cl_nodes_lock ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> o2nm_unlock_subsystem ( ) ; 
4925,<S2SV_StartBug> cm -> fc . nmvc = default_nmv_context ; <S2SV_EndBug> ,<S2SV_ModStart> -> <S2SV_ModEnd> 
4926,<S2SV_StartBug> if ( ! * passwd || ! * user -> passwd ) <S2SV_EndBug> ,"<S2SV_ModStart> user ) { slog_error ( client , ""Password<S2SV_blank>packet<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>packet?"" ) ; return false ; } if ( ! "
4927,"<S2SV_StartBug> quit ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>header<S2SV_blank>to<S2SV_blank>header_bin<S2SV_blank>in<S2SV_blank>parse_notify"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> { applog ( LOG_WARNING , ""%s:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>header<S2SV_blank>to<S2SV_blank>header_bin,<S2SV_blank>got<S2SV_blank>%s"" , __func__ , header ) ; pool_failed ( pool ) ; return false ; } <S2SV_ModEnd> "
4928,<S2SV_StartBug> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ; <S2SV_EndBug> <S2SV_StartBug> if ( ses -> server -> sign ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> | NTLMSSP_NEGOTIATE_SEAL <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4929,<S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! recovery_started ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , ""Not<S2SV_blank>in<S2SV_blank>Recovery<S2SV_blank>mode"" ) ; layoutHome ( ) ; return ; } "
4930,"<S2SV_StartBug> uint8_t mus_event [ ] = { 0 , 0 , 0 , 0 } ; <S2SV_EndBug> <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mus_mdi , ( uint8_t * ) mus_event , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> # define MUS_SZ 4 <S2SV_ModStart> MUS_SZ <S2SV_ModStart> , MUS_SZ "
4931,<S2SV_StartBug> void * dllhandle ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( COM_CompareExtension ( name , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , name ) ; return NULL ; } "
4932,<S2SV_StartBug> struct address_space * mapping = page -> mapping ; <S2SV_EndBug> <S2SV_StartBug> struct inode * inode = mapping -> host ; <S2SV_EndBug> <S2SV_StartBug> SetPageUptodate ( page ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> page_file_mapping ( page ) <S2SV_ModEnd> <S2SV_ModStart> ( page ) ; if ( PageSwapCache ( page ) ) return __set_page_dirty_nobuffers 
4933,<S2SV_StartBug> if ( count < DJREPORT_SHORT_LENGTH - 2 ) <S2SV_EndBug> ,<S2SV_ModStart> > <S2SV_ModEnd> 
4934,<S2SV_StartBug> if ( len != set_arglen [ SET_CMDID ( cmd ) ] ) { <S2SV_EndBug> ,<S2SV_ModStart> cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX ) return - EINVAL ; if ( len < 0 || len > MAX_ARG_LEN ) return - EINVAL ; if ( 
4935,"<S2SV_StartBug> while ( ( type = gettoken_query ( state , & val , & lenval , & strval , & flag ) ) != END ) <S2SV_EndBug> ",<S2SV_ModStart> check_stack_depth ( ) ; 
4936,<S2SV_StartBug> char * tmp ; <S2SV_EndBug> ,<S2SV_ModStart> const 
4937,"<S2SV_StartBug> if ( ! php_var_unserialize ( & intern -> array , & p , s + buf_len , & var_hash TSRMLS_CC ) ) { <S2SV_EndBug> ",<S2SV_ModStart> || ( Z_TYPE_P ( intern -> array ) != IS_ARRAY && Z_TYPE_P ( intern -> array ) != IS_OBJECT ) ) { zval_ptr_dtor ( & intern -> array ) ; <S2SV_ModEnd> 
4938,"<S2SV_StartBug> assert ( idx >= 0 && idx <= PCI_BARMAX ) ; <S2SV_EndBug> <S2SV_StartBug> case PCIBAR_MEM64 : <S2SV_EndBug> <S2SV_StartBug> printf ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n"" , __func__ , type ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( idx + 1 <= PCI_BARMAX ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( idx + 1 > PCI_BARMAX ) { pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>MEM64<S2SV_blank>type\\n"" , __func__ , idx ) ; return - 1 ; } <S2SV_ModStart> pr_err <S2SV_ModEnd> <S2SV_ModStart> return - 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4939,<S2SV_StartBug> if ( t -> pool -> shutdown ) { <S2SV_EndBug> ,<S2SV_ModStart> pthread_mutex_unlock ( & t -> cond_mutex ) ; 
4940,"<S2SV_StartBug> ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> if ( size > urb -> transfer_buffer_length ) { <S2SV_ModEnd> <S2SV_ModStart> return 0 ; <S2SV_ModStart> ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; if ( ret != size ) { dev_err ( & urb -> dev -> dev , ""recv<S2SV_blank>xbuf,<S2SV_blank>%d\\n"" , ret ) ; if ( ud -> side == USBIP_STUB ) { usbip_event_add ( ud , SDEV_EVENT_ERROR_TCP ) ; } else { usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ; return - EPIPE ; } } "
4941,"<S2SV_StartBug> ret = ext4_convert_unwritten_extents_endio ( handle , inode , <S2SV_EndBug> ","<S2SV_ModStart> map , "
4942,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( s -> codec_id == AV_CODEC_ID_MPEG4 ) s -> idsp . mpeg4_studio_profile = s -> studio_profile ; 
4943,"<S2SV_StartBug> if ( perf_event_overflow ( event , 0 , data , regs ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
4944,<S2SV_StartBug> if ( ! eof ) { <S2SV_EndBug> ,<S2SV_ModStart> && vars -> str . c != vars -> ptr 
4945,"<S2SV_StartBug> retval = generic_gss_oid_decompose ( minor_status , <S2SV_EndBug> ",<S2SV_ModStart> if ( ctx -> terminated || ! ctx -> established ) { * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; } 
4946,<S2SV_StartBug> cur_token = * indx ; <S2SV_EndBug> <S2SV_StartBug> res = r ; <S2SV_EndBug> ,<S2SV_ModStart> clist * list ; <S2SV_ModStart> ; goto free_display_name ; } list = clist_new ( ) ; if ( list == NULL ) { res = MAILIMF_ERROR_MEMORY ; goto free_display_name ; } mailbox_list = mailimf_mailbox_list_new ( list ) ; if ( mailbox_list == NULL ) { res = MAILIMF_ERROR_MEMORY ; clist_free ( list ) 
4947,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
4948,<S2SV_StartBug> av_freep ( & h -> DPB ) ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( h -> delayed_pic , 0 , sizeof ( h -> delayed_pic ) ) ; "
4949,"<S2SV_StartBug> return __load_segment_descriptor ( ctxt , selector , seg , cpl , false ) ; <S2SV_EndBug> ","<S2SV_ModStart> , NULL "
4950,"<S2SV_StartBug> mark_object ( & c -> object , NULL , NULL , data ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
4951,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
4952,"<S2SV_StartBug> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> dst = __inet6_csk_dst_check ( sk , np -> dst_cookie ) ; <S2SV_EndBug> ",<S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) <S2SV_ModStart> rcu_read_unlock ( ) ; 
4953,<S2SV_StartBug> static struct desc_struct * get_desc ( unsigned short sel ) <S2SV_EndBug> <S2SV_StartBug> struct desc_struct * desc = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ldt && sel < ldt -> nr_entries ) <S2SV_EndBug> <S2SV_StartBug> desc = & ldt -> entries [ sel ] ; <S2SV_EndBug> <S2SV_StartBug> return desc ; <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> bool get_desc ( <S2SV_ModStart> out , <S2SV_ModEnd> <S2SV_ModStart> bool success = false <S2SV_ModEnd> <S2SV_ModStart> { * out = <S2SV_ModEnd> <S2SV_ModStart> success = true ; } <S2SV_ModStart> success <S2SV_ModEnd> <S2SV_ModStart> false ; * out = * <S2SV_ModEnd> <S2SV_ModStart> return true ; "
4954,<S2SV_StartBug> else if ( i > pos && i + insn -> off + 1 < pos ) <S2SV_EndBug> ,<S2SV_ModStart> + delta <S2SV_ModStart> <= pos + delta <S2SV_ModEnd> 
4955,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ERRORTOKEN <S2SV_ModEnd> 
4956,"<S2SV_StartBug> err = scm_send ( sock , msg , siocb -> scm ) ; <S2SV_EndBug> ","<S2SV_ModStart> , true "
4957,<S2SV_StartBug> if ( ( peer != NULL ) && ( type & EVP_PKT_SIGN ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4958,<S2SV_StartBug> bucket = apr_bucket_eos_create ( r -> connection -> bucket_alloc ) ; <S2SV_EndBug> ,<S2SV_ModStart> apr_brigade_cleanup ( brigade ) ; 
4959,<S2SV_StartBug> case RAPTOR_OPTION_RELATIVE_URIS : <S2SV_EndBug> ,<S2SV_ModStart> RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case 
4960,<S2SV_StartBug> if ( nlmsg_len ( nlh ) < sizeof ( struct nfgenmsg ) || <S2SV_EndBug> ,<S2SV_ModStart> nlh -> nlmsg_len < NLMSG_HDRLEN || skb -> len < nlh -> nlmsg_len || <S2SV_ModStart> ) { nfnl_err_reset ( & err_list ) ; status |= NFNL_BATCH_FAILURE ; goto done <S2SV_ModEnd> 
4961,"<S2SV_StartBug> separator = strchr ( connection -> buffer , '=' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
4962,<S2SV_StartBug> if ( c -> nreslevels < s -> reduction_factor ) <S2SV_EndBug> <S2SV_StartBug> c -> nreslevels2decode = 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> <= <S2SV_ModEnd> <S2SV_ModStart> { av_log ( s -> avctx , AV_LOG_ERROR , ""reduction_factor<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>this<S2SV_blank>bitstream,<S2SV_blank>max<S2SV_blank>is<S2SV_blank>%d\\n"" , c -> nreslevels - 1 ) ; s -> reduction_factor = c -> nreslevels - 1 ; return AVERROR ( EINVAL ) ; } <S2SV_ModEnd> "
4963,"<S2SV_StartBug> static void encode_segmentation ( VP9_COMP * cpi , <S2SV_EndBug> <S2SV_StartBug> struct segmentation * seg = & cpi -> common . seg ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , seg -> update_map ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_choose_segmap_coding_method ( cpi ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , update ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , seg -> temporal_update ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , update ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , seg -> update_data ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , seg -> abs_delta ) ; <S2SV_EndBug> <S2SV_StartBug> const int active = vp9_segfeature_active ( seg , i , j ) ; <S2SV_EndBug> <S2SV_StartBug> const int data = vp9_get_segdata ( seg , i , j ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , data < 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> VP9_COMMON * cm , MACROBLOCKD * xd , struct vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> cm -> seg ; vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> cm , xd <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit ( wb , update ) ; if ( update ) vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit ( wb , update ) ; if ( update ) vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> segfeature_active ( seg , i , j ) ; vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> get_segdata <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> "
4964,<S2SV_StartBug> void exit_io_context ( void ) <S2SV_EndBug> <S2SV_StartBug> task_lock ( current ) ; <S2SV_EndBug> <S2SV_StartBug> ioc = current -> io_context ; <S2SV_EndBug> <S2SV_StartBug> current -> io_context = NULL ; <S2SV_EndBug> <S2SV_StartBug> task_unlock ( current ) ; <S2SV_EndBug> ,<S2SV_ModStart> struct task_struct * task <S2SV_ModEnd> <S2SV_ModStart> task <S2SV_ModEnd> <S2SV_ModStart> task <S2SV_ModEnd> <S2SV_ModStart> task <S2SV_ModEnd> <S2SV_ModStart> task <S2SV_ModEnd> 
4965,"<S2SV_StartBug> run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
4966,"<S2SV_StartBug> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_above_s , & t_above , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left_s , & t_left , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( ta_b , ta_s , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( tl_b , tl_s , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( ta , ta_b , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( tl , tl_b , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
4967,"<S2SV_StartBug> if ( ( ctxt -> mode == X86EMUL_MODE_PROT32 ) && ( efer & EFER_LMA ) <S2SV_EndBug> <S2SV_StartBug> switch ( ctxt -> mode ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> cs_sel = ( u16 ) msr_data ; <S2SV_EndBug> <S2SV_StartBug> ss_sel &= ~ SELECTOR_RPL_MASK ; <S2SV_EndBug> <S2SV_StartBug> if ( ctxt -> mode == X86EMUL_MODE_PROT64 || ( efer & EFER_LMA ) ) { <S2SV_EndBug> <S2SV_StartBug> ctxt -> _eip = msr_data ; <S2SV_EndBug> <S2SV_StartBug> * reg_write ( ctxt , VCPU_REGS_RSP ) = msr_data ; <S2SV_EndBug> ",<S2SV_ModStart> != X86EMUL_MODE_PROT64 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> & <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( efer & EFER_LMA ) ? msr_data : ( u32 ) <S2SV_ModStart> ( efer & EFER_LMA ) ? msr_data : ( u32 ) 
4968,<S2SV_StartBug> return NULL ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! hashtable_seed ) { json_object_seed ( 0 ) ; } 
4969,<S2SV_StartBug> sr -> bytes_to_send = finfo . size ; <S2SV_EndBug> ,<S2SV_ModStart> fd_is_fdt = MK_FALSE ; sr -> 
4970,"<S2SV_StartBug> struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> 
4971,<S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> haddr -> hci_channel = 0 ; 
4972,"<S2SV_StartBug> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; <S2SV_EndBug> ","<S2SV_ModStart> lfi , fname , UDF_NAME_LEN <S2SV_ModEnd> "
4973,"<S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
4974,"<S2SV_StartBug> if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> ",<S2SV_ModStart> 3 == <S2SV_ModStart> && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> 
4975,"<S2SV_StartBug> const char command5 [ ] = { 0x05 , 0x00 } ; <S2SV_EndBug> <S2SV_StartBug> close ( s ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> } ; const char bad_command4 [ ] = { 0x04 , 0x01 , 0x60 , 0x8f , 0xff , 0xff , 0xff , 0x7f <S2SV_ModStart> if ( n == 0 ) { <S2SV_ModStart> s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( bad_command4 , sizeof ( bad_command4 ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( ""Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n"" , ( int ) n ) ; printresponse ( buf , n ) ; close ( s ) ; "
4976,<S2SV_StartBug> buf = g_malloc ( size ) ; <S2SV_EndBug> ,<S2SV_ModStart> g_malloc0 <S2SV_ModEnd> 
4977,"<S2SV_StartBug> show_object ( obj , NULL , name , data ) ; <S2SV_EndBug> <S2SV_StartBug> NULL , path , data ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> & base <S2SV_ModEnd> 
4978,"<S2SV_StartBug> tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p -> z , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
4979,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> this_cpu_add ( net_rand_state . s1 , rol32 ( jiffies , 24 ) + user_tick ) ; "
4980,<S2SV_StartBug> ( void ) mvcost ; <S2SV_EndBug> ,<S2SV_ModStart> mb ; ( void ) 
4981,"<S2SV_StartBug> uint8_t * outbuf ; <S2SV_EndBug> <S2SV_StartBug> command = buf [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> rc = scsi_disk_emulate_command ( r , outbuf ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4982,<S2SV_StartBug> if ( a -> name == MAPI_BODY_HTML ) <S2SV_EndBug> <S2SV_StartBug> else if ( a -> name == MAPI_RTF_COMPRESSED ) <S2SV_EndBug> ,<S2SV_ModStart> type == szMAPI_BINARY && a -> <S2SV_ModStart> a -> type == szMAPI_BINARY && 
4983,"<S2SV_StartBug> int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ; <S2SV_EndBug> <S2SV_StartBug> int offset , subobj_type , subobj_len , total_subobj_len ; <S2SV_EndBug> <S2SV_StartBug> tptr += sizeof ( const struct lmp_common_header ) ; <S2SV_EndBug> <S2SV_StartBug> if ( lmp_obj_len % 4 || lmp_obj_len < 4 ) <S2SV_EndBug> <S2SV_StartBug> lmp_obj_len ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Control<S2SV_blank>Channel<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , <S2SV_EndBug> <S2SV_StartBug> case LMP_CTYPE_UNMD_RMT : <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , <S2SV_EndBug> <S2SV_StartBug> case LMP_CTYPE_2 : <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Node<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Interval:<S2SV_blank>%u\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tx<S2SV_blank>Seq:<S2SV_blank>%u,<S2SV_blank>Rx<S2SV_blank>Seq:<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , <S2SV_EndBug> <S2SV_StartBug> EXTRACT_16BITS ( obj_tptr ) >> 8 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ipaddr_string ( ndo , obj_tptr + 4 ) , <S2SV_EndBug> <S2SV_StartBug> case LMP_CTYPE_IPV6 : <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , <S2SV_EndBug> <S2SV_StartBug> EXTRACT_16BITS ( obj_tptr ) >> 8 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> subobj_type = EXTRACT_16BITS ( obj_tptr + offset ) >> 8 ; <S2SV_EndBug> <S2SV_StartBug> subobj_len = EXTRACT_16BITS ( obj_tptr + offset ) & 0x00FF ; <S2SV_EndBug> <S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_tptr + offset + 4 ) ; <S2SV_EndBug> <S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_tptr + offset + 8 ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case LMP_OBJ_VERIFY_BEGIN : <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> case LMP_OBJ_VERIFY_BEGIN_ACK : <S2SV_EndBug> <S2SV_StartBug> case LMP_CTYPE_1 : <S2SV_EndBug> <S2SV_StartBug> case LMP_OBJ_VERIFY_ID : <S2SV_EndBug> <S2SV_StartBug> case LMP_CTYPE_1 : <S2SV_EndBug> <S2SV_StartBug> case LMP_OBJ_CHANNEL_STATUS : <S2SV_EndBug> <S2SV_StartBug> case LMP_CTYPE_IPV4 : <S2SV_EndBug> <S2SV_StartBug> case LMP_OBJ_CHANNEL_STATUS_REQ : <S2SV_EndBug> <S2SV_StartBug> case LMP_CTYPE_IPV4 : <S2SV_EndBug> <S2SV_StartBug> bittok2str ( lmp_obj_begin_verify_error_values , <S2SV_EndBug> <S2SV_StartBug> EXTRACT_32BITS ( obj_tptr ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> EXTRACT_16BITS ( obj_tptr ) & 0x00FF ) ) ; <S2SV_EndBug> <S2SV_StartBug> case LMP_CTYPE_SERVICE_CONFIG_CPSA : <S2SV_EndBug> <S2SV_StartBug> link_type = EXTRACT_16BITS ( obj_tptr ) >> 8 ; <S2SV_EndBug> <S2SV_StartBug> bittok2str ( lmp_obj_service_config_cpsa_tp_flag_values , <S2SV_EndBug> <S2SV_StartBug> EXTRACT_16BITS ( obj_tptr + 2 ) >> 8 ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> u_int <S2SV_ModEnd> <S2SV_ModStart> u_int offset ; u_int <S2SV_ModEnd> <S2SV_ModStart> if ( tlen < sizeof ( const struct lmp_common_header ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; return ; } if ( tlen > len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>long)"" ) ) ; tlen = len ; } <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( lmp_obj_len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; return ; } if ( ( lmp_obj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)"" ) ) ; return ; } <S2SV_ModStart> if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } <S2SV_ModStart> if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } <S2SV_ModStart> if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } <S2SV_ModStart> if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } <S2SV_ModStart> if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } <S2SV_ModStart> if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } <S2SV_ModStart> if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } <S2SV_ModStart> if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } <S2SV_ModStart> if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } <S2SV_ModStart> switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } <S2SV_ModStart> EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; <S2SV_ModEnd> <S2SV_ModStart> ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } <S2SV_ModStart> EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) hexdump = TRUE ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen < 36 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) ) hexdump = TRUE ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 20 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_begin_verify_flag_values , ""none"" , <S2SV_ModStart> ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Interval:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Data<S2SV_blank>links:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>type:<S2SV_blank>%s"" , tok2str ( gmpls_encoding_values , ""Unknown"" , * ( obj_tptr + <S2SV_ModEnd> <S2SV_ModStart> ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Mechanism:<S2SV_blank>%u<S2SV_blank>(0x%x)%s"" , <S2SV_ModEnd> <S2SV_ModStart> 10 ) , <S2SV_ModEnd> <S2SV_ModStart> 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) & 8000 ? ""<S2SV_blank>(Payload<S2SV_blank>test<S2SV_blank>messages<S2SV_blank>capable)"" : """" <S2SV_ModEnd> <S2SV_ModStart> 12 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Transmission<S2SV_blank>Rate:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr + 16 <S2SV_ModEnd> <S2SV_ModStart> } break ; case LMP_OBJ_VERIFY_BEGIN_ACK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Response:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; <S2SV_ModEnd> <S2SV_ModStart> LMP_OBJ_VERIFY_ID <S2SV_ModEnd> <S2SV_ModStart> if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>ID:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr <S2SV_ModEnd> <S2SV_ModStart> LMP_OBJ_CHANNEL_STATUS <S2SV_ModEnd> <S2SV_ModStart> LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 20 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) ) ; offset += 20 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } <S2SV_ModEnd> <S2SV_ModStart> LMP_OBJ_CHANNEL_STATUS_REQ <S2SV_ModEnd> <S2SV_ModStart> LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 16 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 16 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } <S2SV_ModEnd> <S2SV_ModStart> LMP_OBJ_ERROR_CODE <S2SV_ModEnd> <S2SV_ModStart> LMP_CTYPE_BEGIN_VERIFY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s"" , bittok2str ( lmp_obj_begin_verify_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; case LMP_CTYPE_LINK_SUMMARY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s"" , bittok2str ( lmp_obj_link_summary_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; <S2SV_ModEnd> <S2SV_ModStart> LMP_OBJ_SERVICE_CONFIG <S2SV_ModEnd> <S2SV_ModStart> LMP_CTYPE_SERVICE_CONFIG_SP : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Flags:<S2SV_blank>%s"" <S2SV_ModEnd> <S2SV_ModStart> lmp_obj_service_config_sp_flag_values <S2SV_ModEnd> <S2SV_ModStart> EXTRACT_8BITS ( obj_tptr ) <S2SV_ModEnd> <S2SV_ModStart> EXTRACT_8BITS ( obj_tptr + 1 ) <S2SV_ModEnd> <S2SV_ModStart> if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } link_type = EXTRACT_8BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Link<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_link_type_values , ""Unknown"" , link_type ) , link_type ) ) ; switch ( link_type ) { case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sdh_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sonet_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Transparency:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_cpsa_tp_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Contiguous<S2SV_blank>Concatenation<S2SV_blank>Types:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_cpsa_cct_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Minimum<S2SV_blank>NCC:<S2SV_blank>%u"" , <S2SV_ModEnd> <S2SV_ModStart> + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Maximum<S2SV_blank>NCC:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Minimum<S2SV_blank>NVC:%u"" , EXTRACT_16BITS ( obj_tptr + 8 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Maximum<S2SV_blank>NVC:%u"" , EXTRACT_16BITS ( obj_tptr + 10 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 12 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Transparency<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_transparency_flag_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>TCM<S2SV_blank>Monitoring<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_tcm_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 7 ) ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Diversity:<S2SV_blank>Flags:<S2SV_blank>%s"" <S2SV_ModEnd> <S2SV_ModStart> lmp_obj_service_config_nsa_network_diversity_flag_values <S2SV_ModEnd> <S2SV_ModStart> EXTRACT_8BITS ( obj_tptr + 3 ) <S2SV_ModEnd> "
4984,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> check_stack_depth ( ) ; 
4985,"<S2SV_StartBug> PHP_SHA512Init ( & context ) ; <S2SV_EndBug> <S2SV_StartBug> PHP_SHA256Init ( & context ) ; <S2SV_EndBug> <S2SV_StartBug> PHP_SHA1Init ( & context ) ; <S2SV_EndBug> <S2SV_StartBug> PHP_MD5Init ( & context ) ; <S2SV_EndBug> <S2SV_StartBug> * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } <S2SV_ModStart> if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } <S2SV_ModStart> if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } <S2SV_ModStart> if ( sig_len < sizeof ( digest <S2SV_ModEnd> <S2SV_ModStart> PHP_MD5Init ( & context ) ; read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_MD5Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_MD5Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } "
4986,<S2SV_StartBug> struct mct_u232_private * priv ; <S2SV_EndBug> <S2SV_StartBug> priv -> read_urb = port -> serial -> port [ 1 ] -> interrupt_in_urb ; <S2SV_EndBug> ,"<S2SV_ModStart> usb_serial * serial = port -> serial ; struct <S2SV_ModStart> if ( ! serial -> port [ 1 ] || ! serial -> port [ 1 ] -> interrupt_in_urb ) { dev_err ( & port -> dev , ""expected<S2SV_blank>endpoint<S2SV_blank>missing\\n"" ) ; return - ENODEV ; } <S2SV_ModStart>  <S2SV_ModEnd> "
4987,"<S2SV_StartBug> int is_rf64 = ! strncmp ( fourcc , ""RF64"" , 4 ) , got_ds64 = 0 ; <S2SV_EndBug> <S2SV_StartBug> int supported = TRUE , format ; <S2SV_EndBug> ","<S2SV_ModStart> = 0 , format_chunk <S2SV_ModStart> if ( format_chunk ++ ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } "
4988,"<S2SV_StartBug> rq = blk_mq_tag_to_rq ( tags , off + bit ) ; <S2SV_EndBug> ",<S2SV_ModStart> tags -> rqs [ <S2SV_ModEnd> <S2SV_ModStart> ] <S2SV_ModEnd> 
4989,<S2SV_StartBug> pStart = sqlite3Malloc ( sz * cnt ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( sqlite3_int64 ) 
4990,"<S2SV_StartBug> rc = - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) <S2SV_EndBug> <S2SV_StartBug> ipxitf_put ( ipxif ) ; <S2SV_EndBug> ","<S2SV_ModStart> 0 ; if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) rc = <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4991,<S2SV_StartBug> if ( dst_reg -> smin_value < 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
4992,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>MTU<S2SV_blank>size<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 4 ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( tlv_len < 6 ) { return hexdump ; } 
4993,<S2SV_StartBug> int vert_causal_ctx_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_VSC ; <S2SV_EndBug> ,<S2SV_ModStart> ; av_assert0 ( width <= JPEG2000_MAX_CBLKW ) ; av_assert0 ( height <= JPEG2000_MAX_CBLKH ) 
4994,"<S2SV_StartBug> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <S2SV_EndBug> <S2SV_StartBug> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <S2SV_EndBug> ",<S2SV_ModStart> & 255 <S2SV_ModStart> & 255 
4995,"<S2SV_StartBug> if ( mobj ) <S2SV_EndBug> <S2SV_StartBug> memset ( mobj_get_va ( mobj , 0 ) , 0 , size ) ; <S2SV_EndBug> ","<S2SV_ModStart> { size_t granularity = BIT ( tee_mm_sec_ddr . shift ) ; <S2SV_ModStart> ROUNDUP ( size , granularity ) ) ; } <S2SV_ModEnd> "
4996,<S2SV_StartBug> if ( text [ 1 ] == EOF ) <S2SV_EndBug> <S2SV_StartBug> if ( text [ 2 ] == EOF ) <S2SV_EndBug> <S2SV_StartBug> if ( text [ 3 ] == EOF ) <S2SV_EndBug> ,<S2SV_ModStart> || text [ 1 ] == 0 <S2SV_ModStart> ! isxdigit ( <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> ! isxdigit ( <S2SV_ModStart> ) <S2SV_ModEnd> 
4997,"<S2SV_StartBug> * low = p - reg -> dmax ; <S2SV_EndBug> <S2SV_StartBug> ( pprev ? pprev : str ) , * low ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( p - str < reg -> dmax ) { * low = ( UChar * ) str ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , str , * low ) ; } else { <S2SV_ModStart> } "
4998,"<S2SV_StartBug> if ( ! new_idmap_permitted ( ns , cap_setid , & new_map ) ) <S2SV_EndBug> ","<S2SV_ModStart> file , "
4999,"<S2SV_StartBug> channel = amqp_d16 ( amqp_offset ( raw_frame , 1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> state -> target_size = <S2SV_EndBug> <S2SV_StartBug> amqp_d32 ( amqp_offset ( raw_frame , 3 ) ) + HEADER_SIZE + FOOTER_SIZE ; <S2SV_EndBug> ","<S2SV_ModStart> uint32_t frame_size ; <S2SV_ModStart> frame_size = amqp_d32 ( amqp_offset ( raw_frame , 3 ) ) ; if ( frame_size >= INT32_MAX ) { return AMQP_STATUS_BAD_AMQP_DATA ; } <S2SV_ModStart> frame_size <S2SV_ModEnd> "
5000,<S2SV_StartBug> if ( file -> name ) XFREE ( file -> name ) ; <S2SV_EndBug> <S2SV_StartBug> file -> len = a -> values [ 0 ] . len ; <S2SV_EndBug> <S2SV_StartBug> if ( file -> mime_type ) XFREE ( file -> mime_type ) ; <S2SV_EndBug> <S2SV_StartBug> if ( file -> content_id ) XFREE ( file -> content_id ) ; <S2SV_EndBug> ,<S2SV_ModStart> assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> assert ( ( a -> type == szMAPI_BINARY ) || ( a -> type == szMAPI_OBJECT ) ) ; <S2SV_ModStart> assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> assert ( a -> type == szMAPI_STRING ) ; 
5001,"<S2SV_StartBug> if ( istreq ( str , ""all"" ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ! str ) return false ; if ( 
5002,"<S2SV_StartBug> ihevcd_cxa_create_op_t * ps_create_op ; <S2SV_EndBug> <S2SV_StartBug> ps_create_op = ( ihevcd_cxa_create_op_t * ) pv_api_op ; <S2SV_EndBug> <S2SV_StartBug> ret = ihevcd_allocate_static_bufs ( & ps_codec_obj , pv_api_ip , pv_api_op ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( IV_FAIL == ret ) && ( NULL != ps_codec_obj ) ) <S2SV_EndBug> <S2SV_StartBug> ihevcd_free_static_bufs ( ps_codec_obj ) ; <S2SV_EndBug> ","<S2SV_ModStart> ihevcd_cxa_create_ip_t * ps_create_ip ; <S2SV_ModStart> ps_create_ip = ( ihevcd_cxa_create_ip_t * ) pv_api_ip ; <S2SV_ModStart> ps_codec_obj = NULL ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { if <S2SV_ModEnd> <S2SV_ModStart> { if ( ps_codec_obj -> pv_codec_handle <S2SV_ModStart> } else { void ( * pf_aligned_free ) ( void * pv_mem_ctxt , void * pv_buf ) ; void * pv_mem_ctxt ; pf_aligned_free = ps_create_ip -> s_ivd_create_ip_t . pf_aligned_free ; pv_mem_ctxt = ps_create_ip -> s_ivd_create_ip_t . pv_mem_ctxt ; pf_aligned_free ( pv_mem_ctxt , ps_codec_obj ) ; } } "
5003,"<S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> char line [ NETSCREEN_LINE_LENGTH ] ; <S2SV_EndBug> <S2SV_StartBug> pkt_len = parse_netscreen_rec_hdr ( phdr , line , cap_int , & cap_dir , <S2SV_EndBug> <S2SV_StartBug> if ( pkt_len == - 1 ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return parse_netscreen_packet ( wth -> random_fh , phdr , buf <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5004,"<S2SV_StartBug> alloc_limit_assert ( ""checked_xcalloc"" , ( num * size ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> res <S2SV_ModEnd> "
5005,<S2SV_StartBug> bufsize = file -> size ; <S2SV_EndBug> ,"<S2SV_ModStart> MIN ( <S2SV_ModStart> , sizeof buf ) "
5006,"<S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5007,"<S2SV_StartBug> if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) <S2SV_EndBug> <S2SV_StartBug> if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ; 
5008,<S2SV_StartBug> int pixel_ptr = 0 ; <S2SV_EndBug> <S2SV_StartBug> block_ptr = row_ptr + pixel_ptr ; <S2SV_EndBug> <S2SV_StartBug> ADVANCE_BLOCK ( ) ; <S2SV_EndBug> <S2SV_StartBug> block_ptr = row_ptr + pixel_ptr ; <S2SV_EndBug> <S2SV_StartBug> ADVANCE_BLOCK ( ) ; <S2SV_EndBug> <S2SV_StartBug> block_ptr = row_ptr + pixel_ptr ; <S2SV_EndBug> <S2SV_StartBug> ADVANCE_BLOCK ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> - 4 <S2SV_ModEnd> <S2SV_ModStart> ADVANCE_BLOCK ( ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ADVANCE_BLOCK ( ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ADVANCE_BLOCK ( ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
5009,<S2SV_StartBug> * ptr = ( char ) ( ( existing & ~ ( mask << bitIdx ) ) | ( ( col & mask ) << bitIdx ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ; 
5010,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> iw_set_error ( rctx -> ctx , ""Compression<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>with<S2SV_blank>top-down<S2SV_blank>images"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> goto done ; <S2SV_ModStart> ; goto done 
5011,<S2SV_StartBug> int err = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> = 0 ; msg -> msg_namelen 
5012,<S2SV_StartBug> put_io_context ( ioc ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> 
5013,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> add_bool_conf_item ( ""ANOPE_FLAGS_COMPAT"" , & chansvs . me -> conf_table , 0 , & anope_flags_compat , true ) ; hook_add_event ( ""nick_can_register"" ) ; hook_add_nick_can_register ( check_registration_keywords ) ; hook_add_event ( ""user_can_register"" ) ; hook_add_user_can_register ( check_registration_keywords ) ; "
5014,<S2SV_StartBug> if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ps_dec -> u1_first_slice_in_stream ) <S2SV_EndBug> ,<S2SV_ModStart> UNUSED ( u1_is_idr_slice ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
5015,"<S2SV_StartBug> static inline struct enamemem * <S2SV_EndBug> <S2SV_StartBug> struct enamemem * tp ; <S2SV_EndBug> <S2SV_StartBug> while ( tp -> e_nxt ) <S2SV_EndBug> <S2SV_StartBug> tp -> e_addr1 == j && <S2SV_EndBug> <S2SV_StartBug> tp -> e_addr2 == k && <S2SV_EndBug> <S2SV_StartBug> memcmp ( ( const char * ) bs , ( const char * ) ( tp -> e_bs ) , nlen ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> tp = tp -> e_nxt ; <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_bs == NULL ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( tp -> e_bs , bs , nlen ) ; <S2SV_EndBug> <S2SV_StartBug> tp -> e_nxt = ( struct enamemem * ) calloc ( 1 , sizeof ( * tp ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_nxt == NULL ) <S2SV_EndBug> ","<S2SV_ModStart> bsnamemem <S2SV_ModEnd> <S2SV_ModStart> bsnamemem <S2SV_ModEnd> <S2SV_ModStart> bs_nxt ) if ( nlen == tp -> bs_nbytes <S2SV_ModEnd> <S2SV_ModStart> bs_addr0 == i <S2SV_ModEnd> <S2SV_ModStart> bs_addr1 == j && tp -> bs_addr2 <S2SV_ModEnd> <S2SV_ModStart> bs_bytes <S2SV_ModEnd> <S2SV_ModStart> bs_nxt ; tp -> bs_addr0 = i ; tp -> bs_addr1 = j ; tp -> bs_addr2 = k ; tp -> bs_bytes <S2SV_ModEnd> <S2SV_ModStart> bs_bytes <S2SV_ModEnd> <S2SV_ModStart> bs_bytes , bs , nlen ) ; tp -> bs_nbytes = nlen ; tp -> bs_nxt <S2SV_ModEnd> <S2SV_ModStart> bsnamemem <S2SV_ModEnd> <S2SV_ModStart> bs_nxt <S2SV_ModEnd> "
5016,"<S2SV_StartBug> void vp9_iht4x4_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> 
5017,<S2SV_StartBug> if ( length > 0 ) { <S2SV_EndBug> <S2SV_StartBug> buffer = malloc ( ( uint64_t ) length + 1 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> == SIZE_MAX ) { rfbErr ( ""rfbProcessFileTransferReadBuffer:<S2SV_blank>too<S2SV_blank>big<S2SV_blank>file<S2SV_blank>transfer<S2SV_blank>length<S2SV_blank>requested:<S2SV_blank>%u"" , ( unsigned int ) length ) ; rfbCloseClient ( cl ) ; return NULL ; } if ( length <S2SV_ModStart> size_t <S2SV_ModEnd> "
5018,<S2SV_StartBug> static int mptctl_do_reset ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> struct mpt_ioctl_diag_reset krinfo ; <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,"<S2SV_ModStart> MPT_ADAPTER * iocp , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5019,"<S2SV_StartBug> size_t off = 0 , len = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( base_len < off + len || res_sz < len ) <S2SV_EndBug> ","<S2SV_ModStart> , end <S2SV_ModStart> GIT_ADD_SIZET_OVERFLOW ( & end , off , len ) || base_len < end <S2SV_ModEnd> "
5020,"<S2SV_StartBug> char * method = manager -> method ; <S2SV_EndBug> <S2SV_StartBug> build_config ( working_dir , server ) ; <S2SV_EndBug> <S2SV_StartBug> ""%s<S2SV_blank>-m<S2SV_blank>%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%s.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%s.conf"" , <S2SV_EndBug> <S2SV_StartBug> executable , method , manager -> manager_address , <S2SV_EndBug> <S2SV_StartBug> working_dir , server -> port , working_dir , server -> port ) ; <S2SV_EndBug> ","<S2SV_ModStart> int i ; int port ; port = atoi ( server -> port ) <S2SV_ModEnd> <S2SV_ModStart> manager , server ) <S2SV_ModEnd> <S2SV_ModStart> ""%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%d.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%d.conf"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5021,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5022,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> sas_destruct_devices ( port ) ; sas_destruct_ports ( port ) ; sas_probe_devices ( port ) ; 
5023,"<S2SV_StartBug> if ( io_data -> read && ret > 0 ) { <S2SV_EndBug> <S2SV_StartBug> ! ( io_data -> kiocb -> ki_flags & IOCB_EVENTFD ) ) <S2SV_EndBug> <S2SV_StartBug> usb_ep_free_request ( io_data -> ep , io_data -> req ) ; <S2SV_EndBug> ","<S2SV_ModStart> bool kiocb_has_eventfd = <S2SV_ModEnd> <S2SV_ModStart> ; if ( io_data -> read && ret > 0 ) { use_mm ( io_data -> mm ) ; ret = copy_to_iter ( io_data -> buf , ret , & io_data -> data ) ; if ( iov_iter_count ( & io_data -> data ) ) ret = - EFAULT ; unuse_mm ( io_data -> mm ) ; } io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ; if ( io_data -> ffs -> ffs_eventfd && ! kiocb_has_eventfd <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5024,<S2SV_StartBug> dev -> hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ; <S2SV_EndBug> <S2SV_StartBug> dev -> features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5025,<S2SV_StartBug> ctx -> clockid = clockid ; <S2SV_EndBug> ,<S2SV_ModStart> spin_lock_init ( & ctx -> cancel_lock ) ; 
5026,<S2SV_StartBug> if ( ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_LAST_PWD_CHANGE ) || <S2SV_EndBug> <S2SV_StartBug> if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) <S2SV_EndBug> <S2SV_StartBug> if ( entry == ( kadm5_principal_ent_t ) NULL ) <S2SV_EndBug> ,<S2SV_ModStart> entry == NULL ) return EINVAL ; if ( <S2SV_ModStart> entry -> policy == NULL <S2SV_ModEnd> <S2SV_ModStart> ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK <S2SV_ModEnd> 
5027,"<S2SV_StartBug> COAP_SET_BLOCK_M ( value , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> COAP_SET_BLOCK_M ( value , 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> } 
5028,<S2SV_StartBug> if ( '%' == * ptr ) { <S2SV_EndBug> ,<S2SV_ModStart> && ptr [ 1 ] 
5029,<S2SV_StartBug> unlock_mount_hash ( ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( unlikely ( ! list_empty ( & mnt -> mnt_mounts ) ) ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { umount_mnt ( p ) ; } } "
5030,"<S2SV_StartBug> zap = key -> payload . data [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> rcu_assign_keypointer ( key , upayload ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_ModStart> else zap = NULL ; "
5031,<S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY 
5032,<S2SV_StartBug> if ( code == 0 || code == KRB5_PREAUTH_FAILED ) { <S2SV_EndBug> ,<S2SV_ModStart> ! code <S2SV_ModEnd> <S2SV_ModStart> || code == KRB5KDC_ERR_KEY_EXP 
5033,"<S2SV_StartBug> memcpy ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ",<S2SV_ModStart> mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> mutex_unlock ( & ue -> card -> user_ctl_lock ) ; 
5034,"<S2SV_StartBug> return touch_file ( path , false , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> MODE_INVALID <S2SV_ModEnd> 
5035,<S2SV_StartBug> return SET_IVD_FATAL_ERROR ( e_error ) ; <S2SV_EndBug> ,<S2SV_ModStart> ps_dec -> u2_reinit_max_height = ps_dec -> u2_vertical_size ; ps_dec -> u2_reinit_max_width = ps_dec -> u2_horizontal_size ; return e_error <S2SV_ModEnd> 
5036,<S2SV_StartBug> if ( ! offset ) { <S2SV_EndBug> ,<S2SV_ModStart> || ! ht 
5037,"<S2SV_StartBug> gss_buffer_desc client_name , service_name ; <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
5038,"<S2SV_StartBug> buffer = zend_string_alloc ( len , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> zend_string_safe_alloc ( 1 , len , 0 <S2SV_ModEnd> "
5039,<S2SV_StartBug> sbi -> s_mb_cache = ext4_xattr_create_cache ( sb -> s_id ) ; <S2SV_EndBug> <S2SV_StartBug> failed_mount_wq : <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( sbi -> s_mb_cache ) { ext4_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } 
5040,<S2SV_StartBug> pack -> hdr . ver = ver ; <S2SV_EndBug> ,<S2SV_ModStart> flags = L2TP_FLAG_T | L2TP_FLAG_L | L2TP_FLAG_S | ( ver & L2TP_VER_MASK ) <S2SV_ModEnd> 
5041,<S2SV_StartBug> error = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5042,<S2SV_StartBug> if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || <S2SV_EndBug> <S2SV_StartBug> if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( mask & ~ ALL_PRINC_MASK ) ) <S2SV_EndBug> <S2SV_StartBug> return KADM5_BAD_MASK ; <S2SV_EndBug> ,<S2SV_ModStart> entry == NULL ) return EINVAL ; if ( <S2SV_ModStart> entry -> policy == NULL <S2SV_ModEnd> <S2SV_ModStart> KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( ( mask & <S2SV_ModStart>  <S2SV_ModEnd> 
5043,<S2SV_StartBug> namespace_lock ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! check_mnt ( real_mount ( path -> mnt ) ) ) tree = ERR_PTR ( - EINVAL ) ; else 
5044,<S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY 
5045,<S2SV_StartBug> status = HuffmanDecodeImage ( image ) ; <S2SV_EndBug> ,"<S2SV_ModStart> SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } status = "
5046,"<S2SV_StartBug> mptctl_hp_hostinfo ( unsigned long arg , unsigned int data_size ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> ConfigPageHeader_t hdr ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <S2SV_EndBug> ","<S2SV_ModStart> MPT_ADAPTER * ioc , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5047,"<S2SV_StartBug> if ( COMPAT_USE_64BIT_TIME ) <S2SV_EndBug> <S2SV_StartBug> if ( get_compat_timespec ( & ktspec , timeout ) ) <S2SV_EndBug> <S2SV_StartBug> if ( datagrams > 0 && put_compat_timespec ( & ktspec , timeout ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> compat_get_timespec <S2SV_ModEnd> <S2SV_ModStart> compat_put_timespec <S2SV_ModEnd> 
5048,"<S2SV_StartBug> SCV_NB10_HEADER nb10_hdr ; <S2SV_EndBug> <S2SV_StartBug> ""%x%x"" , nb10_hdr . timestamp , nb10_hdr . age ) ; <S2SV_EndBug> <S2SV_StartBug> nb10_hdr . file_name , sizeof ( res -> file_name ) - 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( dbg_data_len < 20 ) { eprintf ( ""Truncated<S2SV_blank>NB10<S2SV_blank>entry,<S2SV_blank>not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>parse\\n"" ) ; return 0 ; } SCV_NB10_HEADER nb10_hdr = { { 0 } } <S2SV_ModEnd> <S2SV_ModStart> res -> file_name [ 0 ] = 0 ; if ( nb10_hdr . file_name ) { <S2SV_ModStart> } "
5049,<S2SV_StartBug> bpm -> family = AF_BRIDGE ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( bpm , 0 , sizeof ( * bpm ) ) ; "
5050,"<S2SV_StartBug> 1 , 0 , regs , regs -> cp0_badvaddr ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
5051,"<S2SV_StartBug> b = BCON_NEW ( ""my_dbref"" , <S2SV_EndBug> ","<S2SV_ModStart> VALIDATE_TEST ( ""test59.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; "
5052,"<S2SV_StartBug> vpx_memset ( pbi , 0 , sizeof ( VP8D_COMP ) ) ; <S2SV_EndBug> <S2SV_StartBug> pbi -> ec_enabled = 0 ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> ( void ) oxcf ; 
5053,"<S2SV_StartBug> if ( stat ( ""/etc/skel/.zshrc"" , & s ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> copy_file ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> copy_file ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( stat ( ""/etc/skel/.bashrc"" , & s ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> copy_file ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) ; <S2SV_EndBug> ","<S2SV_ModStart> is_link ( fname ) ) { fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n"" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> copy_file_as_user <S2SV_ModEnd> <S2SV_ModStart> is_link ( fname ) ) { fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n"" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> copy_file_as_user <S2SV_ModEnd> <S2SV_ModStart> is_link ( fname ) ) { fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n"" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> copy_file_as_user <S2SV_ModEnd> "
5054,"<S2SV_StartBug> if ( S_ISDIR ( fmode ) && S_ISLNK ( sb . st_mode ) && stat ( fn , & sb ) != 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> ) { struct stat dsb ; if ( stat ( fn , & dsb ) == 0 && S_ISDIR ( dsb . st_mode ) ) { uid_t fuid ; if ( sb . st_uid == 0 || ( rpmugUid ( rpmfilesFUser ( fi , ix ) , & fuid ) == 0 && sb . st_uid == fuid ) ) { sb = dsb ; } } <S2SV_ModEnd> "
5055,"<S2SV_StartBug> asdl_seq * body ; <S2SV_EndBug> <S2SV_StartBug> * out = Module ( body , arena ) ; <S2SV_EndBug> <S2SV_StartBug> isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ; <S2SV_EndBug> <S2SV_StartBug> PyErr_Format ( PyExc_TypeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; <S2SV_EndBug> <S2SV_StartBug> body = _Py_asdl_seq_new ( len , arena ) ; <S2SV_EndBug> <S2SV_StartBug> if ( body == NULL ) goto failed ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty val ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_RuntimeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( body , i , val ) ; <S2SV_EndBug> <S2SV_StartBug> * out = Interactive ( body , arena ) ; <S2SV_EndBug> <S2SV_StartBug> isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; <S2SV_EndBug> <S2SV_StartBug> expr_ty body ; <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; <S2SV_EndBug> <S2SV_StartBug> PyErr_Format ( PyExc_TypeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_RuntimeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; asdl_seq * type_ignores <S2SV_ModStart> if ( _PyObject_LookupAttrId <S2SV_ModEnd> <S2SV_ModStart> & PyId_type_ignores <S2SV_ModEnd> <S2SV_ModStart> ""required<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" <S2SV_ModEnd> <S2SV_ModStart> ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" <S2SV_ModEnd> <S2SV_ModStart> type_ignores <S2SV_ModEnd> <S2SV_ModStart> type_ignores <S2SV_ModEnd> <S2SV_ModStart> type_ignore_ty <S2SV_ModEnd> <S2SV_ModStart> obj2ast_type_ignore <S2SV_ModEnd> <S2SV_ModStart> ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" <S2SV_ModEnd> <S2SV_ModStart> type_ignores <S2SV_ModEnd> <S2SV_ModStart> Module ( body , type_ignores <S2SV_ModEnd> <S2SV_ModStart> Interactive_type <S2SV_ModEnd> <S2SV_ModStart> asdl_seq * <S2SV_ModEnd> <S2SV_ModStart> ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" <S2SV_ModEnd> <S2SV_ModStart> ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" <S2SV_ModEnd> <S2SV_ModStart> ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( body , i , val ) ; } Py_CLEAR ( tmp ) ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & body , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Expression ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionType_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * argtypes ; expr_ty returns ; if ( _PyObject_LookupAttrId ( obj , & PyId_argtypes , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; argtypes = _Py_asdl_seq_new ( len , arena ) ; if ( argtypes == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { expr_ty val ; res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( argtypes , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""returns\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Py_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , "
5056,"<S2SV_StartBug> [ DISCE_PROBE ] = sas_probe_devices , <S2SV_EndBug> <S2SV_StartBug> [ DISCE_RESUME ] = sas_resume_devices , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5057,"<S2SV_StartBug> it = item_get ( key , nkey , c , DO_UPDATE ) ; <S2SV_EndBug> ",<S2SV_ModStart> limited_get <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5058,"<S2SV_StartBug> s_cmd -> command += ec -> cmd_offset ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_to_user ( arg , s_cmd , sizeof ( * s_cmd ) + u_cmd . insize ) ) <S2SV_EndBug> ",<S2SV_ModStart> if ( u_cmd . outsize != s_cmd -> outsize || u_cmd . insize != s_cmd -> insize ) { ret = - EINVAL ; goto exit ; } <S2SV_ModStart> s_cmd -> <S2SV_ModEnd> 
5059,<S2SV_StartBug> proto = EXTRACT_16BITS ( & p [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * ( p + 1 ) == 0x81 || <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> const u_char * bp = p ; if ( length < CHDLC_HDRLEN ) goto trunc ; ND_TCHECK2 ( * p , CHDLC_HDRLEN ) ; <S2SV_ModStart> length < 2 ) goto trunc ; ND_TCHECK_16BITS ( p ) ; if ( <S2SV_ModStart> trunc : ND_PRINT ( ( ndo , ""[|chdlc]"" ) ) ; return ndo -> ndo_snapend - bp ; "
5060,<S2SV_StartBug> if ( atomic_read ( & current -> mm -> mm_users ) > 1 ) <S2SV_EndBug> ,<S2SV_ModStart> 1 ) return - EINVAL ; if ( current -> fs -> users != 
5061,"<S2SV_StartBug> dev = btrfs_find_device ( fs_info -> fs_devices , devid , NULL , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> , true "
5062,<S2SV_StartBug> for ( i = 0 ; i < len ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) { <S2SV_EndBug> <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> ,"<S2SV_ModStart> && j < sizeof ( szLineConv ) - 1 ; i ++ , j <S2SV_ModEnd> <S2SV_ModStart> if ( j + 1 < sizeof ( szLineConv ) - 1 ) { <S2SV_ModStart> break ; } else <S2SV_ModStart> if ( j + 1 < sizeof ( szLineConv ) - 1 && i + 1 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> <S2SV_ModStart> if ( j + 2 < sizeof ( szLineConv ) - 1 && i + 2 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> <S2SV_ModStart> if ( j + 3 < sizeof ( szLineConv ) - 1 && i + 3 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> <S2SV_ModStart> if ( j < sizeof ( szLineConv ) - 1 && i < len ) szLineConv [ j ] = szLine [ i ] ; } if ( j >= sizeof ( szLineConv ) ) szLineConv [ sizeof ( szLineConv ) - 1 ] = 0 ; else <S2SV_ModEnd> "
5063,<S2SV_StartBug> if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( replay_esn ) != ulen ) <S2SV_EndBug> ,<S2SV_ModStart> || replay_esn -> bmp_len != up -> bmp_len 
5064,<S2SV_StartBug> char fstr [ MAXDATELEN + 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart> 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> 
5065,"<S2SV_StartBug> int sctp_verify_asconf ( const struct sctp_association * asoc , <S2SV_EndBug> <S2SV_StartBug> struct sctp_paramhdr * param_hdr , void * chunk_end , <S2SV_EndBug> <S2SV_StartBug> sctp_addip_param_t * asconf_param ; <S2SV_EndBug> <S2SV_StartBug> int length , plen ; <S2SV_EndBug> <S2SV_StartBug> param . v = ( sctp_paramhdr_t * ) param_hdr ; <S2SV_EndBug> ","<S2SV_ModStart> bool <S2SV_ModEnd> <S2SV_ModStart> sctp_chunk * chunk , bool addr_param_needed <S2SV_ModEnd> <S2SV_ModStart> sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) chunk -> chunk_hdr <S2SV_ModEnd> <S2SV_ModStart> bool addr_param_seen = false ; sctp_walk_params ( param , addip , addip_hdr . params ) { size_t length = ntohs ( param . p -> length ) ; * errp = param . p ; switch ( param . p -> type ) { case SCTP_PARAM_ERR_CAUSE : break ; case SCTP_PARAM_IPV4_ADDRESS : if ( length != sizeof ( sctp_ipv4addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_IPV6_ADDRESS : if ( length != sizeof ( sctp_ipv6addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : if ( addr_param_needed && ! addr_param_seen ) return false ; length = ntohs ( param . addip -> param_hdr . length ) ; if ( length < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return false ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return false ; break ; default : return false ; } } if ( addr_param_needed && ! addr_param_seen ) return false ; if ( ! addr_param_needed && addr_param_seen ) return false ; if ( <S2SV_ModEnd> <S2SV_ModStart> != chunk -> chunk_end ) return false ; return true <S2SV_ModEnd> "
5066,"<S2SV_StartBug> if ( ( fd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> close ( fd ) ; <S2SV_EndBug> <S2SV_StartBug> unlink ( hdl -> c_path ) ; <S2SV_EndBug> <S2SV_StartBug> unlink ( hdl -> c_path ) ; <S2SV_EndBug> <S2SV_StartBug> unlink ( hdl -> c_path ) ; <S2SV_EndBug> <S2SV_StartBug> return HSM_COM_SEND_ERR ; <S2SV_EndBug> ",<S2SV_ModStart> hsm_com_errno_t res = HSM_COM_OK ; <S2SV_ModStart> res = HSM_COM_PATH_ERR ; goto cleanup <S2SV_ModEnd> <S2SV_ModStart> res = HSM_COM_BIND_ERR ; goto cleanup ; <S2SV_ModEnd> <S2SV_ModStart> res = HSM_COM_CHMOD_ERR ; goto cleanup <S2SV_ModEnd> <S2SV_ModStart> res = HSM_COM_CONX_ERR ; goto cleanup <S2SV_ModEnd> <S2SV_ModStart> res = HSM_COM_SEND_ERR ; } return res ; cleanup : close ( fd ) ; return res <S2SV_ModEnd> 
5067,"<S2SV_StartBug> int counthook ; <S2SV_EndBug> <S2SV_StartBug> const Proto * p = ci_func ( ci ) -> p ; <S2SV_EndBug> <S2SV_StartBug> pc <= L -> oldpc || <S2SV_EndBug> <S2SV_StartBug> changedline ( p , pcRel ( L -> oldpc , p ) , npci ) ) { <S2SV_EndBug> <S2SV_StartBug> L -> oldpc = pc ; <S2SV_EndBug> ","<S2SV_ModStart> const Proto * p = ci_func ( ci ) -> p ; int counthook ; int oldpc = ( L -> oldpc < p -> sizecode ) ? L -> oldpc : 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> invpcRel ( oldpc , p ) <S2SV_ModEnd> <S2SV_ModStart> oldpc <S2SV_ModEnd> <S2SV_ModStart> npci <S2SV_ModEnd> "
5068,"<S2SV_StartBug> static void sample_hbp_handler ( struct perf_event * bp , int nmi , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
5069,"<S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> ","<S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\""baz\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""foo\\""]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""bar\\""]<S2SV_blank>==<S2SV_blank>\\""bar\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\""dummy\\"")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""foo\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""bar\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> "
5070,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
5071,"<S2SV_StartBug> u64 start = offset >> PAGE_CACHE_SHIFT ; <S2SV_EndBug> <S2SV_StartBug> u64 end = ( offset + len - 1 ) >> PAGE_CACHE_SHIFT ; <S2SV_EndBug> <S2SV_StartBug> ! ( mode & FALLOC_FL_KEEP_SIZE ) ) { <S2SV_EndBug> <S2SV_StartBug> i_size_write ( inode , offset + to ) ; <S2SV_EndBug> <S2SV_StartBug> mark_inode_dirty ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> return error ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned int nr_blks ; sector_t lblock <S2SV_ModEnd> <S2SV_ModStart> inode -> i_blkbits ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) return error ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } while ( len ) { struct buffer_head bh_map = { . b_state = 0 , . b_blocknr = 0 } ; bh_map . b_size = len ; set_buffer_zeronew ( & bh_map ) ; error = gfs2_block_map ( inode , lblock , & bh_map , 1 ) ; if ( unlikely ( error ) ) goto out ; len -= bh_map . b_size ; nr_blks = bh_map . b_size >> inode -> i_blkbits ; lblock += nr_blks ; if ( ! buffer_new ( & bh_map ) ) continue ; if ( unlikely ( ! buffer_zeronew ( & bh_map ) ) ) { error = - EIO ; goto out ; } } if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> len ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> brelse ( dibh ) ; "
5072,"<S2SV_StartBug> memcpy ( tim . bitmap , p + ( tim . length - 3 ) , <S2SV_EndBug> <S2SV_StartBug> ( tim . length - 3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> length -= tim . length - 3 ; <S2SV_EndBug> ","<S2SV_ModStart> offset + 3 , <S2SV_ModEnd> <S2SV_ModStart> ; offset += <S2SV_ModEnd> <S2SV_ModStart> ; length -= <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5073,<S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff "
5074,<S2SV_StartBug> namespace_lock ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! check_mnt ( real_mount ( path -> mnt ) ) ) tree = ERR_PTR ( - EINVAL ) ; else 
5075,"<S2SV_StartBug> if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { <S2SV_EndBug> ","<S2SV_ModStart> memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteOlympusEntry ) ) ; "
5076,<S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> <S2SV_StartBug> limit = get_desc_limit ( desc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( desc -> g ) <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_desc ( & desc , sel ) <S2SV_ModEnd> <S2SV_ModStart> & <S2SV_ModStart> . <S2SV_ModEnd> "
5077,<S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug> ,<S2SV_ModStart> mb2_cache <S2SV_ModEnd> 
5078,"<S2SV_StartBug> & bufferoffset , <S2SV_EndBug> ","<S2SV_ModStart> t2p -> tiff_datasize , "
5079,<S2SV_StartBug> if ( rows > 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> l == NULL ) break ; if ( 
5080,"<S2SV_StartBug> static void encode_txfm_probs ( VP9_COMMON * cm , vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> vp9_write_bit ( w , cm -> tx_mode == TX_MODE_SELECT ) ; <S2SV_EndBug> <S2SV_StartBug> tx_counts_to_branch_counts_8x8 ( cm -> counts . tx . p8x8 [ i ] , ct_8x8p ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p8x8 [ i ] [ j ] , ct_8x8p [ j ] ) ; <S2SV_EndBug> <S2SV_StartBug> tx_counts_to_branch_counts_16x16 ( cm -> counts . tx . p16x16 [ i ] , ct_16x16p ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p16x16 [ i ] [ j ] , <S2SV_EndBug> <S2SV_StartBug> tx_counts_to_branch_counts_32x32 ( cm -> counts . tx . p32x32 [ i ] , ct_32x32p ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p32x32 [ i ] [ j ] , <S2SV_EndBug> ","<S2SV_ModStart> vpx_writer * w , FRAME_COUNTS * counts ) { vpx_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_write_bit <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> "
5081,"<S2SV_StartBug> int len , err = - ENOBUFS ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( nlk -> cb_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> module_put ( cb -> module ) ; <S2SV_EndBug> <S2SV_StartBug> consume_skb ( cb -> skb ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct module * module ; <S2SV_ModStart> module = cb -> module ; skb = cb -> skb ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5082,<S2SV_StartBug> assert ( n >= 0 && n < 32 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( n < 0 || n >= 32 ) { return - 1 ; } <S2SV_ModEnd> 
5083,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
5084,<S2SV_StartBug> DEFINE_WAKE_Q ( wake_q ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( nr_wake < 0 || nr_requeue < 0 ) return - EINVAL 
5085,<S2SV_StartBug> if ( n <= 0 ) return ( n ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5086,<S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> ,<S2SV_ModStart> n2size < 1 ) <S2SV_ModEnd> 
5087,<S2SV_StartBug> next_character ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> recovery_started = true ; 
5088,"<S2SV_StartBug> kvm_iommu_put_pages ( kvm , memslot -> base_gfn , memslot -> npages ) ; <S2SV_EndBug> ",<S2SV_ModStart> kvm_iommu_unmap_pages <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5089,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( ptr ) 
5090,<S2SV_StartBug> for ( p = 0 ; p < 4 && in -> data [ p ] ; p ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && in -> linesize [ p ] 
5091,"<S2SV_StartBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>[-t<S2SV_blank>life]<S2SV_blank>[command<S2SV_blank>[arg<S2SV_blank>...]]\\n"" <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>[-P<S2SV_blank>pkcs11_whitelist]<S2SV_blank>[-t<S2SV_blank>life]<S2SV_blank>[command<S2SV_blank>[arg<S2SV_blank>...]]\\n"" <S2SV_ModEnd> "
5092,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5093,"<S2SV_StartBug> strlcpy ( rcomp . type , ""compression"" , sizeof ( rcomp . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> 
5094,"<S2SV_StartBug> u_int16_t offset = 22 , buf_out_len = 0 ; <S2SV_EndBug> <S2SV_StartBug> offset += 4 + len ; <S2SV_EndBug> <S2SV_StartBug> if ( client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> <S2SV_StartBug> offset += len ; <S2SV_EndBug> <S2SV_StartBug> if ( ! client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> <S2SV_StartBug> offset += len ; <S2SV_EndBug> <S2SV_StartBug> if ( client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> <S2SV_StartBug> offset += len ; <S2SV_EndBug> <S2SV_StartBug> if ( ! client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> <S2SV_StartBug> offset += len ; <S2SV_EndBug> <S2SV_StartBug> if ( client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> <S2SV_StartBug> offset += len ; <S2SV_EndBug> <S2SV_StartBug> if ( ! client_hash ) { <S2SV_EndBug> <S2SV_StartBug> offset += 4 ; <S2SV_EndBug> <S2SV_StartBug> offset += len ; <S2SV_EndBug> ",<S2SV_ModStart> u_int32_t <S2SV_ModEnd> <S2SV_ModStart> if ( len > UINT32_MAX - 4 - offset ) goto invalid_payload ; <S2SV_ModStart> offset += 4 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> <S2SV_ModStart> offset += 4 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> <S2SV_ModStart> offset += 4 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> <S2SV_ModStart> offset += 4 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> <S2SV_ModStart> offset += 4 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> <S2SV_ModStart> offset += 4 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> 
5095,"<S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> 
5096,<S2SV_StartBug> struct snd_timer_user * tu ; <S2SV_EndBug> <S2SV_StartBug> switch ( cmd ) { <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & tu -> tread_sem ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & tu -> tread_sem ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> long ret <S2SV_ModEnd> <S2SV_ModStart> ioctl_lock ) ; ret = __snd_timer_user_ioctl ( file , cmd , arg ) <S2SV_ModEnd> <S2SV_ModStart> ioctl_lock <S2SV_ModEnd> <S2SV_ModStart> ret <S2SV_ModEnd> "
5097,<S2SV_StartBug> if ( p -> io_context ) <S2SV_EndBug> <S2SV_StartBug> out : <S2SV_EndBug> ,<S2SV_ModStart> task_lock ( p ) ; <S2SV_ModStart> task_unlock ( p ) ; 
5098,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> signal_add ( ""server<S2SV_blank>disconnected"" , ( SIGNAL_FUNC ) sig_server_disconnected ) ; "
5099,"<S2SV_StartBug> uint32x2_t d28u32 , d29u32 , d30u32 ; <S2SV_EndBug> <S2SV_StartBug> d0u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> d1u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 1 ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> uint8x16_t q1u8 , q2u8 ; uint16x8_t q1u16 , q2u16 ; uint16x8_t q7u16 , q8u16 , q9u16 ; uint64x2_t q4u64 , q5u64 ; uint64x1_t d12u64 ; uint32x2x2_t d0u32x2 , d1u32x2 , d2u32x2 , d3u32x2 ; if ( xoffset == 0 ) { uint32x2_t d28u32 = vdup_n_u32 ( 0 ) ; uint32x2_t d29u32 = vdup_n_u32 ( 0 ) ; uint32x2_t d30u32 = vdup_n_u32 ( 0 ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5100,"
","
"
5101,"<S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> tty_encode_baud_rate ( tty , baud , baud ) ; <S2SV_EndBug> ","<S2SV_ModStart> { baud = min ( baud , 461550 ) ; <S2SV_ModStart> } "
5102,"<S2SV_StartBug> struct timespec ts ; <S2SV_EndBug> <S2SV_StartBug> ts . tv_sec = div_long_long_rem_signed ( nsec , NSEC_PER_SEC , & ts . tv_nsec ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( nsec < 0 ) ) <S2SV_EndBug> <S2SV_StartBug> set_normalized_timespec ( & ts , ts . tv_sec , ts . tv_nsec ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; s32 rem <S2SV_ModStart> div_s64_rem <S2SV_ModEnd> <S2SV_ModStart> rem <S2SV_ModEnd> <S2SV_ModStart> rem <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModEnd> <S2SV_ModStart> -- ; rem += NSEC_PER_SEC ; } <S2SV_ModEnd> <S2SV_ModStart> = rem <S2SV_ModEnd> 
5103,"<S2SV_StartBug> void Huff_transmit ( huff_t * huff , int ch , byte * fout ) { <S2SV_EndBug> <S2SV_StartBug> Huff_transmit ( huff , NYT , fout ) ; <S2SV_EndBug> <S2SV_StartBug> send ( huff -> loc [ ch ] , NULL , fout ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int maxoffset <S2SV_ModStart> , maxoffset <S2SV_ModStart> , maxoffset "
5104,<S2SV_StartBug> long timeo ; <S2SV_EndBug> ,<S2SV_ModStart> ; msg -> msg_namelen = 0 
5105,"<S2SV_StartBug> int bytes_returned , name_len ; <S2SV_EndBug> ",<S2SV_ModStart> ; unsigned int <S2SV_ModEnd> 
5106,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( pid == INT_MIN ) return - ESRCH ; 
5107,<S2SV_StartBug> int32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ; <S2SV_EndBug> ,<S2SV_ModStart> uint32_t <S2SV_ModEnd> <S2SV_ModStart> uint32_t <S2SV_ModEnd> 
5108,<S2SV_StartBug> return res ; <S2SV_EndBug> ,<S2SV_ModStart> Util_getToken ( res -> token ) ; 
5109,"<S2SV_StartBug> static TX_SIZE read_tx_size ( VP9_COMMON * cm , MACROBLOCKD * xd , TX_MODE tx_mode , <S2SV_EndBug> <S2SV_StartBug> BLOCK_SIZE bsize , int allow_select , vp9_reader * r ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> TX_MODE tx_mode = cm -> tx_mode ; BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; 
5110,<S2SV_StartBug> atomic_inc ( & sb -> s_active ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ; 
5111,"<S2SV_StartBug> FILE * ip ; <S2SV_EndBug> <S2SV_StartBug> # if ! ( defined ( WIN32 ) || defined ( cygwin ) ) <S2SV_EndBug> <S2SV_StartBug> # if ! ( defined ( WIN32 ) || defined ( cygwin ) ) <S2SV_EndBug> <S2SV_StartBug> ip = netsnmp_mibindex_new ( dirname ) ; <S2SV_EndBug> <S2SV_StartBug> if ( add_mibfile ( filenames [ i ] , strrchr ( filenames [ i ] , '/' ) , ip ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> File = oldFile ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5112,<S2SV_StartBug> int just_opened = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! v -> finished && <S2SV_EndBug> ,<S2SV_ModStart> = 0 ; int reload_count <S2SV_ModStart> reload_count ++ ; if ( reload_count > c -> max_reload ) return AVERROR_EOF ; 
5113,"<S2SV_StartBug> int fd = - 1 , ofd = - 1 , ret , ifindex = - 1 ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'."" , getpid ( ) ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'."" , pid ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( setns ( fd , 0 ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> close ( fd ) ; fd = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ifindex = if_nametoindex ( oldname ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> char ifname [ IFNAMSIZ ] , * namep = ifname ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> goto out_err ; <S2SV_EndBug> <S2SV_StartBug> if ( setns ( ofd , 0 ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> ","<S2SV_ModStart> uid_t ruid , suid , euid ; int fret = - 1 ; int fd = - 1 , ifindex <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> usernic_error ( <S2SV_ModEnd> <S2SV_ModStart> fret <S2SV_ModEnd> <S2SV_ModStart> usernic_error ( <S2SV_ModEnd> <S2SV_ModStart> goto do_partial_cleanup ; } ret = getresuid ( & ruid , & euid , & suid ) ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>real,<S2SV_blank>effective,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>"" ""user<S2SV_blank>IDs:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = <S2SV_ModEnd> <S2SV_ModStart> CLONE_NEWNET ) ; <S2SV_ModEnd> <S2SV_ModStart> fd = - 1 ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>the<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>of<S2SV_blank>"" ""the<S2SV_blank>container<S2SV_blank>with<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\n"" , pid , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = setresuid ( ruid , ruid , 0 ) ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>"" ""user<S2SV_blank>id<S2SV_blank>and<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>"" ""ID<S2SV_blank>to<S2SV_blank>0:<S2SV_blank>%s.\\n"" , ruid , strerror ( errno ) ) ; goto do_full_cleanup ; } <S2SV_ModEnd> <S2SV_ModStart> ifindex = if_nametoindex ( oldname ) ; <S2SV_ModStart> ifindex ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>netdev<S2SV_blank>index:<S2SV_blank>%s.\\n"" , strerror ( errno ) ) ; goto do_full_cleanup ; } } ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ; if ( ret < 0 ) { usernic_error ( ""Error<S2SV_blank>%d<S2SV_blank>renaming<S2SV_blank>netdev<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>container.\\n"" , ret , <S2SV_ModEnd> <S2SV_ModStart> ; goto do_full_cleanup <S2SV_ModEnd> <S2SV_ModStart> ; char <S2SV_ModEnd> <S2SV_ModStart> usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name:<S2SV_blank>%s.\\n"" , strerror ( errno ) ) ; goto do_full_cleanup <S2SV_ModEnd> <S2SV_ModStart> do_full_cleanup ; } fret = 0 ; do_full_cleanup : ret = setresuid ( ruid , euid , suid ) ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>restore<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>"" ""user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>"" ""ID<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>%s.\\n"" , ruid , euid , suid , strerror ( errno ) ) ; fret = - 1 ; } ret = <S2SV_ModEnd> <S2SV_ModStart> CLONE_NEWNET ) ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>original<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>"" ""of<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\n"" , ofd , strerror ( errno ) ) ; fret = - 1 ; } do_partial_cleanup : if ( fd >= 0 ) close ( fd ) ; close ( <S2SV_ModEnd> <S2SV_ModStart> fret <S2SV_ModEnd> "
5114,"<S2SV_StartBug> NLSF_Q15 [ i ] = silk_max_int ( NLSF_Q15 [ i ] , NLSF_Q15 [ i - 1 ] + NDeltaMin_Q15 [ i ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> silk_ADD_SAT16 ( NLSF_Q15 [ i - 1 ] , NDeltaMin_Q15 [ i ] ) <S2SV_ModEnd> "
5115,"<S2SV_StartBug> vpx_memset ( input , 0 , 32 ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> 
5116,"<S2SV_StartBug> enc624j600ClearBit ( interface , ENC624J600_REG_EIE , EIE_INTIE ) ; <S2SV_EndBug> <S2SV_StartBug> status = enc624j600ReadReg ( interface , ENC624J600_REG_EIR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & EIR_LINKIF ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> enc624j600ClearBit ( interface , ENC624J600_REG_EIE , EIE_LINKIE ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & EIR_PKTIF ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> enc624j600ClearBit ( interface , ENC624J600_REG_EIE , EIE_PKTIE ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & ( EIR_TXIF | EIR_TXABTIF ) ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_TXIF | EIR_TXABTIF ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_EIE , EIE_INTIE ) ; <S2SV_EndBug> ","<S2SV_ModStart> ENC624J600_EIE , ENC624J600_EIE_INTIE <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EIR <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EIR_LINKIF <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EIE , ENC624J600_EIE_LINKIE <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EIR_PKTIF <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EIE , ENC624J600_EIE_PKTIE <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EIR , ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EIE , ENC624J600_EIE_INTIE <S2SV_ModEnd> "
5117,"<S2SV_StartBug> if ( ( fd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> close ( fd ) ; <S2SV_EndBug> <S2SV_StartBug> unlink ( hdl -> c_path ) ; <S2SV_EndBug> <S2SV_StartBug> unlink ( hdl -> c_path ) ; <S2SV_EndBug> <S2SV_StartBug> unlink ( hdl -> c_path ) ; <S2SV_EndBug> <S2SV_StartBug> return HSM_COM_SEND_ERR ; <S2SV_EndBug> ",<S2SV_ModStart> hsm_com_errno_t res = HSM_COM_OK ; <S2SV_ModStart> res = HSM_COM_PATH_ERR ; goto cleanup <S2SV_ModEnd> <S2SV_ModStart> res = HSM_COM_BIND_ERR ; goto cleanup ; <S2SV_ModEnd> <S2SV_ModStart> res = HSM_COM_CHMOD_ERR ; goto cleanup <S2SV_ModEnd> <S2SV_ModStart> res = HSM_COM_CONX_ERR ; goto cleanup <S2SV_ModEnd> <S2SV_ModStart> res = HSM_COM_SEND_ERR ; } return res ; cleanup : close ( fd ) ; return res <S2SV_ModEnd> 
5118,"<S2SV_StartBug> opt = xchg ( & inet6_sk ( sk ) -> opt , opt ) ; <S2SV_EndBug> ",<S2SV_ModStart> ( __force struct ipv6_txoptions * * ) 
5119,<S2SV_StartBug> s -> cur_pic . field_picture || <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5120,<S2SV_StartBug> char build [ ATUSB_BUILD_SIZE + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ,"<S2SV_ModStart> * build <S2SV_ModEnd> <S2SV_ModStart> ; build = kmalloc ( ATUSB_BUILD_SIZE + 1 , GFP_KERNEL ) ; if ( ! build ) return - ENOMEM <S2SV_ModStart> kfree ( build ) ; "
5121,<S2SV_StartBug> if ( ( flags & FOLL_WRITE ) && ! pte_write ( pte ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> can_follow_write_pte ( pte , flags <S2SV_ModEnd> "
5122,<S2SV_StartBug> xmalloc ( size_t size ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> void * ptr = malloc ( size ) ; <S2SV_EndBug> ,"<S2SV_ModStart> num , size_t <S2SV_ModStart> size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> res <S2SV_ModEnd> "
5123,"<S2SV_StartBug> long mtemp , save_adjust , rem ; <S2SV_EndBug> <S2SV_StartBug> time_offset = div_long_long_rem_signed ( time_offset , <S2SV_EndBug> <S2SV_StartBug> NTP_INTERVAL_FREQ , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> div_s64 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5124,"<S2SV_StartBug> # ifdef CONFIG_SMP <S2SV_EndBug> <S2SV_StartBug> for_each_possible_cpu ( i ) <S2SV_EndBug> <S2SV_StartBug> lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] , <S2SV_EndBug> <S2SV_StartBug> if ( list_lru_init ( & s -> s_dentry_lru ) ) <S2SV_EndBug> <S2SV_StartBug> if ( list_lru_init ( & s -> s_inode_lru ) ) <S2SV_EndBug> ","<S2SV_ModStart> for ( i = 0 ; i < SB_FREEZE_LEVELS ; i ++ ) { if ( percpu_counter_init ( & s -> s_writers . counter [ i ] , 0 ) < 0 <S2SV_ModEnd> <S2SV_ModStart> lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] , & type -> s_writers_key [ i ] , 0 ) ; } init_waitqueue_head ( & s -> s_writers . wait ) ; init_waitqueue_head ( & s -> s_writers . wait_unfrozen ) ; s -> s_flags = flags ; s -> s_bdi = & default_backing_dev_info ; INIT_HLIST_NODE ( & s -> s_instances ) ; INIT_HLIST_BL_HEAD ( & s -> s_anon ) ; INIT_LIST_HEAD ( & s -> s_inodes ) ; if ( list_lru_init ( & s -> s_dentry_lru ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> s_inode_lru <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5125,<S2SV_StartBug> if ( log_fp ) <S2SV_EndBug> <S2SV_StartBug> if ( daemon_mode == FALSE ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int fh ; struct stat st ; if ( log_fp ) return log_fp ; if ( ( fh = open ( log_file , O_RDWR | O_APPEND | O_CREAT | O_NOFOLLOW , S_IRUSR | S_IWUSR ) ) == - 1 ) { if ( daemon_mode == FALSE ) printf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>open<S2SV_blank>log<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>writing\\n"" , log_file ) ; return NULL ; } log_fp = fdopen ( fh <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return NULL ; } if ( ( fstat ( fh , & st ) ) == - 1 ) { log_fp = NULL ; close ( fh ) ; if ( daemon_mode == FALSE ) printf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>fstat<S2SV_blank>log<S2SV_blank>file<S2SV_blank>\'%s\'\\n"" , log_file ) ; return NULL ; } if ( st . st_nlink != 1 || ( st . st_mode & S_IFMT ) != S_IFREG ) { log_fp = NULL ; close ( fh ) ; if ( daemon_mode == FALSE ) printf ( ""Warning:<S2SV_blank>log<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>mode\\n"" , log_file ) ; <S2SV_ModEnd> "
5126,"<S2SV_StartBug> r = do_write_pids ( fc -> pid , f -> controller , f -> cgroup , f -> file , localbuf ) ; <S2SV_EndBug> ","<S2SV_ModStart> fc -> uid , "
5127,<S2SV_StartBug> if ( sec_attr == NULL ) { <S2SV_EndBug> ,<S2SV_ModStart> || sec_attr_len 
5128,"<S2SV_StartBug> pop3c -> mailbox = curl_easy_unescape ( data , path , 0 , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! pop3c -> mailbox ) <S2SV_EndBug> ","<S2SV_ModStart> return Curl_urldecode <S2SV_ModEnd> <S2SV_ModStart> & <S2SV_ModEnd> <S2SV_ModStart> , NULL , TRUE ) <S2SV_ModEnd> "
5129,<S2SV_StartBug> sock_put ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> sk_nulls_node_init ( & sk -> sk_nulls_node ) ; 
5130,<S2SV_StartBug> if ( par -> color_primaries != AVCOL_PRI_UNSPECIFIED ) <S2SV_EndBug> ,"<S2SV_ModStart> print_primaries ( w , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5131,<S2SV_StartBug> if ( p -> io_context ) <S2SV_EndBug> <S2SV_StartBug> out : <S2SV_EndBug> ,<S2SV_ModStart> task_lock ( p ) ; <S2SV_ModStart> task_unlock ( p ) ; 
5132,<S2SV_StartBug> monitor_sync ( pmonitor ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5133,"<S2SV_StartBug> void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) <S2SV_EndBug> <S2SV_StartBug> get_page ( buf -> page ) ; <S2SV_EndBug> ",<S2SV_ModStart> bool <S2SV_ModEnd> <S2SV_ModStart> return try_get_page <S2SV_ModEnd> 
5134,"<S2SV_StartBug> r_cons_printf ( ""k<S2SV_blank>bin/pe/%s/%d=%s.%s\\n"" , <S2SV_EndBug> <S2SV_StartBug> r_cons_printf ( ""k<S2SV_blank>bin/pe/%s/%d=%s\\n"" , <S2SV_EndBug> ","<S2SV_ModStart> ""\\""k<S2SV_blank>bin/pe/%s/%d=%s.%s\\""\\n"" <S2SV_ModEnd> <S2SV_ModStart> ""\\""k<S2SV_blank>bin/pe/%s/%d=%s\\""\\n"" <S2SV_ModEnd> "
5135,"<S2SV_StartBug> ALOGE ( ""b/26366256"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; android_errorWriteLog ( 0x534e4554 , ""26366256"" "
5136,<S2SV_StartBug> cdf_secid_t maxsector = ( cdf_secid_t ) ( sat -> sat_len * size ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sid > maxsector ) { <S2SV_EndBug> ,"<S2SV_ModStart> ( <S2SV_ModStart> / sizeof ( maxsector ) ) <S2SV_ModStart> >= maxsector ) { DPRINTF ( ( ""Sector<S2SV_blank>%d<S2SV_blank>>=<S2SV_blank>%d\\n"" <S2SV_ModEnd> "
5137,<S2SV_StartBug> aio_free_ring ( ctx ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5138,<S2SV_StartBug> bool compat ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> , struct iov_iter * iter <S2SV_ModStart> iov_iter_init ( iter , rw , * iovec , * nr_segs , * len ) ; "
5139,<S2SV_StartBug> if ( IS_NOT_NULL ( Else ) ) { <S2SV_EndBug> <S2SV_StartBug> len += SIZE_OP_JUMP ; <S2SV_EndBug> ,<S2SV_ModStart> len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END ; <S2SV_ModStart>  <S2SV_ModEnd> 
5140,"<S2SV_StartBug> if ( vmx_set_msr ( vcpu , & msr ) != 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> kvm_set_msr <S2SV_ModEnd> 
5141,<S2SV_StartBug> rc = smtp_get_resp ( conn ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( conn ) ; mutt_socket_empty 
5142,"<S2SV_StartBug> signal_remove ( ""message<S2SV_blank>quit"" , ( SIGNAL_FUNC ) msg_quit ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""server<S2SV_blank>disconnected"" , ( SIGNAL_FUNC ) sig_server_disconnected ) ; signal_remove ( "
5143,"<S2SV_StartBug> static int may_create_in_sticky ( struct dentry * const dir , <S2SV_EndBug> <S2SV_StartBug> likely ( ! ( dir -> d_inode -> i_mode & S_ISVTX ) ) || <S2SV_EndBug> <S2SV_StartBug> uid_eq ( inode -> i_uid , dir -> d_inode -> i_uid ) || <S2SV_EndBug> <S2SV_StartBug> if ( likely ( dir -> d_inode -> i_mode & 0002 ) || <S2SV_EndBug> <S2SV_StartBug> ( dir -> d_inode -> i_mode & 0020 && <S2SV_EndBug> ","<S2SV_ModStart> umode_t dir_mode , kuid_t dir_uid <S2SV_ModEnd> <S2SV_ModStart> dir_mode <S2SV_ModEnd> <S2SV_ModStart> dir_uid <S2SV_ModEnd> <S2SV_ModStart> dir_mode <S2SV_ModEnd> <S2SV_ModStart> dir_mode <S2SV_ModEnd> "
5144,"<S2SV_StartBug> mptctl_fw_download ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> return mptctl_do_fw_download ( kfwdl . iocnum , kfwdl . bufp , kfwdl . fwlen ) ; <S2SV_EndBug> ","<S2SV_ModStart> MPT_ADAPTER * iocp , <S2SV_ModStart> iocp <S2SV_ModEnd> "
5145,<S2SV_StartBug> dt -> vlan_id [ 0 ] = p -> vlan_id [ 0 ] ; <S2SV_EndBug> ,<S2SV_ModStart> proto = IP_GET_IPPROTO ( p ) ; dt -> 
5146,<S2SV_StartBug> while ( collen > 0 ) <S2SV_EndBug> <S2SV_StartBug> while ( replen > 0 ) <S2SV_EndBug> <S2SV_StartBug> while ( collen > 0 ) <S2SV_EndBug> <S2SV_StartBug> while ( replen > 0 ) <S2SV_EndBug> ,<S2SV_ModStart> indexw < width && <S2SV_ModStart> indexw < width && <S2SV_ModStart> indexw < width && <S2SV_ModStart> indexw < width && 
5147,<S2SV_StartBug> void <S2SV_EndBug> <S2SV_StartBug> assert ( ( msgnum & ( msgnum - 1 ) ) == 0 && msgnum >= 1 && msgnum <= 32 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> != 0 ) || msgnum < 1 || msgnum > 32 ) { pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>msi<S2SV_blank>messages!\\n"" , __func__ ) ; return - 1 ; } <S2SV_ModEnd> <S2SV_ModStart> return 0 ; "
5148,"<S2SV_StartBug> memcpy ( & priv -> ctrl , p , sizeof ( priv -> ctrl ) ) ; <S2SV_EndBug> <S2SV_StartBug> rc = - ENOMEM ; <S2SV_EndBug> ",<S2SV_ModStart> priv -> ctrl . fname = NULL ; <S2SV_ModStart> return <S2SV_ModEnd> 
5149,"<S2SV_StartBug> ret = ca8210_get_platform_data ( priv -> spi , pdata ) ; <S2SV_EndBug> <S2SV_StartBug> ret = ca8210_dev_com_init ( priv ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ca8210_get_platform_data ( priv -> spi , pdata ) ; if ( ret ) { dev_crit ( & spi_device -> dev , ""ca8210_get_platform_data<S2SV_blank>failed\\n"" ) ; goto error ; } ret = "
5150,<S2SV_StartBug> while ( offset < end_offset ) <S2SV_EndBug> <S2SV_StartBug> return offset ; <S2SV_EndBug> ,<S2SV_ModStart> > 0 && offset <S2SV_ModStart> { <S2SV_ModStart> } 
5151,"<S2SV_StartBug> if ( libfvalue_value_type_initialize ( <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> # if defined ( HAVE_DEBUG_OUTPUT ) <S2SV_EndBug> <S2SV_StartBug> & ( record_data [ data_offset ] ) , <S2SV_EndBug> ","<S2SV_ModStart> user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( <S2SV_ModStart> if ( strings_size > ( ( record_data_size - 4 ) - strings_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } <S2SV_ModStart> if ( data_size > ( ( record_data_size - 4 ) - data_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } <S2SV_ModStart> record_data_offset <S2SV_ModEnd> "
5152,"<S2SV_StartBug> int received = recv ( slot -> fd , buf , size , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
5153,"<S2SV_StartBug> if ( strncmp ( handle -> params . realm , realm -> data , realm -> length ) == 0 <S2SV_EndBug> ","<S2SV_ModStart> success = data_eq_string ( * realm , <S2SV_ModEnd> <S2SV_ModStart> ) && data_eq_string ( * c1 , ""kadmin"" ) && ! data_eq_string ( * c2 , ""history"" ) ; <S2SV_ModEnd> "
5154,"<S2SV_StartBug> struct scatterlist sg [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> sg_init_one ( sg , buf , count ) ; <S2SV_EndBug> <S2SV_StartBug> return __send_to_port ( port , sg , 1 , count , ( void * ) buf , false ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ; void * data ; int ret <S2SV_ModStart> data = kmemdup ( buf , count , GFP_ATOMIC ) ; if ( ! data ) return - ENOMEM ; <S2SV_ModStart> data <S2SV_ModEnd> <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> data <S2SV_ModEnd> <S2SV_ModStart> kfree ( data ) ; return ret ; "
5155,<S2SV_StartBug> if ( ! encoding && c -> palette_size && c -> bpp <= 8 ) { <S2SV_EndBug> ,<S2SV_ModStart> && c -> format != CHUNKY 
5156,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> rdp -> nego -> transport -> credssp = NULL ; 
5157,<S2SV_StartBug> struct free_nid * i ; <S2SV_EndBug> <S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> if ( build ) { <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> ,"<S2SV_ModStart> , * e <S2SV_ModStart> = - EINVAL ; bool ret = false <S2SV_ModStart> i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) goto err ; spin_lock ( & nm_i -> nid_list_lock ) ; <S2SV_ModStart> goto err_out ; e = __lookup_free_nid_list ( nm_i , nid ) ; if ( e ) { if ( e -> state == NID_NEW ) ret = true ; goto err_out ; } } ret = true ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; err_out : spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; err : if ( err ) kmem_cache_free ( free_nid_slab , i ) ; return ret <S2SV_ModEnd> "
5158,<S2SV_StartBug> file_sb_list_del ( file ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5159,"<S2SV_StartBug> gdImageWBMPCtx ( im , fg , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! _gdImageWBMPCtx <S2SV_ModEnd> <S2SV_ModStart> ) { <S2SV_ModEnd> <S2SV_ModStart> } else { rv = NULL ; } 
5160,<S2SV_StartBug> if ( image_info -> ping ) <S2SV_EndBug> <S2SV_StartBug> return ( image ) ; <S2SV_EndBug> ,"<S2SV_ModStart> != MagickFalse <S2SV_ModStart> ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) "
5161,"<S2SV_StartBug> size_t l = 0 ; <S2SV_EndBug> <S2SV_StartBug> ptr += strspn ( ptr , ""\\r\\n\\t<S2SV_blank>"" ) ; <S2SV_EndBug> <S2SV_StartBug> l = strcspn ( ptr , ""\\r\\n\\t<S2SV_blank>"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> int wv , w1 , w2 , w3 , w4 ; int tmpval [ 4 ] ; int tmpcnt <S2SV_ModEnd> <S2SV_ModStart> while ( ptr < buf + len && ( * ptr == '<S2SV_blank>' || * ptr == '\\t' || * ptr == '\\n' || * ptr == '\\r' ) ) { ptr ++ ; } <S2SV_ModEnd> <S2SV_ModStart> if ( ( wv = base64_table [ ( int ) ( unsigned char ) * ptr ++ ] ) == - 1 ) { continue ; } tmpval [ tmpcnt ++ ] = wv ; if ( tmpcnt == 4 ) { tmpcnt = 0 ; w1 = tmpval [ 0 ] ; w2 = tmpval [ 1 ] ; w3 = tmpval [ 2 ] ; w4 = tmpval [ 3 ] ; if ( w2 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w1 << 2 ) + ( w2 >> 4 ) ) & 0xFF ) ; } if ( w3 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w2 << 4 ) + ( w3 >> 2 ) ) & 0xFF ) ; } if ( w4 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w3 << 6 ) + w4 ) & 0xFF ) ; } <S2SV_ModEnd> "
5162,<S2SV_StartBug> return tmp ; <S2SV_EndBug> <S2SV_StartBug> return tmp ; <S2SV_EndBug> <S2SV_StartBug> return state -> ptr = tmp ; <S2SV_EndBug> ,<S2SV_ModStart> goto softfail <S2SV_ModEnd> <S2SV_ModStart> goto softfail <S2SV_ModEnd> <S2SV_ModStart> softfail : state -> offset = 0 ; 
5163,"<S2SV_StartBug> ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;"" <S2SV_EndBug> <S2SV_StartBug> return APR_ENOSPC ; <S2SV_EndBug> <S2SV_StartBug> if ( rv != APR_SUCCESS ) { <S2SV_EndBug> <S2SV_StartBug> case BODY_CHUNK_END : { <S2SV_EndBug> <S2SV_StartBug> int merge_trailers = <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ","<S2SV_ModStart> ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;<S2SV_blank>"" ""using<S2SV_blank>read-until-close"" <S2SV_ModEnd> <S2SV_ModStart> APR_EINVAL <S2SV_ModEnd> <S2SV_ModStart> apr_brigade_cleanup ( bb ) ; <S2SV_ModStart> BODY_CHUNK_LF : case BODY_CHUNK_END : case BODY_CHUNK_END_LF <S2SV_ModEnd> <S2SV_ModStart> return read_chunked_trailers ( ctx , f , b , conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE <S2SV_ModEnd> <S2SV_ModStart> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , f -> r , APLOGNO ( 02901 ) ""Unexpected<S2SV_blank>body<S2SV_blank>state<S2SV_blank>(%i)"" , ( int ) ctx -> state ) ; return APR_EGENERAL <S2SV_ModEnd> "
5164,"
","
"
5165,"<S2SV_StartBug> memcpy ( name , fp + n , name_len ) ; n += name_len ; <S2SV_EndBug> <S2SV_StartBug> attr_len = fp [ n ++ ] ; <S2SV_EndBug> ","<S2SV_ModStart> IRDA_ASSERT ( name_len < IAS_MAX_CLASSNAME + 1 , return ; ) ; <S2SV_ModStart> ; IRDA_ASSERT ( attr_len < IAS_MAX_ATTRIBNAME + 1 , return ; ) "
5166,<S2SV_StartBug> if ( errcode != 0 ) <S2SV_EndBug> ,"<S2SV_ModStart> && state -> status == NULL ) state -> status = ""UNKNOWN_REASON"" <S2SV_ModEnd> "
5167,<S2SV_StartBug> if ( ret == - EEXIST ) <S2SV_EndBug> ,<S2SV_ModStart> || ret == - EOVERFLOW 
5168,"<S2SV_StartBug> static void fadst8 ( const int16_t * input , int16_t * output ) { <S2SV_EndBug> <S2SV_StartBug> int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; <S2SV_EndBug> <S2SV_StartBug> int x1 = input [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> int x2 = input [ 5 ] ; <S2SV_EndBug> <S2SV_StartBug> int x3 = input [ 2 ] ; <S2SV_EndBug> <S2SV_StartBug> int x4 = input [ 3 ] ; <S2SV_EndBug> <S2SV_StartBug> int x5 = input [ 4 ] ; <S2SV_EndBug> <S2SV_StartBug> int x6 = input [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> int x7 = input [ 6 ] ; <S2SV_EndBug> <S2SV_StartBug> output [ 0 ] = x0 ; <S2SV_EndBug> <S2SV_StartBug> output [ 1 ] = - x4 ; <S2SV_EndBug> <S2SV_StartBug> output [ 2 ] = x6 ; <S2SV_EndBug> <S2SV_StartBug> output [ 3 ] = - x2 ; <S2SV_EndBug> <S2SV_StartBug> output [ 4 ] = x3 ; <S2SV_EndBug> <S2SV_StartBug> output [ 5 ] = - x7 ; <S2SV_EndBug> <S2SV_StartBug> output [ 6 ] = x5 ; <S2SV_EndBug> <S2SV_StartBug> output [ 7 ] = - x1 ; <S2SV_EndBug> ","<S2SV_ModStart> tran_low_t * input , tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) "
5169,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % ( bps * stride ) ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""fpDiff"" , ""%s"" , ""(cc%(bps*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModStart> return 1 ; "
5170,<S2SV_StartBug> if ( dataSize > MAX_DLS_WAVE_SIZE ) <S2SV_EndBug> ,<S2SV_ModStart> dataSize < 0 || 
5171,"<S2SV_StartBug> char * bufp , * commentp , * altp ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( strlen ( buf ) >= BUFSZ ) buf [ BUFSZ - 1 ] = '\\0' 
5172,"<S2SV_StartBug> int ctrl_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> pbi ) <S2SV_EndBug> <S2SV_StartBug> * corrupted = ctx -> pbi -> common . frame_to_show -> corrupted ; <S2SV_EndBug> <S2SV_StartBug> return VPX_CODEC_INVALID_PARAM ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> frame_workers ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; RefCntBuffer * const frame_bufs = frame_worker_data -> pbi -> common . buffer_pool -> frame_bufs ; if ( frame_worker_data <S2SV_ModEnd> <S2SV_ModStart> == NULL ) return VPX_CODEC_ERROR ; if ( ctx -> last_show_frame >= 0 ) * corrupted = frame_bufs [ ctx -> last_show_frame ] . buf . corrupted <S2SV_ModEnd> <S2SV_ModStart> VPX_CODEC_ERROR <S2SV_ModEnd> <S2SV_ModStart> return VPX_CODEC_INVALID_PARAM ; } 
5173,"<S2SV_StartBug> char * name , int rep_quick ) <S2SV_EndBug> <S2SV_StartBug> mysql_file_close ( new_file , MYF ( 0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( param -> testflag & T_BACKUP_DATA ? <S2SV_EndBug> ","<S2SV_ModStart> , my_bool no_copy_stat <S2SV_ModStart> myf flags = 0 ; if ( param -> testflag & T_BACKUP_DATA ) flags |= MY_REDEL_MAKE_BACKUP ; if ( no_copy_stat ) flags |= MY_REDEL_NO_COPY_STAT ; <S2SV_ModStart> flags <S2SV_ModEnd> "
5174,<S2SV_StartBug> # ifdef HAVE_OPENSSL <S2SV_EndBug> ,<S2SV_ModStart> SSL_SET_OPTIONS ( & mysql_connection ) ; <S2SV_ModEnd> 
5175,"<S2SV_StartBug> av_log ( mxf , AV_LOG_TRACE , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> -> fc 
5176,<S2SV_StartBug> assert ( ops != NULL ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! ops ) { pr_warn ( ""No<S2SV_blank>driver<S2SV_blank>for<S2SV_blank>device<S2SV_blank>[%s]\\n"" , fi -> fi_name ) ; continue ; } <S2SV_ModEnd> "
5177,<S2SV_StartBug> ut8 opcode = * ( p4 ++ ) & 0xff ; <S2SV_EndBug> ,<S2SV_ModStart> if ( p4 <= 0 ) { return ; } 
5178,"<S2SV_StartBug> change = ue -> tlv_data_size != size ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> return - ENXIO ; <S2SV_EndBug> <S2SV_StartBug> if ( size < ue -> tlv_data_size ) <S2SV_EndBug> <S2SV_StartBug> return - ENOSPC ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_to_user ( tlv , ue -> tlv_data , ue -> tlv_data_size ) ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> mutex_unlock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> int ret = 0 ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto err_unlock ; } <S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto err_unlock ; } <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> err_unlock : mutex_unlock ( & ue -> card -> user_ctl_lock ) ; if ( ret ) return ret ; 
5179,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> usb_conv_info -> class_data_type = USB_CONV_MASS_STORAGE ; } else if ( usb_conv_info -> class_data_type != USB_CONV_MASS_STORAGE ) { return 0 ; 
5180,"<S2SV_StartBug> ND_TCHECK2 ( dp [ 0 ] , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5181,"<S2SV_StartBug> static void encode_b ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int output_enabled , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> update_state ( cpi , get_block_context ( x , bsize ) , mi_row , mi_col , bsize , <S2SV_EndBug> <S2SV_StartBug> encode_superblock ( cpi , tp , output_enabled , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> update_stats ( cpi ) ; <S2SV_EndBug> ","<S2SV_ModStart> , ThreadData * td <S2SV_ModStart> , PICK_MODE_CONTEXT * ctx <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , x <S2SV_ModStart> td , ctx <S2SV_ModEnd> <S2SV_ModStart> , td <S2SV_ModStart> , ctx <S2SV_ModStart> & cpi -> common , td <S2SV_ModEnd> "
5182,"<S2SV_StartBug> if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { <S2SV_EndBug> ","<S2SV_ModStart> memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnotePentaxEntry ) ) ; "
5183,<S2SV_StartBug> if ( ! object || object -> list . length != 2 || ! object -> list . objects [ 0 ] || object -> list . objects [ 1 ] -> list . length != 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> || ! object -> list . objects [ 0 ] || ! object -> list . objects [ 1 ] || <S2SV_ModEnd> 
5184,<S2SV_StartBug> struct task_struct * task = current ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5185,"<S2SV_StartBug> unsigned int ds , unsigned int offset , unsigned int recursion_depth ) <S2SV_EndBug> <S2SV_StartBug> if ( recursion_depth > 12 ) { <S2SV_EndBug> <S2SV_StartBug> ""Deep<S2SV_blank>recursion<S2SV_blank>detected!"" ) ; <S2SV_EndBug> <S2SV_StartBug> exif_data_load_data_content ( data , EXIF_IFD_EXIF , d , ds , o , recursion_depth + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> exif_data_load_data_content ( data , EXIF_IFD_GPS , d , ds , o , recursion_depth + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> exif_data_load_data_content ( data , EXIF_IFD_INTEROPERABILITY , d , ds , o , recursion_depth + 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> recursion_cost <S2SV_ModEnd> <S2SV_ModStart> recursion_cost > 170 <S2SV_ModEnd> <S2SV_ModStart> ""Deep/expensive<S2SV_blank>recursion<S2SV_blank>detected!"" <S2SV_ModEnd> <S2SV_ModStart> recursion_cost + level_cost ( n ) <S2SV_ModEnd> <S2SV_ModStart> recursion_cost + level_cost ( n ) <S2SV_ModEnd> <S2SV_ModStart> recursion_cost + level_cost ( n ) <S2SV_ModEnd> "
5186,"<S2SV_StartBug> int n ; <S2SV_EndBug> <S2SV_StartBug> long newbufsize ; <S2SV_EndBug> <S2SV_StartBug> newbufsize <<= 1 ; <S2SV_EndBug> <S2SV_StartBug> JAS_DBGLOG ( 100 , ( ""mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%z\\n"" , m -> bufsize_ , <S2SV_EndBug> <S2SV_StartBug> if ( m -> pos_ > m -> len_ ) { <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t newbufsize ; size_t <S2SV_ModEnd> <S2SV_ModStart> if ( ! jas_safe_size_mul ( newbufsize , 2 , & newbufsize ) ) { <S2SV_ModEnd> <S2SV_ModStart> ""new<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>would<S2SV_blank>cause<S2SV_blank>overflow\\n"" ) ) ; <S2SV_ModEnd> <S2SV_ModStart> JAS_DBGLOG ( 100 , ( ""mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%zu\\n"" , m -> bufsize_ , newbufsize ) ) ; assert ( newbufsize > 0 ) ; if ( mem_resize ( m , newbufsize ) ) { return - 1 ; } } "
5187,<S2SV_StartBug> down_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ; <S2SV_EndBug> ,"<S2SV_ModStart> error = btrfs_check_dir_item_collision ( BTRFS_I ( dir ) -> root , dir -> i_ino , name , namelen ) ; if ( error ) goto out_dput ; "
5188,<S2SV_StartBug> dst [ y * linesize + x ] = clr ; <S2SV_EndBug> ,<S2SV_ModStart> if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ; 
5189,<S2SV_StartBug> int bind_ports ( void ) { <S2SV_EndBug> ,<S2SV_ModStart> NOEXPORT 
5190,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( length <= 0 ) return ; 
5191,<S2SV_StartBug> const int kBufferFrameCount = 65536 ; <S2SV_EndBug> <S2SV_StartBug> void * buffer = malloc ( kBufferFrameCount * frameSize ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; int bufferSize ; while ( multiplyCheckOverflow ( kBufferFrameCount , frameSize , & bufferSize ) ) kBufferFrameCount /= 2 <S2SV_ModStart> bufferSize <S2SV_ModEnd> "
5192,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> new_fpl -> user = get_uid ( fpl -> user ) ; 
5193,"<S2SV_StartBug> vpx_memset ( dst -> y_buffer + i * dst -> y_stride + dw - 1 , dst -> y_buffer [ i * dst -> y_stride + dw - 2 ] , dst -> y_width - dw + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst -> y_buffer + i * dst -> y_stride , dst -> y_buffer + ( dh - 2 ) * dst -> y_stride , dst -> y_width + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( dst -> u_buffer + i * dst -> uv_stride + dw / 2 - 1 , dst -> u_buffer [ i * dst -> uv_stride + dw / 2 - 2 ] , dst -> uv_width - dw / 2 + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst -> u_buffer + i * dst -> uv_stride , dst -> u_buffer + ( dh / 2 - 2 ) * dst -> uv_stride , dst -> uv_width ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( dst -> v_buffer + i * dst -> uv_stride + dw / 2 - 1 , dst -> v_buffer [ i * dst -> uv_stride + dw / 2 - 2 ] , dst -> uv_width - dw / 2 + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst -> v_buffer + i * dst -> uv_stride , dst -> v_buffer + ( dh / 2 - 2 ) * dst -> uv_stride , dst -> uv_width ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
5194,"<S2SV_StartBug> if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> apply_printer_defaults ( printer , job ) ; <S2SV_EndBug> ","<S2SV_ModStart> attr = ippFindAttribute ( con -> request , ""requesting-user-name"" , IPP_TAG_NAME ) ; if ( attr && ! ippValidateAttribute ( attr ) ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Bad<S2SV_blank>requesting-user-name<S2SV_blank>value:<S2SV_blank>%s"" ) , cupsLastErrorString ( ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } <S2SV_ModStart>  <S2SV_ModEnd> "
5195,<S2SV_StartBug> struct dentry * dentry = path -> dentry ; <S2SV_EndBug> <S2SV_StartBug> struct inode * inode = dentry -> d_inode ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vfs_select_inode ( path -> <S2SV_ModEnd> <S2SV_ModStart> file -> f_path = * path ; <S2SV_ModEnd> 
5196,"<S2SV_StartBug> static inline bool unconditional ( const struct ip6t_ip6 * ipv6 ) <S2SV_EndBug> <S2SV_StartBug> return memcmp ( ipv6 , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug> ",<S2SV_ModStart> ip6t_entry * e <S2SV_ModEnd> <S2SV_ModStart> e -> target_offset == sizeof ( struct ip6t_entry ) && memcmp ( & e -> <S2SV_ModEnd> 
5197,<S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug> ,<S2SV_ModStart> kfree_skb ( skb ) ; 
5198,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> indx , & data , 1 , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> u8 * buf ; int ret ; buf = kmemdup ( & data , 1 , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> kfree ( buf ) ; "
5199,<S2SV_StartBug> static gboolean <S2SV_EndBug> <S2SV_StartBug> ice_conn -> context = client ; <S2SV_EndBug> ,"<S2SV_ModStart> typedef struct { guint watch_id ; guint protocol_timeout ; } GsmIceConnectionWatch ; static void disconnect_ice_connection ( IceConn ice_conn ) { IceSetShutdownNegotiation ( ice_conn , FALSE ) ; IceCloseConnection <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5200,<S2SV_StartBug> tp -> prr_delivered += newly_acked_sacked ; <S2SV_EndBug> ,<S2SV_ModStart> if ( newly_acked_sacked <= 0 || WARN_ON_ONCE ( ! tp -> prior_cwnd ) ) return ; 
5201,"<S2SV_StartBug> ND_TCHECK ( bp [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK ( bp [ 4 ] ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( bp [ 4 ] & 0x3 ) { <S2SV_EndBug> <S2SV_StartBug> if ( bp [ 4 ] & 0xfc ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[rsvd=0x%02x]"" , bp [ 4 ] & 0xfc ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK ( bp [ 5 ] ) ; <S2SV_EndBug> <S2SV_StartBug> nentries = bp [ 5 ] ; <S2SV_EndBug> <S2SV_StartBug> bp += 6 ; len -= 6 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , 6 ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( len < 8 ) goto trunc ; <S2SV_ModStart> if ( len < 4 ) goto trunc ; <S2SV_ModStart> bp += 4 ; len -= 4 ; if ( len < 1 ) goto trunc ; <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> bp += 1 ; len -= 1 ; if ( len < 1 ) goto trunc ; <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> 1 ; len -= 1 <S2SV_ModEnd> <S2SV_ModStart> if ( len < 6 ) goto trunc ; 
5202,<S2SV_StartBug> if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; <S2SV_EndBug> ,<S2SV_ModStart> || num >= 256 
5203,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> jmp_rel ( ctxt , rel ) ; <S2SV_EndBug> ",<S2SV_ModStart> int rc ; <S2SV_ModStart> rc = <S2SV_ModStart> ; if ( rc != X86EMUL_CONTINUE ) return rc 
5204,<S2SV_StartBug> calldata -> arg . open_flags = FMODE_READ ; <S2SV_EndBug> <S2SV_StartBug> calldata -> arg . open_flags = FMODE_WRITE ; <S2SV_EndBug> ,<S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> 
5205,<S2SV_StartBug> int nBytes = sizeof ( sqlite3_vtab * ) * ( db -> nVTrans + ARRAY_INCR ) ; <S2SV_EndBug> ,<S2SV_ModStart> sqlite3_int64 <S2SV_ModEnd> <S2SV_ModStart> ( sqlite3_int64 ) 
5206,<S2SV_StartBug> static void follow_dotdot ( struct nameidata * nd ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ; <S2SV_ModStart> return 0 ; 
5207,<S2SV_StartBug> update_db_bp_intercept ( vcpu ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5208,<S2SV_StartBug> nd -> last_type = LAST_BIND ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5209,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> tcp_rcv_space_adjust ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } tp -> copied_seq = seq ; 
5210,"<S2SV_StartBug> if ( ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , index_key ) ) { <S2SV_EndBug> ",<S2SV_ModStart> assoc_array_ptr_is_leaf ( ptr ) && 
5211,<S2SV_StartBug> if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) { <S2SV_EndBug> ,<S2SV_ModStart> } else if ( warn_script_unsaved && fv -> script_unsaved && AskScriptChanged ( ) == 2 ) { return false ; 
5212,<S2SV_StartBug> conn -> sasl_username = ircnet -> sasl_username ; <S2SV_EndBug> ,<S2SV_ModStart> g_strdup ( ircnet -> sasl_username ) ; conn -> sasl_password = g_strdup ( ircnet -> sasl_password ) <S2SV_ModEnd> 
5213,"<S2SV_StartBug> request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( buf2 ) <S2SV_ModStart> , sizeof ( buf2 ) "
5214,<S2SV_StartBug> void * dllhandle ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( COM_CompareExtension ( name , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , name ) ; return NULL ; } "
5215,<S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY "
5216,<S2SV_StartBug> char * prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; <S2SV_EndBug> ,"<S2SV_ModStart> prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total"" , ( int ) dff_chunk_header . ckDataSize ) ; "
5217,"<S2SV_StartBug> vp9_lpf_horizontal_16 ( s , pitch , lfi -> mblim , lfi -> lim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_horizontal_16 ( s , pitch , lfi -> mblim , lfi -> lim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_horizontal_8_dual ( s , pitch , lfi -> mblim , lfi -> lim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_horizontal_4 ( s + 8 + 4 * pitch , pitch , lfin -> mblim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_horizontal_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_horizontal_4_dual ( s , pitch , lfi -> mblim , lfi -> lim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_horizontal_4 ( s + 8 + 4 * pitch , pitch , lfin -> mblim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_horizontal_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_lpf_horizontal_16 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_horizontal_16 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_horizontal_8_dual <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; } else { if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_horizontal_4 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_horizontal_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_horizontal_4_dual <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; } else { if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_horizontal_4 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_horizontal_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } else if ( mask_4x4_int & 1 ) { vpx_lpf_horizontal_4 <S2SV_ModEnd> "
5218,"<S2SV_StartBug> return perf_read_hw ( event , buf , count ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> struct perf_event_context * ctx ; int ret ; ctx = perf_event_ctx_lock ( event ) ; ret = <S2SV_ModEnd> <S2SV_ModStart> perf_event_ctx_unlock ( event , ctx ) ; return ret ; "
5219,<S2SV_StartBug> return SQLITE_NOMEM ; <S2SV_EndBug> <S2SV_StartBug> return rc ; <S2SV_EndBug> ,"<S2SV_ModStart> sqlite3ErrorToParser ( db , SQLITE_NOMEM ) <S2SV_ModEnd> <S2SV_ModStart> if ( rc && pParse -> nErr == 0 ) { assert ( pParse -> db -> mallocFailed ) ; return sqlite3ErrorToParser ( pParse -> db , SQLITE_NOMEM ) ; } "
5220,"<S2SV_StartBug> vpx_codec_ctx_t codec [ NUM_ENCODERS ] ; <S2SV_EndBug> <S2SV_StartBug> vpx_codec_pts_t frame_cnt = 0 ; <S2SV_EndBug> <S2SV_StartBug> int frame_avail ; <S2SV_EndBug> <S2SV_StartBug> int arg_deadline = VPX_DL_REALTIME ; <S2SV_EndBug> <S2SV_StartBug> uint64_t psnr_sse_total [ NUM_ENCODERS ] = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> int psnr_count [ NUM_ENCODERS ] = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> if ( argc != ( 5 + NUM_ENCODERS ) ) <S2SV_EndBug> <S2SV_StartBug> die ( ""Usage:<S2SV_blank>%s<S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile(s)><S2SV_blank><output<S2SV_blank>psnr?>\\n"" , <S2SV_EndBug> <S2SV_StartBug> height = strtol ( argv [ 2 ] , NULL , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( infile = fopen ( argv [ 3 ] , ""rb"" ) ) ) <S2SV_EndBug> <S2SV_StartBug> die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading"" , argv [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( outfile [ i ] = fopen ( argv [ i + 4 ] , ""wb"" ) ) ) <S2SV_EndBug> <S2SV_StartBug> show_psnr = strtol ( argv [ NUM_ENCODERS + 4 ] , NULL , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> res [ i ] = vpx_codec_enc_config_default ( interface , & cfg [ i ] , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> cfg [ 0 ] . g_threads = 1 ; <S2SV_EndBug> <S2SV_StartBug> cfg [ 0 ] . rc_min_quantizer = 4 ; <S2SV_EndBug> <S2SV_StartBug> cfg [ 0 ] . rc_undershoot_pct = 98 ; <S2SV_EndBug> <S2SV_StartBug> cfg [ 0 ] . rc_overshoot_pct = 100 ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & cfg [ i ] , & cfg [ 0 ] , sizeof ( vpx_codec_enc_cfg_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> write_ivf_file_header ( outfile [ i ] , & cfg [ i ] , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_CPUUSED , speed ) ) <S2SV_EndBug> <S2SV_StartBug> die_codec ( & codec [ i ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>cpu_used"" ) ; <S2SV_EndBug> <S2SV_StartBug> unsigned int static_thresh = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_STATIC_THRESHOLD , static_thresh ) ) <S2SV_EndBug> <S2SV_StartBug> die_codec ( & codec [ i ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>static<S2SV_blank>threshold"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> frame_cnt , 1 , flags , arg_deadline ) ) <S2SV_EndBug> <S2SV_StartBug> die_codec ( & codec [ 0 ] , ""Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame"" ) ; <S2SV_EndBug> <S2SV_StartBug> && ( pkt [ i ] -> data . frame . flags & VPX_FRAME_IS_KEY ) ? ""K"" : ""."" ) ; <S2SV_EndBug> <S2SV_StartBug> printf ( ""\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> FILE * downsampled_input [ NUM_ENCODERS - 1 ] ; char filename [ 50 ] ; <S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> length_frame ; int <S2SV_ModStart> layer_id = 0 ; int layer_flags [ VPX_TS_MAX_PERIODICITY * NUM_ENCODERS ] = { 0 } ; int flag_periodicity ; int <S2SV_ModStart> int key_frame_insert = 0 ; <S2SV_ModStart> ; double cx_time = 0 ; struct timeval tv1 , tv2 , difftv <S2SV_ModStart> unsigned int num_temporal_layers [ NUM_ENCODERS ] = { 3 , 3 , 3 } ; <S2SV_ModStart> 7 + 3 * <S2SV_ModEnd> <S2SV_ModStart> ""Usage:<S2SV_blank>%s<S2SV_blank><width><S2SV_blank><height><S2SV_blank><frame_rate><S2SV_blank><S2SV_blank><infile><S2SV_blank><outfile(s)><S2SV_blank>"" ""<rate_encoder(s)><S2SV_blank><temporal_layer(s)><S2SV_blank><key_frame_insert><S2SV_blank><output<S2SV_blank>psnr?><S2SV_blank>\\n"" <S2SV_ModEnd> <S2SV_ModStart> ] , NULL , 0 ) ; framerate = strtol ( argv [ 3 <S2SV_ModStart> 4 <S2SV_ModEnd> <S2SV_ModStart> 4 <S2SV_ModEnd> <S2SV_ModStart> 5 <S2SV_ModEnd> <S2SV_ModStart> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { target_bitrate [ i ] <S2SV_ModEnd> <S2SV_ModStart> 5 + i <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> num_temporal_layers [ i ] = strtol ( argv [ 2 * NUM_ENCODERS + 5 + i ] , NULL , 0 ) ; if ( num_temporal_layers [ i ] < 1 || num_temporal_layers [ i ] > 3 ) die ( ""Invalid<S2SV_blank>temporal<S2SV_blank>layers:<S2SV_blank>%d,<S2SV_blank>Must<S2SV_blank>be<S2SV_blank>1,<S2SV_blank>2,<S2SV_blank>or<S2SV_blank>3.<S2SV_blank>\\n"" , num_temporal_layers ) ; } for ( i = 0 ; i < NUM_ENCODERS - 1 ; i ++ ) { if ( sprintf ( filename , ""ds%d.yuv"" , NUM_ENCODERS - i ) < 0 ) { <S2SV_ModEnd> <S2SV_ModStart> downsampled_input [ i ] = fopen ( filename , ""wb"" ) ; } key_frame_insert = strtol ( argv [ 3 * NUM_ENCODERS + 5 ] , NULL , 0 ) ; show_psnr = strtol ( argv [ 3 * NUM_ENCODERS + 6 ] , NULL , 0 ) ; for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { res [ i ] = vpx_codec_enc_config_default ( interface , & cfg [ i ] , 0 ) ; if ( res [ i ] ) { printf ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>config:<S2SV_blank>%s\\n"" , vpx_codec_err_to_string ( res [ i ] ) ) ; return EXIT_FAILURE ; } <S2SV_ModStart> rc_dropframe_thresh = 0 <S2SV_ModEnd> <S2SV_ModStart> 2 <S2SV_ModEnd> <S2SV_ModStart> 100 <S2SV_ModEnd> <S2SV_ModStart> 15 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cfg [ 0 ] . g_threads = 2 ; cfg [ 1 ] . g_threads = 1 ; cfg [ 2 ] . g_threads = 1 ; <S2SV_ModStart> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { set_temporal_layer_pattern ( num_temporal_layers [ i ] , & cfg [ i ] , cfg [ i ] . rc_target_bitrate , & layer_flags [ i * VPX_TS_MAX_PERIODICITY ] ) ; } <S2SV_ModStart> i == NUM_ENCODERS - 1 ) speed = - 4 ; if ( <S2SV_ModStart> ) ; } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_STATIC_THRESHOLD , 1 ) ) die_codec ( & codec [ i ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>static<S2SV_blank>threshold"" ) ; } if ( vpx_codec_control ( & codec [ 0 ] , VP8E_SET_NOISE_SENSITIVITY , 1 ) ) die_codec ( & codec [ 0 ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>noise_sensitivity"" ) ; for ( i = 1 ; i < NUM_ENCODERS ; i ++ ) { if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_NOISE_SENSITIVITY , 0 ) ) die_codec ( & codec [ i ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>noise_sensitivity"" ) ; } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_TOKEN_PARTITIONS , 1 ) ) die_codec ( & codec [ i ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>static<S2SV_blank>threshold"" <S2SV_ModStart> max_intra_size_pct = ( int ) ( ( ( double ) cfg [ 0 ] . rc_buf_optimal_sz * 0.5 ) * framerate / 10 ) <S2SV_ModEnd> <S2SV_ModStart> VP8E_SET_MAX_INTRA_BITRATE_PCT , max_intra_size_pct <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> length_frame = cfg [ i ] . g_w * cfg [ i ] . g_h * 3 / 2 ; if ( fwrite ( raw [ i ] . planes [ 0 ] , 1 , length_frame , downsampled_input [ NUM_ENCODERS - i - 1 ] ) != length_frame ) { return EXIT_FAILURE ; } } } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { layer_id = cfg [ i ] . ts_layer_id [ frame_cnt % cfg [ i ] . ts_periodicity ] ; flags = 0 ; flag_periodicity = periodicity_to_num_layers [ num_temporal_layers [ i ] - 1 ] ; flags = layer_flags [ i * VPX_TS_MAX_PERIODICITY + frame_cnt % flag_periodicity ] ; if ( frame_cnt == 0 ) { flags |= VPX_EFLAG_FORCE_KF ; } if ( frame_cnt > 0 && frame_cnt == key_frame_insert ) { flags = VPX_EFLAG_FORCE_KF ; } vpx_codec_control ( & codec [ i ] , VP8E_SET_FRAME_FLAGS , flags ) ; vpx_codec_control ( & codec [ i ] , VP8E_SET_TEMPORAL_LAYER_ID , layer_id ) ; } gettimeofday ( & tv1 , NULL ) ; <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> ) ; } gettimeofday ( & tv2 , NULL ) ; timersub ( & tv2 , & tv1 , & difftv ) ; cx_time += ( double ) ( difftv . tv_sec * 1000000 + difftv . tv_usec <S2SV_ModStart> """" <S2SV_ModEnd> <S2SV_ModStart> ) ; printf ( ""FPS<S2SV_blank>for<S2SV_blank>encoding<S2SV_blank>%d<S2SV_blank>%f<S2SV_blank>%f<S2SV_blank>\\n"" , frame_cnt , ( float ) cx_time / 1000000 , 1000000 * ( double ) frame_cnt / ( double ) cx_time "
5221,"<S2SV_StartBug> int i , retval ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ",<S2SV_ModStart> test_parser_param ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5222,"<S2SV_StartBug> in_uint16_le ( s , length ) ; <S2SV_EndBug> <S2SV_StartBug> in_uint8 ( s , type ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct stream packet = * s ; <S2SV_ModStart> if ( ! s_check_rem ( s , length + 7 ) ) { rdp_protocol_error ( ""process_secondary_order(),<S2SV_blank>next<S2SV_blank>order<S2SV_blank>pointer<S2SV_blank>would<S2SV_blank>overrun<S2SV_blank>stream"" , & packet ) ; } "
5223,"<S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; <S2SV_EndBug> <S2SV_StartBug> pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , <S2SV_EndBug> <S2SV_StartBug> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> ","<S2SV_ModStart> rows ; rows = MagickMax ( GetImageListLength ( images ) , <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> rows , <S2SV_ModEnd> <S2SV_ModStart> columns = MaxPixelChannels ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 <S2SV_ModEnd> <S2SV_ModStart> rows <S2SV_ModEnd> "
5224,<S2SV_StartBug> conn -> c_trans = trans ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( trans == NULL ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( - ENODEV ) ; goto out ; } "
5225,<S2SV_StartBug> ni6 = ( const struct icmp6_nodeinfo * ) dp ; <S2SV_EndBug> <S2SV_StartBug> cp = ( const u_char * ) ( ni6 + 1 ) + 4 ; <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; <S2SV_ModStart> ; ND_TCHECK ( cp [ 0 ] ) "
5226,<S2SV_StartBug> Py_ssize_t new_memo_size = 0 ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < new_memo_size ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> i = new_memo_size ; <S2SV_EndBug> ,<S2SV_ModStart> size_t new_memo_size = 0 <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModStart> for ( size_t i = new_memo_size - 1 ; i != SIZE_MAX ; i -- <S2SV_ModEnd> 
5227,"<S2SV_StartBug> cJSON_AddIntToObject ( j , ""omit"" , test -> omit ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddIntToObject ( j , ""server_affinity"" , test -> server_affinity ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddStringToObject ( j , ""title"" , test -> title ) ; <S2SV_EndBug> ","<S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> <S2SV_ModStart> cJSON_AddNumberToObject ( j , ""server_affinity"" , test -> server_affinity ) ; if ( test -> duration ) cJSON_AddNumberToObject ( j , ""time"" , test -> duration ) ; if ( test -> settings -> bytes ) cJSON_AddNumberToObject ( j , ""num"" , test -> settings -> bytes ) ; if ( test -> settings -> blocks ) cJSON_AddNumberToObject ( j , ""blockcount"" , test -> settings -> blocks ) ; if ( test -> settings -> mss ) cJSON_AddNumberToObject ( j , ""MSS"" , test -> settings -> mss ) ; if ( test -> no_delay ) cJSON_AddTrueToObject ( j , ""nodelay"" ) ; cJSON_AddNumberToObject ( j , ""parallel"" , test -> num_streams ) ; if ( test -> reverse ) cJSON_AddTrueToObject ( j , ""reverse"" ) ; if ( test -> settings -> socket_bufsize ) cJSON_AddNumberToObject ( j , ""window"" , test -> settings -> socket_bufsize ) ; if ( test -> settings -> blksize ) cJSON_AddNumberToObject ( j , ""len"" , test -> settings -> blksize ) ; if ( test -> settings -> rate ) cJSON_AddNumberToObject ( j , ""bandwidth"" , test -> settings -> rate ) ; if ( test -> settings -> burst ) cJSON_AddNumberToObject ( j , ""burst"" , test -> settings -> burst ) ; if ( test -> settings -> tos ) cJSON_AddNumberToObject ( j , ""TOS"" , test -> settings -> tos ) ; if ( test -> settings -> flowlabel ) cJSON_AddNumberToObject ( j , ""flowlabel"" , test -> settings -> flowlabel ) ; if ( test -> title ) cJSON_AddStringToObject ( j , ""title"" , test -> title ) ; if ( test -> congestion ) cJSON_AddStringToObject ( j , ""congestion"" , test -> congestion ) ; if ( test -> get_server_output ) << << << < HEAD <S2SV_ModStart> ""get_server_output"" , iperf_get_test_get_server_output ( test ) ) ; == == == = cJSON_AddNumberToObject ( j , ""get_server_output"" , iperf_get_test_get_server_output ( test ) ) ; if ( test -> udp_counters_64bit ) cJSON_AddNumberToObject ( j , ""udp_counters_64bit"" , iperf_get_test_udp_counters_64bit ( test ) ) ; if ( test -> no_fq_socket_pacing ) cJSON_AddNumberToObject ( j , ""no_fq_socket_pacing"" , iperf_get_no_fq_socket_pacing ( test ) ) ; <S2SV_ModEnd> <S2SV_ModStart> ""client_version"" , IPERF_VERSION ) ; >> >> >> > ed94082 ... Fix a buffer overflow / heap corruption issue that could occur if a <S2SV_ModEnd> "
5228,"<S2SV_StartBug> if ( timeri -> master ) <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & slave_active_lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> && timeri -> timer ) { spin_lock ( & timeri -> timer -> lock ) ; <S2SV_ModEnd> <S2SV_ModStart> spin_unlock ( & timeri -> timer -> lock ) ; } 
5229,<S2SV_StartBug> spin_lock_irq ( & tu -> qlock ) ; <S2SV_EndBug> <S2SV_StartBug> schedule ( ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> <S2SV_StartBug> return result > 0 ? result : err ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_ModStart> mutex_unlock ( & tu -> ioctl_lock ) ; schedule ( ) ; mutex_lock ( & tu -> ioctl_lock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & tu -> ioctl_lock ) ; 
5230,<S2SV_StartBug> ( target -> doc -> dict == ctxt -> dict ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> && xmlDictOwns ( ctxt -> dict , value ) "
5231,"<S2SV_StartBug> return send ( ts [ thread_handle ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
5232,"<S2SV_StartBug> if ( sock -> ops ) { <S2SV_EndBug> <S2SV_StartBug> if ( rcu_dereference_protected ( sock -> wq , 1 ) -> fasync_list ) <S2SV_EndBug> ","<S2SV_ModStart> __sock_release ( sock , NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5233,"<S2SV_StartBug> return g_NPN_GetValue_real ( instance , variable , value ) ; <S2SV_EndBug> ",<S2SV_ModStart> case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling : 
5234,<S2SV_StartBug> ps_dec -> u2_total_mbs_coded ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( u1_tfr_n_mb ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ps_dec -> u2_total_mbs_coded += u1_num_mbs ; 
5235,"<S2SV_StartBug> memcpy ( new , ours , sizeof ( * new ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ) ; memset ( dte , 0 , sizeof ( * dte "
5236,"<S2SV_StartBug> c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * 3 
5237,<S2SV_StartBug> ) { <S2SV_EndBug> ,<S2SV_ModStart> && p -> pWin == 0 
5238,<S2SV_StartBug> c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , ""cblk<S2SV_blank>size<S2SV_blank>><S2SV_blank>64"" ) ; return AVERROR_PATCHWELCOME ; } "
5239,<S2SV_StartBug> kfree ( fpl ) ; <S2SV_EndBug> ,<S2SV_ModStart> free_uid ( fpl -> user ) ; 
5240,"<S2SV_StartBug> BLOCK_SIZE bsize , int use_rd ) { <S2SV_EndBug> <S2SV_StartBug> const int refresh_this_block = candidate_refresh_aq ( cr , mbmi , bsize , use_rd ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mbmi -> segment_id > 0 && ! refresh_this_block ) <S2SV_EndBug> <S2SV_StartBug> if ( mbmi -> segment_id == 1 ) { <S2SV_EndBug> <S2SV_StartBug> cr -> map [ block_index + y * cm -> mi_cols + x ] = new_map_value ; <S2SV_EndBug> <S2SV_StartBug> cpi -> segmentation_map [ block_index + y * cm -> mi_cols + x ] = <S2SV_EndBug> ","<S2SV_ModStart> int64_t rate , int64_t dist , int skip <S2SV_ModEnd> <S2SV_ModStart> rate , dist , bsize <S2SV_ModEnd> <S2SV_ModStart> cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) { mbmi -> segment_id = refresh_this_block ; if ( skip ) mbmi -> segment_id = CR_SEGMENT_ID_BASE ; } if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) { new_map_value = - cr -> time_for_refresh ; } else if ( refresh_this_block ) { if ( cr -> map [ block_index ] <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int map_offset = <S2SV_ModEnd> <S2SV_ModStart> ; cr -> map [ map_offset <S2SV_ModStart> map_offset ] = mbmi -> segment_id ; if ( ! is_inter_block ( mbmi ) || ! skip ) cr -> last_coded_q_map [ map_offset ] = clamp ( cm -> base_qindex + cr -> qindex_delta [ mbmi -> segment_id ] , 0 , MAXQ ) ; } <S2SV_ModEnd> "
5241,"<S2SV_StartBug> static char * create_output_name ( unsigned char * fname , unsigned char * dir , <S2SV_EndBug> <S2SV_StartBug> if ( utf8 ) x *= 3 ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""out<S2SV_blank>of<S2SV_blank>memory!\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> while ( * fname == sep ) fname ++ ; <S2SV_EndBug> <S2SV_StartBug> p = & name [ strlen ( ( char * ) name ) ] ; <S2SV_EndBug> <S2SV_StartBug> if ( fname >= fe ) { <S2SV_EndBug> <S2SV_StartBug> x = ( c & 0x1F ) << 6 ; <S2SV_EndBug> <S2SV_StartBug> } while ( x ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) { char * out , * p <S2SV_ModEnd> <S2SV_ModStart> ( out = malloc ( strlen ( fname ) + 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> '/' || * fname == '\\\\' <S2SV_ModEnd> <S2SV_ModStart> strcpy ( out , ( * fname ) ? fname : ""x"" ) ; for ( p = out ; * p ; p ++ ) <S2SV_ModEnd> <S2SV_ModStart> p [ 0 ] == '.' && p [ 1 ] == '.' && ( p [ 2 ] == '/' || p [ 2 ] == '\\\\' <S2SV_ModEnd> <S2SV_ModStart> p [ 0 ] = p [ 1 ] = 'x' <S2SV_ModEnd> <S2SV_ModStart> } return out <S2SV_ModEnd> "
5242,"<S2SV_StartBug> ERR ( ""callocing<S2SV_blank>this<S2SV_blank>failed"" ) ; <S2SV_EndBug> <S2SV_StartBug> this -> sd = socket ( AF_INET6 , SOCK_STREAM , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> ERR ( ""sockect<S2SV_blank>open<S2SV_blank>failed"" ) ; <S2SV_EndBug> <S2SV_StartBug> addr . sin6_family = AF_INET6 ; <S2SV_EndBug> <S2SV_StartBug> addr . sin6_addr = in6addr_any ; <S2SV_EndBug> <S2SV_StartBug> ERR ( ""Bind<S2SV_blank>on<S2SV_blank>port<S2SV_blank>failed.<S2SV_blank>"" <S2SV_EndBug> <S2SV_StartBug> ERR ( ""listen<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>socket"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""IPv4:<S2SV_blank>callocing<S2SV_blank>this<S2SV_blank>failed"" <S2SV_ModEnd> <S2SV_ModStart> AF_INET <S2SV_ModEnd> <S2SV_ModStart> ""IPv4<S2SV_blank>socket<S2SV_blank>open<S2SV_blank>failed"" ) ; goto error ; } struct sockaddr_in <S2SV_ModEnd> <S2SV_ModStart> sin_family = AF_INET ; addr . sin_port <S2SV_ModEnd> <S2SV_ModStart> sin_addr . s_addr = htonl ( 0x7F000001 ) <S2SV_ModEnd> <S2SV_ModStart> ""IPv4<S2SV_blank>bind<S2SV_blank>on<S2SV_blank>port<S2SV_blank>failed.<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ""IPv4<S2SV_blank>listen<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>socket"" <S2SV_ModEnd> "
5243,<S2SV_StartBug> redisAssert ( server . vm_enabled ) ; <S2SV_EndBug> <S2SV_StartBug> server . vm_blocked_clients -- ; <S2SV_EndBug> ,<S2SV_ModStart> ds_enabled <S2SV_ModEnd> <S2SV_ModStart> cache_blocked_clients <S2SV_ModEnd> 
5244,"<S2SV_StartBug> void oz_hcd_get_desc_cnf ( void * hport , u8 req_id , int status , const u8 * desc , <S2SV_EndBug> <S2SV_StartBug> int length , int offset , int total_size ) <S2SV_EndBug> <S2SV_StartBug> int copy_len ; <S2SV_EndBug> <S2SV_StartBug> int required_size = urb -> transfer_buffer_length ; <S2SV_EndBug> ","<S2SV_ModStart> u8 <S2SV_ModEnd> <S2SV_ModStart> u8 length , u16 offset , u16 <S2SV_ModEnd> <S2SV_ModStart> unsigned <S2SV_ModStart> unsigned "
5245,<S2SV_StartBug> u8 * data = NULL ; <S2SV_EndBug> <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> hdr . flags & ~ ( VFIO_IRQ_SET_DATA_TYPE_MASK | <S2SV_EndBug> <S2SV_StartBug> if ( ! ( hdr . flags & VFIO_IRQ_SET_DATA_NONE ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( hdr . flags & VFIO_IRQ_SET_DATA_BOOL ) <S2SV_EndBug> <S2SV_StartBug> hdr . start >= max || hdr . start + hdr . count > max ) <S2SV_EndBug> ,"<S2SV_ModStart> size_t size ; <S2SV_ModStart> max , <S2SV_ModStart> count >= ( U32_MAX - hdr . start ) || hdr . <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) return - EINVAL ; switch ( hdr . flags & VFIO_IRQ_SET_DATA_TYPE_MASK ) { case VFIO_IRQ_SET_DATA_NONE : size = 0 ; break ; case VFIO_IRQ_SET_DATA_BOOL : size = sizeof ( uint8_t ) ; break ; case VFIO_IRQ_SET_DATA_EVENTFD : size = sizeof ( int32_t ) ; break ; default : return - EINVAL ; } if ( size ) { if ( hdr . argsz - minsz < hdr . count * size "
5246,<S2SV_StartBug> if ( envs [ h_env -> envc ] . env == HTML_DL_COMPACT ) { <S2SV_EndBug> ,<S2SV_ModStart> h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if ( 
5247,<S2SV_StartBug> while ( buflen > 0 ) { <S2SV_EndBug> <S2SV_StartBug> return union_desc ; <S2SV_EndBug> ,"<S2SV_ModStart> >= sizeof ( * union_desc ) ) { union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bLength > buflen ) { dev_err ( & intf -> dev , ""Too<S2SV_blank>large<S2SV_blank>descriptor\\n"" ) ; return NULL ; } <S2SV_ModEnd> <S2SV_ModStart> if ( union_desc -> bLength >= sizeof ( * union_desc ) ) return union_desc ; dev_err ( & intf -> dev , ""Union<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>short<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%zd\\n)"" , union_desc -> bLength , sizeof ( * union_desc ) ) ; return NULL <S2SV_ModEnd> "
5248,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> alt = & gspca_dev -> dev -> actconfig -> intf_cache [ 0 ] -> altsetting [ 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart> struct usb_interface_cache * intfc ; <S2SV_ModStart> intfc = <S2SV_ModEnd> <S2SV_ModStart> ; if ( intfc -> num_altsetting < 2 ) return - ENODEV ; alt = & intfc <S2SV_ModStart> ; if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV 
5249,<S2SV_StartBug> head_shift = ( F_SECT_PER_TRACK + 5 ) / 6 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! F_SECT_PER_TRACK ) return ; 
5250,"<S2SV_StartBug> if ( copy_from_user ( & sas , optval , len ) ) <S2SV_EndBug> <S2SV_StartBug> len = min_t ( size_t , len , sizeof ( sas ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> len = min_t ( size_t , len , sizeof ( sas ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
5251,"<S2SV_StartBug> if ( buf ) <S2SV_EndBug> <S2SV_StartBug> _copy_from_pages ( buf , pages , res . acl_data_offset , res . acl_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> { if ( res . acl_len > buflen ) { ret = - ERANGE ; goto out_free ; } <S2SV_ModStart> } 
5252,"<S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rv ) <S2SV_EndBug> <S2SV_StartBug> fs_logger2 ( ""clone"" , dest ) ; <S2SV_EndBug> ",<S2SV_ModStart> copy_file_as_user <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5253,"<S2SV_StartBug> if ( copy_from_user ( buf , ( void * ) arg , hdr . size_in ) ) { <S2SV_EndBug> ","<S2SV_ModStart> * ( ( struct vbg_ioctl_hdr * ) buf ) = hdr ; <S2SV_ModStart> + sizeof ( hdr ) <S2SV_ModStart> + sizeof ( hdr ) , hdr . size_in - sizeof ( hdr ) <S2SV_ModEnd> "
5254,"<S2SV_StartBug> static int bson_string_is_db_ref ( const unsigned char * string , const int length ) { <S2SV_EndBug> ",<S2SV_ModStart> size_t <S2SV_ModEnd> 
5255,"<S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> != c ) break 
5256,"<S2SV_StartBug> static int detect_flash ( const struct twopass_rc * twopass , int offset ) { <S2SV_EndBug> <S2SV_StartBug> FIRSTPASS_STATS next_frame ; <S2SV_EndBug> <S2SV_StartBug> if ( read_frame_stats ( twopass , & next_frame , offset ) != EOF ) { <S2SV_EndBug> <S2SV_StartBug> if ( next_frame . pcnt_second_ref > next_frame . pcnt_inter && <S2SV_EndBug> <S2SV_StartBug> next_frame . pcnt_second_ref >= 0.5 ) <S2SV_EndBug> ",<S2SV_ModStart> TWO_PASS <S2SV_ModEnd> <S2SV_ModStart> const FIRSTPASS_STATS * const next_frame = <S2SV_ModEnd> <S2SV_ModStart> offset ) ; return next_frame != NULL && next_frame -> <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5257,<S2SV_StartBug> } else <S2SV_EndBug> ,"<S2SV_ModStart> else if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) && ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( dir , CAP_FSETID ) ) mode &= ~ S_ISGID ; "
5258,<S2SV_StartBug> cl -> wsctx = ( wsCtx * ) wsctx ; <S2SV_EndBug> ,<S2SV_ModStart> hybiDecodeCleanup ( wsctx ) ; 
5259,<S2SV_StartBug> out_release_nounlock : <S2SV_EndBug> ,<S2SV_ModStart> if ( vm_shared ) unlock_page ( page ) ; out_release_nounlock : <S2SV_ModEnd> 
5260,"<S2SV_StartBug> DEBUG ( ""snmp<S2SV_blank>plugin:<S2SV_blank>all<S2SV_blank>variables<S2SV_blank>have<S2SV_blank>left<S2SV_blank>their<S2SV_blank>subtree"" ) ; <S2SV_EndBug> <S2SV_StartBug> req = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( req != NULL ) <S2SV_EndBug> ",<S2SV_ModStart> ) ; snmp_free_pdu ( req <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5261,<S2SV_StartBug> int m ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( n < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_pad"" ) ; } "
5262,<S2SV_StartBug> if ( section -> cipher_list ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! section -> option . client ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> # if OPENSSL_VERSION_NUMBER >= 0x10100000L if ( section -> security_level >= 0 ) { SSL_CTX_set_security_level ( section -> ctx , section -> security_level ) ; s_log ( LOG_INFO , ""User-specified<S2SV_blank>security<S2SV_blank>level<S2SV_blank>set:<S2SV_blank>%d"" , section -> security_level ) ; } else if ( SSL_CTX_get_security_level ( section -> ctx ) < DEFAULT_SECURITY_LEVEL ) { SSL_CTX_set_security_level ( section -> ctx , DEFAULT_SECURITY_LEVEL ) ; s_log ( LOG_INFO , ""stunnel<S2SV_blank>default<S2SV_blank>security<S2SV_blank>level<S2SV_blank>set:<S2SV_blank>%d"" , DEFAULT_SECURITY_LEVEL ) ; } else { s_log ( LOG_INFO , ""OpenSSL<S2SV_blank>security<S2SV_blank>level<S2SV_blank>is<S2SV_blank>used:<S2SV_blank>%d"" , SSL_CTX_get_security_level ( section -> ctx ) ) ; } # endif <S2SV_ModStart> # ifndef OPENSSL_NO_TLSEXT <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5263,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , length ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ipaddr_string ( ndo , & cp [ len ] ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> ( 0 ) <S2SV_ModStart> ) ; ND_TCHECK ( cp [ 2 ] <S2SV_ModStart> ND_TCHECK2 ( cp [ len ] , 4 ) ; <S2SV_ModStart> return ( 0 ) ; trunc : return ( - 1 ) ; "
5264,<S2SV_StartBug> cpi -> this_frame_target += ( ( cpi -> current_gf_interval - 1 ) * Adjustment ) ; <S2SV_EndBug> ,<S2SV_ModStart> { Adjustment = <S2SV_ModEnd> <S2SV_ModStart> ; if ( Adjustment > ( 10 * cpi -> this_frame_target ) / 100 ) Adjustment = ( 10 * cpi -> this_frame_target ) / 100 ; cpi -> this_frame_target += Adjustment ; } <S2SV_ModEnd> 
5265,"<S2SV_StartBug> if ( check_anon ( kdc_active_realm , request -> client , request -> server ) != 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> client . princ <S2SV_ModEnd> 
5266,<S2SV_StartBug> facilities_len -= len + 1 ; <S2SV_EndBug> <S2SV_StartBug> facilities_len -= len + 1 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 0 ) return 0 ; <S2SV_ModStart> if ( len < 0 ) return 0 ; 
5267,"<S2SV_StartBug> if ( ! capable ( CAP_NET_ADMIN ) ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( arg , user , get_arglen [ GET_CMDID ( cmd ) ] ) != 0 ) <S2SV_EndBug> ",<S2SV_ModStart> unsigned int copylen ; <S2SV_ModStart> ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX ) return - EINVAL <S2SV_ModStart> copylen = get_arglen [ GET_CMDID ( cmd ) ] ; if ( copylen > 128 ) return - EINVAL ; <S2SV_ModStart> copylen <S2SV_ModEnd> 
5268,<S2SV_StartBug> opt_type = * bp ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! ND_TTEST2 ( * bp , 2 ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|OPT]"" ) ) ; return ; } "
5269,"<S2SV_StartBug> int * returnrate , int64_t * returndist , <S2SV_EndBug> <S2SV_StartBug> int rate_y = 0 , rate_uv = 0 , rate_y_tokenonly = 0 , rate_uv_tokenonly = 0 ; <S2SV_EndBug> <S2SV_StartBug> int64_t dist_y = 0 , dist_uv = 0 , tx_cache [ TX_MODES ] = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize >= BLOCK_8X8 ) { <S2SV_EndBug> <S2SV_StartBug> & dist_y , & y_skip , bsize , tx_cache , <S2SV_EndBug> <S2SV_StartBug> * returnrate = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> max_uv_tx_size = get_uv_tx_size_impl ( xd -> mi [ 0 ] -> mbmi . tx_size , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> & dist_uv , & uv_skip , bsize , max_uv_tx_size ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> * returnrate = rate_y + rate_uv - rate_y_tokenonly - rate_uv_tokenonly + <S2SV_EndBug> <S2SV_StartBug> * returndist = dist_y + dist_uv ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( ctx -> tx_rd_diff ) ; <S2SV_EndBug> ","<S2SV_ModStart> RD_COST * rd_cost , <S2SV_ModEnd> <S2SV_ModStart> struct macroblockd_plane * const pd = xd -> plane ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> xd -> mi [ 0 ] -> mbmi . ref_frame [ 1 ] = NONE ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rd_cost -> rate <S2SV_ModEnd> <S2SV_ModStart> } } else { y_skip = 0 ; if ( rd_pick_intra_sub_8x8_y_mode ( cpi , x , & rate_y , & rate_y_tokenonly , & dist_y , best_rd ) >= best_rd ) { rd_cost -> rate = INT_MAX ; return ; } <S2SV_ModStart> , pd [ 1 ] . subsampling_x , pd [ 1 ] . subsampling_y <S2SV_ModStart> MAX ( BLOCK_8X8 , bsize ) , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rd_cost -> rate <S2SV_ModEnd> <S2SV_ModStart> rd_cost -> dist <S2SV_ModEnd> <S2SV_ModStart> } else { rd_cost -> rate = rate_y + rate_uv + vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; rd_cost -> dist = dist_y + dist_uv ; } ctx -> mic = * xd -> mi [ 0 ] ; ctx -> mbmi_ext = * x -> mbmi_ext ; rd_cost -> rdcost = RDCOST ( x -> rdmult , x -> rddiv , rd_cost -> rate , rd_cost -> dist ) <S2SV_ModEnd> "
5270,<S2SV_StartBug> kern_msg -> msg_name = kern_address ; <S2SV_EndBug> ,<S2SV_ModStart> if ( kern_msg -> msg_name ) 
5271,"<S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> != c ) break 
5272,"<S2SV_StartBug> pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ; <S2SV_EndBug> ",<S2SV_ModStart> PAGE_KERNEL <S2SV_ModEnd> 
5273,<S2SV_StartBug> assert ( bidx <= PCI_BARMAX ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( pdi -> bar [ bidx ] . type == PCIBAR_MEM32 || <S2SV_EndBug> <S2SV_StartBug> pdi -> bar [ bidx ] . type == PCIBAR_MEM64 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( addr + size > <S2SV_ModEnd> <S2SV_ModStart> addr + <S2SV_ModEnd> <S2SV_ModStart> size ) { printf ( ""%s,<S2SV_blank>Out<S2SV_blank>of<S2SV_blank>emulated<S2SV_blank>memory<S2SV_blank>range.\\n"" , __func__ ) ; return - ESRCH ; } <S2SV_ModEnd> "
5274,<S2SV_StartBug> if ( sk != asoc -> base . sk ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5275,<S2SV_StartBug> if ( image_info -> ping ) goto Finish ; <S2SV_EndBug> ,"<S2SV_ModStart> != MagickFalse <S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
5276,<S2SV_StartBug> for ( col = 0 ; col < imagewidth ; col += tw ) { <S2SV_EndBug> ,<S2SV_ModStart> && colb < imagew 
5277,<S2SV_StartBug> number_planes_filled * sizeof ( * pixels ) ) ; <S2SV_EndBug> <S2SV_StartBug> pixel_info_length = image -> columns * image -> rows * number_planes_filled ; <S2SV_EndBug> ,"<S2SV_ModStart> MagickMax ( number_planes_filled , 4 ) <S2SV_ModEnd> <S2SV_ModStart> MagickMax ( number_planes_filled , 4 ) <S2SV_ModEnd> "
5278,<S2SV_StartBug> m -> msg_name = address ; <S2SV_EndBug> ,<S2SV_ModStart> if ( m -> msg_name ) 
5279,<S2SV_StartBug> * sent = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5280,"
","
"
5281,<S2SV_StartBug> u8 smac [ ETH_ALEN ] ; <S2SV_EndBug> <S2SV_StartBug> if ( is_iboe ) { <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & lock ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5282,"<S2SV_StartBug> static int t220_frontend_attach ( struct dvb_usb_adapter * d ) <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x86 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x80 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> msleep ( 50 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_EndBug> <S2SV_StartBug> d -> fe_adap [ 0 ] . fe = dvb_attach ( cxd2820r_attach , & cxd2820r_config , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( d -> fe_adap [ 0 ] . fe != NULL ) { <S2SV_EndBug> <S2SV_StartBug> if ( dvb_attach ( tda18271_attach , d -> fe_adap [ 0 ] . fe , 0x60 , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap , & tda18271_config ) ) { <S2SV_EndBug> ","<S2SV_ModStart> adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x87 ; state -> data [ 2 ] = 0x0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x86 ; state -> data [ 2 ] = 1 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data [ 1 ] = 0x80 ; state -> data <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> msleep ( 50 ) ; state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data [ 0 ] = 0x51 <S2SV_ModEnd> <S2SV_ModStart> , state -> data , 1 , state -> data <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5283,"<S2SV_StartBug> size = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; <S2SV_EndBug> ","<S2SV_ModStart> nr_pages = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; if ( nr_pages < 2 ) nr_pages = 2 ; size = nr_pages * BUF_PAGE_SIZE <S2SV_ModEnd> "
5284,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % ( 2 * stride ) ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horAcc16"" , ""%s"" , ""cc%(2*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; "
5285,<S2SV_StartBug> if ( ! * passwd || ! * user -> passwd ) <S2SV_EndBug> ,"<S2SV_ModStart> user ) { slog_error ( client , ""Password<S2SV_blank>packet<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>packet?"" ) ; return false ; } if ( ! "
5286,<S2SV_StartBug> char * buf ; <S2SV_EndBug> ,"<S2SV_ModStart> struct stream packet = * s ; if ( ! s_check ( s ) ) { rdp_protocol_error ( ""lspci_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state"" , & packet ) ; } "
5287,<S2SV_StartBug> for ( col = 0 ; col < imagewidth ; col += tw ) { <S2SV_EndBug> ,<S2SV_ModStart> && colb < imagew 
5288,"<S2SV_StartBug> write_webm_file_footer ( & stream -> ebml , stream -> hash ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) <S2SV_ModEnd> 
5289,"<S2SV_StartBug> static void encode_uniform ( vp9_writer * w , int v ) { <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , v , l - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , m + ( ( v - m ) >> 1 ) , l - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , ( v - m ) & 1 , 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> vpx_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_write_literal <S2SV_ModEnd> 
5290,"<S2SV_StartBug> k -> get_config ( vdev , vdev -> config ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; } <S2SV_ModStart>  <S2SV_ModEnd> 
5291,"<S2SV_StartBug> strcpy ( link_info . str , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> nla_strlcpy <S2SV_ModEnd> <S2SV_ModStart> , TIPC_MAX_LINK_NAME "
5292,"<S2SV_StartBug> gpio_dev -> pctrl = pinctrl_register ( & amd_pinctrl_desc , <S2SV_EndBug> <S2SV_StartBug> & pdev -> dev , gpio_dev ) ; <S2SV_EndBug> <S2SV_StartBug> goto out1 ; <S2SV_EndBug> <S2SV_StartBug> out1 : <S2SV_EndBug> ","<S2SV_ModStart> devm_pinctrl_register ( & pdev -> dev , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return ret <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5293,"<S2SV_StartBug> if ( mount ( console -> name , lxcpath , ""none"" , MS_BIND , 0 ) ) { <S2SV_EndBug> ","<S2SV_ModStart> safe_mount ( console -> name , lxcpath , ""none"" , MS_BIND , 0 , rootfs -> mount ) ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'"" , <S2SV_ModEnd> <S2SV_ModStart> ) ; return - 1 ; } ret = snprintf ( lxcpath , sizeof ( lxcpath ) , ""%s/console"" , ttydir ) ; if ( ret >= sizeof ( lxcpath ) ) { ERROR ( ""lxc/console<S2SV_blank>path<S2SV_blank>too<S2SV_blank>long"" ) ; return - 1 ; } ret = symlink ( lxcpath , path ) ; if ( ret ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>symlink<S2SV_blank>for<S2SV_blank>console"" ) ; return - 1 ; } INFO ( ""console<S2SV_blank>has<S2SV_blank>been<S2SV_blank>setup<S2SV_blank>on<S2SV_blank>%s"" , lxcpath ) ; return 0 <S2SV_ModEnd> "
5294,"<S2SV_StartBug> static void nsc_decode ( NSC_CONTEXT * context ) <S2SV_EndBug> <S2SV_StartBug> UINT16 rw = ROUND_UP_TO ( context -> width , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> BYTE shift = context -> ColorLossLevel - 1 ; <S2SV_EndBug> <S2SV_StartBug> BYTE * bmpdata = context -> BitmapData ; <S2SV_EndBug> <S2SV_StartBug> * bmpdata ++ = MINMAX ( b_val , 0 , 0xFF ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> ; BYTE shift ; BYTE * bmpdata ; size_t pos = 0 ; if ( ! context ) return FALSE ; rw <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! bmpdata ) return FALSE <S2SV_ModStart> if ( pos + 4 > context -> BitmapDataLength ) return FALSE ; pos += 4 ; <S2SV_ModStart> return TRUE ; 
5295,"<S2SV_StartBug> static void atomic2gen ( lua_State * L , global_State * g ) { <S2SV_EndBug> ",<S2SV_ModStart> g -> gcstate = GCSswpallgc ; 
5296,"<S2SV_StartBug> vp8_decrypt_cb * decrypt_cb , <S2SV_EndBug> ",<S2SV_ModStart> vpx_decrypt_cb <S2SV_ModEnd> 
5297,<S2SV_StartBug> if ( REMAIN > INT_MAX ) <S2SV_EndBug> ,<S2SV_ModStart> == 0 || REMAIN 
5298,<S2SV_StartBug> regs [ insn -> dst_reg ] . var_off = tnum_cast ( <S2SV_EndBug> <S2SV_StartBug> __update_reg_bounds ( & regs [ insn -> dst_reg ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> coerce_reg_to_size <S2SV_ModEnd> <S2SV_ModStart> , 4 "
5299,"<S2SV_StartBug> WORD32 ih264d_end_of_pic ( dec_struct_t * ps_dec , <S2SV_EndBug> <S2SV_StartBug> WORD32 ret ; <S2SV_EndBug> <S2SV_StartBug> ps_dec -> u2_total_mbs_coded = 0 ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5300,<S2SV_StartBug> if ( ! file ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ,<S2SV_ModStart> || count > OE_SSIZE_MAX <S2SV_ModStart> if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } 
5301,"<S2SV_StartBug> DRM_DEBUG ( ""clip<S2SV_blank>rectangles<S2SV_blank>are<S2SV_blank>only<S2SV_blank>valid<S2SV_blank>with<S2SV_blank>the<S2SV_blank>render<S2SV_blank>ring\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; return - EINVAL ; } if ( args -> num_cliprects > UINT_MAX / sizeof ( * cliprects ) ) { DRM_DEBUG ( ""execbuf<S2SV_blank>with<S2SV_blank>%u<S2SV_blank>cliprects\\n"" , args -> num_cliprects "
5302,<S2SV_StartBug> long tmp = * old ; <S2SV_EndBug> <S2SV_StartBug> return * old == tmp ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( tmp == * old ) { * old = new ; return 1 ; } else { * old = tmp ; return 0 ; } <S2SV_ModEnd> 
5303,"<S2SV_StartBug> char buf [ 32 ] , * e ; <S2SV_EndBug> ",<S2SV_ModStart> 50 <S2SV_ModEnd> 
5304,<S2SV_StartBug> nfcf_poll -> sensf_res_len = * data ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> min_t ( __u8 , <S2SV_ModStart> , NFC_SENSF_RES_MAXSIZE ) "
5305,<S2SV_StartBug> mutex_unlock ( & file -> mut ) ; <S2SV_EndBug> ,"<S2SV_ModStart> mutex_lock ( & mut ) ; idr_replace ( & multicast_idr , mc , mc -> id ) ; mutex_unlock ( & mut ) ; "
5306,"<S2SV_StartBug> if ( db -> mallocFailed || sqliteProcessJoin ( pParse , p ) ) { <S2SV_EndBug> ",<S2SV_ModStart> pParse -> nErr || 
5307,"<S2SV_StartBug> u64 msr_data ; <S2SV_EndBug> <S2SV_StartBug> cs . dpl = 3 ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> ctxt -> _eip = reg_read ( ctxt , VCPU_REGS_RDX ) ; <S2SV_EndBug> <S2SV_StartBug> * reg_write ( ctxt , VCPU_REGS_RSP ) = reg_read ( ctxt , VCPU_REGS_RCX ) ; <S2SV_EndBug> ","<S2SV_ModStart> , rcx , rdx <S2SV_ModStart> rcx = reg_read ( ctxt , VCPU_REGS_RCX ) ; rdx = reg_read ( ctxt , VCPU_REGS_RDX ) ; <S2SV_ModStart> if ( is_noncanonical_address ( rcx ) || is_noncanonical_address ( rdx ) ) return emulate_gp ( ctxt , 0 ) ; <S2SV_ModStart> rdx <S2SV_ModEnd> <S2SV_ModStart> rcx <S2SV_ModEnd> "
5308,"<S2SV_StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! po -> running ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> return - EALREADY ; <S2SV_EndBug> <S2SV_StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! po -> rollover ) <S2SV_EndBug> <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & fanout_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> if ( err ) { <S2SV_EndBug> ",<S2SV_ModStart> packet_rollover * rollover = NULL ; struct <S2SV_ModStart> mutex_lock ( & fanout_mutex ) ; err = - EINVAL ; <S2SV_ModStart> goto out ; err = - EALREADY <S2SV_ModEnd> <S2SV_ModStart> goto out <S2SV_ModEnd> <S2SV_ModStart> err = - ENOMEM ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rollover ) goto out <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> po -> rollover = rollover ; } <S2SV_ModEnd> <S2SV_ModStart> if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } <S2SV_ModStart>  <S2SV_ModEnd> 
5309,<S2SV_StartBug> return fd ; <S2SV_EndBug> ,<S2SV_ModStart> sr -> fd_is_fdt = MK_TRUE ; 
5310,"<S2SV_StartBug> int vp8_denoiser_allocate ( VP8_DENOISER * denoiser , int width , int height ) <S2SV_EndBug> <S2SV_StartBug> assert ( denoiser ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( denoiser -> yv12_running_avg [ i ] . buffer_alloc , 0 , <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( denoiser -> yv12_mc_running_avg . buffer_alloc , 0 , <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> , int num_mb_rows , int num_mb_cols , int mode <S2SV_ModStart> ; denoiser -> num_mb_cols = num_mb_cols <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> if ( vp8_yv12_alloc_frame_buffer ( & denoiser -> yv12_last_source , width , height , VP8BORDERINPIXELS ) < 0 ) { vp8_denoiser_free ( denoiser ) ; return 1 ; } memset ( denoiser -> yv12_last_source . buffer_alloc , 0 , denoiser -> yv12_last_source . frame_size ) ; denoiser -> denoise_state = vpx_calloc ( ( num_mb_rows * num_mb_cols ) , 1 ) ; memset ( denoiser -> denoise_state , 0 , ( num_mb_rows * num_mb_cols ) ) ; vp8_denoiser_set_parameters ( denoiser , mode ) ; denoiser -> nmse_source_diff = 0 ; denoiser -> nmse_source_diff_count = 0 ; denoiser -> qp_avg = 0 ; denoiser -> qp_threshold_up = 80 ; denoiser -> qp_threshold_down = 128 ; denoiser -> bitrate_threshold = 400000 ; denoiser -> threshold_aggressive_mode = 80 ; if ( width * height > 1280 * 720 ) { denoiser -> bitrate_threshold = 3000000 ; denoiser -> threshold_aggressive_mode = 200 ; } else if ( width * height > 960 * 540 ) { denoiser -> bitrate_threshold = 1200000 ; denoiser -> threshold_aggressive_mode = 120 ; } else if ( width * height > 640 * 480 ) { denoiser -> bitrate_threshold = 600000 ; denoiser -> threshold_aggressive_mode = 100 ; } return <S2SV_ModEnd> "
5311,<S2SV_StartBug> struct mct_u232_private * priv ; <S2SV_EndBug> <S2SV_StartBug> priv -> read_urb = port -> serial -> port [ 1 ] -> interrupt_in_urb ; <S2SV_EndBug> ,"<S2SV_ModStart> usb_serial * serial = port -> serial ; struct <S2SV_ModStart> if ( ! serial -> port [ 1 ] || ! serial -> port [ 1 ] -> interrupt_in_urb ) { dev_err ( & port -> dev , ""expected<S2SV_blank>endpoint<S2SV_blank>missing\\n"" ) ; return - ENODEV ; } <S2SV_ModStart>  <S2SV_ModEnd> "
5312,"<S2SV_StartBug> ptr = sshpkt_ptr ( ssh , & dlen ) ; <S2SV_EndBug> ","<S2SV_ModStart> ssh_dispatch_set ( ssh , SSH2_MSG_KEXINIT , NULL ) ; "
5313,<S2SV_StartBug> if ( ( temp_buffer & 0xffffff00 ) != 0x100 ) <S2SV_EndBug> <S2SV_StartBug> else if ( temp_buffer < 0x120 ) <S2SV_EndBug> <S2SV_StartBug> else if ( temp_buffer < 0x130 ) <S2SV_EndBug> ,<S2SV_ModStart> temp_buffer & 0xfffffe00 ) continue ; if ( temp_buffer < 2 <S2SV_ModEnd> <S2SV_ModStart> >= 0x100 && temp_buffer <S2SV_ModStart> temp_buffer >= 0x120 && 
5314,"<S2SV_StartBug> unsigned short sel ; <S2SV_EndBug> <S2SV_StartBug> rc = load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) ; <S2SV_EndBug> <S2SV_StartBug> ctxt -> _eip = 0 ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> ","<S2SV_ModStart> , old_sel ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; u8 cpl = ctxt -> ops -> cpl ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_sel , & old_desc , NULL , VCPU_SREG_CS ) <S2SV_ModStart> __load_segment_descriptor <S2SV_ModEnd> <S2SV_ModStart> , cpl , false , & new_desc <S2SV_ModStart> rc = assign_eip_far ( ctxt <S2SV_ModEnd> <S2SV_ModStart> val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_sel , & old_desc , 0 , VCPU_SREG_CS <S2SV_ModEnd> <S2SV_ModStart> rc ; } return rc <S2SV_ModEnd> "
5315,<S2SV_StartBug> if ( x & ( 1 << i ) ) return i ; <S2SV_EndBug> ,<S2SV_ModStart> 1U << ( unsigned int ) <S2SV_ModEnd> 
5316,"<S2SV_StartBug> or_circuit_t * or_circ = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ! CIRCUIT_IS_ORIGIN ( circ ) ) <S2SV_EndBug> <S2SV_StartBug> or_circ = TO_OR_CIRCUIT ( circ ) ; <S2SV_EndBug> <S2SV_StartBug> relay_send_end_cell_from_edge ( rh . stream_id , circ , end_reason , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> END_STREAM_REASON_NOTDIRECTORY , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> END_STREAM_REASON_INTERNAL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> END_STREAM_REASON_EXITPOLICY , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> origin_circuit_t * origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ; <S2SV_EndBug> <S2SV_StartBug> origin_circ -> cpath -> prev ) ; <S2SV_EndBug> ",<S2SV_ModStart> = NULL ; origin_circuit_t * origin_circ = NULL ; crypt_path_t * layer_hint <S2SV_ModStart> { <S2SV_ModStart> } else { tor_assert ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) ; origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ; layer_hint = origin_circ -> cpath -> prev ; } <S2SV_ModStart> layer_hint <S2SV_ModEnd> <S2SV_ModStart> layer_hint <S2SV_ModEnd> <S2SV_ModStart> layer_hint <S2SV_ModEnd> <S2SV_ModStart> layer_hint <S2SV_ModEnd> <S2SV_ModStart> tor_assert ( origin_circ <S2SV_ModEnd> <S2SV_ModStart> layer_hint <S2SV_ModEnd> 
5317,<S2SV_StartBug> struct unix_sock * u = unix_sk ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5318,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( ! ret && xsave -> header . xcomp_bv ) ret = - EINVAL ; 
5319,<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> else { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> struct iattr iattr ; retval = posix_acl_update_mode ( inode , & iattr . ia_mode , & acl ) ; if ( retval <S2SV_ModEnd> <S2SV_ModStart> if ( ! acl ) { value = NULL ; size = 0 ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5320,<S2SV_StartBug> # ifdef __linux <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5321,<S2SV_StartBug> if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; <S2SV_EndBug> ,<S2SV_ModStart> || num >= 256 
5322,<S2SV_StartBug> INST_HANDLER ( lds ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 4 ) { return ; } 
5323,<S2SV_StartBug> for ( col = 0 ; col < imagewidth ; col += tw ) { <S2SV_EndBug> ,<S2SV_ModStart> && colb < imagew 
5324,<S2SV_StartBug> } else <S2SV_EndBug> ,"<S2SV_ModStart> if ( len < 0 ) { log_ppp_warn ( ""radius:packet<S2SV_blank>invalid<S2SV_blank>vendor<S2SV_blank>attribute<S2SV_blank>len<S2SV_blank>received\\n"" ) ; goto out_err ; } if ( 2 + len > n ) { log_ppp_warn ( ""radius:packet:<S2SV_blank>too<S2SV_blank>long<S2SV_blank>vendor<S2SV_blank>attribute<S2SV_blank>received<S2SV_blank>(%i,<S2SV_blank>%i)\\n"" , id , len ) ; goto out_err ; } "
5325,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ca . name [ sizeof ( ca . name ) - 1 ] = 0 ; 
5326,<S2SV_StartBug> goto out ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5327,<S2SV_StartBug> atomic_inc ( & prog -> aux -> refcnt ) ; <S2SV_EndBug> ,<S2SV_ModStart> prog = bpf_prog_inc ( prog <S2SV_ModEnd> 
5328,<S2SV_StartBug> if ( len < tcp_hdrlen ) <S2SV_EndBug> <S2SV_StartBug> if ( skb_tailroom ( skb ) < TCPOLEN_MSS ) { <S2SV_EndBug> ,<S2SV_ModStart> || tcp_hdrlen < sizeof ( struct tcphdr ) <S2SV_ModStart> tcp_hdrlen >= 15 * 4 ) return 0 ; if ( 
5329,<S2SV_StartBug> up_read ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> & control -> id ) ; <S2SV_EndBug> ,<S2SV_ModStart> struct snd_ctl_elem_id id = control -> id ; <S2SV_ModStart> & <S2SV_ModEnd> 
5330,"<S2SV_StartBug> memmove ( s + j , s + qs , blen - qs ) ; <S2SV_EndBug> <S2SV_StartBug> j += blen - qs ; <S2SV_EndBug> ",<S2SV_ModStart> const int qslen = blen - qs ; <S2SV_ModStart> ( size_t ) qslen ) ; qs = j <S2SV_ModEnd> <S2SV_ModStart> qslen <S2SV_ModEnd> 
5331,"<S2SV_StartBug> ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ; <S2SV_EndBug> ",<S2SV_ModStart> -> unary . child 
5332,<S2SV_StartBug> if ( UNEXPECTED ( Z_ISUNDEF_P ( data ) ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5333,<S2SV_StartBug> return - EEXIST ; <S2SV_EndBug> ,<S2SV_ModStart> 0 <S2SV_ModEnd> 
5334,"<S2SV_StartBug> memcpy ( & b [ 4 ] , cmd -> msg , cmd -> msg_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( cmd -> msg_len > sizeof ( b ) - 4 ) return - EINVAL ; 
5335,"<S2SV_StartBug> void vp9_idct32x32_add ( const int16_t * input , uint8_t * dest , int stride , <S2SV_EndBug> <S2SV_StartBug> vp9_idct32x32_1_add ( input , dest , stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_idct32x32_34_add ( input , dest , stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_idct32x32_1024_add ( input , dest , stride ) ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_idct32x32_1_add <S2SV_ModEnd> <S2SV_ModStart> vpx_idct32x32_34_add <S2SV_ModEnd> <S2SV_ModStart> vpx_idct32x32_1024_add <S2SV_ModEnd> 
5336,"<S2SV_StartBug> static inline void assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst ) <S2SV_EndBug> <S2SV_StartBug> switch ( ctxt -> op_bytes ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return assign_eip_far ( ctxt , dst , ctxt -> mode == X86EMUL_MODE_PROT64 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5337,"<S2SV_StartBug> smb_flush_file ( sr , sr -> fid_ofile ) ; <S2SV_EndBug> <S2SV_StartBug> smb_flush_file ( sr , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> smb_ofile_flush <S2SV_ModEnd> <S2SV_ModStart> smb_ofile_flush <S2SV_ModEnd> 
5338,"<S2SV_StartBug> static void print_bpf_insn ( struct bpf_insn * insn ) <S2SV_EndBug> <S2SV_StartBug> } else if ( BPF_MODE ( insn -> code ) == BPF_IMM ) { <S2SV_EndBug> <S2SV_StartBug> insn -> code , insn -> dst_reg , insn -> imm ) ; <S2SV_EndBug> ","<S2SV_ModStart> const struct bpf_verifier_env * env , const <S2SV_ModStart> && BPF_SIZE ( insn -> code ) == BPF_DW ) { u64 imm = ( ( u64 ) ( insn + 1 ) -> imm << 32 ) | ( u32 ) insn -> imm ; bool map_ptr = insn -> src_reg == BPF_PSEUDO_MAP_FD ; if ( map_ptr && ! env -> allow_ptr_leaks ) imm = 0 ; verbose ( ""(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>0x%llx\\n"" , insn -> code , <S2SV_ModEnd> <S2SV_ModStart> ( unsigned long long ) <S2SV_ModEnd> "
5339,<S2SV_StartBug> if ( net != & init_net ) <S2SV_EndBug> ,<S2SV_ModStart> protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if ( 
5340,"<S2SV_StartBug> uint16 strip , nstrips = TIFFNumberOfStrips ( in ) ; <S2SV_EndBug> ",<S2SV_ModStart> uint32 <S2SV_ModEnd> 
5341,"<S2SV_StartBug> s = tcp_recv ( NULL , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ber_in_header ( s , & tagval , & length ) || <S2SV_EndBug> <S2SV_StartBug> in_uint8s ( s , length ) ; <S2SV_EndBug> <S2SV_StartBug> token -> end = token -> p = token -> data ; <S2SV_EndBug> ","<S2SV_ModStart> struct stream packet ; <S2SV_ModStart> packet = * s ; <S2SV_ModStart> if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>version<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } <S2SV_ModStart> if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>token<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } s_realloc ( token , length ) ; s_reset ( token ) <S2SV_ModEnd> "
5342,<S2SV_StartBug> addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> ,<S2SV_ModStart> INADDR_LOOPBACK <S2SV_ModEnd> 
5343,<S2SV_StartBug> return ret ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree ( bo ) ; return ret ; } <S2SV_ModEnd> 
5344,"<S2SV_StartBug> char * fpath = NULL , * path1 , * cgdir = NULL , * controller ; <S2SV_EndBug> <S2SV_StartBug> if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) { <S2SV_EndBug> <S2SV_StartBug> ret = - EACCES ; <S2SV_EndBug> <S2SV_StartBug> if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) { <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> , * next = NULL <S2SV_ModStart> caller_is_in_ancestor ( fc -> pid , controller , path1 , & next <S2SV_ModEnd> <S2SV_ModStart> if ( fpath && strcmp ( next , fpath ) == 0 ) ret = - EEXIST ; else ret = - ENOENT <S2SV_ModEnd> <S2SV_ModStart> fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) { ret = - EACCES ; goto out ; } if ( ! <S2SV_ModStart> free ( next ) ; "
5345,<S2SV_StartBug> bool_t status ; <S2SV_EndBug> <S2SV_StartBug> # if ( TRACE_LEVEL >= TRACE_LEVEL_DEBUG ) <S2SV_EndBug> ,"<S2SV_ModStart> # if ( TRACE_LEVEL >= TRACE_LEVEL_DEBUG ) size_t length = netBufferGetLength ( buffer ) - offset ; TRACE_DEBUG ( ""Sending<S2SV_blank>packet<S2SV_blank>(%"" PRIuSIZE ""<S2SV_blank>bytes)...\\r\\n"" , length ) ; TRACE_DEBUG_NET_BUFFER ( ""<S2SV_blank><S2SV_blank>"" , buffer , offset , length ) ; # endif <S2SV_ModStart>  <S2SV_ModEnd> "
5346,<S2SV_StartBug> if ( ( ( int ) arg >= cdi -> capacity ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5347,<S2SV_StartBug> unsigned int random_variable = 0 ; <S2SV_EndBug> <S2SV_StartBug> random_variable = get_random_int ( ) & STACK_RND_MASK ; <S2SV_EndBug> ,<S2SV_ModStart> long <S2SV_ModEnd> <S2SV_ModStart> ( unsigned long ) <S2SV_ModStart> ; random_variable &= <S2SV_ModEnd> 
5348,"<S2SV_StartBug> SCSIDiskReq * r ; <S2SV_EndBug> <S2SV_StartBug> r = DO_UPCAST ( SCSIDiskReq , req , req ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5349,<S2SV_StartBug> if ( getClientTypeByName ( v [ j ] ) == - 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> int class = <S2SV_ModEnd> <S2SV_ModStart> ; if ( class <S2SV_ModStart> || class == CLIENT_TYPE_MASTER 
5350,"<S2SV_StartBug> return send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
5351,<S2SV_StartBug> const metadata_uptrdiff_t entries_end = <S2SV_EndBug> ,"<S2SV_ModStart> if ( metadata -> data_count > metadata -> data_capacity ) { ALOGE ( ""%s:<S2SV_blank>Data<S2SV_blank>count<S2SV_blank>(%"" PRIu32 "")<S2SV_blank>should<S2SV_blank>be<S2SV_blank><=<S2SV_blank>data<S2SV_blank>capacity<S2SV_blank>"" ""(%"" PRIu32 "")"" , __FUNCTION__ , metadata -> data_count , metadata -> data_capacity ) ; android_errorWriteLog ( SN_EVENT_LOG_ID , ""30591838"" ) ; return ERROR ; } "
5352,"<S2SV_StartBug> dprintk ( 2 , ""vm_close<S2SV_blank>%p<S2SV_blank>[count=%d,vma=%08lx-%08lx]\\n"" , map , <S2SV_EndBug> ","<S2SV_ModStart> ""vm_close<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n"" <S2SV_ModEnd> "
5353,<S2SV_StartBug> const uint32_t c_w = <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < img1 -> d_h ; ++ i ) <S2SV_EndBug> <S2SV_StartBug> img1 -> d_w ) == 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> uint32_t l_w = img1 -> d_w ; <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( img1 -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { l_w *= 2 ; c_w *= 2 ; } # endif <S2SV_ModStart> l_w <S2SV_ModEnd> 
5354,"<S2SV_StartBug> unsigned int blocks ; <S2SV_EndBug> <S2SV_StartBug> blocks = ( ( size - 1 ) / blksize ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> pMap -> range_count = range_count ; <S2SV_EndBug> <S2SV_StartBug> pMap -> ranges = malloc ( range_count * sizeof ( MappedRange ) ) ; <S2SV_EndBug> <S2SV_StartBug> memset ( pMap -> ranges , 0 , range_count * sizeof ( MappedRange ) ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> pMap -> ranges [ range_count - 1 ] . addr = reserve ; <S2SV_EndBug> <S2SV_StartBug> pMap -> ranges [ range_count - 1 ] . length = blocks * blksize ; <S2SV_EndBug> <S2SV_StartBug> next += pMap -> ranges [ i ] . length ; <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> if ( blksize != 0 ) { <S2SV_ModStart> } if ( size == 0 || blksize == 0 || blocks > SIZE_MAX / blksize || range_count == 0 ) { LOGE ( ""invalid<S2SV_blank>data<S2SV_blank>in<S2SV_blank>block<S2SV_blank>map<S2SV_blank>file:<S2SV_blank>size<S2SV_blank>%zu,<S2SV_blank>blksize<S2SV_blank>%u,<S2SV_blank>range_count<S2SV_blank>%u\\n"" , size , blksize , range_count ) ; return - 1 ; } <S2SV_ModStart> calloc ( range_count , <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> == NULL ) { LOGE ( ""calloc(%u,<S2SV_blank>%zu)<S2SV_blank>failed:<S2SV_blank>%s\\n"" , range_count , <S2SV_ModEnd> <S2SV_ModStart> , strerror ( errno ) ) ; return - 1 ; } <S2SV_ModEnd> <S2SV_ModStart> free ( pMap -> ranges ) ; <S2SV_ModStart> ; } int fd = open ( block_dev , O_RDONLY ) ; if ( fd < 0 ) { LOGW ( ""failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>block<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%s\\n"" , block_dev , strerror ( errno ) ) ; munmap ( reserve , blocks * blksize ) ; free ( pMap -> ranges ) ; return - 1 ; } unsigned char * next = reserve ; size_t remaining_size = blocks * blksize ; bool success = true ; for ( i = 0 ; i < range_count ; ++ i ) { size_t start , end ; if ( fscanf ( mapf , ""%zu<S2SV_blank>%zu\\n"" , & start , & end ) != 2 ) { LOGW ( ""failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>range<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>block<S2SV_blank>map\\n"" , i ) ; success = false ; break ; } size_t length = ( end - start ) * blksize ; if ( end <= start || ( end - start ) > SIZE_MAX / blksize || length > remaining_size ) { LOGE ( ""unexpected<S2SV_blank>range<S2SV_blank>in<S2SV_blank>block<S2SV_blank>map:<S2SV_blank>%zu<S2SV_blank>%zu\\n"" , start , end ) ; success = false ; break ; } void * addr = mmap64 ( next , length , PROT_READ , MAP_PRIVATE | MAP_FIXED , fd , ( ( off64_t ) start ) * blksize ) ; if ( addr == MAP_FAILED ) { LOGW ( ""failed<S2SV_blank>to<S2SV_blank>map<S2SV_blank>block<S2SV_blank>%d:<S2SV_blank>%s\\n"" , i , strerror ( errno ) ) ; success = false ; break <S2SV_ModStart> i <S2SV_ModEnd> <S2SV_ModStart> addr <S2SV_ModEnd> <S2SV_ModStart> i <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> length ; remaining_size -= length ; } if ( success && remaining_size != 0 ) { LOGE ( ""ranges<S2SV_blank>in<S2SV_blank>block<S2SV_blank>map<S2SV_blank>are<S2SV_blank>invalid:<S2SV_blank>remaining_size<S2SV_blank>=<S2SV_blank>%zu\\n"" , remaining_size ) ; success = false ; } if ( ! success ) { close ( fd ) ; munmap ( reserve , blocks * blksize ) ; free ( <S2SV_ModStart> ) ; return - 1 ; } close ( fd ) ; pMap -> addr = reserve ; pMap -> length <S2SV_ModEnd> "
5355,"<S2SV_StartBug> sprintf ( url_address , ""%.*s"" , url_len , url_begin ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( url_len >= sizeof ( url_address ) ) { applog ( LOG_WARNING , ""%s:<S2SV_blank>Truncating<S2SV_blank>overflowed<S2SV_blank>address<S2SV_blank>\'%.*s\'"" , __func__ , url_len , url_begin ) ; url_len = sizeof ( url_address ) - 1 ; } "
5356,"<S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rv ) <S2SV_EndBug> <S2SV_StartBug> fs_logger2 ( ""clone"" , dest ) ; <S2SV_EndBug> ",<S2SV_ModStart> copy_file_as_user <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5357,"<S2SV_StartBug> re -> flags | RE_FLAGS_SCAN , <S2SV_EndBug> ","<S2SV_ModStart> 0 , "
5358,"<S2SV_StartBug> void vp9_tokenize_sb ( VP9_COMP * cpi , TOKENEXTRA * * t , int dry_run , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> const int skip_inc = ! vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , <S2SV_EndBug> <S2SV_StartBug> struct tokenize_b_args arg = { cpi , xd , t } ; <S2SV_EndBug> <S2SV_StartBug> cm -> counts . skip [ ctx ] [ 1 ] += skip_inc ; <S2SV_EndBug> <S2SV_StartBug> if ( dry_run ) <S2SV_EndBug> <S2SV_StartBug> cm -> counts . skip [ ctx ] [ 0 ] += skip_inc ; <S2SV_EndBug> <S2SV_StartBug> * t = t_backup ; <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , <S2SV_ModStart> MACROBLOCK * const x = & td -> mb ; <S2SV_ModStart> x -> <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> segfeature_active <S2SV_ModEnd> <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> td -> counts -> <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> td -> counts -> <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5359,<S2SV_StartBug> if ( cmd & 0x08 ) off |= * delta ++ << 24UL ; <S2SV_EndBug> ,<S2SV_ModStart> ( ( unsigned ) <S2SV_ModStart> ) 
5360,"<S2SV_StartBug> if ( ( setup_ret = _WM_SetupMidiEvent ( xmi_mdi , xmi_data , 0 ) ) == 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> xmi_size , "
5361,<S2SV_StartBug> return KRB5KDC_ERR_BADOPTION ; <S2SV_EndBug> <S2SV_StartBug> server_princ ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> * status = ""INVALID_S4U2PROXY_OPTIONS"" ; <S2SV_ModStart> * status = ""EVIDENCE_TICKET_MISMATCH"" ; "
5362,"<S2SV_StartBug> struct pt_regs * regs , int nmi ) <S2SV_EndBug> <S2SV_StartBug> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5363,"<S2SV_StartBug> av_log ( avctx , AV_LOG_DEBUG , <S2SV_EndBug> ","<S2SV_ModStart> if ( s -> diff_start + s -> diff_height > cur_blk_height ) { av_log ( avctx , AV_LOG_ERROR , ""Block<S2SV_blank>parameters<S2SV_blank>invalid\\n"" ) ; return AVERROR_INVALIDDATA ; } "
5364,"<S2SV_StartBug> ret = vfs_dedupe_file_range ( file , same ) ; <S2SV_EndBug> ",<S2SV_ModStart> same -> dest_count = count ; 
5365,"<S2SV_StartBug> cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , <S2SV_EndBug> ","<S2SV_ModStart> ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart>  <S2SV_ModEnd> "
5366,<S2SV_StartBug> struct cpuinfo_x86 * c ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM 
5367,<S2SV_StartBug> bond_dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> ,<S2SV_ModStart> ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> 
5368,"<S2SV_StartBug> size_t size , const uint8_t * * psource , <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * const cm = & pbi -> common ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_refs [ 0 ] . idx != INT_MAX ) <S2SV_EndBug> <S2SV_StartBug> if ( cm -> new_fb_idx >= 0 && cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count == 0 ) <S2SV_EndBug> <S2SV_StartBug> cm -> release_fb_cb ( cm -> cb_priv , <S2SV_EndBug> <S2SV_StartBug> & cm -> frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer ) ; <S2SV_EndBug> <S2SV_StartBug> if ( setjmp ( cm -> error . jmp ) ) { <S2SV_EndBug> <S2SV_StartBug> cm -> error . setjmp = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_refs [ 0 ] . idx != INT_MAX ) <S2SV_EndBug> <S2SV_StartBug> retcode = vp9_decode_frame ( pbi , source , source + size , psource ) ; <S2SV_EndBug> <S2SV_StartBug> if ( retcode < 0 ) { <S2SV_EndBug> <S2SV_StartBug> cm -> error . error_code = VPX_CODEC_ERROR ; <S2SV_EndBug> <S2SV_StartBug> cm -> error . setjmp = 0 ; <S2SV_EndBug> <S2SV_StartBug> swap_frame_buffers ( pbi ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> volatile <S2SV_ModStart> ; BufferPool * volatile const pool = cm -> buffer_pool ; RefCntBuffer * volatile const frame_bufs = cm -> buffer_pool -> frame_bufs <S2SV_ModStart> > 0 ) { assert ( cm -> frame_refs [ 0 ] . buf != NULL ) ; <S2SV_ModEnd> <S2SV_ModStart> } pbi -> ready_for_new_data = 0 ; if ( ! pbi -> frame_parallel_decode && <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pool <S2SV_ModEnd> <S2SV_ModStart> pool <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cm -> new_fb_idx == INVALID_IDX ) return VPX_CODEC_MEM_ERROR ; cm -> cur_frame = & pool -> frame_bufs [ cm -> new_fb_idx ] ; pbi -> hold_ref_buf = 0 ; if ( pbi -> frame_parallel_decode ) { VPxWorker * const worker = pbi -> frame_worker_owner ; vp9_frameworker_lock_stats ( worker ) ; frame_bufs [ cm -> new_fb_idx ] . frame_worker_owner = worker ; pbi -> cur_buf = & frame_bufs [ cm -> new_fb_idx ] ; pbi -> cur_buf -> row = - 1 ; pbi -> cur_buf -> col = - 1 ; vp9_frameworker_unlock_stats ( worker ) ; } else { pbi -> cur_buf = & frame_bufs [ cm -> new_fb_idx ] ; } if ( <S2SV_ModStart> const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; int i ; <S2SV_ModStart> pbi -> ready_for_new_data = 1 ; winterface -> sync ( & pbi -> lf_worker ) ; for ( i = 0 ; i < pbi -> num_tile_workers ; ++ i ) { winterface -> sync ( & pbi -> tile_workers [ i ] ) ; } lock_buffer_pool ( pool ) ; if ( pbi -> hold_ref_buf == 1 ) { int ref_index = 0 , mask ; for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; if ( ( mask & 1 ) && old_idx >= 0 ) { decrease_ref_count ( old_idx , frame_bufs , pool ) ; } ++ ref_index ; } for ( ; ref_index < REF_FRAMES && ! cm -> show_existing_frame ; ++ ref_index ) { const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; } pbi -> hold_ref_buf = 0 ; } decrease_ref_count ( cm -> new_fb_idx , frame_bufs , pool ) ; unlock_buffer_pool ( pool ) ; vpx_clear_system_state ( ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> swap_frame_buffers ( pbi ) ; vpx_clear_system_state ( ) ; if ( ! cm -> show_existing_frame ) { cm -> last_show_frame = cm -> show_frame ; cm -> prev_frame = cm -> cur_frame ; if ( cm -> seg . enabled && ! pbi -> frame_parallel_decode ) vp9_swap_current_and_last_seg_map ( cm ) ; } if ( pbi -> frame_parallel_decode ) { VPxWorker * const worker = pbi -> frame_worker_owner ; FrameWorkerData * const frame_worker_data = worker -> data1 ; vp9_frameworker_lock_stats ( worker ) ; if ( cm -> show_frame ) { cm -> current_video_frame ++ ; } frame_worker_data -> frame_decoded = 1 ; frame_worker_data -> frame_context_ready = 1 ; vp9_frameworker_signal_stats ( worker ) ; vp9_frameworker_unlock_stats ( worker ) ; } else { cm -> last_width = cm -> width ; cm -> last_height = cm -> height ; if ( cm -> show_frame ) { cm -> current_video_frame ++ ; } } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5369,"<S2SV_StartBug> r2 . re -> flags | RE_FLAGS_SCAN , <S2SV_EndBug> ","<S2SV_ModStart> 0 , "
5370,"<S2SV_StartBug> int_mv * prev_golden_ref_mv , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> ",<S2SV_ModStart> const MV <S2SV_ModEnd> <S2SV_ModStart> td . 
5371,<S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,<S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto free_kbuf ; } 
5372,"<S2SV_StartBug> void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <S2SV_EndBug> ",<S2SV_ModStart> static 
5373,<S2SV_StartBug> return TRUE ; <S2SV_EndBug> ,<S2SV_ModStart> if ( iter -> start == iter -> end ) iter -> end = g_utf8_next_char ( iter -> end ) ; 
5374,<S2SV_StartBug> for ( ( pad = w % 4 ) ? ( 4 - w % 4 ) : 0 ; pad > 0 ; pad -- ) <S2SV_EndBug> ,<S2SV_ModStart> pad = ( <S2SV_ModEnd> 
5375,<S2SV_StartBug> while ( c && which > 0 ) { <S2SV_EndBug> <S2SV_StartBug> c = c -> next ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , which -- ; <S2SV_ModEnd> "
5376,<S2SV_StartBug> set_caps ( ) ; <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> fs_rdonly ( RUN_SECCOMP_DIR ) ; # endif set_caps ( ) ; <S2SV_ModEnd> 
5377,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( info_ptr == NULL ) return ; 
5378,"<S2SV_StartBug> opj_write_bytes ( p_data , J2K_MS_SOD , <S2SV_EndBug> ","<S2SV_ModStart> if ( p_total_data_size < 4 ) { opj_event_msg ( p_manager , EVT_ERROR , ""Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOD<S2SV_blank>marker\\n"" ) ; return OPJ_FALSE ; } "
5379,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> snd_usb_mixer_disconnect ( mixer ) ; 
5380,<S2SV_StartBug> memcpy ( ( u8 * ) & priv -> curr_bss_params . bss_descriptor . <S2SV_EndBug> ,<S2SV_ModStart> if ( wmm_param_ie -> vend_hdr . len + 2 > sizeof ( struct ieee_types_wmm_parameter ) ) break ; 
5381,<S2SV_StartBug> usleep ( 200000 ) ; <S2SV_EndBug> ,<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
5382,<S2SV_StartBug> if ( ! del_timer ( & task -> slow_task -> timer ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5383,"<S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> ",<S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) 
5384,<S2SV_StartBug> ue -> info = * info ; <S2SV_EndBug> ,<S2SV_ModStart> card = card ; ue -> 
5385,"<S2SV_StartBug> truncate_pagecache ( inode , inode -> i_size ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_truncate ( inode ) ; <S2SV_EndBug> ",<S2SV_ModStart> down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem 
5386,<S2SV_StartBug> pid_t my_pid = getpid ( ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( g_settings_privatereports ) { if ( ( g_opts & OPT_x ) ) log ( ""Not<S2SV_blank>going<S2SV_blank>to<S2SV_blank>make<S2SV_blank>dump<S2SV_blank>directories<S2SV_blank>world<S2SV_blank>readable<S2SV_blank>because<S2SV_blank>PrivateReports<S2SV_blank>is<S2SV_blank>on"" ) ; mode = DEFAULT_DUMP_DIR_MODE ; my_euid = 0 ; } "
5387,"<S2SV_StartBug> UEV_PARSE ( ""num_reorder_pics"" , value , ps_bitstrm ) ; <S2SV_EndBug> <S2SV_StartBug> UEV_PARSE ( ""max_latency_increase"" , value , ps_bitstrm ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] > MAX_DPB_SIZE ) { return IHEVCD_INVALID_PARAMETER ; } <S2SV_ModStart> if ( ps_sps -> ai1_sps_max_num_reorder_pics [ i ] > ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] ) { return IHEVCD_INVALID_PARAMETER ; } 
5388,<S2SV_StartBug> key_put ( ci -> ci_keyring_key ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5389,"<S2SV_StartBug> if ( ! mx_is_imap ( path ) || imap_parse_path ( path , & mx ) || ! mx . mbox ) <S2SV_EndBug> <S2SV_StartBug> snprintf ( mbox , sizeof ( mbox ) , ""%smailboxes<S2SV_blank>\\""%s\\"""" , subscribe ? """" : ""un"" , path ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t len = 0 ; <S2SV_ModStart> len = <S2SV_ModStart> ""%smailboxes<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ) ; imap_quote_string ( mbox + len , sizeof ( mbox ) - len , path , true <S2SV_ModEnd> "
5390,<S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> ,<S2SV_ModStart> key_is_positive <S2SV_ModEnd> 
5391,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> skip_metadata ( ps ) ; 
5392,<S2SV_StartBug> if ( nsops < 1 ) <S2SV_EndBug> ,<S2SV_ModStart> || nsops > SEMOPM 
5393,"<S2SV_StartBug> vp8_sub_pixel_variance8x8 ( uptr , pre_stride , <S2SV_EndBug> <S2SV_StartBug> vp8_sub_pixel_variance8x8 ( vptr , pre_stride , <S2SV_EndBug> <S2SV_StartBug> vp8_variance8x8 ( uptr , pre_stride , <S2SV_EndBug> <S2SV_StartBug> vp8_variance8x8 ( vptr , pre_stride , <S2SV_EndBug> ",<S2SV_ModStart> vpx_sub_pixel_variance8x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_sub_pixel_variance8x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance8x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance8x8 <S2SV_ModEnd> 
5394,"<S2SV_StartBug> static void super_block_uvrd ( const VP9_COMP * cpi , MACROBLOCK * x , <S2SV_EndBug> <S2SV_StartBug> TX_SIZE uv_txfm_size = get_uv_tx_size ( mbmi ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ref_best_rd < 0 ) <S2SV_EndBug> <S2SV_StartBug> goto term ; <S2SV_EndBug> <S2SV_StartBug> if ( is_inter_block ( mbmi ) ) { <S2SV_EndBug> <S2SV_StartBug> ref_best_rd , plane , bsize , uv_txfm_size , <S2SV_EndBug> <S2SV_StartBug> goto term ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> const TX_SIZE uv_tx_size <S2SV_ModEnd> <S2SV_ModStart> , & xd -> plane [ 1 ] <S2SV_ModStart> int is_cost_valid = 1 ; <S2SV_ModStart> is_cost_valid = 0 <S2SV_ModEnd> <S2SV_ModStart> && is_cost_valid <S2SV_ModStart> uv_tx_size <S2SV_ModEnd> <S2SV_ModStart> { is_cost_valid = 0 ; break ; } <S2SV_ModEnd> <S2SV_ModStart> if ( ! is_cost_valid ) { * rate = INT_MAX ; * distortion = INT64_MAX ; * sse = INT64_MAX ; * skippable = 0 ; } return is_cost_valid <S2SV_ModEnd> "
5395,"<S2SV_StartBug> int sctp_verify_asconf ( const struct sctp_association * asoc , <S2SV_EndBug> <S2SV_StartBug> struct sctp_paramhdr * param_hdr , void * chunk_end , <S2SV_EndBug> <S2SV_StartBug> sctp_addip_param_t * asconf_param ; <S2SV_EndBug> <S2SV_StartBug> int length , plen ; <S2SV_EndBug> <S2SV_StartBug> param . v = ( sctp_paramhdr_t * ) param_hdr ; <S2SV_EndBug> ","<S2SV_ModStart> bool <S2SV_ModEnd> <S2SV_ModStart> sctp_chunk * chunk , bool addr_param_needed <S2SV_ModEnd> <S2SV_ModStart> sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) chunk -> chunk_hdr <S2SV_ModEnd> <S2SV_ModStart> bool addr_param_seen = false ; sctp_walk_params ( param , addip , addip_hdr . params ) { size_t length = ntohs ( param . p -> length ) ; * errp = param . p ; switch ( param . p -> type ) { case SCTP_PARAM_ERR_CAUSE : break ; case SCTP_PARAM_IPV4_ADDRESS : if ( length != sizeof ( sctp_ipv4addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_IPV6_ADDRESS : if ( length != sizeof ( sctp_ipv6addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : if ( addr_param_needed && ! addr_param_seen ) return false ; length = ntohs ( param . addip -> param_hdr . length ) ; if ( length < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return false ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return false ; break ; default : return false ; } } if ( addr_param_needed && ! addr_param_seen ) return false ; if ( ! addr_param_needed && addr_param_seen ) return false ; if ( <S2SV_ModEnd> <S2SV_ModStart> != chunk -> chunk_end ) return false ; return true <S2SV_ModEnd> "
5396,<S2SV_StartBug> assert ( ! vct_iscrlf ( * p ) ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ! vct_iscrlf ( * p ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vct_iscrlf ( * p ) ) { <S2SV_EndBug> <S2SV_StartBug> while ( ! vct_iscrlf ( * p ) ) <S2SV_EndBug> <S2SV_StartBug> if ( vct_iscrlf ( * p ) ) <S2SV_EndBug> <S2SV_StartBug> while ( * p != '\\0' && ! vct_iscrlf ( * p ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5397,"<S2SV_StartBug> spin_lock_irqsave ( & mpu -> input_lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> while ( readw ( mpu -> dev -> MIDQ + JQS_wTail ) != <S2SV_EndBug> <S2SV_StartBug> wTmp = readw ( mpu -> dev -> MIDQ + JQS_wHead ) + 1 ; <S2SV_EndBug> ","<S2SV_ModStart> u16 head , tail , size ; <S2SV_ModStart> head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ; tail = readw ( mpu -> dev -> MIDQ + JQS_wTail ) ; size = readw ( mpu -> dev -> MIDQ + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { unsigned char val = readw ( pwMIDQData + 2 * head ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , & val <S2SV_ModEnd> <S2SV_ModStart> if ( ++ head > size ) head = 0 ; writew ( head , <S2SV_ModEnd> <S2SV_ModStart> ; } out : <S2SV_ModEnd> "
5398,"<S2SV_StartBug> if ( vma -> vm_ops ) { <S2SV_EndBug> <S2SV_StartBug> pmd , flags , entry ) ; <S2SV_EndBug> <S2SV_StartBug> pte , pmd , flags ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pmd , flags , entry ) ; <S2SV_ModEnd> <S2SV_ModStart> pte , pmd , <S2SV_ModEnd> "
5399,<S2SV_StartBug> switch ( dip -> di_format ) { <S2SV_EndBug> ,"<S2SV_ModStart> fa = xfs_dinode_verify_fork ( dip , mp , XFS_DATA_FORK ) ; if ( fa ) return fa ; break ; case 0 : break ; default : return __this_address ; } if ( XFS_DFORK_Q ( dip ) ) { fa = xfs_dinode_verify_fork ( dip , mp , XFS_ATTR_FORK ) ; if ( fa ) return fa ; <S2SV_ModEnd> "
5400,"<S2SV_StartBug> it = item_get ( key , nkey , c , DO_UPDATE ) ; <S2SV_EndBug> ",<S2SV_ModStart> limited_get <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5401,"<S2SV_StartBug> strncpy ( hid -> name , req -> name , 128 ) ; <S2SV_EndBug> ",<S2SV_ModStart> sizeof ( req -> name ) - 1 <S2SV_ModEnd> 
5402,"<S2SV_StartBug> jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> ","<S2SV_ModStart> jas_matind_t numrows , jas_matind_t <S2SV_ModEnd> <S2SV_ModStart> jas_matind_t <S2SV_ModEnd> "
5403,"<S2SV_StartBug> struct ext4_ext_path * path ) <S2SV_EndBug> <S2SV_StartBug> struct ext4_extent * ex ; <S2SV_EndBug> <S2SV_StartBug> ext_debug ( ""ext4_convert_unwritten_extents_endio:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" <S2SV_EndBug> <S2SV_StartBug> ( unsigned long long ) le32_to_cpu ( ex -> ee_block ) , <S2SV_EndBug> ","<S2SV_ModStart> ext4_map_blocks * map , struct <S2SV_ModStart> ; ext4_lblk_t ee_block ; unsigned int ee_len <S2SV_ModStart> ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; <S2SV_ModStart> ee_block , ee_len ) ; if ( ee_block != map -> m_lblk || ee_len > map -> m_len ) { err = ext4_split_unwritten_extents ( handle , inode , map , path , EXT4_GET_BLOCKS_CONVERT ) ; if ( err < 0 ) goto out ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; goto out ; } depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; } <S2SV_ModEnd> "
5404,<S2SV_StartBug> char * prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; <S2SV_EndBug> ,"<S2SV_ModStart> prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total"" , ( int ) dff_chunk_header . ckDataSize ) ; "
5405,<S2SV_StartBug> int family = sk -> sk_family ; <S2SV_EndBug> <S2SV_StartBug> if ( addr_len ) { <S2SV_EndBug> <S2SV_StartBug> sin = ( struct sockaddr_in * ) msg -> msg_name ; <S2SV_EndBug> <S2SV_StartBug> if ( isk -> cmsg_flags ) <S2SV_EndBug> <S2SV_StartBug> sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ; <S2SV_EndBug> <S2SV_StartBug> IP6CB ( skb ) -> iif ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> struct sockaddr_in * <S2SV_ModStart> * addr_len = sizeof ( * sin ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sin6 = ( struct sockaddr_in6 * <S2SV_ModStart> ) ; * addr_len = sizeof ( * sin6 
5406,<S2SV_StartBug> if ( ! port -> interrupt_in_urb ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5407,"<S2SV_StartBug> if ( po -> rx_ring . pg_vec || po -> tx_ring . pg_vec ) <S2SV_EndBug> <S2SV_StartBug> return - EBUSY ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; switch ( val ) { case TPACKET_V1 : case TPACKET_V2 : case TPACKET_V3 : break ; default : return - EINVAL ; } lock_sock ( sk ) ; if ( <S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> ret = 0 ; } release_sock ( sk ) ; return ret ; <S2SV_ModEnd> "
5408,"<S2SV_StartBug> addModuleArgument ( db , pTab , sqlite3DbStrDup ( db , pTab -> zName ) ) ; <S2SV_EndBug> <S2SV_StartBug> addModuleArgument ( db , pTab , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> addModuleArgument ( db , pTab , sqlite3DbStrDup ( db , pTab -> zName ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> pParse <S2SV_ModEnd> <S2SV_ModStart> pParse <S2SV_ModEnd> <S2SV_ModStart> pParse <S2SV_ModEnd> 
5409,"<S2SV_StartBug> return write ( fd , & event , sizeof ( event ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
5410,"<S2SV_StartBug> str = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) count , sizeof ( * str ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> + 1 
5411,"<S2SV_StartBug> struct ip_options * opt = inet_rsk ( req ) -> opt ; <S2SV_EndBug> <S2SV_StartBug> ( opt && opt -> srr ) ? opt -> faddr : ireq -> rmt_addr , <S2SV_EndBug> <S2SV_StartBug> if ( opt && opt -> is_strictroute && rt -> rt_dst != rt -> rt_gateway ) <S2SV_EndBug> ",<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> opt . 
5412,<S2SV_StartBug> field [ nf ] = lp ; <S2SV_EndBug> <S2SV_StartBug> if ( nf > MAXDATEFIELDS ) <S2SV_EndBug> ,<S2SV_ModStart> ; if ( nf >= MAXDATEFIELDS ) return - 1 <S2SV_ModStart>  <S2SV_ModEnd> 
5413,"<S2SV_StartBug> int a = getnum ( L , fmt , MAXALIGN ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
5414,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> <S2SV_StartBug> for ( plane = 1 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) <S2SV_EndBug> ,<S2SV_ModStart> [ plane ] && frame -> linesize <S2SV_ModStart> && frame -> linesize [ plane ] 
5415,<S2SV_StartBug> if ( i > ( sizeof ( outbuff ) - 20 ) ) { <S2SV_EndBug> ,<S2SV_ModStart> 128 <S2SV_ModEnd> 
5416,"<S2SV_StartBug> static int test_candidate_kf ( struct twopass_rc * twopass , <S2SV_EndBug> <S2SV_StartBug> if ( ( this_frame -> pcnt_second_ref < 0.10 ) && <S2SV_EndBug> <S2SV_StartBug> ( next_frame -> pcnt_second_ref < 0.10 ) && <S2SV_EndBug> <S2SV_StartBug> DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) < 2.5 ) && <S2SV_EndBug> <S2SV_StartBug> DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) > 0.40 ) || <S2SV_EndBug> <S2SV_StartBug> DOUBLE_DIVIDE_CHECK ( this_frame -> intra_error ) > 0.40 ) || <S2SV_EndBug> <S2SV_StartBug> DOUBLE_DIVIDE_CHECK ( next_frame -> coded_error ) ) > 3.5 ) ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> double next_iiratio = ( IIKFACTOR1 * local_next_frame . intra_error / <S2SV_EndBug> <S2SV_StartBug> if ( next_iiratio > RMAX ) <S2SV_EndBug> ",<S2SV_ModStart> TWO_PASS <S2SV_ModEnd> <S2SV_ModStart> double pcnt_intra = 1.0 - this_frame -> pcnt_inter ; double modified_pcnt_inter = this_frame -> pcnt_inter - this_frame -> pcnt_neutral ; <S2SV_ModStart> SECOND_REF_USEAGE_THRESH <S2SV_ModEnd> <S2SV_ModStart> SECOND_REF_USEAGE_THRESH ) && ( ( this_frame -> pcnt_inter < VERY_LOW_INTER_THRESH ) || ( ( pcnt_intra > MIN_INTRA_LEVEL ) && ( pcnt_intra > ( INTRA_VS_INTER_THRESH * modified_pcnt_inter ) <S2SV_ModEnd> <S2SV_ModStart> KF_II_ERR_THRESHOLD <S2SV_ModEnd> <S2SV_ModStart> ERR_CHANGE_THRESHOLD <S2SV_ModEnd> <S2SV_ModStart> ERR_CHANGE_THRESHOLD <S2SV_ModEnd> <S2SV_ModStart> II_IMPROVEMENT_THRESHOLD <S2SV_ModEnd> <S2SV_ModStart> BOOST_FACTOR <S2SV_ModEnd> <S2SV_ModStart> KF_II_MAX ) next_iiratio = KF_II_MAX <S2SV_ModEnd> 
5417,<S2SV_StartBug> for ( j = 1 ; j <= len ; j ++ ) { <S2SV_EndBug> ,"<S2SV_ModStart> luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_array"" ) ; "
5418,<S2SV_StartBug> size_t maxlen = 3 * len ; <S2SV_EndBug> ,<S2SV_ModStart> + 8 
5419,<S2SV_StartBug> if ( data -> multi_easy ) <S2SV_EndBug> <S2SV_StartBug> curl_multi_cleanup ( data -> multi_easy ) ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> data -> multi_easy = NULL ; } 
5420,<S2SV_StartBug> while ( readw ( chip -> DSPQ + JQS_wTail ) != readw ( chip -> DSPQ + JQS_wHead ) ) { <S2SV_EndBug> <S2SV_StartBug> wTmp = readw ( chip -> DSPQ + JQS_wHead ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( wTmp > readw ( chip -> DSPQ + JQS_wSize ) ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> u16 head , tail , size ; head <S2SV_ModEnd> <S2SV_ModStart> ; tail = readw ( chip -> DSPQ + JQS_wTail ) ; size = <S2SV_ModEnd> <S2SV_ModStart> ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * head ) ) ; if ( ++ head > size ) head = 0 ; writew ( head <S2SV_ModEnd> <S2SV_ModStart> out : "
5421,<S2SV_StartBug> m = PyModule_Create ( & _astmodule3 ) ; <S2SV_EndBug> ,<S2SV_ModStart> _astmodule <S2SV_ModEnd> 
5422,"<S2SV_StartBug> if ( ( child -> ptrace & PT_PTRACED ) && child -> parent == current ) { <S2SV_EndBug> <S2SV_StartBug> spin_lock_irq ( & child -> sighand -> siglock ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ignore_state || ( task_is_traced ( child ) && <S2SV_EndBug> <S2SV_StartBug> ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ret && ! ignore_state ) <S2SV_EndBug> <S2SV_StartBug> ret = wait_task_inactive ( child , TASK_TRACED ) ? 0 : - ESRCH ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> WARN_ON ( child -> state == __TASK_TRACED <S2SV_ModEnd> <S2SV_ModStart> ptrace_freeze_traced ( child <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { if ( ! <S2SV_ModEnd> <S2SV_ModStart> __TASK_TRACED ) ) { WARN_ON ( child -> state == __TASK_TRACED ) ; ret = <S2SV_ModEnd> <S2SV_ModStart> } } 
5423,<S2SV_StartBug> kfree ( user ) ; <S2SV_EndBug> ,<S2SV_ModStart> cleanup_srcu_struct ( & user -> release_barrier ) ; 
5424,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5425,"<S2SV_StartBug> char * curl_cmd = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ! checkCurl ( ) ) { <S2SV_EndBug> <S2SV_StartBug> symbol_store_path = r_str_escape ( opt -> symbol_store_path ) ; <S2SV_EndBug> <S2SV_StartBug> abspath_to_archive = r_str_newf ( ""%s%s%s%s%s%s%s"" , <S2SV_EndBug> <S2SV_StartBug> const char * cabextractor = ""cabextract"" ; <S2SV_EndBug> <S2SV_StartBug> extractor_cmd = r_str_newf ( format , cabextractor , abspath_to_dir , abspath_to_archive ) ; <S2SV_EndBug> <S2SV_StartBug> eprintf ( ""Attempting<S2SV_blank>to<S2SV_blank>download<S2SV_blank>compressed<S2SV_blank>pdb<S2SV_blank>in<S2SV_blank>%s\\n"" , abspath_to_archive ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt -> extract > 0 ) { <S2SV_EndBug> <S2SV_StartBug> R_FREE ( curl_cmd ) ; <S2SV_EndBug> <S2SV_StartBug> res = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ( cmd_ret = r_sys_cmd ( curl_cmd ) != 0 ) ) { <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> char * abspath_to_file = r_str_newf ( ""%s%s%s%s%s%s%s"" , opt -> symbol_store_path , R_SYS_DIR , opt -> dbg_file , R_SYS_DIR , opt -> guid , R_SYS_DIR , opt -> dbg_file ) ; if ( r_file_exists ( abspath_to_file ) ) { eprintf ( ""File<S2SV_blank>already<S2SV_blank>downloaded.\\n"" ) ; free ( abspath_to_file ) ; return 1 ; } if ( checkExtract ( ) || opt -> extract == 0 ) { char * extractor_cmd = NULL ; char * archive_name = strdup ( opt -> dbg_file ) ; archive_name [ strlen ( archive_name ) <S2SV_ModEnd> <S2SV_ModStart> char * abspath_to_archive = r_str_newf ( ""%s%s%s%s%s%s%s"" , opt -> symbol_store_path , R_SYS_DIR , opt -> dbg_file , R_SYS_DIR , opt -> guid , R_SYS_DIR , archive_name ) ; eprintf ( ""Attempting<S2SV_blank>to<S2SV_blank>download<S2SV_blank>compressed<S2SV_blank>pdb<S2SV_blank>in<S2SV_blank>%s\\n"" , abspath_to_archive ) ; char * abs_arch_esc = r_str_escape_sh ( abspath_to_archive ) ; # if __WINDOWS__ char * abs_file_esc = r_str_escape_sh ( abspath_to_file ) ; extractor_cmd <S2SV_ModEnd> <S2SV_ModStart> ""expand<S2SV_blank>\\""%s\\""<S2SV_blank>\\""%s\\"""" , abs_arch_esc , abs_file_esc ) ; free ( abs_file_esc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> char * abs_dir_esc = r_str_escape_sh ( abspath_to_dir ) ; <S2SV_ModStart> ""cabextract<S2SV_blank>-d<S2SV_blank>\\""%s\\""<S2SV_blank>\\""%s\\"""" , abs_arch_esc , abs_dir_esc ) ; free ( abs_dir_esc ) ; free <S2SV_ModEnd> <S2SV_ModStart> free ( abs_arch_esc ) ; res = download_and_write ( opt , archive_name <S2SV_ModEnd> <S2SV_ModStart> && res ) { eprintf ( ""Attempting<S2SV_blank>to<S2SV_blank>decompress<S2SV_blank>pdb\\n"" ) ; if ( res && <S2SV_ModEnd> <S2SV_ModStart> free ( archive_name ) ; free ( abspath_to_archive <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> res = download_and_write ( opt , opt -> dbg_file ) ; } free ( abspath_to_file <S2SV_ModEnd> "
5426,<S2SV_StartBug> spl_handler_ArrayObject . get_debug_info = spl_array_get_debug_info ; <S2SV_EndBug> ,<S2SV_ModStart> ; spl_handler_ArrayObject . get_gc = spl_array_get_gc 
5427,<S2SV_StartBug> kfree ( cmd ) ; <S2SV_EndBug> ,"<S2SV_ModStart> kfree_skb ( ack_skb ) ; error_msg_to_dev : error_alloc : d_fnend ( 4 , dev , ""(wimax_dev<S2SV_blank>%p<S2SV_blank>state<S2SV_blank>%d)<S2SV_blank>=<S2SV_blank>%d\\n"" , wimax_dev , state , result ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
5428,"<S2SV_StartBug> } else if ( strcmp ( tokens [ 1 ] . value , ""mode"" ) == 0 && ntokens >= 3 && <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( tokens [ 1 ] . value , ""temp_ttl"" ) == 0 && ntokens >= 3 && <S2SV_EndBug> ",<S2SV_ModStart> 4 <S2SV_ModEnd> <S2SV_ModStart> 4 <S2SV_ModEnd> 
5429,"<S2SV_StartBug> ZeroMemory ( & credssp -> authInfo , sizeof ( SecBuffer ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; SecInvalidateHandle ( & credssp -> context 
5430,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && src -> data [ plane ] ; plane ++ ) <S2SV_EndBug> ,<S2SV_ModStart> [ plane ] && src -> linesize 
5431,"<S2SV_StartBug> int aff = sqlite3TableColumnAffinity ( pExpr -> y . pTab , pExpr -> iColumn ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( pExpr -> y . pTab ) { aff <S2SV_ModStart> } else { aff = pExpr -> affExpr ; } 
5432,<S2SV_StartBug> kfree ( inet -> opt ) ; <S2SV_EndBug> ,"<S2SV_ModStart> rcu_dereference_protected ( inet -> inet_opt , 1 ) <S2SV_ModEnd> "
5433,"<S2SV_StartBug> if ( ! c -> c_normalize && ! init_normalization ( c ) ) { <S2SV_EndBug> <S2SV_StartBug> PyTuple_SET_ITEM ( c -> c_normalize_args , 1 , id ) ; <S2SV_EndBug> <S2SV_StartBug> id2 = PyObject_Call ( c -> c_normalize , c -> c_normalize_args , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> PyObject * form ; PyObject * args [ 2 ] ; _Py_IDENTIFIER ( NFKC ) ; <S2SV_ModStart> form = _PyUnicode_FromId ( & PyId_NFKC ) ; if ( form == NULL ) { Py_DECREF ( id ) ; return NULL ; } args [ 0 ] = form ; args [ 1 ] = id ; id2 = _PyObject_FastCall <S2SV_ModEnd> <S2SV_ModStart> args , 2 ) ; Py_DECREF ( id ) ; if ( ! id2 ) return NULL ; if ( ! PyUnicode_Check ( id2 ) ) { PyErr_Format ( PyExc_TypeError , ""unicodedata.normalize()<S2SV_blank>must<S2SV_blank>return<S2SV_blank>a<S2SV_blank>string,<S2SV_blank>not<S2SV_blank>"" ""%.200s"" , Py_TYPE ( id2 ) -> tp_name ) ; Py_DECREF ( id2 ) ; return NULL ; } <S2SV_ModEnd> "
5434,<S2SV_StartBug> if ( pdu -> securityStateRef && <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> sptr = find_sec_mod ( newpdu -> securityModel ) ; if ( sptr && sptr -> pdu_clone ) { ret = sptr -> pdu_clone ( pdu , newpdu <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5435,"<S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , MB_ESCAPE_CODE_LEN ) == MB_ESCAPE_CODE ) <S2SV_EndBug> ",<S2SV_ModStart> && ps_stream -> u4_offset < ps_stream -> u4_max_offset 
5436,"<S2SV_StartBug> struct dw2102_state * state = d -> priv ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x02 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0x51 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0x0 ; <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data , 1 , state -> data <S2SV_ModEnd> <S2SV_ModStart> ) ; mutex_unlock ( & d -> data_mutex "
5437,"<S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> <S2SV_StartBug> * val = ( tmp & 0x80000000 ) ? ( - JAS_CAST ( longlong , ( ( ( ~ tmp ) & <S2SV_EndBug> <S2SV_StartBug> 0x7fffffff ) + 1 ) ) ) : JAS_CAST ( longlong , tmp ) ; <S2SV_EndBug> ",<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> <S2SV_ModStart> jas_longlong <S2SV_ModEnd> <S2SV_ModStart> jas_longlong <S2SV_ModEnd> 
5438,"<S2SV_StartBug> if ( perf_event_overflow ( event , 0 , data , regs ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
5439,"<S2SV_StartBug> mrb_value value ; <S2SV_EndBug> <S2SV_StartBug> fiber_check_cfunc ( mrb , c ) ; <S2SV_EndBug> <S2SV_StartBug> if ( resume && c -> status == MRB_FIBER_TRANSFERRED ) { <S2SV_EndBug> <S2SV_StartBug> if ( c -> status == MRB_FIBER_RUNNING || c -> status == MRB_FIBER_RESUMED ) { <S2SV_EndBug> <S2SV_StartBug> if ( c -> status == MRB_FIBER_TERMINATED ) { <S2SV_EndBug> <S2SV_StartBug> mrb -> c -> status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ; <S2SV_EndBug> <S2SV_StartBug> if ( c -> status == MRB_FIBER_CREATED ) { <S2SV_EndBug> <S2SV_StartBug> if ( len >= c -> stend - c -> stack ) { <S2SV_EndBug> <S2SV_StartBug> fiber_switch_context ( mrb , c ) ; <S2SV_EndBug> ","<S2SV_ModStart> enum mrb_fiber_state status ; <S2SV_ModStart> ; status = c -> status <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> old_c <S2SV_ModEnd> <S2SV_ModStart> fiber_switch_context ( mrb , c ) ; if ( <S2SV_ModEnd> <S2SV_ModStart> mrb_stack_extend ( mrb , len + 2 ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5440,"<S2SV_StartBug> n = s -> method -> ssl_get_message ( s , <S2SV_EndBug> <S2SV_StartBug> if ( ! ok ) return ( ( int ) n ) ; <S2SV_EndBug> <S2SV_StartBug> # ifndef OPENSSL_NO_PSK <S2SV_EndBug> <S2SV_StartBug> if ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK ) <S2SV_EndBug> ","<S2SV_ModStart> EVP_MD_CTX_init ( & md_ctx ) ; <S2SV_ModStart> ; alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey <S2SV_ModStart> if ( alg_k & ( SSL_kDHE | SSL_kECDHE ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } <S2SV_ModStart> alg_k & SSL_kPSK ) { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = NULL ; } # endif s -> s3 -> tmp . reuse_message = 1 ; return ( 1 ) ; } param = p = ( unsigned char * ) s -> init_msg ; if ( s -> session -> sess_cert != NULL ) { # ifndef OPENSSL_NO_RSA if ( s -> session -> sess_cert -> peer_rsa_tmp != NULL ) { RSA_free ( s -> session -> sess_cert -> peer_rsa_tmp ) ; s -> session -> sess_cert -> peer_rsa_tmp = NULL ; } # endif # ifndef OPENSSL_NO_DH if ( s -> session -> sess_cert -> peer_dh_tmp ) { DH_free ( s -> session -> sess_cert -> peer_dh_tmp ) ; s -> session -> sess_cert -> peer_dh_tmp = NULL ; } # endif # ifndef OPENSSL_NO_ECDH if ( s -> session -> sess_cert -> peer_ecdh_tmp ) { EC_KEY_free ( s -> session -> sess_cert -> peer_ecdh_tmp ) ; s -> session -> sess_cert -> peer_ecdh_tmp = NULL ; } # endif } else { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; } param_len = 0 ; alg_a = <S2SV_ModStart> algorithm_auth <S2SV_ModEnd> "
5441,"<S2SV_StartBug> static void write_mv_update ( const vp9_tree_index * tree , <S2SV_EndBug> <S2SV_StartBug> vp9_prob probs [ ] , <S2SV_EndBug> <S2SV_StartBug> int n , vp9_writer * w ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_tree_index <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_writer <S2SV_ModEnd> 
5442,<S2SV_StartBug> if ( val == 0 && sp -> do_auto_asconf ) { <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> spin_lock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; <S2SV_ModStart> spin_unlock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; 
5443,"<S2SV_StartBug> int len = mutt_b64_decode ( buffer , encoded ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( buffer ) "
5444,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5445,"<S2SV_StartBug> void vp9_iht4x4_16_add_c ( const int16_t * input , uint8_t * dest , int stride , <S2SV_EndBug> <S2SV_StartBug> { idct4 , idct4 } , <S2SV_EndBug> <S2SV_StartBug> int16_t out [ 4 * 4 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = out ; <S2SV_EndBug> <S2SV_StartBug> int16_t temp_in [ 4 ] , temp_out [ 4 ] ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < 4 ; ++ j ) <S2SV_EndBug> <S2SV_StartBug> dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 4 ) <S2SV_EndBug> <S2SV_StartBug> + dest [ j * stride + i ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> idct4_c , idct4_c } , { iadst4_c , idct4_c } , { idct4_c , iadst4_c } , { iadst4_c , iadst4_c <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> clip_pixel_add ( <S2SV_ModEnd> <S2SV_ModStart> , ROUND_POWER_OF_TWO ( temp_out [ j ] , 4 ) ) ; } <S2SV_ModEnd> "
5446,"<S2SV_StartBug> if ( ! chrooted && strncmp ( dir , home , strlen ( home ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart> rpath <S2SV_ModEnd> 
5447,<S2SV_StartBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5448,"<S2SV_StartBug> size_t l = 0 ; <S2SV_EndBug> <S2SV_StartBug> ptr += strspn ( ptr , ""\\r\\n\\t<S2SV_blank>"" ) ; <S2SV_EndBug> <S2SV_StartBug> l = strcspn ( ptr , ""\\r\\n\\t<S2SV_blank>"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> int wv , w1 , w2 , w3 , w4 ; int tmpval [ 4 ] ; int tmpcnt <S2SV_ModEnd> <S2SV_ModStart> while ( ptr < buf + len && ( * ptr == '<S2SV_blank>' || * ptr == '\\t' || * ptr == '\\n' || * ptr == '\\r' ) ) { ptr ++ ; } <S2SV_ModEnd> <S2SV_ModStart> if ( ( wv = base64_table [ ( int ) ( unsigned char ) * ptr ++ ] ) == - 1 ) { continue ; } tmpval [ tmpcnt ++ ] = wv ; if ( tmpcnt == 4 ) { tmpcnt = 0 ; w1 = tmpval [ 0 ] ; w2 = tmpval [ 1 ] ; w3 = tmpval [ 2 ] ; w4 = tmpval [ 3 ] ; if ( w2 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w1 << 2 ) + ( w2 >> 4 ) ) & 0xFF ) ; } if ( w3 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w2 << 4 ) + ( w3 >> 2 ) ) & 0xFF ) ; } if ( w4 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w3 << 6 ) + w4 ) & 0xFF ) ; } <S2SV_ModEnd> "
5449,<S2SV_StartBug> if ( likely ( walk . nbytes == nbytes ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5450,<S2SV_StartBug> rctx -> image_height = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 6 ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( rctx -> image_width < 1 || rctx -> image_height < 1 ) { iw_set_error ( rctx -> ctx , ""Invalid<S2SV_blank>image<S2SV_blank>dimensions"" ) ; goto done ; } "
5451,"<S2SV_StartBug> int tlen ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK ( * vqp_common_header ) ; <S2SV_EndBug> <S2SV_StartBug> vqp_obj_type = EXTRACT_32BITS ( vqp_obj_tlv -> obj_type ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( vqp_obj_type ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> case VQP_OBJ_MAC_NULL : <S2SV_EndBug> ",<S2SV_ModStart> u_int <S2SV_ModEnd> <S2SV_ModStart> ; if ( sizeof ( struct vqp_common_header_t ) > tlen ) goto trunc <S2SV_ModStart> ND_TCHECK ( * vqp_obj_tlv ) ; if ( sizeof ( struct vqp_obj_tlv_t ) > tlen ) goto trunc ; <S2SV_ModStart> if ( vqp_obj_len > tlen ) goto trunc ; <S2SV_ModStart> if ( vqp_obj_len != 4 ) goto trunc ; <S2SV_ModStart> if ( vqp_obj_len != ETHER_ADDR_LEN ) goto trunc ; 
5452,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && frame -> linesize [ plane ] 
5453,<S2SV_StartBug> exit_io_context ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> tsk 
5454,<S2SV_StartBug> if ( key_is_instantiated ( key ) ) { <S2SV_EndBug> ,<S2SV_ModStart> key_is_positive <S2SV_ModEnd> 
5455,<S2SV_StartBug> static void pcrypt_free ( struct crypto_instance * inst ) <S2SV_EndBug> <S2SV_StartBug> struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ; <S2SV_EndBug> ,<S2SV_ModStart> aead_instance <S2SV_ModEnd> <S2SV_ModStart> aead_instance_ctx <S2SV_ModEnd> 
5456,"<S2SV_StartBug> uint8_t value ; <S2SV_EndBug> <S2SV_StartBug> 0 , reg , & value , 1 , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> return ret >= 0 ? value : ret ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> * buffer ; uint8_t value ; buffer = kmalloc ( 1 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> buffer <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> ) { value = buffer [ 0 ] ; kfree ( buffer ) ; return value ; } else { kfree ( buffer ) ; return <S2SV_ModEnd> <S2SV_ModStart> } "
5457,"<S2SV_StartBug> int main_loop ( int argc , const char * * argv_ ) { <S2SV_EndBug> <S2SV_StartBug> int do_md5 = 0 , progress = 0 ; <S2SV_EndBug> <S2SV_StartBug> int ec_enabled = 0 ; <S2SV_EndBug> <S2SV_StartBug> vpx_codec_dec_cfg_t cfg = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> int frame_avail , got_data ; <S2SV_EndBug> <S2SV_StartBug> struct ExternalFrameBufferList ext_fb_list = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> struct VpxDecInputContext input = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> struct VpxInputContext vpx_input_ctx = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> struct WebmInputContext webm_ctx = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> input . vpx_input_ctx = & vpx_input_ctx ; <S2SV_EndBug> <S2SV_StartBug> } else if ( arg_match ( & arg , & use_i420 , argi ) ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( arg_match ( & arg , & flipuvarg , argi ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( arg_match ( & arg , & verbosearg , argi ) ) <S2SV_EndBug> <S2SV_StartBug> num_external_frame_buffers = arg_parse_uint ( & arg ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! fn ) <S2SV_EndBug> <S2SV_StartBug> usage_exit ( ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'"" , strcmp ( fn , ""-"" ) ? fn : ""stdin"" ) ; <S2SV_EndBug> <S2SV_StartBug> ""<S2SV_blank>try<S2SV_blank>--i420<S2SV_blank>or<S2SV_blank>--yv12.\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> ( ec_enabled ? VPX_CODEC_USE_ERROR_CONCEALMENT : 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & decoder , interface -> interface ( ) , & cfg , dec_flags ) ) { <S2SV_EndBug> <S2SV_StartBug> int corrupted ; <S2SV_EndBug> <S2SV_StartBug> goto fail ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> vpx_usec_timer_start ( & timer ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_control ( & decoder , VP8D_GET_FRAME_CORRUPTED , & corrupted ) ) { <S2SV_EndBug> <S2SV_StartBug> warn ( ""Failed<S2SV_blank>VP8_GET_FRAME_CORRUPTED:<S2SV_blank>%s"" , vpx_codec_error ( & decoder ) ) ; <S2SV_EndBug> <S2SV_StartBug> scaled_img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I420 , display_width , <S2SV_EndBug> <S2SV_StartBug> display_height , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_image_scale ( img , scaled_img , kFilterBox ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( frame_out == 1 ) { <S2SV_EndBug> <S2SV_StartBug> & vpx_input_ctx . framerate , img -> fmt ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( stop_after && frame_in >= stop_after ) <S2SV_EndBug> <S2SV_StartBug> if ( scaled_img ) vpx_img_free ( scaled_img ) ; <S2SV_EndBug> ","<S2SV_ModStart> static <S2SV_ModStart> , frame_parallel = 0 <S2SV_ModStart> = 0 ; int keep_going <S2SV_ModStart> int opt_yv12 = 0 ; int opt_i420 = 0 ; <S2SV_ModStart> , 0 , 0 } ; # if CONFIG_VP9_HIGHBITDEPTH int output_bit_depth = 0 ; # endif <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH vpx_image_t * img_shifted = NULL ; # endif <S2SV_ModStart> , flush_decoder = 0 <S2SV_ModStart> , NULL <S2SV_ModStart> NULL , NULL <S2SV_ModEnd> <S2SV_ModStart> ; # if CONFIG_WEBM_IO <S2SV_ModEnd> <S2SV_ModStart> ; memset ( & ( webm_ctx ) , 0 , sizeof ( webm_ctx ) ) <S2SV_ModEnd> <S2SV_ModStart> webm_ctx = & webm_ctx ; # endif input . <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> opt_yv12 = 1 ; # if CONFIG_VP9_HIGHBITDEPTH output_bit_depth = 8 ; # endif <S2SV_ModStart> opt_i420 = 1 ; <S2SV_ModStart> rawvideo , argi ) ) { use_y4m = 0 ; } else if ( arg_match ( & arg , & <S2SV_ModStart> # if CONFIG_VP9_DECODER || CONFIG_VP10_DECODER <S2SV_ModStart> frameparallelarg , argi ) ) frame_parallel = 1 ; # endif else if ( arg_match ( & arg , & <S2SV_ModStart> else if ( arg_match ( & arg , & continuearg , argi ) ) keep_going = 1 ; # if CONFIG_VP9_HIGHBITDEPTH else if ( arg_match ( & arg , & outbitdeptharg , argi ) ) { output_bit_depth = arg_parse_uint ( & arg ) ; } # endif <S2SV_ModStart> { free ( argv ) ; <S2SV_ModStart> } <S2SV_ModStart> fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>input<S2SV_blank>file<S2SV_blank>\'%s\'"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank>try<S2SV_blank>--i420<S2SV_blank>or<S2SV_blank>--yv12<S2SV_blank>or<S2SV_blank>--rawvideo.\\n"" <S2SV_ModEnd> <S2SV_ModStart> | ( frame_parallel ? VPX_CODEC_USE_FRAME_THREADING : 0 ) <S2SV_ModStart> codec_interface ( ) , <S2SV_ModEnd> <S2SV_ModStart> = 0 <S2SV_ModStart> if ( ! keep_going ) <S2SV_ModStart> else { flush_decoder = 1 ; } } else { flush_decoder = 1 ; <S2SV_ModStart> if ( flush_decoder ) { if ( vpx_codec_decode ( & decoder , NULL , 0 , NULL , 0 ) ) { warn ( ""Failed<S2SV_blank>to<S2SV_blank>flush<S2SV_blank>decoder:<S2SV_blank>%s"" , vpx_codec_error ( & decoder ) ) ; } } <S2SV_ModStart> ! frame_parallel && <S2SV_ModStart> if ( ! keep_going ) <S2SV_ModStart> img -> fmt <S2SV_ModEnd> <S2SV_ModStart> ; scaled_img -> bit_depth = img -> bit_depth <S2SV_ModStart> # if CONFIG_LIBYUV libyuv_scale <S2SV_ModEnd> <S2SV_ModStart> # else fprintf ( stderr , ""Failed<S2SV_blank><S2SV_blank>to<S2SV_blank>scale<S2SV_blank>output<S2SV_blank>frame:<S2SV_blank>%s.\\n"" ""Scaling<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>configuration.<S2SV_blank>"" ""To<S2SV_blank>enable<S2SV_blank>scaling,<S2SV_blank>configure<S2SV_blank>with<S2SV_blank>--enable-libyuv\\n"" , vpx_codec_error ( & decoder ) ) ; return EXIT_FAILURE ; # endif } } # if CONFIG_VP9_HIGHBITDEPTH if ( ! output_bit_depth ) { output_bit_depth = img -> bit_depth ; } if ( output_bit_depth != img -> bit_depth ) { const vpx_img_fmt_t shifted_fmt = output_bit_depth == 8 ? img -> fmt ^ ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) : img -> fmt | VPX_IMG_FMT_HIGHBITDEPTH ; if ( img_shifted && img_shifted_realloc_required ( img , img_shifted , shifted_fmt ) ) { vpx_img_free ( img_shifted ) ; img_shifted = NULL ; } if ( ! img_shifted ) { img_shifted = vpx_img_alloc ( NULL , shifted_fmt , img -> d_w , img -> d_h , 16 ) ; img_shifted -> bit_depth = output_bit_depth ; } if ( output_bit_depth > img -> bit_depth ) { vpx_img_upshift ( img_shifted , img , output_bit_depth - img -> bit_depth ) ; } else { vpx_img_downshift ( img_shifted , img , img -> bit_depth - output_bit_depth ) ; } img = img_shifted ; } # endif <S2SV_ModEnd> <S2SV_ModStart> img -> fmt == VPX_IMG_FMT_I440 || img -> fmt == VPX_IMG_FMT_I44016 ) { fprintf ( stderr , ""Cannot<S2SV_blank>produce<S2SV_blank>y4m<S2SV_blank>output<S2SV_blank>for<S2SV_blank>440<S2SV_blank>sampling.\\n"" ) ; goto fail ; } if ( <S2SV_ModStart> , img -> bit_depth <S2SV_ModStart> else { if ( frame_out == 1 ) { if ( opt_i420 ) { if ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_I42016 ) { fprintf ( stderr , ""Cannot<S2SV_blank>produce<S2SV_blank>i420<S2SV_blank>output<S2SV_blank>for<S2SV_blank>bit-stream.\\n"" ) ; goto fail ; } } if ( opt_yv12 ) { if ( ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_YV12 ) || img -> bit_depth != 8 ) { fprintf ( stderr , ""Cannot<S2SV_blank>produce<S2SV_blank>yv12<S2SV_blank>output<S2SV_blank>for<S2SV_blank>bit-stream.\\n"" ) ; goto fail ; } } } } <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( img_shifted ) vpx_img_free ( img_shifted ) ; # endif "
5458,"<S2SV_StartBug> if ( copy_from_user ( & tx32 , utp , sizeof ( struct compat_timex ) ) ) <S2SV_EndBug> ","<S2SV_ModStart> memset ( txc , 0 , sizeof ( struct timex ) ) ; "
5459,<S2SV_StartBug> if ( key_is_instantiated ( key ) ) { <S2SV_EndBug> ,<S2SV_ModStart> key_is_positive <S2SV_ModEnd> 
5460,"<S2SV_StartBug> return __blkdev_driver_ioctl ( fc -> dev -> bdev , fc -> dev -> mode , cmd , arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct dm_dev * dev = fc -> dev ; int r = 0 ; if <S2SV_ModEnd> <S2SV_ModStart> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( <S2SV_ModStart>  <S2SV_ModEnd> "
5461,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> ret = sscanf ( argv [ i ] + 1 , ""prestring=%s"" , buf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( len = strlen ( buf ) ) > L_BUF_SIZE - 3 ) { <S2SV_EndBug> <S2SV_StartBug> ret = sscanf ( argv [ i ] + 1 , ""protos=%s"" , buf ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""cpp<S2SV_blank>-ansi<S2SV_blank>-DNO_PROTOS<S2SV_blank>%s<S2SV_blank>%s"" , <S2SV_EndBug> ","<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> ""prestring=%490s"" <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> ""protos=%490s"" <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> "
5462,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.data.%d"" , gplot -> rootname , gplot -> nplots ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%f<S2SV_blank>%f\\n"" , valx , valy ) ; <S2SV_EndBug> ",<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> 
5463,"<S2SV_StartBug> struct mount * n , * p ; <S2SV_EndBug> <S2SV_StartBug> if ( p == dest_master || IS_MNT_MARKED ( p ) ) { <S2SV_EndBug> ","<S2SV_ModStart> ; bool done <S2SV_ModStart> break ; } do { struct mount * parent = last_source -> mnt_parent ; if ( last_source == first_source ) break ; done = parent -> mnt_master == p ; if ( done && peers ( n , parent ) ) break ; last_source = last_source -> mnt_master ; } while ( ! done ) ; <S2SV_ModEnd> "
5464,"<S2SV_StartBug> slapi_send_ldap_result ( pb , LDAP_NO_SUCH_OBJECT , NULL , NULL , 0 , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> slapi_send_ldap_result ( pb , LDAP_INAPPROPRIATE_AUTH , NULL , NULL , 0 , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS , NULL , NULL , 0 , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , ""Entry<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist"" ) ; slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS <S2SV_ModEnd> <S2SV_ModStart> slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , ""Entry<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>userpassword<S2SV_blank>set"" ) ; slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS <S2SV_ModEnd> <S2SV_ModStart> slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , ""Invalid<S2SV_blank>credentials"" ) ; "
5465,<S2SV_StartBug> vpn_packet_t outpkt ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( len > sizeof outpkt . data ) return 
5466,<S2SV_StartBug> last_source = source_mnt ; <S2SV_EndBug> ,<S2SV_ModStart> first_source = source_mnt ; 
5467,"<S2SV_StartBug> if ( ! inode -> i_op -> set_acl || ! IS_POSIXACL ( inode ) ) <S2SV_EndBug> <S2SV_StartBug> host_error = inode -> i_op -> set_acl ( inode , pacl , ACL_TYPE_ACCESS ) ; <S2SV_EndBug> <S2SV_StartBug> goto out_release ; <S2SV_EndBug> <S2SV_StartBug> host_error = inode -> i_op -> set_acl ( inode , dpacl , <S2SV_EndBug> <S2SV_StartBug> out_release : <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> fh_lock ( fhp ) ; host_error = set_posix_acl ( inode , ACL_TYPE_ACCESS , pacl <S2SV_ModEnd> <S2SV_ModStart> out_drop_lock <S2SV_ModEnd> <S2SV_ModStart> set_posix_acl ( inode , ACL_TYPE_DEFAULT , dpacl <S2SV_ModEnd> <S2SV_ModStart> out_drop_lock : fh_unlock ( fhp ) ; <S2SV_ModEnd> "
5468,<S2SV_StartBug> assert ( bi != NULL ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5469,"<S2SV_StartBug> unsigned long off ; <S2SV_EndBug> <S2SV_StartBug> if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) <S2SV_EndBug> <S2SV_StartBug> off = vma -> vm_pgoff << PAGE_SHIFT ; <S2SV_EndBug> <S2SV_StartBug> if ( fb -> fb_mmap ) { <S2SV_EndBug> <S2SV_StartBug> fb_pgprotect ( file , vma , off ) ; <S2SV_EndBug> ","<S2SV_ModStart> mmio_pgoff <S2SV_ModEnd> <S2SV_ModStart> fb = info -> fbops ; if ( ! fb ) return - ENODEV ; mutex_lock ( & info -> mm_lock ) ; if ( fb -> fb_mmap ) { int res ; res = fb -> fb_mmap ( info , vma ) ; mutex_unlock ( & info -> mm_lock ) ; return res ; } start = info -> fix . smem_start ; len = info -> fix . smem_len ; mmio_pgoff = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + len ) >> PAGE_SHIFT ; if ( <S2SV_ModEnd> <S2SV_ModStart> >= mmio_pgoff ) { vma -> vm_pgoff -= mmio_pgoff ; start = info -> fix . mmio_start ; len = info -> fix . mmio_len ; } mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> start ) ; return vm_iomap_memory ( vma , start , len ) <S2SV_ModEnd> "
5470,<S2SV_StartBug> spl_handler_ArrayObject . get_debug_info = spl_array_get_debug_info ; <S2SV_EndBug> ,<S2SV_ModStart> ; spl_handler_ArrayObject . get_gc = spl_array_get_gc 
5471,<S2SV_StartBug> if ( mainprog_ptr -> width > INT_MAX / mainprog_ptr -> height ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( mainprog_ptr -> rgba_data = malloc ( rowbytes * mainprog_ptr -> height ) ) == NULL ) { <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rowbytes > INT_MAX / mainprog_ptr -> height ) { png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if ( "
5472,"<S2SV_StartBug> const uint8_t * p , u_int length , u_int caplen ) <S2SV_EndBug> <S2SV_StartBug> if ( caplen <= 1 ) { <S2SV_EndBug> <S2SV_StartBug> print_unknown_data ( ndo , p , ""\\n\\t"" , caplen ) ; <S2SV_EndBug> <S2SV_StartBug> print_unknown_data ( ndo , p , ""\\n\\t"" , caplen ) ; <S2SV_EndBug> <S2SV_StartBug> if ( caplen > 1 ) <S2SV_EndBug> <S2SV_StartBug> print_unknown_data ( ndo , p , ""\\n\\t"" , caplen ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ! ND_TTEST ( * p ) <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> 
5473,<S2SV_StartBug> xmep -> proc = EXTRACT_32BITS ( & rp -> rm_call . cb_proc ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! ND_TTEST ( rp -> rm_call . cb_proc ) ) return ( 0 ) ; <S2SV_ModStart> ) ; if ( ! ND_TTEST ( rp -> rm_call . cb_vers ) ) return ( 0 
5474,<S2SV_StartBug> flush_rq -> mq_ctx = first_rq -> mq_ctx ; <S2SV_EndBug> <S2SV_StartBug> flush_rq -> tag = first_rq -> tag ; <S2SV_EndBug> ,"<S2SV_ModStart> struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> ; fq -> orig_rq = first_rq ; hctx = q -> mq_ops -> map_queue ( q , first_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , first_rq -> tag , flush_rq ) "
5475,<S2SV_StartBug> overrun = timr -> it_overrun_last ; <S2SV_EndBug> ,"<S2SV_ModStart> timer_overrun_to_int ( timr , 0 ) <S2SV_ModEnd> "
5476,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5477,<S2SV_StartBug> skipsize = LOGICAL_BLOCK_SIZE * vd -> location ; <S2SV_EndBug> <S2SV_StartBug> skipsize = LOGICAL_BLOCK_SIZE * vd -> location ; <S2SV_EndBug> ,<S2SV_ModStart> ( int64_t ) <S2SV_ModStart> ( int64_t ) 
5478,<S2SV_StartBug> if ( key_bytes_len < GROUP_KEY_MIN_LEN || key_bytes_len > eapol_len - sizeof ( EAPOL_RSN_KEY ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) || ( eapol_len < sizeof ( EAPOL_RSN_KEY ) ) || ( <S2SV_ModEnd> <S2SV_ModStart> ) 
5479,"<S2SV_StartBug> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , <S2SV_EndBug> <S2SV_StartBug> CRYPTO_MAX_ALG_NAME ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""larval"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> strncpy ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strncpy ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strncpy ( <S2SV_ModEnd> <S2SV_ModStart> sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 <S2SV_ModEnd> <S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> ""larval"" , sizeof ( rl . type ) <S2SV_ModEnd> "
5480,"<S2SV_StartBug> entries = kmalloc ( sizeof ( * entries ) * cmap -> len , GFP_KERNEL ) ; <S2SV_EndBug> ","<S2SV_ModStart> kmalloc_array ( cmap -> len , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> "
5481,<S2SV_StartBug> case LZX_BLOCKTYPE_UNCOMPRESSED : <S2SV_EndBug> ,"<S2SV_ModStart> if ( window_posn + this_run > lzx -> window_size ) { D ( ( ""match<S2SV_blank>ran<S2SV_blank>over<S2SV_blank>window<S2SV_blank>boundary"" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; } "
5482,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vp8_postproc_cfg_t * config = va_arg ( args , vp8_postproc_cfg_t * ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) ctr_id ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
5483,"<S2SV_StartBug> vpx_memset ( seg -> tree_probs , 255 , sizeof ( seg -> tree_probs ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> 
5484,"<S2SV_StartBug> jas_eprintf ( ""box<S2SV_blank>type<S2SV_blank>%s\\n"" , box -> info -> name ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""got<S2SV_blank>box<S2SV_blank>type<S2SV_blank>%s\\n"" <S2SV_ModEnd> "
5485,"<S2SV_StartBug> pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ; <S2SV_EndBug> ",<S2SV_ModStart> PAGE_KERNEL <S2SV_ModEnd> 
5486,"<S2SV_StartBug> wait_for_unix_gc ( ) ; <S2SV_EndBug> <S2SV_StartBug> unix_state_lock ( other ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_flag ( other , SOCK_DEAD ) ) { <S2SV_EndBug> <S2SV_StartBug> err = 0 ; <S2SV_EndBug> <S2SV_StartBug> unix_state_lock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> unix_peer ( sk ) = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( unix_peer ( other ) != sk && unix_recvq_full ( other ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! timeo ) { <S2SV_EndBug> <S2SV_StartBug> goto out_unlock ; <S2SV_EndBug> <S2SV_StartBug> timeo = unix_wait_for_peer ( other , timeo ) ; <S2SV_EndBug> <S2SV_StartBug> unix_state_unlock ( other ) ; <S2SV_EndBug> ","<S2SV_ModStart> int sk_locked ; <S2SV_ModStart> sk_locked = 0 ; <S2SV_ModStart> restart_locked : <S2SV_ModStart> unlikely ( <S2SV_ModStart> ) <S2SV_ModStart> if ( ! sk_locked ) unix_state_lock ( sk ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; unix_dgram_peer_wake_disconnect_wakeup ( sk , other ) <S2SV_ModStart> unlikely ( <S2SV_ModStart> ) { if ( timeo ) { timeo = unix_wait_for_peer ( other , timeo ) ; err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } <S2SV_ModEnd> <S2SV_ModStart> sk_locked ) { unix_state_unlock ( other ) ; unix_state_double_lock ( sk , other ) ; } if ( unix_peer ( sk ) != other || unix_dgram_peer_wake_me ( sk , other ) <S2SV_ModEnd> <S2SV_ModStart> sk_locked = 1 ; <S2SV_ModStart> if ( ! sk_locked ) { sk_locked = 1 ; goto restart_locked ; } } if ( unlikely ( sk_locked ) ) unix_state_unlock ( sk ) ; <S2SV_ModEnd> <S2SV_ModStart> if ( sk_locked ) unix_state_unlock ( sk ) ; "
5487,<S2SV_StartBug> alarm_timer = alarm_new ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! is_restricted_mode ( ) ) btif_config_remove_restricted ( config ) ; 
5488,"<S2SV_StartBug> # line 52 ""dt_test2.pgc"" <S2SV_EndBug> <S2SV_StartBug> # line 53 ""dt_test2.pgc"" <S2SV_EndBug> <S2SV_StartBug> # line 54 ""dt_test2.pgc"" <S2SV_EndBug> <S2SV_StartBug> # line 55 ""dt_test2.pgc"" <S2SV_EndBug> <S2SV_StartBug> # line 56 ""dt_test2.pgc"" <S2SV_EndBug> <S2SV_StartBug> # line 57 ""dt_test2.pgc"" <S2SV_EndBug> ",<S2SV_ModStart> 62 <S2SV_ModEnd> <S2SV_ModStart> 63 <S2SV_ModEnd> <S2SV_ModStart> 64 <S2SV_ModEnd> <S2SV_ModStart> 65 <S2SV_ModEnd> <S2SV_ModStart> 66 <S2SV_ModEnd> <S2SV_ModStart> 67 <S2SV_ModEnd> 
5489,"<S2SV_StartBug> if ( netal == 0 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s"" , etheraddr_string ( ndo , snpa ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> snpal == 6 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , snpal , etheraddr_string ( ndo , snpa ) ) ) ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , snpal , linkaddr_string ( ndo , snpa , LINKADDR_OTHER , snpal ) ) ) ; if ( netal != <S2SV_ModEnd> <S2SV_ModStart> ""\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u)<S2SV_blank>%s"" , netal , <S2SV_ModEnd> "
5490,<S2SV_StartBug> lua_newtable ( L ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_decode_to_lua_array"" "
5491,<S2SV_StartBug> struct hns_roce_ib_alloc_ucontext_resp resp ; <S2SV_EndBug> ,<S2SV_ModStart> = { } 
5492,<S2SV_StartBug> EXT4_DESC_PER_BLOCK ( sb ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ext4_has_feature_meta_bg ( sb ) ) { if ( le32_to_cpu ( es -> s_first_meta_bg ) >= db_count ) { ext4_msg ( sb , KERN_WARNING , ""first<S2SV_blank>meta<S2SV_blank>block<S2SV_blank>group<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>"" ""(group<S2SV_blank>descriptor<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%u)"" , le32_to_cpu ( es -> s_first_meta_bg ) , db_count ) ; goto failed_mount ; } } "
5493,<S2SV_StartBug> packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( alt -> desc . bNumEndpoints < 1 ) { sd -> gspca_dev . usb_err = - ENODEV ; return ; } 
5494,"<S2SV_StartBug> fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , mode > 0 ? mode : 0644 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ( mode == 0 || mode == MODE_INVALID ) ? 0644 : mode <S2SV_ModEnd> 
5495,<S2SV_StartBug> dev -> header_ops = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> 
5496,<S2SV_StartBug> if ( rdf_parser -> uri_filter ) <S2SV_EndBug> ,"<S2SV_ModStart> raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ; "
5497,"<S2SV_StartBug> if ( fd == - 1 ) ABRT ( EBADF , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>graphics<S2SV_blank>transmission<S2SV_blank>with<S2SV_blank>error:<S2SV_blank>[%d]<S2SV_blank>%s"" , fname , errno , strerror ( errno ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>file<S2SV_blank>for<S2SV_blank>graphics<S2SV_blank>transmission<S2SV_blank>with<S2SV_blank>error:<S2SV_blank>[%d]<S2SV_blank>%s"" <S2SV_ModEnd> "
5498,"<S2SV_StartBug> rds_info_copy ( iter , & minfo , sizeof ( minfo ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> minfo . flags = 0 ; 
5499,"<S2SV_StartBug> struct ip_options * opt ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( cork -> opt , opt , sizeof ( struct ip_options ) + opt -> optlen ) ; <S2SV_EndBug> ",<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> & opt -> <S2SV_ModStart> opt . 
5500,"<S2SV_StartBug> if ( snprintf ( spath , sizeof ( spath ) , var , iface ) >= sizeof ( spath ) ) <S2SV_EndBug> ","<S2SV_ModStart> ) ) return - 1 ; if ( strstr ( name , "".."" ) || strchr ( name , '/' "
5501,<S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> memset ( p , 0 , sizeof ( * p ) ) ; "
5502,"<S2SV_StartBug> assert_se ( touch_file ( path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) == 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> MODE_INVALID <S2SV_ModEnd> 
5503,"<S2SV_StartBug> const vp9_prob * context_tree , <S2SV_EndBug> ",<S2SV_ModStart> vpx_prob <S2SV_ModEnd> 
5504,"<S2SV_StartBug> strlcpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <S2SV_EndBug> <S2SV_StartBug> strlcpy ( ualg -> cru_driver_name , alg -> cra_driver_name , <S2SV_EndBug> <S2SV_StartBug> strlcpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , <S2SV_EndBug> <S2SV_StartBug> strlcpy ( rl . type , ""larval"" , sizeof ( rl . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> strncpy <S2SV_ModEnd> 
5505,"<S2SV_StartBug> if ( po -> rx_ring . pg_vec || po -> tx_ring . pg_vec ) <S2SV_EndBug> <S2SV_StartBug> return - EBUSY ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; switch ( val ) { case TPACKET_V1 : case TPACKET_V2 : case TPACKET_V3 : break ; default : return - EINVAL ; } lock_sock ( sk ) ; if ( <S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> ret = 0 ; } release_sock ( sk ) ; return ret ; <S2SV_ModEnd> "
5506,<S2SV_StartBug> usb_conv_info -> class_data = u3v_conv_info ; <S2SV_EndBug> ,<S2SV_ModStart> ; usb_conv_info -> class_data_type = USB_CONV_U3V ; } else if ( usb_conv_info -> class_data_type != USB_CONV_U3V ) { return 0 
5507,<S2SV_StartBug> len -= cut ; <S2SV_EndBug> ,<S2SV_ModStart> + 1 
5508,"<S2SV_StartBug> void vp9_iht8x8_64_add_c ( const int16_t * input , uint8_t * dest , int stride , <S2SV_EndBug> <S2SV_StartBug> int16_t out [ 8 * 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = out ; <S2SV_EndBug> <S2SV_StartBug> int16_t temp_in [ 8 ] , temp_out [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < 8 ; ++ j ) <S2SV_EndBug> <S2SV_StartBug> dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 5 ) <S2SV_EndBug> <S2SV_StartBug> + dest [ j * stride + i ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> clip_pixel_add ( <S2SV_ModEnd> <S2SV_ModStart> , ROUND_POWER_OF_TWO ( temp_out [ j ] , 5 ) ) ; } <S2SV_ModEnd> "
5509,<S2SV_StartBug> static size_t scanned ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
5510,"<S2SV_StartBug> if ( test_opt ( sbi , FLUSH_MERGE ) && ! f2fs_readonly ( sbi -> sb ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
5511,"<S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> ","<S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[256]<S2SV_blank>==<S2SV_blank>256<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\""baz\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""foo\\""]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""bar\\""]<S2SV_blank>==<S2SV_blank>\\""bar\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\""dummy\\"")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""foo\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""bar\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> "
5512,<S2SV_StartBug> len = file ? file -> size : 4096 ; <S2SV_EndBug> ,<S2SV_ModStart> && file -> size > 0 
5513,"<S2SV_StartBug> skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , <S2SV_EndBug> ",<S2SV_ModStart> msg -> msg_namelen = 0 ; 
5514,"<S2SV_StartBug> static int set_registers ( rtl8150_t * dev , u16 indx , u16 size , void * data ) <S2SV_EndBug> <S2SV_StartBug> return usb_control_msg ( dev -> udev , usb_sndctrlpipe ( dev -> udev , 0 ) , <S2SV_EndBug> <S2SV_StartBug> indx , 0 , data , size , 500 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> const <S2SV_ModStart> void * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> kfree ( buf ) ; return ret ; "
5515,<S2SV_StartBug> if ( * rsize >= 30 && rdesc [ 29 ] == 0x05 && rdesc [ 30 ] == 0x09 ) { <S2SV_EndBug> ,<S2SV_ModStart> 31 <S2SV_ModEnd> 
5516,<S2SV_StartBug> scratch = newscratch = malloc ( 2 * data -> set . buffer_size ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> UPLOAD_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> DEBUGASSERT ( UPLOAD_BUFSIZE >= nread ) ; 
5517,"<S2SV_StartBug> char * req_name [ ] = { ""Module"" , ""Expression"" , ""Interactive"" } ; <S2SV_EndBug> <S2SV_StartBug> assert ( 0 <= mode && mode <= 2 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , ""FunctionType"" <S2SV_ModStart> 3 <S2SV_ModEnd> "
5518,"<S2SV_StartBug> int n , len ; <S2SV_EndBug> <S2SV_StartBug> memset ( & facilities , 0x00 , sizeof ( struct rose_facilities_struct ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! rose_parse_facilities ( skb -> data + len + 4 , & facilities ) ) { <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ROSE_CALL_REQ_FACILITIES_OFF , skb -> len - ROSE_CALL_REQ_FACILITIES_OFF , <S2SV_ModEnd> "
5519,<S2SV_StartBug> case BGP_CAPCODE_MP : <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK_8BITS ( opt + i + 5 ) ; 
5520,<S2SV_StartBug> iPinCount = iACLen - 1 ; <S2SV_EndBug> ,<S2SV_ModStart> > 0 ? iACLen - 1 : 0 <S2SV_ModEnd> 
5521,<S2SV_StartBug> if ( ctx -> state == BODY_CHUNK_END ) { <S2SV_EndBug> <S2SV_StartBug> ctx -> state = BODY_CHUNK ; <S2SV_EndBug> <S2SV_StartBug> return APR_EGENERAL ; <S2SV_EndBug> <S2SV_StartBug> ctx -> chunkbits = sizeof ( long ) * 8 ; <S2SV_EndBug> <S2SV_StartBug> if ( c == ';' || c == CR ) { <S2SV_EndBug> <S2SV_StartBug> else if ( c == LF ) { <S2SV_EndBug> <S2SV_StartBug> int xvalue = 0 ; <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> return APR_EGENERAL ; <S2SV_EndBug> <S2SV_StartBug> ctx -> chunkbits -= 4 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> || ctx -> state == BODY_CHUNK_END_LF <S2SV_ModStart> ; } else if ( c == CR && ctx -> state == BODY_CHUNK_END ) { ctx -> state = BODY_CHUNK_END_LF ; } else { return APR_EINVAL <S2SV_ModStart> APR_EINVAL <S2SV_ModEnd> <S2SV_ModStart> apr_off_t <S2SV_ModEnd> <S2SV_ModStart> LF ) { if ( ctx -> remaining ) { ctx -> state = BODY_CHUNK_DATA ; } else { ctx -> state = BODY_CHUNK_TRAILER ; } } else if ( ctx -> state == BODY_CHUNK_LF ) { return APR_EINVAL ; } else if ( c == CR ) { ctx -> state = BODY_CHUNK_LF ; } else if ( c == ';' <S2SV_ModEnd> <S2SV_ModStart> ctx -> state == BODY_CHUNK_EXT ) { if ( c != '\\t' && apr_iscntrl ( c ) ) { return APR_EINVAL ; } } else if ( ctx -> state == BODY_CHUNK_PART <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; } ctx -> chunkbits -= 4 ; if ( ctx -> chunkbits < 0 ) { return APR_ENOSPC <S2SV_ModStart> APR_EINVAL <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> } else { return APR_EGENERAL ; 
5522,"<S2SV_StartBug> pdf = calloc ( 1 , sizeof ( pdf_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> pdf -> name = malloc ( strlen ( n ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> pdf -> name = malloc ( strlen ( ""Unknown"" ) + 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> safe_calloc ( <S2SV_ModEnd> <S2SV_ModStart> safe_calloc <S2SV_ModEnd> <S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
5523,<S2SV_StartBug> assert ( ( size & ( size - 1 ) ) == 0 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { pr_err ( ""%s:<S2SV_blank>Cannot<S2SV_blank>alloc<S2SV_blank>invalid<S2SV_blank>size<S2SV_blank>%lld<S2SV_blank>resource\\n"" , __func__ , size ) ; return - 1 ; } <S2SV_ModEnd> "
5524,"<S2SV_StartBug> krb5_data rspac ; <S2SV_EndBug> <S2SV_StartBug> krbtgt_out , <S2SV_EndBug> ","<S2SV_ModStart> ; const char * tgt_realm = krb5_principal_get_realm ( context , krbtgt -> entry . principal ) <S2SV_ModStart> tgt_realm , "
5525,<S2SV_StartBug> int is_valid ; <S2SV_EndBug> <S2SV_StartBug> giterr_clear ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> = ( error == GIT_OK ) <S2SV_ModStart>  <S2SV_ModEnd> 
5526,"<S2SV_StartBug> if ( ioctl ( slot -> fd , FIONREAD , size ) == 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
5527,<S2SV_StartBug> if ( ret != ARCHIVE_OK && ret != ARCHIVE_WARN ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> rar -> start_new_table = 1 ; } 
5528,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , sfar ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
5529,"<S2SV_StartBug> pkt = ctx -> iface -> enc . get_cx_data ( ctx -> priv -> alg_priv , iter ) ; <S2SV_EndBug> ",<S2SV_ModStart> get_alg_priv ( ctx ) <S2SV_ModEnd> 
5530,"<S2SV_StartBug> if ( vp9_segfeature_active ( seg , segment_id , SEG_LVL_ALT_Q ) ) { <S2SV_EndBug> <S2SV_StartBug> const int data = vp9_get_segdata ( seg , segment_id , SEG_LVL_ALT_Q ) ; <S2SV_EndBug> ",<S2SV_ModStart> segfeature_active <S2SV_ModEnd> <S2SV_ModStart> get_segdata <S2SV_ModEnd> 
5531,<S2SV_StartBug> config -> listeners [ config -> listener_count - 1 ] . security_options . password_file = config -> default_listener . security_options . password_file ; <S2SV_EndBug> ,<S2SV_ModStart> acl_file = config -> default_listener . security_options . acl_file ; config -> listeners [ config -> listener_count - 1 ] . security_options . 
5532,"<S2SV_StartBug> vpx_memcpy ( dest_ptr2 , src_ptr2 , plane_stride ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dest_ptr2 , src_ptr2 , plane_stride ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dest_ptr2 , src_ptr2 , plane_stride ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
5533,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> horDiff32 ( tif , cp0 , cc ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( ! <S2SV_ModStart> ) return 0 <S2SV_ModStart> return 1 ; 
5534,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( ( UWORD8 * ) ps_bitstrm -> pu4_buf > ps_bitstrm -> pu1_buf_max ) { return IHEVCD_INVALID_PARAMETER ; } 
5535,"<S2SV_StartBug> void vp9_encode_mv ( VP9_COMP * cpi , vp9_writer * w , <S2SV_EndBug> <S2SV_StartBug> if ( ! cpi -> dummy_packing && cpi -> sf . auto_mv_step_size ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> . mv 
5536,"<S2SV_StartBug> for ( out = escaped , len = 0 ; * text ; ++ len , ++ out , ++ text ) { <S2SV_EndBug> ","<S2SV_ModStart> if ( ! strlen ( text ) ) return ""empty<S2SV_blank>string"" ; "
5537,"<S2SV_StartBug> if ( cm -> last_frame_seg_map ) <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cm -> last_frame_seg_map , 0 , ( cm -> mi_rows * cm -> mi_cols ) ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_init_mode_probs ( & cm -> fc ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_init_mv_probs ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> frame_contexts [ i ] = cm -> fc ; <S2SV_EndBug> <S2SV_StartBug> cm -> frame_contexts [ cm -> frame_context_idx ] = cm -> fc ; <S2SV_EndBug> <S2SV_StartBug> if ( frame_is_intra_only ( cm ) ) <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cm -> prev_mip , 0 , cm -> mi_stride * ( cm -> mi_rows + 1 ) * <S2SV_EndBug> <S2SV_StartBug> sizeof ( * cm -> prev_mip ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> && ! cm -> frame_parallel_decode ) memset <S2SV_ModEnd> <S2SV_ModStart> , 0 , ( cm -> mi_rows * cm -> mi_cols ) ) ; if ( cm -> current_frame_seg_map ) memset ( cm -> current_frame_seg_map <S2SV_ModStart> init_mode_probs ( <S2SV_ModEnd> <S2SV_ModStart> ; cm -> fc -> initialized = 1 <S2SV_ModStart> * <S2SV_ModStart> * <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> && ! cm -> frame_parallel_decode ) memset ( cm -> prev_mip , 0 , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5538,<S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! head -> dev ) <S2SV_EndBug> <S2SV_StartBug> if ( qp -> user == IP_DEFRAG_CONNTRACK_IN && ! skb_dst ( head ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> const struct iphdr * iph ; int err ; <S2SV_ModStart> ) goto out_rcu_unlock ; skb_dst_drop ( head ) ; iph = ip_hdr ( head ) ; err = ip_route_input_noref ( head , iph -> daddr , iph -> saddr , iph -> tos , head -> dev ) ; if ( err <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
5539,<S2SV_StartBug> if ( track -> timescale > UINT16_MAX ) { <S2SV_EndBug> ,<S2SV_ModStart> || ! track -> par -> channels 
5540,<S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
5541,"<S2SV_StartBug> timag = ixheaacd_add32 ( i1 , r1 ) ; <S2SV_EndBug> <S2SV_StartBug> treal = ixheaacd_sub32 ( i2 , r2 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ixheaacd_add32_sat <S2SV_ModEnd> <S2SV_ModStart> ixheaacd_sub32_sat ( i2 , r2 ) ; treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; filter_states [ j ] = treal ; treal = ixheaacd_sub32_sat ( i1 , r1 ) ; treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; * filter_states ++ = treal ; timag = ixheaacd_add32_sat <S2SV_ModEnd> "
5542,"<S2SV_StartBug> assert ( ybf -> y_height - ybf -> y_crop_height < 16 ) ; <S2SV_EndBug> <S2SV_StartBug> extend_plane ( ybf -> y_buffer , ybf -> y_stride , <S2SV_EndBug> <S2SV_StartBug> ( ybf -> y_crop_width + 1 ) / 2 , ( ybf -> y_crop_height + 1 ) / 2 , <S2SV_EndBug> <S2SV_StartBug> ( ybf -> y_crop_width + 1 ) / 2 , ( ybf -> y_crop_height + 1 ) / 2 , <S2SV_EndBug> ","<S2SV_ModStart> const int uv_border = ybf -> border / 2 ; assert ( ybf -> border % 2 == 0 ) ; <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( ybf -> flags & YV12_FLAG_HIGHBITDEPTH ) { extend_plane_high ( ybf -> y_buffer , ybf -> y_stride , ybf -> y_crop_width , ybf -> y_crop_height , ybf -> border , ybf -> border , ybf -> border + ybf -> y_height - ybf -> y_crop_height , ybf -> border + ybf -> y_width - ybf -> y_crop_width ) ; extend_plane_high ( ybf -> u_buffer , ybf -> uv_stride , ybf -> uv_crop_width , ybf -> uv_crop_height , uv_border , uv_border , uv_border + ybf -> uv_height - ybf -> uv_crop_height , uv_border + ybf -> uv_width - ybf -> uv_crop_width ) ; extend_plane_high ( ybf -> v_buffer , ybf -> uv_stride , ybf -> uv_crop_width , ybf -> uv_crop_height , uv_border , uv_border , uv_border + ybf -> uv_height - ybf -> uv_crop_height , uv_border + ybf -> uv_width - ybf -> uv_crop_width ) ; return ; } # endif <S2SV_ModStart> ybf -> uv_crop_width , ybf -> uv_crop_height , uv_border , uv_border , uv_border + ybf -> uv_height - ybf -> uv_crop_height , uv_border + ybf -> uv_width - ybf -> uv_crop_width <S2SV_ModEnd> <S2SV_ModStart> ybf -> uv_crop_width , ybf -> uv_crop_height , uv_border , uv_border , uv_border + ybf -> uv_height - ybf -> uv_crop_height , uv_border + ybf -> uv_width - ybf -> uv_crop_width <S2SV_ModEnd> "
5543,<S2SV_StartBug> usb_autopm_put_interface ( serial -> interface ) ; <S2SV_EndBug> ,<S2SV_ModStart> info -> port = NULL ; 
5544,"<S2SV_StartBug> ""Key<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>the<S2SV_blank>null<S2SV_blank>string"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; return NULL ; } if ( IVlen != 0 && mode == MODE_ECB ) { PyErr_Format ( PyExc_ValueError , ""ECB<S2SV_blank>mode<S2SV_blank>does<S2SV_blank>not<S2SV_blank>use<S2SV_blank>IV"" ) ; return NULL ; } if ( IVlen != 0 && mode == MODE_CTR ) { PyErr_Format ( PyExc_ValueError , ""CTR<S2SV_blank>mode<S2SV_blank>needs<S2SV_blank>counter<S2SV_blank>parameter,<S2SV_blank>not<S2SV_blank>IV"" "
5545,"<S2SV_StartBug> cmd = kmalloc ( sizeof ( * cmd ) , GFP_KERNEL ) ; <S2SV_EndBug> ",<S2SV_ModStart> kzalloc <S2SV_ModEnd> 
5546,<S2SV_StartBug> assert ( proto != LLDP_MGMT_ADDR_NONE ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( proto == LLDP_MGMT_ADDR_NONE ) continue <S2SV_ModEnd> 
5547,<S2SV_StartBug> if ( tgt_clobbers & ~ site_clobbers ) <S2SV_EndBug> <S2SV_StartBug> if ( len < 5 ) <S2SV_EndBug> ,"<S2SV_ModStart> len < 5 ) { # ifdef CONFIG_RETPOLINE WARN_ONCE ( ""Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>CALL<S2SV_blank>in<S2SV_blank>%ps\\n"" , ( void * ) addr ) ; # endif <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModEnd> "
5548,<S2SV_StartBug> put_io_context ( p -> io_context ) ; <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> ) exit_io_context ( p 
5549,<S2SV_StartBug> if ( frame_end - frame < width + 3 ) <S2SV_EndBug> ,<S2SV_ModStart> 4 <S2SV_ModEnd> 
5550,<S2SV_StartBug> if ( mk_security_check_url ( sr -> uri ) < 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> uri_processed <S2SV_ModEnd> 
5551,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( s == 0 ) return ( ( void * ) NULL ) ; 
5552,"<S2SV_StartBug> static void read_quant_matrix_ext ( MpegEncContext * s , GetBitContext * gb ) <S2SV_EndBug> <S2SV_StartBug> if ( get_bits1 ( gb ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 64 ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> if ( get_bits1 ( gb ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 64 ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> return 0 ; 
5553,<S2SV_StartBug> if ( peer ) { <S2SV_EndBug> ,<S2SV_ModStart> lsa -> l2tp_unused = 0 ; 
5554,"<S2SV_StartBug> super_block_uvrd ( cpi , x , rate_tokenonly , distortion , <S2SV_EndBug> <S2SV_StartBug> * rate = * rate_tokenonly + x -> intra_uv_mode_cost [ cm -> frame_type ] [ DC_PRED ] ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) ; <S2SV_ModStart> cpi <S2SV_ModEnd> "
5555,<S2SV_StartBug> if ( isspace ( * s ) ) <S2SV_EndBug> ,<S2SV_ModStart> ( unsigned char ) 
5556,"<S2SV_StartBug> vpx_memcpy ( & best_mode -> mbmode , & x -> e_mbd . mode_info_context -> mbmi , sizeof ( MB_MODE_INFO ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & best_mode -> partition , x -> partition_info , sizeof ( PARTITION_INFO ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
5557,"<S2SV_StartBug> im = ( gdImage * ) gdCalloc ( 1 , sizeof ( gdImage ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( overflow2 ( sizeof ( unsigned char * ) , sx ) ) { return NULL ; } "
5558,<S2SV_StartBug> # if 0 <S2SV_EndBug> <S2SV_StartBug> p ++ ; s ++ ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
