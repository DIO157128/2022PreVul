,source,target
0,<S2SV_StartBug> data [ l ++ ] = SEG_REG_PREFIXES [ op -> operands [ 1 ] . regs [ 0 ] ] ; <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = 0x8b ; <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = offset ; <S2SV_EndBug> <S2SV_StartBug> return l ; <S2SV_EndBug> <S2SV_StartBug> if ( a -> bits == 64 ) { <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = 0x25 ; <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ; <S2SV_EndBug> <S2SV_StartBug> if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) { <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ; <S2SV_EndBug> ,<S2SV_ModStart> % 6 <S2SV_ModStart> data [ l ++ ] = ( ( ( ut32 ) op -> operands [ 0 ] . reg ) << 3 ) | 0x5 ; data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; return l ; } if ( a -> bits == 64 ) { if ( op -> operands [ 0 ] . type & OT_QWORD ) { if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { if ( op -> operands [ 1 ] . regs [ 0 ] != - 1 ) { data [ l ++ ] = 0x67 ; } data [ l ++ ] = 0x48 ; } } else if ( op -> operands [ 1 ] . type & OT_DWORD ) { data [ l ++ ] = 0x44 ; } else if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x67 ; } if ( op -> operands [ 1 ] . type & OT_QWORD && op -> operands [ 0 ] . type & OT_QWORD ) { data [ l ++ ] = 0x48 ; } } if ( op -> operands [ 0 ] . type & OT_WORD ) { data [ l ++ ] = 0x66 ; data [ l ++ ] = op -> operands [ 1 ] . type & OT_BYTE ? 0x8a : 0x8b ; } else { data [ l ++ ] = ( op -> operands [ 1 ] . type & OT_BYTE || op -> operands [ 0 ] . type & OT_BYTE ) ? 0x8a : 0x8b ; } if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_UNDEFINED ) { if ( a -> bits == 64 ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x4 ; data [ l ++ ] = 0x25 ; } else { <S2SV_ModStart> } <S2SV_ModStart> } else { if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ; if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) { base = 5 ; } if ( base ) { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 6 | op -> operands [ 1 ] . regs [ 0 ] << 3 | base ; } else { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 3 | op -> operands [ 1 ] . regs [ 0 ] ; } if ( offset || base ) { data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } <S2SV_ModStart> op -> operands [ 1 ] . regs [ 1 ] != X86R_UNDEFINED <S2SV_ModEnd> <S2SV_ModStart> op -> operands [ 1 ] . regs [ 1 ] << 3 | op -> operands [ 1 ] . regs [ 0 ] ; return l ; } if ( offset || op -> operands [ 1 ] . regs [ 0 ] == X86R_EBP ) { mod = 0x2 ; if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x4 ; } } if ( a -> bits == 64 && offset && op -> operands [ 0 ] . type & OT_QWORD ) { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) { data [ l ++ ] = 0x5 <S2SV_ModEnd> <S2SV_ModStart> if ( op -> operands [ 1 ] . offset > 127 ) { data [ l ++ ] = 0x80 | <S2SV_ModEnd> <S2SV_ModStart> op -> operands [ 1 ] . regs [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> data [ l ++ ] = 0x40 | op -> operands [ 1 ] . regs [ 0 ] ; } } if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x1 ; } } else { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_EIP && ( op -> operands [ 0 ] . type & OT_DWORD ) ) { data [ l ++ ] = 0x0d ; } else if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP && ( op -> operands [ 0 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x05 ; } else { data [ l ++ ] = mod << 5 | <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1,"<S2SV_StartBug> if ( mount ( console -> name , path , ""none"" , MS_BIND , 0 ) ) { <S2SV_EndBug> ","<S2SV_ModStart> safe_mount ( console -> name , path , ""none"" , MS_BIND , 0 , rootfs -> mount <S2SV_ModEnd> "
2,"<S2SV_StartBug> static int fsmVerify ( const char * path , rpmfi fi ) <S2SV_EndBug> <S2SV_StartBug> rc = fsmStat ( path , 0 , & dsb ) ; <S2SV_EndBug> <S2SV_StartBug> if ( S_ISDIR ( dsb . st_mode ) ) return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> , const struct stat * fsb <S2SV_ModStart> uid_t luid = dsb . st_uid ; <S2SV_ModStart> && ( luid == 0 || luid == fsb -> st_uid ) ) <S2SV_ModEnd> "
3,"<S2SV_StartBug> int r = ( int ) recv ( p_scb -> socket_id [ 1 ] , p_dcb -> p_tx_pkt , <S2SV_EndBug> <S2SV_StartBug> p_dcb -> mtu , MSG_DONTWAIT ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
4,<S2SV_StartBug> dentry -> d_fsdata = ( void * ) ns -> ops ; <S2SV_EndBug> ,<S2SV_ModStart> d_flags |= DCACHE_RCUACCESS ; dentry -> 
5,"<S2SV_StartBug> uint8_t * buf = mempool_alloc ( buf_pool ) ; <S2SV_EndBug> <S2SV_StartBug> uint8_t * ptr ; <S2SV_EndBug> <S2SV_StartBug> int n ; <S2SV_EndBug> <S2SV_StartBug> ptr = buf + sizeof ( pack -> hdr ) ; <S2SV_EndBug> <S2SV_StartBug> avp -> M = attr -> M ; <S2SV_EndBug> <S2SV_StartBug> avp -> length = sizeof ( * avp ) + attr -> length ; <S2SV_EndBug> <S2SV_StartBug> n = sendto ( sock , buf , ntohs ( pack -> hdr . length ) , 0 , <S2SV_EndBug> <S2SV_StartBug> if ( n != ntohs ( pack -> hdr . length ) ) { <S2SV_EndBug> <S2SV_StartBug> log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>write<S2SV_blank>(%i/%i)\\n"" , n , ntohs ( pack -> hdr . length ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct l2tp_hdr_t * hdr <S2SV_ModEnd> <S2SV_ModStart> buf , * <S2SV_ModStart> , len ; buf = mempool_alloc ( buf_pool <S2SV_ModEnd> <S2SV_ModStart> hdr = ( struct l2tp_hdr_t * ) buf ; ptr = ( uint8_t * ) ( hdr + 1 ) ; len = <S2SV_ModEnd> <S2SV_ModStart> flags = htons ( ( attr -> M ? L2TP_AVP_FLAG_M : 0 ) | ( attr -> H ? L2TP_AVP_FLAG_H : 0 ) | ( ( <S2SV_ModEnd> <S2SV_ModStart> ) & L2TP_AVP_LEN_MASK ) <S2SV_ModEnd> <S2SV_ModStart> hdr -> flags = htons ( pack -> hdr . flags ) ; <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> "
6,"<S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || <S2SV_EndBug> ","<S2SV_ModStart> > MAXDATELEN ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } switch ( dtype ) { case DTK_DATE : if ( tm2timestamp ( tm , fsec , NULL , & result <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
7,<S2SV_StartBug> if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { <S2SV_EndBug> ,<S2SV_ModStart> i_lenEAttr > bs || iinfo -> i_lenAlloc > bs ) goto out ; if ( udf_file_entry_alloc_offset ( inode ) + iinfo -> i_lenAlloc > bs ) goto out ; if ( iinfo -> 
8,"<S2SV_StartBug> ""zlib@openssh.com,zlib,none"" : ""none,zlib@openssh.com,zlib"" ; <S2SV_EndBug> ","<S2SV_ModStart> ""zlib@openssh.com,none"" : ""none,zlib@openssh.com"" <S2SV_ModEnd> "
9,<S2SV_StartBug> len = ( ms -> c . len += 20 ) * sizeof ( * ms -> c . li ) ; <S2SV_EndBug> ,<S2SV_ModStart> = 20 + level <S2SV_ModEnd> 
10,"<S2SV_StartBug> if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) <S2SV_EndBug> <S2SV_StartBug> if ( sk -> sk_state != TCP_CLOSE ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out_unlock ; if ( "
11,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> usb_conv_info -> class_data_type = USB_CONV_AUDIO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_AUDIO ) { return 0 ; 
12,<S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> ,<S2SV_ModStart> sas_eh_finish_cmd <S2SV_ModEnd> <S2SV_ModStart> sas_eh_finish_cmd <S2SV_ModEnd> <S2SV_ModStart> sas_eh_finish_cmd <S2SV_ModEnd> 
13,<S2SV_StartBug> void close_connection ( h2o_http2_conn_t * conn ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return - 1 ; } return 0 ; <S2SV_ModEnd> 
14,<S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug> ,<S2SV_ModStart> ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> 
15,<S2SV_StartBug> while ( res == 0 && dev ) { <S2SV_EndBug> <S2SV_StartBug> dev = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
16,"<S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> case CFM_CHASSIS_ID_MAC_ADDRESS : <S2SV_EndBug> <S2SV_StartBug> hexdump |= cfm_network_addr_print ( ndo , tptr ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> if ( mgmt_addr_length ) { <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> cfm_tlv_len -= mgmt_addr_length ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mgmt_addr_length ) { <S2SV_EndBug> <S2SV_StartBug> cfm_tlv_len -= mgmt_addr_length ; <S2SV_EndBug> <S2SV_StartBug> tptr += cfm_tlv_len ; <S2SV_EndBug> ","<S2SV_ModStart> goto next_tlv <S2SV_ModEnd> <S2SV_ModStart> goto next_tlv <S2SV_ModEnd> <S2SV_ModStart> goto next_tlv <S2SV_ModEnd> <S2SV_ModStart> if ( chassis_id_length != ETHER_ADDR_LEN ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>MAC<S2SV_blank>address<S2SV_blank>length)"" ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> + 1 , chassis_id_length <S2SV_ModStart> break <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Domain<S2SV_blank>Length<S2SV_blank>%u"" , mgmt_addr_length ) ) ; <S2SV_ModStart> goto next_tlv <S2SV_ModEnd> <S2SV_ModStart> ; hex_print ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Domain:<S2SV_blank>"" , tptr , mgmt_addr_length ) <S2SV_ModStart> ""<S2SV_blank>(Management<S2SV_blank>Address<S2SV_blank>Length<S2SV_blank>is<S2SV_blank>missing)"" ) ) ; hexdump = TRUE ; break <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Length<S2SV_blank>%u"" , mgmt_addr_length ) ) ; <S2SV_ModStart> ; hex_print ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address:<S2SV_blank>"" , tptr , mgmt_addr_length ) <S2SV_ModStart> next_tlv : "
17,"<S2SV_StartBug> jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> jpc_iict ( tile -> tcomps [ 0 ] . data , tile -> tcomps [ 1 ] . data , <S2SV_EndBug> ","<S2SV_ModStart> ) ; return - 1 ; } if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\n"" <S2SV_ModStart> if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\n"" ) ; return - 1 ; } "
18,<S2SV_StartBug> if ( ret ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> ptr -> kernel_data = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ptr -> next = NULL ; ptr -> buffer_length = 0 ; ptr -> kernel_data = NULL ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
19,"<S2SV_StartBug> if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) <S2SV_EndBug> <S2SV_StartBug> if ( ( strlen ( retname ) + rr -> len - 5 ) >= 254 ) { <S2SV_EndBug> <S2SV_StartBug> strncat ( retname , rr -> u . NM . name , rr -> len - 5 ) ; <S2SV_EndBug> <S2SV_StartBug> retnamlen += rr -> len - 5 ; <S2SV_EndBug> ","<S2SV_ModStart> char * p ; int len ; <S2SV_ModStart> len = <S2SV_ModEnd> <S2SV_ModStart> ; if ( retnamlen + len <S2SV_ModEnd> <S2SV_ModStart> p = memchr ( rr -> u . NM . name , '\\0' , len ) ; if ( unlikely ( p ) ) len = p - rr -> u . NM . name ; memcpy ( retname + retnamlen <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> len ; retname [ retnamlen ] = '\\0' <S2SV_ModEnd> "
20,<S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ( inbuffer = ReadInput ( inname ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> exit ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> return ( - 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
21,"<S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , delim ) ; <S2SV_EndBug> <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false <S2SV_ModStart> , false <S2SV_ModStart> , false <S2SV_ModStart> , false <S2SV_ModStart> , false "
22,"<S2SV_StartBug> static INLINE void right_shift_8x8 ( __m128i * res , int const bit ) { <S2SV_EndBug> <S2SV_StartBug> if ( bit_m02 >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> res [ 0 ] = _mm_srai_epi16 ( res [ 0 ] , bit ) ; <S2SV_EndBug> ","<S2SV_ModStart> const int bit ) { <S2SV_ModEnd> <S2SV_ModStart> bit == 2 ) { const __m128i const_rounding = _mm_set1_epi16 ( 1 ) ; res [ 0 ] = _mm_add_epi16 ( res [ 0 ] , const_rounding ) ; res [ 1 ] = _mm_add_epi16 ( res [ 1 ] , const_rounding ) ; res [ 2 ] = _mm_add_epi16 ( res [ 2 ] , const_rounding ) ; res [ 3 ] = _mm_add_epi16 ( res [ 3 ] , const_rounding ) ; res [ 4 ] = _mm_add_epi16 ( res [ 4 ] , const_rounding ) ; res [ 5 ] = _mm_add_epi16 ( res [ 5 ] , const_rounding ) ; res [ 6 ] = _mm_add_epi16 ( res [ 6 ] , const_rounding ) ; res [ 7 ] = _mm_add_epi16 ( res [ 7 ] , const_rounding <S2SV_ModEnd> <S2SV_ModStart> if ( bit == 1 ) { res [ 0 ] = _mm_srai_epi16 ( res [ 0 ] , 1 ) ; res [ 1 ] = _mm_srai_epi16 ( res [ 1 ] , 1 ) ; res [ 2 ] = _mm_srai_epi16 ( res [ 2 ] , 1 ) ; res [ 3 ] = _mm_srai_epi16 ( res [ 3 ] , 1 ) ; res [ 4 ] = _mm_srai_epi16 ( res [ 4 ] , 1 ) ; res [ 5 ] = _mm_srai_epi16 ( res [ 5 ] , 1 ) ; res [ 6 ] = _mm_srai_epi16 ( res [ 6 ] , 1 ) ; res [ 7 ] = _mm_srai_epi16 ( res [ 7 ] , 1 ) ; } else { res [ 0 ] = _mm_srai_epi16 ( res [ 0 ] , 2 ) ; res [ 1 ] = _mm_srai_epi16 ( res [ 1 ] , 2 ) ; res [ 2 ] = _mm_srai_epi16 ( res [ 2 ] , 2 ) ; res [ 3 ] = _mm_srai_epi16 ( res [ 3 ] , 2 ) ; res [ 4 ] = _mm_srai_epi16 ( res [ 4 ] , 2 ) ; res [ 5 ] = _mm_srai_epi16 ( res [ 5 ] , 2 ) ; res [ 6 ] = _mm_srai_epi16 ( res [ 6 ] , 2 ) ; res [ 7 ] = _mm_srai_epi16 ( res [ 7 ] , 2 ) ; } <S2SV_ModEnd> "
23,<S2SV_StartBug> if ( ! ext4_handle_valid ( handle ) ) <S2SV_EndBug> ,<S2SV_ModStart> EXT4_SB ( sb ) -> s_journal <S2SV_ModEnd> 
24,<S2SV_StartBug> newsk -> sk_mark = inet_rsk ( req ) -> ir_mark ; <S2SV_EndBug> ,<S2SV_ModStart> inet_sk ( newsk ) -> mc_list = NULL ; 
25,"<S2SV_StartBug> status = nfsd4_encode_bitmap ( xdr , NFSD_SUPPATTR_EXCLCREAT_WORD0 , <S2SV_EndBug> ","<S2SV_ModStart> u32 supp [ 3 ] ; memcpy ( supp , nfsd_suppattrs [ minorversion ] , sizeof ( supp ) ) ; supp [ 0 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD0 ; supp [ 1 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD1 ; supp [ 2 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD2 ; <S2SV_ModStart> supp [ 0 ] , supp [ 1 ] , supp [ 2 ] <S2SV_ModEnd> "
26,<S2SV_StartBug> if ( wsctx && wsctx -> readbuflen ) <S2SV_EndBug> ,<S2SV_ModStart> readlen <S2SV_ModEnd> 
27,"<S2SV_StartBug> const struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( np -> opt != NULL ) <S2SV_EndBug> <S2SV_StartBug> newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ; <S2SV_EndBug> <S2SV_StartBug> if ( newnp -> opt != NULL ) <S2SV_EndBug> <S2SV_StartBug> inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + <S2SV_EndBug> <S2SV_StartBug> newnp -> opt -> opt_flen ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; struct ipv6_txoptions * opt <S2SV_ModStart> opt = rcu_dereference <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( opt ) { <S2SV_ModEnd> <S2SV_ModStart> opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } <S2SV_ModEnd> <S2SV_ModStart> opt <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
28,<S2SV_StartBug> prev = NULL ; <S2SV_EndBug> <S2SV_StartBug> up_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! mmget_still_valid ( mm ) ) goto skip_mm ; <S2SV_ModStart> skip_mm : 
29,<S2SV_StartBug> pExpr -> iTable = pX -> iIdxCur ; <S2SV_EndBug> ,"<S2SV_ModStart> assert ( pExpr -> y . pTab != 0 ) ; pExpr -> affExpr = sqlite3TableColumnAffinity ( pExpr -> y . pTab , pExpr -> iColumn ) ; "
30,<S2SV_StartBug> char * path = server . diskstore_path ; <S2SV_EndBug> ,<S2SV_ModStart> ds_path <S2SV_ModEnd> 
31,"<S2SV_StartBug> Stream_Read_UINT32 ( s , scopeCount ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( Stream_GetRemainingLength ( s ) / sizeof ( LICENSE_BLOB ) < scopeCount ) return FALSE 
32,"<S2SV_StartBug> void vp9_idct4x4_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) { <S2SV_EndBug> <S2SV_StartBug> vp9_idct4x4_16_add ( input , dest , stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_idct4x4_1_add ( input , dest , stride ) ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_idct4x4_16_add <S2SV_ModEnd> <S2SV_ModStart> vpx_idct4x4_1_add <S2SV_ModEnd> 
33,<S2SV_StartBug> INST_HANDLER ( sts ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 4 ) { return ; } 
34,"<S2SV_StartBug> unsigned int maxw , maxh , max ; <S2SV_EndBug> <S2SV_StartBug> unsigned int i , j ; <S2SV_EndBug> <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0U ; i < maxh ; ++ i ) <S2SV_EndBug> <S2SV_StartBug> for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> <S2SV_StartBug> if ( j < maxw ) { <S2SV_EndBug> <S2SV_StartBug> # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_EndBug> <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> <S2SV_StartBug> if ( g ) free ( g ) ; <S2SV_EndBug> <S2SV_StartBug> if ( b ) free ( b ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> , offx , loopmaxw <S2SV_ModStart> size_t i <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; <S2SV_ModStart> size_t j ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } <S2SV_ModStart> loopmaxw <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> loopmaxw <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> <S2SV_ModStart> dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
35,"<S2SV_StartBug> int i , j , offset ; <S2SV_EndBug> <S2SV_StartBug> uint32_t loc ; <S2SV_EndBug> <S2SV_StartBug> struct sparablePartitionMap * spm = <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( udf_load_sparable_map ( sb , map , ( <S2SV_ModEnd> <S2SV_ModStart> ) gpm ) < 0 ) goto out_bh <S2SV_ModEnd> "
36,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( ret != 0 ) <S2SV_EndBug> <S2SV_StartBug> DATA_SYNC ( ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } if ( ps_dec -> u4_pic_buf_got == 1 ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec ) ; if ( ret != OK ) return ret ; } else { ret = ih264d_end_of_pic ( ps_dec ) ; if ( ret != OK ) return ret ; } } 
37,<S2SV_StartBug> if ( x < sx ) { <S2SV_EndBug> <S2SV_StartBug> j = x * size + b ; <S2SV_EndBug> <S2SV_StartBug> if ( y < sy && x < sx ) { <S2SV_EndBug> <S2SV_StartBug> j = ( ( x * sy + y ) * size ) + b ; <S2SV_EndBug> <S2SV_StartBug> if ( z < sz && y < sy && x < sx ) { <S2SV_EndBug> <S2SV_StartBug> ( ( char * ) data -> data ) [ j ] = output [ i ] ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( j >= 0 && j < elements * size ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( j >= 0 && j < elements * size ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( j >= 0 && j < elements * size ) { 
38,<S2SV_StartBug> ExprList_Init ( & state -> expr_list ) ; <S2SV_EndBug> ,<S2SV_ModStart> state -> fmode = 0 ; 
39,<S2SV_StartBug> return ret ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! ret ) invalidate_lstat_cache ( ) ; 
40,<S2SV_StartBug> if ( ! awaiting_character ) { <S2SV_EndBug> ,<S2SV_ModStart> || ! recovery_started 
41,"<S2SV_StartBug> int sent = send ( sock -> our_fd , buf , len , MSG_DONTWAIT ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
42,<S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( a ) ; 
43,"<S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_lineno ) ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_type ) ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExceptHandler"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>excepthandler"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""col_offset\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>excepthandler"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type = NULL ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_name , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; name = NULL ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExceptHandler"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> * out = ExceptHandler ( type , name , body , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
44,"<S2SV_StartBug> u8 reset ; <S2SV_EndBug> <S2SV_StartBug> hx = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ret = usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) ) != 1 ) <S2SV_EndBug> <S2SV_StartBug> kfree ( hx ) ; <S2SV_EndBug> <S2SV_StartBug> reset = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ret || usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) != 1 ) { <S2SV_EndBug> <S2SV_StartBug> kfree ( hx ) ; <S2SV_EndBug> ","<S2SV_ModStart> * buf <S2SV_ModEnd> <S2SV_ModStart> u16 cpu_cs_register = <S2SV_ModEnd> <S2SV_ModStart> ; buf = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; hx = ( struct hexline * ) buf ; buf [ 0 ] = 1 ; if ( usb_cypress_writemem ( udev , cpu_cs_register , buf , 1 <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> buf [ 0 ] = 0 ; if ( <S2SV_ModEnd> <S2SV_ModStart> cpu_cs_register , buf <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> "
45,"<S2SV_StartBug> void set_header ( HttpResponse res , const char * name , const char * value ) { <S2SV_EndBug> <S2SV_StartBug> h -> value = Str_dup ( value ) ; <S2SV_EndBug> ","<S2SV_ModStart> , ... <S2SV_ModStart> va_list ap ; va_start ( ap , value ) ; <S2SV_ModStart> Str_vcat ( value , ap ) ; va_end ( ap <S2SV_ModEnd> "
46,"<S2SV_StartBug> char * mask2 , * mask_decoded , * mask_decoded2 , * mask_decoded3 , * mask_decoded4 ; <S2SV_EndBug> <S2SV_StartBug> mask_decoded = NULL ; <S2SV_EndBug> <S2SV_StartBug> mask2 = weechat_string_replace ( mask , dir_separator , ""\\01"" ) ; <S2SV_EndBug> <S2SV_StartBug> mask_decoded5 = malloc ( length ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! mask_decoded5 ) <S2SV_EndBug> <S2SV_StartBug> mask_decoded5 [ 0 ] = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> strftime ( mask_decoded5 , length - 1 , mask_decoded4 , date_tmp ) ; <S2SV_EndBug> <S2SV_StartBug> weechat_string_tolower ( mask_decoded5 ) ; <S2SV_EndBug> <S2SV_StartBug> mask , mask_decoded5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mask_decoded ) <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded ) ; <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded2 ) ; <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded3 ) ; <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded4 ) ; <S2SV_EndBug> <S2SV_StartBug> return mask_decoded5 ; <S2SV_EndBug> ","<S2SV_ModStart> mask3 , * mask4 , * mask5 , * mask6 , * mask7 <S2SV_ModEnd> <S2SV_ModStart> mask3 = NULL ; mask4 = NULL ; mask5 = NULL ; mask6 = NULL ; mask7 <S2SV_ModEnd> <S2SV_ModStart> length = strlen ( mask <S2SV_ModEnd> <S2SV_ModStart> mask2 <S2SV_ModEnd> <S2SV_ModStart> mask2 <S2SV_ModEnd> <S2SV_ModStart> mask2 <S2SV_ModEnd> <S2SV_ModStart> if ( strftime ( mask2 <S2SV_ModEnd> <S2SV_ModStart> mask <S2SV_ModEnd> <S2SV_ModStart> == 0 ) mask2 [ 0 ] = '\\0' ; mask3 = weechat_string_replace ( mask2 , dir_separator , ""\\01"" ) ; if ( ! mask3 ) goto end ; mask4 = weechat_buffer_string_replace_local_var ( buffer , mask3 ) ; if ( ! mask4 ) goto end ; mask5 = weechat_string_replace ( mask4 , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ; if ( ! mask5 ) goto end ; # ifdef __CYGWIN__ mask6 = weechat_string_replace ( mask5 , ""\\\\"" , weechat_config_string ( logger_config_file_replacement_char ) ) ; # else mask6 = strdup ( mask5 ) ; # endif if ( ! mask6 ) goto end ; mask7 = weechat_string_replace ( mask6 , ""\\01"" , dir_separator ) ; if ( ! mask7 ) goto end <S2SV_ModStart> mask7 <S2SV_ModEnd> <S2SV_ModStart> mask7 <S2SV_ModEnd> <S2SV_ModStart> mask3 <S2SV_ModEnd> <S2SV_ModStart> mask3 ) ; if ( mask4 <S2SV_ModEnd> <S2SV_ModStart> mask4 ) ; if ( mask5 <S2SV_ModEnd> <S2SV_ModStart> mask5 ) ; if ( mask6 <S2SV_ModEnd> <S2SV_ModStart> mask6 <S2SV_ModEnd> <S2SV_ModStart> mask7 <S2SV_ModEnd> "
47,<S2SV_StartBug> xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) && <S2SV_EndBug> ,<S2SV_ModStart> if ( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize ) { <S2SV_ModStart> } else { xWantedSize = 0 ; } <S2SV_ModStart> ( xWantedSize > 0 ) && 
48,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> jmp_rel ( ctxt , rel ) ; <S2SV_EndBug> ",<S2SV_ModStart> int rc ; <S2SV_ModStart> rc = <S2SV_ModStart> ; if ( rc != X86EMUL_CONTINUE ) return rc 
49,"<S2SV_StartBug> if ( ( transfer_encoding != NULL ) && ( strstr ( transfer_encoding , ""chunked"" ) != NULL ) ) { <S2SV_EndBug> ",<S2SV_ModStart> m_strcasestr <S2SV_ModEnd> 
50,<S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> <S2SV_StartBug> return get_desc_base ( desc ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_desc ( & desc , sel ) <S2SV_ModEnd> <S2SV_ModStart> & "
51,<S2SV_StartBug> if ( read != entry . uncompressed_filesize ) { <S2SV_EndBug> ,<S2SV_ModStart> || read <= 8 
52,"<S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ret ) { <S2SV_EndBug> <S2SV_StartBug> uwq = list_first_entry ( & fork_event , <S2SV_EndBug> <S2SV_StartBug> userfaultfd_event_complete ( ctx , uwq ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug> ",<S2SV_ModStart> userfaultfd_ctx_get ( fork_nctx ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> userfaultfd_ctx_put ( fork_nctx ) ; <S2SV_ModStart> if ( likely ( ! ret ) ) <S2SV_ModStart> else { if ( ret ) userfaultfd_ctx_put ( fork_nctx ) ; } spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_ModEnd> 
53,"<S2SV_StartBug> vp9_subtract_block ( bh , bw , p -> src_diff , bw , p -> src . buf , p -> src . stride , <S2SV_EndBug> ","<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( x -> e_mbd . cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vpx_highbd_subtract_block ( bh , bw , p -> src_diff , bw , p -> src . buf , p -> src . stride , pd -> dst . buf , pd -> dst . stride , x -> e_mbd . bd ) ; return ; } # endif vpx_subtract_block <S2SV_ModEnd> "
54,<S2SV_StartBug> static unsigned short len = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> 
55,"<S2SV_StartBug> return g_NPN_GetValue_real ( instance , variable , value ) ; <S2SV_EndBug> ",<S2SV_ModStart> case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling : 
56,"<S2SV_StartBug> ( IN_DEV_SHARED_MEDIA ( out_dev ) || <S2SV_EndBug> <S2SV_StartBug> inet_addr_onlink ( out_dev , saddr , FIB_RES_GW ( * res ) ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart> skb -> protocol == htons ( ETH_P_IP ) && <S2SV_ModStart> IPCB ( skb ) -> flags |= IPSKB_DOREDIRECT ; <S2SV_ModEnd> 
57,"<S2SV_StartBug> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
58,"<S2SV_StartBug> cifs_find_smb_ses ( struct TCP_Server_Info * server , char * username ) <S2SV_EndBug> <S2SV_StartBug> list_for_each ( tmp , & server -> smb_ses_list ) { <S2SV_EndBug> <S2SV_StartBug> if ( strncmp ( ses -> userName , username , MAX_USERNAME_SIZE ) ) <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> ","<S2SV_ModStart> struct smb_vol * vol ) { <S2SV_ModEnd> <S2SV_ModStart> list_for_each_entry ( ses <S2SV_ModEnd> <S2SV_ModStart> , smb_ses_list ) { switch ( server -> secType ) { case Kerberos : if ( vol -> linux_uid != ses -> linux_uid ) continue ; break ; default : <S2SV_ModEnd> <S2SV_ModStart> vol -> <S2SV_ModStart> if ( strlen ( vol -> username ) != 0 && strncmp ( ses -> password , vol -> password , MAX_PASSWORD_SIZE ) ) continue ; } "
59,"<S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> ",<S2SV_ModStart> rc = <S2SV_ModStart> rc = <S2SV_ModStart> rc = 
60,<S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 4 ) <S2SV_EndBug> <S2SV_StartBug> p ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ( image -> columns % 4 ) >= 1 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( image -> columns % 4 ) >= 2 ) <S2SV_EndBug> ,<S2SV_ModStart> 3 <S2SV_ModEnd> <S2SV_ModStart> q ++ ; p <S2SV_ModEnd> <S2SV_ModStart> > <S2SV_ModEnd> <S2SV_ModStart> > <S2SV_ModEnd> 
61,"<S2SV_StartBug> skb = sock_alloc_send_skb ( sk , <S2SV_EndBug> <S2SV_StartBug> skb -> csum = 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> struct frag_hdr fhdr ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) <S2SV_ModEnd> "
62,"<S2SV_StartBug> PIXA * pixa ; <S2SV_EndBug> <S2SV_StartBug> pix1 = pixaDisplayTiledAndScaled ( pixa , 32 , 400 , 4 , 0 , 20 , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> pixDisplayWithTitle ( pix1 , 100 , 0 , NULL , rp -> display ) ; <S2SV_EndBug> <S2SV_StartBug> pixDestroy ( & pix1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , * pixa2 <S2SV_ModStart> pixa2 = pixaCreate ( 3 ) ; pix1 = pixRead ( ""weasel8.png"" ) ; pixGammaTRC ( pix1 , pix1 , 1.0 , 0 , 270 ) ; pixaAddPix ( pixa2 , pix1 , L_COPY ) ; pixGetDimensions ( pix1 , & w , & h , NULL ) ; pixRasterop ( pix1 , 0 , 0 , 5 , h , PIX_SET , NULL , 0 , 0 ) ; pixRasterop ( pix1 <S2SV_ModEnd> <S2SV_ModStart> 0 , 2 , h , PIX_SET , NULL , 0 , 0 ) ; pixRasterop ( pix1 , 40 , 0 , 3 , h , PIX_SET , NULL , 0 , 0 ) ; pixRasterop ( pix1 , 0 , 0 , w , 3 , PIX_SET , NULL , 0 , 0 ) ; pixRasterop ( pix1 , 0 , 15 , w , 3 , PIX_SET , NULL , 0 , 0 ) ; pixRasterop ( pix1 , 0 , 35 , w , 2 , PIX_SET , NULL , 0 , 0 ) ; pixaAddPix ( pixa2 , pix1 , L_COPY ) ; pixFillMapHoles ( pix1 , w , h , L_FILL_WHITE ) ; pixaAddPix ( pixa2 , pix1 , L_INSERT ) ; pix2 = pixaDisplayTiledInColumns ( pixa2 , 3 , 1.0 , 20 , 1 ) ; regTestWritePixAndCheck ( rp , pix2 , IFF_PNG <S2SV_ModEnd> <S2SV_ModStart> pix2 , 50 , 850 <S2SV_ModEnd> <S2SV_ModStart> pixaDestroy ( & pixa2 ) ; pixDestroy ( & pix2 ) ; pix1 = pixaDisplayTiledAndScaled ( pixa , 32 , 400 , 4 , 0 , 20 , 2 ) ; pixWrite ( ""/tmp/lept/adapt/results.jpg"" , pix1 , IFF_JFIF_JPEG ) ; pixDisplayWithTitle ( pix1 , 50 , 0 , NULL , rp -> display ) ; "
63,"<S2SV_StartBug> strncpy ( str , ""?["" , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> espruino_snprintf ( str , len , ""?[%d]"" , token <S2SV_ModEnd> "
64,"<S2SV_StartBug> static void count_segs ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 , <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> xd -> mi = mi_8x8 ; <S2SV_EndBug> <S2SV_StartBug> const BLOCK_SIZE bsize = mi_8x8 [ 0 ] -> mbmi . sb_type ; <S2SV_EndBug> <S2SV_StartBug> const int pred_segment_id = vp9_get_segment_id ( cm , cm -> last_frame_seg_map , <S2SV_EndBug> ","<S2SV_ModStart> const VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> xd -> mi <S2SV_ModEnd> <S2SV_ModStart> get_segment_id <S2SV_ModEnd> "
65,<S2SV_StartBug> if ( dst == NULL || src == NULL ) return ERROR ; <S2SV_EndBug> ,<S2SV_ModStart> ) return ERROR ; if ( src -> entry_count + dst -> entry_count < src -> entry_count ) return ERROR ; if ( src -> data_count + dst -> data_count < src -> data_count 
66,"
","
"
67,"<S2SV_StartBug> cmpt -> stream_ = ( inmem ) ? jas_stream_memopen ( 0 , size ) : <S2SV_EndBug> ",<S2SV_ModStart> jas_stream_memopen2 <S2SV_ModEnd> 
68,<S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> ,<S2SV_ModStart> dev_kfree_skb ( skb ) ; 
69,<S2SV_StartBug> malloc_called += 1 ; <S2SV_EndBug> ,<S2SV_ModStart> = <S2SV_ModEnd> 
70,"<S2SV_StartBug> StringBuffer_append ( res -> outputbuffer , ""%s"" , buf ) ; <S2SV_EndBug> ",<S2SV_ModStart> escapeHTML ( res -> outputbuffer <S2SV_ModEnd> 
71,<S2SV_StartBug> if ( * rsize >= 60 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 && <S2SV_EndBug> ,<S2SV_ModStart> 62 <S2SV_ModEnd> 
72,<S2SV_StartBug> if ( index > MAX_SUPPORTED_TV_TIMING ) <S2SV_EndBug> <S2SV_StartBug> if ( index > MAX_SUPPORTED_TV_TIMING_V1_2 ) <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> <S2SV_ModStart> >= <S2SV_ModEnd> 
73,<S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( t + 3 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( 2 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( 2 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( 2 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( likely ( HAVE_OP ( t + 15 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( HAVE_IP ( 6 ) ) { <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> <S2SV_StartBug> if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( t + 3 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , 0 <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , 0 <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , 0 "
74,<S2SV_StartBug> boolean_t owner = B_FALSE ; <S2SV_EndBug> <S2SV_StartBug> mutex_enter ( & zdp -> z_acl_lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> is_attr <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
75,"<S2SV_StartBug> if ( ( o2 + 10 < o2 ) || ( o2 + 10 < 10 ) || ( o2 + 10 > buf_size ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( o2 + 4 < o2 ) || ( o2 + 4 < 4 ) || ( o2 + 4 > buf_size ) ) return ; <S2SV_EndBug> <S2SV_StartBug> if ( ( o2 + 12 < o2 ) || ( o2 + 12 < 12 ) || ( o2 + 12 > buf_size ) ) return ; <S2SV_EndBug> <S2SV_StartBug> if ( ( o2 + 2 < o2 ) || ( o2 + 2 < 2 ) || ( o2 + 2 > buf_size ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) { <S2SV_EndBug> <S2SV_StartBug> ""ExifMnoteOlympus"" , ""Short<S2SV_blank>MakerNote"" ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dataofs + s > buf_size && n -> version == sanyoV1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) || <S2SV_EndBug> ","<S2SV_ModStart> CHECKOVERFLOW ( o2 , buf_size , 10 <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( o2 , buf_size , 4 <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( o2 , buf_size , 12 <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( o2 , buf_size , 2 <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteOlympus"" , ""Short<S2SV_blank>MakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) + base ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteOlympus"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_olympus_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components <S2SV_ModEnd> <S2SV_ModStart> ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( <S2SV_ModEnd> <S2SV_ModStart> ) , <S2SV_ModEnd> <S2SV_ModStart> ) ; continue ; } <S2SV_ModEnd> <S2SV_ModStart> > ( buf_size - s ) <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteOlympus"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteOlympus"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s <S2SV_ModEnd> "
76,"<S2SV_StartBug> struct pt_regs * regs , int nmi ) <S2SV_EndBug> <S2SV_StartBug> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
77,<S2SV_StartBug> if ( stringset == ETH_SS_STATS ) <S2SV_EndBug> ,<S2SV_ModStart> || stringset == ETH_SS_PRIV_FLAGS 
78,<S2SV_StartBug> jumpstack [ stackidx ++ ] = e ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; } 
79,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> else if ( ( too_many_pipe_buffers_hard ( pipe -> user ) || too_many_pipe_buffers_soft ( pipe -> user ) ) && ! capable ( CAP_SYS_RESOURCE ) && ! capable ( CAP_SYS_ADMIN ) ) { ret = - EPERM ; goto out ; } 
80,"<S2SV_StartBug> char sbuf [ 128 ] ; <S2SV_EndBug> <S2SV_StartBug> err = __video_do_ioctl ( file , cmd , parg ) ; <S2SV_EndBug> ","<S2SV_ModStart> return video_usercopy <S2SV_ModEnd> <S2SV_ModStart> arg , __video_do_ioctl ) <S2SV_ModEnd> "
81,"<S2SV_StartBug> 0xD5 , 0x75 , 0xF1 , 0x23 , 0xC1 , 0x81 , 0x4B , 0x44 , 0x23 , 0xBE , <S2SV_EndBug> <S2SV_StartBug> 0xC5 , 0x5F , 0x86 , 0x42 , 0x7F , 0x38 , 0xA3 , 0x95 , 0xEE , 0xA0 , <S2SV_EndBug> ","<S2SV_ModStart> 0xCF , 0x9F , 0x3A , 0x9C , 0xC5 , 0xA5 , 0x89 , 0x27 , 0x6D , 0x2C , 0x2C , 0xF3 , 0xA6 , 0x00 , 0xD2 , 0x7C , 0xEA , 0xFA , 0xF2 , 0x43 , 0x4F , 0x49 , 0x0A , 0xFC , 0xA6 , 0xE7 , 0x75 , 0xCA , 0x07 , 0xDC , 0xA5 , 0xF2 , 0x83 , 0x4E , 0x5A , 0xA0 , 0xA0 , 0xF5 , 0x9C , 0xFD , 0x02 , 0xE6 , 0x9E , 0xFC , 0x01 , 0x59 , 0xD7 , 0xB6 , 0xC1 , 0x4E , 0xC0 , 0xB6 , 0x71 , 0x49 , 0xF0 , 0xC7 , 0xD5 , 0x2F , 0x8D , 0xDF , 0xD3 , 0xF1 , 0x82 , 0x82 , 0x23 , 0x33 , 0x13 , 0x93 , 0xEB , 0x50 , 0x29 , 0xFD , 0x1B , 0x5A , 0x2F , 0xD5 , 0x08 , 0x99 , 0x64 , 0xE9 , 0x7B , 0x1A , 0xDD , 0x68 , 0x16 , 0x08 , 0xD0 , 0x13 , 0x82 , 0xB6 , 0x86 , 0x62 , 0x76 , 0xAA , 0x16 , 0x14 , 0xCC , 0x86 , 0x72 , 0x26 , 0x45 , 0x8E , 0x2A , 0x82 , 0x5B , 0x6F , 0xC1 , 0xDF , 0xAA , 0x18 , 0x43 , 0xB8 , 0xAD , 0x84 , 0x52 , 0xF2 , 0xD9 , 0x9C , 0xC0 , 0x47 , 0x52 , 0x1B , 0x8E , 0x42 , 0xC4 , 0xD3 , 0x61 , 0x7B , 0x65 , 0xA7 , 0x69 , 0x03 , 0xB5 , 0xD4 , 0x6C , 0x83 , 0x6A , 0x46 , 0x73 , 0xAF , 0x76 , 0x77 , 0x70 , 0xC2 , 0xD0 , 0x74 , 0xFE , 0x78 , 0xF5 , 0x75 , 0x3B , 0xCE , 0xE2 , 0xB6 , 0xA0 , 0x25 , 0xE9 , 0xE8 , 0x4B , 0xA2 , 0xF1 , 0x20 , 0x88 , 0x13 , 0x07 , 0xED , 0x66 , 0xBC , 0x46 , 0xA1 , 0xB3 , 0x44 , 0xAF , 0x2C , 0xED , 0x73 , 0x75 , 0x3D , 0x14 , 0x6E , 0x43 , 0x92 , 0x40 , 0x99 , 0xB0 , 0xD1 , 0xBF , 0x2C , 0x4D , 0x0F , 0x2A , 0x63 , 0xF4 , 0x85 , 0x7B , 0x1B , 0x0E , 0x48 , 0x5A , 0x06 , 0x02 , 0xA6 , 0x3D , 0x9E , 0x78 , 0x05 , 0xA8 , 0x7C , 0xAD , 0x54 , 0x49 , 0xDE , 0x7A , 0xE6 , 0x36 , 0x5C , 0x50 , 0xFC , 0x09 <S2SV_ModEnd> <S2SV_ModStart> 0x9E , 0x83 , 0x53 , 0x8C <S2SV_ModEnd> <S2SV_ModStart> 0xEF , 0x12 , 0x36 , 0x4F , 0x22 , 0x16 , 0x2A , 0x15 , 0x88 , 0x83 , 0xA9 , 0x00 , 0x66 , 0x9E , 0xD1 , 0xDC , 0x0F , 0x54 , 0xC0 , 0x32 , 0x5C , 0x4C , 0x5E , 0xE2 , 0x3D , 0xBC , 0x56 , 0x89 , 0x75 , 0x28 , 0xA3 <S2SV_ModEnd> "
82,"<S2SV_StartBug> static char * print_string_ptr ( const char * str ) <S2SV_EndBug> <S2SV_StartBug> char * ptr2 , * out ; <S2SV_EndBug> <S2SV_StartBug> int len = 0 ; <S2SV_EndBug> <S2SV_StartBug> return cJSON_strdup ( """" ) ; <S2SV_EndBug> <S2SV_StartBug> ++ len ; <S2SV_EndBug> <S2SV_StartBug> ++ ptr ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( out = ( char * ) cJSON_malloc ( len + 3 ) ) ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ","<S2SV_ModStart> , printbuffer * p <S2SV_ModStart> char * ptr2 , * out ; <S2SV_ModEnd> <S2SV_ModStart> , flag = 0 ; <S2SV_ModEnd> <S2SV_ModStart> { if ( p ) out = ensure ( p , 3 ) ; else out = ( char * ) cJSON_malloc ( 3 ) ; if ( ! out ) return 0 ; strcpy ( out , ""\\""\\"""" ) ; return out ; } for ( ptr = str ; * ptr ; ptr ++ ) flag |= ( ( * ptr > 0 && * ptr < 32 ) || ( * ptr == \'\\""\' ) || ( * ptr == '\\\\' ) ) ? 1 : 0 ; if ( ! flag ) { len = ptr - str ; if ( p ) out = ensure ( p , len + 3 ) ; else out = ( char * ) cJSON_malloc ( len + 3 ) ; if ( ! out ) return 0 ; ptr2 = out ; * ptr2 ++ = \'\\""\' ; strcpy ( ptr2 , str ) ; ptr2 [ len ] = \'\\""\' ; ptr2 [ len + 1 ] = 0 ; return out ; } ptr = str ; <S2SV_ModEnd> <S2SV_ModStart> len ++ ; <S2SV_ModEnd> <S2SV_ModStart> ptr ++ ; } if ( p ) out = ensure ( p , <S2SV_ModEnd> <S2SV_ModStart> ; else out = ( char * ) cJSON_malloc ( len + 3 ) ; if ( ! out ) <S2SV_ModEnd> <S2SV_ModStart> break ; } } } * ptr2 ++ = \'\\""\' ; <S2SV_ModEnd> "
83,"<S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , MB_STUFFING_CODE_LEN ) == MB_STUFFING_CODE ) <S2SV_EndBug> ",<S2SV_ModStart> && ps_stream -> u4_offset < ps_stream -> u4_max_offset 
84,"<S2SV_StartBug> alloc_limit_assert ( ""checked_xcalloc"" , ( num * size ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> res <S2SV_ModEnd> "
85,"<S2SV_StartBug> char * out = mutt_mem_malloc ( 3 * len / 4 + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> int dlen = mutt_b64_decode ( out , it ) ; <S2SV_EndBug> ","<S2SV_ModStart> const int olen = <S2SV_ModEnd> <S2SV_ModStart> ; char * out = mutt_mem_malloc ( olen <S2SV_ModStart> , olen "
86,<S2SV_StartBug> if ( ! sock || ( count && ! buf ) ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ,<S2SV_ModStart> || count > OE_SSIZE_MAX <S2SV_ModStart> if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } 
87,"<S2SV_StartBug> imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ; <S2SV_EndBug> ","<S2SV_ModStart> , true "
88,<S2SV_StartBug> mmu_notifier_mm_init ( mm ) ; <S2SV_EndBug> ,"<S2SV_ModStart> RCU_INIT_POINTER ( mm -> exe_file , NULL ) ; "
89,"<S2SV_StartBug> const int qzbin_factor = q == 0 ? 64 : ( vp9_dc_quant ( q , 0 ) < 148 ? 84 : 80 ) ; <S2SV_EndBug> <S2SV_StartBug> quant = i == 0 ? vp9_dc_quant ( q , cm -> y_dc_delta_q ) <S2SV_EndBug> <S2SV_StartBug> : vp9_ac_quant ( q , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> quants -> y_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> y_dequant [ q ] [ i ] = quant ; <S2SV_EndBug> <S2SV_StartBug> quant = i == 0 ? vp9_dc_quant ( q , cm -> uv_dc_delta_q ) <S2SV_EndBug> <S2SV_StartBug> : vp9_ac_quant ( q , cm -> uv_ac_delta_q ) ; <S2SV_EndBug> <S2SV_StartBug> quants -> uv_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> uv_dequant [ q ] [ i ] = quant ; <S2SV_EndBug> <S2SV_StartBug> quants -> a_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ; <S2SV_EndBug> <S2SV_StartBug> cm -> a_dequant [ q ] [ i ] = quant ; <S2SV_EndBug> <S2SV_StartBug> quants -> y_quant_shift [ q ] [ i ] = quants -> y_quant_shift [ q ] [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> cm -> y_dequant [ q ] [ i ] = cm -> y_dequant [ q ] [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> quants -> uv_quant_shift [ q ] [ i ] = quants -> uv_quant_shift [ q ] [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> cm -> uv_dequant [ q ] [ i ] = cm -> uv_dequant [ q ] [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_ALPHA <S2SV_EndBug> ","<S2SV_ModStart> get_qzbin_factor ( q , cm -> bit_depth <S2SV_ModEnd> <S2SV_ModStart> int qrounding_factor_fp = i == 0 ? 48 : 42 ; if ( q == 0 ) qrounding_factor_fp = 64 ; <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> y_quant_fp [ q ] [ i ] = ( 1 << 16 ) / quant ; quants -> y_round_fp [ q ] [ i ] = ( qrounding_factor_fp <S2SV_ModEnd> <S2SV_ModStart> quants -> y_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ; quants -> y_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ; cpi <S2SV_ModEnd> <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> uv_quant_fp [ q ] [ i ] = ( 1 << 16 ) / quant ; quants -> uv_round_fp [ q ] [ i ] = ( qrounding_factor_fp <S2SV_ModEnd> <S2SV_ModStart> quants -> uv_zbin <S2SV_ModEnd> <S2SV_ModStart> uv_round <S2SV_ModEnd> <S2SV_ModStart> cpi -> uv_dequant [ q ] [ i ] = quant ; <S2SV_ModEnd> <S2SV_ModStart> y_quant_fp [ q ] [ i ] = quants -> y_quant_fp [ q ] [ 1 ] ; quants -> y_round_fp [ q ] [ i ] = quants -> y_round_fp [ q ] [ 1 ] ; quants -> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> uv_quant_fp [ q ] [ i ] = quants -> uv_quant_fp [ q ] [ 1 ] ; quants -> uv_round_fp [ q ] [ i ] = quants -> uv_round_fp [ q ] [ 1 ] ; quants -> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
90,<S2SV_StartBug> static inline int <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
91,<S2SV_StartBug> char buffer [ 4096 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( name_len > sizeof ( buffer ) - 2 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> <S2SV_StartBug> if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) { <S2SV_EndBug> <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> ,"<S2SV_ModStart> * buf , * buf2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> efree ( buf ) ; <S2SV_ModEnd> <S2SV_ModStart> buf2 = estrndup ( value , value_len ) ; <S2SV_ModEnd> <S2SV_ModStart> efree ( buf ) ; efree ( buf2 ) ; <S2SV_ModEnd> "
92,"<S2SV_StartBug> msg -> fp = mutt_bcache_get ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> <S2SV_StartBug> msg -> fp = mutt_bcache_put ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> <S2SV_StartBug> mutt_bcache_commit ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> ",<S2SV_ModStart> cache_id ( <S2SV_ModStart> ) <S2SV_ModStart> cache_id ( <S2SV_ModStart> ) <S2SV_ModStart> cache_id ( <S2SV_ModStart> ) 
93,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>method=%s"" , len - 4 , <S2SV_EndBug> <S2SV_StartBug> if ( 1 < ndo -> ndo_vflag && 4 < len ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( ndo -> ndo_vflag && 4 < len ) { <S2SV_EndBug> <S2SV_StartBug> return ( const u_char * ) ext + len ; <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank>len=%u<S2SV_blank>method=%s"" <S2SV_ModEnd> <S2SV_ModStart> len > 4 ) { if ( <S2SV_ModEnd> <S2SV_ModStart> > 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } "
94,"<S2SV_StartBug> if ( ( doff + s < doff ) || ( doff + s < s ) || ( doff + s > size ) ) { <S2SV_EndBug> <S2SV_StartBug> ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , doff + s , size ) ; <S2SV_EndBug> ","<S2SV_ModStart> doff >= size ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Tag<S2SV_blank>starts<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , doff , size ) ; return 0 ; } if ( <S2SV_ModEnd> <S2SV_ModStart> - doff <S2SV_ModEnd> <S2SV_ModStart> ""Tag<S2SV_blank>data<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" <S2SV_ModEnd> "
95,"<S2SV_StartBug> p = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> <S2SV_StartBug> p = strchr ( p + 1 , '<S2SV_blank>' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> 
96,<S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * const lc = get_layer_context ( svc ) ; <S2SV_EndBug> <S2SV_StartBug> const int layer = svc -> temporal_layer_id ; <S2SV_EndBug> <S2SV_StartBug> lc -> framerate = oxcf -> framerate / oxcf -> ts_rate_decimator [ layer ] ; <S2SV_EndBug> <S2SV_StartBug> lrc -> av_per_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; <S2SV_EndBug> <S2SV_StartBug> if ( layer == 0 ) { <S2SV_EndBug> <S2SV_StartBug> lc -> avg_frame_size = lrc -> av_per_frame_bandwidth ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> framerate / oxcf -> ts_rate_decimator [ layer - 1 ] ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> ts_target_bitrate [ layer - 1 ] * 1000 ; <S2SV_EndBug> ,<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> st_idx = svc -> spatial_layer_id * svc -> number_temporal_layers + <S2SV_ModEnd> <S2SV_ModStart> const int tl = svc -> temporal_layer_id ; lc -> framerate = cpi <S2SV_ModEnd> <S2SV_ModStart> tl <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> tl <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> tl <S2SV_ModEnd> <S2SV_ModStart> layer_target_bitrate [ st_idx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
97,<S2SV_StartBug> if ( ses -> server -> sign && ses -> server -> ops -> generate_signingkey ) { <S2SV_EndBug> <S2SV_StartBug> rc = ses -> server -> ops -> generate_signingkey ( ses ) ; <S2SV_EndBug> <S2SV_StartBug> goto keygen_exit ; <S2SV_EndBug> <S2SV_StartBug> keygen_exit : <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return rc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
98,<S2SV_StartBug> if ( ! fs_searchpaths ) <S2SV_EndBug> <S2SV_StartBug> for ( search = fs_searchpaths ; search ; search = search -> next ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> qboolean isLocalConfig ; <S2SV_ModStart> isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> if ( isLocalConfig && search -> pack ) continue ; "
99,<S2SV_StartBug> f = po -> fanout ; <S2SV_EndBug> <S2SV_StartBug> if ( ! f ) <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & fanout_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & fanout_mutex ) ; <S2SV_ModStart> f ) { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & fanout_mutex ) ; } 
100,"<S2SV_StartBug> memcpy ( own_dir , ""."" , 2 ) ; <S2SV_EndBug> ","<S2SV_ModStart> # ifdef SUPER_SECURE memcpy ( own_dir , ""/dev/null/"" , 2 ) ; # else <S2SV_ModStart> # endif "
101,<S2SV_StartBug> uint32_t id ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( size_left < 4 ) { LogError ( ""Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>withdraw<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u"" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; } "
102,"<S2SV_StartBug> dbuf_copy ( c -> infile , pos + 4 , data_len , d -> iccprofile_file ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! d -> iccprofile_file ) { de_warn ( c , ""Bad<S2SV_blank>ICC<S2SV_blank>profile<S2SV_blank>segment"" ) ; return ; } "
103,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
104,"<S2SV_StartBug> int size_chk , err ; <S2SV_EndBug> <S2SV_StartBug> size_chk = chunk_size - headroom - XDP_PACKET_HEADROOM ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( headroom >= chunk_size - XDP_PACKET_HEADROOM <S2SV_ModEnd> 
105,<S2SV_StartBug> int rec ; <S2SV_EndBug> <S2SV_StartBug> int rec_len = file -> record_length ; <S2SV_EndBug> <S2SV_StartBug> for ( rec = 1 ; ; rec ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> size_t rec ; size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> if ( rec > file -> record_count ) { rv = 0 ; break ; } 
106,"<S2SV_StartBug> vpx_memset ( a_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( l_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
107,"<S2SV_StartBug> static const char * parse_value ( cJSON * item , const char * value ) <S2SV_EndBug> <S2SV_StartBug> return parse_string ( item , value ) ; <S2SV_EndBug> <S2SV_StartBug> return parse_number ( item , value ) ; <S2SV_EndBug> <S2SV_StartBug> return parse_array ( item , value ) ; <S2SV_EndBug> <S2SV_StartBug> return parse_object ( item , value ) ; <S2SV_EndBug> ","<S2SV_ModStart> , const char * * ep ) { if ( ! value ) <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> , ep ) ; } <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> , ep ) ; } <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> , ep ) ; } * ep = value ; <S2SV_ModEnd> "
108,"<S2SV_StartBug> if ( copy_to_user ( uaddr , ( ( u32 * ) regs ) + off , KVM_REG_SIZE ( reg -> id ) ) ) <S2SV_EndBug> ",<S2SV_ModStart> validate_core_offset ( reg ) ) return - EINVAL ; if ( 
109,<S2SV_StartBug> get_page ( * page ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( ! try_get_page ( * page ) ) ) { ret = - ENOMEM ; goto unmap ; } <S2SV_ModEnd> 
110,"<S2SV_StartBug> ses = cifs_find_smb_ses ( server , volume_info -> username ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
111,"<S2SV_StartBug> dbg_hid ( ""%s,<S2SV_blank>size:%d\\n"" , __func__ , size ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) { dev_err ( & hdev -> dev , ""%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\n"" , __func__ , dj_report -> device_index ) ; return false ; } "
112,"<S2SV_StartBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>[-t<S2SV_blank>life]<S2SV_blank>[command<S2SV_blank>[arg<S2SV_blank>...]]\\n"" <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>[-P<S2SV_blank>pkcs11_whitelist]<S2SV_blank>[-t<S2SV_blank>life]<S2SV_blank>[command<S2SV_blank>[arg<S2SV_blank>...]]\\n"" <S2SV_ModEnd> "
113,"<S2SV_StartBug> int xml_init ( modsec_rec * msr , char * * error_msg ) { <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ",<S2SV_ModStart> xmlParserInputBufferCreateFilenameFunc entity ; <S2SV_ModStart> if ( msr -> txcfg -> xml_external_entity == 0 ) { entity = xmlParserInputBufferCreateFilenameDefault ( xml_unload_external_entity ) ; } 
114,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.data.%d"" , gplot -> rootname , gplot -> nplots ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%f<S2SV_blank>%f\\n"" , valx , valy ) ; <S2SV_EndBug> ",<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> 
115,"<S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
116,"<S2SV_StartBug> dev_data = pci_get_drvdata ( dev ) ; <S2SV_EndBug> <S2SV_StartBug> return pci_write_config_word ( dev , offset , value ) ; <S2SV_EndBug> ","<S2SV_ModStart> u16 val ; struct pci_cmd_info * cmd = data ; <S2SV_ModStart> cmd -> val = value ; if ( ! permissive && ( ! dev_data || ! dev_data -> permissive ) ) return 0 ; err = pci_read_config_word ( dev , offset , & val ) ; if ( err || val == value ) return err ; value &= PCI_COMMAND_GUEST ; value |= val & ~ PCI_COMMAND_GUEST ; "
117,<S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC ) && * rsize >= 90 && rdesc [ 83 ] == 0x26 && <S2SV_EndBug> <S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC_REL_ABS ) && * rsize >= 50 && <S2SV_EndBug> ,<S2SV_ModStart> 91 <S2SV_ModEnd> <S2SV_ModStart> 51 <S2SV_ModEnd> 
118,<S2SV_StartBug> # ifdef __linux <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
119,"<S2SV_StartBug> if ( strcmp ( im -> mode , ""1"" ) == 0 && state -> xsize > state -> bytes * 8 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( im -> mode , ""P"" ) == 0 && state -> xsize > state -> bytes ) { <S2SV_EndBug> <S2SV_StartBug> ptr = buf ; <S2SV_EndBug> ","<S2SV_ModStart> ( state -> xsize * state -> bits + 7 ) / 8 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ptr = buf ; for ( ; ; ) { if ( bytes < 1 ) return ptr - buf ; if ( ( * ptr & 0xC0 ) == 0xC0 ) { if ( bytes < 2 ) return ptr - buf ; n = ptr [ 0 ] & 0x3F ; while ( n > 0 ) { if ( state -> x >= state -> bytes ) { state -> errcode = IMAGING_CODEC_OVERRUN ; break ; } state -> buffer [ state -> x ++ ] = ptr [ 1 ] ; n -- ; } ptr += 2 ; bytes -= 2 ; } else { state -> buffer [ state -> x ++ ] = ptr [ 0 ] ; ptr ++ ; bytes -- ; } if ( state -> x >= state -> bytes ) { if ( state -> bytes % state -> xsize && state -> bytes > state -> xsize ) { int bands = state -> bytes / state -> xsize ; int stride = state -> bytes / bands ; int i ; for ( i = 1 ; i < bands ; i ++ ) { memmove ( & state -> buffer [ i * state -> xsize ] , & state -> buffer [ i * stride ] , state -> xsize ) ; } } state -> shuffle ( ( UINT8 * ) im -> image [ state -> y + state -> yoff ] + state -> xoff * im -> pixelsize , state -> buffer , state -> xsize ) ; state -> x = 0 ; if ( ++ state -> y >= state -> ysize ) { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
120,<S2SV_StartBug> dname = malloc ( strlen ( name ) + 16 ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
121,"<S2SV_StartBug> __mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { <S2SV_ModStart> insn -> imm ) ; } else { __mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ; } <S2SV_ModEnd> "
122,"<S2SV_StartBug> strncat ( params , gtk_entry_get_text ( GTK_ENTRY ( entry1 ) ) , PARAMS_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( params , ""/"" , PARAMS_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( params , gtk_entry_get_text ( GTK_ENTRY ( entry2 ) ) , PARAMS_LEN ) ; <S2SV_EndBug> ",<S2SV_ModStart> ETH_ASCII_ADDR_LEN <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> IP6_ASCII_ADDR_LEN <S2SV_ModEnd> 
123,"<S2SV_StartBug> if ( poll ( & pfd , 1 , 500 ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( sent = send ( fd , p , len , MSG_NOSIGNAL ) ) == - 1 ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
124,"<S2SV_StartBug> bufobj = PyObject_CallObject ( tok -> decoding_readline , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> _PyObject_CallNoArg <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
125,<S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> ,<S2SV_ModStart> q -> fq = NULL ; 
126,<S2SV_StartBug> gdImagePtr im ; <S2SV_EndBug> ,"<S2SV_ModStart> check_file ( ""heap_overflow_1.tga"" ) ; check_file ( ""heap_overflow_2.tga"" <S2SV_ModEnd> "
127,<S2SV_StartBug> # if PY_MINOR_VERSION >= 4 <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
128,"<S2SV_StartBug> u32 i = 0 , j , page_offset = 0 , sg_per_table , sg_tables , total_sg_needed ; <S2SV_EndBug> <S2SV_StartBug> struct rd_dev_sg_table * sg_table ; <S2SV_EndBug> <S2SV_StartBug> while ( total_sg_needed ) { <S2SV_EndBug> ","<S2SV_ModStart> struct rd_dev_sg_table * sg_table ; u32 <S2SV_ModEnd> <S2SV_ModStart> int rc <S2SV_ModEnd> <S2SV_ModStart> rc = rd_allocate_sgl_table ( rd_dev , sg_table , total_sg_needed , 0x00 ) ; if ( rc ) return rc ; <S2SV_ModEnd> "
129,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>title<S2SV_blank>\'%s\'"" , gplot -> title ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>xlabel<S2SV_blank>\'%s\'"" , gplot -> xlabel ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>ylabel<S2SV_blank>\'%s\'"" , gplot -> ylabel ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>x"" ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>y"" ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s"" , <S2SV_EndBug> ",<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> 
130,<S2SV_StartBug> outpos += <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sendClean ( outputbuffer ) ; 
131,"<S2SV_StartBug> if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , <S2SV_EndBug> ","<S2SV_ModStart> p_total_data_size , "
132,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> skb_free_datagram ( sk , skb ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } 
133,<S2SV_StartBug> follow_dotdot ( nd ) ; <S2SV_EndBug> ,<S2SV_ModStart> return 
134,<S2SV_StartBug> list = lptr = ( nodeitem * ) palloc ( sizeof ( nodeitem ) * ( num + 1 ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( num + 1 > MaxAllocSize / sizeof ( nodeitem ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , num + 1 , ( int ) ( MaxAllocSize / sizeof ( nodeitem ) ) ) ) ) ; "
135,<S2SV_StartBug> ld -> bytes_left = ld -> buffer_size - words * 4 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ld -> buffer_size < words * 4 ) ld -> bytes_left = 0 ; else 
136,"<S2SV_StartBug> profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; "
137,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( clk_src ) ; 
138,"<S2SV_StartBug> sync . clock_rate = FST_RDL ( card , portConfig [ i ] . lineSpeed ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( & sync , 0 , sizeof ( sync ) ) ; "
139,"<S2SV_StartBug> if ( pos >= GDT_ENTRY_TLS_ENTRIES * sizeof ( struct user_desc ) || <S2SV_EndBug> <S2SV_StartBug> set_tls_desc ( target , <S2SV_EndBug> ",<S2SV_ModStart> int i ; <S2SV_ModStart> for ( i = 0 ; i < count / sizeof ( struct user_desc ) ; i ++ ) if ( ! tls_desc_okay ( info + i ) ) return - EINVAL ; 
140,"<S2SV_StartBug> char buf [ 32 ] , * e ; <S2SV_EndBug> ",<S2SV_ModStart> 50 <S2SV_ModEnd> 
141,<S2SV_StartBug> ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( rr -> u . ER . len_id + offsetof ( struct rock_ridge , u . ER . data ) > rr -> len ) goto out ; "
142,<S2SV_StartBug> m -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
143,<S2SV_StartBug> disk -> queue = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> put_disk ( disk ) ; 
144,"<S2SV_StartBug> static int getnum ( lua_State * L , const char * * fmt , int df ) { <S2SV_EndBug> <S2SV_StartBug> if ( a > ( INT_MAX / 10 ) || a * 10 > ( INT_MAX - ( * * fmt - '0' ) ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
145,"<S2SV_StartBug> void vp9_choose_segmap_coding_method ( VP9_COMP * cpi ) { <S2SV_EndBug> <S2SV_StartBug> vp9_prob no_pred_tree [ SEG_TREE_PROBS ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob t_pred_tree [ SEG_TREE_PROBS ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob t_nopred_prob [ PREDICTION_PROBS ] ; <S2SV_EndBug> <S2SV_StartBug> const int mis = cm -> mi_stride ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( seg -> pred_probs , 255 , sizeof ( seg -> pred_probs ) ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_tile_init ( & tile , cm , 0 , tile_col ) ; <S2SV_EndBug> <S2SV_StartBug> mi_row += 8 , mi_ptr += 8 * mis ) { <S2SV_EndBug> <S2SV_StartBug> count_segs_sb ( cpi , & tile , mi , no_pred_segcounts , <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( seg -> tree_probs , t_pred_tree , sizeof ( t_pred_tree ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( seg -> pred_probs , t_nopred_prob , sizeof ( t_nopred_prob ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( seg -> tree_probs , no_pred_tree , sizeof ( no_pred_tree ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> VP9_COMMON * cm , MACROBLOCKD * xd ) { <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> MODE_INFO * * mi_ptr ; <S2SV_ModStart> cm -> mi_stride ) { MODE_INFO * * <S2SV_ModEnd> <S2SV_ModStart> cm , xd <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> "
146,"<S2SV_StartBug> g_return_if_fail ( RS_IS_FILTER ( filter ) ) ; <S2SV_EndBug> <S2SV_StartBug> g_file_set_contents ( ""/tmp/rs-filter-graph"" , str -> str , str -> len , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( 0 != system ( ""dot<S2SV_blank>-Tpng<S2SV_blank>>/tmp/rs-filter-graph.png<S2SV_blank></tmp/rs-filter-graph"" ) ) <S2SV_EndBug> <S2SV_StartBug> if ( 0 != system ( ""gnome-open<S2SV_blank>/tmp/rs-filter-graph.png"" ) ) <S2SV_EndBug> <S2SV_StartBug> g_warning ( ""Calling<S2SV_blank>gnome-open<S2SV_blank>failed."" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; gchar * dot_filename ; gchar * png_filename ; gchar * command_line <S2SV_ModStart> dot_filename = g_strdup_printf ( ""/tmp/rs-filter-graph.%u"" , g_random_int ( ) ) ; png_filename = g_strdup_printf ( ""%s.%u.png"" , dot_filename , g_random_int ( ) ) ; g_file_set_contents ( dot_filename <S2SV_ModEnd> <S2SV_ModStart> command_line = g_strdup_printf ( ""dot<S2SV_blank>-Tpng<S2SV_blank>>%s<S2SV_blank><%s"" , png_filename , dot_filename ) ; <S2SV_ModStart> command_line <S2SV_ModEnd> <S2SV_ModStart> g_free ( command_line ) ; command_line = g_strdup_printf ( ""gnome-open<S2SV_blank>%s"" , png_filename ) ; <S2SV_ModStart> command_line <S2SV_ModEnd> <S2SV_ModStart> ) ; g_free ( command_line ) ; g_free ( dot_filename ) ; g_free ( png_filename "
147,"<S2SV_StartBug> if ( ( fd = open ( clonedev , O_RDWR ) ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( err = ioctl ( fd , TUNSETIFF , ( void * ) & ifr ) ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> int flags = fcntl ( fd , F_GETFL , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> fcntl ( fd , F_SETFL , flags | O_NONBLOCK ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ; TEMP_FAILURE_RETRY ( <S2SV_ModEnd> <S2SV_ModStart> ) 
148,<S2SV_StartBug> # if CONFIG_MULTIPLE_ARF <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_MULTIPLE_ARF <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> multi_arf_enabled ) { <S2SV_EndBug> <S2SV_StartBug> arf_idx = ( cpi -> frame_coding_order [ sn ] < 0 ) ? <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart> if ( vp9_preserve_existing_gf ( cpi ) ) { <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> oxcf . pass == 2 ) && cpi -> multi_arf_allowed ) { const GF_GROUP * const gf_group = & cpi -> twopass . gf_group <S2SV_ModEnd> <S2SV_ModStart> gf_group -> arf_update_idx [ gf_group -> index <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
149,"<S2SV_StartBug> struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , void * data ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> 
150,<S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! tls_desc_okay ( & info ) ) return - EINVAL 
151,"<S2SV_StartBug> id = ipc_addid ( & shm_ids ( ns ) , & shp -> shm_perm , ns -> shm_ctlmni ) ; <S2SV_EndBug> <S2SV_StartBug> shp -> shm_cprid = task_tgid_vnr ( current ) ; <S2SV_EndBug> ",<S2SV_ModStart> shp -> shm_cprid = task_tgid_vnr ( current ) ; shp -> shm_lprid = 0 ; shp -> shm_atim = shp -> shm_dtim = 0 ; shp -> shm_ctim = get_seconds ( ) ; shp -> shm_segsz = size ; shp -> shm_nattch = 0 ; shp -> shm_file = file ; shp -> shm_creator = current ; <S2SV_ModStart>  <S2SV_ModEnd> 
152,"<S2SV_StartBug> . daddr = ( param -> replyopts . srr ? <S2SV_EndBug> <S2SV_StartBug> param -> replyopts . faddr : iph -> saddr ) , <S2SV_EndBug> ",<S2SV_ModStart> opt . opt . <S2SV_ModStart> . opt . opt 
153,<S2SV_StartBug> bprm -> interp = interp ; <S2SV_EndBug> <S2SV_StartBug> return search_binary_handler ( bprm ) ; <S2SV_EndBug> ,"<S2SV_ModStart> retval = bprm_change_interp ( interp , <S2SV_ModEnd> <S2SV_ModStart> file = open_exec ( interp ) ; if ( IS_ERR ( file ) ) return PTR_ERR ( file ) ; bprm -> file = file ; retval = prepare_binprm ( bprm ) ; if ( retval < 0 ) return retval ; "
154,"<S2SV_StartBug> sprintf ( addr , ""%d.%d.%d.%d"" , a , b , c , d ) ; <S2SV_EndBug> ","<S2SV_ModStart> snprintf ( addr , sizeof ( addr ) <S2SV_ModEnd> "
155,"<S2SV_StartBug> int ntlm_read_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <S2SV_EndBug> ",<S2SV_ModStart> static 
156,"<S2SV_StartBug> cmd = kmalloc ( sizeof ( * cmd ) , GFP_KERNEL ) ; <S2SV_EndBug> ",<S2SV_ModStart> kzalloc <S2SV_ModEnd> 
157,<S2SV_StartBug> hash_param . data = 0 ; <S2SV_EndBug> <S2SV_StartBug> hash_param . len = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> instance -> private_key <S2SV_ModEnd> <S2SV_ModStart> instance -> private_key_len <S2SV_ModEnd> 
158,"<S2SV_StartBug> unix_insert_socket ( unix_sockets_unbound ( sk ) , sk ) ; <S2SV_EndBug> ","<S2SV_ModStart> init_waitqueue_func_entry ( & u -> peer_wake , unix_dgram_peer_wake_relay ) ; "
159,"<S2SV_StartBug> # ifdef __linux__ <S2SV_EndBug> <S2SV_StartBug> sun . sun_path [ 0 ] = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> sun_len = offsetof ( struct sockaddr_un , sun_path ) + strlen ( address ) + 1 ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sizeof <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> 
160,<S2SV_StartBug> # ifndef NETSNMP_NO_WRITE_SUPPORT <S2SV_EndBug> <S2SV_StartBug> # ifndef NETSNMP_NO_WRITE_SUPPORT <S2SV_EndBug> ,<S2SV_ModStart> if ! defined ( NETSNMP_NO_WRITE_SUPPORT ) && ENABLE_EXTEND_WRITE_ACCESS <S2SV_ModEnd> <S2SV_ModStart> if ! defined ( NETSNMP_NO_WRITE_SUPPORT ) && ENABLE_EXTEND_WRITE_ACCESS <S2SV_ModEnd> 
161,"<S2SV_StartBug> static struct ip_options * ip_options_get_alloc ( const int optlen ) <S2SV_EndBug> <S2SV_StartBug> return kzalloc ( sizeof ( struct ip_options ) + ( ( optlen + 3 ) & ~ 3 ) , <S2SV_EndBug> ",<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> 
162,<S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> BUG_ON ( ! ptr ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! cursor ) goto gc_complete ; <S2SV_ModStart> cursor <S2SV_ModEnd> 
163,<S2SV_StartBug> local_vec = ( struct rds_iovec __user * ) ( unsigned long ) args -> local_vec_addr ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( args -> nr_local == 0 ) return - EINVAL 
164,<S2SV_StartBug> assert ( plen <= * len ) ; <S2SV_EndBug> ,<S2SV_ModStart> && plen > 0 
165,"<S2SV_StartBug> return send ( ts [ h ] . cmd_fdw , cmd_send , size_send , 0 ) == size_send ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
166,"<S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ldt , VCPU_SREG_LDTR , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ; <S2SV_EndBug> ","<S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> "
167,"<S2SV_StartBug> if ( ! capable ( CAP_NET_ADMIN ) ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( arg , user , get_arglen [ GET_CMDID ( cmd ) ] ) != 0 ) <S2SV_EndBug> ",<S2SV_ModStart> unsigned int copylen ; <S2SV_ModStart> ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX ) return - EINVAL <S2SV_ModStart> copylen = get_arglen [ GET_CMDID ( cmd ) ] ; if ( copylen > 128 ) return - EINVAL ; <S2SV_ModStart> copylen <S2SV_ModEnd> 
168,<S2SV_StartBug> if ( tgt_clobbers & ~ site_clobbers ) <S2SV_EndBug> <S2SV_StartBug> if ( len < 5 ) <S2SV_EndBug> ,"<S2SV_ModStart> len < 5 ) { # ifdef CONFIG_RETPOLINE WARN_ONCE ( ""Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>CALL<S2SV_blank>in<S2SV_blank>%ps\\n"" , ( void * ) addr ) ; # endif <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModEnd> "
169,<S2SV_StartBug> if ( o == NULL ) return ; <S2SV_EndBug> ,"<S2SV_ModStart> || checkType ( c , o , OBJ_STREAM ) "
170,"<S2SV_StartBug> CHECK_TLV_SIZE ( 1 + addr_str_length , ""Management<S2SV_blank>address"" ) ; <S2SV_EndBug> <S2SV_StartBug> CHECK_TLV_SIZE ( 4 , ""Organisational"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( addr_str_length > sizeof ( addr_str_buffer ) ) { log_warnx ( ""lldp"" , ""too<S2SV_blank>large<S2SV_blank>management<S2SV_blank>address<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } <S2SV_ModStart> 1 + ( int ) sizeof ( orgid ) <S2SV_ModEnd> "
171,"<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <S2SV_EndBug> ","<S2SV_ModStart> result ; int <S2SV_ModStart> result = <S2SV_ModEnd> <S2SV_ModStart> ; if ( result < 0 ) js_error ( J , ""regexec<S2SV_blank>failed"" ) ; if ( result == 0 "
172,<S2SV_StartBug> goto read_error ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
173,"<S2SV_StartBug> cred = rpc_lookup_cred ( ) ; <S2SV_EndBug> <S2SV_StartBug> state = nfs4_do_open ( dir , & path , openflags , NULL , cred ) ; <S2SV_EndBug> <S2SV_StartBug> nfs4_intent_set_file ( nd , & path , state ) ; <S2SV_EndBug> <S2SV_StartBug> nfs4_close_sync ( & path , state , openflags ) ; <S2SV_EndBug> ","<S2SV_ModStart> fmode_t fmode = openflags & ( FMODE_READ | FMODE_WRITE ) ; <S2SV_ModStart> , fmode <S2SV_ModStart> , fmode <S2SV_ModStart> fmode <S2SV_ModEnd> "
174,<S2SV_StartBug> int target = rc -> av_per_frame_bandwidth * kf_ratio ; <S2SV_EndBug> ,<S2SV_ModStart> const <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> 
175,"<S2SV_StartBug> if ( test_bit ( DMF_FREEING , & md -> flags ) || <S2SV_EndBug> <S2SV_StartBug> dm_deleting_md ( md ) ) <S2SV_EndBug> <S2SV_StartBug> dm_get ( md ) ; <S2SV_EndBug> ",<S2SV_ModStart> spin_lock ( & _minor_lock ) ; <S2SV_ModStart> { md = NULL ; goto out ; } <S2SV_ModEnd> <S2SV_ModStart> ) ; out : spin_unlock ( & _minor_lock 
176,"<S2SV_StartBug> return luaL_argerror ( L , 0 , ""MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input."" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; if ( ! lua_checkstack ( L , nargs ) ) return luaL_argerror ( L , 0 , ""Too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>MessagePack<S2SV_blank>pack."" "
177,<S2SV_StartBug> if ( group_leader -> ctx -> type != ctx -> type ) <S2SV_EndBug> ,<S2SV_ModStart> task <S2SV_ModEnd> <S2SV_ModStart> task ) goto err_context ; if ( group_leader -> cpu != event -> cpu <S2SV_ModEnd> 
178,<S2SV_StartBug> down_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ; <S2SV_EndBug> ,"<S2SV_ModStart> error = btrfs_check_dir_item_collision ( BTRFS_I ( dir ) -> root , dir -> i_ino , name , namelen ) ; if ( error ) goto out_dput ; "
179,"<S2SV_StartBug> MACROBLOCK * x , <S2SV_EndBug> <S2SV_StartBug> const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; <S2SV_EndBug> <S2SV_StartBug> int offset = ( mi_row * MI_SIZE ) * yv12 -> y_stride + ( mi_col * MI_SIZE ) ; <S2SV_EndBug> <S2SV_StartBug> var = cpi -> fn_ptr [ bs ] . vf ( x -> plane [ 0 ] . src . buf , <S2SV_EndBug> ","<S2SV_ModStart> const struct buf_2d * ref <S2SV_ModEnd> <S2SV_ModStart> unsigned int sse , var ; uint8_t * last_y ; <S2SV_ModStart> last <S2SV_ModEnd> <S2SV_ModStart> assert ( last != NULL ) ; last_y = & last -> y_buffer [ <S2SV_ModEnd> <S2SV_ModStart> * last <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ] <S2SV_ModEnd> <S2SV_ModStart> ref -> buf , ref -> stride , last_y , last <S2SV_ModEnd> "
180,"<S2SV_StartBug> checked_xmalloc ( size_t size ) <S2SV_EndBug> <S2SV_StartBug> alloc_limit_assert ( ""checked_xmalloc"" , size ) ; <S2SV_EndBug> <S2SV_StartBug> return xmalloc ( size ) ; <S2SV_EndBug> ","<S2SV_ModStart> num , size_t <S2SV_ModStart> size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> res <S2SV_ModEnd> <S2SV_ModStart> num , "
181,<S2SV_StartBug> int m ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( n < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_gobble"" ) ; } "
182,<S2SV_StartBug> if ( p ++ != pages [ i + j ] ) <S2SV_EndBug> <S2SV_StartBug> if ( p ++ != pages [ i + j ] ) <S2SV_EndBug> ,<S2SV_ModStart> ++ p <S2SV_ModEnd> <S2SV_ModStart> ++ p <S2SV_ModEnd> 
183,<S2SV_StartBug> hdl -> client_state = HSM_COM_C_STATE_IN ; <S2SV_EndBug> ,<S2SV_ModStart> if ( mkstemp ( hdl -> c_path ) == - 1 ) { res = HSM_COM_PATH_ERR ; goto cleanup ; } 
184,"<S2SV_StartBug> ( * sp -> encodepfunc ) ( tif , bp , cc ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) return 0 
185,<S2SV_StartBug> new -> cid_mask = new -> lid_mask = 0xffff ; <S2SV_EndBug> ,<S2SV_ModStart> ( 1 << KVM_X2APIC_CID_BITS ) - 1 ; 
186,<S2SV_StartBug> if ( ! ( ifa1 -> ifa_flags & IFA_F_SECONDARY ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> in_dev -> dead ) goto no_promotions ; if ( <S2SV_ModStart> no_promotions : 
187,<S2SV_StartBug> SvcInternal * si ; <S2SV_EndBug> <S2SV_StartBug> si = ( SvcInternal * ) svc_ctx -> internal ; <S2SV_EndBug> <S2SV_StartBug> free ( si -> buffer ) ; <S2SV_EndBug> ,<S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> <S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
188,"<S2SV_StartBug> strncpy ( extra_response -> key , key , strlen ( key ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> strlen ( NOTUNDERSTOOD ) + 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> strlcpy <S2SV_ModEnd> <S2SV_ModStart> sizeof ( extra_response -> key ) ) ; strlcpy <S2SV_ModEnd> <S2SV_ModStart> sizeof ( extra_response -> value ) <S2SV_ModEnd> 
189,"<S2SV_StartBug> u32 i = 0 , j , page_offset = 0 , sg_per_table , sg_tables , total_sg_needed ; <S2SV_EndBug> <S2SV_StartBug> struct rd_dev_sg_table * sg_table ; <S2SV_EndBug> <S2SV_StartBug> while ( total_sg_needed ) { <S2SV_EndBug> ","<S2SV_ModStart> struct rd_dev_sg_table * sg_table ; u32 <S2SV_ModEnd> <S2SV_ModStart> int rc <S2SV_ModEnd> <S2SV_ModStart> rc = rd_allocate_sgl_table ( rd_dev , sg_table , total_sg_needed , 0x00 ) ; if ( rc ) return rc ; <S2SV_ModEnd> "
190,<S2SV_StartBug> return ( ( Image * ) NULL ) ; <S2SV_EndBug> ,<S2SV_ModStart> break <S2SV_ModEnd> 
191,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( TSQUERY_TOO_BIG ( list_length ( state . polstr ) , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ; "
192,<S2SV_StartBug> buf = malloc ( sz + 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
193,<S2SV_StartBug> return ret ; <S2SV_EndBug> <S2SV_StartBug> if ( s -> ref ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( ret == 1 ) { ret = AVERROR_INVALIDDATA ; goto fail ; } <S2SV_ModStart>  <S2SV_ModEnd> 
194,"<S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> <S2SV_StartBug> int rv = copy_file ( src , dest ) ; <S2SV_EndBug> <S2SV_StartBug> if ( chown ( dest , getuid ( ) , getgid ( ) ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( chmod ( dest , S_IRUSR | S_IWUSR ) < 0 ) <S2SV_EndBug> ","<S2SV_ModStart> copy_file_as_user <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; fs_logger2 ( ""clone"" , dest <S2SV_ModEnd> "
195,"<S2SV_StartBug> static inline long decode_twos_comp ( ulong c , int prec ) <S2SV_EndBug> ",<S2SV_ModStart> jas_ulong <S2SV_ModEnd> 
196,"<S2SV_StartBug> x -> quantize_b_pair = vp8_fast_quantize_b_pair ; <S2SV_EndBug> <S2SV_StartBug> & distortion , & intra_error ) ; <S2SV_EndBug> <S2SV_StartBug> x -> quantize_b = vp8_regular_quantize_b ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , mb_row , mb_col <S2SV_ModStart>  <S2SV_ModEnd> "
197,<S2SV_StartBug> ascii = malloc ( strlen ( str ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ascii = malloc ( str_len ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> <S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
198,<S2SV_StartBug> char lowstr [ MAXDATELEN + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> ,<S2SV_ModStart> MAXDATEFIELDS <S2SV_ModEnd> <S2SV_ModStart> > MAXDATELEN <S2SV_ModEnd> 
199,<S2SV_StartBug> free_uid ( group -> inotify_data . user ) ; <S2SV_EndBug> ,<S2SV_ModStart> atomic_dec ( & group -> inotify_data . user -> inotify_devs ) ; 
200,"<S2SV_StartBug> int i , j ; <S2SV_EndBug> <S2SV_StartBug> i = ctm -> length ; <S2SV_EndBug> <S2SV_StartBug> if ( ( i < 11 ) || ( i > 17 ) ) <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( i < 13 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> * ( p ++ ) = * ( str ++ ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( * str >= '0' ) && ( * str <= '9' ) ) <S2SV_EndBug> <S2SV_StartBug> if ( * str == 'Z' ) <S2SV_EndBug> <S2SV_StartBug> else { <S2SV_EndBug> <S2SV_StartBug> if ( ( * str != '+' ) && ( * str != '-' ) ) <S2SV_EndBug> ","<S2SV_ModStart> , remaining <S2SV_ModStart> remaining <S2SV_ModEnd> <S2SV_ModStart> int min_length = sizeof ( ""YYMMDDHHMMZ"" ) - 1 ; int max_length = sizeof ( ""YYMMDDHHMMSS+hhmm"" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> <S2SV_ModStart> remaining -= 10 ; <S2SV_ModStart> int min_length = sizeof ( ""YYYYMMDDHHMMZ"" ) - 1 ; int max_length = sizeof ( ""YYYYMMDDHHMMSS.fff+hhmm"" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> <S2SV_ModStart> remaining -= 12 ; <S2SV_ModStart> if ( remaining < 2 ) return 0 ; * ( p ++ ) = * ( str ++ ) ; * ( p ++ ) = * ( str ++ ) ; remaining -= 2 ; if ( remaining && <S2SV_ModEnd> <S2SV_ModStart> remaining -- ; for ( i = 0 ; i < 3 && remaining ; i ++ , str ++ , remaining -- ) { if ( * str < '0' || * str > '9' ) break ; } <S2SV_ModEnd> <S2SV_ModStart> ! remaining ) return 0 ; if ( <S2SV_ModStart> { if ( remaining != 1 ) return 0 ; <S2SV_ModStart> } <S2SV_ModStart> ) return 0 ; if ( remaining != 5 ) return 0 ; if ( str [ 1 ] < '0' || str [ 1 ] > '9' || str [ 2 ] < '0' || str [ 2 ] > '9' || str [ 3 ] < '0' || str [ 3 ] > '9' || str [ 4 ] < '0' || str [ 4 ] > '9' "
201,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( s == 0 ) return ( ( void * ) NULL ) ; 
202,<S2SV_StartBug> if ( ! ( flags | RT6_LOOKUP_F_DST_NOREF ) ) <S2SV_EndBug> ,<S2SV_ModStart> & <S2SV_ModEnd> 
203,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
204,<S2SV_StartBug> pu1_buf = ( UWORD8 * ) ps_codec -> pv_mv_bank_buf_base ; <S2SV_EndBug> ,<S2SV_ModStart> ps_codec -> i4_max_dpb_size = max_dpb_size ; 
205,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , rpl_tstr <S2SV_ModEnd> "
206,"<S2SV_StartBug> static int nfs4_open_recover_helper ( struct nfs4_opendata * opendata , mode_t openflags , struct nfs4_state * * res ) <S2SV_EndBug> <S2SV_StartBug> opendata -> o_arg . open_flags = openflags ; <S2SV_EndBug> <S2SV_StartBug> nfs4_close_state ( & opendata -> path , newstate , openflags ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> 0 ; opendata -> o_arg . fmode = fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> 
207,<S2SV_StartBug> # if ( ETH_SUPPORT == ENABLED ) <S2SV_EndBug> ,<S2SV_ModStart> message -> interface = queueItem -> interface ; 
208,<S2SV_StartBug> while ( 1 ) { <S2SV_EndBug> <S2SV_StartBug> assert ( ! state -> last_str || <S2SV_EndBug> ,<S2SV_ModStart> state -> fmode = 1 ; <S2SV_ModStart>  <S2SV_ModEnd> 
209,"<S2SV_StartBug> if ( pos > CDF_SEC_SIZE ( h ) * sst -> sst_len ) { <S2SV_EndBug> <S2SV_StartBug> pos , CDF_SEC_SIZE ( h ) * sst -> sst_len ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> + len <S2SV_ModStart> + len 
210,<S2SV_StartBug> vstart += verdef -> vd_aux ; <S2SV_EndBug> ,<S2SV_ModStart> int vdaux = verdef -> vd_aux ; if ( vdaux < 1 ) { sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux <S2SV_ModEnd> 
211,"<S2SV_StartBug> int sec ; <S2SV_EndBug> <S2SV_StartBug> guint pkt_len ; <S2SV_EndBug> <S2SV_StartBug> guint offset = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( sscanf ( line , ""%9d.%9d:<S2SV_blank>%15[a-z0-9/:.-](%1[io])<S2SV_blank>len=%9u:%12s->%12s/"" , <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> ","<S2SV_ModStart> pkt_len ; int <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> ""%9d.%9d:<S2SV_blank>%15[a-z0-9/:.-](%1[io])<S2SV_blank>len=%9d:%12s->%12s/"" <S2SV_ModEnd> <S2SV_ModStart> ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""netscreen:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ; return FALSE "
212,<S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> <S2SV_StartBug> ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ret ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> o2nm_unlock_subsystem ( ) ; 
213,"<S2SV_StartBug> memcpy ( new , ours , sizeof ( * new ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ) ; memset ( dte , 0 , sizeof ( * dte "
214,<S2SV_StartBug> if ( ! PPEEK_IS ( ')' ) ) return ONIGERR_INVALID_GROUP_NAME ; <S2SV_EndBug> ,"<S2SV_ModStart> { r = ONIGERR_INVALID_GROUP_NAME ; onig_scan_env_set_error_string ( env , r , p - 1 , p + 1 ) ; return r ; } <S2SV_ModEnd> "
215,"<S2SV_StartBug> FRAME_CONTEXT * fc = & cm -> fc ; <S2SV_EndBug> <S2SV_StartBug> fc -> intra_inter_prob [ i ] = adapt_prob ( pre_fc -> intra_inter_prob [ i ] , <S2SV_EndBug> <S2SV_StartBug> fc -> comp_inter_prob [ i ] = adapt_prob ( pre_fc -> comp_inter_prob [ i ] , <S2SV_EndBug> <S2SV_StartBug> fc -> comp_ref_prob [ i ] = adapt_prob ( pre_fc -> comp_ref_prob [ i ] , <S2SV_EndBug> <S2SV_StartBug> fc -> single_ref_prob [ i ] [ j ] = adapt_prob ( pre_fc -> single_ref_prob [ i ] [ j ] , <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_inter_mode_tree , pre_fc -> inter_mode_probs [ i ] , <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_intra_mode_tree , pre_fc -> y_mode_prob [ i ] , <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_intra_mode_tree , pre_fc -> uv_mode_prob [ i ] , <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_partition_tree , pre_fc -> partition_prob [ i ] , <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_switchable_interp_tree , pre_fc -> switchable_interp_prob [ i ] , <S2SV_EndBug> <S2SV_StartBug> fc -> tx_probs . p8x8 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p8x8 [ i ] [ j ] , <S2SV_EndBug> <S2SV_StartBug> fc -> tx_probs . p16x16 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p16x16 [ i ] [ j ] , <S2SV_EndBug> <S2SV_StartBug> fc -> tx_probs . p32x32 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p32x32 [ i ] [ j ] , <S2SV_EndBug> <S2SV_StartBug> fc -> skip_probs [ i ] = adapt_prob ( pre_fc -> skip_probs [ i ] , counts -> skip [ i ] ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs ( <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_merge_probs <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_merge_probs <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_merge_probs <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_merge_probs <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_merge_probs <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs ( <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs ( <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs ( <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs ( <S2SV_ModEnd> 
216,<S2SV_StartBug> struct snd_kcontrol * kctl ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( card -> last_numid >= UINT_MAX - count ) card -> last_numid = 0 
217,"<S2SV_StartBug> void * shared_kaddr ; <S2SV_EndBug> <S2SV_StartBug> struct pvclock_vcpu_time_info * guest_hv_clock ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vcpu -> time_page ) <S2SV_EndBug> <S2SV_StartBug> shared_kaddr = kmap_atomic ( vcpu -> time_page ) ; <S2SV_EndBug> <S2SV_StartBug> pvclock_flags = ( guest_hv_clock -> flags & PVCLOCK_GUEST_STOPPED ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( shared_kaddr + vcpu -> time_offset , & vcpu -> hv_clock , <S2SV_EndBug> <S2SV_StartBug> kunmap_atomic ( shared_kaddr ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pv_time_enabled <S2SV_ModEnd> <S2SV_ModStart> if ( unlikely ( kvm_read_guest_cached ( v -> kvm , & vcpu -> pv_time , & guest_hv_clock , sizeof ( guest_hv_clock ) ) ) ) return 0 <S2SV_ModEnd> <S2SV_ModStart> . <S2SV_ModEnd> <S2SV_ModStart> kvm_write_guest_cached ( v -> kvm , & vcpu -> pv_time , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
218,"<S2SV_StartBug> int64_t vp9_block_error_c ( const int16_t * coeff , const int16_t * dqcoeff , <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> 
219,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> ",<S2SV_ModStart> key_is_negative ( key <S2SV_ModEnd> 
220,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
221,"<S2SV_StartBug> void Huff_offsetReceive ( node_t * node , int * ch , byte * fin , int * offset ) { <S2SV_EndBug> <S2SV_StartBug> while ( node && node -> symbol == INTERNAL_NODE ) { <S2SV_EndBug> ","<S2SV_ModStart> , int maxoffset <S2SV_ModStart> if ( bloc >= maxoffset ) { * ch = 0 ; * offset = maxoffset + 1 ; return ; } "
222,<S2SV_StartBug> bufsize = file -> size ; <S2SV_EndBug> ,"<S2SV_ModStart> MIN ( <S2SV_ModStart> , sizeof buf ) "
223,<S2SV_StartBug> next_byte : <S2SV_EndBug> ,<S2SV_ModStart> if ( s -> pc - pc_start > 14 ) { goto illegal_op ; } 
224,<S2SV_StartBug> return true ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ndp_msg_type_info ( msg_type ) -> addrto_validate ) return ndp_msg_type_info ( msg_type ) -> addrto_validate ( & msg -> addrto ) ; else 
225,"<S2SV_StartBug> if ( ! ( segment -> temporal_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> temporal_offset_entries ) ) ) || <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < segment -> nb_index_entries ; i ++ ) { <S2SV_EndBug> ",<S2SV_ModStart> segment -> nb_index_entries && length < 11 ) return AVERROR_INVALIDDATA ; if ( <S2SV_ModStart> if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; 
226,<S2SV_StartBug> const float factor = 0.5 ; <S2SV_EndBug> <S2SV_StartBug> if ( rc -> av_per_frame_bandwidth < factor * number_blocks || <S2SV_EndBug> ,<S2SV_ModStart> 0.25 <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> 
227,"<S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; <S2SV_EndBug> <S2SV_StartBug> pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads , <S2SV_EndBug> <S2SV_StartBug> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> ","<S2SV_ModStart> rows ; rows = MagickMax ( GetImageListLength ( images ) , <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> rows , <S2SV_ModEnd> <S2SV_ModStart> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 <S2SV_ModEnd> <S2SV_ModStart> rows <S2SV_ModEnd> "
228,"<S2SV_StartBug> char * pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"" ; <S2SV_EndBug> ","<S2SV_ModStart> ""/lxc/lock/var/lib/lxc/"" <S2SV_ModEnd> "
229,"<S2SV_StartBug> result = send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
230,"<S2SV_StartBug> uint32_t off = offset , tmp , finish ; <S2SV_EndBug> <S2SV_StartBug> finish = fru -> size ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> memcpy ( frubuf , rsp -> data + 1 , tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp == 0 && off < finish ) { <S2SV_EndBug> ","<S2SV_ModStart> ; uint32_t tmp ; uint32_t finish ; uint32_t size_left_in_buffer <S2SV_ModEnd> <S2SV_ModStart> memset ( frubuf + fru -> size , 0 , length - fru -> size ) ; <S2SV_ModStart> length = finish - offset ; <S2SV_ModStart> size_left_in_buffer = length ; <S2SV_ModStart> if ( rsp -> data_len < 1 || tmp > rsp -> data_len - 1 || tmp > size_left_in_buffer ) { printf ( ""<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>buffer<S2SV_blank>size"" ) ; return - 1 ; } <S2SV_ModStart> size_left_in_buffer -= tmp ; "
231,<S2SV_StartBug> if ( buffer ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
232,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> peer = NULL ; 
233,<S2SV_StartBug> static uid_t uid_server = 0 ; <S2SV_EndBug> <S2SV_StartBug> uid_server = getuid ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( gid_cluster != 0 && gid_client != 0 ) { <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> uid_client != 0 ) { crm_trace ( ""Giving<S2SV_blank>access<S2SV_blank>to<S2SV_blank>group<S2SV_blank>%u"" , gid_cluster ) ; qb_ipcs_connection_auth_set ( c , - 1 <S2SV_ModEnd> "
234,<S2SV_StartBug> if ( client -> type == USER_CLIENT ) <S2SV_EndBug> ,<S2SV_ModStart> && client -> data . user . fifo 
235,"<S2SV_StartBug> stmt_ty s ; <S2SV_EndBug> <S2SV_StartBug> mod_ty res = NULL ; <S2SV_EndBug> <S2SV_StartBug> res = Module ( stmts , arena ) ; <S2SV_EndBug> <S2SV_StartBug> default : <S2SV_EndBug> ","<S2SV_ModStart> asdl_seq * type_ignores = NULL ; <S2SV_ModStart> ; asdl_seq * argtypes = NULL ; expr_ty ret , arg <S2SV_ModStart> ch = CHILD ( n , NCH ( n ) - 1 ) ; REQ ( ch , ENDMARKER ) ; num = NCH ( ch ) ; type_ignores = _Py_asdl_seq_new ( num , arena ) ; if ( ! type_ignores ) goto out ; for ( i = 0 ; i < num ; i ++ ) { type_ignore_ty ti = TypeIgnore ( LINENO ( CHILD ( ch , i ) ) , arena ) ; if ( ! ti ) goto out ; asdl_seq_SET ( type_ignores , i , ti ) ; } <S2SV_ModStart> , type_ignores <S2SV_ModStart> case func_type_input : n = CHILD ( n , 0 ) ; REQ ( n , func_type ) ; if ( TYPE ( CHILD ( n , 1 ) ) == typelist ) { ch = CHILD ( n , 1 ) ; num = 0 ; for ( i = 0 ; i < NCH ( ch ) ; i ++ ) { if ( TYPE ( CHILD ( ch , i ) ) == test ) { num ++ ; } } argtypes = _Py_asdl_seq_new ( num , arena ) ; if ( ! argtypes ) goto out ; j = 0 ; for ( i = 0 ; i < NCH ( ch ) ; i ++ ) { if ( TYPE ( CHILD ( ch , i ) ) == test ) { arg = ast_for_expr ( & c , CHILD ( ch , i ) ) ; if ( ! arg ) goto out ; asdl_seq_SET ( argtypes , j ++ , arg ) ; } } } else { argtypes = _Py_asdl_seq_new ( 0 , arena ) ; if ( ! argtypes ) goto out ; } ret = ast_for_expr ( & c , CHILD ( n , NCH ( n ) - 1 ) ) ; if ( ! ret ) goto out ; res = FunctionType ( argtypes , ret , arena ) ; break ; "
236,"<S2SV_StartBug> uint8_t chipRevision ; <S2SV_EndBug> <S2SV_StartBug> vendorId = ( dm9000ReadReg ( DM9000_REG_VIDH ) << 8 ) | dm9000ReadReg ( DM9000_REG_VIDL ) ; <S2SV_EndBug> <S2SV_StartBug> productId = ( dm9000ReadReg ( DM9000_REG_PIDH ) << 8 ) | dm9000ReadReg ( DM9000_REG_PIDL ) ; <S2SV_EndBug> <S2SV_StartBug> chipRevision = dm9000ReadReg ( DM9000_REG_CHIPR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( chipRevision != DM9000A_CHIP_REV && chipRevision != DM9000B_CHIP_REV ) <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_GPR , 0x00 ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_NCR , NCR_RST ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( dm9000ReadReg ( DM9000_REG_NCR ) & NCR_RST ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> dm9000WritePhyReg ( DM9000_PHY_REG_BMCR , BMCR_RST ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( dm9000ReadPhyReg ( DM9000_PHY_REG_BMCR ) & BMCR_RST ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> TRACE_INFO ( ""<S2SV_blank><S2SV_blank>CHIPR<S2SV_blank>=<S2SV_blank>0x%02"" PRIX8 ""\\r\\n"" , chipRevision ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_INFO ( ""<S2SV_blank><S2SV_blank>PHYIDR1<S2SV_blank>=<S2SV_blank>0x%04"" PRIX16 ""\\r\\n"" , dm9000ReadPhyReg ( DM9000_PHY_REG_PHYIDR1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_INFO ( ""<S2SV_blank><S2SV_blank>PHYIDR2<S2SV_blank>=<S2SV_blank>0x%04"" PRIX16 ""\\r\\n"" , dm9000ReadPhyReg ( DM9000_PHY_REG_PHYIDR2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_NCR , DM9000_LBK_PHY ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WritePhyReg ( DM9000_PHY_REG_BMCR , BMCR_LOOPBACK | BMCR_SPEED_SEL | BMCR_AN_EN | BMCR_DUPLEX_MODE ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_PAR0 + i , interface -> macAddr . b [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_MAR0 + i , 0x00 ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_MAR7 , 0x80 ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_IMR , IMR_PAR ) ; <S2SV_EndBug> ","<S2SV_ModStart> chipRev <S2SV_ModEnd> <S2SV_ModStart> DM9000_VIDH <S2SV_ModEnd> <S2SV_ModStart> DM9000_VIDL <S2SV_ModEnd> <S2SV_ModStart> DM9000_PIDH <S2SV_ModEnd> <S2SV_ModStart> DM9000_PIDL ) ; chipRev <S2SV_ModEnd> <S2SV_ModStart> DM9000_CHIPR <S2SV_ModEnd> <S2SV_ModStart> chipRev != DM9000_CHIPR_REV_A && chipRev != DM9000_CHIPR_REV_B <S2SV_ModEnd> <S2SV_ModStart> DM9000_GPR <S2SV_ModEnd> <S2SV_ModStart> DM9000_NCR , DM9000_NCR_RST <S2SV_ModEnd> <S2SV_ModStart> DM9000_NCR ) & DM9000_NCR_RST <S2SV_ModEnd> <S2SV_ModStart> DM9000_BMCR , DM9000_BMCR_RST <S2SV_ModEnd> <S2SV_ModStart> DM9000_BMCR ) & DM9000_BMCR_RST <S2SV_ModEnd> <S2SV_ModStart> chipRev <S2SV_ModEnd> <S2SV_ModStart> DM9000_PHYIDR1 <S2SV_ModEnd> <S2SV_ModStart> DM9000_PHYIDR2 <S2SV_ModEnd> <S2SV_ModStart> DM9000_NCR , DM9000_NCR_LBK_PHY <S2SV_ModEnd> <S2SV_ModStart> DM9000_BMCR , DM9000_BMCR_LOOPBACK | DM9000_BMCR_SPEED_SEL | DM9000_BMCR_AN_EN | DM9000_BMCR_DUPLEX_MODE <S2SV_ModEnd> <S2SV_ModStart> DM9000_PAR0 <S2SV_ModEnd> <S2SV_ModStart> DM9000_MAR0 <S2SV_ModEnd> <S2SV_ModStart> DM9000_MAR7 <S2SV_ModEnd> <S2SV_ModStart> DM9000_IMR , DM9000_IMR_PAR ) ; dm9000WriteReg ( DM9000_NSR , DM9000_NSR_WAKEST | DM9000_NSR_TX2END | DM9000_NSR_TX1END ) ; dm9000WriteReg ( DM9000_ISR , DM9000_ISR_LNKCHG | DM9000_ISR_UDRUN | DM9000_ISR_ROO | DM9000_ISR_ROS | DM9000_ISR_PT | DM9000_ISR_PR ) ; dm9000WriteReg ( DM9000_IMR , DM9000_IMR_PAR | DM9000_IMR_LNKCHGI | DM9000_IMR_PTI | DM9000_IMR_PRI ) ; dm9000WriteReg ( DM9000_RCR , DM9000_RCR_DIS_LONG | DM9000_RCR_DIS_CRC | DM9000_RCR_RXEN <S2SV_ModEnd> "
237,<S2SV_StartBug> int64_t old_off = s -> off ; <S2SV_EndBug> <S2SV_StartBug> else if ( ( s -> filesize == - 1 && whence == SEEK_END ) ) <S2SV_EndBug> ,<S2SV_ModStart> uint64_t <S2SV_ModEnd> <S2SV_ModStart> UINT64_MAX <S2SV_ModEnd> 
238,<S2SV_StartBug> vp9_coeff_probs_model * const probs = cm -> fc . coef_probs [ tx_size ] ; <S2SV_EndBug> ,<S2SV_ModStart> -> <S2SV_ModEnd> 
239,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> horDiff32 ( tif , cp0 , cc ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( ! <S2SV_ModStart> ) return 0 <S2SV_ModStart> return 1 ; 
240,"<S2SV_StartBug> static void nfs_set_open_stateid_locked ( struct nfs4_state * state , nfs4_stateid * stateid , int open_flags ) <S2SV_EndBug> <S2SV_StartBug> switch ( open_flags ) { <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> 
241,<S2SV_StartBug> cf . can_id = 0 ; <S2SV_EndBug> <S2SV_StartBug> * ( u64 * ) ( & cf . data ) = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & cf , 0 , sizeof ( cf ) ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
242,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> g_free_not_null ( ircconn -> sasl_username ) ; g_free_not_null ( ircconn -> sasl_password ) ; 
243,<S2SV_StartBug> sock -> sk -> sk_uid = iattr -> ia_uid ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( sock -> sk ) <S2SV_ModStart> else err = - ENOENT ; 
244,<S2SV_StartBug> char * buffer = ( char * ) dlmalloc ( bytes + CHK_OVERHEAD_SIZE ) ; <S2SV_EndBug> ,<S2SV_ModStart> size_t size = bytes + CHK_OVERHEAD_SIZE ; if ( size < bytes ) { return NULL ; } uint8_t <S2SV_ModEnd> <S2SV_ModStart> uint8_t <S2SV_ModEnd> <S2SV_ModStart> size <S2SV_ModEnd> 
245,"<S2SV_StartBug> if ( ! __archive_ppmd7_functions . Ppmd7_Alloc ( & rar -> ppmd7_context , <S2SV_EndBug> ","<S2SV_ModStart> rar -> dictionary_size == 0 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>zero<S2SV_blank>dictionary<S2SV_blank>size"" ) ; return ( ARCHIVE_FATAL ) ; } if ( "
246,<S2SV_StartBug> return code ; <S2SV_EndBug> ,"<S2SV_ModStart> { * status = ""DECODE_PA_FOR_USER"" ; return code ; } <S2SV_ModEnd> "
247,"<S2SV_StartBug> # line 585 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> case 'O' : goto yy13 ; <S2SV_EndBug> <S2SV_StartBug> case 'R' : goto yy2 ; <S2SV_EndBug> <S2SV_StartBug> case 'S' : goto yy10 ; <S2SV_EndBug> <S2SV_StartBug> case 'a' : goto yy11 ; <S2SV_EndBug> <S2SV_StartBug> case 'b' : goto yy6 ; <S2SV_EndBug> <S2SV_StartBug> case 'd' : goto yy8 ; <S2SV_EndBug> <S2SV_StartBug> case 'i' : goto yy7 ; <S2SV_EndBug> <S2SV_StartBug> case 'r' : goto yy4 ; <S2SV_EndBug> <S2SV_StartBug> case 's' : goto yy9 ; <S2SV_EndBug> <S2SV_StartBug> case '}' : goto yy14 ; <S2SV_EndBug> <S2SV_StartBug> default : goto yy16 ; <S2SV_EndBug> <S2SV_StartBug> # line 962 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 646 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> if ( yych == ':' ) goto yy89 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych == ';' ) goto yy87 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych == ':' ) goto yy83 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych == ':' ) goto yy77 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych == ':' ) goto yy53 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych == ':' ) goto yy46 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych == ':' ) goto yy39 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych == ':' ) goto yy32 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych == ':' ) goto yy25 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych == ':' ) goto yy17 ; <S2SV_EndBug> <S2SV_StartBug> yy14 : <S2SV_EndBug> <S2SV_StartBug> # line 956 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 695 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> goto yy20 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych == '+' ) goto yy19 ; <S2SV_EndBug> <S2SV_StartBug> goto yy20 ; <S2SV_EndBug> <S2SV_StartBug> goto yy20 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych >= ';' ) goto yy18 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych != \'""\' ) goto yy18 ; <S2SV_EndBug> <S2SV_StartBug> # line 804 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> if ( * start == 'C' ) { <S2SV_EndBug> <S2SV_StartBug> len2 = len = parse_uiv ( start + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> * p = start + 2 ; <S2SV_EndBug> <S2SV_StartBug> # line 878 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( yych <= '9' ) goto yy27 ; <S2SV_EndBug> <S2SV_StartBug> # line 793 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> zend_long elements = parse_iv ( start + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> # line 959 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> if ( yych == '+' ) goto yy40 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych <= '9' ) goto yy41 ; <S2SV_EndBug> <S2SV_StartBug> # line 735 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1292 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 646 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> ZVAL_BOOL ( rval , parse_iv ( start + 2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> # line 1306 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 640 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> id = parse_iv ( start + 2 ) - 1 ; <S2SV_EndBug> <S2SV_StartBug> * p = YYCURSOR ; <S2SV_EndBug> <S2SV_StartBug> id = parse_iv ( start + 2 ) - 1 ; <S2SV_EndBug> <S2SV_StartBug> zval_ptr_dtor ( rval ) ; <S2SV_EndBug> <S2SV_StartBug> if ( Z_ISREF_P ( rval_ref ) ) { <S2SV_EndBug> <S2SV_StartBug> ZVAL_COPY ( rval , rval_ref ) ; <S2SV_EndBug> <S2SV_StartBug> ZVAL_NEW_REF ( rval_ref , rval_ref ) ; <S2SV_EndBug> <S2SV_StartBug> ZVAL_COPY ( rval , rval_ref ) ; <S2SV_EndBug> <S2SV_StartBug> # line 1412 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> ","<S2SV_ModStart> 576 <S2SV_ModEnd> <S2SV_ModStart> yy4 <S2SV_ModEnd> <S2SV_ModStart> yy6 <S2SV_ModEnd> <S2SV_ModStart> yy7 <S2SV_ModEnd> <S2SV_ModStart> yy8 <S2SV_ModEnd> <S2SV_ModStart> yy9 <S2SV_ModEnd> <S2SV_ModStart> yy10 <S2SV_ModEnd> <S2SV_ModStart> yy11 <S2SV_ModEnd> <S2SV_ModStart> yy13 <S2SV_ModEnd> <S2SV_ModStart> yy14 <S2SV_ModEnd> <S2SV_ModStart> yy15 <S2SV_ModEnd> <S2SV_ModStart> yy2 ; } yy2 : ++ YYCURSOR <S2SV_ModEnd> <S2SV_ModStart> 951 <S2SV_ModEnd> <S2SV_ModStart> 636 <S2SV_ModEnd> <S2SV_ModStart> yy17 <S2SV_ModEnd> <S2SV_ModStart> yy19 <S2SV_ModEnd> <S2SV_ModStart> yy21 <S2SV_ModEnd> <S2SV_ModStart> yy22 <S2SV_ModEnd> <S2SV_ModStart> yy23 <S2SV_ModEnd> <S2SV_ModStart> yy24 <S2SV_ModEnd> <S2SV_ModStart> yy25 <S2SV_ModEnd> <S2SV_ModStart> yy26 <S2SV_ModEnd> <S2SV_ModStart> yy27 <S2SV_ModEnd> <S2SV_ModStart> yy28 <S2SV_ModEnd> <S2SV_ModStart> : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy29 ; goto yy3 ; yy15 <S2SV_ModStart> 945 <S2SV_ModEnd> <S2SV_ModStart> 689 ""ext/standard/var_unserializer.c"" <S2SV_ModEnd> <S2SV_ModStart> yy31 <S2SV_ModEnd> <S2SV_ModStart> yy30 ; yy18 : YYCURSOR = YYMARKER ; goto yy3 ; yy19 : ++ YYCURSOR ; # line 629 ""ext/standard/var_unserializer.re"" { * p = YYCURSOR ; ZVAL_NULL ( rval ) ; return 1 ; } # line 707 ""ext/standard/var_unserializer.c"" yy21 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych == '+' ) goto yy33 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy33 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy34 ; goto yy18 ; } yy22 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy36 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy37 ; goto yy18 ; yy23 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy39 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy40 ; goto yy18 ; yy24 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '1' ) goto yy42 ; goto yy18 ; yy25 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) { if ( yych <= ',' ) { if ( yych == '+' ) goto yy43 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy44 ; if ( yych <= '.' ) goto yy45 ; goto yy18 ; } } else { if ( yych <= 'I' ) { if ( yych <= '9' ) goto yy46 ; if ( yych <= 'H' ) goto yy18 ; goto yy48 ; } else { if ( yych == 'N' ) goto yy49 ; goto yy18 ; } } yy26 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych == '+' ) goto yy50 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy50 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy51 ; goto yy18 ; } yy27 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych == '+' ) goto yy53 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy53 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy54 ; goto yy18 ; } yy28 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych == '+' ) goto yy56 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy56 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy57 ; goto yy18 ; } yy29 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy59 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy60 ; goto yy18 ; yy30 <S2SV_ModEnd> <S2SV_ModStart> yy31 ; } goto yy18 ; yy31 <S2SV_ModEnd> <S2SV_ModStart> yy31 <S2SV_ModEnd> <S2SV_ModStart> <= ':' ) goto yy62 ; goto yy18 ; yy33 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy34 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy34 ; if ( yych == <S2SV_ModEnd> <S2SV_ModStart> yy63 ; goto yy18 ; yy36 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy37 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy37 ; if ( yych <= ':' ) goto yy65 ; goto yy18 ; yy39 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy40 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy40 ; if ( yych <= ':' ) goto yy66 ; goto yy18 ; yy42 : yych = * ++ YYCURSOR ; if ( yych == ';' ) goto yy67 ; goto yy18 ; yy43 : yych = * ++ YYCURSOR ; if ( yych == '.' ) goto yy45 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy46 ; goto yy18 ; yy44 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) { <S2SV_ModEnd> <S2SV_ModStart> '.' ) goto yy18 ; } else { if ( yych <= '9' ) goto yy46 ; if ( yych == 'I' ) goto yy48 ; goto yy18 ; } yy45 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy69 ; goto yy18 ; yy46 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 4 ) YYFILL ( 4 ) ; yych = * YYCURSOR ; if ( yych <= ':' ) { if ( yych <= '.' ) { if ( yych <= '-' ) goto yy18 ; goto yy69 ; } else { if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy46 ; goto yy18 ; } } else { if ( yych <= 'E' ) { if ( yych <= ';' ) goto yy71 ; if ( yych <= 'D' ) goto yy18 ; goto yy73 ; } else { if ( yych == 'e' ) goto yy73 ; goto yy18 ; } } yy48 : yych = * ++ YYCURSOR ; if ( yych == 'N' ) goto yy74 ; goto yy18 ; yy49 : yych = * ++ YYCURSOR ; if ( yych == 'A' ) goto yy75 ; goto yy18 ; yy50 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy51 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy51 ; if ( yych == ';' ) goto yy76 ; goto yy18 ; yy53 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy54 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy54 ; if ( yych <= ':' ) goto yy78 ; goto yy18 ; yy56 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy57 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy57 ; if ( yych == ';' ) goto yy79 ; goto yy18 ; yy59 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy60 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy60 ; if ( yych <= ':' ) goto yy81 ; goto yy18 ; yy62 : yych = * ++ YYCURSOR ; if ( yych == <S2SV_ModStart> yy82 ; goto yy18 ; yy63 : <S2SV_ModEnd> <S2SV_ModStart> 580 ""ext/standard/var_unserializer.re"" { zend_long id ; * p = YYCURSOR <S2SV_ModEnd> <S2SV_ModStart> id = parse_iv <S2SV_ModEnd> <S2SV_ModStart> - 1 ; if ( id == - 1 || ( rval_ref = var_access ( var_hash , id ) ) == NULL ) { return 0 ; } if ( Z_ISUNDEF_P ( rval_ref ) || ( Z_ISREF_P ( rval_ref ) && Z_ISUNDEF_P ( Z_REFVAL_P ( rval_ref ) ) ) ) { return 0 ; } if ( Z_ISREF_P ( rval_ref ) ) { ZVAL_COPY ( rval , rval_ref ) ; } else { ZVAL_NEW_REF ( rval_ref , rval_ref ) ; ZVAL_COPY ( rval , rval_ref ) ; } return 1 ; } # line 982 ""ext/standard/var_unserializer.c"" yy65 : yych = * ++ YYCURSOR ; if ( yych == \'""\' ) goto yy84 ; goto yy18 ; yy66 : yych = * ++ YYCURSOR ; if ( yych == '{' ) goto yy86 ; goto yy18 ; yy67 : ++ YYCURSOR ; # line 635 ""ext/standard/var_unserializer.re"" <S2SV_ModEnd> <S2SV_ModStart> YYCURSOR ; ZVAL_BOOL ( rval , parse_iv ( <S2SV_ModStart> ) ) ; return 1 <S2SV_ModEnd> <S2SV_ModStart> 999 ""ext/standard/var_unserializer.c"" yy69 <S2SV_ModEnd> <S2SV_ModStart> 4 <S2SV_ModEnd> <S2SV_ModStart> 4 ) ; yych = * YYCURSOR ; if ( yych <= ';' ) { <S2SV_ModEnd> <S2SV_ModStart> yy69 ; if ( yych <= ':' ) goto yy18 ; } else { if ( yych <= 'E' ) { if ( yych <= 'D' ) goto yy18 ; goto yy73 ; } else { if ( yych == 'e' ) goto yy73 ; goto yy18 ; } } yy71 : <S2SV_ModEnd> <S2SV_ModStart> 683 ""ext/standard/var_unserializer.re"" { # if SIZEOF_ZEND_LONG == 4 use_double : # endif * p = YYCURSOR ; ZVAL_DOUBLE ( rval , zend_strtod ( ( const char * ) <S2SV_ModEnd> <S2SV_ModStart> , NULL ) ) ; return 1 <S2SV_ModEnd> <S2SV_ModStart> 1028 ""ext/standard/var_unserializer.c"" yy73 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { <S2SV_ModEnd> <S2SV_ModStart> yy88 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy88 <S2SV_ModEnd> <S2SV_ModStart> yy89 ; goto yy18 ; } yy74 : yych = * ++ YYCURSOR ; if ( yych == 'F' ) goto yy91 ; goto yy18 ; yy75 : yych = * ++ YYCURSOR ; if ( yych == 'N' ) goto yy91 ; goto yy18 ; yy76 : <S2SV_ModEnd> <S2SV_ModStart> 641 <S2SV_ModEnd> <S2SV_ModStart> 1076 ""ext/standard/var_unserializer.c"" yy78 : yych = * ++ YYCURSOR ; if ( yych == \'""\' ) goto yy92 ; goto yy18 ; yy79 : <S2SV_ModEnd> <S2SV_ModStart> 605 ""ext/standard/var_unserializer.re"" { zend_long id ; <S2SV_ModEnd> <S2SV_ModStart> if ( ! var_hash ) return 0 ; id = <S2SV_ModEnd> <S2SV_ModStart> - 1 ; if ( id == - 1 || ( rval_ref = var_access ( var_hash , id ) ) == NULL ) { return 0 ; } if ( rval_ref == rval ) { return 0 ; } if ( Z_ISUNDEF_P ( rval_ref ) || ( Z_ISREF_P ( rval_ref ) && Z_ISUNDEF_P ( Z_REFVAL_P ( rval_ref ) ) ) ) { return 0 ; } ZVAL_COPY ( rval , rval_ref <S2SV_ModStart> 1107 ""ext/standard/var_unserializer.c"" yy81 : yych = * ++ YYCURSOR ; if ( yych == \'""\' ) goto yy94 ; goto yy18 ; yy82 <S2SV_ModEnd> <S2SV_ModStart> 793 ""ext/standard/var_unserializer.re"" { size_t len , len2 , len3 , maxlen ; zend_long elements ; char * str ; zend_string * class_name ; zend_class_entry * ce ; int incomplete_class = 0 ; int custom_object = 0 ; zval user_func ; zval retval ; zval args [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> if ( * start == 'C' ) { custom_object = 1 ; } len2 = len = parse_uiv <S2SV_ModEnd> <S2SV_ModStart> ; maxlen = max - YYCURSOR ; if ( maxlen < len || len == 0 ) { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; return 0 ; } str = ( char * ) YYCURSOR ; YYCURSOR += len ; if ( * ( YYCURSOR ) != \'""\' ) { * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ':' ) { * p = YYCURSOR + 1 ; return 0 ; } len3 = strspn ( str , ""0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\177\\200\\201\\202\\203\\204\\205\\206\\207\\210\\211\\212\\213\\214\\215\\216\\217\\220\\221\\222\\223\\224\\225\\226\\227\\230\\231\\232\\233\\234\\235\\236\\237\\240\\241\\242\\243\\244\\245\\246\\247\\250\\251\\252\\253\\254\\255\\256\\257\\260\\261\\262\\263\\264\\265\\266\\267\\270\\271\\272\\273\\274\\275\\276\\277\\300\\301\\302\\303\\304\\305\\306\\307\\310\\311\\312\\313\\314\\315\\316\\317\\320\\321\\322\\323\\324\\325\\326\\327\\330\\331\\332\\333\\334\\335\\336\\337\\340\\341\\342\\343\\344\\345\\346\\347\\350\\351\\352\\353\\354\\355\\356\\357\\360\\361\\362\\363\\364\\365\\366\\367\\370\\371\\372\\373\\374\\375\\376\\377\\\\"" ) ; if ( len3 != len ) { * p = YYCURSOR + len3 - len ; return 0 ; } class_name = zend_string_init ( str , len , 0 ) ; do { if ( ! unserialize_allowed_class ( class_name , classes ) ) { incomplete_class = 1 ; ce = PHP_IC_ENTRY ; break ; } BG ( serialize_lock ) ++ ; ce = zend_lookup_class ( class_name ) ; if ( ce ) { BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { zend_string_release ( class_name ) ; return 0 ; } break ; } BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { zend_string_release ( class_name ) ; return 0 ; } if ( ( PG ( unserialize_callback_func ) == NULL ) || ( PG ( unserialize_callback_func ) [ 0 ] == '\\0' ) ) { incomplete_class = 1 ; ce = PHP_IC_ENTRY ; break ; } ZVAL_STRING ( & user_func , PG ( unserialize_callback_func ) ) ; ZVAL_STR_COPY ( & args [ 0 ] , class_name ) ; BG ( serialize_lock ) ++ ; if ( call_user_function_ex ( CG ( function_table ) , NULL , & user_func , & retval , 1 , args , 0 , NULL ) != SUCCESS ) { BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { zend_string_release ( class_name ) ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & args [ 0 ] ) ; return 0 ; } php_error_docref ( NULL , E_WARNING , ""defined<S2SV_blank>(%s)<S2SV_blank>but<S2SV_blank>not<S2SV_blank>found"" , Z_STRVAL ( user_func ) ) ; incomplete_class = 1 ; ce = PHP_IC_ENTRY ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & args [ 0 ] ) ; break ; } BG ( serialize_lock ) -- ; zval_ptr_dtor ( & retval ) ; if ( EG ( exception ) ) { zend_string_release ( class_name ) ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & args [ 0 ] ) ; return 0 ; } BG ( serialize_lock ) ++ ; if ( ( ce = zend_lookup_class ( class_name ) ) == NULL ) { php_error_docref ( NULL , E_WARNING , ""Function<S2SV_blank>%s()<S2SV_blank>hasn\'t<S2SV_blank>defined<S2SV_blank>the<S2SV_blank>class<S2SV_blank>it<S2SV_blank>was<S2SV_blank>called<S2SV_blank>for"" , Z_STRVAL ( user_func ) ) ; incomplete_class = 1 ; ce = PHP_IC_ENTRY ; } BG ( serialize_lock ) -- ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & args [ 0 ] ) ; break ; } while ( 1 ) ; * p = YYCURSOR ; if ( custom_object ) { int ret ; ret = object_custom ( UNSERIALIZE_PASSTHRU , ce ) ; if ( ret && incomplete_class ) { php_store_class_name ( rval , ZSTR_VAL ( class_name ) , len2 ) ; } zend_string_release ( class_name ) ; return ret ; } elements = object_common1 ( UNSERIALIZE_PASSTHRU , ce ) ; if ( elements < 0 ) { zend_string_release ( class_name ) ; return 0 ; } if ( incomplete_class ) { php_store_class_name ( rval , ZSTR_VAL ( class_name ) , len2 ) ; } zend_string_release ( class_name ) ; return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ; } # line 1266 ""ext/standard/var_unserializer.c"" yy84 : ++ YYCURSOR ; # line 724 ""ext/standard/var_unserializer.re"" { size_t len , maxlen ; zend_string * str ; len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len ) { * p = start + 2 ; return 0 ; } if ( ( str = unserialize_str ( & YYCURSOR , len , maxlen ) ) == NULL ) { return 0 ; } if ( * ( YYCURSOR ) != \'""\' ) { zend_string_free ( str ) ; * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ';' ) { efree ( str ) ; * p = YYCURSOR + 1 ; <S2SV_ModEnd> <S2SV_ModStart> YYCURSOR += 2 ; * p = YYCURSOR ; ZVAL_STR ( rval , str <S2SV_ModEnd> <S2SV_ModStart> # line 1303 ""ext/standard/var_unserializer.c"" yy86 : ++ YYCURSOR ; # line 758 ""ext/standard/var_unserializer.re"" { zend_long elements = parse_iv ( start + 2 ) ; * p = YYCURSOR ; if ( ! var_hash ) return 0 ; if ( elements < 0 || elements >= HT_MAX_SIZE ) { return 0 ; } array_init_size <S2SV_ModEnd> <S2SV_ModStart> elements ) ; if ( elements ) { zend_hash_real_init ( Z_ARRVAL_P ( rval ) , 0 ) ; } if ( ! process_nested_data ( UNSERIALIZE_PASSTHRU , Z_ARRVAL_P ( rval ) , elements , 0 ) ) { return 0 ; } return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; } # line 1330 ""ext/standard/var_unserializer.c"" yy88 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych == '+' ) goto yy96 ; goto yy18 <S2SV_ModEnd> <S2SV_ModStart> if ( yych <= '-' ) goto yy96 ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; } yy89 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy89 ; if ( yych == ';' ) goto yy71 ; goto yy18 ; yy91 : yych = * ++ YYCURSOR ; if ( yych == ';' ) goto yy97 ; goto yy18 ; yy92 : ++ YYCURSOR ; # line 782 ""ext/standard/var_unserializer.re"" { zend_long elements ; if ( ! var_hash ) return 0 ; elements = object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ; if ( elements < 0 || elements >= HT_MAX_SIZE ) { return 0 ; } return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ; } # line 1366 ""ext/standard/var_unserializer.c"" yy94 : ++ YYCURSOR ; # line 692 ""ext/standard/var_unserializer.re"" { size_t len , maxlen ; char * str ; len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len ) { * p = start + 2 ; return 0 ; } str = ( char * ) YYCURSOR ; YYCURSOR += len ; if ( * ( YYCURSOR ) != \'""\' ) { * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ';' ) { * p = YYCURSOR + 1 ; return 0 ; } YYCURSOR += 2 ; * p = YYCURSOR ; ZVAL_STRINGL <S2SV_ModEnd> <S2SV_ModStart> str , len ) ; <S2SV_ModEnd> <S2SV_ModStart> 1401 ""ext/standard/var_unserializer.c"" yy96 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy89 ; goto yy18 ; yy97 : ++ YYCURSOR ; # line 667 ""ext/standard/var_unserializer.re"" { * p = YYCURSOR ; if ( ! strncmp ( ( char * ) start + 2 , ""NAN"" , 3 ) ) { ZVAL_DOUBLE ( rval , php_get_nan ( ) ) ; } else if ( ! strncmp ( ( char * ) start + 2 , ""INF"" , 3 ) ) { ZVAL_DOUBLE ( rval , php_get_inf ( ) ) ; } else if ( ! strncmp ( ( char * ) start + 2 , ""-INF"" , 4 ) ) { ZVAL_DOUBLE ( rval , - php_get_inf ( ) ) ; } else { ZVAL_NULL ( rval ) ; } return 1 ; } # line 1425 ""ext/standard/var_unserializer.c"" } # line 953 ""ext/standard/var_unserializer.re"" return <S2SV_ModEnd> "
248,<S2SV_StartBug> if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
249,"<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> gossip_err ( ""%s:<S2SV_blank>posix_acl_equiv_mode<S2SV_blank>err:<S2SV_blank>%d\\n"" , <S2SV_EndBug> <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> ","<S2SV_ModStart> ; error = posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( error <S2SV_ModEnd> <S2SV_ModStart> ""%s:<S2SV_blank>posix_acl_update_mode<S2SV_blank>err:<S2SV_blank>%d\\n"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
250,"<S2SV_StartBug> FILE * file = fopen ( dump_file , ""w"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> fopen_safe <S2SV_ModEnd> 
251,"<S2SV_StartBug> uid_eq ( root_uid , current_uid ( ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( gid_eq ( root_gid , current_gid ( ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart> current_euid <S2SV_ModEnd> <S2SV_ModStart> in_egroup_p ( root_gid <S2SV_ModEnd> 
252,<S2SV_StartBug> # ifdef KEY_DEBUGGING <S2SV_EndBug> ,<S2SV_ModStart> if ( flags & KEY_ALLOC_UID_KEYRING ) key -> flags |= 1 << KEY_FLAG_UID_KEYRING ; 
253,"<S2SV_StartBug> int64_t vp9_rd_pick_inter_mode_sub8x8 ( VP9_COMP * cpi , MACROBLOCK * x , <S2SV_EndBug> <S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int * returnrate , <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * xd = & x -> e_mbd ; <S2SV_EndBug> <S2SV_StartBug> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> const struct segmentation * seg = & cm -> seg ; <S2SV_EndBug> <S2SV_StartBug> int64_t best_tx_rd [ TX_MODES ] ; <S2SV_EndBug> <S2SV_StartBug> MB_MODE_INFO best_mbmode = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob comp_mode_p ; <S2SV_EndBug> <S2SV_StartBug> int rate_uv_intra [ TX_SIZES ] , rate_uv_tokenonly [ TX_SIZES ] ; <S2SV_EndBug> <S2SV_StartBug> int64_t dist_uv [ TX_SIZES ] ; <S2SV_EndBug> <S2SV_StartBug> int skip_uv [ TX_SIZES ] ; <S2SV_EndBug> <S2SV_StartBug> int intra_cost_penalty = 20 * vp9_dc_quant ( cm -> base_qindex , cm -> y_dc_delta_q ) ; <S2SV_EndBug> <S2SV_StartBug> int ref_frame_mask = 0 ; <S2SV_EndBug> <S2SV_StartBug> x -> skip_encode = cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( x -> zcoeff_blk [ TX_4X4 ] , 0 , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> estimate_ref_frame_costs ( cpi , segment_id , ref_costs_single , ref_costs_comp , <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < TX_MODES ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> best_tx_rd [ i ] = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> * returnrate = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> vp9_setup_buffer_inter ( cpi , x , tile , <S2SV_EndBug> <S2SV_StartBug> frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> for ( mode_index = 0 ; mode_index < MAX_REFS ; ++ mode_index ) { <S2SV_EndBug> <S2SV_StartBug> int64_t tx_cache [ TX_MODES ] ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < TX_MODES ; ++ i ) <S2SV_EndBug> <S2SV_StartBug> ref_frame = vp9_ref_order [ mode_index ] . ref_frame [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> second_ref_frame = vp9_ref_order [ mode_index ] . ref_frame [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( mode_index > 2 && cpi -> sf . mode_skip_start < MAX_MODES ) { <S2SV_EndBug> <S2SV_StartBug> if ( mode_index == 3 ) { <S2SV_EndBug> <S2SV_StartBug> switch ( vp9_ref_order [ best_mode_index ] . ref_frame [ 0 ] ) { <S2SV_EndBug> <S2SV_StartBug> mode_skip_mask = 0 ; <S2SV_EndBug> <S2SV_StartBug> mode_skip_mask = 0x0010 ; <S2SV_EndBug> <S2SV_StartBug> mode_skip_mask = 0x0008 ; <S2SV_EndBug> <S2SV_StartBug> mode_skip_mask = 0x0000 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( mode_skip_mask & ( 1 << mode_index ) ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ( ( int64_t ) cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ mode_index ] * <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_thresh_freq_sub8x8 [ bsize ] [ mode_index ] >> 5 ) ) || <S2SV_EndBug> <S2SV_StartBug> if ( ( second_ref_frame > INTRA_FRAME ) && <S2SV_EndBug> <S2SV_StartBug> mbmi -> ref_frame [ 0 ] = ref_frame ; <S2SV_EndBug> <S2SV_StartBug> comp_pred = second_ref_frame > INTRA_FRAME ; <S2SV_EndBug> <S2SV_StartBug> set_ref_ptrs ( cm , xd , ref_frame , second_ref_frame ) ; <S2SV_EndBug> <S2SV_StartBug> if ( comp_pred ) { <S2SV_EndBug> <S2SV_StartBug> if ( vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) && <S2SV_EndBug> <S2SV_StartBug> mbmi -> tx_size = TX_4X4 ; <S2SV_EndBug> <S2SV_StartBug> if ( rate_uv_intra [ TX_4X4 ] == INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> choose_intra_uv_mode ( cpi , ctx , bsize , TX_4X4 , <S2SV_EndBug> <S2SV_StartBug> & rate_uv_intra [ TX_4X4 ] , <S2SV_EndBug> <S2SV_StartBug> & rate_uv_tokenonly [ TX_4X4 ] , <S2SV_EndBug> <S2SV_StartBug> & dist_uv [ TX_4X4 ] , & skip_uv [ TX_4X4 ] , <S2SV_EndBug> <S2SV_StartBug> & mode_uv [ TX_4X4 ] ) ; <S2SV_EndBug> <S2SV_StartBug> rate2 += rate_uv_intra [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> rate_uv = rate_uv_tokenonly [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> distortion2 += dist_uv [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> distortion_uv = dist_uv [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> mbmi -> uv_mode = mode_uv [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> & mbmi -> ref_mvs [ second_ref_frame ] [ 0 ] : NULL ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ THR_LAST ] : <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ THR_ALTR ] ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ THR_GOLD ] : this_rd_thresh ; <S2SV_EndBug> <S2SV_StartBug> xd -> mi [ 0 ] -> mbmi . tx_size = TX_4X4 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_filter_cache [ i ] = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> cpi -> sf . disable_filter_search_var_thresh ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> sf . adaptive_pred_interp_filter == 1 && <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> sf . adaptive_pred_interp_filter == 2 ) { <S2SV_EndBug> <S2SV_StartBug> mbmi -> interp_filter = switchable_filter_index ; <S2SV_EndBug> <S2SV_StartBug> tmp_rd = rd_pick_best_mbsegmentation ( cpi , x , tile , <S2SV_EndBug> <S2SV_StartBug> rs = vp9_get_switchable_rate ( x ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_filter_cache [ switchable_filter_index ] = tmp_rd ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] = <S2SV_EndBug> <S2SV_StartBug> MIN ( cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] , <S2SV_EndBug> <S2SV_StartBug> cpi -> mask_filter_rd = MAX ( cpi -> mask_filter_rd , tmp_rd ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> sf . use_rd_breakout && <S2SV_EndBug> <S2SV_StartBug> tmp_rd = rd_pick_best_mbsegmentation ( cpi , x , tile , <S2SV_EndBug> <S2SV_StartBug> rate2 += vp9_get_switchable_rate ( x ) ; <S2SV_EndBug> <S2SV_StartBug> super_block_uvrd ( cpi , x , & rate_uv , & distortion_uv , & uv_skippable , <S2SV_EndBug> <S2SV_StartBug> & uv_sse , BLOCK_8X8 , tmp_best_rdu ) ; <S2SV_EndBug> <S2SV_StartBug> tx_cache [ ONLY_4X4 ] = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ; <S2SV_EndBug> <S2SV_StartBug> const int mb_skip_allowed = ! vp9_segfeature_active ( seg , segment_id , <S2SV_EndBug> <S2SV_StartBug> } else if ( mb_skip_allowed ) { <S2SV_EndBug> <S2SV_StartBug> this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ; <S2SV_EndBug> <S2SV_StartBug> best_mode_index = mode_index ; <S2SV_EndBug> <S2SV_StartBug> * returnrate = rate2 ; <S2SV_EndBug> <S2SV_StartBug> * returndistortion = distortion2 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> select_txfm_size ) <S2SV_EndBug> <S2SV_StartBug> swap_block_ptr ( x , ctx , max_plane ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( ctx -> zcoeff_blk , x -> zcoeff_blk [ mbmi -> tx_size ] , <S2SV_EndBug> <S2SV_StartBug> sizeof ( uint8_t ) * ctx -> num_4x4_blk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( cpi -> sf . mode_search_skip_flags & FLAG_EARLY_TERMINATE ) && <S2SV_EndBug> <S2SV_StartBug> ( mode_index > MIN_EARLY_TERM_INDEX ) ) { <S2SV_EndBug> <S2SV_StartBug> const int qstep = xd -> plane [ 0 ] . dequant [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> int scale = 4 ; <S2SV_EndBug> <S2SV_StartBug> if ( second_ref_frame <= INTRA_FRAME && <S2SV_EndBug> <S2SV_StartBug> single_rd < best_pred_rd [ SINGLE_REFERENCE ] ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( second_ref_frame > INTRA_FRAME && <S2SV_EndBug> <S2SV_StartBug> single_rd < best_pred_rd [ COMPOUND_REFERENCE ] ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> int64_t ref = cpi -> rd_filter_cache [ cm -> interp_filter == SWITCHABLE ? <S2SV_EndBug> <S2SV_StartBug> else if ( cpi -> rd_filter_cache [ i ] == INT64_MAX ) <S2SV_EndBug> <S2SV_StartBug> adj_rd = cpi -> mask_filter_rd - ref + 10 ; <S2SV_EndBug> <S2SV_StartBug> adj_rd = cpi -> rd_filter_cache [ i ] - ref ; <S2SV_EndBug> <S2SV_StartBug> best_filter_rd [ i ] = MIN ( best_filter_rd [ i ] , adj_rd ) ; <S2SV_EndBug> <S2SV_StartBug> if ( best_rd >= best_rd_so_far ) <S2SV_EndBug> <S2SV_StartBug> if ( vp9_ref_order [ best_mode_index ] . ref_frame [ 0 ] == INTRA_FRAME ) { <S2SV_EndBug> <S2SV_StartBug> TX_SIZE uv_tx_size ; <S2SV_EndBug> <S2SV_StartBug> uv_tx_size = get_uv_tx_size ( mbmi ) ; <S2SV_EndBug> <S2SV_StartBug> rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv_intra [ uv_tx_size ] , <S2SV_EndBug> <S2SV_StartBug> & rate_uv_tokenonly [ uv_tx_size ] , <S2SV_EndBug> <S2SV_StartBug> & dist_uv [ uv_tx_size ] , <S2SV_EndBug> <S2SV_StartBug> & skip_uv [ uv_tx_size ] , <S2SV_EndBug> <S2SV_StartBug> BLOCK_8X8 , uv_tx_size ) ; <S2SV_EndBug> <S2SV_StartBug> if ( best_rd == INT64_MAX && bsize < BLOCK_8X8 ) { <S2SV_EndBug> <S2SV_StartBug> * returndistortion = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> return best_rd ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . adaptive_rd_thresh ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & xd -> mi [ 0 ] -> bmi [ i ] , & best_bmodes [ i ] , sizeof ( b_mode_info ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> skip ) { <S2SV_EndBug> <S2SV_StartBug> store_coding_context ( x , ctx , best_mode_index , <S2SV_EndBug> <S2SV_StartBug> best_pred_diff , best_tx_diff , best_filter_diff ) ; <S2SV_EndBug> ","<S2SV_ModStart> void <S2SV_ModEnd> <S2SV_ModStart> TileDataEnc * tile_data , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> RD_COST * rd_cost <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> ; RD_OPT * const rd_opt = & cpi -> rd ; SPEED_FEATURES * const sf = & cpi -> sf <S2SV_ModStart> const <S2SV_ModStart> const <S2SV_ModStart> const <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; int ref_index , best_ref_index <S2SV_ModEnd> <S2SV_ModStart> vpx_prob comp_mode_p <S2SV_ModEnd> <S2SV_ModStart> , rate_uv_tokenonly <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; PREDICTION_MODE mode_uv = DC_PRED ; const <S2SV_ModEnd> <S2SV_ModStart> vp9_get_intra_cost_penalty ( <S2SV_ModEnd> <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> ref_frame_skip_mask [ 2 ] = { 0 } ; int64_t mask_filter = 0 ; int64_t filter_cache [ SWITCHABLE_FILTER_CONTEXTS ] ; int internal_active_edge = vp9_active_edge_sb ( cpi , mi_row , mi_col ) && vp9_internal_image_edge ( cpi ) <S2SV_ModEnd> <S2SV_ModStart> sf -> <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> ; vp9_zero ( best_mbmode ) ; for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) filter_cache [ i ] = INT64_MAX <S2SV_ModStart> cm , xd <S2SV_ModEnd> <S2SV_ModStart> SWITCHABLE_FILTER_CONTEXTS <S2SV_ModEnd> <S2SV_ModStart> best_filter_rd <S2SV_ModEnd> <S2SV_ModStart> rate_uv_intra <S2SV_ModEnd> <S2SV_ModStart> rd_cost -> rate <S2SV_ModEnd> <S2SV_ModStart> setup_buffer_inter <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> else { ref_frame_skip_mask [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK ; } frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ; frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ; <S2SV_ModEnd> <S2SV_ModStart> ref_index = 0 ; ref_index <S2SV_ModEnd> <S2SV_ModStart> ref_index <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ref_index <S2SV_ModEnd> <S2SV_ModStart> ref_index <S2SV_ModEnd> <S2SV_ModStart> ref_index <S2SV_ModEnd> <S2SV_ModStart> sf -> <S2SV_ModEnd> <S2SV_ModStart> ref_index <S2SV_ModEnd> <S2SV_ModStart> best_mbmode <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ref_frame_skip_mask [ 0 ] |= ( 1 << GOLDEN_FRAME ) | ( 1 << ALTREF_FRAME ) ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK <S2SV_ModEnd> <S2SV_ModStart> ref_frame_skip_mask [ 0 ] |= ( 1 << LAST_FRAME ) | ( 1 << ALTREF_FRAME ) ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK <S2SV_ModEnd> <S2SV_ModStart> ref_frame_skip_mask [ 0 ] |= ( 1 << GOLDEN_FRAME ) | ( 1 << LAST_FRAME ) <S2SV_ModEnd> <S2SV_ModStart> break ; } } } if ( ( ref_frame_skip_mask [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> ref_frame ) ) && ( ref_frame_skip_mask [ 1 ] & ( 1 << MAX ( 0 , second_ref_frame ) ) <S2SV_ModEnd> <S2SV_ModStart> if ( ! internal_active_edge && rd_less_than_thresh ( best_rd , rd_opt -> threshes <S2SV_ModEnd> <S2SV_ModStart> ref_index ] , tile_data -> thresh_freq_fact <S2SV_ModEnd> <S2SV_ModStart> ref_index ] ) <S2SV_ModEnd> <S2SV_ModStart> comp_pred = <S2SV_ModEnd> <S2SV_ModStart> ; if ( comp_pred ) { if ( ! cpi -> allow_comp_inter_inter ) continue ; if ( ! ( cpi -> ref_frame_flags & flag_list [ second_ref_frame ] ) ) continue ; if ( segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) continue ; if ( ( sf -> mode_search_skip_flags & FLAG_SKIP_COMP_BESTINTRA ) && best_mbmode . <S2SV_ModEnd> <S2SV_ModStart> == INTRA_FRAME ) continue ; } if ( ref_frame > INTRA_FRAME && vp9_is_scaled ( & cm -> frame_refs [ ref_frame - 1 ] . sf ) ) continue ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( comp_pred ) mode_excluded = cm -> reference_mode == SINGLE_REFERENCE ; else if ( ref_frame != INTRA_FRAME ) mode_excluded = cm -> reference_mode == COMPOUND_REFERENCE ; if ( segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) && get_segdata ( seg , segment_id , SEG_LVL_REF_FRAME ) != ( int ) ref_frame ) { continue ; } else if ( ! segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) { if ( cpi -> rc . is_src_frame_alt_ref && ( cpi -> oxcf . arnr_max_frames == 0 ) ) continue ; } mbmi -> tx_size = TX_4X4 ; mbmi -> uv_mode = DC_PRED ; mbmi -> ref_frame [ 0 ] = ref_frame ; mbmi -> ref_frame [ 1 ] = second_ref_frame <S2SV_ModEnd> <S2SV_ModStart> x -> skip = 0 ; set_ref_ptrs ( cm , xd , ref_frame , second_ref_frame ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> x , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> x -> mbmi_ext <S2SV_ModEnd> <S2SV_ModStart> rd_opt -> threshes <S2SV_ModEnd> <S2SV_ModStart> rd_opt -> threshes <S2SV_ModEnd> <S2SV_ModStart> rd_opt -> threshes <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart> sf -> <S2SV_ModEnd> <S2SV_ModStart> sf -> <S2SV_ModEnd> <S2SV_ModStart> sf -> <S2SV_ModEnd> <S2SV_ModStart> MB_MODE_INFO_EXT * mbmi_ext = x -> mbmi_ext ; <S2SV_ModStart> rd_pick_best_sub8x8_mode <S2SV_ModEnd> <S2SV_ModStart> & mbmi_ext <S2SV_ModEnd> <S2SV_ModStart> cpi , xd <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart> mask_filter <S2SV_ModEnd> <S2SV_ModStart> mask_filter <S2SV_ModEnd> <S2SV_ModStart> sf -> <S2SV_ModEnd> <S2SV_ModStart> rd_pick_best_sub8x8_mode <S2SV_ModEnd> <S2SV_ModStart> & x -> mbmi_ext <S2SV_ModEnd> <S2SV_ModStart> cpi , xd <S2SV_ModEnd> <S2SV_ModStart> memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) ; if ( ! <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> best_ref_index = ref_index <S2SV_ModEnd> <S2SV_ModStart> rd_cost -> rate <S2SV_ModEnd> <S2SV_ModStart> rd_cost -> dist = distortion2 ; rd_cost -> rdcost = this_rd <S2SV_ModEnd> <S2SV_ModStart> select_tx_size <S2SV_ModEnd> <S2SV_ModStart> 1 , 0 , 0 , <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> TX_4X4 <S2SV_ModEnd> <S2SV_ModStart> ctx -> zcoeff_blk [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> sf -> <S2SV_ModEnd> <S2SV_ModStart> ref_index <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { qstep >>= ( xd -> bd - 8 ) ; } # endif <S2SV_ModStart> ! comp_pred <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> comp_pred <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart> mask_filter <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { rd_cost -> rate = INT_MAX ; rd_cost -> rdcost = INT64_MAX ; return ; } if ( sf -> <S2SV_ModEnd> <S2SV_ModStart> best_mbmode <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> TX_4X4 <S2SV_ModEnd> <S2SV_ModStart> ) { rd_cost -> rate <S2SV_ModEnd> <S2SV_ModStart> rd_cost -> dist <S2SV_ModEnd> <S2SV_ModStart> rd_cost -> rdcost = INT64_MAX ; return <S2SV_ModEnd> <S2SV_ModStart> vp9_update_rd_thresh_fact ( tile_data -> thresh_freq_fact , sf -> adaptive_rd_thresh , bsize , best_ref_index ) ; <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> best_ref_index <S2SV_ModEnd> <S2SV_ModStart> best_filter_diff , 0 ) <S2SV_ModEnd> "
254,<S2SV_StartBug> the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> the_url <S2SV_ModEnd> 
255,<S2SV_StartBug> if ( vma ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
256,<S2SV_StartBug> convert_to_double_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> x = Z_DVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_double_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> y = Z_DVAL_PP ( tmp ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> <S2SV_ModStart> Z_DVAL ( dval ) ; } else { x = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> <S2SV_ModStart> Z_DVAL ( dval ) ; } else { y = <S2SV_ModStart> } 
257,<S2SV_StartBug> L -> oldpc = pc + 1 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
258,"<S2SV_StartBug> int64_t off = s -> off ; <S2SV_EndBug> <S2SV_StartBug> ""Range:<S2SV_blank>bytes=%"" PRId64 ""-"" , s -> off ) ; <S2SV_EndBug> <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> ",<S2SV_ModStart> uint64_t <S2SV_ModEnd> <S2SV_ModStart> PRIu64 <S2SV_ModEnd> <S2SV_ModStart> UINT64_MAX <S2SV_ModEnd> 
259,"<S2SV_StartBug> uint_fast32_t rawsize ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( image = jas_image_create0 ( ) ) ) { <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> image -> inmem_ = true ; <S2SV_EndBug> <S2SV_StartBug> jas_image_destroy ( image ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> for ( cmptno = 0 , cmptparm = cmptparms ; cmptno < numcmpts ; ++ cmptno , <S2SV_EndBug> <S2SV_StartBug> ++ cmptparm ) { <S2SV_EndBug> <S2SV_StartBug> jas_image_destroy ( image ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> ++ image -> numcmpts_ ; <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> image = 0 ; JAS_DBGLOG ( 100 , ( ""jas_image_create(%d,<S2SV_blank>%p,<S2SV_blank>%d)\\n"" , numcmpts , cmptparms , clrspc ) ) ; <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> # if 0 <S2SV_ModStart> # endif <S2SV_ModStart> if ( ! jas_safe_size_mul3 ( cmptparm -> width , cmptparm -> height , ( cmptparm -> prec + 7 ) , & rawsize ) ) { goto error ; } rawsize /= 8 ; inmem = ( rawsize < JAS_IMAGE_INMEMTHRESH ) ; <S2SV_ModStart> goto error ; } ++ image -> numcmpts_ ; } jas_image_setbbox ( image ) ; return image ; error : if ( image ) { <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> "
260,<S2SV_StartBug> unsigned int i ; <S2SV_EndBug> ,<S2SV_ModStart> ; cmap -> ents = 0 
261,<S2SV_StartBug> if ( client -> priv -> protocol_timeout > 0 ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
262,<S2SV_StartBug> VP9_COMMON * const cm = & ctx -> pbi -> common ; <S2SV_EndBug> <S2SV_StartBug> cm -> new_fb_idx = - 1 ; <S2SV_EndBug> <S2SV_StartBug> cm -> get_fb_cb = ctx -> get_ext_fb_cb ; <S2SV_EndBug> <S2SV_StartBug> cm -> release_fb_cb = ctx -> release_ext_fb_cb ; <S2SV_EndBug> <S2SV_StartBug> cm -> cb_priv = ctx -> ext_priv ; <S2SV_EndBug> <S2SV_StartBug> cm -> get_fb_cb = vp9_get_frame_buffer ; <S2SV_EndBug> <S2SV_StartBug> cm -> release_fb_cb = vp9_release_frame_buffer ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_alloc_internal_frame_buffers ( & cm -> int_frame_buffers ) ) <S2SV_EndBug> <S2SV_StartBug> cm -> cb_priv = & cm -> int_frame_buffers ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> int i ; for ( i = 0 ; i < ctx -> num_frame_workers ; ++ i ) { VPxWorker * const worker = & ctx -> frame_workers [ i ] ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; <S2SV_ModStart> frame_worker_data <S2SV_ModEnd> <S2SV_ModStart> BufferPool * const pool = cm -> buffer_pool ; <S2SV_ModStart> INVALID_IDX ; cm -> byte_alignment = ctx -> byte_alignment ; cm -> skip_loop_filter = ctx -> skip_loop_filter <S2SV_ModEnd> <S2SV_ModStart> pool <S2SV_ModEnd> <S2SV_ModStart> pool <S2SV_ModEnd> <S2SV_ModStart> pool <S2SV_ModEnd> <S2SV_ModStart> pool <S2SV_ModEnd> <S2SV_ModStart> pool <S2SV_ModEnd> <S2SV_ModStart> pool <S2SV_ModEnd> <S2SV_ModStart> pool <S2SV_ModEnd> <S2SV_ModStart> pool <S2SV_ModEnd> <S2SV_ModStart> } 
263,"<S2SV_StartBug> static int udf_translate_to_linux ( uint8_t * newName , uint8_t * udfName , <S2SV_EndBug> <S2SV_StartBug> int udfLen , uint8_t * fidName , <S2SV_EndBug> <S2SV_StartBug> if ( newIndex < 256 ) <S2SV_EndBug> <S2SV_StartBug> maxFilenameLen = 250 - localExtIndex ; <S2SV_EndBug> <S2SV_StartBug> } else if ( newIndex > 250 ) <S2SV_EndBug> ","<S2SV_ModStart> int newLen , <S2SV_ModStart> int udfLen , <S2SV_ModEnd> <S2SV_ModStart> newLen <S2SV_ModEnd> <S2SV_ModStart> newLen - CRC_LEN <S2SV_ModEnd> <S2SV_ModStart> newLen - CRC_LEN ) newIndex = newLen - CRC_LEN <S2SV_ModEnd> "
264,<S2SV_StartBug> hw_init ( LOW_FREQUENCY ) ; <S2SV_EndBug> <S2SV_StartBug> # if BOOT_TO_DFU <S2SV_EndBug> ,<S2SV_ModStart> # if BOOT_TO_DFU flash_option_bytes_init ( 1 ) ; # else flash_option_bytes_init ( 0 ) ; # endif <S2SV_ModStart>  <S2SV_ModEnd> 
265,"<S2SV_StartBug> status = ocfs2_rw_lock ( inode , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> goto bail_unlock ; <S2SV_EndBug> ",<S2SV_ModStart> inode_dio_wait ( inode ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
266,"<S2SV_StartBug> static void sas_destruct_devices ( struct work_struct * work ) <S2SV_EndBug> <S2SV_StartBug> struct domain_device * dev , * n ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> asd_sas_port * port <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
267,"<S2SV_StartBug> while ( ! EOFBlob ( image ) ) <S2SV_EndBug> <S2SV_StartBug> if ( filepos != ( unsigned int ) filepos ) <S2SV_EndBug> <S2SV_StartBug> if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) > GetBlobSize ( image ) ) <S2SV_EndBug> <S2SV_StartBug> ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> filepos < GetBlobSize ( image ) && <S2SV_ModStart> > GetBlobSize ( image ) || filepos < 0 <S2SV_ModEnd> <S2SV_ModStart> >= <S2SV_ModEnd> <S2SV_ModStart> ) ; ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" "
268,"<S2SV_StartBug> char * fmtname ; <S2SV_EndBug> <S2SV_StartBug> while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> case OPT_INFILE : <S2SV_EndBug> <S2SV_StartBug> if ( infile ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ; int debug <S2SV_ModStart> debug = 0 ; <S2SV_ModStart> OPT_DEBUG : debug = atoi ( jas_optarg ) ; break ; case <S2SV_ModStart> jas_setdbglevel ( debug ) ; <S2SV_ModStart> jas_stream_close ( instream ) ; 
269,<S2SV_StartBug> ps_codec -> pu1_inp_bitsbuf += ( nal_ofst + nal_len ) ; <S2SV_EndBug> ,"<S2SV_ModStart> s_parse . i4_cur_slice_idx = MAX ( 0 , ( ps_codec -> s_parse . i4_cur_slice_idx - 1 ) ) ; ps_codec -> "
270,<S2SV_StartBug> nfca_poll -> rats_res_len = * data ++ ; <S2SV_EndBug> <S2SV_StartBug> nfcb_poll -> attrib_res_len = * data ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> min_t ( __u8 , <S2SV_ModStart> , 20 ) <S2SV_ModStart> min_t ( __u8 , <S2SV_ModStart> , 50 ) "
271,<S2SV_StartBug> p = find_eoq ( cmd + 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart> cmd [ 0 ] ? <S2SV_ModStart> : NULL 
272,<S2SV_StartBug> struct hns_roce_ib_alloc_ucontext_resp resp ; <S2SV_EndBug> ,<S2SV_ModStart> = { } 
273,"<S2SV_StartBug> int retval = 0 ; <S2SV_EndBug> <S2SV_StartBug> retval = - ENODEV ; <S2SV_EndBug> <S2SV_StartBug> bytes_read = snprintf ( in_buffer , 20 , ""%lld\\n"" , dev -> bbu ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * ppos < bytes_read ) { <S2SV_EndBug> <S2SV_StartBug> return retval ; <S2SV_EndBug> ","<S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & dev -> io_mutex ) ; return - ENODEV <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> simple_read_from_buffer ( buffer , count , ppos , in_buffer , len ) <S2SV_ModEnd> "
274,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , rpl_tstr <S2SV_ModEnd> "
275,"<S2SV_StartBug> int16_t vp9_dc_quant ( int qindex , int delta ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , vpx_bit_depth_t bit_depth ) { # if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) { case VPX_BITS_8 : <S2SV_ModEnd> <S2SV_ModStart> case VPX_BITS_10 : return dc_qlookup_10 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; case VPX_BITS_12 : return dc_qlookup_12 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12"" ) ; return - 1 ; } # else ( void ) bit_depth ; return dc_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ; # endif "
276,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> else { matvar -> name [ tmp - 1 ] = '\\0' ; } 
277,"<S2SV_StartBug> err = aead_register_instance ( tmpl , inst ) ; <S2SV_EndBug> ",<S2SV_ModStart> inst -> free = pcrypt_free ; 
278,<S2SV_StartBug> if ( shmflg & SHM_RND ) <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) && addr >= shmlba 
279,"<S2SV_StartBug> ( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) <S2SV_EndBug> <S2SV_StartBug> iris_info . name ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) count ; <S2SV_EndBug> <S2SV_StartBug> if ( EOFBlob ( image ) != MagickFalse ) <S2SV_EndBug> ","<S2SV_ModStart> count = <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" <S2SV_ModStart> if ( count != sizeof ( iris_info . filler ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
280,<S2SV_StartBug> STREAM out ; <S2SV_EndBug> ,"<S2SV_ModStart> struct stream packet = * in ; if ( ! s_check_rem ( in , 4 ) ) { rdp_protocol_error ( ""rdpsnd_process_training(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>training<S2SV_blank>data<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } "
281,"<S2SV_StartBug> dprintk ( ""%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\n"" , bd -> name , count ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL "
282,<S2SV_StartBug> const VP9_CONFIG * oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> int64_t critical_level = oxcf -> optimal_buffer_level >> 2 ; <S2SV_EndBug> <S2SV_StartBug> int active_worst_quality ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> current_video_frame > 1 ) <S2SV_EndBug> <S2SV_StartBug> rc -> avg_frame_qindex [ INTER_FRAME ] * 5 / 4 ) ; <S2SV_EndBug> <S2SV_StartBug> rc -> avg_frame_qindex [ KEY_FRAME ] * 3 / 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ( int ) ( ( rc -> worst_quality - rc -> avg_frame_qindex [ INTER_FRAME ] ) * <S2SV_EndBug> <S2SV_StartBug> ( oxcf -> optimal_buffer_level - rc -> buffer_level ) / <S2SV_EndBug> ,"<S2SV_ModStart> RATE_CONTROL * rc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rc <S2SV_ModEnd> <S2SV_ModStart> 3 <S2SV_ModEnd> <S2SV_ModStart> ; int ambient_qp ; unsigned int num_frames_weight_key = 5 * cpi -> svc . number_temporal_layers <S2SV_ModStart> ambient_qp = <S2SV_ModEnd> <S2SV_ModStart> < num_frames_weight_key ) ? MIN ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) : <S2SV_ModEnd> <S2SV_ModStart> ; active_worst_quality = MIN ( rc -> worst_quality , ambient_qp * 5 / 4 ) ; if ( <S2SV_ModEnd> <S2SV_ModStart> > rc -> optimal_buffer_level ) { int max_adjustment_down = active_worst_quality / 3 ; if ( max_adjustment_down ) { buff_lvl_step = ( ( rc -> maximum_buffer_size - rc -> optimal_buffer_level ) / max_adjustment_down ) ; if ( buff_lvl_step ) adjustment = ( int ) ( ( rc -> buffer_level - rc -> optimal_buffer_level ) / buff_lvl_step ) ; active_worst_quality -= adjustment ; } } else if ( rc -> buffer_level > critical_level ) { if ( critical_level ) { buff_lvl_step = ( rc -> optimal_buffer_level - critical_level ) ; if ( buff_lvl_step ) { adjustment = ( int ) ( ( rc -> worst_quality - ambient_qp ) * ( rc -> optimal_buffer_level - rc -> buffer_level ) / buff_lvl_step ) ; } active_worst_quality = ambient_qp <S2SV_ModEnd> "
283,<S2SV_StartBug> if ( ! ( buf = g_try_malloc ( size ) ) ) { <S2SV_EndBug> ,<S2SV_ModStart> g_try_malloc0 <S2SV_ModEnd> 
284,<S2SV_StartBug> alt = pcu -> ctrl_intf -> cur_altsetting ; <S2SV_EndBug> <S2SV_StartBug> alt = pcu -> data_intf -> cur_altsetting ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! pcu -> ctrl_intf ) return - EINVAL ; <S2SV_ModStart> if ( ! pcu -> data_intf ) return - EINVAL ; 
285,"<S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bp [ hlen ] & 0xf0 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""K"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mh -> ip6m_data8 [ 1 ] & 0x80 ) <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 16 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( mh -> ip6m_data8 [ 1 ] <S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> <S2SV_ModStart> bp [ hlen ] , <S2SV_ModEnd> "
286,"<S2SV_StartBug> Convert_art ( & dls , & defaultArt , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> dls . artCount = 1 ; <S2SV_EndBug> ",<S2SV_ModStart> if ( dls . pDLS ) { <S2SV_ModStart> } 
287,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>n<S2SV_blank>len=%d"" , ntohs ( e . len ) - 4 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( 2 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( 1 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ike_show_somedata ( ndo , ( const u_char * ) ( const uint8_t * ) ( ext + 1 ) , ep ) ) <S2SV_EndBug> <S2SV_StartBug> return ( const u_char * ) ext + ntohs ( e . len ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank>n<S2SV_blank>len=%u"" <S2SV_ModEnd> <S2SV_ModStart> ntohs ( e . len ) > 4 ) { if ( <S2SV_ModEnd> <S2SV_ModStart> > 2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> > 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } "
288,"<S2SV_StartBug> strcpy ( plugin_name , argv [ i ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( strlen ( argv [ i ] ) + 4 + 1 > FN_REFLEN ) { fprintf ( stderr , ""ERROR:<S2SV_blank>argument<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" ) ; return 1 ; } "
289,"<S2SV_StartBug> BN_ULONG t1 , t2 ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
290,"<S2SV_StartBug> void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi ) <S2SV_EndBug> <S2SV_StartBug> __wait_discard_cmd ( sbi , false ) ; <S2SV_EndBug> ","<S2SV_ModStart> , bool umount <S2SV_ModStart> ! umount <S2SV_ModEnd> "
291,<S2SV_StartBug> attrs = malloc ( sizeof ( TEE_Attribute ) * attr_count ) ; <S2SV_EndBug> ,"<S2SV_ModStart> size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , attr_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> alloc_size <S2SV_ModEnd> "
292,<S2SV_StartBug> if ( rdf_parser -> uri_filter ) <S2SV_EndBug> ,"<S2SV_ModStart> raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ; "
293,<S2SV_StartBug> if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || <S2SV_EndBug> <S2SV_StartBug> if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( mask & ~ ALL_PRINC_MASK ) ) <S2SV_EndBug> <S2SV_StartBug> return KADM5_BAD_MASK ; <S2SV_EndBug> ,<S2SV_ModStart> entry == NULL ) return EINVAL ; if ( <S2SV_ModStart> entry -> policy == NULL <S2SV_ModEnd> <S2SV_ModStart> KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( ( mask & <S2SV_ModStart>  <S2SV_ModEnd> 
294,"<S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> <S2SV_StartBug> pr_err ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> 
295,"<S2SV_StartBug> static void read_tx_mode_probs ( struct tx_probs * tx_probs , vp9_reader * r ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> 
296,"<S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> width - 1 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> height - 1 , 16 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> 
297,<S2SV_StartBug> if ( length == SIZE_MAX ) { <S2SV_EndBug> ,<S2SV_ModStart> || length > INT_MAX 
298,"<S2SV_StartBug> # define ThrowCUTReaderException ( severity , tag ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( severity , tag ) ; } <S2SV_EndBug> <S2SV_StartBug> offset = SeekBlob ( image , 6 , SEEK_SET ) ; <S2SV_EndBug> ","<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ; "
299,<S2SV_StartBug> jumpstack [ stackidx ++ ] = e ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; } 
300,<S2SV_StartBug> if ( ( exit_intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR && <S2SV_EndBug> ,<S2SV_ModStart> is_nmi ( exit_intr_info <S2SV_ModEnd> 
301,<S2SV_StartBug> tok -> err = json_tokener_success ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ( len < - 1 ) || ( len == - 1 && strlen ( str ) > INT32_MAX ) ) { tok -> err = json_tokener_error_size ; return NULL ; } 
302,<S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } <S2SV_ModEnd> <S2SV_ModStart> { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } <S2SV_ModEnd> "
303,<S2SV_StartBug> hwc -> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 ; <S2SV_EndBug> ,<S2SV_ModStart> + ( hwc -> idx - X86_PMC_IDX_FIXED ) 
304,<S2SV_StartBug> static off_t ivf_header_pos = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! stream -> ebml . debug ) <S2SV_EndBug> <S2SV_StartBug> off_t currpos = ftello ( stream -> file ) ; <S2SV_EndBug> <S2SV_StartBug> case VPX_CODEC_PSNR_PKT : <S2SV_EndBug> ,"<S2SV_ModStart> int64_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const int64_t <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_FP_MB_STATS case VPX_CODEC_FPMB_STATS_PKT : stats_write ( & stream -> fpmb_stats , pkt -> data . firstpass_mb_stats . buf , pkt -> data . firstpass_mb_stats . sz ) ; stream -> nbytes += pkt -> data . raw . sz ; break ; # endif "
305,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( clk_src ) ; 
306,"<S2SV_StartBug> struct snd_ctl_elem_id id ; <S2SV_EndBug> <S2SV_StartBug> up_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> for ( idx = 0 ; idx < kcontrol -> count ; idx ++ , id . index ++ , id . numid ++ ) <S2SV_EndBug> ",<S2SV_ModStart> ; unsigned int count <S2SV_ModStart> count = kcontrol -> count ; <S2SV_ModStart>  <S2SV_ModEnd> 
307,<S2SV_StartBug> Proto * p = clLvalue ( s2v ( ci -> func ) ) -> p ; <S2SV_EndBug> <S2SV_StartBug> if ( isLua ( ci -> previous ) ) <S2SV_EndBug> <S2SV_StartBug> L -> oldpc = ci -> previous -> u . l . savedpc ; <S2SV_EndBug> ,"<S2SV_ModStart> ci_func ( ci <S2SV_ModEnd> <S2SV_ModStart> = ci <S2SV_ModStart> pcRel ( ci <S2SV_ModEnd> <S2SV_ModStart> , ci_func ( ci ) -> p ) "
308,"<S2SV_StartBug> if ( total_length < sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) ) { <S2SV_EndBug> <S2SV_StartBug> ""Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>a<S2SV_blank>length<S2SV_blank>of<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%"" PRIsize , <S2SV_EndBug> <S2SV_StartBug> sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> || ( total_length > BT_SHB_INSANE_MAX ) <S2SV_ModStart> ""Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>length<S2SV_blank>%"" PRIsize ""<S2SV_blank><<S2SV_blank>_%lu_<S2SV_blank><<S2SV_blank>%lu<S2SV_blank>(BT_SHB_INSANE_MAX)"" <S2SV_ModEnd> <S2SV_ModStart> , total_length , BT_SHB_INSANE_MAX <S2SV_ModEnd> "
309,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> ",<S2SV_ModStart> int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> rc = <S2SV_ModStart> rc <S2SV_ModEnd> 
310,"<S2SV_StartBug> CRM_LOG_ASSERT ( client_obj -> request_id ) ; <S2SV_EndBug> <S2SV_StartBug> rid , client_obj -> name , from_peer ? ""(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)"" : """" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( client_obj -> ipc ) { <S2SV_ModStart> } else { crm_trace ( ""Sending<S2SV_blank>response<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s"" , client_obj -> name , from_peer ? ""(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)"" : """" ) ; } "
311,"<S2SV_StartBug> checked_xmalloc ( size_t size ) <S2SV_EndBug> <S2SV_StartBug> alloc_limit_assert ( ""checked_xmalloc"" , size ) ; <S2SV_EndBug> <S2SV_StartBug> return xmalloc ( size ) ; <S2SV_EndBug> ","<S2SV_ModStart> num , size_t <S2SV_ModStart> size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> res <S2SV_ModEnd> <S2SV_ModStart> num , "
312,"<S2SV_StartBug> static vpx_codec_err_t ctrl_set_svc ( vpx_codec_alg_priv_t * ctx , int ctr_id , <S2SV_EndBug> <S2SV_StartBug> ( cfg -> rc_end_usage == VPX_CBR || <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
313,<S2SV_StartBug> if ( size_bmp > BMP_HEADER_SIZE ) { <S2SV_EndBug> ,<S2SV_ModStart> && size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE 
314,"<S2SV_StartBug> dev = btrfs_find_device ( fs_info -> fs_devices , devid , NULL , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> , true "
315,"<S2SV_StartBug> if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n"" , <S2SV_EndBug> <S2SV_StartBug> if ( box -> len == 1 ) { <S2SV_EndBug> ","<S2SV_ModStart> jp2_box_create0 ( ) ) ) { goto error ; } <S2SV_ModEnd> <S2SV_ModStart> ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>"" ""type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%"" PRIuFAST32 ""\\n"" <S2SV_ModEnd> <S2SV_ModStart> JAS_DBGLOG ( 10 , ( ""big<S2SV_blank>length\\n"" ) ) ; "
316,<S2SV_StartBug> state -> array_nl = strdup ( RSTRING_PTR ( array_nl ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> fstrndup <S2SV_ModEnd> <S2SV_ModStart> , len "
317,"<S2SV_StartBug> if ( ! test_bit ( HCI_UP , & hdev -> flags ) ) <S2SV_EndBug> <S2SV_StartBug> return - ENETDOWN ; <S2SV_EndBug> <S2SV_StartBug> hci_req_sync_unlock ( hdev ) ; <S2SV_EndBug> ",<S2SV_ModStart> hci_req_sync_lock ( hdev ) ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> else ret = - ENETDOWN ; 
318,<S2SV_StartBug> vpx_codec_err_t res = VPX_CODEC_OK ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> y_crop_width = img -> d_w ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> uv_height = yv12 -> y_height / 2 ; <S2SV_EndBug> ,<S2SV_ModStart> const int y_w = img -> d_w ; const int y_h = img -> d_h ; const int uv_w = ( img -> d_w + 1 ) / 2 ; const int uv_h = ( img -> d_h + 1 ) / 2 ; <S2SV_ModStart> y_w ; yv12 -> y_crop_height = y_h ; yv12 -> y_width = y_w ; yv12 -> y_height = y_h ; yv12 -> uv_crop_width = uv_w ; yv12 -> uv_crop_height = uv_h ; yv12 -> uv_width = uv_w ; yv12 -> uv_height = uv_h ; yv12 -> y_stride = img -> stride [ VPX_PLANE_Y ] ; yv12 -> uv_stride = img -> stride [ VPX_PLANE_U ] ; yv12 -> border = ( img -> stride [ VPX_PLANE_Y ] - <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
319,<S2SV_StartBug> void * buffer ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( params -> buffer . fragment_size == 0 || params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) return - EINVAL 
320,<S2SV_StartBug> if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; <S2SV_EndBug> ,<S2SV_ModStart> || num >= 256 
321,"
","
"
322,<S2SV_StartBug> state = vterm_state_new ( vt ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( state == NULL ) return NULL 
323,"<S2SV_StartBug> mpeg4_decode_profile_level ( s , gb ) ; <S2SV_EndBug> <S2SV_StartBug> ( s -> avctx -> level > 0 && s -> avctx -> level < 9 ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! s -> avctx -> bits_per_raw_sample ) { <S2SV_EndBug> ","<S2SV_ModStart> int profile , level ; <S2SV_ModStart> , & profile , & level ) ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> else if ( s -> studio_profile ) { avpriv_request_sample ( s -> avctx , ""Mixes<S2SV_blank>studio<S2SV_blank>and<S2SV_blank>non<S2SV_blank>studio<S2SV_blank>profile\\n"" ) ; return AVERROR_PATCHWELCOME ; } s -> avctx -> profile = profile ; s -> avctx -> level = level ; <S2SV_ModStart> av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ; "
324,"<S2SV_StartBug> const uint8_t * end , * ptr = avpkt -> data ; <S2SV_EndBug> <S2SV_StartBug> end = avpkt -> data + avpkt -> size ; <S2SV_EndBug> <S2SV_StartBug> while ( memcmp ( ptr , ""/*<S2SV_blank>XPM<S2SV_blank>*/"" , 9 ) && ptr < end - 9 ) <S2SV_EndBug> <S2SV_StartBug> size *= 94 ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ncolors ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> if ( ptr + cpp > end ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ptr += mod_strcspn ( ptr , ""\\"""" ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < avctx -> width ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> if ( ptr + cpp > end ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> av_fast_padded_malloc ( & x -> buf , & x -> buf_size , avpkt -> size ) ; if ( ! x -> buf ) return AVERROR ( ENOMEM ) ; memcpy ( x -> buf , avpkt -> data , avpkt -> size ) ; x -> buf [ avpkt -> size ] = 0 ; ptr = x -> buf ; end = x -> buf <S2SV_ModEnd> <S2SV_ModStart> end - ptr > 9 && <S2SV_ModStart> ) ptr ++ ; if ( end - ptr <= 9 <S2SV_ModEnd> <S2SV_ModStart> 95 <S2SV_ModEnd> <S2SV_ModStart> if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> end - ptr < cpp <S2SV_ModEnd> <S2SV_ModStart> if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> end - ptr < cpp <S2SV_ModEnd> "
325,"<S2SV_StartBug> static struct nfs4_state * nfs4_do_open ( struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred ) <S2SV_EndBug> <S2SV_StartBug> status = _nfs4_do_open ( dir , path , flags , sattr , cred , & res ) ; <S2SV_EndBug> ","<S2SV_ModStart> , fmode_t fmode <S2SV_ModStart> , fmode "
326,"<S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> <S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> <S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> <S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> <S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> <S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> <S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> <S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> ",<S2SV_ModStart> false <S2SV_ModStart> false <S2SV_ModStart> false <S2SV_ModStart> false <S2SV_ModStart> false <S2SV_ModStart> false <S2SV_ModStart> false <S2SV_ModStart> false 
327,<S2SV_StartBug> iris_info . dimension = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; if ( ( iris_info . dimension == 0 ) || ( iris_info . dimension > 3 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" "
328,<S2SV_StartBug> bprm -> interp = interp ; <S2SV_EndBug> <S2SV_StartBug> return search_binary_handler ( bprm ) ; <S2SV_EndBug> ,"<S2SV_ModStart> retval = bprm_change_interp ( interp , <S2SV_ModEnd> <S2SV_ModStart> file = open_exec ( interp ) ; if ( IS_ERR ( file ) ) return PTR_ERR ( file ) ; bprm -> file = file ; retval = prepare_binprm ( bprm ) ; if ( retval < 0 ) return retval ; "
329,<S2SV_StartBug> INIT_LIST_HEAD ( & f -> f_u . fu_list ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
330,<S2SV_StartBug> ps_dec -> u4_first_slice_in_pic = 2 ; <S2SV_EndBug> ,<S2SV_ModStart> ; ps_dec -> u1_first_pb_nal_in_pic = 1 
331,"<S2SV_StartBug> ( void ) strncpy ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ; <S2SV_EndBug> ",<S2SV_ModStart> - 1 
332,<S2SV_StartBug> if ( pkt == NULL ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
333,<S2SV_StartBug> kgctx . have_acceptor_subkey = 1 ; <S2SV_EndBug> ,<S2SV_ModStart> established = 1 ; kgctx . 
334,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
335,<S2SV_StartBug> port -> exists = true ; <S2SV_EndBug> <S2SV_StartBug> mb ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> spin_lock_irq ( & i8042_lock ) ; <S2SV_ModStart> spin_unlock_irq ( & i8042_lock <S2SV_ModEnd> 
336,<S2SV_StartBug> if ( ( new -> euid != old -> uid || <S2SV_EndBug> ,"<S2SV_ModStart> ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) bprm -> per_clear |= PER_CLEAR_ON_SETID ; if ( "
337,<S2SV_StartBug> if ( ! rc -> source_alt_ref_pending ) <S2SV_EndBug> <S2SV_StartBug> rc -> source_alt_ref_active = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } 
338,"<S2SV_StartBug> static void kiocb_batch_free ( struct kiocb_batch * batch ) <S2SV_EndBug> <S2SV_StartBug> struct kiocb * req , * n ; <S2SV_EndBug> <S2SV_StartBug> kmem_cache_free ( kiocb_cachep , req ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> struct kioctx * ctx , <S2SV_ModStart> ; if ( list_empty ( & batch -> head ) ) return ; spin_lock_irq ( & ctx -> ctx_lock ) <S2SV_ModStart> list_del ( & req -> ki_list ) ; <S2SV_ModStart> ctx -> reqs_active -- ; } spin_unlock_irq ( & ctx -> ctx_lock ) ; <S2SV_ModEnd> "
339,<S2SV_StartBug> sax -> sax25_family = AF_NETROM ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( sax , 0 , sizeof ( sax ) ) ; "
340,"<S2SV_StartBug> size = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; <S2SV_EndBug> ","<S2SV_ModStart> nr_pages = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; if ( nr_pages < 2 ) nr_pages = 2 ; size = nr_pages * BUF_PAGE_SIZE <S2SV_ModEnd> "
341,<S2SV_StartBug> uchar * dp ; <S2SV_EndBug> ,<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
342,<S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> ,<S2SV_ModStart> ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> 
343,<S2SV_StartBug> int event_id = event -> attr . config ; <S2SV_EndBug> ,<S2SV_ModStart> u64 <S2SV_ModEnd> 
344,<S2SV_StartBug> char * buf ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! s_check ( s ) ) { rdp_protocol_error ( ""rdpsnddbg_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state"" , s ) ; } "
345,<S2SV_StartBug> case RAPTOR_OPTION_RELATIVE_URIS : <S2SV_EndBug> ,<S2SV_ModStart> RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case 
346,"<S2SV_StartBug> static PixelChannels * * AcquirePixelThreadSet ( const Image * image ) <S2SV_EndBug> <S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <S2SV_EndBug> ","<S2SV_ModStart> images ) { const Image * next ; <S2SV_ModEnd> <S2SV_ModStart> columns , <S2SV_ModStart> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <S2SV_ModStart> columns , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
347,"<S2SV_StartBug> int vp9_decode_frame ( VP9Decoder * pbi , <S2SV_EndBug> <S2SV_StartBug> const size_t first_partition_size = read_uncompressed_header ( pbi , & rb ) ; <S2SV_EndBug> <S2SV_StartBug> * p_data_end = data + 1 ; <S2SV_EndBug> <S2SV_StartBug> pbi -> do_loopfilter_inline = <S2SV_EndBug> <S2SV_StartBug> ( cm -> log2_tile_rows | cm -> log2_tile_cols ) == 0 && cm -> lf . filter_level ; <S2SV_EndBug> <S2SV_StartBug> if ( pbi -> oxcf . max_threads > 1 && ! vp9_worker_reset ( & pbi -> lf_worker ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( pbi -> oxcf . max_threads > 1 && tile_rows == 1 && tile_cols > 1 && <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> new_fb -> corrupted |= xd -> corrupted ; <S2SV_EndBug> <S2SV_StartBug> ""A<S2SV_blank>stream<S2SV_blank>must<S2SV_blank>start<S2SV_blank>with<S2SV_blank>a<S2SV_blank>complete<S2SV_blank>key<S2SV_blank>frame"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> refresh_frame_context ) <S2SV_EndBug> <S2SV_StartBug> cm -> frame_contexts [ cm -> frame_context_idx ] = cm -> fc ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> void vp9_decode_frame ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end , const uint8_t * * p_data_end ) { VP9_COMMON * const cm = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; struct vpx_read_bit_buffer rb ; int context_updated = 0 ; uint8_t clear_data [ MAX_VP9_HEADER_SIZE ] <S2SV_ModEnd> <S2SV_ModStart> init_read_bit_buffer ( pbi , & rb , data , data_end , clear_data ) ) <S2SV_ModEnd> <S2SV_ModStart> ( cm -> profile <= PROFILE_2 ? 1 : 2 ) ; return ; } data += vpx_rb_bytes_read <S2SV_ModEnd> <S2SV_ModStart> cm -> use_prev_frame_mvs = ! cm -> error_resilient_mode && cm -> width == cm -> last_width && cm -> height == cm -> last_height && ! cm -> last_intra_only && cm -> last_show_frame && ( cm -> last_frame_type != KEY_FRAME ) ; vp9_setup_block_planes ( xd , cm -> subsampling_x , cm -> subsampling_y ) ; * cm -> fc = cm -> frame_contexts [ cm -> frame_context_idx ] ; if ( ! cm -> fc -> initialized ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Uninitialized<S2SV_blank>entropy<S2SV_blank>context."" ) ; vp9_zero ( cm -> counts ) ; xd -> corrupted = 0 ; new_fb -> corrupted = read_compressed_header ( pbi , data , first_partition_size ) ; if ( new_fb -> corrupted ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Decode<S2SV_blank>failed.<S2SV_blank>Frame<S2SV_blank>data<S2SV_blank>header<S2SV_blank>is<S2SV_blank>corrupted."" ) ; if ( <S2SV_ModEnd> <S2SV_ModStart> && ! cm -> skip_loop_filter ) { vp9_loop_filter_frame_init ( cm , cm -> lf . filter_level ) ; } if ( pbi -> frame_parallel_decode && cm -> frame_parallel_decoding_mode ) { VPxWorker * const worker = pbi -> frame_worker_owner ; FrameWorkerData * const frame_worker_data = worker -> data1 ; if ( cm -> refresh_frame_context ) { context_updated = 1 ; cm -> frame_contexts [ cm -> frame_context_idx ] = * cm -> fc ; } vp9_frameworker_lock_stats ( worker ) ; pbi -> cur_buf -> row = - 1 ; pbi -> cur_buf -> col = - 1 ; frame_worker_data -> frame_context_ready = 1 ; vp9_frameworker_signal_stats ( worker ) ; vp9_frameworker_unlock_stats ( worker ) ; } if ( pbi -> <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! xd -> corrupted ) { if ( ! cm -> skip_loop_filter ) { vp9_loop_filter_frame_mt ( new_fb , cm , pbi -> mb . plane , cm -> lf . filter_level , 0 , 0 , pbi -> tile_workers , pbi -> num_tile_workers , & pbi -> lf_row_sync ) ; } } else { vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Decode<S2SV_blank>failed.<S2SV_blank>Frame<S2SV_blank>data<S2SV_blank>is<S2SV_blank>corrupted."" ) ; } <S2SV_ModStart> if ( ! xd -> corrupted ) { if ( ! cm -> error_resilient_mode && ! cm -> frame_parallel_decoding_mode ) { vp9_adapt_coef_probs ( cm ) ; if ( ! frame_is_intra_only ( cm ) ) { vp9_adapt_mode_probs ( cm ) ; vp9_adapt_mv_probs ( cm , cm -> allow_high_precision_mv ) ; } } else { debug_check_frame_counts ( cm ) ; } } else { <S2SV_ModEnd> <S2SV_ModStart> ""Decode<S2SV_blank>failed.<S2SV_blank>Frame<S2SV_blank>data<S2SV_blank>is<S2SV_blank>corrupted."" <S2SV_ModEnd> <S2SV_ModStart> && ! context_updated <S2SV_ModStart> * <S2SV_ModStart>  <S2SV_ModEnd> "
348,<S2SV_StartBug> sock_put ( skpair ) ; <S2SV_EndBug> ,"<S2SV_ModStart> unix_dgram_peer_wake_disconnect ( sk , skpair ) ; "
349,"<S2SV_StartBug> ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
350,<S2SV_StartBug> if ( vma -> vm_flags & ( VM_DONTEXPAND | VM_PFNMAP ) ) { <S2SV_EndBug> ,<S2SV_ModStart> new_len > old_len ) { unsigned long pgoff ; if ( <S2SV_ModStart> goto Efault ; pgoff = ( addr - vma -> vm_start ) >> PAGE_SHIFT ; pgoff += vma -> vm_pgoff ; if ( pgoff + ( new_len >> PAGE_SHIFT ) < pgoff ) goto Einval <S2SV_ModEnd> 
351,"<S2SV_StartBug> if ( dashsize ) outpos += sprintf ( outpos , ""<S2SV_blank>[%12.3f]<S2SV_blank>%12.3f<S2SV_blank>d"" , dashsize , phase ) ; <S2SV_EndBug> <S2SV_StartBug> else outpos += sprintf ( outpos , ""<S2SV_blank>[]<S2SV_blank>0<S2SV_blank>d"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> { sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sendClean ( outputbuffer ) ; } else send ( <S2SV_ModEnd> 
352,"<S2SV_StartBug> l2tp_msgtype_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_proto_ver_print ( ndo , ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_framing_cap_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_bearer_cap_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> print_octets ( ndo , ( const u_char * ) ptr , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> print_16bits_val ( ndo , ptr ) ; <S2SV_EndBug> <S2SV_StartBug> print_octets ( ndo , ( const u_char * ) ptr , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> print_32bits_val ( ndo , ( const uint32_t * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_bearer_type_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_framing_type_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_proxy_auth_type_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_proxy_auth_id_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_call_errors_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_accm_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> ","<S2SV_ModStart> , len - 6 <S2SV_ModStart> , len - 6 <S2SV_ModStart> , len - 6 <S2SV_ModStart> , len - 6 <S2SV_ModStart> if ( len - 6 < 8 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; break ; } <S2SV_ModStart> if ( len - 6 < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; break ; } <S2SV_ModStart> if ( len - 6 < 16 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; break ; } <S2SV_ModStart> if ( len - 6 < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; break ; } <S2SV_ModStart> , len - 6 <S2SV_ModStart> , len - 6 <S2SV_ModStart> , len - 6 <S2SV_ModStart> , len - 6 <S2SV_ModStart> , len - 6 <S2SV_ModStart> , len - 6 "
353,<S2SV_StartBug> o4 = o * sizeof ( uint32_t ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( q + o >= e ) goto out ; 
354,"<S2SV_StartBug> if ( ! spec || ! value || ! hdr || ! obuf || obuf_len < 0 ) { <S2SV_EndBug> <S2SV_StartBug> case DW_FORM_data2 : <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; <S2SV_EndBug> ",<S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> # if 0 <S2SV_ModStart> # endif <S2SV_ModStart> if ( value -> encoding . block . data ) { <S2SV_ModStart> } <S2SV_ModStart> if ( value -> encoding . block . data ) { <S2SV_ModStart> } 
355,"<S2SV_StartBug> netdev -> dcbnl_ops -> getpermhwaddr ( netdev , perm_addr ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( perm_addr , 0 , sizeof ( perm_addr ) ) ; "
356,"<S2SV_StartBug> if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> memset ( box , 0 , sizeof ( jp2_box_t ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> jp2_box_create0 ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
357,"<S2SV_StartBug> char * name ; <S2SV_EndBug> <S2SV_StartBug> if ( EVP_CipherInit_ex ( ctx , cipher , NULL , dummy_key , NULL , - 1 ) != 1 ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> NULL <S2SV_ModEnd> 
358,"<S2SV_StartBug> av_bprint_get_buffer ( bp , 1 , & buf , & buf_size ) ; <S2SV_EndBug> <S2SV_StartBug> zstream . avail_out = buf_size ; <S2SV_EndBug> ","<S2SV_ModStart> 2 , & buf , & buf_size ) ; if ( buf_size < 2 <S2SV_ModEnd> <S2SV_ModStart> - 1 "
359,"<S2SV_StartBug> unsigned v = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> f -> chroma_planes = get_rac ( c , state ) ; <S2SV_EndBug> <S2SV_StartBug> f -> chroma_h_shift = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> f -> chroma_v_shift = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> f -> transparency = get_rac ( c , state ) ; <S2SV_EndBug> ","<S2SV_ModStart> int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( f -> plane_count ) { if ( chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency ) { av_log ( f -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>change<S2SV_blank>of<S2SV_blank>global<S2SV_blank>parameters\\n"" ) ; return AVERROR_INVALIDDATA ; } } f -> chroma_planes = chroma_planes ; f -> chroma_h_shift = chroma_h_shift ; f -> chroma_v_shift = chroma_v_shift ; f -> transparency = transparency "
360,<S2SV_StartBug> r = verify_vc_kbmode ( fd ) ; <S2SV_EndBug> ,<S2SV_ModStart> vt_verify_kbmode <S2SV_ModEnd> 
361,<S2SV_StartBug> nfcf_poll -> sensf_res_len = * data ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> min_t ( __u8 , <S2SV_ModStart> , NFC_SENSF_RES_MAXSIZE ) "
362,<S2SV_StartBug> queueItem -> srcPort = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> interface = interface ; queueItem -> 
363,<S2SV_StartBug> NAPI_GRO_CB ( skb ) -> udp_mark = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> encap_mark <S2SV_ModEnd> 
364,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> kvm_pit_load_count ( kvm , 0 , ps -> channels [ 0 ] . count , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> int i ; <S2SV_ModStart> for ( i = 0 ; i < 3 ; i ++ ) <S2SV_ModStart> i <S2SV_ModEnd> <S2SV_ModStart> i <S2SV_ModEnd> 
365,<S2SV_StartBug> if ( malloc_called != 20 || free_called != 20 ) <S2SV_EndBug> ,<S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> 
366,"<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> int numrows ; <S2SV_EndBug> <S2SV_StartBug> if ( fscanf ( in , ""%d<S2SV_blank>%d"" , & xoff , & yoff ) != 2 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( fscanf ( in , ""%d<S2SV_blank>%d"" , & numcols , & numrows ) != 2 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> jas_matind_t i ; jas_matind_t <S2SV_ModEnd> <S2SV_ModStart> jas_matind_t numrows ; jas_matind_t numcols ; jas_matind_t xoff ; jas_matind_t yoff ; long tmp_xoff ; long tmp_yoff ; long tmp_numrows ; long tmp_numcols <S2SV_ModEnd> <S2SV_ModStart> ""%ld<S2SV_blank>%ld"" , & tmp_xoff , & tmp_yoff <S2SV_ModEnd> <S2SV_ModStart> { return 0 ; } xoff = tmp_xoff ; yoff = tmp_yoff <S2SV_ModEnd> <S2SV_ModStart> ""%ld<S2SV_blank>%ld"" , & tmp_numcols , & tmp_numrows <S2SV_ModEnd> <S2SV_ModStart> { return 0 ; } numrows = tmp_numrows ; numcols = tmp_numcols <S2SV_ModEnd> <S2SV_ModStart> { return 0 ; } <S2SV_ModEnd> "
367,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> 
368,"<S2SV_StartBug> else if ( Ustrcmp ( argrest , ""Mr"" ) == 0 ) received_protocol = argv [ ++ i ] ; <S2SV_EndBug> <S2SV_StartBug> uschar * hn = Ustrchr ( argrest , ':' ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( received_protocol ) { fprintf ( stderr , ""received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\n"" ) ; exit ( EXIT_FAILURE ) ; } else <S2SV_ModStart> hn ; if ( received_protocol ) { fprintf ( stderr , ""received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\n"" ) ; exit ( EXIT_FAILURE ) ; } "
369,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> r -> iov . iov_len = MIN ( r -> sector_count * 512 , SCSI_DMA_BUF_SIZE ) ; <S2SV_EndBug> ","<S2SV_ModStart> SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; if ( ! r -> iov . iov_base ) { r -> buflen = SCSI_DMA_BUF_SIZE ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } <S2SV_ModStart> r -> buflen <S2SV_ModEnd> "
370,<S2SV_StartBug> return ret ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree ( bo ) ; return ret ; } <S2SV_ModEnd> 
371,"<S2SV_StartBug> static void encode_sb_rt ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int output_enabled , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> switch ( partition ) { <S2SV_EndBug> <S2SV_StartBug> if ( output_enabled && bsize >= BLOCK_8X8 ) <S2SV_EndBug> <S2SV_StartBug> encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> <S2SV_StartBug> if ( mi_col + hbs < cm -> mi_cols ) { <S2SV_EndBug> <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> <S2SV_StartBug> if ( mi_row + hbs < cm -> mi_rows ) { <S2SV_EndBug> <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> <S2SV_StartBug> encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> encode_sb_rt ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , <S2SV_EndBug> <S2SV_StartBug> encode_sb_rt ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , <S2SV_EndBug> <S2SV_StartBug> assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , <S2SV_ModStart> , PC_TREE * pc_tree <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> b_width_log2_lookup [ bsize ] <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( output_enabled && bsize != BLOCK_4X4 ) td -> counts -> partition [ ctx ] [ partition ] ++ ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> td , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none <S2SV_ModEnd> <S2SV_ModStart> encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> && bsize > BLOCK_8X8 ) { encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> && bsize > BLOCK_8X8 ) { encode_b_rt ( cpi , td , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> encode_sb_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> split [ 0 ] ) <S2SV_ModEnd> <S2SV_ModStart> td , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 1 ] ) <S2SV_ModEnd> <S2SV_ModStart> td , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> <S2SV_ModStart> td , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 3 ] <S2SV_ModEnd> <S2SV_ModStart> 0 && ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; break <S2SV_ModEnd> "
372,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( s == 0 ) return ( ( void * ) NULL ) ; 
373,<S2SV_StartBug> field [ nf ] = lp ; <S2SV_EndBug> <S2SV_StartBug> if ( nf > MAXDATEFIELDS ) <S2SV_EndBug> ,<S2SV_ModStart> ; if ( nf >= MAXDATEFIELDS ) return - 1 <S2SV_ModStart>  <S2SV_ModEnd> 
374,"<S2SV_StartBug> u_int16_t port ; <S2SV_EndBug> <S2SV_StartBug> unsigned int ret ; <S2SV_EndBug> <S2SV_StartBug> nf_ct_helper_log ( skb , exp -> master , ""all<S2SV_blank>ports<S2SV_blank>in<S2SV_blank>use"" ) ; <S2SV_EndBug> <S2SV_StartBug> ret = nf_nat_mangle_tcp_packet ( skb , exp -> master , ctinfo , <S2SV_EndBug> <S2SV_StartBug> nf_ct_helper_log ( skb , exp -> master , ""cannot<S2SV_blank>mangle<S2SV_blank>packet"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct nf_conn * ct = exp -> master ; union nf_inet_addr newaddr ; <S2SV_ModStart> ; newaddr = ct -> tuplehash [ IP_CT_DIR_REPLY ] . tuple . dst . u3 <S2SV_ModStart> ct <S2SV_ModEnd> <S2SV_ModStart> snprintf ( buffer , sizeof ( buffer ) , ""%u<S2SV_blank>%u"" , ntohl ( newaddr . ip ) , port ) ; pr_debug ( ""nf_nat_irc:<S2SV_blank>inserting<S2SV_blank>\'%s\'<S2SV_blank>==<S2SV_blank>%pI4,<S2SV_blank>port<S2SV_blank>%u\\n"" , buffer , & newaddr . ip , port ) ; <S2SV_ModStart> ct <S2SV_ModEnd> <S2SV_ModStart> ct <S2SV_ModEnd> "
375,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( * i == '\\\\' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , ""Backslash<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL."" ) ; return HTTP_BAD_REQUEST ; } "
376,<S2SV_StartBug> ipc_lock_object ( & shp -> shm_perm ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( shp -> shm_file == NULL ) { ipc_unlock_object ( & shp -> shm_perm ) ; err = - EIDRM ; goto out_unlock ; } 
377,<S2SV_StartBug> convert_to_double_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> x = Z_DVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_double_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> y = Z_DVAL_PP ( tmp ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> <S2SV_ModStart> Z_DVAL ( dval ) ; } else { x = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> <S2SV_ModStart> Z_DVAL ( dval ) ; } else { y = <S2SV_ModStart> } 
378,<S2SV_StartBug> if ( test_tsk_need_resched ( rq -> curr ) ) <S2SV_EndBug> ,<S2SV_ModStart> rq -> curr -> se . on_rq && 
379,"<S2SV_StartBug> rc = fsmVerify ( fpath , fi ) ; <S2SV_EndBug> ","<S2SV_ModStart> , & sb "
380,<S2SV_StartBug> if ( dc_size > 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( dc_count > ( 6LL * td -> xsize * td -> ysize + 63 ) / 64 ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> != dc_w * dc_h * 3 <S2SV_ModEnd> 
381,"<S2SV_StartBug> struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , void * data ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> 
382,<S2SV_StartBug> if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > <S2SV_EndBug> <S2SV_StartBug> pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
383,<S2SV_StartBug> if ( name_len == 0 ) goto chunk_end ; <S2SV_EndBug> <S2SV_StartBug> READ_ENCINT ( length ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue 
384,<S2SV_StartBug> path -> mnt = mntget ( nd -> path . mnt ) ; <S2SV_EndBug> <S2SV_StartBug> follow_mount ( path ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mntget ( path -> mnt ) ; 
385,"<S2SV_StartBug> while ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != u4_start_code_val ) <S2SV_EndBug> <S2SV_StartBug> && ( ps_dec -> s_bit_stream . u4_offset <= ps_dec -> s_bit_stream . u4_max_offset ) ) <S2SV_EndBug> ",<S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> < <S2SV_ModEnd> 
386,"<S2SV_StartBug> if ( msg -> maxsize - msg -> cursize < 4 ) { <S2SV_EndBug> <S2SV_StartBug> if ( bits == 8 ) { <S2SV_EndBug> <S2SV_StartBug> nbits = bits & 7 ; <S2SV_EndBug> <S2SV_StartBug> Huff_offsetTransmit ( & msgHuff . compressor , ( value & 0xff ) , msg -> data , & msg -> bit ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> overflowed ) { <S2SV_ModEnd> <S2SV_ModStart> msg -> cursize + ( bits >> 3 ) > msg -> maxsize ) { msg -> overflowed = qtrue ; return ; } if ( <S2SV_ModStart> if ( msg -> bit + nbits > msg -> maxsize << 3 ) { msg -> overflowed = qtrue ; return ; } <S2SV_ModStart> , msg -> maxsize << 3 <S2SV_ModStart> if ( msg -> bit > msg -> maxsize << 3 ) { msg -> overflowed = qtrue ; return ; } "
387,<S2SV_StartBug> if ( ! fs_searchpaths ) <S2SV_EndBug> <S2SV_StartBug> for ( search = fs_searchpaths ; search ; search = search -> next ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> qboolean isLocalConfig ; <S2SV_ModStart> isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> if ( isLocalConfig && search -> pack ) continue ; "
388,<S2SV_StartBug> kgctx . have_acceptor_subkey = 1 ; <S2SV_EndBug> ,<S2SV_ModStart> established = 1 ; kgctx . 
389,"<S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( rsvp_obj_ctype ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps"" , <S2SV_EndBug> ",<S2SV_ModStart> switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; 
390,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
391,<S2SV_StartBug> image -> storage_class = PseudoClass ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> case RMT_NONE : <S2SV_EndBug> <S2SV_StartBug> * sun_colormap ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
392,<S2SV_StartBug> ( cm -> frame_flags & FRAMEFLAGS_KEY ) || <S2SV_EndBug> <S2SV_StartBug> ( cpi -> oxcf . auto_key && test_for_kf_one_pass ( cpi ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> rc -> frames_to_key = cpi -> key_frame_frequency ; <S2SV_EndBug> <S2SV_StartBug> rc -> baseline_gf_interval = DEFAULT_GF_INTERVAL ; <S2SV_EndBug> <S2SV_StartBug> rc -> frames_till_gf_update_due = rc -> frames_to_key ; <S2SV_EndBug> ,<S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> oxcf . key_freq <S2SV_ModEnd> <S2SV_ModStart> ( rc -> min_gf_interval + rc -> max_gf_interval ) / 2 <S2SV_ModEnd> <S2SV_ModStart> { rc -> frames_till_gf_update_due = rc -> frames_to_key ; rc -> constrained_gf_group = 1 ; } else { rc -> constrained_gf_group = 0 ; } <S2SV_ModEnd> 
393,"<S2SV_StartBug> opendata = nfs4_opendata_alloc ( & ctx -> path , state -> owner , 0 , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> , 0 "
394,"<S2SV_StartBug> ERR ( ""callocing<S2SV_blank>this<S2SV_blank>failed"" ) ; <S2SV_EndBug> <S2SV_StartBug> this -> sd = socket ( AF_INET6 , SOCK_STREAM , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> ERR ( ""sockect<S2SV_blank>open<S2SV_blank>failed"" ) ; <S2SV_EndBug> <S2SV_StartBug> addr . sin6_family = AF_INET6 ; <S2SV_EndBug> <S2SV_StartBug> addr . sin6_addr = in6addr_any ; <S2SV_EndBug> <S2SV_StartBug> ERR ( ""Bind<S2SV_blank>on<S2SV_blank>port<S2SV_blank>failed.<S2SV_blank>"" <S2SV_EndBug> <S2SV_StartBug> ERR ( ""listen<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>socket"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""IPv4:<S2SV_blank>callocing<S2SV_blank>this<S2SV_blank>failed"" <S2SV_ModEnd> <S2SV_ModStart> AF_INET <S2SV_ModEnd> <S2SV_ModStart> ""IPv4<S2SV_blank>socket<S2SV_blank>open<S2SV_blank>failed"" ) ; goto error ; } struct sockaddr_in <S2SV_ModEnd> <S2SV_ModStart> sin_family = AF_INET ; addr . sin_port <S2SV_ModEnd> <S2SV_ModStart> sin_addr . s_addr = htonl ( 0x7F000001 ) <S2SV_ModEnd> <S2SV_ModStart> ""IPv4<S2SV_blank>bind<S2SV_blank>on<S2SV_blank>port<S2SV_blank>failed.<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ""IPv4<S2SV_blank>listen<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>socket"" <S2SV_ModEnd> "
395,"<S2SV_StartBug> col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""PKTAP"" ) ; <S2SV_EndBug> <S2SV_StartBug> dissector_try_uint ( wtap_encap_dissector_table , <S2SV_EndBug> <S2SV_StartBug> wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree ) ; <S2SV_EndBug> ","<S2SV_ModStart> int wtap_encap ; struct eth_phdr eth ; void * phdr ; <S2SV_ModStart> wtap_encap = wtap_pcap_encap_to_wtap_encap ( dlt ) ; switch ( wtap_encap ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdr = & eth ; break ; default : phdr = NULL ; break ; } dissector_try_uint_new <S2SV_ModEnd> <S2SV_ModStart> wtap_encap <S2SV_ModEnd> <S2SV_ModStart> , TRUE , phdr "
396,"<S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> cm -> last_frame_type = cm -> frame_type ; <S2SV_EndBug> <S2SV_StartBug> cpi , ( cpi -> sf . recode_loop >= ALLOW_RECODE_KFARFGF || <S2SV_EndBug> <S2SV_StartBug> rc -> last_q [ KEY_FRAME ] = cm -> base_qindex ; <S2SV_EndBug> <S2SV_StartBug> 3 * rc -> avg_frame_qindex [ KEY_FRAME ] + cm -> base_qindex , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( ! rc -> is_src_frame_alt_ref && <S2SV_EndBug> <S2SV_StartBug> ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) && <S2SV_EndBug> <S2SV_StartBug> ! ( cpi -> use_svc && oxcf -> end_usage == USAGE_STREAM_FROM_SERVER ) ) { <S2SV_EndBug> <S2SV_StartBug> rc -> last_q [ 2 ] = cm -> base_qindex ; <S2SV_EndBug> <S2SV_StartBug> rc -> avg_frame_qindex [ 2 ] = ROUND_POWER_OF_TWO ( <S2SV_EndBug> <S2SV_StartBug> 3 * rc -> avg_frame_qindex [ 2 ] + cm -> base_qindex , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> rc -> tot_q += vp9_convert_qindex_to_q ( cm -> base_qindex ) ; <S2SV_EndBug> <S2SV_StartBug> rc -> avg_q = rc -> tot_q / ( double ) rc -> ni_frames ; <S2SV_EndBug> <S2SV_StartBug> rc -> ni_tot_qi += cm -> base_qindex ; <S2SV_EndBug> <S2SV_StartBug> if ( ( cm -> base_qindex < rc -> last_boosted_qindex ) || <S2SV_EndBug> <S2SV_StartBug> ( ( cpi -> static_mb_pct < 100 ) && <S2SV_EndBug> <S2SV_StartBug> ( ( cm -> frame_type == KEY_FRAME ) || cpi -> refresh_alt_ref_frame || <S2SV_EndBug> <S2SV_StartBug> rc -> last_boosted_qindex = cm -> base_qindex ; <S2SV_EndBug> <S2SV_StartBug> rc -> total_target_bits += ( cm -> show_frame ? rc -> av_per_frame_bandwidth : 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( oxcf -> play_alternate && cpi -> refresh_alt_ref_frame && <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_type == KEY_FRAME ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> const <S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> const int qindex = cm -> base_qindex ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) { vp9_cyclic_refresh_postencode ( cpi ) ; } <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> qindex <S2SV_ModEnd> <S2SV_ModStart> qindex <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> use_svc ) { int i = 0 ; SVC * svc = & cpi -> svc ; for ( i = 0 ; i < svc -> number_temporal_layers ; ++ i ) { const int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , i , svc -> number_temporal_layers ) ; LAYER_CONTEXT * lc = & svc -> layer_context [ layer ] ; RATE_CONTROL * lrc = & lc -> rc ; lrc -> last_q [ KEY_FRAME ] = rc -> last_q [ KEY_FRAME ] ; lrc -> avg_frame_qindex [ KEY_FRAME ] = rc -> avg_frame_qindex [ KEY_FRAME ] ; } } } else { if ( rc -> is_src_frame_alt_ref || ! <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> rc_mode == VPX_CBR <S2SV_ModEnd> <S2SV_ModStart> INTER_FRAME ] = qindex <S2SV_ModEnd> <S2SV_ModStart> INTER_FRAME ] = <S2SV_ModEnd> <S2SV_ModStart> INTER_FRAME ] + qindex <S2SV_ModEnd> <S2SV_ModStart> qindex , cm -> bit_depth <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> qindex <S2SV_ModEnd> <S2SV_ModStart> } if ( ( qindex <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( ! rc -> constrained_gf_group && ( <S2SV_ModStart> qindex ; } if ( cm -> frame_type == KEY_FRAME ) rc -> last_kf_qindex = qindex ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth : 0 <S2SV_ModEnd> <S2SV_ModStart> ! cpi -> use_svc ) { if ( is_altref_enabled ( cpi ) <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> if ( oxcf -> pass != 0 ) { cpi -> resize_pending = rc -> next_frame_size_selector != rc -> frame_size_selector ; rc -> frame_size_selector = rc -> next_frame_size_selector ; } "
397,<S2SV_StartBug> int delegation_type = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> fmode_t <S2SV_ModEnd> 
398,"<S2SV_StartBug> rrd_set_error ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>imginfo"" ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
399,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> check_stack_depth ( ) ; 
400,"<S2SV_StartBug> pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" <S2SV_EndBug> ",<S2SV_ModStart> pr_debug <S2SV_ModEnd> 
401,"<S2SV_StartBug> struct pt_regs * regs , int nmi ) <S2SV_EndBug> <S2SV_StartBug> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
402,"<S2SV_StartBug> ctxt -> dst . type = OP_REG ; <S2SV_EndBug> <S2SV_StartBug> rc = emulate_pop ( ctxt , & ctxt -> dst . val , ctxt -> op_bytes ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned long eip <S2SV_ModEnd> <S2SV_ModStart> eip <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_near ( ctxt , eip "
403,"<S2SV_StartBug> r = parse_gid ( e + 1 , & gid ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( e - p > HOST_NAME_MAX - 1 ) goto not_found ; 
404,"<S2SV_StartBug> static void reconstruct_inter_block ( int plane , int block , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd = args -> xd ; <S2SV_EndBug> <S2SV_StartBug> int x , y , eob ; <S2SV_EndBug> <S2SV_StartBug> eob = vp9_decode_block_tokens ( cm , xd , plane , block , plane_bsize , x , y , <S2SV_EndBug> <S2SV_StartBug> inverse_transform_block ( xd , plane , block , tx_size , <S2SV_EndBug> <S2SV_StartBug> & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * x ] , <S2SV_EndBug> <S2SV_StartBug> * args -> eobtotal += eob ; <S2SV_EndBug> ","<S2SV_ModStart> int reconstruct_inter_block ( <S2SV_ModEnd> <S2SV_ModStart> , vpx_reader * r , MB_MODE_INFO * const mbmi , int plane , int row , int col , TX_SIZE tx_size ) { <S2SV_ModEnd> <S2SV_ModStart> const scan_order * sc = & vp9_default_scan_orders [ tx_size ] ; const int <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sc , col , row , tx_size , r , mbmi -> segment_id ) ; inverse_transform_block_inter ( xd , plane <S2SV_ModEnd> <S2SV_ModStart> row <S2SV_ModEnd> <S2SV_ModStart> col <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> "
405,"<S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> ",<S2SV_ModStart> _dh <S2SV_ModEnd> 
406,<S2SV_StartBug> length += len ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( length > ( size_t ) ( length + len ) ) ) goto _output_error ; 
407,"<S2SV_StartBug> mask |= FS_EVENT_ON_CHILD ; <S2SV_EndBug> <S2SV_StartBug> if ( path ) <S2SV_EndBug> <S2SV_StartBug> dentry -> d_name . name , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> dentry -> d_name . name , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct name_snapshot name ; <S2SV_ModStart> take_dentry_name_snapshot ( & name , dentry ) ; <S2SV_ModStart> name <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> <S2SV_ModStart> ) ; release_dentry_name_snapshot ( & name "
408,"<S2SV_StartBug> size_t ss = CDF_SEC_SIZE ( h ) , i , j ; <S2SV_EndBug> ",<S2SV_ModStart> CDF_SHORT_SEC_SIZE <S2SV_ModEnd> 
409,<S2SV_StartBug> tcon -> bad_network_name = true ; <S2SV_EndBug> ,<S2SV_ModStart> if ( tcon ) 
410,"<S2SV_StartBug> memcpy ( bss_cfg -> rates , rate_ie + 1 , rate_ie -> len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rate_ie ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( bss_cfg -> rates + rate_len , rate_ie + 1 , rate_ie -> len ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES ) return ; <S2SV_ModStart> { if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES - rate_len ) return ; <S2SV_ModStart> } 
411,"<S2SV_StartBug> agoo_log_cat ( & agoo_con_cat , ""Server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>accepted<S2SV_blank>connection<S2SV_blank>%llu<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>[%d]"" , <S2SV_EndBug> <S2SV_StartBug> getpid ( ) , ( unsigned long long ) cnt , b -> id , con -> sock ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""Server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>accepted<S2SV_blank>connection<S2SV_blank>%llu<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>[%d]<S2SV_blank>from<S2SV_blank>%s"" <S2SV_ModEnd> <S2SV_ModStart> , con -> remote "
412,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = strdup_if_nonnull ( & target -> cr_principal , source -> cr_principal ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = kstrdup ( <S2SV_ModEnd> <S2SV_ModStart> , GFP_KERNEL ) ; target -> cr_raw_principal = kstrdup ( source -> cr_raw_principal , GFP_KERNEL <S2SV_ModStart> ( source -> cr_principal && ! target -> cr_principal ) || ( source -> cr_raw_principal && ! target -> cr_raw_principal ) ) return - ENOMEM <S2SV_ModEnd> "
413,<S2SV_StartBug> assert ( offset >= capoff ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
414,"<S2SV_StartBug> r = mount ( ""cgroup_root"" , path , ""tmpfs"" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , ""size=10240k,mode=755"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> safe_mount <S2SV_ModEnd> <S2SV_ModStart> , root "
415,"<S2SV_StartBug> int err = 0 ; <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_zeroout ( inode , & orig_ex ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; BUG_ON ( ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) == ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) <S2SV_ModStart> if ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) { if ( split_flag & EXT4_EXT_DATA_VALID1 ) err = ext4_ext_zeroout ( inode , ex2 ) ; else err = ext4_ext_zeroout ( inode , ex ) ; } else "
416,"<S2SV_StartBug> unsigned int block_size , <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 , k = 0 ; i < block_size ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < block_size ; j ++ , k ++ ) { <S2SV_EndBug> <S2SV_StartBug> modifier += 1 << ( strength - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> byte += stride - block_size ; <S2SV_EndBug> ","<S2SV_ModStart> block_width , unsigned int block_height <S2SV_ModEnd> <S2SV_ModStart> const int rounding = strength > 0 ? 1 << ( strength - 1 ) : 0 ; <S2SV_ModStart> block_height <S2SV_ModEnd> <S2SV_ModStart> block_width <S2SV_ModEnd> <S2SV_ModStart> rounding <S2SV_ModEnd> <S2SV_ModStart> block_width <S2SV_ModEnd> "
417,<S2SV_StartBug> assert ( idx >= 1 ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n"" , __func__ , dev -> bar [ idx ] . type ) ; return <S2SV_ModEnd> "
418,"<S2SV_StartBug> return check_mac_perms_from_lookup ( spid , uid , perm , str8 ( name , name_len ) ) ? 1 : 0 ; <S2SV_EndBug> ",<S2SV_ModStart> if ( uid >= AID_APP ) { return 0 ; } 
419,<S2SV_StartBug> if ( Offset < ( SizeOfHeader + 8 ) ) goto Error ; <S2SV_EndBug> ,<S2SV_ModStart> ) goto Error ; if ( ( Offset + Len ) > SizeOfTag + 8 
420,<S2SV_StartBug> void ext4_xattr_destroy_cache ( struct mb_cache * cache ) <S2SV_EndBug> <S2SV_StartBug> mb_cache_destroy ( cache ) ; <S2SV_EndBug> ,<S2SV_ModStart> mb2_cache <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_destroy <S2SV_ModEnd> 
421,<S2SV_StartBug> mu_run_test ( test_r_str_unescape ) ; <S2SV_EndBug> ,<S2SV_ModStart> test_r_str_escape_sh ) ; mu_run_test ( 
422,<S2SV_StartBug> sbinfo -> max_blocks = config . nr_blocks ; <S2SV_EndBug> <S2SV_StartBug> sbinfo -> free_blocks = config . nr_blocks ; <S2SV_EndBug> <S2SV_StartBug> if ( ! inode ) <S2SV_EndBug> <S2SV_StartBug> root = d_alloc_root ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> kfree ( sbinfo ) ; <S2SV_EndBug> ,"<S2SV_ModStart> max_inodes = config . nr_inodes ; sbinfo -> free_inodes = config . nr_inodes ; sbinfo -> spool = NULL ; if ( <S2SV_ModEnd> <S2SV_ModStart> != - 1 ) { sbinfo -> spool = hugepage_new_subpool ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sbinfo -> spool <S2SV_ModEnd> <S2SV_ModStart> } sb -> s_maxbytes = MAX_LFS_FILESIZE ; sb -> s_blocksize = huge_page_size ( config . hstate ) ; sb -> s_blocksize_bits = huge_page_shift ( config . hstate ) ; sb -> s_magic = HUGETLBFS_MAGIC ; sb -> s_op = & hugetlbfs_ops ; sb -> s_time_gran = 1 ; inode = hugetlbfs_get_root ( sb , & config ) ; if ( ! inode ) goto out_free ; <S2SV_ModStart> if ( sbinfo -> spool ) kfree ( sbinfo -> spool ) ; "
423,<S2SV_StartBug> U2FHID_INIT_RESP initresp ; <S2SV_EndBug> <S2SV_StartBug> if ( resplen > sizeof ( initresp ) ) <S2SV_EndBug> <S2SV_StartBug> dev -> cid = initresp . cid ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionInterface = initresp . versionInterface ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionMajor = initresp . versionMajor ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionMinor = initresp . versionMinor ; <S2SV_EndBug> <S2SV_StartBug> dev -> capFlags = initresp . capFlags ; <S2SV_EndBug> ,"<S2SV_ModStart> int offs = sizeof ( nonce ) <S2SV_ModEnd> <S2SV_ModStart> < 17 ) { return U2FH_SIZE_ERROR ; } if ( memcmp ( nonce , resp , sizeof ( nonce ) ) != 0 ) { return U2FH_TRANSPORT_ERROR ; } <S2SV_ModEnd> <S2SV_ModStart> resp [ offs ] << 24 | resp [ offs + 1 ] << 16 | resp [ offs + 2 ] << 8 | resp [ offs + 3 ] ; offs += 4 <S2SV_ModEnd> <S2SV_ModStart> resp [ offs ++ ] <S2SV_ModEnd> <S2SV_ModStart> resp [ offs ++ ] <S2SV_ModEnd> <S2SV_ModStart> resp [ offs ++ ] ; dev -> versionBuild = resp [ offs ++ ] <S2SV_ModEnd> <S2SV_ModStart> resp [ offs ++ ] <S2SV_ModEnd> "
424,<S2SV_StartBug> return MS_FALSE ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( strchr ( timestring , '\\'' ) || strchr ( timestring , '\\\\' ) ) { msSetError ( MS_MISCERR , ""Invalid<S2SV_blank>time<S2SV_blank>filter."" , ""msPostGISLayerSetTimeFilter()"" ) ; return MS_FALSE ; } "
425,"<S2SV_StartBug> return recv ( socket -> fd , buf , count , MSG_DONTWAIT ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
426,"<S2SV_StartBug> ns_capable ( current -> nsproxy -> pid_ns -> user_ns , CAP_SYS_ADMIN ) ) && <S2SV_EndBug> ",<S2SV_ModStart> task_active_pid_ns ( current ) <S2SV_ModEnd> 
427,"<S2SV_StartBug> static vpx_codec_err_t vp8e_get_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
428,<S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY "
429,"<S2SV_StartBug> ND_TCHECK ( pptr [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> plen -= 32 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( pptr [ 1 ] , ( plen + 7 ) / 8 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & route_target , & pptr [ 1 ] , ( plen + 7 ) / 8 ) ; <S2SV_EndBug> <S2SV_StartBug> as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + 1 ) ) , <S2SV_EndBug> ","<S2SV_ModStart> char asbuf [ sizeof ( astostr ) ] ; <S2SV_ModStart> ND_TCHECK_32BITS ( pptr + 1 ) ; as_printf ( ndo , asbuf , sizeof ( asbuf ) , EXTRACT_32BITS ( pptr + 1 ) ) ; <S2SV_ModStart> 5 <S2SV_ModEnd> <S2SV_ModStart> 5 <S2SV_ModEnd> <S2SV_ModStart> asbuf <S2SV_ModEnd> "
430,<S2SV_StartBug> cork -> length += length ; <S2SV_EndBug> <S2SV_StartBug> if ( length > mtu ) { <S2SV_EndBug> <S2SV_StartBug> if ( dontfrag && ( proto == IPPROTO_UDP || proto == IPPROTO_RAW ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( proto == IPPROTO_UDP && <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> sk -> sk_protocol <S2SV_ModEnd> <S2SV_ModStart> sk -> sk_protocol <S2SV_ModEnd> <S2SV_ModStart> skb = skb_peek_tail ( & sk -> sk_write_queue ) ; cork -> length += length ; if ( ( ( length > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) <S2SV_ModEnd> <S2SV_ModStart> if ( ! skb <S2SV_ModEnd> 
431,<S2SV_StartBug> vstart += verdef -> vd_aux ; <S2SV_EndBug> ,<S2SV_ModStart> int vdaux = verdef -> vd_aux ; if ( vdaux < 1 ) { sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux <S2SV_ModEnd> 
432,<S2SV_StartBug> mapping = ( struct address_space * ) page_private ( page ) ; <S2SV_EndBug> ,<S2SV_ModStart> vma -> vm_file -> f_dentry -> d_inode -> i_mapping <S2SV_ModEnd> 
433,"<S2SV_StartBug> zap = key -> payload . data [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> rcu_assign_keypointer ( key , upayload ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_ModStart> else zap = NULL ; "
434,"<S2SV_StartBug> void vp9_fht8x8_c ( const int16_t * input , int16_t * output , <S2SV_EndBug> <S2SV_StartBug> vp9_fdct8x8_c ( input , output , stride ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t out [ 64 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = & out [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t temp_in [ 8 ] , temp_out [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> outptr [ j * 8 + i ] = temp_out [ j ] ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_fdct8x8_c <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> 
435,"<S2SV_StartBug> 1 , 0 , xcp , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
436,"<S2SV_StartBug> if ( s -> chunksize >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> s -> chunksize = strtoll ( line , NULL , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> av_log ( NULL , AV_LOG_TRACE , ""Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%"" PRId64 ""\'\\n"" , <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> int64_t target = h -> is_streamed ? 0 : s -> off ; <S2SV_EndBug> <S2SV_StartBug> av_log ( h , AV_LOG_INFO , ""Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRId64 ""<S2SV_blank>error=%s.\\n"" , s -> off , av_err2str ( read_ret ) ) ; <S2SV_EndBug> <S2SV_StartBug> av_log ( h , AV_LOG_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRId64 "".\\n"" , target ) ; <S2SV_EndBug> ","<S2SV_ModStart> != UINT64_MAX <S2SV_ModEnd> <S2SV_ModStart> strtoull <S2SV_ModEnd> <S2SV_ModStart> h <S2SV_ModEnd> <S2SV_ModStart> PRIu64 <S2SV_ModEnd> <S2SV_ModStart> else if ( s -> chunksize == UINT64_MAX ) { av_log ( h , AV_LOG_ERROR , ""Invalid<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>%"" PRIu64 ""\\n"" , s -> chunksize ) ; return AVERROR ( EINVAL ) ; } <S2SV_ModStart> uint64_t <S2SV_ModEnd> <S2SV_ModStart> PRIu64 <S2SV_ModEnd> <S2SV_ModStart> PRIu64 <S2SV_ModEnd> "
437,<S2SV_StartBug> int iSrc ; <S2SV_EndBug> <S2SV_StartBug> for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { <S2SV_EndBug> <S2SV_StartBug> dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ] . 
438,<S2SV_StartBug> else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) && <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
439,"<S2SV_StartBug> ALOGE ( ""b/26366256"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; android_errorWriteLog ( 0x534e4554 , ""26366256"" "
440,<S2SV_StartBug> void unix_inflight ( struct file * fp ) <S2SV_EndBug> <S2SV_StartBug> fp -> f_cred -> user -> unix_inflight ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> struct user_struct * user , <S2SV_ModStart>  <S2SV_ModEnd> "
441,"<S2SV_StartBug> const u_char * bp , enum pimv2_addrtype at , int silent ) <S2SV_EndBug> <S2SV_StartBug> int len , hdrlen ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK ( bp [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> len = sizeof ( struct in_addr ) ; <S2SV_EndBug> <S2SV_StartBug> len = sizeof ( struct in6_addr ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( pimv2_addr_len ) { <S2SV_EndBug> <S2SV_StartBug> len = pimv2_addr_len ; <S2SV_EndBug> <S2SV_StartBug> switch ( at ) { <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , len ) ; <S2SV_EndBug> <S2SV_StartBug> return hdrlen + len ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , len + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> return hdrlen + 2 + len ; <S2SV_EndBug> ","<S2SV_ModStart> u_int len , <S2SV_ModStart> u_int addr_len , <S2SV_ModStart> hdrlen ; if ( addr_len == 0 ) { if ( len < 2 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> addr_len = ( u_int ) <S2SV_ModEnd> <S2SV_ModStart> addr_len = ( u_int ) <S2SV_ModEnd> <S2SV_ModStart> addr_len <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> len -= hdrlen ; <S2SV_ModStart> if ( len < addr_len ) goto trunc ; <S2SV_ModStart> addr_len <S2SV_ModEnd> <S2SV_ModStart> addr_len <S2SV_ModEnd> <S2SV_ModStart> if ( len < addr_len + 2 ) goto trunc ; <S2SV_ModStart> addr_len <S2SV_ModEnd> <S2SV_ModStart> addr_len <S2SV_ModEnd> "
442,"<S2SV_StartBug> n = r -> sector_count ; <S2SV_EndBug> <S2SV_StartBug> r -> iov . iov_len = n * 512 ; <S2SV_EndBug> <S2SV_StartBug> qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , & r -> qiov , n , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> n = scsi_init_iovec ( r ) ; bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_READ ) ; r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , <S2SV_ModEnd> <S2SV_ModStart> n , scsi_read_complete , r ) ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
443,<S2SV_StartBug> match_length += callback_args -> forward_matches ; <S2SV_EndBug> ,<S2SV_ModStart> ; assert ( match_offset + match_length <= callback_args -> data_size ) 
444,<S2SV_StartBug> string -> space = 1 ; <S2SV_EndBug> <S2SV_StartBug> string -> space *= 2 ; <S2SV_EndBug> <S2SV_StartBug> if ( string -> space < 0 ) <S2SV_EndBug> <S2SV_StartBug> new_len = string -> space = G_MAXINT - 8 ; <S2SV_EndBug> ,"<S2SV_ModStart> { <S2SV_ModStart> 4 ; } else { const guint max_space = MIN ( G_MAXINT , G_MAXSIZE / MAX ( sizeof ( PangoGlyphInfo ) , sizeof ( gint ) ) ) ; guint more_space = ( guint ) <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModEnd> <S2SV_ModStart> more_space > max_space ) { more_space = max_space ; if ( ( guint ) new_len > max_space ) { g_error ( ""%s:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>glyph<S2SV_blank>string<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%i\\n"" , G_STRLOC , new_len ) ; } } <S2SV_ModEnd> <S2SV_ModStart> more_space <S2SV_ModEnd> "
445,<S2SV_StartBug> newnp -> mcast_oif = inet6_iif ( skb ) ; <S2SV_EndBug> <S2SV_StartBug> newnp -> pktoptions = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> <S2SV_ModStart> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> 
446,<S2SV_StartBug> szLineConv [ i ] = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( i >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; 
447,"<S2SV_StartBug> ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , <S2SV_EndBug> <S2SV_StartBug> if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) <S2SV_EndBug> ",<S2SV_ModStart> ps_dec -> ps_cur_slice -> u1_bottom_field_flag = 0 ; ps_dec -> ps_cur_slice -> u1_field_pic_flag = 0 ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; <S2SV_ModStart> ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ; 
448,"<S2SV_StartBug> cmdline_status = options_cmdline ( arg1 , arg2 ) ; <S2SV_EndBug> <S2SV_StartBug> return cmdline_status ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ",<S2SV_ModStart> log_flush ( LOG_MODE_BUFFER ) ; <S2SV_ModStart> { log_flush ( LOG_MODE_ERROR ) ; return cmdline_status ; } options_free ( 1 ) <S2SV_ModEnd> <S2SV_ModStart> { unbind_ports ( ) ; options_free ( 1 ) ; options_defaults ( ) ; options_apply ( ) ; log_flush ( LOG_MODE_ERROR ) ; return 1 ; } <S2SV_ModEnd> <S2SV_ModStart> { log_flush ( LOG_MODE_ERROR ) ; return 1 ; } <S2SV_ModEnd> <S2SV_ModStart> { log_flush ( LOG_MODE_ERROR ) ; return 1 ; } <S2SV_ModEnd> <S2SV_ModStart> { log_flush ( LOG_MODE_ERROR ) ; return 1 ; } <S2SV_ModEnd> 
449,"<S2SV_StartBug> len = get_line_size ( * b , * avail , nl ) ; <S2SV_EndBug> ","<S2SV_ModStart> + len , * avail - len <S2SV_ModEnd> "
450,"<S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
451,"<S2SV_StartBug> static INLINE int cost_coeffs ( MACROBLOCK * x , <S2SV_EndBug> <S2SV_StartBug> const int16_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int c , cost ; <S2SV_EndBug> <S2SV_StartBug> : get_uv_tx_size ( mbmi ) == tx_size ) ; <S2SV_EndBug> <S2SV_StartBug> int prev_t = vp9_dct_value_tokens_ptr [ v ] . token ; <S2SV_EndBug> <S2SV_StartBug> cost = ( * token_costs ) [ 0 ] [ pt ] [ prev_t ] + vp9_dct_value_cost_ptr [ v ] ; <S2SV_EndBug> <S2SV_StartBug> int t ; <S2SV_EndBug> <S2SV_StartBug> t = vp9_dct_value_tokens_ptr [ v ] . token ; <S2SV_EndBug> <S2SV_StartBug> cost += ( * token_costs ) [ ! prev_t ] [ ! prev_t ] [ t ] + vp9_dct_value_cost_ptr [ v ] ; <S2SV_EndBug> <S2SV_StartBug> cost += ( * token_costs ) [ ! prev_t ] [ pt ] [ t ] + vp9_dct_value_cost_ptr [ v ] ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH const int16_t * cat6_high_cost = vp9_get_high_cost_table ( xd -> bd ) ; # else const int16_t * cat6_high_cost = vp9_get_high_cost_table ( 8 ) ; # endif <S2SV_ModStart> , pd <S2SV_ModStart> int16_t prev_t ; EXTRABIT e ; vp9_get_token_extra ( v , & prev_t , & e ) <S2SV_ModEnd> <S2SV_ModStart> vp9_get_cost ( prev_t , e , cat6_high_cost ) <S2SV_ModEnd> <S2SV_ModStart> int16_t <S2SV_ModEnd> <S2SV_ModStart> vp9_get_token_extra ( v , & t , & e ) <S2SV_ModEnd> <S2SV_ModStart> vp9_get_cost ( t , e , cat6_high_cost ) <S2SV_ModEnd> <S2SV_ModStart> vp9_get_cost ( t , e , cat6_high_cost ) <S2SV_ModEnd> "
452,<S2SV_StartBug> if ( net != c_net || ! tc -> t_sock ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
453,"<S2SV_StartBug> CU_add_test ( parserTestSuite , ""Parse<S2SV_blank>Exchange"" , test_parserComplete ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""Parse<S2SV_blank>hvi<S2SV_blank>check<S2SV_blank>fail"" , test_parser_hvi ) ; CU_add_test ( parserTestSuite , "
454,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> m -> msg_namelen = 0 ; 
455,<S2SV_StartBug> return NF_ACCEPT ; <S2SV_EndBug> ,<S2SV_ModStart> err == 0 ? NF_ACCEPT : NF_DROP <S2SV_ModEnd> 
456,"<S2SV_StartBug> separator = strchr ( line , ':' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
457,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( plenbytes < 0 ) return plenbytes ; 
458,"<S2SV_StartBug> msg -> fp = mutt_bcache_get ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> <S2SV_StartBug> msg -> fp = mutt_bcache_put ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> <S2SV_StartBug> mutt_bcache_commit ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> ",<S2SV_ModStart> cache_id ( <S2SV_ModStart> ) <S2SV_ModStart> cache_id ( <S2SV_ModStart> ) <S2SV_ModStart> cache_id ( <S2SV_ModStart> ) 
459,<S2SV_StartBug> if ( dp -> icmp6_data16 [ 1 ] & 0xc0 ) <S2SV_EndBug> <S2SV_StartBug> if ( dp -> icmp6_data16 [ 1 ] & 0x80 ) <S2SV_EndBug> <S2SV_StartBug> if ( dp -> icmp6_data16 [ 1 ] & 0x40 ) <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 0xc0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> 0x80 ) ND_PRINT ( ( ndo , ""M"" ) ) ; if ( dp -> icmp6_data16 [ 1 ] & "
460,<S2SV_StartBug> struct serial_icounter_struct icount ; <S2SV_EndBug> ,<S2SV_ModStart> = { } 
461,"<S2SV_StartBug> r = mount ( ""cgroup_root"" , path , ""tmpfs"" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , ""size=10240k,mode=755"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> safe_mount <S2SV_ModEnd> <S2SV_ModStart> , root "
462,<S2SV_StartBug> Z_STRVAL_P ( return_value ) = emalloc ( len + 1 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( len > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d"" , INT_MAX ) ; RETURN_FALSE ; } "
463,"<S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> ThrowReaderException ( CorruptImageError , <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> ThrowDCMException <S2SV_ModEnd> 
464,"<S2SV_StartBug> strlcpy ( rcomp . type , ""compression"" , sizeof ( rcomp . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> 
465,<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ; 
466,<S2SV_StartBug> int err ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL 
467,<S2SV_StartBug> return ( ( f != NULL && <S2SV_EndBug> <S2SV_StartBug> f -> addressFamily != NULL && f -> addressFamily -> data != NULL ) <S2SV_EndBug> <S2SV_StartBug> ? ( ( f -> addressFamily -> data [ 0 ] << 8 ) | ( f -> addressFamily -> data [ 1 ] ) ) <S2SV_EndBug> ,<S2SV_ModStart> if ( f == NULL || <S2SV_ModEnd> <S2SV_ModStart> == NULL || <S2SV_ModEnd> <S2SV_ModStart> == NULL || f -> addressFamily -> length < 2 ) return 0 ; return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
468,"<S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> ",<S2SV_ModStart> { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> } <S2SV_ModStart> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> } <S2SV_ModStart> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; 
469,"<S2SV_StartBug> if ( stat ( ""/etc/skel/.zshrc"" , & s ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( is_link ( ""/etc/skel/.zshrc"" ) ) { <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>/etc/skel/.zshrc<S2SV_blank>file\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.zshrc"" , fname ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> errExit ( ""chown"" ) ; <S2SV_EndBug> <S2SV_StartBug> fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( arg_csh ) { <S2SV_EndBug> ","<S2SV_ModStart> is_link ( fname ) ) { fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n"" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> copy_file_as_user ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) ; fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ; } else { touch_file_as_user ( fname , u , g , 0644 ) ; fs_logger2 ( ""touch"" , fname ) ; } free ( fname ) ; } else if ( arg_csh ) { if ( asprintf ( & fname , ""%s/.cshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; <S2SV_ModStart> fname <S2SV_ModEnd> <S2SV_ModStart> ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n"" , fname <S2SV_ModEnd> <S2SV_ModStart> stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) { copy_file_as_user ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) ; fs_logger ( ""clone<S2SV_blank>/etc/skel/.cshrc"" ) ; } else { touch_file_as_user ( fname , u , g , 0644 ) ; fs_logger2 ( ""touch"" , fname ) ; } free ( fname ) ; } else { if ( asprintf ( & fname , ""%s/.bashrc"" , homedir <S2SV_ModEnd> <S2SV_ModStart> ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( is_link ( fname ) ) { fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n"" , fname ) ; exit ( 1 ) ; } if ( stat ( ""/etc/skel/.bashrc"" , & s ) == 0 ) { copy_file_as_user ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 <S2SV_ModEnd> <S2SV_ModStart> ""clone<S2SV_blank>/etc/skel/.bashrc"" ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
470,"<S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> ","<S2SV_ModStart> | CVAR_PROTECTED <S2SV_ModStart> if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; } "
471,"<S2SV_StartBug> ret = scsi_disk_emulate_command ( r , r -> iov . iov_base ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
472,"<S2SV_StartBug> ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; <S2SV_EndBug> <S2SV_StartBug> tlen = len ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> type , length ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( tptr [ 3 ] , length - 3 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( tptr [ 3 ] , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> EXTRACT_64BITS ( tptr + 3 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> print_unknown_data ( ndo , tptr + 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , length - 3 ) ; <S2SV_EndBug> ",<S2SV_ModStart> tlen = len ; while ( tlen >= 3 ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tptr += 3 ; tlen -= 3 ; <S2SV_ModStart> ; if ( length < 3 ) goto trunc ; length -= 3 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( length < 8 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
473,<S2SV_StartBug> state -> object_nl = strdup ( RSTRING_PTR ( object_nl ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> fstrndup <S2SV_ModEnd> <S2SV_ModStart> , len "
474,<S2SV_StartBug> for ( y = 0 ; y < s -> ymin ; y ++ ) { <S2SV_EndBug> ,"<S2SV_ModStart> FFMIN ( <S2SV_ModStart> , s -> h ) "
475,"<S2SV_StartBug> for ( ac = 0 ; ac < IEEE80211_NUM_ACS ; ac ++ ) { <S2SV_EndBug> <S2SV_StartBug> ieee80211_add_pending_skbs_fn ( local , & pending , clear_sta_ps_flags , sta ) ; <S2SV_EndBug> ",<S2SV_ModStart> spin_lock ( & sta -> ps_lock ) ; <S2SV_ModStart> ) ; spin_unlock ( & sta -> ps_lock 
476,"<S2SV_StartBug> prefetch_table ( ( const void * ) encT , sizeof ( encT ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> enc_tables . counter_head ++ ; enc_tables . counter_tail ++ ; <S2SV_ModStart> & enc_tables <S2SV_ModEnd> <S2SV_ModStart> enc_tables <S2SV_ModEnd> 
477,<S2SV_StartBug> struct ssh * ssh = active_state ; <S2SV_EndBug> <S2SV_StartBug> if ( options . compression ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
478,<S2SV_StartBug> if ( l >= ( len - o ) ) { <S2SV_EndBug> ,<S2SV_ModStart> - 4 
479,"<S2SV_StartBug> ap_log_cerror ( APLOG_MARK , APLOG_ERR , 0 , session -> c , <S2SV_EndBug> <S2SV_StartBug> if ( status != APR_SUCCESS && ! h2_stream_is_ready ( stream ) ) { <S2SV_EndBug> ","<S2SV_ModStart> APLOG_DEBUG <S2SV_ModEnd> <S2SV_ModStart> if ( status == APR_ECONNRESET ) { ap_log_cerror ( APLOG_MARK , APLOG_TRACE1 , status , session -> c , ""h2-stream(%ld-%d):<S2SV_blank>on_header,<S2SV_blank>reset<S2SV_blank>stream"" , session -> id , stream -> id ) ; nghttp2_submit_rst_stream ( ngh2 , NGHTTP2_FLAG_NONE , stream -> id , NGHTTP2_INTERNAL_ERROR ) ; } else "
480,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % ( 2 * stride ) ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horDiff8"" , ""%s"" , ""(cc%(2*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; "
481,"<S2SV_StartBug> CAFChannelLayout * caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; <S2SV_EndBug> <S2SV_StartBug> ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || <S2SV_EndBug> <S2SV_StartBug> int bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ; <S2SV_EndBug> <S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> caf_chunk_header . mChunkSize > 1024 ) { error_line ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\'chan\'<S2SV_blank>chunk!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""\'chan\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes"" , ( int ) caf_chunk_header . mChunkSize ) ; caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; if ( <S2SV_ModStart> uint32_t <S2SV_ModEnd> <S2SV_ModStart> buff ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } "
482,"<S2SV_StartBug> char linebuf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> if ( fgets ( linebuf , L_BUF_SIZE , fp ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> sscanf ( linebuf , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%s<S2SV_blank><S2SV_blank>------"" , selname ) ; <S2SV_EndBug> ","<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%200s<S2SV_blank><S2SV_blank>------"" <S2SV_ModEnd> "
483,<S2SV_StartBug> char build [ ATUSB_BUILD_SIZE + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ,"<S2SV_ModStart> * build <S2SV_ModEnd> <S2SV_ModStart> ; build = kmalloc ( ATUSB_BUILD_SIZE + 1 , GFP_KERNEL ) ; if ( ! build ) return - ENOMEM <S2SV_ModStart> kfree ( build ) ; "
484,<S2SV_StartBug> if ( isspace ( * s ) ) <S2SV_EndBug> ,<S2SV_ModStart> ( unsigned char ) 
485,"<S2SV_StartBug> uzbl . net . useragent = ""Test<S2SV_blank>useragent"" ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
486,"<S2SV_StartBug> zval * options = NULL , * classes = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { <S2SV_EndBug> <S2SV_StartBug> zval_ptr_dtor ( return_value ) ; <S2SV_EndBug> <S2SV_StartBug> var_push_dtor ( & var_hash , return_value ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; zval * retval <S2SV_ModStart> retval = var_tmp_var ( & var_hash ) ; <S2SV_ModStart> retval <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ZVAL_COPY ( return_value , retval <S2SV_ModEnd> "
487,"<S2SV_StartBug> int cond_len , then_len , jump_len ; <S2SV_EndBug> <S2SV_StartBug> jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END ; <S2SV_EndBug> <S2SV_StartBug> int else_len = compile_length_tree ( Else , reg ) ; <S2SV_EndBug> <S2SV_StartBug> COP ( reg ) -> jump . addr = else_len + SIZE_INC_OP ; <S2SV_EndBug> <S2SV_StartBug> r = compile_tree ( Else , reg , env ) ; <S2SV_EndBug> ","<S2SV_ModStart> else_len , <S2SV_ModStart> + <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( else_len < 0 ) return else_len ; } else else_len = 0 <S2SV_ModStart> SIZE_OP_ATOMIC_END + <S2SV_ModStart> add_op ( reg , OP_ATOMIC_END ) ; if ( r != 0 ) return r ; if ( IS_NOT_NULL ( Else ) ) { r = "
488,"<S2SV_StartBug> if ( pt [ 6 ] & AX25_HBIT ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> memcpy ( & facilities -> source_digis [ facilities -> source_ndigis ++ ] , pt , AX25_ADDR_LEN ) ; <S2SV_EndBug> ",<S2SV_ModStart> { if ( facilities -> dest_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; <S2SV_ModStart> } else { if ( facilities -> source_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; <S2SV_ModEnd> <S2SV_ModStart> } 
489,"<S2SV_StartBug> uint8_t * outbuf ; <S2SV_EndBug> <S2SV_StartBug> command = buf [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> rc = scsi_disk_emulate_command ( r , outbuf ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
490,"<S2SV_StartBug> assertEqualInt ( ARCHIVE_OK , archive_write_free ( a ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; assert ( 0 == unlink ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) ; failure ( ""Extracting<S2SV_blank>an<S2SV_blank>absolute<S2SV_blank>path<S2SV_blank>should<S2SV_blank>fail<S2SV_blank>here."" ) ; assertEqualInt ( ARCHIVE_FAILED , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileNotExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; "
491,"<S2SV_StartBug> const uint8_t * p , u_int length , u_int caplen ) <S2SV_EndBug> <S2SV_StartBug> if ( caplen <= 1 ) { <S2SV_EndBug> <S2SV_StartBug> print_unknown_data ( ndo , p , ""\\n\\t"" , caplen ) ; <S2SV_EndBug> <S2SV_StartBug> print_unknown_data ( ndo , p , ""\\n\\t"" , caplen ) ; <S2SV_EndBug> <S2SV_StartBug> if ( caplen > 1 ) <S2SV_EndBug> <S2SV_StartBug> print_unknown_data ( ndo , p , ""\\n\\t"" , caplen ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ! ND_TTEST ( * p ) <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> 
492,<S2SV_StartBug> register struct enamemem * tp ; <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_name ) <S2SV_EndBug> <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> <S2SV_StartBug> tp -> e_name = strdup ( buf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_name == NULL ) <S2SV_EndBug> <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> ,<S2SV_ModStart> bsnamemem <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> 
493,<S2SV_StartBug> if ( ctx -> mb_height > 68 || <S2SV_EndBug> <S2SV_StartBug> ctx -> data_offset = 0x280 ; <S2SV_EndBug> ,"<S2SV_ModStart> ) { av_log ( ctx -> avctx , AV_LOG_ERROR , ""mb<S2SV_blank>height<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%d\\n"" , ctx -> mb_height ) ; return AVERROR_INVALIDDATA ; } ctx -> data_offset = 0x280 ; } if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
494,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> opt = np -> opt ; <S2SV_EndBug> <S2SV_StartBug> return err < 0 ? err : len ; <S2SV_EndBug> ,<S2SV_ModStart> struct ipv6_txoptions * opt_to_free = NULL ; <S2SV_ModStart> { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> <S2SV_ModStart> txopt_put ( opt_to_free ) ; 
495,<S2SV_StartBug> mutex_lock ( & vdev -> vdev_mutex ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( memcmp ( & dd , dd_config , sizeof ( dd ) ) ) { ret = - EINVAL ; goto free_ret ; } "
496,<S2SV_StartBug> if ( count < sizeof ( cmd ) ) { <S2SV_EndBug> ,<S2SV_ModStart> WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if ( 
497,<S2SV_StartBug> filename [ filename_size ++ ] = '\\0' ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
498,"<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> rc = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc == 0 ) <S2SV_EndBug> ","<S2SV_ModStart> ; rc = posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( rc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
499,<S2SV_StartBug> spin_lock_init ( & port -> phy_list_lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> INIT_LIST_HEAD ( & port -> sas_port_del_list ) ; 
500,"<S2SV_StartBug> hmp_data = hmp_chunk [ i ] + chunk_length [ i ] ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( ( setup_ret = _WM_SetupMidiEvent ( hmp_mdi , hmp_chunk [ i ] , 0 ) ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chunk_end [ i ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( * hmp_chunk [ i ] < 0x80 ) { <S2SV_EndBug> <S2SV_StartBug> chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( * hmp_chunk [ i ] < 0x80 ) ; <S2SV_EndBug> <S2SV_StartBug> chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ; <S2SV_EndBug> <S2SV_StartBug> hmp_chunk [ i ] ++ ; <S2SV_EndBug> ","<S2SV_ModStart> [ i ] ; chunk_length [ i ] -= chunk_ofs <S2SV_ModStart> chunk_length [ i ] -= 3 ; <S2SV_ModStart> [ i ] , chunk_length <S2SV_ModStart> ; chunk_length [ i ] -= 3 <S2SV_ModStart> chunk_length [ i ] -= setup_ret ; <S2SV_ModStart> chunk_length [ i ] && <S2SV_ModStart> if ( ! chunk_length [ i ] ) break ; <S2SV_ModStart> chunk_length [ i ] -- ; <S2SV_ModStart> if ( ! chunk_length [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmp_end ; } <S2SV_ModStart> ; chunk_length [ i ] -- "
501,"<S2SV_StartBug> mem_free ( gr . gr_ctx . value , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & min_stat , & gd -> checksum ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
502,"<S2SV_StartBug> ns_capable ( current -> nsproxy -> pid_ns -> user_ns , CAP_SYS_ADMIN ) ) && <S2SV_EndBug> ",<S2SV_ModStart> task_active_pid_ns ( current ) <S2SV_ModEnd> 
503,<S2SV_StartBug> mntput ( ns -> proc_mnt ) ; <S2SV_EndBug> ,<S2SV_ModStart> kern_unmount <S2SV_ModEnd> 
504,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p + 2 ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
505,"<S2SV_StartBug> return ! inode_capable ( inode , CAP_FOWNER ) ; <S2SV_EndBug> ",<S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> 
506,"<S2SV_StartBug> struct LayerData * cx_layer_list = NULL ; <S2SV_EndBug> <S2SV_StartBug> memset ( & superframe , 0 , sizeof ( superframe ) ) ; <S2SV_EndBug> <S2SV_StartBug> case VPX_CODEC_CX_FRAME_PKT : { <S2SV_EndBug> <S2SV_StartBug> si -> bytes_sum [ si -> layer ] += frame_pkt_size ; <S2SV_EndBug> <S2SV_StartBug> ld_list_add ( & cx_layer_list , layer_data ) ; <S2SV_EndBug> ","<S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> <S2SV_ModStart> svc_log_reset ( svc_ctx ) ; res = vpx_codec_encode ( codec_ctx , rawimg , pts , ( uint32_t ) duration <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if VPX_ENCODER_ABI_VERSION > ( 5 + VPX_CODEC_ABI_VERSION ) # if CONFIG_SPATIAL_SVC case VPX_CODEC_SPATIAL_SVC_LAYER_PSNR : { int i ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) { int j ; svc_log ( svc_ctx , SVC_LOG_DEBUG , ""SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>PSNR(Total/Y/U/V):<S2SV_blank>"" ""%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank>\\n"" , si -> psnr_pkt_received , i , cx_pkt -> data . layer_psnr [ i ] . psnr [ 0 ] , cx_pkt -> data . layer_psnr [ i ] . psnr [ 1 ] , cx_pkt -> data . layer_psnr [ i ] . psnr [ 2 ] , cx_pkt -> data . layer_psnr [ i ] . psnr [ 3 ] ) ; svc_log ( svc_ctx , SVC_LOG_DEBUG , ""SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>SSE(Total/Y/U/V):<S2SV_blank>"" ""%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank>\\n"" , si -> psnr_pkt_received , i , cx_pkt -> data . layer_psnr [ i ] . sse [ 0 ] , cx_pkt -> data . layer_psnr [ i ] . sse [ 1 ] , cx_pkt -> data . layer_psnr [ i ] . sse [ 2 ] , cx_pkt -> data . layer_psnr [ i ] . sse [ 3 ] ) ; for ( j = 0 ; j < COMPONENTS ; ++ j ) { si -> psnr_sum [ i ] [ j ] += cx_pkt -> data . layer_psnr [ i ] . psnr [ j ] ; si -> sse_sum [ i ] [ j ] += cx_pkt -> data . layer_psnr [ i ] . sse [ j ] ; } } ++ si -> psnr_pkt_received ; break ; } case VPX_CODEC_SPATIAL_SVC_LAYER_SIZES : { int i ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) <S2SV_ModEnd> <S2SV_ModStart> i ] += cx_pkt -> data . layer_sizes [ i ] ; break ; } # endif # endif default : { break ; } } } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
507,<S2SV_StartBug> void * parg = NULL ; <S2SV_EndBug> <S2SV_StartBug> int is_ext_ctrl ; <S2SV_EndBug> <S2SV_StartBug> case _IOC_NONE : <S2SV_EndBug> <S2SV_StartBug> case _IOC_WRITE : <S2SV_EndBug> <S2SV_StartBug> if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> ( void * ) arg ; long err = - EINVAL ; bool has_array_args ; size_t array_size = 0 ; void __user * user_ptr = NULL ; void * * kernel_ptr = NULL ; if ( _IOC_DIR ( cmd ) != _IOC_NONE ) { if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) { parg = sbuf ; } else { mbuf = kmalloc ( _IOC_SIZE ( cmd ) , GFP_KERNEL ) ; if ( NULL == mbuf ) return - ENOMEM ; parg = mbuf ; } err = - EFAULT ; if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) { unsigned long n = cmd_input_size ( cmd ) ; if ( copy_from_user ( parg , ( void __user * ) arg , n ) ) goto out ; if ( n < _IOC_SIZE ( cmd ) ) memset ( ( u8 * ) parg + n , 0 , _IOC_SIZE ( cmd ) - n ) ; } else { memset ( parg , 0 , _IOC_SIZE ( cmd ) ) ; } } err = check_array_args ( cmd , parg , & array_size , & user_ptr , & kernel_ptr ) ; if ( err < 0 ) goto out ; has_array_args = err ; if ( has_array_args ) { mbuf = kmalloc ( array_size , GFP_KERNEL ) ; err = - ENOMEM ; if ( NULL == mbuf ) goto out_array_args ; err = - EFAULT ; if ( copy_from_user ( mbuf , user_ptr , array_size ) ) goto out_array_args ; * kernel_ptr = mbuf ; } err = func ( file , cmd , parg ) ; if ( err == - ENOIOCTLCMD ) <S2SV_ModEnd> <S2SV_ModStart> if ( has_array_args ) { * kernel_ptr = user_ptr ; if ( copy_to_user ( user_ptr , mbuf , array_size ) ) err = - EFAULT ; goto out_array_args ; } if ( err < 0 ) goto out ; out_array_args : <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
508,<S2SV_StartBug> char fstr [ MAXDATELEN + 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart> 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> 
509,"<S2SV_StartBug> pi -> xstep = pi -> picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn + <S2SV_EndBug> <S2SV_StartBug> pi -> ystep = pi -> picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn + <S2SV_EndBug> <S2SV_StartBug> pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( 1 << <S2SV_EndBug> <S2SV_StartBug> pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( 1 << <S2SV_EndBug> ","<S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> <S2SV_ModStart> ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> <S2SV_ModStart> ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> "
510,"<S2SV_StartBug> sraSpanInsertAfter ( sraSpan * newspan , sraSpan * after ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> after ) { if ( newspan && <S2SV_ModStart> } 
511,<S2SV_StartBug> while ( c && which > 0 ) { <S2SV_EndBug> <S2SV_StartBug> c = c -> next ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , which -- ; <S2SV_ModEnd> "
512,<S2SV_StartBug> if ( noblock ) <S2SV_EndBug> ,<S2SV_ModStart> cond_resched ( ) <S2SV_ModEnd> 
513,"<S2SV_StartBug> memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( len < j + msg -> len + 1 ) { LM_ERR ( ""not<S2SV_blank>enough<S2SV_blank>space<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>sip<S2SV_blank>message\\n"" ) ; return - 1 ; } "
514,"<S2SV_StartBug> isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len <S2SV_ModStart>  <S2SV_ModEnd> "
515,<S2SV_StartBug> skcipher -> setkey = alg -> setkey ; <S2SV_EndBug> ,<S2SV_ModStart> skcipher_setkey <S2SV_ModEnd> 
516,"<S2SV_StartBug> c . c_normalize_args = NULL ; <S2SV_EndBug> <S2SV_StartBug> PyTuple_SET_ITEM ( c . c_normalize_args , 1 , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
517,"<S2SV_StartBug> void vp9_encode_block_intra ( MACROBLOCK * x , int plane , int block , <S2SV_EndBug> <S2SV_StartBug> unsigned char * skip ) { <S2SV_EndBug> <S2SV_StartBug> struct encode_b_args arg = { x , NULL , skip } ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> void * arg <S2SV_ModEnd> <S2SV_ModStart> * const args = arg ; MACROBLOCK * const x = args -> x ; MACROBLOCKD * const xd = & x -> e_mbd ; MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; struct macroblock_plane * const p = & x -> plane [ plane ] ; struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; tran_low_t * coeff = BLOCK_OFFSET ( p -> coeff , block ) ; tran_low_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; tran_low_t * dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; const scan_order * scan_order ; TX_TYPE tx_type = DCT_DCT ; PREDICTION_MODE mode ; const int bwl = b_width_log2_lookup [ plane_bsize ] ; const int diff_stride = 4 * ( 1 << bwl ) ; uint8_t * src , * dst ; int16_t * src_diff ; uint16_t * eob = & p -> eobs [ block ] ; const int src_stride = p -> src . stride ; const int dst_stride = pd -> dst . stride ; int i , j ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ; dst = & pd -> dst . buf [ 4 * ( j * dst_stride + i ) ] ; src = & p -> src . buf [ 4 * ( j * src_stride + i ) ] ; src_diff = & p -> src_diff [ 4 * ( j * diff_stride + i ) ] ; if ( tx_size == TX_4X4 ) { tx_type = get_tx_type_4x4 ( pd -> plane_type , xd , block ) ; scan_order = & vp9_scan_orders [ TX_4X4 ] [ tx_type ] ; mode = plane == 0 ? get_y_mode ( xd -> mi [ 0 ] , block ) : mbmi -> uv_mode ; } else { mode = plane == 0 ? mbmi -> mode : mbmi -> uv_mode ; if ( tx_size == TX_32X32 ) { scan_order = & vp9_default_scan_orders [ TX_32X32 ] ; } else { tx_type = get_tx_type ( pd -> plane_type , xd ) ; scan_order = & vp9_scan_orders [ tx_size ] [ tx_type ] ; } } vp9_predict_intra_block ( xd , bwl , tx_size , mode , x -> skip_encode ? src : dst , x -> skip_encode ? src_stride : dst_stride , dst , dst_stride , i , j , plane ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { switch ( tx_size ) { case TX_32X32 : if ( ! x -> skip_recode ) { vpx_highbd_subtract_block ( 32 , 32 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ; highbd_fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) { vp9_highbd_idct32x32_add ( dqcoeff , dst , dst_stride , * eob , xd -> bd ) ; } break ; case TX_16X16 : if ( ! x -> skip_recode ) { vpx_highbd_subtract_block ( 16 , 16 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ; if ( tx_type == DCT_DCT ) vpx_highbd_fdct16x16 ( src_diff , coeff , diff_stride ) ; else vp9_highbd_fht16x16 ( src_diff , coeff , diff_stride , tx_type ) ; vpx_highbd_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) { vp9_highbd_iht16x16_add ( tx_type , dqcoeff , dst , dst_stride , * eob , xd -> bd ) ; } break ; case TX_8X8 : if ( ! x -> skip_recode ) { vpx_highbd_subtract_block ( 8 , 8 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ; if ( tx_type == DCT_DCT ) vpx_highbd_fdct8x8 ( src_diff , coeff , diff_stride ) ; else vp9_highbd_fht8x8 ( src_diff , coeff , diff_stride , tx_type ) ; vpx_highbd_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) { vp9_highbd_iht8x8_add ( tx_type , dqcoeff , dst , dst_stride , * eob , xd -> bd ) ; } break ; case TX_4X4 : if ( ! x -> skip_recode ) { vpx_highbd_subtract_block ( 4 , 4 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ; if ( tx_type != DCT_DCT ) vp9_highbd_fht4x4 ( src_diff , coeff , diff_stride , tx_type ) ; else x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) { if ( tx_type == DCT_DCT ) { x -> highbd_itxm_add ( dqcoeff , dst , dst_stride , * eob , xd -> bd ) ; } else { vp9_highbd_iht4x4_16_add ( dqcoeff , dst , dst_stride , tx_type , xd -> bd ) ; } } break ; default : assert ( 0 ) ; return ; } if ( * eob ) * ( args -> skip ) = 0 ; return ; } # endif switch ( tx_size ) { case TX_32X32 : if ( ! x -> skip_recode ) { vpx_subtract_block ( 32 , 32 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ; fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; vpx_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) vp9_idct32x32_add ( dqcoeff , dst , dst_stride , * eob ) ; break ; case TX_16X16 : if ( ! x -> skip_recode ) { vpx_subtract_block ( 16 , 16 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ; vp9_fht16x16 ( src_diff , coeff , diff_stride , tx_type ) ; vpx_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) vp9_iht16x16_add ( tx_type , dqcoeff , dst , dst_stride , * eob ) ; break ; case TX_8X8 : if ( ! x -> skip_recode ) { vpx_subtract_block ( 8 , 8 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ; vp9_fht8x8 ( src_diff , coeff , diff_stride , tx_type ) ; vpx_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) vp9_iht8x8_add ( tx_type , dqcoeff , dst , dst_stride , * eob ) ; break ; case TX_4X4 : if ( ! x -> skip_recode ) { vpx_subtract_block ( 4 , 4 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ; if ( tx_type != DCT_DCT ) vp9_fht4x4 ( src_diff , coeff , diff_stride , tx_type ) ; else x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) { if ( tx_type == DCT_DCT ) x -> itxm_add ( dqcoeff , dst , dst_stride , * eob ) ; else vp9_iht4x4_16_add ( dqcoeff , dst , dst_stride , tx_type ) ; } break ; default : assert ( 0 ) ; break ; } if ( * eob ) * ( args -> skip ) = 0 <S2SV_ModEnd> "
518,"<S2SV_StartBug> UnpackRaster : <S2SV_EndBug> <S2SV_StartBug> image -> rows = Bitmap2Header1 . Height ; <S2SV_EndBug> <S2SV_StartBug> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; <S2SV_EndBug> ","<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; <S2SV_ModStart> ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break <S2SV_ModStart>  <S2SV_ModEnd> "
519,<S2SV_StartBug> if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) <S2SV_EndBug> ,"<S2SV_ModStart> * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ; if ( <S2SV_ModStart> * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ; if ( "
520,"<S2SV_StartBug> int ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( d2i_ECDSA_SIG ( & s , & sigbuf , sig_len ) == NULL ) goto err ; <S2SV_EndBug> <S2SV_StartBug> ECDSA_SIG_free ( s ) ; <S2SV_EndBug> ","<S2SV_ModStart> const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> p <S2SV_ModEnd> <S2SV_ModStart> goto err ; derlen = i2d_ECDSA_SIG ( s , & der ) ; if ( derlen != sig_len || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; } "
521,"<S2SV_StartBug> switch ( af ) { <S2SV_EndBug> <S2SV_StartBug> strncpy ( addr_text , <S2SV_EndBug> <S2SV_StartBug> ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , <S2SV_EndBug> ","<S2SV_ModStart> size_t pathlen = 0 ; <S2SV_ModStart> pathlen = sizeof ( <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( MAXPATHLEN <= pathlen ) { pathlen = MAXPATHLEN - 1 ; } strncpy ( addr_text , ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , pathlen ) ; addr_text [ pathlen <S2SV_ModEnd> "
522,<S2SV_StartBug> struct tpacket_req * req = & req_u -> req ; <S2SV_EndBug> <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( pg_vec ) <S2SV_EndBug> ,"<S2SV_ModStart> ; lock_sock ( sk ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( pg_vec ) free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ; out : <S2SV_ModStart>  <S2SV_ModEnd> "
523,<S2SV_StartBug> ! no_port_forwarding_flag && ! options . disable_forwarding ) { <S2SV_EndBug> ,<S2SV_ModStart> && use_privsep 
524,"<S2SV_StartBug> RANGE_CHECK_HI ( cfg , rc_undershoot_pct , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK_HI ( cfg , rc_overshoot_pct , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK ( cfg , ss_number_layers , 1 , VPX_SS_MAX_LAYERS ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> ts_number_layers > 1 ) { <S2SV_EndBug> <S2SV_StartBug> unsigned int i ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 1 ; i < cfg -> ts_number_layers ; ++ i ) <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>increasing"" ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = cfg -> ts_number_layers - 2 ; i > 0 ; -- i ) <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> ts_rate_decimator [ i - 1 ] != 2 * cfg -> ts_rate_decimator [ i ] ) <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2"" ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK_BOOL ( extra_cfg , enable_auto_alt_ref ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK ( extra_cfg , cpu_used , - 16 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK ( extra_cfg , arnr_type , 1 , 3 ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK ( extra_cfg , cq_level , 0 , 63 ) ; <S2SV_EndBug> <S2SV_StartBug> size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; <S2SV_EndBug> <S2SV_StartBug> int n_packets = ( int ) ( cfg -> rc_twopass_stats_in . sz / packet_sz ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> ss_number_layers > 1 ) { <S2SV_EndBug> <S2SV_StartBug> || ( int ) ( stats -> count + 0.5 ) != n_packets_per_layer [ layer_id ] - 1 ) <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> g_profile <= ( unsigned int ) PROFILE_1 && <S2SV_EndBug> <S2SV_StartBug> extra_cfg -> bit_depth > BITS_8 ) <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 && <S2SV_EndBug> <S2SV_StartBug> extra_cfg -> bit_depth == BITS_8 ) <S2SV_EndBug> ","<S2SV_ModStart> 100 <S2SV_ModEnd> <S2SV_ModStart> 100 <S2SV_ModEnd> <S2SV_ModStart> extra_cfg , min_gf_interval , 0 , ( MAX_LAG_BUFFERS - 1 ) ) ; RANGE_CHECK ( extra_cfg , max_gf_interval , 0 , ( MAX_LAG_BUFFERS - 1 ) ) ; if ( extra_cfg -> max_gf_interval > 0 ) { RANGE_CHECK ( extra_cfg , max_gf_interval , 2 , ( MAX_LAG_BUFFERS - 1 ) ) ; } if ( extra_cfg -> min_gf_interval > 0 && extra_cfg -> max_gf_interval > 0 ) { RANGE_CHECK ( extra_cfg , max_gf_interval , extra_cfg -> min_gf_interval , ( MAX_LAG_BUFFERS - 1 ) ) ; } if ( cfg -> rc_resize_allowed == 1 ) { RANGE_CHECK ( cfg , rc_scaled_width , 0 , cfg -> g_w ) ; RANGE_CHECK ( cfg , rc_scaled_height , 0 , cfg -> g_h ) ; } RANGE_CHECK ( <S2SV_ModStart> ss_number_layers * cfg -> ts_number_layers > VPX_MAX_LAYERS ) ERROR ( ""ss_number_layers<S2SV_blank>*<S2SV_blank>ts_number_layers<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" ) ; if ( cfg -> ts_number_layers > <S2SV_ModEnd> <S2SV_ModStart> sl , tl <S2SV_ModEnd> <S2SV_ModStart> sl = 1 ; sl <S2SV_ModEnd> <S2SV_ModStart> ss_number_layers ; ++ sl ) { for ( tl = 1 ; tl < cfg -> <S2SV_ModStart> tl ) { const int layer = LAYER_IDS_TO_IDX ( sl , tl , cfg -> ts_number_layers ) ; if ( cfg -> layer_target_bitrate [ layer ] < cfg -> layer_target_bitrate [ layer <S2SV_ModEnd> <S2SV_ModStart> } } <S2SV_ModStart> tl <S2SV_ModEnd> <S2SV_ModStart> tl <S2SV_ModEnd> <S2SV_ModStart> tl <S2SV_ModEnd> <S2SV_ModStart> tl <S2SV_ModEnd> <S2SV_ModStart> tl ] ) ERROR ( ""ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2"" ) ; } # if CONFIG_SPATIAL_SVC if ( ( cfg -> ss_number_layers > 1 || cfg -> ts_number_layers > 1 ) && cfg -> g_pass == VPX_RC_LAST_PASS ) { unsigned int i , alt_ref_sum = 0 ; for ( i = 0 ; i < cfg -> ss_number_layers ; ++ i ) { if ( cfg -> ss_enable_auto_alt_ref [ <S2SV_ModStart> ++ alt_ref_sum ; } if ( alt_ref_sum > REF_FRAMES - cfg -> ss_number_layers ) ERROR ( ""Not<S2SV_blank>enough<S2SV_blank>ref<S2SV_blank>buffers<S2SV_blank>for<S2SV_blank>svc<S2SV_blank>alt<S2SV_blank>ref<S2SV_blank>frames"" ) ; if ( cfg -> ss_number_layers * cfg -> ts_number_layers > 3 && cfg -> g_error_resilient == 0 ) ERROR ( ""Multiple<S2SV_blank>frame<S2SV_blank>context<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>more<S2SV_blank>than<S2SV_blank>3<S2SV_blank>layers"" ) ; } # endif <S2SV_ModEnd> <S2SV_ModStart> RANGE_CHECK <S2SV_ModEnd> <S2SV_ModStart> , 0 , 2 <S2SV_ModStart> 8 , 8 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; RANGE_CHECK ( cfg , g_bit_depth , VPX_BITS_8 , VPX_BITS_12 ) ; RANGE_CHECK ( cfg , g_input_bit_depth , 8 , 12 ) ; RANGE_CHECK ( extra_cfg , content , VP9E_CONTENT_DEFAULT , VP9E_CONTENT_INVALID - 1 <S2SV_ModStart> const <S2SV_ModStart> const <S2SV_ModStart> > 1 || cfg -> ts_number_layers <S2SV_ModStart> unsigned <S2SV_ModStart> # if ! CONFIG_VP9_HIGHBITDEPTH if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 ) { ERROR ( ""Profile<S2SV_blank>><S2SV_blank>1<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>this<S2SV_blank>build<S2SV_blank>configuration"" ) ; } # endif <S2SV_ModStart> cfg -> g_bit_depth > VPX_BITS_8 ) { ERROR ( ""Codec<S2SV_blank>high<S2SV_blank>bit-depth<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank><<S2SV_blank>2"" ) ; } <S2SV_ModEnd> <S2SV_ModStart> <= <S2SV_ModEnd> <S2SV_ModStart> cfg -> g_input_bit_depth > 8 ) { ERROR ( ""Source<S2SV_blank>high<S2SV_blank>bit-depth<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank><<S2SV_blank>2"" ) ; } if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 && cfg -> g_bit_depth == VPX_BITS_8 ) { ERROR ( ""Codec<S2SV_blank>bit-depth<S2SV_blank>8<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank>><S2SV_blank>1"" ) ; } RANGE_CHECK ( extra_cfg , color_space , VPX_CS_UNKNOWN , VPX_CS_SRGB <S2SV_ModEnd> "
525,"<S2SV_StartBug> static vpx_codec_err_t vp8_get_last_ref_frame ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
526,<S2SV_StartBug> char added ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
527,<S2SV_StartBug> blk_cleanup_queue ( cd -> disk -> queue ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! cd -> disk ) continue ; 
528,<S2SV_StartBug> if ( sum_calculated != headersum ) { <S2SV_EndBug> ,<S2SV_ModStart> lha -> compsize < 0 ) goto invalid ; if ( 
529,"<S2SV_StartBug> int fd = accept ( s , ( struct sockaddr * ) & client_address , & clen ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
530,<S2SV_StartBug> if ( net != & init_net ) <S2SV_EndBug> ,<S2SV_ModStart> protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if ( 
531,"<S2SV_StartBug> rb_define_method ( req_class , ""rack_version"" , rack_version , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> rack_version_val = rb_str_new_cstr ( ""rack.version"" ) ; rb_gc_register_address ( & rack_version_val ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""remote_addr"" , remote_addr , 0 ) ; rb_define_method ( req_class , <S2SV_ModStart> ) ; remote_addr_val = rb_str_new_cstr ( ""REMOTE_ADDR"" ) ; rb_gc_register_address ( & remote_addr_val "
532,"<S2SV_StartBug> static void calc_segtree_probs ( int * segcounts , vp9_prob * segment_tree_probs ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_prob <S2SV_ModEnd> 
533,"<S2SV_StartBug> opt = xchg ( & np -> opt , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> <S2SV_StartBug> opt = ipv6_renew_options ( sk , np -> opt , optname , <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> <S2SV_StartBug> opt -> tot_len = sizeof ( * opt ) + optlen ; <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> ","<S2SV_ModStart> ( __force struct ipv6_txoptions * * ) <S2SV_ModStart> { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> <S2SV_ModStart> rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; opt = <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> <S2SV_ModStart> atomic_set ( & opt -> refcnt , 1 ) ; <S2SV_ModStart> { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> "
534,"<S2SV_StartBug> JSObjectRef globalobject ; <S2SV_EndBug> <S2SV_StartBug> globalobject = JSContextGetGlobalObject ( context ) ; <S2SV_EndBug> <S2SV_StartBug> JSObjectDeleteProperty ( context , globalobject , var_name , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
535,"<S2SV_StartBug> const int zbin = cpi -> zbin_mode_boost + x -> act_zbin_adj ; <S2SV_EndBug> <S2SV_StartBug> x -> plane [ 0 ] . quant_shift = quants -> y_quant_shift [ qindex ] ; <S2SV_EndBug> <S2SV_StartBug> x -> plane [ 0 ] . zbin_extra = ( int16_t ) ( ( cm -> y_dequant [ qindex ] [ 1 ] * zbin ) >> 7 ) ; <S2SV_EndBug> <S2SV_StartBug> x -> plane [ i ] . quant_shift = quants -> uv_quant_shift [ qindex ] ; <S2SV_EndBug> <S2SV_StartBug> x -> plane [ i ] . zbin_extra = ( int16_t ) ( ( cm -> uv_dequant [ qindex ] [ 1 ] * zbin ) >> 7 ) ; <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_ALPHA <S2SV_EndBug> <S2SV_StartBug> x -> skip_block = vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_initialize_me_consts ( cpi , x -> q_index ) ; <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> quant_fp = quants -> y_quant_fp [ qindex ] ; x -> plane [ 0 ] . round_fp = quants -> y_round_fp [ qindex ] ; x -> plane [ 0 ] . <S2SV_ModStart> xd -> plane [ 0 ] . dequant = cpi <S2SV_ModEnd> <S2SV_ModStart> ; x -> plane [ 0 ] . quant_thred [ 0 ] = x -> plane [ 0 ] . zbin [ 0 ] * x -> plane [ 0 ] . zbin [ 0 ] ; x -> plane [ 0 ] . quant_thred [ 1 ] = x -> plane [ 0 ] . zbin [ 1 ] * x -> plane [ 0 ] . zbin [ 1 <S2SV_ModEnd> <S2SV_ModStart> quant_fp = quants -> uv_quant_fp [ qindex ] ; x -> plane [ i ] . round_fp = quants -> uv_round_fp [ qindex ] ; x -> plane [ i ] . <S2SV_ModStart> xd -> plane [ i ] . dequant = cpi <S2SV_ModEnd> <S2SV_ModStart> ; x -> plane [ i ] . quant_thred [ 0 ] = x -> plane [ i ] . zbin [ 0 ] * x -> plane [ i ] . zbin [ 0 ] ; x -> plane [ i ] . quant_thred [ 1 ] = x -> plane [ i ] . zbin [ 1 ] * x -> plane [ i ] . zbin [ 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> segfeature_active <S2SV_ModEnd> <S2SV_ModStart> , x "
536,<S2SV_StartBug> if ( label_exec ( opt_exec_label ) == - 1 ) <S2SV_EndBug> ,"<S2SV_ModStart> setsid ( ) == ( pid_t ) - 1 ) die_with_error ( ""setsid"" ) ; if ( "
537,<S2SV_StartBug> same_page : <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( page_count ( page ) <= 0 ) ) { if ( pages ) { spin_unlock ( ptl ) ; remainder = 0 ; err = - ENOMEM ; break ; } } 
538,<S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> oxcf -> tuning = vp8_cfg . tuning ; <S2SV_EndBug> ,<S2SV_ModStart> else ( void ) mr_cfg ; # <S2SV_ModStart> ; oxcf -> screen_content_mode = vp8_cfg . screen_content_mode 
539,<S2SV_StartBug> usleep ( us_delay ) ; <S2SV_EndBug> ,<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
540,<S2SV_StartBug> if ( ctx -> pbi ) { <S2SV_EndBug> <S2SV_StartBug> ctx -> pbi = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> frame_workers != NULL ) { int i ; for ( i = 0 ; i < ctx -> num_frame_workers ; ++ i ) { VPxWorker * const worker = & ctx -> frame_workers [ i ] ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; vpx_get_worker_interface ( ) -> end ( worker ) ; vp9_remove_common ( & frame_worker_data -> pbi -> common ) ; # if CONFIG_VP9_POSTPROC vp9_free_postproc_buffers ( & frame_worker_data -> pbi -> common ) ; # endif vp9_decoder_remove ( frame_worker_data <S2SV_ModEnd> <S2SV_ModStart> vpx_free ( frame_worker_data -> scratch_buffer ) ; # if CONFIG_MULTITHREAD pthread_mutex_destroy ( & frame_worker_data -> stats_mutex ) ; pthread_cond_destroy ( & frame_worker_data -> stats_cond ) ; # endif vpx_free ( frame_worker_data ) ; } # if CONFIG_MULTITHREAD pthread_mutex_destroy ( & ctx -> buffer_pool -> pool_mutex ) ; # endif } if ( ctx -> buffer_pool ) { vp9_free_ref_frame_buffers ( ctx -> buffer_pool ) ; vp9_free_internal_frame_buffers ( & ctx -> buffer_pool -> int_frame_buffers ) ; } vpx_free ( ctx -> frame_workers ) ; vpx_free ( ctx -> buffer_pool ) ; <S2SV_ModEnd> 
541,"<S2SV_StartBug> c_t = tvb_get_bits8 ( tvb , tb_bit_off , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> macinf -> lchid [ j + chan ] = c_t + 1 ; <S2SV_EndBug> <S2SV_StartBug> macinf -> content [ j + chan ] = lchId_type_table [ c_t + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> rlcinf -> mode [ j + chan ] = lchId_rlc_map [ c_t + 1 ] ; <S2SV_EndBug> ",<S2SV_ModStart> ( <S2SV_ModStart> + 1 ) % 0xf <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
542,<S2SV_StartBug> if ( setuid ( current_user . uid ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( setgid ( current_user . gid ) < 0 ) <S2SV_EndBug> ,"<S2SV_ModStart> # if HAVE_DECL_SETRESUID if ( setresuid ( current_user . uid , current_user . uid , current_user . uid ) < 0 ) # else <S2SV_ModStart> # endif <S2SV_ModStart> # if HAVE_DECL_SETRESGID if ( setresgid ( current_user . gid , current_user . gid , current_user . gid ) < 0 ) # else <S2SV_ModStart> # endif "
543,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ret = key_read_state ( key ) ; if ( ret < 0 ) goto error2 ; <S2SV_ModEnd> 
544,<S2SV_StartBug> int copy = output_size - count ; <S2SV_EndBug> <S2SV_StartBug> if ( avail < copy ) copy = avail ; <S2SV_EndBug> ,<S2SV_ModStart> png_size_t <S2SV_ModEnd> <S2SV_ModStart> ( png_size_t ) <S2SV_ModStart> ( png_size_t ) 
545,"<S2SV_StartBug> pi -> xstep = pi -> picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn + <S2SV_EndBug> <S2SV_StartBug> pi -> ystep = pi -> picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn + <S2SV_EndBug> <S2SV_StartBug> pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( 1 << <S2SV_EndBug> <S2SV_StartBug> pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( 1 << <S2SV_EndBug> ","<S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> <S2SV_ModStart> ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> <S2SV_ModStart> ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> "
546,"<S2SV_StartBug> struct keydata * keyptr ; <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = half_md4_transform ( hash , keyptr -> secret ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> unsigned int ret <S2SV_ModEnd> <S2SV_ModStart> md5_transform <S2SV_ModEnd> <S2SV_ModStart> random_int_secret ) ; ret = hash [ 0 ] <S2SV_ModEnd> 
547,"<S2SV_StartBug> if ( using_compacted_format ( ) ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> err = __copy_from_user ( & fpu -> state . xsave , buf_fx , state_size ) ; <S2SV_EndBug> ","<S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> if ( ! err && state_size > offsetof ( struct xregs_state , header ) && fpu -> state . xsave . header . xcomp_bv ) err = - EINVAL ; } "
548,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> horAcc32 ( tif , cp0 , cc ) ; <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return 
549,<S2SV_StartBug> if ( c -> chunk_size == 0 ) <S2SV_EndBug> <S2SV_StartBug> else { <S2SV_EndBug> ,<S2SV_ModStart> <= 0 ) { c -> chunk_size = 0 ; goto fail ; } <S2SV_ModEnd> <S2SV_ModStart> av_assert0 ( len <= c -> chunk_size ) ; 
550,<S2SV_StartBug> u16 source_node_id ; <S2SV_EndBug> <S2SV_StartBug> specifier_id = ( be32_to_cpu ( buf_ptr [ 0 ] ) & 0xffff ) << 8 <S2SV_EndBug> <S2SV_StartBug> ( ver == RFC2734_SW_VERSION <S2SV_EndBug> <S2SV_StartBug> || ver == RFC3146_SW_VERSION <S2SV_EndBug> <S2SV_StartBug> ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( length > IEEE1394_GASP_HDR_SIZE && gasp_specifier_id ( buf_ptr ) <S2SV_ModEnd> <S2SV_ModStart> gasp_version ( buf_ptr ) <S2SV_ModEnd> <S2SV_ModStart> gasp_version ( buf_ptr ) <S2SV_ModEnd> <S2SV_ModStart> fwnet_incoming_packet ( dev , buf_ptr + 2 , length - IEEE1394_GASP_HDR_SIZE , gasp_source_id ( buf_ptr ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
551,<S2SV_StartBug> sc = create_spnego_ctx ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> 0 
552,<S2SV_StartBug> len -= EVP_GCM_TLS_EXPLICIT_IV_LEN ; <S2SV_EndBug> <S2SV_StartBug> if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) <S2SV_EndBug> <S2SV_StartBug> len -= EVP_GCM_TLS_TAG_LEN ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len < EVP_GCM_TLS_EXPLICIT_IV_LEN ) return 0 ; <S2SV_ModStart> { if ( len < EVP_GCM_TLS_TAG_LEN ) return 0 ; <S2SV_ModStart> } 
553,"<S2SV_StartBug> int r , len , group = 0 ; <S2SV_EndBug> <S2SV_StartBug> Node * * tp ; <S2SV_EndBug> <S2SV_StartBug> goto end_of_token ; <S2SV_EndBug> <S2SV_StartBug> qn = node_new_quantifier ( tok -> u . repeat . lower , tok -> u . repeat . upper , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; unsigned int parse_depth ; group = 0 <S2SV_ModStart> ; parse_depth = env -> parse_depth <S2SV_ModStart> parse_depth ++ ; if ( parse_depth > ParseDepthLimit ) return ONIGERR_PARSE_DEPTH_LIMIT_OVER ; 
554,"<S2SV_StartBug> const int length , const char check_utf8 , const char check_dot , <S2SV_EndBug> <S2SV_StartBug> int position = 0 ; <S2SV_EndBug> ",<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> 
555,"<S2SV_StartBug> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , <S2SV_EndBug> <S2SV_StartBug> Min ( 4 , dds_info -> height - y ) , exception ) ; <S2SV_EndBug> <S2SV_StartBug> SkipDXTMipmaps ( image , dds_info , 16 ) ; <S2SV_EndBug> ","<S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> return ( <S2SV_ModStart> , exception ) ) <S2SV_ModEnd> "
556,<S2SV_StartBug> if ( getCcalls ( L ) <= CSTACKERR ) <S2SV_EndBug> <S2SV_StartBug> luaE_freeCI ( L ) ; <S2SV_EndBug> ,<S2SV_ModStart> { luaE_exitCcall <S2SV_ModEnd> <S2SV_ModStart> luaE_enterCcall ( L ) ; } 
557,"<S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_DESTRUCT ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
558,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""tell<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""at<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""for<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""who-has<S2SV_blank>"" ) ) ; atmarp_tpaddr_print ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank>tell<S2SV_blank>"" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> atmarp_spaddr_print ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>is-at<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ""at<S2SV_blank>"" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> ""for<S2SV_blank>"" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> "
559,"<S2SV_StartBug> h -> emptyStreamBools = calloc ( ( size_t ) zip -> numFiles , <S2SV_EndBug> <S2SV_StartBug> h -> emptyFileBools = calloc ( empty_streams , <S2SV_EndBug> <S2SV_StartBug> h -> antiBools = calloc ( empty_streams , <S2SV_EndBug> <S2SV_StartBug> if ( ( ll & 1 ) || ll < zip -> numFiles * 4 ) <S2SV_EndBug> <S2SV_StartBug> h -> attrBools = calloc ( ( size_t ) zip -> numFiles , <S2SV_EndBug> ",<S2SV_ModStart> if ( h -> emptyStreamBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> if ( h -> emptyFileBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> if ( h -> antiBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> ) return ( - 1 ) ; if ( zip -> entry_names != NULL <S2SV_ModStart> if ( h -> attrBools != NULL ) return ( - 1 ) ; 
560,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> av_assert1 ( avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ; <S2SV_EndBug> ,<S2SV_ModStart> MpegEncContext * s = avctx -> priv_data ; <S2SV_ModStart> s -> studio_profile <S2SV_ModEnd> 
561,<S2SV_StartBug> len = file ? file -> size : 4096 ; <S2SV_EndBug> ,<S2SV_ModStart> && file -> size > 0 
562,"<S2SV_StartBug> if ( data_sz <= 8 ) <S2SV_EndBug> <S2SV_StartBug> struct vp9_read_bit_buffer rb = { data , data + data_sz , 0 , NULL , NULL } ; <S2SV_EndBug> ","<S2SV_ModStart> return decoder_peek_si_internal ( data , data_sz , si <S2SV_ModEnd> <S2SV_ModStart> , NULL ) <S2SV_ModEnd> "
563,<S2SV_StartBug> vstart += entry -> vn_aux ; <S2SV_EndBug> ,<S2SV_ModStart> st32 vnaux = entry -> vn_aux ; if ( vnaux < 1 ) { goto beach ; } vstart += vnaux <S2SV_ModEnd> 
564,<S2SV_StartBug> return code ; <S2SV_EndBug> ,"<S2SV_ModStart> { * status = ""DECODE_PA_FOR_USER"" ; return code ; } <S2SV_ModEnd> "
565,"<S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
566,<S2SV_StartBug> if ( pSubSrc -> nSrc > 1 || isAgg || IsVirtual ( pSubSrc -> a [ 0 ] . pTab ) ) { <S2SV_EndBug> ,<S2SV_ModStart> || ( p -> selFlags & SF_Distinct ) != 0 
567,"<S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , best_predictor , 16 * 4 ) ; <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , short , best_dqcoeff , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( best_dqcoeff , b -> dqcoeff , 32 ) ; <S2SV_EndBug> ",<S2SV_ModStart> DECLARE_ALIGNED <S2SV_ModEnd> <S2SV_ModStart> [ <S2SV_ModEnd> <S2SV_ModStart> ] ) ; DECLARE_ALIGNED <S2SV_ModEnd> <S2SV_ModStart> [ 16 ] <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
568,<S2SV_StartBug> struct pipe_buffer * buf ; <S2SV_EndBug> <S2SV_StartBug> orig_sz = size ; <S2SV_EndBug> <S2SV_StartBug> if ( off ) <S2SV_EndBug> <S2SV_StartBug> size += off - pipe -> bufs [ idx ] . offset ; <S2SV_EndBug> <S2SV_StartBug> if ( size <= buf -> len ) <S2SV_EndBug> <S2SV_StartBug> size -= buf -> len ; <S2SV_EndBug> <S2SV_StartBug> buf -> len = size ; <S2SV_EndBug> <S2SV_StartBug> off = i -> iov_offset = buf -> offset + size ; <S2SV_EndBug> <S2SV_StartBug> i -> count -= orig_sz ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> struct pipe_buffer * buf ; size_t off = i -> iov_offset , left = size ; int idx = i -> idx ; <S2SV_ModStart> left <S2SV_ModEnd> <S2SV_ModStart> left <S2SV_ModEnd> <S2SV_ModStart> left <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> left ; <S2SV_ModEnd> <S2SV_ModStart> size ; pipe_truncate ( i ) <S2SV_ModEnd> "
569,"<S2SV_StartBug> PyObject * logical = NULL ; <S2SV_EndBug> <S2SV_StartBug> FriBidiParType base = FRIBIDI_TYPE_RTL ; <S2SV_EndBug> <S2SV_StartBug> { ""logical"" , ""base_direction"" , ""encoding"" , ""clean"" , ""reordernsm"" , NULL } ; <S2SV_EndBug> <S2SV_StartBug> if ( ! PyArg_ParseTupleAndKeywords ( args , kw , ""O|isii"" , kwargs , <S2SV_EndBug> <S2SV_StartBug> & logical , & base , & encoding , & clean , & reordernsm ) ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON ) ) <S2SV_EndBug> <S2SV_StartBug> if ( PyUnicode_Check ( logical ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( PyString_Check ( logical ) ) <S2SV_EndBug> ","<S2SV_ModStart> PyUnicodeObject <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""U|iii"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } return unicode_log2vis <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
570,<S2SV_StartBug> wp -> socket_mode = 0666 ; <S2SV_EndBug> ,<S2SV_ModStart> 0660 <S2SV_ModEnd> 
571,<S2SV_StartBug> i1_is_end_of_poc = 0 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> 1 ; <S2SV_ModEnd> <S2SV_ModStart> if ( ps_dec -> u4_first_slice_in_pic != 2 ) { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ; <S2SV_ModEnd> "
572,<S2SV_StartBug> H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ; <S2SV_EndBug> ,<S2SV_ModStart> ps_dec -> u4_first_slice_in_pic = 0 ; 
573,<S2SV_StartBug> if ( g -> sect <= 0 || <S2SV_EndBug> <S2SV_StartBug> g -> head <= 0 || <S2SV_EndBug> ,<S2SV_ModStart> ( int ) <S2SV_ModStart> ( int ) <S2SV_ModStart> <= 0 || ( int ) ( g -> sect * g -> head ) 
574,"<S2SV_StartBug> u64 base_addr , size ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( get_securelevel ( ) > 0 ) return - EPERM 
575,"<S2SV_StartBug> if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ; <S2SV_EndBug> <S2SV_StartBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_default , <S2SV_EndBug> <S2SV_StartBug> out_drop_write : <S2SV_EndBug> ","<S2SV_ModStart> error = fh_want_write ( fh ) ; if ( error ) <S2SV_ModEnd> <S2SV_ModStart> fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( error ) goto out_drop_lock ; fh_unlock ( fh ) <S2SV_ModEnd> <S2SV_ModStart> out_drop_lock : fh_unlock ( fh ) ; <S2SV_ModEnd> "
576,<S2SV_StartBug> dev -> netdev_ops = & bnep_netdev_ops ; <S2SV_EndBug> ,<S2SV_ModStart> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> 
577,"<S2SV_StartBug> uint32_t authResult = 0 , reasonLen = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ReadFromRFBServer ( client , ( char * ) & reasonLen , 4 ) ) return FALSE ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ReadReason ( client <S2SV_ModEnd> 
578,<S2SV_StartBug> m -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
579,"<S2SV_StartBug> cJSON * cJSON_CreateIntArray ( int64_t * numbers , int count ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; a && i < count ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> n = cJSON_CreateInt ( numbers [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! i ) <S2SV_EndBug> ",<S2SV_ModStart> const int <S2SV_ModEnd> <S2SV_ModStart> i ++ <S2SV_ModEnd> <S2SV_ModStart> cJSON_CreateNumber <S2SV_ModEnd> <S2SV_ModStart> if ( ! n ) { cJSON_Delete ( a ) ; return 0 ; } 
580,<S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , true "
581,<S2SV_StartBug> bitmap -> compressed = FALSE ; <S2SV_EndBug> <S2SV_StartBug> bitmap -> length = DstWidth * DstHeight * GetBytesPerPixel ( bitmap -> format ) ; <S2SV_EndBug> ,<S2SV_ModStart> UINT32 size = DstWidth * DstHeight ; <S2SV_ModStart> if ( ( GetBytesPerPixel ( bitmap -> format ) == 0 ) || ( DstWidth == 0 ) || ( DstHeight == 0 ) || ( DstWidth > UINT32_MAX / DstHeight ) || ( size > ( UINT32_MAX / GetBytesPerPixel ( bitmap -> format ) ) ) ) return FALSE ; size *= GetBytesPerPixel ( bitmap -> format ) ; <S2SV_ModStart> size <S2SV_ModEnd> 
582,<S2SV_StartBug> devc -> voc [ voice ] . panning = value ; <S2SV_EndBug> ,<S2SV_ModStart> if ( voice < 0 || voice >= devc -> nr_voice ) return ; 
583,<S2SV_StartBug> if ( server . vm_enabled && listLength ( server . io_ready_clients ) ) { <S2SV_EndBug> <S2SV_StartBug> server . vm_blocked_clients -- ; <S2SV_EndBug> ,<S2SV_ModStart> ds_enabled <S2SV_ModEnd> <S2SV_ModStart> cache_blocked_clients <S2SV_ModEnd> 
584,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , sfar ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
585,<S2SV_StartBug> while ( entries -- ) <S2SV_EndBug> ,<S2SV_ModStart> # ifdef LIBRAW_LIBRARY_BUILD imgdata . process_warnings |= LIBRAW_WARN_PARSEFUJI_PROCESSED ; # endif 
586,<S2SV_StartBug> int Q = cpi -> active_worst_quality ; <S2SV_EndBug> ,<S2SV_ModStart> if ( cpi -> force_maxqp == 1 ) { cpi -> active_worst_quality = cpi -> worst_quality ; return cpi -> worst_quality ; } 
587,<S2SV_StartBug> f = po -> fanout ; <S2SV_EndBug> <S2SV_StartBug> if ( ! f ) <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & fanout_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & fanout_mutex ) ; <S2SV_ModStart> f ) { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & fanout_mutex ) ; } 
588,"<S2SV_StartBug> void vp9_predict_intra_block ( const MACROBLOCKD * xd , int block_idx , int bwl_in , <S2SV_EndBug> <S2SV_StartBug> TX_SIZE tx_size , MB_PREDICTION_MODE mode , <S2SV_EndBug> <S2SV_StartBug> const int bwl = bwl_in - tx_size ; <S2SV_EndBug> <S2SV_StartBug> const int wmask = ( 1 << bwl ) - 1 ; <S2SV_EndBug> <S2SV_StartBug> const int have_top = ( block_idx >> bwl ) || xd -> up_available ; <S2SV_EndBug> <S2SV_StartBug> const int have_left = ( block_idx & wmask ) || xd -> left_available ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> bw <S2SV_ModEnd> <S2SV_ModStart> bwl_in ) ; const int txw = ( 1 << tx_size ) <S2SV_ModEnd> <S2SV_ModStart> loff <S2SV_ModEnd> <S2SV_ModStart> aoff || xd -> left_available ; const int have_right = ( aoff + txw ) < bw ; const int x = aoff * 4 ; const int y = loff * 4 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { build_intra_predictors_high ( xd , ref , ref_stride , dst , dst_stride , mode , tx_size , have_top , have_left , have_right , x , y , plane , xd -> bd ) ; return ; } # endif <S2SV_ModEnd> "
589,"<S2SV_StartBug> z . kind = 0 ; <S2SV_EndBug> <S2SV_StartBug> # define PARSE_STRING s = parse_field ( ndo , & parse , & parselen ) ; if ( ! s ) lose = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( lose ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int truncated = 0 ; <S2SV_ModStart> , & truncated ) ; if ( truncated ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> return ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|zephyr]<S2SV_blank>(%d)"" , length ) ) ; return ; "
590,"<S2SV_StartBug> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <S2SV_EndBug> ",<S2SV_ModStart> HeapOverflowSanityCheck <S2SV_ModEnd> 
591,"<S2SV_StartBug> ( void ) CopyMagickMemory ( clone_info -> magick , magic_info -> name , MagickPathExtent ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> 
592,<S2SV_StartBug> for ( i = 0 ; i < len ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) { <S2SV_EndBug> <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> ,"<S2SV_ModStart> && j < sizeof ( szLineConv ) - 1 ; i ++ , j <S2SV_ModEnd> <S2SV_ModStart> if ( j + 1 < sizeof ( szLineConv ) - 1 ) { <S2SV_ModStart> break ; } else <S2SV_ModStart> if ( j + 1 < sizeof ( szLineConv ) - 1 && i + 1 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> <S2SV_ModStart> if ( j + 2 < sizeof ( szLineConv ) - 1 && i + 2 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> <S2SV_ModStart> if ( j + 3 < sizeof ( szLineConv ) - 1 && i + 3 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> <S2SV_ModStart> if ( j < sizeof ( szLineConv ) - 1 && i < len ) szLineConv [ j ] = szLine [ i ] ; } if ( j >= sizeof ( szLineConv ) ) szLineConv [ sizeof ( szLineConv ) - 1 ] = 0 ; else <S2SV_ModEnd> "
593,"<S2SV_StartBug> void rdp_read_flow_control_pdu ( wStream * s , UINT16 * type ) <S2SV_EndBug> <S2SV_StartBug> UINT8 pduType ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! type ) return FALSE ; if ( Stream_GetRemainingLength ( s ) < 6 ) return FALSE <S2SV_ModStart> return TRUE ; 
594,"<S2SV_StartBug> ikev1_attr_print ( netdissect_options * ndo , const u_char * p , const u_char * ep ) <S2SV_EndBug> <S2SV_StartBug> if ( p [ 0 ] & 0x80 ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> if ( ep < p + totlen ) { <S2SV_EndBug> <S2SV_StartBug> return ep + 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , EXTRACT_16BITS ( & p [ 2 ] ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , EXTRACT_16BITS ( & p [ 2 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> return p + totlen ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ep2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <S2SV_ModStart> } if ( ep2 <S2SV_ModEnd> <S2SV_ModStart> ep2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( & p [ 0 ] ) ; <S2SV_ModStart> if ( ! <S2SV_ModStart> ) { ND_PRINT ( ( ndo , "")"" ) ) ; goto trunc ; } <S2SV_ModEnd> <S2SV_ModStart> totlen - 4 ) ) ; if ( ! <S2SV_ModEnd> <S2SV_ModStart> totlen - 4 ) ) { <S2SV_ModEnd> <S2SV_ModStart> goto trunc ; } } ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_ModStart> trunc : return NULL ; "
595,<S2SV_StartBug> uchar buf [ 2 ] ; <S2SV_EndBug> ,<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
596,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> args -> rmtvaluelen = args -> valuelen ; 
597,<S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
598,<S2SV_StartBug> while ( bin ) <S2SV_EndBug> <S2SV_StartBug> numones -= 1 ; <S2SV_EndBug> ,<S2SV_ModStart> && ( numones <= 16 ) <S2SV_ModStart>  <S2SV_ModEnd> 
599,"<S2SV_StartBug> COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! COM_CompareExtension ( filename , "".txt"" ) ) { Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".txt\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" ) ; return ; } "
600,"<S2SV_StartBug> unsigned_relts_print ( ndo , EXTRACT_16BITS ( bp ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""0x%08x"" , EXTRACT_32BITS ( bp ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""v%d"" , * bp ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>?0x%04x?"" , EXTRACT_16BITS ( bp + 2 ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( olen != 2 ) { ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>2<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ; } else { <S2SV_ModStart> } <S2SV_ModStart> if ( olen != 4 ) { ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ; } else { <S2SV_ModStart> } <S2SV_ModStart> if ( olen != 4 ) { ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ; } else { <S2SV_ModStart> } "
601,<S2SV_StartBug> return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( node -> nd_item . ci_parent ) <S2SV_ModStart> else return NULL ; 
602,<S2SV_StartBug> int64_t cur_offset = avio_tell ( pb ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( par -> codec_type == AVMEDIA_TYPE_AUDIO && ! pkt -> size ) { av_log ( s , AV_LOG_WARNING , ""Empty<S2SV_blank>audio<S2SV_blank>Packet\\n"" ) ; return AVERROR ( EINVAL ) ; } "
603,<S2SV_StartBug> if ( count >= 4 ) { <S2SV_EndBug> ,<S2SV_ModStart> > <S2SV_ModEnd> 
604,<S2SV_StartBug> } else { <S2SV_EndBug> ,"<S2SV_ModStart> { uint8_t computedHvi [ 32 ] ; uint16_t HelloMessageLength = zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength ; uint16_t DHPartHelloMessageStringLength = zrtpPacket -> messageLength + HelloMessageLength ; uint8_t * DHPartHelloMessageString = ( uint8_t * ) malloc ( DHPartHelloMessageStringLength * sizeof ( uint8_t ) ) ; memcpy ( DHPartHelloMessageString , input + ZRTP_PACKET_HEADER_LENGTH , zrtpPacket -> messageLength ) ; memcpy ( DHPartHelloMessageString + zrtpPacket -> messageLength , zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , HelloMessageLength ) ; zrtpChannelContext -> hashFunction ( DHPartHelloMessageString , DHPartHelloMessageStringLength , 32 , computedHvi ) ; free ( DHPartHelloMessageString ) ; if ( memcmp ( computedHvi , peerCommitMessageData -> hvi , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHVI ; } } "
605,"<S2SV_StartBug> ep = ( const u_char * ) ndo -> ndo_snapend ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK ( pim -> pim_rsv ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>RFC2117-encoding"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( PIM_TYPE ( pim -> pim_typever ) ) { <S2SV_EndBug> <S2SV_StartBug> bp += 4 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , 4 + olen ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ptr < ( bp + olen ) ) { <S2SV_EndBug> <S2SV_StartBug> advance = pimv2_addr_print ( ndo , ptr , pimv2_unicast , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> bp += olen ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( bp + 4 ) , PIMV2_REGISTER_FLAG_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> EXTRACT_32BITS ( bp + 4 ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> bp += 8 ; len -= 8 ; <S2SV_EndBug> <S2SV_StartBug> switch ( IP_V ( ip ) ) { <S2SV_EndBug> <S2SV_StartBug> case 0 : <S2SV_EndBug> <S2SV_StartBug> bp += 4 ; len -= 4 ; <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> int i , j ; <S2SV_EndBug> <S2SV_StartBug> if ( bp >= ep ) <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( bp + 4 > ep ) <S2SV_EndBug> <S2SV_StartBug> if ( bp >= ep ) <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( bp + 4 > ep ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_source , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_source , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> jp_done : <S2SV_EndBug> <S2SV_StartBug> bp += 4 ; <S2SV_EndBug> <S2SV_StartBug> if ( bp + 1 >= ep ) break ; <S2SV_EndBug> <S2SV_StartBug> if ( bp >= ep ) break ; <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( bp >= ep ) { <S2SV_EndBug> <S2SV_StartBug> if ( bp + 1 >= ep ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>FRPcnt=%d"" , frpcnt = bp [ 1 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> bp += 4 ; <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , <S2SV_EndBug> <S2SV_StartBug> if ( bp + 1 >= ep ) { <S2SV_EndBug> <S2SV_StartBug> if ( bp + 2 >= ep ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , "",prio=%d"" , bp [ 2 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> bs_done : <S2SV_EndBug> <S2SV_StartBug> bp += 4 ; len -= 4 ; <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( bp >= ep ) <S2SV_EndBug> <S2SV_StartBug> bp += 4 ; <S2SV_EndBug> <S2SV_StartBug> if ( bp + 1 >= ep ) break ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>prio=%d"" , bp [ 1 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 2 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bp >= ep ) break ; <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>grp="" ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>forwarder="" ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , 2 ) ; <S2SV_EndBug> ","<S2SV_ModStart> int pimv2_addr_len ; <S2SV_ModStart> if ( len < 2 ) goto trunc ; <S2SV_ModStart> ) ; if ( len < 4 ) goto trunc ; ND_TCHECK ( pim -> pim_cksum <S2SV_ModStart> bp += 4 ; len -= 4 ; <S2SV_ModStart> while ( len > 0 ) { if ( len < 4 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>Value:<S2SV_blank>"" , tok2str ( pimv2_hello_option_values , ""Unknown"" , otype ) , otype , olen ) ) ; bp += 4 ; len -= 4 ; if ( len < olen ) goto trunc ; <S2SV_ModStart> olen ) <S2SV_ModEnd> <S2SV_ModStart> u_int plen = len ; <S2SV_ModStart> plen , pimv2_unicast , pimv2_addr_len , 0 ) ; if ( advance < 0 ) goto trunc ; ptr += advance ; plen -= <S2SV_ModEnd> <S2SV_ModStart> olen ; len -= <S2SV_ModStart> if ( len < 4 ) goto trunc ; <S2SV_ModStart> bp <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 4 <S2SV_ModEnd> <S2SV_ModStart> 4 ; if ( len == 0 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( ip -> ip_vhl ) ; <S2SV_ModStart> ND_TCHECK ( ip -> ip_dst ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ""<S2SV_blank>group="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , len , pimv2_group , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; bp += advance <S2SV_ModEnd> <S2SV_ModStart> advance ; ND_PRINT ( ( ndo , ""<S2SV_blank>source="" <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> len < 4 ) goto trunc ; ND_TCHECK2 ( * bp , 4 ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> len , pimv2_group , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> len < 4 ) goto trunc ; ND_TCHECK2 ( * bp , 4 ) ; <S2SV_ModEnd> <S2SV_ModStart> len , pimv2_source , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> len , pimv2_source , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( len < 2 ) goto trunc ; ND_TCHECK_16BITS ( bp ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>tag=%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; if ( len < 1 ) goto trunc ; ND_TCHECK ( bp [ 0 ] ) <S2SV_ModEnd> <S2SV_ModStart> len < 2 ) goto trunc ; ND_TCHECK ( bp [ 2 ] ) <S2SV_ModEnd> <S2SV_ModStart> len -= 2 <S2SV_ModEnd> <S2SV_ModStart> len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; bp += advance ; len -= <S2SV_ModEnd> <S2SV_ModStart> len , pimv2_group , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> len -= advance ; if ( len < 1 ) goto trunc ; ND_TCHECK ( bp [ 0 ] ) ; <S2SV_ModEnd> <S2SV_ModStart> len < 2 ) goto trunc ; ND_TCHECK ( <S2SV_ModEnd> <S2SV_ModStart> ; ND_PRINT ( ( ndo , ""<S2SV_blank>FRPcnt=%d"" , frpcnt = bp [ 1 ] ) ) ; if ( len < 4 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> 4 ; len -= <S2SV_ModStart> len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> len -= advance ; if ( len < 2 ) goto trunc ; ND_TCHECK_16BITS ( bp ) ; <S2SV_ModEnd> <S2SV_ModStart> len < 3 ) goto trunc ; ND_TCHECK ( <S2SV_ModEnd> <S2SV_ModStart> ; ND_PRINT ( ( ndo , "",prio=%d"" , bp [ 2 ] ) ) ; if ( len < 4 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> len -= 4 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""<S2SV_blank>group="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , len , pimv2_group , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; bp += advance <S2SV_ModEnd> <S2SV_ModStart> advance ; ND_PRINT ( ( ndo , ""<S2SV_blank>src="" <S2SV_ModEnd> <S2SV_ModStart> len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> len < 8 ) goto trunc ; ND_TCHECK2 ( * bp , 8 ) <S2SV_ModEnd> <S2SV_ModStart> if ( len < 1 ) goto trunc ; ND_TCHECK ( bp [ 0 ] ) <S2SV_ModEnd> <S2SV_ModStart> len < 2 ) goto trunc ; ND_TCHECK ( <S2SV_ModEnd> <S2SV_ModStart> ; ND_PRINT ( ( ndo , ""<S2SV_blank>prio=%d"" , bp [ 1 ] ) ) ; if ( len < 4 ) goto trunc ; ND_TCHECK_16BITS <S2SV_ModEnd> <S2SV_ModStart> ; ND_PRINT ( ( ndo , ""<S2SV_blank>holdtime="" ) ) ; unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 2 ] ) <S2SV_ModStart> len -= 4 <S2SV_ModEnd> <S2SV_ModStart> len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; bp += advance ; len -= <S2SV_ModEnd> <S2SV_ModStart> len , pimv2_group , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; bp += advance ; len -= <S2SV_ModEnd> <S2SV_ModStart> len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> len -= advance ; <S2SV_ModStart> len , pimv2_group , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> len -= advance ; <S2SV_ModStart> len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> len -= advance ; if ( len < 2 ) goto trunc ; ND_TCHECK_16BITS ( bp <S2SV_ModEnd> "
606,<S2SV_StartBug> if ( p -> selFlags & SF_UsesEphemeral ) { <S2SV_EndBug> ,<S2SV_ModStart> pParse -> nErr ) goto multi_select_end ; if ( 
607,<S2SV_StartBug> struct fscrypt_info * ci = inode -> i_crypt_info ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ci || <S2SV_EndBug> ,"<S2SV_ModStart> crypt_info ; struct fscrypt_context ctx ; struct crypto_skcipher * ctfm ; const char * cipher_str ; int keysize ; u8 * raw_key = NULL ; int res ; if ( <S2SV_ModEnd> <S2SV_ModStart> ) return 0 ; res = fscrypt_initialize ( inode -> i_sb -> s_cop -> flags ) ; if ( res ) return res <S2SV_ModStart> inode -> i_sb -> s_cop -> get_context ) return - EOPNOTSUPP ; res = inode -> i_sb -> s_cop -> get_context ( inode , & ctx , sizeof ( ctx ) ) ; if ( res < 0 ) { if ( ! fscrypt_dummy_context_enabled ( inode ) || inode -> i_sb -> s_cop -> is_encrypted ( inode ) ) return res ; memset ( & ctx , 0 , sizeof ( ctx ) ) ; ctx . format = FS_ENCRYPTION_CONTEXT_FORMAT_V1 ; ctx . contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS ; ctx . filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS ; memset ( ctx . master_key_descriptor , 0x42 , FS_KEY_DESCRIPTOR_SIZE ) ; } else if ( res != sizeof ( ctx ) ) { return - EINVAL ; } if ( ctx . format != FS_ENCRYPTION_CONTEXT_FORMAT_V1 ) return - EINVAL ; if ( ctx . flags & ~ FS_POLICY_FLAGS_VALID ) return - EINVAL ; crypt_info = kmem_cache_alloc ( fscrypt_info_cachep , GFP_NOFS ) ; if ( ! crypt_info ) return - ENOMEM ; crypt_info -> ci_flags = ctx . flags ; crypt_info -> ci_data_mode = ctx . contents_encryption_mode ; crypt_info -> ci_filename_mode = ctx . filenames_encryption_mode ; crypt_info -> ci_ctfm = NULL ; memcpy ( crypt_info -> ci_master_key , ctx . master_key_descriptor , sizeof ( crypt_info -> ci_master_key ) ) ; res = determine_cipher_type ( crypt_info , inode , & cipher_str , & keysize ) ; if ( res ) goto out ; res = - ENOMEM ; raw_key = kmalloc ( FS_MAX_KEY_SIZE , GFP_NOFS ) ; if ( ! raw_key ) goto out ; res = validate_user_key ( crypt_info , & ctx , raw_key , FS_KEY_DESC_PREFIX ) ; if ( res && inode -> i_sb -> s_cop -> key_prefix ) { int res2 = validate_user_key ( crypt_info , & ctx , raw_key , inode -> i_sb -> s_cop -> key_prefix ) ; if ( res2 ) { if ( res2 == - ENOKEY ) res = - ENOKEY ; goto out ; } } else if ( res ) { goto out ; } ctfm = crypto_alloc_skcipher ( cipher_str , 0 , 0 ) ; if ( ! ctfm || IS_ERR ( ctfm ) ) { res = ctfm ? PTR_ERR ( ctfm ) : - ENOMEM ; printk ( KERN_DEBUG ""%s:<S2SV_blank>error<S2SV_blank>%d<S2SV_blank>(inode<S2SV_blank>%u)<S2SV_blank>allocating<S2SV_blank>crypto<S2SV_blank>tfm\\n"" , __func__ , res , ( unsigned ) inode -> i_ino ) ; goto out ; } crypt_info -> ci_ctfm = ctfm ; crypto_skcipher_clear_flags ( ctfm , ~ 0 ) ; crypto_skcipher_set_flags ( ctfm , CRYPTO_TFM_REQ_WEAK_KEY ) ; res = crypto_skcipher_setkey ( ctfm , raw_key , keysize ) ; if ( res ) goto out ; if ( cmpxchg ( & inode -> i_crypt_info , NULL , crypt_info ) == NULL ) crypt_info = NULL ; out : if ( res == - ENOKEY ) res = 0 ; put_crypt_info ( crypt_info ) ; kzfree ( raw_key ) ; return res <S2SV_ModEnd> "
608,"<S2SV_StartBug> vp9_quantize_b ( BLOCK_OFFSET ( p -> coeff , block ) , <S2SV_EndBug> <S2SV_StartBug> pd -> dequant , p -> zbin_extra , & p -> eobs [ block ] , scan , iscan ) ; <S2SV_EndBug> ","<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vpx_highbd_quantize_b <S2SV_ModEnd> <S2SV_ModStart> & p -> eobs [ block ] , scan , iscan ) ; return ; } # endif vpx_quantize_b ( BLOCK_OFFSET ( p -> coeff , block ) , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , BLOCK_OFFSET ( p -> qcoeff , block ) , BLOCK_OFFSET ( pd -> dqcoeff , block ) , pd -> dequant <S2SV_ModEnd> "
609,<S2SV_StartBug> jumpstack [ stackidx ++ ] = e ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; } 
610,"<S2SV_StartBug> CRM_LOG_ASSERT ( client_obj -> request_id ) ; <S2SV_EndBug> <S2SV_StartBug> rid , client_obj -> name , from_peer ? ""(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)"" : """" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( client_obj -> ipc ) { <S2SV_ModStart> } else { crm_trace ( ""Sending<S2SV_blank>response<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s"" , client_obj -> name , from_peer ? ""(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)"" : """" ) ; } "
611,"<S2SV_StartBug> if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , <S2SV_EndBug> ","<S2SV_ModStart> p_total_data_size , "
612,<S2SV_StartBug> if ( NFCT_FRAG6_CB ( fp ) -> orig == NULL ) <S2SV_EndBug> ,<S2SV_ModStart> fp && 
613,<S2SV_StartBug> int i ; <S2SV_EndBug> ,"<S2SV_ModStart> ; account_pipe_buffers ( pipe , pipe -> buffers , 0 ) ; free_uid ( pipe -> user ) "
614,"<S2SV_StartBug> ""vm_enabled:%d\\r\\n"" <S2SV_EndBug> <S2SV_StartBug> server . vm_enabled != 0 , <S2SV_EndBug> <S2SV_StartBug> if ( server . vm_enabled ) { <S2SV_EndBug> <S2SV_StartBug> ""vm_conf_max_memory:%llu\\r\\n"" <S2SV_EndBug> <S2SV_StartBug> , ( unsigned long long ) server . vm_max_memory , <S2SV_EndBug> <S2SV_StartBug> ( unsigned long long ) server . vm_page_size , <S2SV_EndBug> ","<S2SV_ModStart> ""ds_enabled:%d\\r\\n"" <S2SV_ModEnd> <S2SV_ModStart> ds_enabled <S2SV_ModEnd> <S2SV_ModStart> ds_enabled <S2SV_ModEnd> <S2SV_ModStart> ""cache_max_memory:%llu\\r\\n"" ""cache_blocked_clients:%lu\\r\\n"" <S2SV_ModEnd> <S2SV_ModStart> cache_max_memory <S2SV_ModEnd> <S2SV_ModStart> ) server . cache_blocked_clients <S2SV_ModEnd> "
615,"<S2SV_StartBug> p = strchr ( context -> buffer , \'\\""\' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
616,"<S2SV_StartBug> void imap_quote_string ( char * dest , size_t dlen , const char * src ) <S2SV_EndBug> ","<S2SV_ModStart> , bool quote_backtick ) { const char * quote = ""`\\""\\\\"" ; if ( ! quote_backtick ) quote ++ <S2SV_ModEnd> "
617,<S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 2 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> . ptr [ <S2SV_ModEnd> <S2SV_ModStart> . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
618,<S2SV_StartBug> img -> bps = 12 ; <S2SV_EndBug> ,<S2SV_ModStart> bit_depth = 8 ; img -> 
619,<S2SV_StartBug> s = & pit_state -> channels [ addr ] ; <S2SV_EndBug> ,<S2SV_ModStart> if ( addr == 3 ) return 0 ; 
620,"<S2SV_StartBug> if ( kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ! dev_name || 
621,"<S2SV_StartBug> int i , n_items , end_lineno , end_col_offset ; <S2SV_EndBug> <S2SV_StartBug> REQ ( n , with_stmt ) ; <S2SV_EndBug> <S2SV_StartBug> n_items = ( NCH ( n ) - 2 ) / 2 ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 1 ; i < NCH ( n ) - 2 ; i += 2 ) { <S2SV_EndBug> <S2SV_StartBug> if ( is_async ) <S2SV_EndBug> <S2SV_StartBug> return AsyncWith ( items , body , LINENO ( n0 ) , n0 -> n_col_offset , <S2SV_EndBug> <S2SV_StartBug> return With ( items , body , LINENO ( n ) , n -> n_col_offset , <S2SV_EndBug> ","<S2SV_ModStart> nch_minus_type , has_type_comment , <S2SV_ModStart> string type_comment ; <S2SV_ModStart> has_type_comment = TYPE ( CHILD ( n , NCH ( n ) - 2 ) ) == TYPE_COMMENT ; nch_minus_type = NCH ( n ) - has_type_comment ; <S2SV_ModStart> nch_minus_type <S2SV_ModEnd> <S2SV_ModStart> nch_minus_type <S2SV_ModEnd> <S2SV_ModStart> has_type_comment ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , NCH ( n ) - 2 ) ) ; if ( ! type_comment ) return NULL ; } else type_comment = NULL ; if ( <S2SV_ModStart> type_comment , <S2SV_ModStart> , type_comment "
622,"<S2SV_StartBug> while ( * s && * s != \'\\""\' ) <S2SV_EndBug> <S2SV_StartBug> while ( isdigit ( ( unsigned char ) * s ) ) <S2SV_EndBug> ",<S2SV_ModStart> ( <S2SV_ModStart> ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) ) <S2SV_ModStart> ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) 
623,"<S2SV_StartBug> tlv = cp + i ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 4 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( i + 4 > length ) return - 1 ; <S2SV_ModStart> ; if ( i + 4 + optlen > length ) return - 1 
624,"<S2SV_StartBug> if ( ( gr -> gr_ctx . value = mem_alloc ( sizeof ( gss_union_ctx_id_desc ) ) ) == NULL ) { <S2SV_EndBug> <S2SV_StartBug> memcpy ( gr -> gr_ctx . value , gd -> ctx , sizeof ( gss_union_ctx_id_desc ) ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""xxxx"" ; <S2SV_ModEnd> <S2SV_ModStart> length = 4 <S2SV_ModEnd> "
625,"<S2SV_StartBug> s -> off = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> <S2SV_StartBug> s -> filesize = strtoll ( slash + 1 , NULL , 10 ) ; <S2SV_EndBug> ",<S2SV_ModStart> strtoull <S2SV_ModEnd> <S2SV_ModStart> strtoull <S2SV_ModEnd> 
626,"<S2SV_StartBug> ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> { quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_ModStart> } 
627,<S2SV_StartBug> const VP9_CONFIG * oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> optimal_buffer_level / 100 ) ; <S2SV_EndBug> ,<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> rc <S2SV_ModEnd> 
628,<S2SV_StartBug> register struct enamemem * tp ; <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_name ) <S2SV_EndBug> <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> <S2SV_StartBug> tp -> e_name = strdup ( buf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_name == NULL ) <S2SV_EndBug> <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> ,<S2SV_ModStart> bsnamemem <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> 
629,"<S2SV_StartBug> static int can_open_cached ( struct nfs4_state * state , int mode ) <S2SV_EndBug> <S2SV_StartBug> switch ( mode & ( FMODE_READ | FMODE_WRITE | O_EXCL ) ) { <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> fmode_t mode , int open_mode <S2SV_ModEnd> <S2SV_ModStart> if ( open_mode & O_EXCL ) goto out ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> out : "
630,<S2SV_StartBug> if ( src < ( uint8_t * ) buf || src > ( uint8_t * ) buf + buf_size ) <S2SV_EndBug> ,<S2SV_ModStart> + src_size < src || src + src_size 
631,<S2SV_StartBug> if ( * p == FAC_CCITT_DEST_NSAP ) { <S2SV_EndBug> ,<S2SV_ModStart> l < 10 || l > 20 ) return - 1 ; if ( 
632,<S2SV_StartBug> int nByte = sizeof ( * pWith ) + ( sizeof ( pWith -> a [ 1 ] ) * pWith -> nCte ) ; <S2SV_EndBug> ,<S2SV_ModStart> sqlite3_int64 <S2SV_ModEnd> 
633,<S2SV_StartBug> if ( len > count ) <S2SV_EndBug> ,<S2SV_ModStart> ( unsigned long ) len > ( unsigned long ) <S2SV_ModEnd> 
634,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , tstr <S2SV_ModEnd> "
635,"<S2SV_StartBug> cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ; <S2SV_EndBug> ",<S2SV_ModStart> nd -> last_type = LAST_BIND ; 
636,<S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> bail : free ( tmpbuf ) ; tmpbuf = NULL ; return - 1 ; 
637,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> ptr = cp [ 2 ] - 1 ; <S2SV_EndBug> <S2SV_StartBug> switch ( cp [ 3 ] & 0xF ) { <S2SV_EndBug> <S2SV_StartBug> type = ""<S2SV_blank>^<S2SV_blank>"" ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> ( 0 ) <S2SV_ModStart> ND_TCHECK ( cp [ 2 ] ) ; <S2SV_ModStart> ND_TCHECK ( cp [ 3 ] ) ; <S2SV_ModStart> ; ND_TCHECK2 ( cp [ len ] , hoplen ) <S2SV_ModStart> return ( 0 ) ; trunc : return ( - 1 ) ; "
638,<S2SV_StartBug> void impeg2d_dec_pnb_mb_params ( dec_state_t * ps_dec ) <S2SV_EndBug> <S2SV_StartBug> ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ; <S2SV_EndBug> <S2SV_StartBug> ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> WORD32 <S2SV_ModEnd> <S2SV_ModStart> if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ; <S2SV_ModStart> if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ; <S2SV_ModStart> return 0 ; 
639,<S2SV_StartBug> comics_document -> selected_command = <S2SV_EndBug> <S2SV_StartBug> comics_document -> selected_command = <S2SV_EndBug> <S2SV_StartBug> comics_document -> selected_command = <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } else <S2SV_ModEnd> 
640,"<S2SV_StartBug> static u32 ip6_idents_hashrnd __read_mostly ; <S2SV_EndBug> <S2SV_StartBug> id = __ipv6_select_ident ( net , ip6_idents_hashrnd , daddr , saddr ) ; <S2SV_EndBug> ",<S2SV_ModStart> u32 id <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
641,"<S2SV_StartBug> int mi_index = 0 ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 = cm -> mi_grid_visible ; <S2SV_EndBug> <S2SV_StartBug> print_mi_data ( cm , mvs , ""Skips:"" , offsetof ( MB_MODE_INFO , skip ) ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( mvs , ""V<S2SV_blank>"" ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( mvs , ""%4d:%4d<S2SV_blank>"" , mi_8x8 [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . row , <S2SV_EndBug> <S2SV_StartBug> mi_index += 8 ; <S2SV_EndBug> <S2SV_StartBug> fclose ( mvs ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> ""Ref<S2SV_blank>frame:"" , offsetof ( MB_MODE_INFO , ref_frame [ 0 ] ) ) ; print_mi_data ( cm , mvs , ""Transform:"" , offsetof ( MB_MODE_INFO , tx_size ) ) ; print_mi_data ( cm , mvs , ""UV<S2SV_blank>Modes:"" , offsetof ( MB_MODE_INFO , uv_mode ) ) ; log_frame_info ( cm , ""Skips:"" <S2SV_ModEnd> <S2SV_ModStart> ""S<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ""%2d<S2SV_blank>"" , mi [ 0 <S2SV_ModEnd> <S2SV_ModStart> skip ) ; mi <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> log_frame_info ( cm , ""Vectors<S2SV_blank>"" , mvs ) ; mi = cm -> mi_grid_visible ; for ( mi_row = 0 ; mi_row < rows ; mi_row ++ ) { fprintf ( mvs , ""V<S2SV_blank>"" ) ; for ( mi_col = 0 ; mi_col < cols ; mi_col ++ ) { fprintf ( mvs , ""%4d:%4d<S2SV_blank>"" , mi [ 0 ] -> mbmi . mv [ 0 ] . as_mv . row , mi [ 0 ] -> mbmi . mv [ 0 ] . as_mv . col ) ; mi ++ ; } fprintf ( mvs , ""\\n"" ) ; mi += 8 ; } fprintf ( mvs , ""\\n"" ) ; "
642,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( caught_signal ) <S2SV_EndBug> <S2SV_StartBug> sleep ( 2 ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , _ ( ""<S2SV_blank>...killed.\\n"" ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> child = ( pid_t ) - 1 ; <S2SV_ModStart> && child != ( pid_t ) - 1 <S2SV_ModStart> if ( child != ( pid_t ) - 1 ) { <S2SV_ModStart> } 
643,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( ! ret && xsave -> header . xcomp_bv ) ret = - EINVAL ; 
644,<S2SV_StartBug> return le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ; 
645,"<S2SV_StartBug> return udp_prot . setsockopt ( sk , level , optname , optval , optlen ) ; <S2SV_EndBug> ",<S2SV_ModStart> - EINVAL <S2SV_ModEnd> 
646,"<S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> found = cm -> width == cfg -> y_crop_width && <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> use_svc ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> width - 1 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> height - 1 , 16 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> use_svc && ( ( cpi -> svc . number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) || ( cpi -> svc . number_spatial_layers > 1 && cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] . is_key_frame ) || ( is_two_pass_svc ( cpi ) && cpi -> svc . encode_empty_frame_state == ENCODING && cpi -> svc . layer_context [ 0 ] . frames_from_key_frame < cpi -> svc . number_temporal_layers + 1 ) ) ) { found = 0 ; } else if ( cfg != NULL ) { <S2SV_ModStart> } vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> 
647,<S2SV_StartBug> BUG_IF ( tree_root == NULL ) ; <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> return 0 
648,<S2SV_StartBug> int err ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL 
649,"<S2SV_StartBug> VTermState * state = vterm_allocator_malloc ( vt , sizeof ( VTermState ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( state == NULL ) return NULL 
650,"<S2SV_StartBug> static int _nfs4_do_open ( struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred , struct nfs4_state * * res ) <S2SV_EndBug> <S2SV_StartBug> nfs4_return_incompatible_delegation ( path -> dentry -> d_inode , flags & ( FMODE_READ | FMODE_WRITE ) ) ; <S2SV_EndBug> <S2SV_StartBug> opendata = nfs4_opendata_alloc ( path , sp , flags , sattr ) ; <S2SV_EndBug> ","<S2SV_ModStart> fmode_t fmode , <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> , fmode "
651,<S2SV_StartBug> commonlen = COMPUTESIZE ( state . num ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( state . num > QUERYTYPEMAXITEMS ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>query<S2SV_blank>items<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , state . num , ( int ) QUERYTYPEMAXITEMS ) ) ) ; "
652,<S2SV_StartBug> while ( tmp && alen < tmp ) { <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK2 ( * tptr , alen ) ; "
653,<S2SV_StartBug> libettercap_init ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( write_output ( ) != E_SUCCESS ) <S2SV_EndBug> ,"<S2SV_ModStart> int ret_value = 0 ; <S2SV_ModStart> ret_value = <S2SV_ModEnd> <S2SV_ModStart> ; if ( ret_value == - E_NOTHANDLED ) FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correctly<S2SV_blank>handled."" , EF_GBL_OPTIONS -> output_file ) ; else if ( ret_value == - E_INVALID ) FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>format<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correct.<S2SV_blank>"" <S2SV_ModEnd> "
654,"<S2SV_StartBug> printf ( ""%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%u<S2SV_blank>sectors)\\n"" , fs -> fat_size , <S2SV_EndBug> <S2SV_StartBug> fs -> fat_size / lss ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%10lld<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%llu<S2SV_blank>sectors)\\n"" , ( long long ) <S2SV_ModEnd> <S2SV_ModStart> ( long long ) "
655,"<S2SV_StartBug> static void update_stats ( VP9_COMP * cpi ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! frame_is_intra_only ( cm ) ) { <S2SV_EndBug> <S2SV_StartBug> const int seg_ref_active = vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , <S2SV_EndBug> <S2SV_StartBug> FRAME_COUNTS * const counts = & cm -> counts ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> VP9_COMMON * cm , ThreadData * td ) { const MACROBLOCK * x = & td <S2SV_ModEnd> <S2SV_ModStart> const MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext ; const BLOCK_SIZE bsize = mbmi -> sb_type ; <S2SV_ModStart> FRAME_COUNTS * const counts = td -> counts ; const int inter_block = is_inter_block ( mbmi ) ; <S2SV_ModStart> segfeature_active <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( inter_block && ! segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) { const int mode_ctx = mbmi_ext -> mode_context [ mbmi -> ref_frame [ 0 ] ] ; if ( bsize >= BLOCK_8X8 ) { const PREDICTION_MODE mode = mbmi -> mode ; ++ counts -> inter_mode [ mode_ctx ] [ INTER_OFFSET ( mode ) ] ; } else { const int num_4x4_w = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ bsize ] ; int idx , idy ; for ( idy = 0 ; idy < 2 ; idy += num_4x4_h ) { for ( idx = 0 ; idx < 2 ; idx += num_4x4_w ) { const int j = idy * 2 + idx ; const PREDICTION_MODE b_mode = mi -> bmi [ j ] . as_mode ; ++ counts -> inter_mode [ mode_ctx ] [ INTER_OFFSET ( b_mode ) ] ; } } } } "
656,"<S2SV_StartBug> attach_shadowed ( mnt , parent , shadows ) ; <S2SV_EndBug> ",<S2SV_ModStart> n -> mounts += n -> pending_mounts ; n -> pending_mounts = 0 ; 
657,<S2SV_StartBug> const char * errstr ; <S2SV_EndBug> <S2SV_StartBug> # else <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> # if ! defined ( __linux__ ) && ! defined ( __NetBSD__ ) <S2SV_ModStart> = NULL ; # else int status ; # endif <S2SV_ModEnd> <S2SV_ModStart> if ( errstr ) return - 1 ; # else status = <S2SV_ModEnd> <S2SV_ModStart> if ( status != 1 <S2SV_ModEnd> <S2SV_ModStart> # endif 
658,"<S2SV_StartBug> SkipRGBMipmaps ( image , dds_info , 3 ) ; <S2SV_EndBug> ","<S2SV_ModStart> return ( <S2SV_ModStart> , exception ) ) <S2SV_ModEnd> "
659,"<S2SV_StartBug> void vp9_fht8x8_sse2 ( const int16_t * input , int16_t * output , <S2SV_EndBug> <S2SV_StartBug> vp9_fdct8x8_sse2 ( input , output , stride ) ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_fdct8x8_sse2 <S2SV_ModEnd> 
660,"<S2SV_StartBug> c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( c16 -> Curves [ i ] == NULL ) { for ( j = 0 ; j < i ; j ++ ) { _cmsFree ( ContextID , c16 -> Curves [ j ] ) ; } _cmsFree ( ContextID , c16 -> Curves ) ; _cmsFree ( ContextID , c16 ) ; return NULL ; } "
661,"<S2SV_StartBug> if ( osStrlen ( topicName ) == 2 && strchr ( topicName , '#' ) == NULL && <S2SV_EndBug> <S2SV_StartBug> strchr ( topicName , '+' ) == NULL ) <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> 
662,"<S2SV_StartBug> len = min_t ( unsigned int , len , sizeof ( sec ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> sec . key_size = 0 ; 
663,<S2SV_StartBug> if ( ! data ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> || len < 2 ) { <S2SV_ModEnd> <S2SV_ModStart> } 
664,"<S2SV_StartBug> struct strbuf * path , const char * component ) <S2SV_EndBug> <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name ) { const <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
665,"<S2SV_StartBug> size_t input_size , <S2SV_EndBug> <S2SV_StartBug> int max_bytes_matched = input_size ; <S2SV_EndBug> ","<S2SV_ModStart> input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> <S2SV_ModStart> ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? input_backwards_size : input_forwards_size <S2SV_ModEnd> "
666,"<S2SV_StartBug> void vp9_rc_init ( const VP9_CONFIG * oxcf , int pass , RATE_CONTROL * rc ) { <S2SV_EndBug> <S2SV_StartBug> if ( pass == 0 && oxcf -> end_usage == USAGE_STREAM_FROM_SERVER ) { <S2SV_EndBug> <S2SV_StartBug> rc -> avg_frame_qindex [ 0 ] = oxcf -> worst_allowed_q ; <S2SV_EndBug> <S2SV_StartBug> rc -> avg_frame_qindex [ 1 ] = oxcf -> worst_allowed_q ; <S2SV_EndBug> <S2SV_StartBug> rc -> avg_frame_qindex [ 0 ] = ( oxcf -> worst_allowed_q + <S2SV_EndBug> <S2SV_StartBug> rc -> avg_frame_qindex [ 1 ] = ( oxcf -> worst_allowed_q + <S2SV_EndBug> <S2SV_StartBug> rc -> avg_frame_qindex [ 2 ] = ( oxcf -> worst_allowed_q + <S2SV_EndBug> <S2SV_StartBug> rc -> last_q [ 0 ] = oxcf -> best_allowed_q ; <S2SV_EndBug> ","<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> int i ; <S2SV_ModStart> rc_mode == VPX_CBR <S2SV_ModEnd> <S2SV_ModStart> KEY_FRAME <S2SV_ModEnd> <S2SV_ModStart> INTER_FRAME <S2SV_ModEnd> <S2SV_ModStart> KEY_FRAME <S2SV_ModEnd> <S2SV_ModStart> INTER_FRAME <S2SV_ModEnd> <S2SV_ModStart> } rc -> last_q [ KEY_FRAME ] = oxcf -> best_allowed_q ; rc -> last_q [ INTER_FRAME ] = oxcf -> worst_allowed_q ; rc -> buffer_level = rc -> starting_buffer_level ; rc -> bits_off_target = rc -> starting_buffer_level ; rc -> rolling_target_bits = rc -> avg_frame_bandwidth ; rc -> rolling_actual_bits = rc -> avg_frame_bandwidth ; rc -> long_rolling_target_bits = rc -> avg_frame_bandwidth ; rc -> long_rolling_actual_bits = rc -> avg_frame_bandwidth ; rc -> total_actual_bits = 0 ; rc -> total_target_bits = 0 ; rc -> total_target_vs_actual = 0 ; rc -> frames_since_key = 8 ; rc -> this_key_frame_forced = 0 ; rc -> next_key_frame_forced = 0 ; rc -> source_alt_ref_pending = 0 ; rc -> source_alt_ref_active = 0 ; rc -> frames_till_gf_update_due = 0 ; rc -> ni_av_qi = oxcf -> worst_allowed_q ; rc -> ni_tot_qi = 0 ; rc -> ni_frames = 0 ; rc -> tot_q = 0.0 ; rc -> avg_q = vp9_convert_qindex_to_q ( oxcf -> worst_allowed_q , oxcf -> bit_depth ) ; for ( i = 0 ; i < RATE_FACTOR_LEVELS ; ++ i ) { rc -> rate_correction_factors [ i ] = 1.0 ; } rc -> min_gf_interval = oxcf -> min_gf_interval ; rc -> max_gf_interval = oxcf -> max_gf_interval ; if ( rc -> min_gf_interval == 0 ) rc -> min_gf_interval = vp9_rc_get_default_min_gf_interval ( oxcf -> width , oxcf -> height , oxcf -> init_framerate ) ; if ( rc -> max_gf_interval == 0 ) rc -> max_gf_interval = vp9_rc_get_default_max_gf_interval ( oxcf -> init_framerate , rc -> min_gf_interval ) ; rc -> baseline_gf_interval = ( rc -> min_gf_interval + rc -> max_gf_interval <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
667,<S2SV_StartBug> unsigned int array_index_stack [ ARRAY_INDEX_STACK_SIZE ] ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> 
668,"<S2SV_StartBug> ""session<S2SV_blank>authenticated"" , NULL , NULL , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> cb_new_auth <S2SV_ModEnd> 
669,"<S2SV_StartBug> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <S2SV_EndBug> <S2SV_StartBug> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <S2SV_EndBug> ",<S2SV_ModStart> & 255 <S2SV_ModStart> & 255 
670,"<S2SV_StartBug> static MB_PREDICTION_MODE read_inter_mode ( VP9_COMMON * cm , vp9_reader * r , <S2SV_EndBug> <S2SV_StartBug> const int mode = vp9_read_tree ( r , vp9_inter_mode_tree , <S2SV_EndBug> <S2SV_StartBug> cm -> fc . inter_mode_probs [ ctx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ","<S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> MACROBLOCKD * xd , vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_read_tree <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> "
671,<S2SV_StartBug> if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> ,"<S2SV_ModStart> info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; if ( replace ) { err = snd_ctl_remove_user_ctl ( file , & info -> id ) ; if ( err ) return err ; } if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
672,"<S2SV_StartBug> static void optimize_b ( int plane , int block , BLOCK_SIZE plane_bsize , <S2SV_EndBug> <S2SV_StartBug> TX_SIZE tx_size , MACROBLOCK * mb , <S2SV_EndBug> <S2SV_StartBug> struct macroblock_plane * p = & mb -> plane [ plane ] ; <S2SV_EndBug> <S2SV_StartBug> struct macroblockd_plane * pd = & xd -> plane [ plane ] ; <S2SV_EndBug> <S2SV_StartBug> const int16_t * coeff = BLOCK_OFFSET ( mb -> plane [ plane ] . coeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int eob = p -> eobs [ block ] , final_eob , sz = 0 ; <S2SV_EndBug> <S2SV_StartBug> PLANE_TYPE type = pd -> plane_type ; <S2SV_EndBug> <S2SV_StartBug> uint8_t token_cache [ 1024 ] ; <S2SV_EndBug> <S2SV_StartBug> const int16_t * dequant_ptr = pd -> dequant ; <S2SV_EndBug> <S2SV_StartBug> const int16_t * scan = so -> scan ; <S2SV_EndBug> <S2SV_StartBug> rdmult = mb -> rdmult * err_mult ; <S2SV_EndBug> <S2SV_StartBug> if ( ! is_inter_block ( & mb -> e_mbd . mi [ 0 ] -> mbmi ) ) <S2SV_EndBug> <S2SV_StartBug> rddiv = mb -> rddiv ; <S2SV_EndBug> <S2SV_StartBug> * ( tokens [ eob ] + 1 ) = * ( tokens [ eob ] + 0 ) ; <S2SV_EndBug> <S2SV_StartBug> token_cache [ scan [ i ] ] = vp9_pt_energy_class [ vp9_dct_value_tokens_ptr [ <S2SV_EndBug> <S2SV_StartBug> qcoeff [ scan [ i ] ] ] . token ] ; <S2SV_EndBug> <S2SV_StartBug> for ( i = eob ; i -- > i0 ; ) { <S2SV_EndBug> <S2SV_StartBug> rc = scan [ i ] ; <S2SV_EndBug> <S2SV_StartBug> x = qcoeff [ rc ] ; <S2SV_EndBug> <S2SV_StartBug> t0 = ( vp9_dct_value_tokens_ptr + x ) -> token ; <S2SV_EndBug> <S2SV_StartBug> base_bits = * ( vp9_dct_value_cost_ptr + x ) ; <S2SV_EndBug> <S2SV_StartBug> dx = mul * ( dqcoeff [ rc ] - coeff [ rc ] ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> t0 = t1 = ( vp9_dct_value_tokens_ptr + x ) -> token ; <S2SV_EndBug> <S2SV_StartBug> base_bits = * ( vp9_dct_value_cost_ptr + x ) ; <S2SV_EndBug> <S2SV_StartBug> if ( shortcut ) { <S2SV_EndBug> <S2SV_StartBug> dx -= ( dequant_ptr [ rc != 0 ] + sz ) ^ sz ; <S2SV_EndBug> <S2SV_StartBug> pt = combine_entropy_contexts ( * a , * l ) ; <S2SV_EndBug> <S2SV_StartBug> rate0 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 0 ] [ pt ] [ t0 ] ; <S2SV_EndBug> <S2SV_StartBug> rate1 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 0 ] [ pt ] [ t1 ] ; <S2SV_EndBug> <S2SV_StartBug> final_eob = i0 - 1 ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( qcoeff , 0 , sizeof ( * qcoeff ) * ( 16 << ( tx_size * 2 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( dqcoeff , 0 , sizeof ( * dqcoeff ) * ( 16 << ( tx_size * 2 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> x = tokens [ i ] [ best ] . qc ; <S2SV_EndBug> <S2SV_StartBug> if ( x ) { <S2SV_EndBug> <S2SV_StartBug> rc = scan [ i ] ; <S2SV_EndBug> <S2SV_StartBug> * a = * l = ( final_eob > 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> int optimize_b ( MACROBLOCK * mb , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int ctx <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> const <S2SV_ModStart> uint8_t token_cache [ 1024 ] ; const tran_low_t * const <S2SV_ModEnd> <S2SV_ModStart> tran_low_t * const <S2SV_ModEnd> <S2SV_ModStart> tran_low_t * const <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> ; const <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const int16_t * dequant_ptr = pd -> dequant ; const uint8_t * const band_translate = get_band_translate ( tx_size ) ; const scan_order * const so = get_scan ( xd , tx_size , type , block ) <S2SV_ModEnd> <S2SV_ModStart> const scan = so -> scan ; const int16_t * const nb = so -> neighbors ; int next = eob , sz = 0 ; int64_t rdmult = mb -> rdmult * plane_rd_mult [ type ] , rddiv = mb -> rddiv ; int64_t rd_cost0 , rd_cost1 ; int rate0 , rate1 , error0 , error1 ; int16_t t0 , t1 ; EXTRABIT e0 ; int best , band , pt , i , final_eob ; # if CONFIG_VP9_HIGHBITDEPTH const int16_t * cat6_high_cost = vp9_get_high_cost_table ( xd -> bd ) ; # else <S2SV_ModEnd> <S2SV_ModStart> cat6_high_cost = vp9_get_high_cost_table ( 8 ) ; # endif <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> [ 1 ] = <S2SV_ModEnd> <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> vp9_get_token ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> const int <S2SV_ModStart> int <S2SV_ModStart> vp9_get_token_extra ( x , & t0 , & e0 ) <S2SV_ModEnd> <S2SV_ModStart> vp9_get_cost ( t0 , e0 , cat6_high_cost <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { dx >>= xd -> bd - 8 ; } # endif <S2SV_ModStart> e0 = 0 ; <S2SV_ModStart> vp9_get_token_extra ( x , & t0 , & e0 ) ; t1 = t0 <S2SV_ModEnd> <S2SV_ModStart> vp9_get_cost ( t0 , e0 , cat6_high_cost <S2SV_ModEnd> <S2SV_ModStart> ) { # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH <S2SV_ModStart> ( <S2SV_ModStart> >> ( xd -> bd - 8 ) ) <S2SV_ModStart> } else { dx -= ( dequant_ptr [ rc != 0 ] + sz ) ^ sz ; } # else dx -= ( dequant_ptr [ rc != 0 ] + sz ) ^ sz ; # endif <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ctx <S2SV_ModEnd> <S2SV_ModStart> ctx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> const int <S2SV_ModStart> const int rc = scan [ i ] ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return final_eob <S2SV_ModEnd> "
673,"<S2SV_StartBug> int vp9_decode_block_tokens ( VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_EndBug> <S2SV_StartBug> int plane , int block , BLOCK_SIZE plane_bsize , <S2SV_EndBug> <S2SV_StartBug> int x , int y , TX_SIZE tx_size , vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_EndBug> <S2SV_StartBug> const scan_order * so = get_scan ( xd , tx_size , pd -> plane_type , block ) ; <S2SV_EndBug> <S2SV_StartBug> const int eob = decode_coefs ( cm , xd , pd -> plane_type , <S2SV_EndBug> <S2SV_StartBug> BLOCK_OFFSET ( pd -> dqcoeff , block ) , tx_size , <S2SV_EndBug> <S2SV_StartBug> pd -> dequant , ctx , so -> scan , so -> neighbors , r ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_set_contexts ( xd , pd , plane_bsize , tx_size , eob > 0 , x , y ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const scan_order * sc <S2SV_ModEnd> <S2SV_ModStart> vpx_reader * r , int seg_id <S2SV_ModEnd> <S2SV_ModStart> ] ; const int16_t * const dequant = pd -> seg_dequant [ seg_id <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tx_size , <S2SV_ModEnd> <S2SV_ModStart> sc <S2SV_ModEnd> <S2SV_ModStart> sc <S2SV_ModEnd> <S2SV_ModStart> dec_set_contexts <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
674,"
","
"
675,<S2SV_StartBug> free_called += 1 ; <S2SV_EndBug> ,<S2SV_ModStart> = <S2SV_ModEnd> 
676,<S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> <S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> <S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> <S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> ,<S2SV_ModStart> bailout <S2SV_ModEnd> <S2SV_ModStart> bailout <S2SV_ModEnd> <S2SV_ModStart> bailout <S2SV_ModEnd> <S2SV_ModStart> bailout <S2SV_ModEnd> 
677,<S2SV_StartBug> goto err_unregister_v4l2_dev ; <S2SV_EndBug> <S2SV_StartBug> err_unregister_v4l2_dev : <S2SV_EndBug> ,<S2SV_ModStart> err_free_controls <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
678,<S2SV_StartBug> max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; <S2SV_EndBug> <S2SV_StartBug> max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ; <S2SV_EndBug> ,"<S2SV_ModStart> { if ( CheckMemoryOverflow <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; } else { if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_ModEnd> <S2SV_ModStart> } "
679,<S2SV_StartBug> # if HAVA_LZMA_H && HAVE_LIBLZMA <S2SV_EndBug> ,<S2SV_ModStart> HAVE_LZMA_H <S2SV_ModEnd> 
680,"<S2SV_StartBug> mcryptd_check_internal ( tb , & type , & mask ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) return - EINVAL 
681,"<S2SV_StartBug> static void utee_param_to_param ( struct tee_ta_param * p , struct utee_params * up ) <S2SV_EndBug> <S2SV_StartBug> switch ( TEE_PARAM_TYPE_GET ( types , n ) ) { <S2SV_EndBug> <S2SV_StartBug> case TEE_PARAM_TYPE_MEMREF_INPUT : <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> TEE_Result utee_param_to_param ( struct user_ta_ctx * utc , <S2SV_ModEnd> <S2SV_ModStart> uint32_t flags = TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER ; <S2SV_ModStart> TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : flags |= TEE_MEMORY_ACCESS_WRITE ; case TEE_PARAM_TYPE_MEMREF_INPUT <S2SV_ModEnd> <S2SV_ModStart> if ( tee_mmu_check_access_rights ( utc , flags , a , b ) ) return TEE_ERROR_ACCESS_DENIED ; <S2SV_ModStart> return TEE_SUCCESS ; "
682,"<S2SV_StartBug> mcryptd_check_internal ( tb , & type , & mask ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) return - EINVAL 
683,<S2SV_StartBug> void fdct8_sse2 ( __m128i * in ) { <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug> ,<S2SV_ModStart> static <S2SV_ModStart> ( int16_t ) 
684,"<S2SV_StartBug> if ( output ) <S2SV_EndBug> <S2SV_StartBug> strcpy ( output , ( const char * ) output_u8 ) ; <S2SV_EndBug> ",<S2SV_ModStart> size_t len = strlen ( ( char * ) output_u8 ) ; if ( len > 63 ) { free ( output_u8 ) ; return IDN2_TOO_BIG_DOMAIN ; } <S2SV_ModStart>  <S2SV_ModEnd> 
685,<S2SV_StartBug> if ( ! unconditional ( & e -> ip ) ) <S2SV_EndBug> ,<S2SV_ModStart> e <S2SV_ModEnd> 
686,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
687,<S2SV_StartBug> if ( key_is_instantiated ( keyring ) ) { <S2SV_EndBug> ,<S2SV_ModStart> key_is_positive <S2SV_ModEnd> 
688,"<S2SV_StartBug> int isopen ; <S2SV_EndBug> <S2SV_StartBug> size = offsetof ( POLYGON , p [ 0 ] ) + sizeof ( poly -> p [ 0 ] ) * npts ; <S2SV_EndBug> ","<S2SV_ModStart> base_size ; int <S2SV_ModStart> base_size = sizeof ( poly -> p [ 0 ] ) * npts ; <S2SV_ModStart> base_size ; if ( base_size / npts != <S2SV_ModStart> || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested"" ) ) ) <S2SV_ModEnd> "
689,"<S2SV_StartBug> void nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride ) <S2SV_EndBug> <S2SV_StartBug> nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ; <S2SV_EndBug> <S2SV_StartBug> nsc_encode_subsampling ( context ) ; <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> if ( ! context || ! bmpdata || ( rowstride == 0 ) ) return FALSE ; if ( ! <S2SV_ModStart> ) return FALSE <S2SV_ModStart> if ( ! <S2SV_ModStart> ) return FALSE ; } return TRUE ; <S2SV_ModEnd> 
690,<S2SV_StartBug> * ( * fill ) ++ = suffix [ code ] ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( code >= clear ) { fprintf ( stderr , ""bad<S2SV_blank>input:<S2SV_blank>code=%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>clear=%d\\n"" , code , clear ) ; return 0 ; } "
691,<S2SV_StartBug> if ( ! from_buffer ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
692,<S2SV_StartBug> char added ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
693,"<S2SV_StartBug> separator = strchr ( context -> buffer , ':' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
694,"<S2SV_StartBug> if ( memcmp ( & name [ 2 ] , & content_name [ 2 ] , 31L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . content = fi ; <S2SV_EndBug> <S2SV_StartBug> else if ( memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . control = fi ; <S2SV_EndBug> <S2SV_StartBug> else if ( memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . spaninfo = fi ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> name_len == 40 && memcmp ( name , content_name , 40 <S2SV_ModEnd> <S2SV_ModStart> chm -> sec1 . content = fi ; } else if ( name_len == 44 && memcmp ( name , control_name , 44 <S2SV_ModEnd> <S2SV_ModStart> control <S2SV_ModEnd> <S2SV_ModStart> name_len == 41 && memcmp ( name , spaninfo_name , 41 <S2SV_ModEnd> <S2SV_ModStart> spaninfo <S2SV_ModEnd> <S2SV_ModStart> name_len == 105 && memcmp ( name , rtable_name , 105 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
695,"<S2SV_StartBug> void generate_filename ( const char * pattern , char * out , size_t q_len , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> static <S2SV_ModStart> break ; 
696,"<S2SV_StartBug> if ( args -> skip ) <S2SV_EndBug> <S2SV_StartBug> if ( ! is_inter_block ( mbmi ) ) <S2SV_EndBug> <S2SV_StartBug> vp9_encode_block_intra ( x , plane , block , plane_bsize , tx_size , & mbmi -> skip ) ; <S2SV_EndBug> <S2SV_StartBug> dist_block ( plane , block , tx_size , args ) ; <S2SV_EndBug> <S2SV_StartBug> rd1 = RDCOST ( x -> rdmult , x -> rddiv , args -> rate , args -> dist ) ; <S2SV_EndBug> <S2SV_StartBug> rd2 = RDCOST ( x -> rdmult , x -> rddiv , 0 , args -> sse ) ; <S2SV_EndBug> <S2SV_StartBug> args -> this_rate += args -> rate ; <S2SV_EndBug> <S2SV_StartBug> args -> this_dist += args -> dist ; <S2SV_EndBug> <S2SV_StartBug> args -> this_sse += args -> sse ; <S2SV_EndBug> <S2SV_StartBug> args -> skip = 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int rate ; int64_t dist ; int64_t sse ; if ( args -> exit_early <S2SV_ModEnd> <S2SV_ModStart> { struct encode_b_args arg = { x , NULL , & mbmi -> skip } ; vp9_encode_block_intra ( <S2SV_ModEnd> <S2SV_ModStart> arg ) ; dist_block ( x , plane , block , tx_size , & dist , & sse ) ; } else if ( max_txsize_lookup [ plane_bsize ] == tx_size ) { if ( x -> skip_txfm [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] == SKIP_TXFM_NONE ) { <S2SV_ModEnd> <S2SV_ModStart> x , plane , block , tx_size , & dist , & sse ) ; } else if ( x -> skip_txfm [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] == SKIP_TXFM_AC_ONLY ) { tran_low_t * const coeff = BLOCK_OFFSET ( x -> plane [ plane ] . coeff , block ) ; tran_low_t * const dqcoeff = BLOCK_OFFSET ( xd -> plane [ plane ] . dqcoeff , block ) ; vp9_xform_quant_dc ( x , plane , block , plane_bsize , tx_size ) ; sse = x -> bsse [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] << 4 ; dist = sse ; if ( x -> plane [ plane ] . eobs [ block ] ) { const int64_t orig_sse = ( int64_t ) coeff [ 0 ] * coeff [ 0 ] ; const int64_t resd_sse = coeff [ 0 ] - dqcoeff [ 0 ] ; int64_t dc_correct = orig_sse - resd_sse * resd_sse ; # if CONFIG_VP9_HIGHBITDEPTH dc_correct >>= ( ( xd -> bd - 8 ) * 2 ) ; # endif if ( tx_size != TX_32X32 ) dc_correct >>= 2 ; dist = MAX ( 0 , sse - dc_correct ) ; } } else { x -> plane [ plane ] . eobs [ block ] = 0 ; sse = x -> bsse [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] << 4 ; dist = sse ; } } else { vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; dist_block ( x , plane , block , tx_size , & dist , & sse ) ; } rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , dist ) ; if ( args -> this_rd + rd > args -> best_rd ) { args -> exit_early = 1 ; return ; } rate = <S2SV_ModEnd> <S2SV_ModStart> rate , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> exit_early <S2SV_ModEnd> <S2SV_ModStart> args -> skippable &= ! x -> plane [ plane ] . eobs [ block ] ; "
697,"<S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) length ; j += 8 ) <S2SV_EndBug> <S2SV_StartBug> ""InsufficientImageDataInFile"" , image -> filename ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( DiscardBlobBytes ( image , length ) == <S2SV_ModEnd> <S2SV_ModStart> ""UnexpectedEndOfFile"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
698,"<S2SV_StartBug> u8 * gb_cur , * version_tlv , version , version_length ; <S2SV_EndBug> <S2SV_StartBug> gb_len += version_length ; <S2SV_EndBug> <S2SV_StartBug> gb_len += lto_length ; <S2SV_EndBug> <S2SV_StartBug> gb_len += wks_length ; <S2SV_EndBug> <S2SV_StartBug> & miux_length ) ; <S2SV_EndBug> ","<S2SV_ModStart> version , version_length ; u8 lto_length , wks_length , miux_length ; u8 * version_tlv = NULL , * lto_tlv = NULL , * wks_tlv = NULL , * miux_tlv = NULL <S2SV_ModEnd> <S2SV_ModStart> if ( ! version_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> if ( ! lto_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> if ( ! wks_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> if ( ! miux_tlv ) { ret = - ENOMEM ; goto out ; } "
699,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( up -> replay_window > up -> bmp_len * sizeof ( __u32 ) * 8 ) return - EINVAL ; 
700,"<S2SV_StartBug> mrb_value value ; <S2SV_EndBug> <S2SV_StartBug> fiber_check_cfunc ( mrb , c ) ; <S2SV_EndBug> <S2SV_StartBug> if ( resume && c -> status == MRB_FIBER_TRANSFERRED ) { <S2SV_EndBug> <S2SV_StartBug> if ( c -> status == MRB_FIBER_RUNNING || c -> status == MRB_FIBER_RESUMED ) { <S2SV_EndBug> <S2SV_StartBug> if ( c -> status == MRB_FIBER_TERMINATED ) { <S2SV_EndBug> <S2SV_StartBug> mrb -> c -> status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ; <S2SV_EndBug> <S2SV_StartBug> if ( c -> status == MRB_FIBER_CREATED ) { <S2SV_EndBug> <S2SV_StartBug> if ( len >= c -> stend - c -> stack ) { <S2SV_EndBug> <S2SV_StartBug> fiber_switch_context ( mrb , c ) ; <S2SV_EndBug> ","<S2SV_ModStart> enum mrb_fiber_state status ; <S2SV_ModStart> ; status = c -> status <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> old_c <S2SV_ModEnd> <S2SV_ModStart> fiber_switch_context ( mrb , c ) ; if ( <S2SV_ModEnd> <S2SV_ModStart> mrb_stack_extend ( mrb , len + 2 ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
701,<S2SV_StartBug> uint_t i ; <S2SV_EndBug> <S2SV_StartBug> if ( length < sizeof ( DhcpMessage ) ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> if ( option -> code == DHCP_OPT_END ) <S2SV_EndBug> <S2SV_StartBug> if ( ( i + 1 ) >= length || ( i + 1 + option -> length ) >= length ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> >= <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModEnd> <S2SV_ModStart> { } else <S2SV_ModEnd> <S2SV_ModStart> ) { break ; } else { if ( ( i + 1 ) >= length <S2SV_ModStart> sizeof ( DhcpOption ) <S2SV_ModEnd> <S2SV_ModStart> > <S2SV_ModEnd> <S2SV_ModStart> } } 
702,<S2SV_StartBug> ipv6_select_ident ( fptr ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , ( struct rt6_info * ) skb_dst ( skb ) "
703,"<S2SV_StartBug> rb_define_singleton_method ( klass , ""read_memory"" , read_memory , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> rb_define_singleton_method ( klass , ""from_document"" , from_document , 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> - <S2SV_ModStart> - 
704,<S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> ,<S2SV_ModStart> status = MagickFalse ; break <S2SV_ModEnd> 
705,<S2SV_StartBug> int i ; <S2SV_EndBug> ,<S2SV_ModStart> jas_matind_t i ; jas_matind_t <S2SV_ModEnd> 
706,<S2SV_StartBug> struct iovec * iovec ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> , struct iov_iter * iter ) { if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ; <S2SV_ModEnd> <S2SV_ModStart> iov_iter_init ( iter , rw , iovec , * nr_segs , len ) ; "
707,<S2SV_StartBug> if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) ) <S2SV_EndBug> ,<S2SV_ModStart> ( CLONE_NEWUSER | CLONE_FS ) ) == ( CLONE_NEWUSER | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & 
708,<S2SV_StartBug> void ntlm_print_negotiate_flags ( UINT32 flags ) <S2SV_EndBug> ,<S2SV_ModStart> static 
709,<S2SV_StartBug> new_fname = malloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
710,"<S2SV_StartBug> # line 496 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 861 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 558 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 855 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 607 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 708 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> if ( incomplete_class ) { <S2SV_EndBug> <S2SV_StartBug> # line 785 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 699 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> return object_common2 ( UNSERIALIZE_PASSTHRU , <S2SV_EndBug> <S2SV_StartBug> object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ) ; <S2SV_EndBug> <S2SV_StartBug> # line 819 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 678 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 861 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 643 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 917 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 610 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 971 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 600 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1069 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 585 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1143 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 558 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1197 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 551 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1212 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 544 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1222 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 521 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1268 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 500 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1312 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 863 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> ","<S2SV_ModStart> 501 <S2SV_ModEnd> <S2SV_ModStart> 875 <S2SV_ModEnd> <S2SV_ModStart> 563 <S2SV_ModEnd> <S2SV_ModStart> 869 <S2SV_ModEnd> <S2SV_ModStart> 612 <S2SV_ModEnd> <S2SV_ModStart> 717 <S2SV_ModEnd> <S2SV_ModStart> elements < 0 ) { efree ( class_name ) ; return 0 ; } if ( <S2SV_ModStart> 795 <S2SV_ModEnd> <S2SV_ModStart> 704 ""ext/standard/var_unserializer.re"" { long elements ; <S2SV_ModEnd> <S2SV_ModStart> elements = object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ; if ( elements < 0 ) { return 0 ; } <S2SV_ModStart> elements <S2SV_ModEnd> <S2SV_ModStart> 833 <S2SV_ModEnd> <S2SV_ModStart> 683 <S2SV_ModEnd> <S2SV_ModStart> 875 <S2SV_ModEnd> <S2SV_ModStart> 648 <S2SV_ModEnd> <S2SV_ModStart> 931 <S2SV_ModEnd> <S2SV_ModStart> 615 <S2SV_ModEnd> <S2SV_ModStart> 985 <S2SV_ModEnd> <S2SV_ModStart> 605 <S2SV_ModEnd> <S2SV_ModStart> 1083 <S2SV_ModEnd> <S2SV_ModStart> 590 <S2SV_ModEnd> <S2SV_ModStart> 1157 <S2SV_ModEnd> <S2SV_ModStart> 563 <S2SV_ModEnd> <S2SV_ModStart> 1211 <S2SV_ModEnd> <S2SV_ModStart> 556 <S2SV_ModEnd> <S2SV_ModStart> 1226 <S2SV_ModEnd> <S2SV_ModStart> 549 <S2SV_ModEnd> <S2SV_ModStart> 1236 <S2SV_ModEnd> <S2SV_ModStart> 526 <S2SV_ModEnd> <S2SV_ModStart> 1282 <S2SV_ModEnd> <S2SV_ModStart> 505 <S2SV_ModEnd> <S2SV_ModStart> 1326 <S2SV_ModEnd> <S2SV_ModStart> 877 <S2SV_ModEnd> "
711,"<S2SV_StartBug> if ( send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
712,<S2SV_StartBug> * ( * fill ) ++ = suffix [ code ] ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( code >= clear ) { fprintf ( stderr , ""bad<S2SV_blank>input:<S2SV_blank>code=%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>clear=%d\\n"" , code , clear ) ; return 0 ; } "
713,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
714,<S2SV_StartBug> p -> exit_signal = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( clone_flags & CLONE_PARENT ) <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( clone_flags & CLONE_THREAD ) p -> exit_signal = - 1 ; else p -> exit_signal = current -> group_leader -> exit_signal ; <S2SV_ModStart> p -> exit_signal = args -> exit_signal ; 
715,"<S2SV_StartBug> const u_char * ep , uint32_t phase , uint32_t doi0 _U_ , <S2SV_EndBug> <S2SV_StartBug> uint32_t proto0 _U_ , int depth ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>orig=("" ) ) ; <S2SV_EndBug> <S2SV_StartBug> size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case IPSECDOI_NTYPE_REPLAY_STATUS : <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> isakmp_print ( ndo , cp , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> _U_ <S2SV_ModStart> _U_ <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>attrs=("" ) <S2SV_ModStart> ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ""<S2SV_blank>status=("" ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , "")"" ) ) <S2SV_ModEnd> <S2SV_ModStart> if ( ndo -> ndo_vflag > 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>data=("" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> } else { if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; } break ; } "
716,"<S2SV_StartBug> iframe -> iv = nghttp2_mem_malloc ( mem , sizeof ( nghttp2_settings_entry ) * <S2SV_EndBug> ","<S2SV_ModStart> if ( iframe -> max_niv - 1 > session -> max_settings ) { rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_ENHANCE_YOUR_CALM , ""SETTINGS:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>setting<S2SV_blank>entries"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } "
717,"<S2SV_StartBug> ! inode_capable ( VFS_I ( ip ) , CAP_FSETID ) ) <S2SV_EndBug> ",<S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> 
718,<S2SV_StartBug> data -> o_arg . open_flags ) ; <S2SV_EndBug> ,<S2SV_ModStart> fmode <S2SV_ModEnd> 
719,"<S2SV_StartBug> # define EXIFMultipleValues ( size , format , arg ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , arg ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> <S2SV_StartBug> # define EXIFMultipleFractions ( size , format , arg1 , arg2 ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , ( arg1 ) , ( arg2 ) ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> <S2SV_StartBug> if ( GetValueFromSplayTree ( exif_resources , q ) == q ) <S2SV_EndBug> <S2SV_StartBug> components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> q > ( exif + length - 12 ) ) break ; if ( <S2SV_ModStart> ; if ( components < 0 ) break 
720,<S2SV_StartBug> if ( ! static_key_enabled ( work -> key ) ) <S2SV_EndBug> ,<S2SV_ModStart> BUG_ON <S2SV_ModEnd> <S2SV_ModStart> ; static_key_slow_dec <S2SV_ModEnd> 
721,<S2SV_StartBug> goto errout_locked ; <S2SV_EndBug> <S2SV_StartBug> kfree ( family -> attrbuf ) ; <S2SV_EndBug> ,<S2SV_ModStart> errout_free <S2SV_ModEnd> <S2SV_ModStart> errout_free : 
722,"<S2SV_StartBug> memcpy ( & bss_cfg -> wmm_info , wmm_ie + <S2SV_EndBug> <S2SV_StartBug> sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> > sizeof ( struct mwifiex_types_wmm_info ) ) return ; memcpy ( & bss_cfg -> wmm_info , wmm_ie + sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) "
723,"<S2SV_StartBug> separator = strchr ( connection -> buffer , '=' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
724,<S2SV_StartBug> * ( buf + insertpos ) = x2c ( & buf [ editpos + 3 ] ) ; <S2SV_EndBug> ,<S2SV_ModStart> _x2c <S2SV_ModEnd> 
725,"<S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_PRE_IO ) { <S2SV_EndBug> <S2SV_StartBug> ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; <S2SV_EndBug> <S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_CONVERT ) { <S2SV_EndBug> ",<S2SV_ModStart> ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result <S2SV_ModStart> ( flags & EXT4_GET_BLOCKS_CONVERT ) <S2SV_ModEnd> 
726,"<S2SV_StartBug> ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> if ( size > urb -> transfer_buffer_length ) { <S2SV_ModEnd> <S2SV_ModStart> return 0 ; <S2SV_ModStart> ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; if ( ret != size ) { dev_err ( & urb -> dev -> dev , ""recv<S2SV_blank>xbuf,<S2SV_blank>%d\\n"" , ret ) ; if ( ud -> side == USBIP_STUB ) { usbip_event_add ( ud , SDEV_EVENT_ERROR_TCP ) ; } else { usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ; return - EPIPE ; } } "
727,<S2SV_StartBug> net -> dev_base_seq = 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> get_random_bytes ( & net -> hash_mix , sizeof ( u32 ) ) ; "
728,"<S2SV_StartBug> strlcpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <S2SV_EndBug> <S2SV_StartBug> strlcpy ( ualg -> cru_driver_name , alg -> cra_driver_name , <S2SV_EndBug> <S2SV_StartBug> strlcpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , <S2SV_EndBug> <S2SV_StartBug> strlcpy ( rl . type , ""larval"" , sizeof ( rl . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> strncpy <S2SV_ModEnd> 
729,<S2SV_StartBug> cJSON * c ; <S2SV_EndBug> ,"<S2SV_ModStart> return cJSON_ParseWithOpts ( value , 0 , 0 ) ; <S2SV_ModEnd> "
730,<S2SV_StartBug> unpack_streams += ( size_t ) f [ i ] . numUnpackStreams ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unpack_streams > SIZE_MAX - UMAX_ENTRY ) { return ( - 1 ) ; } 
731,<S2SV_StartBug> BUG_ON ( direction != ITER_PIPE ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; WARN_ON ( pipe -> nrbufs == pipe -> buffers 
732,<S2SV_StartBug> mnt_flags |= mnt -> mnt . mnt_flags & MNT_PROPAGATION_MASK ; <S2SV_EndBug> ,<S2SV_ModStart> ~ MNT_USER_SETTABLE_MASK <S2SV_ModEnd> 
733,"<S2SV_StartBug> static int fsmVerify ( const char * path , rpmfi fi ) <S2SV_EndBug> <S2SV_StartBug> rc = fsmStat ( path , 0 , & dsb ) ; <S2SV_EndBug> <S2SV_StartBug> if ( S_ISDIR ( dsb . st_mode ) ) return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> , const struct stat * fsb <S2SV_ModStart> uid_t luid = dsb . st_uid ; <S2SV_ModStart> && ( luid == 0 || luid == fsb -> st_uid ) ) <S2SV_ModEnd> "
734,"<S2SV_StartBug> snd_pcm_stream_unlock_irqrestore ( substream , flags ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> snd_pcm_stream_unlock_irqrestore ( substream , flags ) ; "
735,<S2SV_StartBug> for ( plane = 0 ; in -> data [ plane ] && plane < 4 ; plane ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( plane = 0 ; in -> data [ plane ] && plane < 4 ; plane ++ ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && in -> data [ plane ] && in -> linesize [ plane ] <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && in -> data [ plane ] && in -> linesize [ plane ] 
736,"<S2SV_StartBug> bool valid_handle ; <S2SV_EndBug> <S2SV_StartBug> valid_handle = ion_handle_validate ( client , handle ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ion_free_nolock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
737,<S2SV_StartBug> WORD16 i2_level_arr [ 16 ] ; <S2SV_EndBug> ,<S2SV_ModStart> ai2_level_arr [ 19 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> 
738,<S2SV_StartBug> if ( frame -> color_primaries != AVCOL_PRI_UNSPECIFIED ) <S2SV_EndBug> ,"<S2SV_ModStart> print_primaries ( w , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
739,<S2SV_StartBug> if ( ! s -> cdx [ i ] || ! s -> cdy [ i ] ) { <S2SV_EndBug> ,<S2SV_ModStart> s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || <S2SV_ModStart> || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4 
740,<S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff "
741,<S2SV_StartBug> follow_dotdot ( nd ) ; <S2SV_EndBug> ,<S2SV_ModStart> return 
742,<S2SV_StartBug> dname = malloc ( strlen ( name ) + 16 ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
743,"<S2SV_StartBug> while ( ( type = gettoken_query ( state , & val , & lenval , & strval , & flag ) ) != END ) <S2SV_EndBug> ",<S2SV_ModStart> check_stack_depth ( ) ; 
744,<S2SV_StartBug> struct sock * sk ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL 
745,<S2SV_StartBug> static void usage ( char * progname ) { <S2SV_EndBug> <S2SV_StartBug> progname ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> exec_name <S2SV_ModEnd> 
746,"<S2SV_StartBug> int watchdog = 0 ; <S2SV_EndBug> <S2SV_StartBug> num = SSL_shutdown ( c -> ssl ) ; <S2SV_EndBug> <S2SV_StartBug> err = SSL_get_error ( c -> ssl , ( int ) num ) ; <S2SV_EndBug> <S2SV_StartBug> case SSL_ERROR_SYSCALL : <S2SV_EndBug> <S2SV_StartBug> case SSL_ERROR_ZERO_RETURN : <S2SV_EndBug> <S2SV_StartBug> case SSL_ERROR_WANT_WRITE : <S2SV_EndBug> <S2SV_StartBug> num = writesocket ( c -> sock_wfd -> fd , c -> ssl_buff , c -> ssl_ptr ) ; <S2SV_EndBug> <S2SV_StartBug> num = readsocket ( c -> sock_rfd -> fd , <S2SV_EndBug> <S2SV_StartBug> write_wants_read = 0 ; <S2SV_EndBug> <S2SV_StartBug> num = SSL_write ( c -> ssl , c -> sock_buff , ( int ) ( c -> sock_ptr ) ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( err = SSL_get_error ( c -> ssl , ( int ) num ) ) { <S2SV_EndBug> <S2SV_StartBug> case SSL_ERROR_SYSCALL : <S2SV_EndBug> <S2SV_StartBug> if ( num && parse_socket_error ( c , ""SSL_write"" ) ) <S2SV_EndBug> <S2SV_StartBug> case SSL_ERROR_ZERO_RETURN : <S2SV_EndBug> <S2SV_StartBug> s_log ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_write)"" ) ; <S2SV_EndBug> <S2SV_StartBug> case SSL_ERROR_SSL : <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , ""SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ; shutdown_wants_read = 0 ; shutdown_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : s_log ( LOG_DEBUG , ""SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ; shutdown_wants_read = 1 ; shutdown_wants_write = 0 ; break ; case SSL_ERROR_SSL : sslerror ( ""SSL_shutdown"" ) ; throw_exception ( c , 1 ) ; case SSL_ERROR_ZERO_RETURN : <S2SV_ModEnd> <S2SV_ModStart> SSL_ERROR_SYSCALL : if ( parse_socket_error ( c , ""SSL_shutdown"" ) ) break ; <S2SV_ModEnd> <S2SV_ModStart> default : s_log ( LOG_ERR , ""SSL_shutdown/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ; throw_exception ( c , 1 <S2SV_ModEnd> <S2SV_ModStart> ssize_t <S2SV_ModStart> ssize_t <S2SV_ModStart> int num = SSL_write ( c -> ssl , c -> sock_buff , ( int ) ( c -> sock_ptr ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> SSL_ERROR_SSL : sslerror ( ""SSL_write"" ) ; throw_exception ( c , 1 ) ; case SSL_ERROR_ZERO_RETURN : case <S2SV_ModStart> parse_socket_error ( c , ""SSL_write"" ) && num <S2SV_ModEnd> <S2SV_ModStart> default : s_log ( LOG_ERR , ""SSL_write/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ; throw_exception ( c , 1 ) ; } } if ( ( read_wants_read && ( ssl_can_rd || pending ) ) || ( read_wants_write && ssl_can_wr ) ) { int num = SSL_read ( c -> ssl , c -> ssl_buff + c -> ssl_ptr , ( int ) ( BUFFSIZE - c -> ssl_ptr ) ) ; read_wants_read = 0 ; read_wants_write = 0 ; switch ( err = SSL_get_error ( c -> ssl , num ) ) { case SSL_ERROR_NONE : if ( num == 0 ) { s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>0"" ) ; break ; } c -> ssl_ptr += ( size_t ) num ; watchdog = 0 ; break ; case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ; read_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : # if 0 s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ; # endif read_wants_read = 1 ; break ; case SSL_ERROR_WANT_X509_LOOKUP : s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_X509_LOOKUP:<S2SV_blank>retrying"" ) ; break ; case SSL_ERROR_SSL : sslerror ( ""SSL_read"" ) ; throw_exception ( c , 1 ) ; <S2SV_ModStart> ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_read)"" <S2SV_ModEnd> <S2SV_ModStart> SSL_ERROR_SYSCALL : if ( parse_socket_error ( c , ""SSL_read"" ) && num <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
747,<S2SV_StartBug> return err ; <S2SV_EndBug> ,<S2SV_ModStart> goto free_data <S2SV_ModEnd> 
748,"<S2SV_StartBug> evas_object_resize ( app_data -> window , DEFAULT_WIDTH , DEFAULT_HEIGHT ) ; <S2SV_EndBug> ","<S2SV_ModStart> window_width , window_height <S2SV_ModEnd> "
749,<S2SV_StartBug> if ( refill_pi_state_cache ( ) ) <S2SV_EndBug> <S2SV_StartBug> goto out_put_key1 ; <S2SV_EndBug> ,"<S2SV_ModStart> uaddr1 == uaddr2 ) return - EINVAL ; if ( <S2SV_ModStart> if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; } "
750,"<S2SV_StartBug> sctp_addiphdr_t * hdr ; <S2SV_EndBug> <S2SV_StartBug> int all_param_pass = 1 ; <S2SV_EndBug> <S2SV_StartBug> while ( chunk_len > 0 ) { <S2SV_EndBug> <S2SV_StartBug> asconf_param ) ; <S2SV_EndBug> <S2SV_StartBug> all_param_pass = 0 ; <S2SV_EndBug> <S2SV_StartBug> asconf_param -> crr_id , err_code , <S2SV_EndBug> <S2SV_StartBug> length = ntohs ( asconf_param -> param_hdr . length ) ; <S2SV_EndBug> ","<S2SV_ModStart> sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) asconf -> chunk_hdr ; bool all_param_pass = true ; union sctp_params param ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sctp_walk_params ( param , addip , addip_hdr . params ) { if ( param . p -> type == SCTP_PARAM_IPV4_ADDRESS || param . p -> type == SCTP_PARAM_IPV6_ADDRESS ) continue ; <S2SV_ModEnd> <S2SV_ModStart> param . addip ) ; if ( err_code != SCTP_ERROR_NO_ERROR <S2SV_ModEnd> <S2SV_ModStart> false <S2SV_ModEnd> <S2SV_ModStart> param . addip <S2SV_ModEnd> <S2SV_ModStart> err_code , param . addip ) ; if ( err_code == SCTP_ERROR_RSRC_LOW <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
751,<S2SV_StartBug> cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ; <S2SV_EndBug> <S2SV_StartBug> cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ; <S2SV_EndBug> ,<S2SV_ModStart> ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ; cpio -> extract_flags |= <S2SV_ModStart> ; cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS 
752,<S2SV_StartBug> while ( c != EOF && c != '\\n' ) { <S2SV_EndBug> <S2SV_StartBug> c = tok_nextc ( tok ) ; <S2SV_EndBug> ,"<S2SV_ModStart> const char * prefix , * p , * type_start ; <S2SV_ModStart> } if ( tok -> type_comments ) { p = tok -> start ; prefix = type_comment_prefix ; while ( * prefix && p < tok -> cur ) { if ( * prefix == '<S2SV_blank>' ) { while ( * p == '<S2SV_blank>' || * p == '\\t' ) { p ++ ; } } else if ( * prefix == * p ) { p ++ ; } else { break ; } prefix ++ ; } if ( ! * prefix ) { int is_type_ignore = 1 ; tok_backup ( tok , c ) ; type_start = p ; is_type_ignore = tok -> cur >= p + 6 && memcmp ( p , ""ignore"" , 6 ) == 0 ; p += 6 ; while ( is_type_ignore && p < tok -> cur ) { if ( * p == '#' ) break ; is_type_ignore = is_type_ignore && ( * p == '<S2SV_blank>' || * p == '\\t' ) ; p ++ ; } if ( is_type_ignore ) { if ( blankline ) { tok_nextc ( tok ) ; tok -> atbol = 1 ; } return TYPE_IGNORE ; } else { * p_start = ( char * ) type_start ; * p_end = tok -> cur ; return TYPE_COMMENT ; } } "
753,<S2SV_StartBug> LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> oxcf . starting_buffer_level = lc -> starting_buffer_level ; <S2SV_EndBug> ,<S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> alt_ref_source <S2SV_ModEnd> <S2SV_ModStart> alt_ref_source <S2SV_ModEnd> 
754,"<S2SV_StartBug> status = ksz8851ReadReg ( interface , KSZ8851_REG_ISR ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_LCIS ) ; <S2SV_EndBug> <S2SV_StartBug> status = ksz8851ReadReg ( interface , KSZ8851_REG_P1SR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & P1SR_OPERATION_DUPLEX ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( status & ISR_RXIS ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_RXIS ) ; <S2SV_EndBug> <S2SV_StartBug> frameCount = MSB ( ksz8851ReadReg ( interface , KSZ8851_REG_RXFCTR ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_IER , IER_LCIE | IER_RXIE ) ; <S2SV_EndBug> ","<S2SV_ModStart> KSZ8851_ISR ) ; if ( ( status & KSZ8851_ISR_LCIS <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_ISR , KSZ8851_ISR_LCIS <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_P1SR ) ; if ( ( status & KSZ8851_P1SR_LINK_GOOD ) != 0 ) { if ( ( status & KSZ8851_P1SR_OPERATION_SPEED <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_P1SR_OPERATION_DUPLEX <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_ISR_RXIS <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_ISR , KSZ8851_ISR_RXIS <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXFCTR <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_IER , KSZ8851_IER_LCIE | KSZ8851_IER_RXIE <S2SV_ModEnd> "
755,<S2SV_StartBug> convert_to_double_ex ( zval_affine_elem ) ; <S2SV_EndBug> <S2SV_StartBug> affine [ i ] = Z_DVAL_PP ( zval_affine_elem ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . x = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . y = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . width = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . height = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> ,<S2SV_ModStart> { zval dval ; dval = * * zval_affine_elem ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> <S2SV_ModStart> Z_DVAL ( dval ) ; } <S2SV_ModEnd> <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . x = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . y = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . width = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . height = <S2SV_ModStart> } 
756,<S2SV_StartBug> vp9_free_context_buffers ( cm ) ; <S2SV_EndBug> ,"<S2SV_ModStart> vp9_set_mb_mi ( cm , 0 , 0 ) ; "
757,"<S2SV_StartBug> __mincore_unmapped_range ( addr , end , vma , vec ) ; <S2SV_EndBug> <S2SV_StartBug> __mincore_unmapped_range ( addr , addr + PAGE_SIZE , <S2SV_EndBug> <S2SV_StartBug> if ( non_swap_entry ( entry ) ) { <S2SV_EndBug> ","<S2SV_ModStart> memset ( vec , 1 , nr <S2SV_ModEnd> <S2SV_ModStart> * vec = 0 <S2SV_ModEnd> <S2SV_ModStart> * vec = ! ! <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> "
758,"<S2SV_StartBug> buffer = zend_string_alloc ( len , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> zend_string_safe_alloc ( 1 , len , 0 <S2SV_ModEnd> "
759,<S2SV_StartBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) <S2SV_EndBug> ,<S2SV_ModStart> + <S2SV_ModEnd> <S2SV_ModStart> > vdev -> config_len ) { return ; } <S2SV_ModEnd> 
760,"<S2SV_StartBug> u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & value -> tv_nsec ) ; <S2SV_EndBug> ","<S2SV_ModStart> u32 rem ; value -> tv_sec = div_u64_rem ( <S2SV_ModEnd> <S2SV_ModStart> , NSEC_PER_SEC , & rem ) <S2SV_ModStart> tv_nsec = rem <S2SV_ModEnd> "
761,<S2SV_StartBug> ret = convert_ctx_accesses ( env ) ; <S2SV_EndBug> ,<S2SV_ModStart> sanitize_dead_code ( env ) ; if ( ret == 0 ) 
762,<S2SV_StartBug> # if CONFIG_MEM_MANAGER <S2SV_EndBug> <S2SV_StartBug> # else <S2SV_EndBug> ,<S2SV_ModStart> new_addr = realloc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
763,<S2SV_StartBug> if ( errcode != 0 ) <S2SV_EndBug> ,"<S2SV_ModStart> && state -> status == NULL ) state -> status = ""UNKNOWN_REASON"" <S2SV_ModEnd> "
764,"<S2SV_StartBug> if ( CheckMemoryOverflow ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse ) <S2SV_EndBug> <S2SV_StartBug> if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) <S2SV_EndBug> ",<S2SV_ModStart> HeapOverflowSanityCheck <S2SV_ModEnd> <S2SV_ModStart> HeapOverflowSanityCheck <S2SV_ModEnd> 
765,"<S2SV_StartBug> if ( ( r = sshbuf_get_u32 ( b , & comp -> type ) ) != 0 || <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
766,<S2SV_StartBug> if ( clone_info ) <S2SV_EndBug> <S2SV_StartBug> DeleteImageFromList ( & tmp ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( tmp == image2 ) image2 = ( Image * ) NULL ; 
767,"<S2SV_StartBug> int open_mode = opendata -> o_arg . open_flags & ( FMODE_READ | FMODE_WRITE | O_EXCL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( can_open_cached ( state , open_mode ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( can_open_cached ( state , open_mode ) ) { <S2SV_EndBug> <S2SV_StartBug> update_open_stateflags ( state , open_mode ) ; <S2SV_EndBug> <S2SV_StartBug> ! can_open_delegated ( delegation , open_mode ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( update_open_stateid ( state , NULL , & stateid , open_mode ) ) <S2SV_EndBug> ","<S2SV_ModStart> O_EXCL ; fmode_t fmode = opendata -> o_arg . fmode <S2SV_ModEnd> <S2SV_ModStart> fmode , <S2SV_ModStart> fmode , <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> "
768,<S2SV_StartBug> if ( vma ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
769,<S2SV_StartBug> bitmap -> compressed = FALSE ; <S2SV_EndBug> <S2SV_StartBug> bitmap -> length = DstWidth * DstHeight * GetBytesPerPixel ( bitmap -> format ) ; <S2SV_EndBug> ,<S2SV_ModStart> UINT32 size = DstWidth * DstHeight ; <S2SV_ModStart> if ( ( GetBytesPerPixel ( bitmap -> format ) == 0 ) || ( DstWidth == 0 ) || ( DstHeight == 0 ) || ( DstWidth > UINT32_MAX / DstHeight ) || ( size > ( UINT32_MAX / GetBytesPerPixel ( bitmap -> format ) ) ) ) return FALSE ; size *= GetBytesPerPixel ( bitmap -> format ) ; <S2SV_ModStart> size <S2SV_ModEnd> 
770,"<S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> int active_best_quality ; <S2SV_EndBug> <S2SV_StartBug> if ( frame_is_intra_only ( cm ) ) { <S2SV_EndBug> <S2SV_StartBug> active_best_quality = rc -> best_quality ; <S2SV_EndBug> <S2SV_StartBug> double last_boosted_q = vp9_convert_qindex_to_q ( qindex ) ; <S2SV_EndBug> <S2SV_StartBug> last_boosted_q * 0.75 ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( cm -> current_video_frame > 0 ) { <S2SV_EndBug> <S2SV_StartBug> active_best_quality = get_active_quality ( rc -> avg_frame_qindex [ KEY_FRAME ] , <S2SV_EndBug> <S2SV_StartBug> rc -> kf_boost , <S2SV_EndBug> <S2SV_StartBug> q_val = vp9_convert_qindex_to_q ( active_best_quality ) ; <S2SV_EndBug> <S2SV_StartBug> q_val * q_adj_factor ) ; <S2SV_EndBug> <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> if ( q < cpi -> cq_target_quality ) <S2SV_EndBug> <S2SV_StartBug> } else if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> active_best_quality = cpi -> cq_target_quality ; <S2SV_EndBug> <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) && <S2SV_EndBug> <S2SV_StartBug> ( active_best_quality < cpi -> cq_target_quality ) ) { <S2SV_EndBug> <S2SV_StartBug> # if LIMIT_QRANGE_FOR_ALTREF_AND_KEY <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced ) { <S2SV_EndBug> <S2SV_StartBug> * top_index = ( active_worst_quality + active_best_quality * 3 ) / 4 ; <S2SV_EndBug> <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_MULTIPLE_ARF <S2SV_EndBug> ","<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> const int cq_level = get_active_cq_level ( rc , oxcf ) ; <S2SV_ModStart> int * inter_minq ; ASSIGN_MINQ_TABLE ( cm -> bit_depth , inter_minq ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_kf_active_quality ( rc , <S2SV_ModEnd> <S2SV_ModStart> cm -> bit_depth <S2SV_ModEnd> <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> , cm -> bit_depth ) ; } <S2SV_ModEnd> <S2SV_ModStart> rc_mode == VPX_CQ <S2SV_ModEnd> <S2SV_ModStart> cq_level ) q = cq_level ; active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; <S2SV_ModEnd> <S2SV_ModStart> rc_mode == VPX_Q <S2SV_ModEnd> <S2SV_ModStart> cq_level ; } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; } } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth <S2SV_ModEnd> <S2SV_ModStart> rc_mode == VPX_Q ) { active_best_quality = cq_level <S2SV_ModEnd> <S2SV_ModStart> rc_mode == VPX_CQ <S2SV_ModEnd> <S2SV_ModStart> cq_level ) ) { active_best_quality = cq_level <S2SV_ModEnd> <S2SV_ModStart> { int qdelta = 0 ; vpx_clear_system_state ( ) ; <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> { qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 2.0 , cm -> bit_depth ) ; } else if ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) { qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 1.75 , cm -> bit_depth ) ; } * top_index = active_worst_quality + qdelta ; * top_index = ( * top_index > * bottom_index ) ? * top_index : * bottom_index <S2SV_ModEnd> <S2SV_ModStart> rc_mode == VPX_Q <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
771,<S2SV_StartBug> for ( j = 1 ; j <= len ; j ++ ) { <S2SV_EndBug> ,"<S2SV_ModStart> luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_array"" ) ; "
772,"<S2SV_StartBug> guint32 off = offset ; <S2SV_EndBug> <S2SV_StartBug> DebugLog ( ( ""parse_wbxml_tag<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\n"" , * level , offset ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , last_off <S2SV_ModStart> ; last_off = off <S2SV_ModStart> if ( off < last_off ) { THROW ( ReportedBoundsError ) ; } last_off = off ; "
773,"<S2SV_StartBug> Py_INCREF ( id ) ; <S2SV_EndBug> <S2SV_StartBug> PyDict_DelItemString ( value , ""$id"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( id == NULL ) { id = Py_None ; <S2SV_ModStart> } else { Py_INCREF ( id ) ; <S2SV_ModStart> } 
774,<S2SV_StartBug> case BGP_CAPCODE_RESTART : <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK_16BITS ( opt + i + 2 ) ; 
775,<S2SV_StartBug> j = scantable [ idx ++ ] ; <S2SV_EndBug> <S2SV_StartBug> j = scantable [ idx ++ ] ; <S2SV_EndBug> <S2SV_StartBug> } else if ( group == 21 ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( idx > 63 ) return AVERROR_INVALIDDATA ; 
776,"<S2SV_StartBug> static void extend_to_full_distribution ( vp9_prob * probs , vp9_prob p ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( probs , vp9_pareto8_full [ p = 0 ? 0 : p - 1 ] , <S2SV_EndBug> <S2SV_StartBug> MODEL_NODES * sizeof ( vp9_prob ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> 
777,"<S2SV_StartBug> return ( ( png_charp ) PNG_STRING_NEWLINE ""libpng<S2SV_blank>version<S2SV_blank>1.2.52<S2SV_blank>-<S2SV_blank>November<S2SV_blank>20,<S2SV_blank>2014"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1998-2014<S2SV_blank>Glenn<S2SV_blank>Randers-Pehrson"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1996-1997<S2SV_blank>Andreas<S2SV_blank>Dilger"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1995-1996<S2SV_blank>Guy<S2SV_blank>Eric<S2SV_blank>Schalnat,<S2SV_blank>Group<S2SV_blank>42,<S2SV_blank>Inc."" PNG_STRING_NEWLINE ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( png_charp ) ""libpng<S2SV_blank>version<S2SV_blank>1.2.52<S2SV_blank>-<S2SV_blank>November<S2SV_blank>20,<S2SV_blank>2014\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1998-2014<S2SV_blank>Glenn<S2SV_blank>Randers-Pehrson\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1996-1997<S2SV_blank>Andreas<S2SV_blank>Dilger\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1995-1996<S2SV_blank>Guy<S2SV_blank>Eric<S2SV_blank>Schalnat,<S2SV_blank>Group<S2SV_blank>42,<S2SV_blank>Inc."" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""libpng<S2SV_blank>version<S2SV_blank>1.2.54<S2SV_blank>-<S2SV_blank>November<S2SV_blank>12,<S2SV_blank>2015"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1998-2015<S2SV_blank>Glenn<S2SV_blank>Randers-Pehrson"" <S2SV_ModEnd> <S2SV_ModStart> ""libpng<S2SV_blank>version<S2SV_blank>1.2.54<S2SV_blank>-<S2SV_blank>November<S2SV_blank>12,<S2SV_blank>2015\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1998-2015<S2SV_blank>Glenn<S2SV_blank>Randers-Pehrson\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1996-1997<S2SV_blank>Andreas<S2SV_blank>Dilger\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1995-1996<S2SV_blank>Guy<S2SV_blank>Eric<S2SV_blank>Schalnat,<S2SV_blank>Group<S2SV_blank>42,<S2SV_blank>Inc."" <S2SV_ModEnd> "
778,<S2SV_StartBug> if ( cf_auth_type <= AUTH_TRUST ) { <S2SV_EndBug> ,"<S2SV_ModStart> ! client -> auth_user ) { disconnect_client ( client , true , ""client<S2SV_blank>password<S2SV_blank>pkt<S2SV_blank>before<S2SV_blank>startup<S2SV_blank>packet"" ) ; return false ; } if ( "
779,"<S2SV_StartBug> rc = cmd_start ( adata , cmdstr , flags ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( rc == IMAP_RES_CONTINUE ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( flags & IMAP_CMD_SINGLE ) { if ( adata -> nextcmd != adata -> lastcmd ) imap_exec ( adata , NULL , IMAP_CMD_POLL ) ; } <S2SV_ModStart> if ( ( flags & IMAP_CMD_SINGLE ) && ( adata -> nextcmd == adata -> lastcmd ) ) break ; "
780,<S2SV_StartBug> if ( mainprog_ptr -> width > INT_MAX / mainprog_ptr -> height ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( mainprog_ptr -> rgba_data = malloc ( rowbytes * mainprog_ptr -> height ) ) == NULL ) { <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rowbytes > INT_MAX / mainprog_ptr -> height ) { png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if ( "
781,"<S2SV_StartBug> ar2 -> intf [ 0 ] = interface ; <S2SV_EndBug> <S2SV_StartBug> r = usb_driver_claim_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] , ar2 ) ; <S2SV_EndBug> <S2SV_StartBug> ar2 -> ep [ 1 ] = & alt -> endpoint [ 0 ] . desc ; <S2SV_EndBug> <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> <S2SV_StartBug> goto fail3 ; <S2SV_EndBug> <S2SV_StartBug> fail3 : <S2SV_EndBug> <S2SV_StartBug> ati_remote2_urb_cleanup ( ar2 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , ""%s():<S2SV_blank>interface<S2SV_blank>0<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n"" , __func__ ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> if ( ( udev -> actconfig -> desc . bNumInterfaces < 2 ) || ! ar2 -> intf [ 1 ] ) { dev_err ( & interface -> dev , ""%s():<S2SV_blank>need<S2SV_blank>2<S2SV_blank>interfaces,<S2SV_blank>found<S2SV_blank>%d\\n"" , __func__ , udev -> actconfig -> desc . bNumInterfaces ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , ""%s():<S2SV_blank>interface<S2SV_blank>1<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n"" , __func__ ) ; r = - ENODEV ; goto fail2 ; } <S2SV_ModStart> fail3 <S2SV_ModEnd> <S2SV_ModStart> fail3 <S2SV_ModEnd> <S2SV_ModStart> fail3 <S2SV_ModEnd> <S2SV_ModStart> fail4 <S2SV_ModEnd> <S2SV_ModStart> fail4 : sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; fail3 : ati_remote2_urb_cleanup ( ar2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
782,"<S2SV_StartBug> pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size ) ; <S2SV_EndBug> ",<S2SV_ModStart> + EXTRA_BS_OFFSET 
783,<S2SV_StartBug> same_page : <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( page_count ( page ) <= 0 ) ) { if ( pages ) { spin_unlock ( ptl ) ; remainder = 0 ; err = - ENOMEM ; break ; } } 
784,<S2SV_StartBug> u8 odata [ 16 ] ; <S2SV_EndBug> ,<S2SV_ModStart> * odata = pctx -> odata ; u8 * idata = pctx -> idata <S2SV_ModEnd> 
785,<S2SV_StartBug> if ( status ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) { <S2SV_EndBug> <S2SV_StartBug> urb -> actual_length - 1 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ! urb -> actual_length ) { dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>empty<S2SV_blank>response,<S2SV_blank>exiting.\\n"" , __func__ ) ; return ; } if ( <S2SV_ModStart> ( <S2SV_ModStart> && ( <S2SV_ModEnd> <S2SV_ModStart> <= sizeof ( command_info -> result_buffer ) ) ) { memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1 "
786,"<S2SV_StartBug> struct mb_cache_entry * * pce ) <S2SV_EndBug> <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> again : <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev , <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( ce ) ) { <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_find_next ( ce , inode -> i_sb -> s_bdev , hash ) ; <S2SV_EndBug> ","<S2SV_ModStart> mb2_cache_entry <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_entry * ce ; struct mb2_cache <S2SV_ModEnd> <S2SV_ModStart> ce = mb2_cache_entry_find_first <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_entry_find_next ( ext4_mb_cache , ce <S2SV_ModEnd> "
787,"<S2SV_StartBug> if ( vm_flags & VM_NORESERVE ) <S2SV_EndBug> <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> hugepage_subpool_get_pages ( spool <S2SV_ModEnd> <S2SV_ModStart> hugepage_subpool_put_pages ( spool <S2SV_ModEnd> 
788,"<S2SV_StartBug> lua_pushvalue ( L , i ) ; <S2SV_EndBug> ","<S2SV_ModStart> luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_check"" ) ; "
789,<S2SV_StartBug> drop_futex_key_refs ( & q -> key ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
790,"<S2SV_StartBug> COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! COM_CompareExtension ( filename , "".txt"" ) ) { Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".txt\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" ) ; return ; } "
791,<S2SV_StartBug> if ( sk_hashed ( sk ) ) { <S2SV_EndBug> <S2SV_StartBug> write_lock_bh ( & ping_table . lock ) ; <S2SV_EndBug> <S2SV_StartBug> write_unlock_bh ( & ping_table . lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> write_lock_bh ( & ping_table . lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> 
792,<S2SV_StartBug> msc -> ntouches = 0 ; <S2SV_EndBug> <S2SV_StartBug> npoints = ( size - 6 ) / 8 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( npoints > 15 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>TRACKPAD_REPORT_ID\\n"" , size ) ; return 0 ; } <S2SV_ModStart> if ( npoints > 15 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>MOUSE_REPORT_ID\\n"" , size ) ; return 0 ; } "
793,"<S2SV_StartBug> int hdrlen ; <S2SV_EndBug> <S2SV_StartBug> if ( caplen < 3 ) { <S2SV_EndBug> <S2SV_StartBug> switch ( ( fc >> 10 ) & 0x3 ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> case 0x03 : <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( ( fc >> 14 ) & 0x3 ) { <S2SV_EndBug> <S2SV_StartBug> case 0x00 : <S2SV_EndBug> <S2SV_StartBug> case 0x01 : <S2SV_EndBug> <S2SV_StartBug> case 0x02 : <S2SV_EndBug> <S2SV_StartBug> if ( ! ( fc & ( 1 << 6 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case 0x03 : <S2SV_EndBug> <S2SV_StartBug> if ( ! ( fc & ( 1 << 6 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> caplen -= hdrlen ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> u_int <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( caplen < 3 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ; switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return hdrlen ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> <S2SV_ModStart> caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> + 2 ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen <S2SV_ModEnd> <S2SV_ModStart> FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> <S2SV_ModStart> caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> + 2 <S2SV_ModStart> caplen -= 8 ; hdrlen += 8 ; <S2SV_ModStart> if ( ndo -> ndo_vflag ) <S2SV_ModStart> FC_SRC_ADDRESSING_MODE ( fc ) <S2SV_ModEnd> <S2SV_ModStart> FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) <S2SV_ModEnd> <S2SV_ModStart> FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) <S2SV_ModEnd> <S2SV_ModStart> FC_ADDRESSING_MODE_SHORT <S2SV_ModEnd> <S2SV_ModStart> FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> <S2SV_ModStart> caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModEnd> <S2SV_ModStart> caplen -= 2 ; hdrlen += 2 ; <S2SV_ModStart> FC_ADDRESSING_MODE_LONG <S2SV_ModEnd> <S2SV_ModStart> FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> <S2SV_ModStart> caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModEnd> <S2SV_ModStart> caplen -= 8 ; hdrlen += 8 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> hdrlen <S2SV_ModEnd> "
794,<S2SV_StartBug> struct pmu * leader_pmu = event -> group_leader -> pmu ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( is_software_event ( event ) ) return 1 
795,"<S2SV_StartBug> id = ipc_addid ( & msg_ids ( ns ) , & msq -> q_perm , ns -> msg_ctlmni ) ; <S2SV_EndBug> <S2SV_StartBug> msq -> q_stime = msq -> q_rtime = 0 ; <S2SV_EndBug> ",<S2SV_ModStart> msq -> q_stime = msq -> q_rtime = 0 ; msq -> q_ctime = get_seconds ( ) ; msq -> q_cbytes = msq -> q_qnum = 0 ; msq -> q_qbytes = ns -> msg_ctlmnb ; msq -> q_lspid = msq -> q_lrpid = 0 ; INIT_LIST_HEAD ( & msq -> q_messages ) ; INIT_LIST_HEAD ( & msq -> q_receivers ) ; INIT_LIST_HEAD ( & msq -> q_senders ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
796,<S2SV_StartBug> VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ; <S2SV_EndBug> <S2SV_StartBug> vips_image_pio_input ( load -> real ) ) <S2SV_EndBug> <S2SV_StartBug> return ( NULL ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; if ( load -> error ) return ( NULL <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> { vips_operation_invalidate ( VIPS_OPERATION ( load ) ) ; load -> error = TRUE ; return ( NULL ) ; } <S2SV_ModEnd> 
797,"<S2SV_StartBug> vpx_memset ( x -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( x -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( x -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( x -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
798,"<S2SV_StartBug> if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> arg = ( arg != NULL ) ? arg : """" ; "
799,<S2SV_StartBug> line += PKT_LEN_SIZE ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ; 
800,"<S2SV_StartBug> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; <S2SV_EndBug> ","<S2SV_ModStart> lfi , fname , UDF_NAME_LEN <S2SV_ModEnd> "
801,<S2SV_StartBug> outpos += <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sendClean ( outputbuffer ) ; 
802,"<S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 * <S2SV_EndBug> ","<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
803,"<S2SV_StartBug> if ( copy_from_user ( & sas , optval , len ) ) <S2SV_EndBug> <S2SV_StartBug> len = min_t ( size_t , len , sizeof ( sas ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> len = min_t ( size_t , len , sizeof ( sas ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
804,<S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( int ) 
805,<S2SV_StartBug> char buffer [ 4096 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( name_len > sizeof ( buffer ) - 2 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> <S2SV_StartBug> if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) { <S2SV_EndBug> <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> ,"<S2SV_ModStart> * buf , * buf2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> efree ( buf ) ; <S2SV_ModEnd> <S2SV_ModStart> buf2 = estrndup ( value , value_len ) ; <S2SV_ModEnd> <S2SV_ModStart> efree ( buf ) ; efree ( buf2 ) ; <S2SV_ModEnd> "
806,<S2SV_StartBug> if ( ( exit_intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR && <S2SV_EndBug> ,<S2SV_ModStart> is_nmi ( exit_intr_info <S2SV_ModEnd> 
807,<S2SV_StartBug> vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> return vp9_read_bit ( r ) ? ( vp9_read_bit ( r ) ? REFERENCE_MODE_SELECT <S2SV_EndBug> ,<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_read_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_read_bit <S2SV_ModEnd> 
808,<S2SV_StartBug> return vp9_filteredinterp_filters1000 ; <S2SV_EndBug> <S2SV_StartBug> return vp9_filteredinterp_filters875 ; <S2SV_EndBug> <S2SV_StartBug> return vp9_filteredinterp_filters750 ; <S2SV_EndBug> <S2SV_StartBug> return vp9_filteredinterp_filters625 ; <S2SV_EndBug> <S2SV_StartBug> return vp9_filteredinterp_filters500 ; <S2SV_EndBug> ,<S2SV_ModStart> filteredinterp_filters1000 <S2SV_ModEnd> <S2SV_ModStart> filteredinterp_filters875 <S2SV_ModEnd> <S2SV_ModStart> filteredinterp_filters750 <S2SV_ModEnd> <S2SV_ModStart> filteredinterp_filters625 <S2SV_ModEnd> <S2SV_ModStart> filteredinterp_filters500 <S2SV_ModEnd> 
809,"<S2SV_StartBug> p += 2 ; <S2SV_EndBug> <S2SV_StartBug> if ( * p == FAC_NATIONAL_RAND ) <S2SV_EndBug> <S2SV_StartBug> p += 4 ; <S2SV_EndBug> <S2SV_StartBug> l = p [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & facilities -> source_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & facilities -> dest_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & facilities -> fail_call , p + 2 , AX25_ADDR_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & facilities -> fail_addr , p + 3 , ROSE_ADDR_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( * p == FAC_NATIONAL_DIGIS ) { <S2SV_EndBug> ",<S2SV_ModStart> if ( len < 2 ) return - 1 ; <S2SV_ModStart> len < 3 ) return - 1 ; if ( <S2SV_ModStart> if ( len < 4 ) return - 1 ; <S2SV_ModStart> if ( len < 2 ) return - 1 ; l = p [ 1 ] ; if ( len < 2 + l ) return - 1 <S2SV_ModEnd> <S2SV_ModStart> if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> if ( l < 1 + ROSE_ADDR_LEN ) return - 1 ; <S2SV_ModStart> if ( l % AX25_ADDR_LEN ) return - 1 ; 
810,"<S2SV_StartBug> static void update_coef_probs_common ( vp9_writer * const bc , VP9_COMP * cpi , <S2SV_EndBug> <S2SV_StartBug> vp9_coeff_stats * frame_branch_ct ) { <S2SV_EndBug> <S2SV_StartBug> cpi -> common . fc . coef_probs [ tx_size ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; <S2SV_EndBug> <S2SV_StartBug> const vp9_prob oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; <S2SV_EndBug> <S2SV_StartBug> old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_bit ( bc , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_bit ( bc , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; <S2SV_EndBug> <S2SV_StartBug> const vp9_prob upd = DIFF_UPDATE_PROB ; <S2SV_EndBug> <S2SV_StartBug> old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( bc , u , upd ) ; <S2SV_EndBug> <S2SV_StartBug> case ONE_LOOP : <S2SV_EndBug> <S2SV_StartBug> const int prev_coef_contexts_to_update = <S2SV_EndBug> <S2SV_StartBug> vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; <S2SV_EndBug> <S2SV_StartBug> if ( l >= prev_coef_contexts_to_update || <S2SV_EndBug> <S2SV_StartBug> if ( t == PIVOT_NODE ) <S2SV_EndBug> <S2SV_StartBug> old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; <S2SV_EndBug> <S2SV_StartBug> if ( s > 0 && newp != * oldp ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> vp9_write_bit ( bc , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( bc , 0 , upd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( bc , u , upd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_bit ( bc , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> , vp9_coeff_probs_model * new_coef_probs ) { vp9_coeff_probs_model * old_coef_probs = <S2SV_ModEnd> <S2SV_ModStart> -> coef_probs [ tx_size ] ; const vpx_prob upd = DIFF_UPDATE_PROB ; const int entropy_nodes_update = UNCONSTRAINED_NODES ; int i , j , k , l , t ; int stepsize = cpi -> sf . coeff_prob_appx_step <S2SV_ModEnd> <S2SV_ModStart> vpx_prob newp = new_coef_probs <S2SV_ModEnd> <S2SV_ModStart> vpx_prob oldp = old_coef_probs <S2SV_ModEnd> <S2SV_ModStart> old_coef_probs <S2SV_ModEnd> <S2SV_ModStart> , stepsize <S2SV_ModStart> vpx_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; vpx_prob * oldp = old_coef_probs <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> old_coef_probs <S2SV_ModEnd> <S2SV_ModStart> , stepsize <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int updates = 0 ; int noupdates_before_first = 0 ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS <S2SV_ModEnd> <S2SV_ModStart> vpx_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; vpx_prob * oldp = old_coef_probs <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> old_coef_probs <S2SV_ModEnd> <S2SV_ModStart> , stepsize ) ; } else { <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write_bit <S2SV_ModEnd> "
811,<S2SV_StartBug> if ( ! retval ) { <S2SV_EndBug> ,"<S2SV_ModStart> r = k5memdup0 ( realm , rlen , & retval ) ; <S2SV_ModEnd> "
812,"<S2SV_StartBug> void vp9_fht16x16_sse2 ( const int16_t * input , int16_t * output , <S2SV_EndBug> <S2SV_StartBug> vp9_fdct16x16_sse2 ( input , output , stride ) ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_fdct16x16_sse2 <S2SV_ModEnd> 
813,<S2SV_StartBug> if ( avctx -> codec_id == AV_CODEC_ID_MPEG4 && avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) <S2SV_EndBug> ,<S2SV_ModStart> c -> mpeg4_studio_profile <S2SV_ModEnd> 
814,<S2SV_StartBug> int c_sz ; <S2SV_EndBug> ,<S2SV_ModStart> ; ( void ) _aux 
815,"<S2SV_StartBug> rc = expandRegular ( fi , fn , psm , nodigest , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> 0 , "
816,"<S2SV_StartBug> size_t ss = CDF_SEC_SIZE ( h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( pos > ss * sst -> sst_len ) { <S2SV_EndBug> <S2SV_StartBug> pos , ss * sst -> sst_len ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> CDF_SHORT_SEC_SIZE <S2SV_ModEnd> <S2SV_ModStart> CDF_SEC_SIZE ( h ) <S2SV_ModEnd> <S2SV_ModStart> CDF_SEC_SIZE ( h ) <S2SV_ModEnd> 
817,<S2SV_StartBug> struct fb_vblank vblank ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & vblank , 0 , sizeof ( vblank ) ) "
818,<S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ret >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> ext4_free_io_end ( io ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> struct ext4_inode_info * ei = EXT4_I ( inode ) ; unsigned long flags ; int ret <S2SV_ModEnd> <S2SV_ModStart> < <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & inode -> i_mutex ) ; return ; } spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModStart> spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModEnd> <S2SV_ModStart> ext4_free_io_end ( io ) ; "
819,<S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> ,<S2SV_ModStart> n2size < 1 ) <S2SV_ModEnd> 
820,<S2SV_StartBug> if ( s ) { <S2SV_EndBug> <S2SV_StartBug> struct unix_sock * u = unix_sk ( s ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock ( & unix_gc_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> spin_lock ( & unix_gc_lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } fp -> f_cred -> user -> unix_inflight ++ ; <S2SV_ModStart>  <S2SV_ModEnd> 
821,<S2SV_StartBug> BOOL ret = FALSE ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> data = NULL ; <S2SV_EndBug> <S2SV_StartBug> ret = TRUE ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> return TRUE ; err : sud -> directory <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> FALSE <S2SV_ModEnd> 
822,"<S2SV_StartBug> in_uint16_le ( s , length ) ; <S2SV_EndBug> <S2SV_StartBug> in_uint8 ( s , type ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct stream packet = * s ; <S2SV_ModStart> if ( ! s_check_rem ( s , length + 7 ) ) { rdp_protocol_error ( ""process_secondary_order(),<S2SV_blank>next<S2SV_blank>order<S2SV_blank>pointer<S2SV_blank>would<S2SV_blank>overrun<S2SV_blank>stream"" , & packet ) ; } "
823,<S2SV_StartBug> if ( cpi -> common . frame_type == KEY_FRAME ) { <S2SV_EndBug> <S2SV_StartBug> cpi -> rc . key_frame_rate_correction_factor = factor ; <S2SV_EndBug> <S2SV_StartBug> ! cpi -> rc . is_src_frame_alt_ref && <S2SV_EndBug> <S2SV_StartBug> ! ( cpi -> use_svc && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) ) <S2SV_EndBug> <S2SV_StartBug> cpi -> rc . rate_correction_factor = factor ; <S2SV_EndBug> ,"<S2SV_ModStart> RATE_CONTROL * const rc = & cpi -> rc ; factor /= rcf_mult [ cpi -> rc . frame_size_selector ] ; factor = fclamp ( factor , MIN_BPB_FACTOR , MAX_BPB_FACTOR ) ; <S2SV_ModStart> rc -> rate_correction_factors [ KF_STD ] = factor ; } else if ( cpi -> oxcf . pass == 2 ) { RATE_FACTOR_LEVEL rf_lvl = cpi -> twopass . gf_group . rf_level [ cpi -> twopass . gf_group . index ] ; rc -> rate_correction_factors [ rf_lvl ] <S2SV_ModEnd> <S2SV_ModStart> rc -> <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( <S2SV_ModStart> rc_mode != VPX_CBR || cpi -> oxcf . gf_cbr_boost_pct > 20 ) ) rc -> rate_correction_factors [ GF_ARF_STD ] <S2SV_ModEnd> <S2SV_ModStart> rc -> rate_correction_factors [ INTER_NORMAL ] <S2SV_ModEnd> "
824,<S2SV_StartBug> mutex_init ( & tu -> tread_sem ) ; <S2SV_EndBug> ,<S2SV_ModStart> ioctl_lock <S2SV_ModEnd> 
825,<S2SV_StartBug> ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( u1_nal_ref_idc != 0 ) { if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) { memcpy ( ( void * ) ps_dec -> ps_dpb_cmds , ( void * ) ( & ( ps_dec -> s_dpb_cmds_scratch ) ) , sizeof ( dpb_commands_t ) ) ; } } "
826,<S2SV_StartBug> char buf [ 32 ] ; <S2SV_EndBug> <S2SV_StartBug> char buf [ 100 ] ; <S2SV_EndBug> ,<S2SV_ModStart> 100 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
827,<S2SV_StartBug> temp = ( struct sackhole * ) <S2SV_EndBug> <S2SV_StartBug> temp = ( struct sackhole * ) <S2SV_EndBug> ,<S2SV_ModStart> if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ; <S2SV_ModStart> if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ; 
828,"<S2SV_StartBug> ""The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request:<S2SV_blank>%s"" , <S2SV_EndBug> ","<S2SV_ModStart> ""The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request"" ) , <S2SV_ModEnd> "
829,"<S2SV_StartBug> n = s -> method -> ssl_get_message ( s , <S2SV_EndBug> <S2SV_StartBug> if ( ! ok ) return ( ( int ) n ) ; <S2SV_EndBug> <S2SV_StartBug> # ifndef OPENSSL_NO_PSK <S2SV_EndBug> <S2SV_StartBug> if ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK ) <S2SV_EndBug> ","<S2SV_ModStart> EVP_MD_CTX_init ( & md_ctx ) ; <S2SV_ModStart> ; alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey <S2SV_ModStart> if ( alg_k & ( SSL_kDHE | SSL_kECDHE ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } <S2SV_ModStart> alg_k & SSL_kPSK ) { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = NULL ; } # endif s -> s3 -> tmp . reuse_message = 1 ; return ( 1 ) ; } param = p = ( unsigned char * ) s -> init_msg ; if ( s -> session -> sess_cert != NULL ) { # ifndef OPENSSL_NO_RSA if ( s -> session -> sess_cert -> peer_rsa_tmp != NULL ) { RSA_free ( s -> session -> sess_cert -> peer_rsa_tmp ) ; s -> session -> sess_cert -> peer_rsa_tmp = NULL ; } # endif # ifndef OPENSSL_NO_DH if ( s -> session -> sess_cert -> peer_dh_tmp ) { DH_free ( s -> session -> sess_cert -> peer_dh_tmp ) ; s -> session -> sess_cert -> peer_dh_tmp = NULL ; } # endif # ifndef OPENSSL_NO_ECDH if ( s -> session -> sess_cert -> peer_ecdh_tmp ) { EC_KEY_free ( s -> session -> sess_cert -> peer_ecdh_tmp ) ; s -> session -> sess_cert -> peer_ecdh_tmp = NULL ; } # endif } else { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; } param_len = 0 ; alg_a = <S2SV_ModStart> algorithm_auth <S2SV_ModEnd> "
830,"<S2SV_StartBug> OPJ_UINT32 x , y ; <S2SV_EndBug> <S2SV_StartBug> x = y = 0U ; <S2SV_EndBug> <S2SV_StartBug> * pix = c1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> return OPJ_TRUE ; <S2SV_EndBug> ","<S2SV_ModStart> , written <S2SV_ModStart> written = <S2SV_ModStart> ; written ++ <S2SV_ModStart> written ++ ; <S2SV_ModStart> if ( written != width * height ) { fprintf ( stderr , ""warning,<S2SV_blank>image\'s<S2SV_blank>actual<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>advertized<S2SV_blank>one\\n"" ) ; return OPJ_FALSE ; } "
831,"<S2SV_StartBug> int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <S2SV_EndBug> ",<S2SV_ModStart> | O_NOFOLLOW 
832,"<S2SV_StartBug> l2tp_proto_ver_print ( netdissect_options * ndo , const uint16_t * dat ) <S2SV_EndBug> ","<S2SV_ModStart> , u_int length ) { if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModEnd> "
833,"<S2SV_StartBug> kvmclock_reset ( vcpu ) ; <S2SV_EndBug> <S2SV_StartBug> vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vcpu -> arch . time_offset & <S2SV_EndBug> <S2SV_StartBug> vcpu -> arch . time_page = <S2SV_EndBug> <S2SV_StartBug> gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ; <S2SV_EndBug> ","<S2SV_ModStart> u64 gpa_offset ; <S2SV_ModStart> gpa_offset <S2SV_ModEnd> <S2SV_ModStart> gpa_offset <S2SV_ModEnd> <S2SV_ModStart> if ( kvm_gfn_to_hva_cache_init <S2SV_ModEnd> <S2SV_ModStart> & vcpu -> arch . pv_time , data & ~ 1ULL ) ) vcpu -> arch . pv_time_enabled = false ; else vcpu -> arch . pv_time_enabled = true <S2SV_ModEnd> "
834,<S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC ) && * rsize >= 90 && rdesc [ 83 ] == 0x26 && <S2SV_EndBug> <S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC_REL_ABS ) && * rsize >= 50 && <S2SV_EndBug> ,<S2SV_ModStart> 91 <S2SV_ModEnd> <S2SV_ModStart> 51 <S2SV_ModEnd> 
835,"<S2SV_StartBug> static int enable ( void ) { <S2SV_EndBug> <S2SV_StartBug> LOG_INFO ( ""%s"" , __func__ ) ; <S2SV_EndBug> ","<S2SV_ModStart> bool start_restricted <S2SV_ModEnd> <S2SV_ModStart> LOG_TAG , ""%s:<S2SV_blank>start<S2SV_blank>restricted<S2SV_blank>=<S2SV_blank>%d"" , __func__ , start_restricted ) ; restricted_mode = start_restricted <S2SV_ModEnd> "
836,"<S2SV_StartBug> if ( ! file || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ","<S2SV_ModStart> size_t data_size = 0 ; <S2SV_ModStart> , & data_size <S2SV_ModStart> ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } "
837,<S2SV_StartBug> return 1000000 - count ; <S2SV_EndBug> ,<S2SV_ModStart> const uint32_t max_stack = 1000000 ; if ( count > max_stack ) return 0 ; return max_stack <S2SV_ModEnd> 
838,<S2SV_StartBug> while ( * s && * s != '}' ) { <S2SV_EndBug> <S2SV_StartBug> if ( * s == '\\n' ) * s = '<S2SV_blank>' ; <S2SV_EndBug> <S2SV_StartBug> if ( ( * s == '<S2SV_blank>' || * s == '\\n' ) && ( s [ 1 ] == '<S2SV_blank>' || s [ 1 ] == '\\n' ) ) s ++ ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } if ( ( * s == '<S2SV_blank>' ) && ( s [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> s [ 1 ] == '\\n' || s [ 1 ] == 0 ) ) { s ++ ; } else { * t ++ = * s ++ ; } } * t = 0 ; s = t = str ; while ( * s ) { if ( * s == '.' ) { period = 1 ; * t ++ = * s ++ ; } else if ( isdigit ( * s ) ) { * t ++ = * s ++ ; } else if ( period ) { while ( t > str && t [ - 1 ] == '0' ) { t -- ; } if ( t > str && t [ - 1 ] == '.' ) { t -- ; if ( t > str && ! isdigit ( t [ - 1 ] ) ) { * t ++ = '0' ; } } period = 0 ; * t ++ = * s ++ ; } else { period = 0 ; * t ++ = * s ++ ; } } * t = 0 ; s = t = str ; while ( * s ) { if ( * s == '-' && s [ 1 ] == '0' && s [ 2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
839,"<S2SV_StartBug> int res , ret ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( uaddr == uaddr2 ) return - EINVAL 
840,"<S2SV_StartBug> static void iwl_sta_ucode_activate ( struct iwl_priv * priv , u8 sta_id ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( sta_id >= IWLAGN_STATION_COUNT ) { IWL_ERR ( priv , ""invalid<S2SV_blank>sta_id<S2SV_blank>%u"" , sta_id ) ; return - EINVAL ; } <S2SV_ModStart> return 0 ; "
841,<S2SV_StartBug> int remaining = s -> icy_metaint - s -> icy_data_read ; <S2SV_EndBug> ,<S2SV_ModStart> uint64_t remaining ; if ( s -> icy_metaint < s -> icy_data_read ) return AVERROR_INVALIDDATA ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
842,<S2SV_StartBug> end = dup ; <S2SV_EndBug> ,<S2SV_ModStart> if ( dup == NULL ) { return PyErr_NoMemory ( ) ; } 
843,<S2SV_StartBug> netdev -> hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
844,<S2SV_StartBug> if ( split_flag ) { <S2SV_EndBug> ,<S2SV_ModStart> && size >= MIN_BLOCK_SIZE 
845,<S2SV_StartBug> if ( count < sizeof ( cmd ) ) { <S2SV_EndBug> ,<S2SV_ModStart> WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if ( 
846,"<S2SV_StartBug> sprintf ( descriptor -> msg , ""\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" , <S2SV_EndBug> <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug> ","<S2SV_ModStart> ""\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" <S2SV_ModEnd> <S2SV_ModStart> intptr_t <S2SV_ModEnd> <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) "
847,"<S2SV_StartBug> mark_desktop_file_trusted ( job , <S2SV_EndBug> ",<S2SV_ModStart> mark_desktop_file_executable <S2SV_ModEnd> 
848,<S2SV_StartBug> return 1000000 - count ; <S2SV_EndBug> ,<S2SV_ModStart> const uint32_t max_stack = 1000000 ; if ( count > max_stack ) return 0 ; return max_stack <S2SV_ModEnd> 
849,<S2SV_StartBug> msg -> msg_namelen = sizeof ( * sipx ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( sipx ) { sipx -> sipx_family = AF_IPX ; sipx -> sipx_port = ipx -> ipx_source . sock ; memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ) ; sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net ; sipx -> sipx_type = ipx -> ipx_type ; sipx -> sipx_zero = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> "
850,<S2SV_StartBug> if ( gfs ) <S2SV_EndBug> ,<S2SV_ModStart> last_name = 0 ; 
851,<S2SV_StartBug> if ( ! addr || addr -> sa_family != AF_BLUETOOTH ) <S2SV_EndBug> ,<S2SV_ModStart> ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_sco ) 
852,<S2SV_StartBug> down_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( id . index > UINT_MAX - kcontrol -> count ) goto error ; 
