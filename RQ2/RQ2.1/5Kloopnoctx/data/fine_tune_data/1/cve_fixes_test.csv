,source,target
0,<S2SV_StartBug> sock_put ( skpair ) ; <S2SV_EndBug> ,"<S2SV_ModStart> unix_dgram_peer_wake_disconnect ( sk , skpair ) ; "
1,"<S2SV_StartBug> int_mv * ref_mv , <S2SV_EndBug> <S2SV_StartBug> int64_t tx_size_diff [ TX_MODES ] , <S2SV_EndBug> <S2SV_StartBug> int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] ) { <S2SV_EndBug> <S2SV_StartBug> ctx -> best_mode_index = mode_index ; <S2SV_EndBug> <S2SV_StartBug> ctx -> best_ref_mv [ 0 ] . as_int = ref_mv -> as_int ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( ctx -> tx_rd_diff , tx_size_diff , sizeof ( ctx -> tx_rd_diff ) ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , int skippable <S2SV_ModStart> skippable = skippable ; ctx -> <S2SV_ModStart> mbmi_ext = * x -> mbmi_ext <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> "
2,<S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK2 ( * ext , sizeof ( a ) <S2SV_ModEnd> "
3,"<S2SV_StartBug> cm -> allow_comp_inter_inter = 0 ; <S2SV_EndBug> <S2SV_StartBug> cm -> allow_comp_inter_inter = 1 ; <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> const int64_t * mode_thresh = cpi -> rd_prediction_type_threshes [ frame_type ] ; <S2SV_EndBug> <S2SV_StartBug> const int64_t * filter_thresh = cpi -> rd_filter_threshes [ frame_type ] ; <S2SV_EndBug> <S2SV_StartBug> if ( frame_type == ALTREF_FRAME || ! cm -> allow_comp_inter_inter ) <S2SV_EndBug> <S2SV_StartBug> else if ( mode_thresh [ COMPOUND_REFERENCE ] > mode_thresh [ SINGLE_REFERENCE ] && <S2SV_EndBug> <S2SV_StartBug> mode_thresh [ COMPOUND_REFERENCE ] > <S2SV_EndBug> <S2SV_StartBug> mode_thresh [ REFERENCE_MODE_SELECT ] && <S2SV_EndBug> <S2SV_StartBug> else if ( mode_thresh [ SINGLE_REFERENCE ] > mode_thresh [ REFERENCE_MODE_SELECT ] ) <S2SV_EndBug> <S2SV_StartBug> if ( cm -> interp_filter == SWITCHABLE ) { <S2SV_EndBug> <S2SV_StartBug> cm -> interp_filter = EIGHTTAP_SMOOTH ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> const int diff = ( int ) ( cpi -> rd_comp_pred_diff [ i ] / cm -> MBs ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> const int64_t diff = cpi -> rd_filter_diff [ i ] / cm -> MBs ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> single_count_zero += cm -> counts . comp_inter [ i ] [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> comp_count_zero += cm -> counts . comp_inter [ i ] [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( cm -> counts . comp_inter ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( cm -> counts . comp_inter ) ; <S2SV_EndBug> <S2SV_StartBug> count4x4 += cm -> counts . tx . p32x32 [ i ] [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> count4x4 += cm -> counts . tx . p16x16 [ i ] [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> count4x4 += cm -> counts . tx . p8x8 [ i ] [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> count8x8_lp += cm -> counts . tx . p32x32 [ i ] [ TX_8X8 ] ; <S2SV_EndBug> <S2SV_StartBug> count8x8_lp += cm -> counts . tx . p16x16 [ i ] [ TX_8X8 ] ; <S2SV_EndBug> <S2SV_StartBug> count8x8_8x8p += cm -> counts . tx . p8x8 [ i ] [ TX_8X8 ] ; <S2SV_EndBug> <S2SV_StartBug> count16x16_16x16p += cm -> counts . tx . p16x16 [ i ] [ TX_16X16 ] ; <S2SV_EndBug> <S2SV_StartBug> count16x16_lp += cm -> counts . tx . p32x32 [ i ] [ TX_16X16 ] ; <S2SV_EndBug> <S2SV_StartBug> count32x32 += cm -> counts . tx . p32x32 [ i ] [ TX_32X32 ] ; <S2SV_EndBug> <S2SV_StartBug> reset_skip_txfm_size ( cm , TX_8X8 ) ; <S2SV_EndBug> <S2SV_StartBug> reset_skip_txfm_size ( cm , TX_4X4 ) ; <S2SV_EndBug> <S2SV_StartBug> reset_skip_txfm_size ( cm , TX_16X16 ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> interp_filter = SWITCHABLE ; <S2SV_EndBug> ","<S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> ; RD_OPT * const rd_opt = & cpi -> rd ; FRAME_COUNTS * counts = cpi -> td . counts ; RD_COUNTS * const rdc = & cpi -> td . rd_counts <S2SV_ModStart> int64_t * const mode_thrs = rd_opt -> prediction_type_threshes <S2SV_ModEnd> <S2SV_ModStart> int64_t * const filter_thrs = rd_opt -> filter_threshes <S2SV_ModEnd> <S2SV_ModStart> const int is_alt_ref = <S2SV_ModEnd> <S2SV_ModStart> ; if ( is_alt_ref || ! cpi <S2SV_ModEnd> <S2SV_ModStart> mode_thrs <S2SV_ModEnd> <S2SV_ModStart> mode_thrs <S2SV_ModEnd> <S2SV_ModStart> mode_thrs <S2SV_ModEnd> <S2SV_ModStart> mode_thrs <S2SV_ModEnd> <S2SV_ModStart> mode_thrs <S2SV_ModEnd> <S2SV_ModStart> mode_thrs <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_interp_filter ( filter_thrs , is_alt_ref ) ; <S2SV_ModEnd> <S2SV_ModStart> mode_thrs [ i ] = ( mode_thrs [ i ] + rdc -> comp_pred_diff <S2SV_ModEnd> <S2SV_ModStart> / 2 ; <S2SV_ModEnd> <S2SV_ModStart> ++ i ) filter_thrs [ i ] = ( filter_thrs [ i ] + rdc -> filter_diff <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> reset_skip_tx_size <S2SV_ModEnd> <S2SV_ModStart> reset_skip_tx_size <S2SV_ModEnd> <S2SV_ModStart> reset_skip_tx_size <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4,"<S2SV_StartBug> if ( test_bit ( EV_KEY , dev -> evbit ) && <S2SV_EndBug> ","<S2SV_ModStart> if ( old_keycode > KEY_MAX ) { dev_warn ( dev -> dev . parent ? : & dev -> dev , ""%s:<S2SV_blank>got<S2SV_blank>too<S2SV_blank>big<S2SV_blank>old<S2SV_blank>keycode<S2SV_blank>%#x\\n"" , __func__ , old_keycode ) ; } else "
5,"<S2SV_StartBug> goto out_nofree ; <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_name != NULL ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg -> msg_name , & sa , sizeof ( struct sockaddr_pn ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> sa ) ) ; * addr_len = sizeof ( sa ) ; } <S2SV_ModEnd> 
6,<S2SV_StartBug> if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) <S2SV_EndBug> ,<S2SV_ModStart> 4 <S2SV_ModEnd> 
7,"<S2SV_StartBug> if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) { <S2SV_EndBug> ",<S2SV_ModStart> | O_NOFOLLOW 
8,<S2SV_StartBug> saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> ,<S2SV_ModStart> INADDR_LOOPBACK <S2SV_ModEnd> 
9,"<S2SV_StartBug> FILE * fp = fopen ( dest_filename , ""w"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""wx"" <S2SV_ModEnd> "
10,"<S2SV_StartBug> * low = p - reg -> dmax ; <S2SV_EndBug> <S2SV_StartBug> ( pprev ? pprev : str ) , * low ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( p - str < reg -> dmax ) { * low = ( UChar * ) str ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , str , * low ) ; } else { <S2SV_ModStart> } "
11,<S2SV_StartBug> if ( hrtimer_cancel ( timer ) ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & pit -> pit_state . lock ) ; <S2SV_ModStart> mutex_unlock ( & pit -> pit_state . lock ) ; 
12,<S2SV_StartBug> vpx_roi_map_t roi = { 0 } ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & roi , 0 , sizeof ( roi ) ) <S2SV_ModEnd> "
13,"<S2SV_StartBug> static const char * parse_object ( cJSON * item , const char * value ) <S2SV_EndBug> <S2SV_StartBug> ep = value ; <S2SV_EndBug> <S2SV_StartBug> return value + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( item -> child = child = cJSON_New_Item ( ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ( value = skip ( parse_string ( child , skip ( value ) ) ) ) ) <S2SV_EndBug> <S2SV_StartBug> ep = value ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) <S2SV_EndBug> <S2SV_StartBug> child = new_item ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( value = skip ( parse_string ( child , skip ( value + 1 ) ) ) ) ) <S2SV_EndBug> <S2SV_StartBug> ep = value ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) <S2SV_EndBug> <S2SV_StartBug> return value + 1 ; <S2SV_EndBug> ","<S2SV_ModStart> , const char * * ep <S2SV_ModStart> * ep = value ; return 0 ; <S2SV_ModEnd> <S2SV_ModStart> return value + 1 ; <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! item -> child ) return 0 ; <S2SV_ModEnd> <S2SV_ModStart> , ep ) ) ; if ( ! value ) <S2SV_ModEnd> <S2SV_ModStart> * ep = value ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> , ep ) ) ; if ( ! value ) <S2SV_ModEnd> <S2SV_ModStart> child = new_item ; <S2SV_ModEnd> <S2SV_ModStart> , ep ) ) ; if ( ! value ) <S2SV_ModEnd> <S2SV_ModStart> * ep = value ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> , ep ) ) ; if ( ! value ) <S2SV_ModEnd> <S2SV_ModStart> return value + 1 ; * ep = value ; <S2SV_ModEnd> "
14,<S2SV_StartBug> ncomponents = bytestream2_get_be16u ( & s -> g ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( s -> image_offset_x || s -> image_offset_y ) { avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>image<S2SV_blank>offsets"" ) ; return AVERROR_PATCHWELCOME ; } "
15,"<S2SV_StartBug> addModuleArgument ( db , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> pParse <S2SV_ModEnd> 
16,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> av_freep ( & x -> buf ) ; x -> buf_size = 0 ; 
17,<S2SV_StartBug> new_fname = malloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
18,<S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ; 
19,"<S2SV_StartBug> strlcpy ( rakcipher . type , ""akcipher"" , sizeof ( rakcipher . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> 
20,"<S2SV_StartBug> void imap_quote_string ( char * dest , size_t dlen , const char * src ) <S2SV_EndBug> ","<S2SV_ModStart> , bool quote_backtick ) { const char * quote = ""`\\""\\\\"" ; if ( ! quote_backtick ) quote ++ <S2SV_ModEnd> "
21,<S2SV_StartBug> int r ; <S2SV_EndBug> <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug> ,"<S2SV_ModStart> , dontmax = 0 <S2SV_ModStart> if ( ( st . st_mode & S_IFREG ) == 0 || st . st_size <= 0 ) { st . st_size = 64 * 1024 ; dontmax = 1 ; } if ( ( r = sshbuf_allocate ( blob , st . st_size ) ) != 0 || ( dontmax && ( r = sshbuf_set_max_size ( blob , st . st_size ) ) != 0 ) ) return r ; "
22,<S2SV_StartBug> params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) <S2SV_EndBug> ,<S2SV_ModStart> INT_MAX <S2SV_ModEnd> 
23,"<S2SV_StartBug> memcpy ( output , input , sizeof ( uint8_t ) * length ) ; <S2SV_EndBug> ",<S2SV_ModStart> output [ 0 ] <S2SV_ModEnd> 
24,<S2SV_StartBug> if ( vcpu -> arch . time_page ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pv_time_enabled = false ; } <S2SV_ModEnd> 
25,"<S2SV_StartBug> handle = ion_handle_get_by_id ( client , data . handle . handle ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( handle ) ) <S2SV_EndBug> <S2SV_StartBug> ion_free ( client , handle ) ; <S2SV_EndBug> ","<S2SV_ModStart> mutex_lock ( & client -> lock ) ; handle = ion_handle_get_by_id_nolock <S2SV_ModEnd> <S2SV_ModStart> { mutex_unlock ( & client -> lock ) ; <S2SV_ModStart> } ion_free_nolock ( client , handle ) ; ion_handle_put_nolock ( handle ) ; mutex_unlock ( & client -> lock <S2SV_ModEnd> "
26,<S2SV_StartBug> int data_len = elt -> length - <S2SV_EndBug> <S2SV_StartBug> sizeof ( struct oz_get_desc_rsp ) + 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> u16 offs , total_size ; u8 data_len ; if ( elt -> length < sizeof ( struct oz_get_desc_rsp ) - 1 ) break ; <S2SV_ModEnd> <S2SV_ModStart> ( <S2SV_ModStart> ) - 1 ) ; offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , ""USB_REQ_GET_DESCRIPTOR<S2SV_blank>-<S2SV_blank>cnf\\n"" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_SET_INTERFACE_RSP : { struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_VENDOR_CLASS_RSP : { struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp <S2SV_ModStart>  <S2SV_ModEnd> "
27,"<S2SV_StartBug> growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; <S2SV_EndBug> ",<S2SV_ModStart> i + 
28,<S2SV_StartBug> if ( len < 5 ) <S2SV_EndBug> <S2SV_StartBug> return len ; <S2SV_EndBug> ,"<S2SV_ModStart> { # ifdef CONFIG_RETPOLINE WARN_ONCE ( ""Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>JMP<S2SV_blank>in<S2SV_blank>%ps\\n"" , ( void * ) addr ) ; # endif <S2SV_ModStart> } "
29,<S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> buffer_size -= ( size_t ) pkg_length ; <S2SV_ModStart> buffer_size -= ( size_t ) pkg_length ; <S2SV_ModStart> buffer_size -= ( size_t ) pkg_length ; 
30,<S2SV_StartBug> mapping = ( struct address_space * ) page_private ( page ) ; <S2SV_EndBug> ,<S2SV_ModStart> vma -> vm_file -> f_dentry -> d_inode -> i_mapping <S2SV_ModEnd> 
31,"<S2SV_StartBug> void fdct16_8col ( __m128i * in ) { <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_m24_m08 = pair_set_epi16 ( - cospi_24_64 , - cospi_8_64 ) ; <S2SV_EndBug> <S2SV_StartBug> v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m24_m08 ) ; <S2SV_EndBug> <S2SV_StartBug> v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ; <S2SV_EndBug> <S2SV_StartBug> u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; <S2SV_EndBug> <S2SV_StartBug> s [ 2 ] = _mm_sub_epi16 ( p [ 3 ] , t [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> s [ 3 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> static <S2SV_ModStart> ( int16_t ) <S2SV_ModStart> k__cospi_p08_m24 <S2SV_ModEnd> <S2SV_ModStart> cospi_8_64 , - cospi_24_64 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 3 ] = _mm_madd_epi16 ( u [ 3 <S2SV_ModEnd> <S2SV_ModStart> v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p08_m24 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p08_m24 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ; <S2SV_ModStart> _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ; s [ 3 ] = <S2SV_ModStart> 4 ] = _mm_sub_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 5 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
32,<S2SV_StartBug> if ( pes_signal != 1 || pes_header_data_length == 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> avio_feof ( pb ) ) { return AVERROR_EOF ; } if ( 
33,<S2SV_StartBug> newnp -> mcast_oif = inet6_iif ( skb ) ; <S2SV_EndBug> <S2SV_StartBug> newnp -> pktoptions = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> <S2SV_ModStart> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> 
34,<S2SV_StartBug> long elements ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( * p >= max - 2 ) { zend_error ( E_WARNING , ""Bad<S2SV_blank>unserialize<S2SV_blank>data"" ) ; return - 1 ; } <S2SV_ModStart> - 1 <S2SV_ModEnd> "
35,<S2SV_StartBug> if ( ! is_guest_mode ( vcpu ) ) { <S2SV_EndBug> ,<S2SV_ModStart> && kvm_x86_ops -> get_cpl ( vcpu ) == 0 
36,<S2SV_StartBug> auth . skb = chunk -> auth_chunk ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! net -> sctp . auth_enable || ! new_asoc -> peer . auth_capable ) { kfree_skb ( chunk -> auth_chunk ) ; sctp_association_free ( new_asoc ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } "
37,<S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> ,"<S2SV_ModStart> size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> alloc_size <S2SV_ModEnd> "
38,"<S2SV_StartBug> declen = mutt_b64_decode ( out2 , out1 ) ; <S2SV_EndBug> <S2SV_StartBug> declen = mutt_b64_decode ( out2 , out1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( out2 ) <S2SV_ModStart> , sizeof ( out2 ) "
39,"<S2SV_StartBug> RANGE_CHECK ( cfg , g_timebase . num , 1 , cfg -> g_timebase . den ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK ( vp8_cfg , cq_level , 0 , 63 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> ts_target_bitrate [ i ] <= cfg -> ts_target_bitrate [ i - 1 ] ) <S2SV_EndBug> ","<S2SV_ModStart> 1000000000 <S2SV_ModEnd> <S2SV_ModStart> ) ; RANGE_CHECK_HI ( vp8_cfg , screen_content_mode , 2 <S2SV_ModStart> && cfg -> rc_target_bitrate > 0 "
40,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> ",<S2SV_ModStart> key -> state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> 
41,"<S2SV_StartBug> long mtemp , save_adjust , rem ; <S2SV_EndBug> <S2SV_StartBug> time_offset = div_long_long_rem_signed ( time_offset , <S2SV_EndBug> <S2SV_StartBug> NTP_INTERVAL_FREQ , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> div_s64 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
42,<S2SV_StartBug> temp = EXTRACT_32BITS ( bp ) ; <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK_32BITS ( bp ) ; 
43,<S2SV_StartBug> if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( alloc > 2 ) && 
44,<S2SV_StartBug> size_t length ; <S2SV_EndBug> <S2SV_StartBug> if ( segment -> dataOffset < 5 ) <S2SV_EndBug> <S2SV_StartBug> length = segment -> dataOffset * 4 - sizeof ( TcpHeader ) ; <S2SV_EndBug> <S2SV_StartBug> if ( option -> kind == TCP_OPTION_NOP ) <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> if ( ( i + 1 ) >= length || ( i + option -> length ) > length ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> ,<S2SV_ModStart> i ; size_t length <S2SV_ModEnd> <S2SV_ModStart> >= ( sizeof ( TcpHeader ) / 4 ) ) { length = ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> TCP_OPTION_END ) { break ; } else if ( option -> kind == <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> ) break ; if ( option -> length < sizeof ( TcpOption ) <S2SV_ModStart> } } 
45,"<S2SV_StartBug> double vp9_convert_qindex_to_q ( int qindex ) { <S2SV_EndBug> <S2SV_StartBug> return vp9_ac_quant ( qindex , 0 ) / 4.0 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , vpx_bit_depth_t bit_depth ) { # if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) { case VPX_BITS_8 : <S2SV_ModEnd> <S2SV_ModStart> , bit_depth <S2SV_ModStart> case VPX_BITS_10 : return vp9_ac_quant ( qindex , 0 , bit_depth ) / 16.0 ; case VPX_BITS_12 : return vp9_ac_quant ( qindex , 0 , bit_depth ) / 64.0 ; default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12"" ) ; return - 1.0 ; } # else return vp9_ac_quant ( qindex , 0 , bit_depth ) / 4.0 ; # endif "
46,<S2SV_StartBug> if ( byte [ i ] & 0x40 ) <S2SV_EndBug> ,<S2SV_ModStart> && i > 0 
47,<S2SV_StartBug> if ( buf -> pts == AV_NOPTS_VALUE ) { <S2SV_EndBug> ,<S2SV_ModStart> || av_fifo_size ( s -> fifo ) <= 0 
48,<S2SV_StartBug> parameters -> res_spec = parameters -> numresolution - 1 ; <S2SV_EndBug> <S2SV_StartBug> parameters -> prch_init [ i ] = 256 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( parameters -> numresolution == 1 ) { parameters -> res_spec = 1 ; parameters -> prcw_init [ 0 ] = 128 ; parameters -> prch_init [ 0 ] = 128 ; } else { <S2SV_ModStart> } 
49,<S2SV_StartBug> return ERROR_INV_SPS_PPS_T ; <S2SV_EndBug> ,<S2SV_ModStart> ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> 
50,<S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> ,<S2SV_ModStart> n2size < 1 ) <S2SV_ModEnd> 
51,<S2SV_StartBug> for ( i = 0 ; i < table_entries_used ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ; <S2SV_EndBug> ,<S2SV_ModStart> { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } 
52,<S2SV_StartBug> # undef _ <S2SV_EndBug> ,<S2SV_ModStart> _ ( NPPVpluginUrlRequestsDisplayedBool ) ; _ ( NPPVpluginWantsAllNetworkStreams ) ; _ ( NPPVpluginNativeAccessibleAtkPlugId ) ; _ ( NPPVpluginCancelSrcStream ) ; _ ( NPPVSupportsAdvancedKeyHandling ) ; 
53,"<S2SV_StartBug> return udp_prot . getsockopt ( sk , level , optname , optval , optlen ) ; <S2SV_EndBug> ",<S2SV_ModStart> - EINVAL <S2SV_ModEnd> 
54,<S2SV_StartBug> # ifdef HAVE_OPENSSL <S2SV_EndBug> ,<S2SV_ModStart> SSL_SET_OPTIONS ( & mysql ) ; <S2SV_ModEnd> 
55,<S2SV_StartBug> if ( ! ( fhdr -> frag_off & htons ( 0xFFF9 ) ) ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
56,"<S2SV_StartBug> if ( enc624j600ReadReg ( interface , ENC624J600_REG_ECON1 ) & ECON1_TXRTS ) <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EGPWRPT , ENC624J600_TX_BUFFER_START ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ETXST , ENC624J600_TX_BUFFER_START ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ETXLEN , length ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_TXIF | EIR_TXABTIF ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_TXRTS ) ; <S2SV_EndBug> ","<S2SV_ModStart> ENC624J600_ECON1 ) & ENC624J600_ECON1_TXRTS <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EGPWRPT <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ETXST <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ETXLEN <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EIR , ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ECON1 , ENC624J600_ECON1_TXRTS <S2SV_ModEnd> "
57,<S2SV_StartBug> native_handle_t * h = malloc ( <S2SV_EndBug> <S2SV_StartBug> sizeof ( native_handle_t ) + sizeof ( int ) * ( numFds + numInts ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( numFds < 0 || numInts < 0 || numFds > kMaxNativeFds || numInts > kMaxNativeInts ) { return NULL ; } size_t mallocSize = <S2SV_ModEnd> <S2SV_ModStart> ( <S2SV_ModStart> ) ; native_handle_t * h = malloc ( mallocSize 
58,<S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> . ptr [ <S2SV_ModEnd> <S2SV_ModStart> . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
59,<S2SV_StartBug> ptr = p + 2 ; <S2SV_EndBug> ,<S2SV_ModStart> 3 <S2SV_ModEnd> 
60,<S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> ,<S2SV_ModStart> pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> 
61,"<S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) <S2SV_EndBug> ",<S2SV_ModStart> && ps_stream -> u4_offset < ps_stream -> u4_max_offset 
62,"<S2SV_StartBug> res = entry -> fn ( ctx -> priv -> alg_priv , ctrl_id , ap ) ; <S2SV_EndBug> ",<S2SV_ModStart> ( vpx_codec_alg_priv_t * ) <S2SV_ModStart>  <S2SV_ModEnd> 
63,"<S2SV_StartBug> isoclns_print ( ndo , p , length , caplen ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
64,<S2SV_StartBug> * p == SSL3_MT_CLIENT_HELLO ) && <S2SV_EndBug> ,<S2SV_ModStart> s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] <S2SV_ModEnd> 
65,"<S2SV_StartBug> d = ast_for_call ( c , CHILD ( n , 3 ) , name_expr ) ; <S2SV_EndBug> ","<S2SV_ModStart> , true "
66,<S2SV_StartBug> ue -> info = * info ; <S2SV_EndBug> ,<S2SV_ModStart> card = card ; ue -> 
67,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> return num ; <S2SV_EndBug> ,<S2SV_ModStart> fpl -> user = NULL ; <S2SV_ModStart> if ( ! fpl -> user ) fpl -> user = get_uid ( current_user ( ) ) ; 
68,"<S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> <S2SV_StartBug> coerce_reg_to_size ( & src_reg , 4 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( insn_bitness == 32 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } <S2SV_ModStart>  <S2SV_ModEnd> "
69,"<S2SV_StartBug> error = copy_to_user ( buf , & socket_packet -> icmp_packet , <S2SV_EndBug> <S2SV_StartBug> socket_packet -> icmp_len ) ; <S2SV_EndBug> ","<S2SV_ModStart> packet_len = min ( count , socket_packet -> icmp_len ) ; <S2SV_ModStart> packet_len ) <S2SV_ModEnd> "
70,"<S2SV_StartBug> READ ( data , msg . f . length ) <S2SV_EndBug> <S2SV_StartBug> if ( msg . f . length > sizeof ( data ) ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> HandleFence ( cl , flags , msg . f . length , data ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> SKIP ( msg . f . length ) } else { READ ( data , msg . f . length ) <S2SV_ModEnd> <S2SV_ModStart> } "
71,<S2SV_StartBug> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! tmp ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; 
72,<S2SV_StartBug> spin_lock_irq ( & tu -> qlock ) ; <S2SV_EndBug> <S2SV_StartBug> schedule ( ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> <S2SV_StartBug> return result > 0 ? result : err ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_ModStart> mutex_unlock ( & tu -> ioctl_lock ) ; schedule ( ) ; mutex_lock ( & tu -> ioctl_lock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & tu -> ioctl_lock ) ; 
73,<S2SV_StartBug> avail = vec -> iov_len - ( old - ( char * ) vec -> iov_base ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ( void * ) old > vec -> iov_base + vec -> iov_len ) return 0 ; 
74,"<S2SV_StartBug> int mongo_env_write_socket ( mongo * conn , const void * buf , int len ) { <S2SV_EndBug> <S2SV_StartBug> int sent = send ( conn -> sock , cbuf , len , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> 
75,"<S2SV_StartBug> uint32_t qttag , qtsize32 , len ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; size_t <S2SV_ModEnd> <S2SV_ModStart> LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
76,"<S2SV_StartBug> struct sk_buff * skb ; <S2SV_EndBug> <S2SV_StartBug> if ( dump_one_state ( x , 0 , & info ) ) { <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> ",<S2SV_ModStart> ; int err <S2SV_ModStart> err = <S2SV_ModEnd> <S2SV_ModStart> ; if ( err <S2SV_ModStart> ERR_PTR ( err ) <S2SV_ModEnd> 
77,"<S2SV_StartBug> len = mutt_b64_decode ( obuf , idata -> buf + 2 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( obuf ) "
78,<S2SV_StartBug> if ( ! ps_seq -> u1_frame_mbs_only_flag ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! ps_dec -> u1_first_slice_in_stream ) <S2SV_EndBug> ,"<S2SV_ModStart> ps_dec -> u1_first_slice_in_stream && ( ps_dec -> u4_first_slice_in_pic == 2 ) ) { pocstruct_t * ps_prev_poc = & ps_dec -> s_prev_pic_poc ; pocstruct_t * ps_cur_poc = & ps_dec -> s_cur_pic_poc ; ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; if ( ( 0 == u1_is_idr_slice ) && ps_cur_slice -> u1_nal_ref_idc ) ps_dec -> u2_prev_ref_frame_num = ps_cur_slice -> u2_frame_num ; if ( u1_is_idr_slice || ps_cur_slice -> u1_mmco_equalto5 ) ps_dec -> u2_prev_ref_frame_num = 0 ; if ( ps_dec -> ps_cur_sps -> u1_gaps_in_frame_num_value_allowed_flag ) { ih264d_decode_gaps_in_frame_num ( ps_dec , u2_frame_num ) ; } ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = ps_cur_poc -> u2_frame_num ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_slice -> u1_mmco_equalto5 ; if ( ps_cur_slice -> u1_nal_ref_idc ) { ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_cur_poc -> u1_bot_field ; } ps_dec -> u2_total_mbs_coded = 0 ; } if ( ! <S2SV_ModStart> if ( i1_is_end_of_poc ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } <S2SV_ModStart>  <S2SV_ModEnd> "
79,<S2SV_StartBug> int vm_shared = dst_vma -> vm_flags & VM_SHARED ; <S2SV_EndBug> <S2SV_StartBug> if ( vm_shared ) { <S2SV_EndBug> <S2SV_StartBug> struct address_space * mapping = dst_vma -> vm_file -> f_mapping ; <S2SV_EndBug> <S2SV_StartBug> spin_lock ( ptl ) ; <S2SV_EndBug> ,"<S2SV_ModStart> struct address_space * mapping ; pgoff_t idx ; unsigned long size ; <S2SV_ModStart> mapping = dst_vma -> vm_file -> f_mapping ; idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; <S2SV_ModStart> size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_nounlock <S2SV_ModEnd> <S2SV_ModStart> ; size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_unlock "
80,"<S2SV_StartBug> char query [ 1024 ] , * end ; <S2SV_EndBug> <S2SV_StartBug> end = strxmov ( query , ""show<S2SV_blank>table<S2SV_blank>status<S2SV_blank>from<S2SV_blank>`"" , db , ""`"" , NullS ) ; <S2SV_EndBug> <S2SV_StartBug> if ( wild && wild [ 0 ] ) <S2SV_EndBug> ","<S2SV_ModStart> NAME_LEN + 100 ] ; int len <S2SV_ModEnd> <S2SV_ModStart> len = sizeof ( query ) ; len -= my_snprintf ( query , len , ""show<S2SV_blank>table<S2SV_blank>status<S2SV_blank>from<S2SV_blank>`%s`"" , db <S2SV_ModEnd> <S2SV_ModStart> && len ) strxnmov ( query + strlen ( query ) , len <S2SV_ModEnd> "
81,<S2SV_StartBug> bestmv -> as_mv . row <<= 3 ; <S2SV_EndBug> <S2SV_StartBug> bestmv -> as_mv . col <<= 3 ; <S2SV_EndBug> ,<S2SV_ModStart> *= 8 <S2SV_ModEnd> <S2SV_ModStart> *= 8 <S2SV_ModEnd> 
82,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> <S2SV_StartBug> exit_func : <S2SV_EndBug> ",<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : <S2SV_ModStart>  <S2SV_ModEnd> 
83,"<S2SV_StartBug> error = scsi_nonblockable_ioctl ( sdp , cmd , p , <S2SV_EndBug> ","<S2SV_ModStart> scsi_verify_blk_ioctl ( bdev , cmd ) ; if ( error < 0 ) return error ; error = "
84,"<S2SV_StartBug> if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) <S2SV_EndBug> <S2SV_StartBug> if ( ( strlen ( retname ) + rr -> len - 5 ) >= 254 ) { <S2SV_EndBug> <S2SV_StartBug> strncat ( retname , rr -> u . NM . name , rr -> len - 5 ) ; <S2SV_EndBug> <S2SV_StartBug> retnamlen += rr -> len - 5 ; <S2SV_EndBug> ","<S2SV_ModStart> char * p ; int len ; <S2SV_ModStart> len = <S2SV_ModEnd> <S2SV_ModStart> ; if ( retnamlen + len <S2SV_ModEnd> <S2SV_ModStart> p = memchr ( rr -> u . NM . name , '\\0' , len ) ; if ( unlikely ( p ) ) len = p - rr -> u . NM . name ; memcpy ( retname + retnamlen <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> len ; retname [ retnamlen ] = '\\0' <S2SV_ModEnd> "
85,"<S2SV_StartBug> VpxVideoWriter * writer = NULL ; <S2SV_EndBug> <S2SV_StartBug> vpx_fixed_buf_t stats = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> const VpxInterface * encoder = NULL ; <S2SV_EndBug> <S2SV_StartBug> info . codec_fourcc = encoder -> fourcc ; <S2SV_EndBug> <S2SV_StartBug> info . frame_height = strtol ( height_arg , NULL , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( info . frame_width <= 0 || <S2SV_EndBug> <S2SV_StartBug> info . frame_height <= 0 || <S2SV_EndBug> <S2SV_StartBug> ( info . frame_width % 2 ) != 0 || <S2SV_EndBug> <S2SV_StartBug> ( info . frame_height % 2 ) != 0 ) { <S2SV_EndBug> <S2SV_StartBug> die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width , <S2SV_EndBug> <S2SV_StartBug> info . frame_height , 1 ) ) { <S2SV_EndBug> <S2SV_StartBug> die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image"" , info . frame_width , info . frame_height ) ; <S2SV_EndBug> <S2SV_StartBug> while ( vpx_img_read ( & raw , infile ) ) { <S2SV_EndBug> <S2SV_StartBug> fclose ( infile ) ; <S2SV_EndBug> ","<S2SV_ModStart> int w , h <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> w <S2SV_ModEnd> <S2SV_ModStart> h <S2SV_ModEnd> <S2SV_ModStart> w <S2SV_ModEnd> <S2SV_ModStart> h <S2SV_ModEnd> <S2SV_ModStart> ( w <S2SV_ModEnd> <S2SV_ModStart> ( h <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> w , h ) ; <S2SV_ModEnd> <S2SV_ModStart> w , h <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> w , h ) ; printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> codec_interface ( ) ) ) ; res = vpx_codec_enc_config_default ( encoder -> codec_interface ( ) , & cfg , 0 ) ; if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ; cfg . g_w = w ; cfg . g_h = h ; cfg . g_timebase . num = 1 ; cfg . g_timebase . den = fps ; cfg . rc_target_bitrate = bitrate ; if ( ! ( infile = fopen ( infile_arg , ""rb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading"" , infile_arg ) ; cfg . g_pass = VPX_RC_FIRST_PASS ; stats = pass0 ( & raw , infile , encoder , & cfg ) ; rewind ( infile ) ; cfg . g_pass = VPX_RC_LAST_PASS ; cfg . rc_twopass_stats_in = stats ; pass1 ( & raw , infile , outfile_arg , encoder , & cfg ) ; free ( stats . buf ) ; vpx_img_free <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
86,<S2SV_StartBug> if ( c -> string ) <S2SV_EndBug> ,<S2SV_ModStart> ! ( c -> type & cJSON_StringIsConst ) && 
87,<S2SV_StartBug> void vp9_inc_frame_in_layer ( SVC * svc ) { <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * const lc = ( svc -> number_temporal_layers > 1 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> VP9_COMP * const cpi <S2SV_ModEnd> <S2SV_ModStart> & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers <S2SV_ModEnd> <S2SV_ModStart> ++ lc -> frames_from_key_frame ; 
88,<S2SV_StartBug> if ( ! fs_searchpaths ) <S2SV_EndBug> <S2SV_StartBug> for ( search = fs_searchpaths ; search ; search = search -> next ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> qboolean isLocalConfig ; <S2SV_ModStart> isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> if ( isLocalConfig && search -> pack ) continue ; "
89,"<S2SV_StartBug> long rem ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> ",<S2SV_ModStart> u32 <S2SV_ModEnd> <S2SV_ModStart> div_u64_rem <S2SV_ModEnd> 
90,<S2SV_StartBug> tunnel_type = * ( tptr + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> tlen = len ; <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
91,<S2SV_StartBug> ExitLoop : <S2SV_EndBug> ,<S2SV_ModStart> quantum_info = DestroyQuantumInfo ( quantum_info ) ; 
92,<S2SV_StartBug> while ( peek ( s ) != '>' && ! eol ( s ) ) <S2SV_EndBug> ,<S2SV_ModStart> && ! eof ( s ) 
93,"<S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EUDAST , 0x1234 ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( enc624j600ReadReg ( interface , ENC624J600_REG_EUDAST ) != 0x1234 ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_CLKRDY ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON2 , ECON2_ETHRST ) ; <S2SV_EndBug> <S2SV_StartBug> if ( enc624j600ReadReg ( interface , ENC624J600_REG_EUDAST ) != 0x0000 ) <S2SV_EndBug> ","<S2SV_ModStart> ENC624J600_EUDAST <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EUDAST <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ESTAT ) & ENC624J600_ESTAT_CLKRDY <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ECON2 , ENC624J600_ECON2_ETHRST <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EUDAST <S2SV_ModEnd> "
94,"<S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( tim . bitmap , p + offset + 3 , tim . length - 3 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
95,<S2SV_StartBug> size_t e ; <S2SV_EndBug> <S2SV_StartBug> if ( mrb_basic_ptr ( v ) -> tt == MRB_TT_FREE ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ; mrb_value nil <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> e = c -> stend - c -> stbase ; nil = mrb_nil_value ( ) ; for ( ; i < e ; i ++ ) { c -> stbase [ i ] = nil ; 
96,<S2SV_StartBug> if ( client -> ipc == NULL ) { <S2SV_EndBug> ,<S2SV_ModStart> && client -> session == NULL 
97,"<S2SV_StartBug> sk_wait_data ( sk , & timeo , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) break ; 
98,"<S2SV_StartBug> ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;"" <S2SV_EndBug> <S2SV_StartBug> return APR_ENOSPC ; <S2SV_EndBug> <S2SV_StartBug> if ( rv != APR_SUCCESS ) { <S2SV_EndBug> <S2SV_StartBug> case BODY_CHUNK_END : { <S2SV_EndBug> <S2SV_StartBug> int merge_trailers = <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ","<S2SV_ModStart> ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;<S2SV_blank>"" ""using<S2SV_blank>read-until-close"" <S2SV_ModEnd> <S2SV_ModStart> APR_EINVAL <S2SV_ModEnd> <S2SV_ModStart> apr_brigade_cleanup ( bb ) ; <S2SV_ModStart> BODY_CHUNK_LF : case BODY_CHUNK_END : case BODY_CHUNK_END_LF <S2SV_ModEnd> <S2SV_ModStart> return read_chunked_trailers ( ctx , f , b , conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE <S2SV_ModEnd> <S2SV_ModStart> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , f -> r , APLOGNO ( 02901 ) ""Unexpected<S2SV_blank>body<S2SV_blank>state<S2SV_blank>(%i)"" , ( int ) ctx -> state ) ; return APR_EGENERAL <S2SV_ModEnd> "
99,"<S2SV_StartBug> if ( ! ND_TTEST2 ( cp , len ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
100,<S2SV_StartBug> struct ipv6_txoptions * opt = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ! opt ) <S2SV_EndBug> <S2SV_StartBug> fl6_sock_release ( flowlabel ) ; <S2SV_EndBug> ,<S2SV_ModStart> = NULL ; struct ipv6_txoptions * opt_to_free <S2SV_ModStart> { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> <S2SV_ModStart> ) ; txopt_put ( opt_to_free 
101,"<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; ret = posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( ret ) return ret <S2SV_ModEnd> "
102,"<S2SV_StartBug> NUMA * na ; <S2SV_EndBug> <S2SV_StartBug> pixt = pixCopy ( NULL , pix ) ; <S2SV_EndBug> <S2SV_StartBug> for ( j = goodcol - 1 ; j >= 0 ; j -- ) { <S2SV_EndBug> <S2SV_StartBug> pixRasterop ( pix , j , 0 , 1 , h , PIX_SRC , pixt , j + 1 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> pixRasterop ( pixt , j , 0 , 1 , h , PIX_SRC , pix , j , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> pixRasterop ( pix , j , 0 , 1 , h , PIX_SRC , pixt , j - 1 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> pixRasterop ( pixt , j , 0 , 1 , h , PIX_SRC , pix , j , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pix <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pix <S2SV_ModEnd> <S2SV_ModStart> } } <S2SV_ModEnd> 
103,<S2SV_StartBug> u16 source_node_id ; <S2SV_EndBug> <S2SV_StartBug> specifier_id = ( be32_to_cpu ( buf_ptr [ 0 ] ) & 0xffff ) << 8 <S2SV_EndBug> <S2SV_StartBug> ( ver == RFC2734_SW_VERSION <S2SV_EndBug> <S2SV_StartBug> || ver == RFC3146_SW_VERSION <S2SV_EndBug> <S2SV_StartBug> ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( length > IEEE1394_GASP_HDR_SIZE && gasp_specifier_id ( buf_ptr ) <S2SV_ModEnd> <S2SV_ModStart> gasp_version ( buf_ptr ) <S2SV_ModEnd> <S2SV_ModStart> gasp_version ( buf_ptr ) <S2SV_ModEnd> <S2SV_ModStart> fwnet_incoming_packet ( dev , buf_ptr + 2 , length - IEEE1394_GASP_HDR_SIZE , gasp_source_id ( buf_ptr ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
104,<S2SV_StartBug> sin -> sin_family = AF_INET ; <S2SV_EndBug> <S2SV_StartBug> if ( isk -> cmsg_flags ) <S2SV_EndBug> <S2SV_StartBug> sin6 -> sin6_family = AF_INET6 ; <S2SV_EndBug> <S2SV_StartBug> * addr_len = sizeof ( * sin6 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sin ) { <S2SV_ModStart> } <S2SV_ModStart> if ( sin6 ) { <S2SV_ModStart> } 
105,<S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> <S2SV_StartBug> up_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! mmget_still_valid ( mm ) ) goto skip_mm <S2SV_ModStart> skip_mm : 
106,<S2SV_StartBug> guint uint_val = GST_READ_UINT32_LE ( value ) ; <S2SV_EndBug> <S2SV_StartBug> gboolean bool_val = GST_READ_UINT32_LE ( value ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( value_len < 4 ) break ; uint_val <S2SV_ModStart> ; if ( value_len < 4 ) break ; bool_val 
107,<S2SV_StartBug> kk = malloc ( xsize * kmax * sizeof ( float ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! kk ) <S2SV_EndBug> ,<S2SV_ModStart> if ( kmax > 0 && xsize > SIZE_MAX / kmax ) return ( Imaging ) ImagingError_MemoryError ( ) ; if ( xsize * kmax > SIZE_MAX / sizeof ( float ) ) return ( Imaging ) ImagingError_MemoryError ( ) ; <S2SV_ModStart> ) return ( Imaging ) ImagingError_MemoryError ( ) ; if ( xsize > SIZE_MAX / ( 2 * sizeof ( int ) ) 
108,<S2SV_StartBug> countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ; <S2SV_EndBug> ,<S2SV_ModStart> tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ; 
109,"<S2SV_StartBug> struct timespec ts ; <S2SV_EndBug> <S2SV_StartBug> ts . tv_sec = div_long_long_rem_signed ( nsec , NSEC_PER_SEC , & ts . tv_nsec ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( nsec < 0 ) ) <S2SV_EndBug> <S2SV_StartBug> set_normalized_timespec ( & ts , ts . tv_sec , ts . tv_nsec ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; s32 rem <S2SV_ModStart> div_s64_rem <S2SV_ModEnd> <S2SV_ModStart> rem <S2SV_ModEnd> <S2SV_ModStart> rem <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModEnd> <S2SV_ModStart> -- ; rem += NSEC_PER_SEC ; } <S2SV_ModEnd> <S2SV_ModStart> = rem <S2SV_ModEnd> 
110,<S2SV_StartBug> buffer = malloc ( msg . tc . length + 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( msg . tc . length > MAX_TEXTCHAT_SIZE ) return FALSE ; 
111,"<S2SV_StartBug> rb_define_singleton_method ( klass , ""read_memory"" , read_memory , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> rb_define_singleton_method ( klass , ""from_document"" , from_document , 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> - <S2SV_ModStart> - 
112,<S2SV_StartBug> static void nsc_encode_subsampling ( NSC_CONTEXT * context ) <S2SV_EndBug> <S2SV_StartBug> BYTE * co_dst ; <S2SV_EndBug> <S2SV_StartBug> UINT32 tempHeight ; <S2SV_EndBug> <S2SV_StartBug> for ( y = 0 ; y < tempHeight >> 1 ; y ++ ) <S2SV_EndBug> <S2SV_StartBug> co_dst = context -> priv -> PlaneBuffers [ 1 ] + y * ( tempWidth >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> cg_dst = context -> priv -> PlaneBuffers [ 2 ] + y * ( tempWidth >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> co_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 1 ] + ( y << 1 ) * tempWidth ; <S2SV_EndBug> <S2SV_StartBug> co_src1 = co_src0 + tempWidth ; <S2SV_EndBug> <S2SV_StartBug> cg_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 2 ] + ( y << 1 ) * tempWidth ; <S2SV_EndBug> <S2SV_StartBug> cg_src1 = cg_src0 + tempWidth ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! context ) return FALSE <S2SV_ModStart> if ( tempHeight == 0 ) return FALSE ; if ( tempWidth > context -> priv -> PlaneBuffersLength / tempHeight ) return FALSE ; <S2SV_ModStart> BYTE * <S2SV_ModStart> BYTE * <S2SV_ModStart> const INT8 * <S2SV_ModStart> const INT8 * <S2SV_ModStart> const INT8 * <S2SV_ModStart> const INT8 * <S2SV_ModStart> return TRUE ; 
113,<S2SV_StartBug> int iSrc ; <S2SV_EndBug> <S2SV_StartBug> for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { <S2SV_EndBug> <S2SV_StartBug> dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ] . 
114,<S2SV_StartBug> if ( hrtimer_cancel ( timer ) ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & pit -> pit_state . lock ) ; <S2SV_ModStart> mutex_unlock ( & pit -> pit_state . lock ) ; 
115,"<S2SV_StartBug> FILE * file = NULL ; <S2SV_EndBug> <S2SV_StartBug> md5_context_t ctx ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , STRLEN , ""%lu%d%lu"" , ( unsigned long ) Time_now ( ) , getpid ( ) , random ( ) ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( file , ""%s"" , Run . id ) ; <S2SV_EndBug> ",<S2SV_ModStart> ASSERT ( idfile ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> Util_getToken ( Run . id ) <S2SV_ModEnd> 
116,<S2SV_StartBug> aptr += RRFIXEDSZ ; <S2SV_EndBug> ,<S2SV_ModStart> if ( aptr + rr_len > abuf + alen ) { free ( rr_name ) ; status = ARES_EBADRESP ; break ; } 
117,"<S2SV_StartBug> hdr . w0 = be32_to_cpu ( buf [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> hdr . w1 = ntohl ( buf [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( len <= RFC2374_UNFRAG_HDR_SIZE ) return 0 ; <S2SV_ModStart> if ( len <= RFC2374_FRAG_HDR_SIZE ) return 0 ; <S2SV_ModStart> if ( fg_off + len > dg_size ) return 0 ; 
118,<S2SV_StartBug> return KADM5_BAD_MASK ; <S2SV_EndBug> ,<S2SV_ModStart> if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail != NULL ; tl_data_tail = tl_data_tail -> tl_data_next ) { if ( tl_data_tail -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; } } 
119,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> ",<S2SV_ModStart> int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> rc = <S2SV_ModStart> rc <S2SV_ModEnd> 
120,<S2SV_StartBug> if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { mnt -> mnt . mnt_flags |= MNT_LOCK_ATIME ; if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mnt -> mnt . mnt_flags & MNT_NODEV ) mnt -> mnt . mnt_flags |= MNT_LOCK_NODEV ; if ( mnt -> mnt . mnt_flags & MNT_NOSUID ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOSUID ; if ( mnt -> mnt . mnt_flags & MNT_NOEXEC ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOEXEC ; } if ( 
121,"<S2SV_StartBug> if ( fwrite ( s -> s , 1 , s -> n , f ) != s -> n || fflush ( f ) != 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> s && ( <S2SV_ModStart> ) 
122,"<S2SV_StartBug> if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL ) <S2SV_EndBug> ",<S2SV_ModStart> psf_allocate ( <S2SV_ModEnd> 
123,"<S2SV_StartBug> box -> len = len ; <S2SV_EndBug> <S2SV_StartBug> jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; JAS_DBGLOG ( 10 , ( ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n"" , \'""\' , boxinfo -> name , \'""\' , box -> type , box -> len ) ) <S2SV_ModStart> box -> ops = & jp2_boxinfo_unk . ops ; "
124,"<S2SV_StartBug> count = yr_max ( 64 , ( index + 1 ) * 2 ) ; <S2SV_EndBug> <S2SV_StartBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc ( <S2SV_EndBug> ",<S2SV_ModStart> 64 ; while ( count <= index ) count *= 2 <S2SV_ModEnd> <S2SV_ModStart> while ( count <= index ) count *= 2 ; 
125,<S2SV_StartBug> if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) <S2SV_EndBug> <S2SV_StartBug> else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) <S2SV_EndBug> ,<S2SV_ModStart> tlen == BGP_VPN_RD_LEN + 4 + sizeof ( struct in_addr ) && <S2SV_ModStart> tlen == BGP_VPN_RD_LEN + 3 + sizeof ( struct in6_addr ) && 
126,"<S2SV_StartBug> ND_TCHECK2 ( dp [ 0 ] , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
127,"<S2SV_StartBug> num_pages = get_user_pages_fast ( base , size , 0 , & page [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( num_pages != size ) || <S2SV_EndBug> ",<S2SV_ModStart> if ( i + size > MAX_SKB_FRAGS ) return - EMSGSIZE ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
128,"<S2SV_StartBug> buffer_copy_buffer ( con -> physical . basedir , ds -> value ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( uri_ptr [ alias_len ] == '.' ) { char * s = uri_ptr + alias_len + 1 ; if ( * s == '.' ) ++ s ; if ( * s == '/' || * s == '\\0' ) { size_t vlen = buffer_string_length ( ds -> value ) ; if ( 0 != alias_len && ds -> key -> ptr [ alias_len - 1 ] != '/' && 0 != vlen && ds -> value -> ptr [ vlen - 1 ] == '/' ) { con -> http_status = 403 ; return HANDLER_FINISHED ; } } } 
129,"<S2SV_StartBug> size_t buf_size = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ","<S2SV_ModStart> = 0 ; size_t data_size <S2SV_ModStart> , & data_size <S2SV_ModStart> ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } "
130,<S2SV_StartBug> kfree ( init_name ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( rv && new_smi -> io . io_cleanup ) { new_smi -> io . io_cleanup ( & new_smi -> io ) ; new_smi -> io . io_cleanup = NULL ; } 
131,<S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart> if ( strlen ( password ) > MAX_PASSWORD_LEN ) return 0 ; 
132,<S2SV_StartBug> len = args -> len = ntohl ( * p ++ ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0 
133,<S2SV_StartBug> if ( ! ( info = bmp_getinfo ( in ) ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\n"" , hdr . magic , hdr . siz , hdr . reserved1 , hdr . reserved2 , hdr . off ) ) ; <S2SV_ModStart> JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%d;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>hres<S2SV_blank>%d;<S2SV_blank>vres<S2SV_blank>%d;<S2SV_blank>numcolors<S2SV_blank>%d;<S2SV_blank>"" ""mincolors<S2SV_blank>%d\\n"" , info -> len , info -> width , info -> height , info -> numplanes , info -> depth , info -> enctype , info -> siz , info -> hres , info -> vres , info -> numcolors , info -> mincolors ) ) ; "
134,"<S2SV_StartBug> ip_printts ( ndo , cp , option_len ) ; <S2SV_EndBug> <S2SV_StartBug> case IPOPT_RA : <S2SV_EndBug> ","<S2SV_ModStart> if ( ip_printts <S2SV_ModEnd> <S2SV_ModStart> IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ; break ; case "
135,<S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( numSamples <= 0 ) { ALOGE ( ""b/26366256"" ) ; return ; } "
136,"<S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <S2SV_EndBug> <S2SV_StartBug> iph -> protocol , <S2SV_EndBug> ","<S2SV_ModStart> static u32 ip_idents_hashrnd_extra __read_mostly ; <S2SV_ModStart> ) ) ; net_get_random_once ( & ip_idents_hashrnd_extra , sizeof ( ip_idents_hashrnd_extra <S2SV_ModStart> ^ ip_idents_hashrnd_extra "
137,"<S2SV_StartBug> strncpy ( extra_response -> key , key , strlen ( key ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> strlen ( NOTUNDERSTOOD ) + 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> strlcpy <S2SV_ModEnd> <S2SV_ModStart> sizeof ( extra_response -> key ) ) ; strlcpy <S2SV_ModEnd> <S2SV_ModStart> sizeof ( extra_response -> value ) <S2SV_ModEnd> 
138,"<S2SV_StartBug> static int override_release ( char __user * release , int len ) <S2SV_EndBug> <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> char * rest = UTS_RELEASE ; <S2SV_EndBug> <S2SV_StartBug> unsigned v ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , len , ""2.6.%u%s"" , v , rest ) ; <S2SV_EndBug> <S2SV_StartBug> ret = copy_to_user ( release , buf , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> ; char buf [ 65 ] = { 0 } <S2SV_ModStart> ; size_t copy <S2SV_ModStart> copy = min ( sizeof ( buf ) , max_t ( size_t , 1 , len ) ) ; copy = scnprintf <S2SV_ModEnd> <S2SV_ModStart> copy <S2SV_ModEnd> <S2SV_ModStart> copy + 1 <S2SV_ModEnd> "
139,<S2SV_StartBug> if ( stringset == ETH_SS_STATS ) <S2SV_EndBug> ,<S2SV_ModStart> || stringset == ETH_SS_PRIV_FLAGS 
140,"<S2SV_StartBug> struct rdcost_block_args args = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> args . use_fast_coef_costing = use_fast_coef_casting ; <S2SV_EndBug> <S2SV_StartBug> if ( args . skip ) { <S2SV_EndBug> <S2SV_StartBug> * skippable = vp9_is_skippable_in_plane ( x , bsize , plane ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; vp9_zero ( args ) <S2SV_ModEnd> <S2SV_ModStart> ; args . skippable = 1 <S2SV_ModStart> exit_early <S2SV_ModEnd> <S2SV_ModStart> args . skippable <S2SV_ModEnd> 
141,"<S2SV_StartBug> len = strlen ( ""/lock/lxc/"" ) + strlen ( n ) + strlen ( p ) + 3 ; <S2SV_EndBug> <S2SV_StartBug> ret = snprintf ( dest , len , ""%s/lock/lxc/%s"" , rundir , p ) ; <S2SV_EndBug> <S2SV_StartBug> int l2 = 22 + strlen ( n ) + strlen ( p ) ; <S2SV_EndBug> <S2SV_StartBug> free ( rundir ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""/lxc/lock/"" <S2SV_ModEnd> <S2SV_ModStart> ""%s/lxc/lock/%s"" <S2SV_ModEnd> <S2SV_ModStart> free ( dest ) ; free ( rundir ) ; return NULL ; } ret = snprintf ( dest , len , ""%s/lxc/lock/%s/.%s"" , rundir , p , n ) ; free ( rundir <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
142,<S2SV_StartBug> struct flowi6 * fl6 = & inet -> cork . fl . u . ip6 ; <S2SV_EndBug> <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> fl6 ; int err = 0 ; int is_udplite = IS_UDPLITE ( sk ) ; __wsum csum = 0 ; if ( up -> pending == AF_INET ) return udp_push_pending_frames ( sk ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
143,<S2SV_StartBug> endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; <S2SV_EndBug> <S2SV_StartBug> goto fail3 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( intf -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & intf -> dev , ""interface<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>endpoints,<S2SV_blank>but<S2SV_blank>must<S2SV_blank>have<S2SV_blank>minimum<S2SV_blank>1\\n"" , intf -> altsetting [ 0 ] . desc . bNumEndpoints ) ; err = - EINVAL ; goto fail3 ; } <S2SV_ModStart> err = - EINVAL ; "
144,"<S2SV_StartBug> GF_BitStream * mybs = gf_bs_new ( data + i , size - i , GF_BITSTREAM_READ ) ; <S2SV_EndBug> <S2SV_StartBug> gf_isom_box_del ( ( GF_Box * ) ptr -> esd ) ; <S2SV_EndBug> ",<S2SV_ModStart> extern Bool use_dump_mode ; <S2SV_ModStart> if ( ! use_dump_mode ) 
145,<S2SV_StartBug> if ( * pStackPtr >= CDL_STACK_SIZE ) <S2SV_EndBug> <S2SV_StartBug> return EAS_ERROR_FILE_FORMAT ; <S2SV_EndBug> ,"<S2SV_ModStart> ( CDL_STACK_SIZE - 1 ) ) { ALOGE ( ""b/34031018,<S2SV_blank>stackPtr(%d)"" , * pStackPtr ) ; android_errorWriteLog ( 0x534e4554 , ""34031018"" ) ; <S2SV_ModEnd> <S2SV_ModStart> } "
146,"<S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> ","<S2SV_ModStart> , XEN_NETIF_RSP_OKAY "
147,"<S2SV_StartBug> } else if ( ! av_strcasecmp ( tag , ""Content-Length"" ) && s -> filesize == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> s -> filesize = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> <S2SV_StartBug> ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; <S2SV_EndBug> <S2SV_StartBug> s -> icy_metaint = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> ","<S2SV_ModStart> UINT64_MAX <S2SV_ModEnd> <S2SV_ModStart> strtoull <S2SV_ModEnd> <S2SV_ModStart> UINT64_MAX ; s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , ""WWW-Authenticate"" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Authentication-Info"" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Proxy-Authenticate"" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Connection"" ) ) { if ( ! strcmp ( p , ""close"" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , ""Server"" ) ) { if ( ! av_strcasecmp ( p , ""AkamaiGHost"" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , ""MediaGateway"" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , ""Content-Type"" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , ""Set-Cookie"" ) ) { if ( parse_cookie ( s , p , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strtoull <S2SV_ModEnd> "
148,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> mutt_socket_empty ( conn ) ; 
149,"<S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>h<S2SV_blank>f"" ) ; <S2SV_EndBug> <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>s"" ) ; <S2SV_EndBug> <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>h<S2SV_blank>f"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> send ( <S2SV_ModEnd> <S2SV_ModStart> send ( <S2SV_ModEnd> <S2SV_ModStart> send ( <S2SV_ModEnd> 
150,<S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( numSamples <= 0 ) { ALOGE ( ""b/26366256"" ) ; return ; } "
151,<S2SV_StartBug> char added ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
152,"<S2SV_StartBug> const char * name = d -> name ; <S2SV_EndBug> <S2SV_StartBug> struct device dev = d -> udev -> dev ; <S2SV_EndBug> <S2SV_StartBug> dev_info ( & dev , ""%s:<S2SV_blank>\'%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n"" , <S2SV_EndBug> <S2SV_StartBug> KBUILD_MODNAME , name ) ; <S2SV_EndBug> ","<S2SV_ModStart> devname = kstrdup ( dev_name ( & <S2SV_ModEnd> <S2SV_ModStart> ) , GFP_KERNEL ) ; const char * drvname = d -> name <S2SV_ModStart> pr_info ( ""%s:<S2SV_blank>\'%s:%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n"" <S2SV_ModEnd> <S2SV_ModStart> drvname , devname ) ; kfree ( devname <S2SV_ModEnd> "
153,"<S2SV_StartBug> list_del ( & key -> graveyard_link ) ; <S2SV_EndBug> <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && <S2SV_EndBug> <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) <S2SV_EndBug> ",<S2SV_ModStart> short state = key -> state ; <S2SV_ModStart> state == KEY_IS_POSITIVE && <S2SV_ModEnd> <S2SV_ModStart> state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> 
154,"<S2SV_StartBug> REQ ( n , for_stmt ) ; <S2SV_EndBug> <S2SV_StartBug> if ( NCH ( n ) == 9 ) { <S2SV_EndBug> <S2SV_StartBug> seq = ast_for_suite ( c , CHILD ( n , 8 ) ) ; <S2SV_EndBug> <S2SV_StartBug> suite_seq = ast_for_suite ( c , CHILD ( n , 5 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( is_async ) <S2SV_EndBug> <S2SV_StartBug> return AsyncFor ( target , expression , suite_seq , seq , <S2SV_EndBug> <S2SV_StartBug> return For ( target , expression , suite_seq , seq , <S2SV_EndBug> ","<S2SV_ModStart> int has_type_comment ; string type_comment ; <S2SV_ModStart> ; has_type_comment = TYPE ( CHILD ( n , 5 ) ) == TYPE_COMMENT <S2SV_ModStart> + has_type_comment <S2SV_ModStart> + has_type_comment <S2SV_ModStart> + has_type_comment <S2SV_ModStart> has_type_comment ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , 5 ) ) ; if ( ! type_comment ) return NULL ; } else type_comment = NULL ; if ( <S2SV_ModStart> type_comment , <S2SV_ModStart> , type_comment "
155,"<S2SV_StartBug> uid_eq ( root_uid , current_uid ( ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( gid_eq ( root_gid , current_gid ( ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart> current_euid <S2SV_ModEnd> <S2SV_ModStart> in_egroup_p ( root_gid <S2SV_ModEnd> 
156,<S2SV_StartBug> MinVal = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; "
157,<S2SV_StartBug> mutex_lock ( & vdev -> vdev_mutex ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( memcmp ( & dd , dd_config , sizeof ( dd ) ) ) { ret = - EINVAL ; goto free_ret ; } "
158,<S2SV_StartBug> if ( bytecnt ) { <S2SV_EndBug> <S2SV_StartBug> bytecnt -- ; <S2SV_EndBug> ,<S2SV_ModStart> >= 2 <S2SV_ModStart> if ( wpc -> channel_reordering [ i ] >= nchans ) wpc -> channel_reordering [ i ] = 0 ; 
159,"<S2SV_StartBug> if ( ( keylen ) > nodesize ) { <S2SV_EndBug> <S2SV_StartBug> PRIu16 "")"" , rec , cur_node , keylen , nodesize ) ; <S2SV_EndBug> ",<S2SV_ModStart> keylen >= nodesize - rec_off <S2SV_ModEnd> <S2SV_ModStart> ( nodesize - rec_off ) <S2SV_ModEnd> 
160,"<S2SV_StartBug> if ( sock -> ops ) { <S2SV_EndBug> <S2SV_StartBug> if ( rcu_dereference_protected ( sock -> wq , 1 ) -> fasync_list ) <S2SV_EndBug> ","<S2SV_ModStart> __sock_release ( sock , NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
161,<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> msg -> msg_namelen = 0 ; 
162,"<S2SV_StartBug> ns_to_timespec ( cur_setting -> it_interval , timr -> it . mmtimer . incr * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> ns_to_timespec ( cur_setting -> it_value , ( timr -> it . mmtimer . expires - rtc_time ( ) ) * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = ns_to_timespec ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = ns_to_timespec ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
163,"<S2SV_StartBug> fprintf ( stderr , ""File<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>IOD"" , inName ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""File<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>IOD\\n"" <S2SV_ModEnd> "
164,<S2SV_StartBug> test -> remote_cpu_util [ 0 ] = j_cpu_util_total -> valuefloat ; <S2SV_EndBug> <S2SV_StartBug> test -> remote_cpu_util [ 1 ] = j_cpu_util_user -> valuefloat ; <S2SV_EndBug> <S2SV_StartBug> test -> remote_cpu_util [ 2 ] = j_cpu_util_system -> valuefloat ; <S2SV_EndBug> <S2SV_StartBug> jitter = j_jitter -> valuefloat ; <S2SV_EndBug> ,<S2SV_ModStart> valuedouble <S2SV_ModEnd> <S2SV_ModStart> valuedouble <S2SV_ModEnd> <S2SV_ModStart> valuedouble <S2SV_ModEnd> <S2SV_ModStart> valuedouble <S2SV_ModEnd> 
165,"<S2SV_StartBug> skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ; <S2SV_EndBug> ",<S2SV_ModStart> m -> msg_namelen = 0 ; 
166,"<S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ",<S2SV_ModStart> ssplit <S2SV_ModEnd> 
167,"<S2SV_StartBug> uzbl . net . useragent = ""Test<S2SV_blank>useragent"" ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
168,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( map -> m_flags & EXT4_MAP_NEW && ! ( map -> m_flags & EXT4_MAP_UNWRITTEN ) && ! ( flags & EXT4_GET_BLOCKS_ZERO ) && ! IS_NOQUOTA ( inode ) && ext4_should_order_data ( inode ) ) { ret = ext4_jbd2_file_inode ( handle , inode ) ; if ( ret ) return ret ; } } return <S2SV_ModEnd> "
169,<S2SV_StartBug> head_shift = ( F_SECT_PER_TRACK + 5 ) / 6 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! F_SECT_PER_TRACK ) return ; 
170,<S2SV_StartBug> if ( roishift == 0 && bgshift == 0 ) { <S2SV_EndBug> <S2SV_StartBug> mask = ( 1 << numbps ) - 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> < 0 ) { jas_eprintf ( ""warning:<S2SV_blank>forcing<S2SV_blank>negative<S2SV_blank>ROI<S2SV_blank>shift<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>"" ""(bitstream<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>corrupt)\\n"" ) ; roishift = 0 ; } if ( roishift <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> "
171,<S2SV_StartBug> case EXIT_REASON_INVEPT : <S2SV_EndBug> ,<S2SV_ModStart> case EXIT_REASON_INVVPID : 
172,<S2SV_StartBug> struct pmu * leader_pmu = event -> group_leader -> pmu ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( is_software_event ( event ) ) return 1 
173,<S2SV_StartBug> int n = 0 ; <S2SV_EndBug> <S2SV_StartBug> sock = ap_get_conn_socket ( r -> connection ) ; <S2SV_EndBug> <S2SV_StartBug> lua_websocket_read ( L ) ; <S2SV_EndBug> ,<S2SV_ModStart> do_read = 1 ; int <S2SV_ModStart> ; while ( do_read ) { do_read = 0 <S2SV_ModStart> do_read = 1 ; } <S2SV_ModEnd> 
174,<S2SV_StartBug> copy_flags |= CL_SHARED_TO_SLAVE ; <S2SV_EndBug> ,<S2SV_ModStart> | CL_UNPRIVILEGED 
175,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( rc -> uwbd . task ) 
176,"<S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
177,"<S2SV_StartBug> SetImageColorspace ( image , GRAYColorspace ) ; <S2SV_EndBug> ","<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
178,"<S2SV_StartBug> const void * data ; <S2SV_EndBug> <S2SV_StartBug> int noffset = 0 ; <S2SV_EndBug> <S2SV_StartBug> char * err_msg = """" ; <S2SV_EndBug> <S2SV_StartBug> printf ( ""error!\\n%s<S2SV_blank>for<S2SV_blank>\'%s\'<S2SV_blank>hash<S2SV_blank>node<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>image<S2SV_blank>node\\n"" , <S2SV_EndBug> <S2SV_StartBug> err_msg , fit_get_name ( fit , noffset , NULL ) , <S2SV_EndBug> <S2SV_StartBug> return fit_image_verify_with_data ( fit , image_noffset , data , size ) ; <S2SV_EndBug> ","<S2SV_ModStart> char * name = fit_get_name ( fit , image_noffset , NULL ) ; const <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( strchr ( name , '@' ) ) { err_msg = ""Node<S2SV_blank>name<S2SV_blank>contains<S2SV_blank>@"" ; goto err ; } <S2SV_ModStart> goto err ; } return fit_image_verify_with_data <S2SV_ModEnd> <S2SV_ModStart> image_noffset , data , size ) ; err : printf ( ""error!\\n%s<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>image<S2SV_blank>node\\n"" , err_msg <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
179,<S2SV_StartBug> if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) || * dp ++ != ( ( csum >> 16 ) & 0xff ) || * dp ++ != ( ( csum >> 24 ) & 0xff ) ) <S2SV_EndBug> <S2SV_StartBug> if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dp [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> dp [ 2 ] <S2SV_ModEnd> <S2SV_ModStart> dp [ 3 ] <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dp [ 1 ] <S2SV_ModEnd> 
180,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = wc_Hash ( hash_type , data , data_len , hash_data , hash_len ) ; <S2SV_EndBug> <S2SV_StartBug> hash_data , hash_enc_len , sig , sig_len , key , key_len , rng ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> return wc_SignatureGenerate_ex ( hash_type , sig_type <S2SV_ModEnd> <S2SV_ModStart> sig , <S2SV_ModEnd> <S2SV_ModStart> , 1 <S2SV_ModStart>  <S2SV_ModEnd> "
181,<S2SV_StartBug> if ( copy_in ) { <S2SV_EndBug> <S2SV_StartBug> * bounce_buf_ret = bounce_buf ; <S2SV_EndBug> ,<S2SV_ModStart> * bounce_buf_ret = bounce_buf ; <S2SV_ModStart>  <S2SV_ModEnd> 
182,<S2SV_StartBug> const FIRSTPASS_STATS * this_frame ) { <S2SV_EndBug> <S2SV_StartBug> const struct twopass_rc * twopass = & cpi -> twopass ; <S2SV_EndBug> <S2SV_StartBug> av_err = stats -> ssim_weighted_pred_err / stats -> count ; <S2SV_EndBug> <S2SV_StartBug> modified_error = av_err * pow ( this_frame -> ssim_weighted_pred_err / <S2SV_EndBug> <S2SV_StartBug> cpi -> oxcf . two_pass_vbrbias / 100.0 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> TWO_PASS * twopass , const VP9EncoderConfig * oxcf , const <S2SV_ModStart> FIRSTPASS_STATS * const <S2SV_ModEnd> <S2SV_ModStart> const double av_weight <S2SV_ModEnd> <S2SV_ModStart> weight <S2SV_ModEnd> <S2SV_ModStart> const double av_err = ( stats -> coded_error * av_weight ) / stats -> count ; double <S2SV_ModStart> coded_error * this_frame -> weight <S2SV_ModEnd> <S2SV_ModStart> oxcf -> <S2SV_ModEnd> <S2SV_ModStart> ) ; modified_error *= pow ( calculate_active_area ( cpi , this_frame ) , ACT_AREA_CORRECTION "
183,<S2SV_StartBug> while ( bytes ) { <S2SV_EndBug> ,<S2SV_ModStart> || ! iov -> iov_len 
184,<S2SV_StartBug> return FALSE ; <S2SV_EndBug> ,<S2SV_ModStart> transport -> credssp = NULL ; 
185,<S2SV_StartBug> return true ; <S2SV_EndBug> ,<S2SV_ModStart> ( * field_rtrn != NULL ) <S2SV_ModEnd> 
186,<S2SV_StartBug> int nByte = sizeof ( u32 ) * ( 2 * nElem + 1 ) + sizeof ( MatchinfoBuffer ) ; <S2SV_EndBug> <S2SV_StartBug> int nStr = ( int ) strlen ( zMatchinfo ) ; <S2SV_EndBug> <S2SV_StartBug> pRet = sqlite3_malloc ( nByte + nStr + 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart> sqlite3_int64 <S2SV_ModEnd> <S2SV_ModStart> ( sqlite3_int64 ) <S2SV_ModStart> sqlite3_int64 nStr = <S2SV_ModEnd> <S2SV_ModStart> sqlite3_malloc64 <S2SV_ModEnd> 
187,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
188,<S2SV_StartBug> # ifdef HAVE_OPENSSL <S2SV_EndBug> ,<S2SV_ModStart> SSL_SET_OPTIONS ( & mysql_connection ) ; <S2SV_ModEnd> 
189,"<S2SV_StartBug> memcpy ( devinfo . driver_name , dev -> driver -> driver_name , COMEDI_NAMELEN ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( devinfo . board_name , dev -> board_name , COMEDI_NAMELEN ) ; <S2SV_EndBug> ",<S2SV_ModStart> strlcpy <S2SV_ModEnd> <S2SV_ModStart> strlcpy <S2SV_ModEnd> 
190,"<S2SV_StartBug> void jas_matrix_bindsub ( jas_matrix_t * mat0 , jas_matrix_t * mat1 , int r0 , <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> ","<S2SV_ModStart> jas_matind_t r0 , jas_matind_t c0 , jas_matind_t r1 , jas_matind_t <S2SV_ModEnd> <S2SV_ModStart> jas_matind_t <S2SV_ModEnd> "
191,"<S2SV_StartBug> if ( ! spec || ! value || ! hdr || ! obuf || obuf_len < 0 ) { <S2SV_EndBug> <S2SV_StartBug> case DW_FORM_data2 : <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; <S2SV_EndBug> ",<S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> # if 0 <S2SV_ModStart> # endif <S2SV_ModStart> if ( value -> encoding . block . data ) { <S2SV_ModStart> } <S2SV_ModStart> if ( value -> encoding . block . data ) { <S2SV_ModStart> } 
192,<S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug> ,<S2SV_ModStart> mb2_cache <S2SV_ModEnd> 
193,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> title , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> style_block , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> script , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> object , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> textarea , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> option , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> math , s ) ; <S2SV_EndBug> <S2SV_StartBug> # ifdef USE_PRETTYSRC <S2SV_EndBug> ","<S2SV_ModStart> HTChunk * target = NULL ; <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( target != NULL ) { if ( target -> data == s ) { CTRACE ( ( tfp , ""BUG:<S2SV_blank>appending<S2SV_blank>chunk<S2SV_blank>to<S2SV_blank>itself:<S2SV_blank>`%.*s\'\\n"" , target -> size , target -> data ) ) ; } else { HTChunkPuts ( target , s ) ; } } "
194,"<S2SV_StartBug> static vpx_codec_err_t vp8e_update_entropy ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
195,<S2SV_StartBug> when = timespec_to_ns ( new_setting -> it_value ) ; <S2SV_EndBug> <S2SV_StartBug> period = timespec_to_ns ( new_setting -> it_interval ) ; <S2SV_EndBug> <S2SV_StartBug> now = timespec_to_ns ( n ) ; <S2SV_EndBug> ,<S2SV_ModStart> & <S2SV_ModStart> & <S2SV_ModStart> & 
196,<S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ; 
197,"<S2SV_StartBug> sprintf ( descriptor -> msg , ""\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" , <S2SV_EndBug> <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug> ","<S2SV_ModStart> ""\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" <S2SV_ModEnd> <S2SV_ModStart> intptr_t <S2SV_ModEnd> <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) "
198,<S2SV_StartBug> if ( ex && ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug> <S2SV_StartBug> if ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug> ,<S2SV_ModStart> ! ( flag & <S2SV_ModEnd> <S2SV_ModStart> ! ( flag & EXT4_GET_BLOCKS_PRE_IO ) <S2SV_ModEnd> 
199,<S2SV_StartBug> mptctl_replace_fw ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,"<S2SV_ModStart> MPT_ADAPTER * ioc , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
200,"<S2SV_StartBug> if ( ( addr_fd = open ( val , O_RDONLY ) ) != - 1 ) <S2SV_EndBug> <S2SV_StartBug> read ( addr_fd , val , FACTORY_BT_BDADDR_STORAGE_LEN ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
201,<S2SV_StartBug> op -> regs [ reg_index ] = reg ; <S2SV_EndBug> <S2SV_StartBug> ++ reg_index ; <S2SV_EndBug> <S2SV_StartBug> op -> offset += temp ; <S2SV_EndBug> <S2SV_StartBug> op -> regs [ reg_index ] = X86R_UNDEFINED ; <S2SV_EndBug> ,<S2SV_ModStart> if ( reg_index < 2 ) { <S2SV_ModStart> } <S2SV_ModStart> if ( reg_index < 2 ) { <S2SV_ModStart> } 
202,<S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> value = ast2obj_string ( o -> v . FunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value = ast2obj_string ( o -> v . AsyncFunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value = ast2obj_string ( o -> v . Assign . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value = ast2obj_string ( o -> v . For . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value = ast2obj_string ( o -> v . AsyncFor . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value = ast2obj_string ( o -> v . With . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value = ast2obj_string ( o -> v . AsyncWith . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; "
203,<S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug> ,<S2SV_ModStart> ctx -> terminated || 
204,"<S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_context_expr ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_context_expr ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( tmp , & context_expr , arena ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ","<S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""context_expr\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>withitem"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & context_expr , arena ) ; if ( res != 0 <S2SV_ModEnd> <S2SV_ModStart> Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_optional_vars , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; optional_vars = NULL ; } else { int res ; <S2SV_ModStart> optional_vars <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
205,"<S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> != c ) break 
206,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> 
207,"<S2SV_StartBug> static vpx_codec_err_t vp8e_set_activemap ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
208,"<S2SV_StartBug> enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_NO_FLAGS ) ; <S2SV_EndBug> ",<S2SV_ModStart> IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn <S2SV_ModEnd> 
209,"<S2SV_StartBug> log_file = fopen ( file_name , ""a"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> fopen_safe <S2SV_ModEnd> 
210,<S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , false "
211,"<S2SV_StartBug> int frame_avail , got_data ; <S2SV_EndBug> <S2SV_StartBug> struct VpxInputContext input = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> exec_name = argv_ [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> input . use_i420 = 1 ; <S2SV_EndBug> <S2SV_StartBug> input . only_i420 = 1 ; <S2SV_EndBug> <S2SV_StartBug> parse_global_config ( & global , argv ) ; <S2SV_EndBug> <S2SV_StartBug> off_t lagged_count = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! input . width || ! input . height ) <S2SV_EndBug> <S2SV_StartBug> } ) ; <S2SV_EndBug> <S2SV_StartBug> ""<S2SV_blank>and<S2SV_blank>--height<S2SV_blank>(-h)"" ) ; <S2SV_EndBug> <S2SV_StartBug> input . use_i420 ? VPX_IMG_FMT_I420 <S2SV_EndBug> <S2SV_StartBug> FOREACH_STREAM ( open_output_file ( stream , & global ) ) ; <S2SV_EndBug> <S2SV_StartBug> FOREACH_STREAM ( initialize_encoder ( stream , & global ) ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""\\033[K"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( frames_in > global . skip_frames ) { <S2SV_EndBug> <S2SV_StartBug> vpx_usec_timer_mark ( & timer ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! got_data && input . length && ! streams -> frames_out ) { <S2SV_EndBug> <S2SV_StartBug> off_t frame_in_lagged = ( seen_frames - lagged_count ) * 1000 ; <S2SV_EndBug> <S2SV_StartBug> off_t input_pos = ftello ( input . file ) ; <S2SV_EndBug> <S2SV_StartBug> off_t input_pos_lagged = input_pos - lagged_count ; <S2SV_EndBug> <S2SV_StartBug> int64_t limit = input . length ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! global . quiet ) <S2SV_EndBug> <S2SV_StartBug> ""\\rPass<S2SV_blank>%d/%d<S2SV_blank>frame<S2SV_blank>%4d/%-4d<S2SV_blank>%7"" PRId64 ""B<S2SV_blank>%7lub/f<S2SV_blank>%7"" PRId64 ""b/s"" <S2SV_EndBug> <S2SV_StartBug> seen_frames ? ( unsigned long ) ( stream -> nbytes * 8 / seen_frames ) : 0 , <S2SV_EndBug> <S2SV_StartBug> usec_to_fps ( stream -> cx_time , seen_frames ) ) ; <S2SV_EndBug> <S2SV_StartBug> FOREACH_STREAM ( show_psnr ( stream ) ) ; <S2SV_EndBug> <S2SV_StartBug> FOREACH_STREAM ( stats_close ( & stream -> stats , global . passes - 1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> } ) ; <S2SV_EndBug> ","<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH vpx_image_t raw_shift ; int allocated_raw_shift = 0 ; int use_16bit_internal = 0 ; int input_shift = 0 ; # endif <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memset ( & input , 0 , sizeof ( input ) ) ; <S2SV_ModStart> only_i420 <S2SV_ModEnd> <S2SV_ModStart> bit_depth = 0 <S2SV_ModEnd> <S2SV_ModStart> switch ( global . color_type ) { case I420 : input . fmt = VPX_IMG_FMT_I420 ; break ; case I422 : input . fmt = VPX_IMG_FMT_I422 ; break ; case I444 : input . fmt = VPX_IMG_FMT_I444 ; break ; case I440 : input . fmt = VPX_IMG_FMT_I440 ; break ; case YV12 : input . fmt = VPX_IMG_FMT_YV12 ; break ; } <S2SV_ModStart> int64_t <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> if ( ! input . bit_depth ) { FOREACH_STREAM ( { if ( stream -> config . cfg . g_input_bit_depth ) input . bit_depth = stream -> config . cfg . g_input_bit_depth ; else input . bit_depth = stream -> config . cfg . g_input_bit_depth = ( int ) stream -> config . cfg . g_bit_depth ; } ) ; if ( input . bit_depth > 8 ) input . fmt |= VPX_IMG_FMT_HIGHBITDEPTH ; } else { FOREACH_STREAM ( { stream -> config . cfg . g_input_bit_depth = input . bit_depth ; } ) ; } <S2SV_ModStart> input . fmt , <S2SV_ModEnd> <S2SV_ModStart> , & input . pixel_aspect_ratio <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( strcmp ( global . codec -> name , ""vp9"" ) == 0 || strcmp ( global . codec -> name , ""vp10"" ) == 0 ) { FOREACH_STREAM ( { if ( stream -> config . use_16bit_internal ) { use_16bit_internal = 1 ; } if ( stream -> config . cfg . g_profile == 0 ) { input_shift = 0 ; } else { input_shift = ( int ) stream -> config . cfg . g_bit_depth - stream -> config . cfg . g_input_bit_depth ; } } ) ; } # endif <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH vpx_image_t * frame_to_encode ; if ( input_shift || ( use_16bit_internal && input . bit_depth == 8 ) ) { assert ( use_16bit_internal ) ; if ( ! allocated_raw_shift ) { vpx_img_alloc ( & raw_shift , raw . fmt | VPX_IMG_FMT_HIGHBITDEPTH , input . width , input . height , 32 ) ; allocated_raw_shift = 1 ; } vpx_img_upshift ( & raw_shift , & raw , input_shift ) ; frame_to_encode = & raw_shift ; } else { frame_to_encode = & raw ; } vpx_usec_timer_start ( & timer ) ; if ( use_16bit_internal ) { assert ( frame_to_encode -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ; FOREACH_STREAM ( { if ( stream -> config . use_16bit_internal ) encode_frame ( stream , & global , frame_avail ? frame_to_encode : NULL , frames_in ) ; else assert ( 0 ) ; } ) ; } else { assert ( ( frame_to_encode -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) == 0 ) ; FOREACH_STREAM ( encode_frame ( stream , & global , frame_avail ? frame_to_encode : NULL , frames_in ) ) ; } # else <S2SV_ModStart> # endif <S2SV_ModStart> streams != NULL && <S2SV_ModStart> const int64_t <S2SV_ModEnd> <S2SV_ModStart> const int64_t <S2SV_ModEnd> <S2SV_ModStart> const int64_t <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> if ( ! global . quiet ) fprintf ( stderr , ""\\033[K"" ) ; <S2SV_ModStart> { <S2SV_ModStart> ""B<S2SV_blank>%7"" PRId64 ""b/f<S2SV_blank>%7"" <S2SV_ModEnd> <S2SV_ModStart> int64_t <S2SV_ModEnd> <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_ModStart> { if ( global . codec -> fourcc == VP9_FOURCC ) { FOREACH_STREAM ( <S2SV_ModEnd> <S2SV_ModStart> , ( 1 << stream -> config . cfg . g_input_bit_depth ) - 1 ) ) ; } else { FOREACH_STREAM ( show_psnr ( stream , 255.0 ) ) ; } } <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_FP_MB_STATS FOREACH_STREAM ( stats_close ( & stream -> fpmb_stats , global . passes - 1 ) ) ; # endif <S2SV_ModStart> ) ; # endif # if CONFIG_VP9_HIGHBITDEPTH if ( allocated_raw_shift ) vpx_img_free ( & raw_shift "
212,"<S2SV_StartBug> int opts ; <S2SV_EndBug> <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <S2SV_EndBug> ","<S2SV_ModStart> result ; int <S2SV_ModStart> result = <S2SV_ModEnd> <S2SV_ModStart> ; if ( result < 0 ) js_error ( J , ""regexec<S2SV_blank>failed"" ) ; if ( result == 0 "
213,"<S2SV_StartBug> uint32_t GetPayloadTime ( size_t handle , uint32_t index , float * in , float * out ) <S2SV_EndBug> <S2SV_StartBug> if ( mp4 == NULL ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets == 0 || mp4 -> basemetadataduration == 0 || mp4 -> meta_clockdemon == 0 || in == NULL || out == NULL ) return 1 ; <S2SV_EndBug> <S2SV_StartBug> * in = ( float ) ( ( double ) index * ( double ) mp4 -> basemetadataduration / ( double ) mp4 -> meta_clockdemon ) ; <S2SV_EndBug> <S2SV_StartBug> * out = ( float ) ( ( double ) ( index + 1 ) * ( double ) mp4 -> basemetadataduration / ( double ) mp4 -> meta_clockdemon ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ",<S2SV_ModStart> double <S2SV_ModEnd> <S2SV_ModStart> double <S2SV_ModEnd> <S2SV_ModStart> GPMF_ERROR_MEMORY <S2SV_ModEnd> <S2SV_ModStart> GPMF_ERROR_MEMORY <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> GPMF_OK <S2SV_ModEnd> 
214,<S2SV_StartBug> uint32_t id ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( size_left < 4 ) { LogError ( ""Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>withdraw<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u"" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; } "
215,"<S2SV_StartBug> separator = strchr ( connection -> buffer , ':' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
216,<S2SV_StartBug> if ( option ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ( * session_ptr ) -> max_settings = NGHTTP2_DEFAULT_MAX_SETTINGS ; <S2SV_ModStart> if ( ( option -> opt_set_mask & NGHTTP2_OPT_MAX_SETTINGS ) && option -> max_settings ) { ( * session_ptr ) -> max_settings = option -> max_settings ; } 
217,"<S2SV_StartBug> if ( rc < 0 ) <S2SV_EndBug> <S2SV_StartBug> dev_err ( & port -> dev , ""Reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed<S2SV_blank>(error<S2SV_blank>=<S2SV_blank>%d)\\n"" , <S2SV_EndBug> ","<S2SV_ModStart> != KLSI_STATUSBUF_LEN ) { <S2SV_ModEnd> <S2SV_ModStart> ""reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed:<S2SV_blank>%d\\n"" , rc ) ; if ( rc >= 0 ) rc = - EIO ; } <S2SV_ModEnd> "
218,<S2SV_StartBug> if ( nbytes < sizeof ( * hwrpb ) ) <S2SV_EndBug> ,<S2SV_ModStart> > <S2SV_ModEnd> 
219,"<S2SV_StartBug> jsWarn ( ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> { jsExceptionHere ( JSET_ERROR , <S2SV_ModEnd> <S2SV_ModStart> return 0 ; } if ( gfx . data . height & 7 ) { jsExceptionHere ( JSET_ERROR , ""height<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8<S2SV_blank>when<S2SV_blank>using<S2SV_blank>vertical_byte\\n"" ) ; return 0 ; } "
220,"<S2SV_StartBug> if ( NFS_PROTO ( inode ) -> have_delegation ( inode , FMODE_WRITE ) ) <S2SV_EndBug> <S2SV_StartBug> if ( nfs_write_pageuptodate ( page , inode ) && ( inode -> i_flock == NULL || <S2SV_EndBug> <S2SV_StartBug> inode -> i_flock -> fl_type != F_RDLCK ) ) ) <S2SV_EndBug> ","<S2SV_ModStart> ! nfs_write_pageuptodate ( page , inode ) ) return 0 ; if ( <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
221,"<S2SV_StartBug> const struct oe_sockaddr * src_addr , <S2SV_EndBug> <S2SV_StartBug> oe_socklen_t addrlen_in = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! sock || ( count && ! buf ) ) <S2SV_EndBug> <S2SV_StartBug> ( struct oe_sockaddr * ) src_addr , <S2SV_EndBug> <S2SV_StartBug> addrlen ) != OE_OK ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = 0 ; oe_socklen_t addrlen_out <S2SV_ModStart> || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( src_addr && <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> & addrlen_out <S2SV_ModEnd> <S2SV_ModStart> if ( src_addr && addrlen ) { if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; * addrlen = addrlen_out ; } if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } 
222,<S2SV_StartBug> ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( ps_dec ) ; <S2SV_EndBug> ,<S2SV_ModStart> { i_temp = ih264d_read_mmco_commands ( ps_dec ) ; if ( i_temp < 0 ) { return ERROR_DBP_MANAGER_T ; } <S2SV_ModStart> i_temp ; } <S2SV_ModEnd> 
223,"<S2SV_StartBug> static MB_PREDICTION_MODE read_intra_mode_y ( VP9_COMMON * cm , vp9_reader * r , <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE y_mode = read_intra_mode ( r , <S2SV_EndBug> <S2SV_StartBug> cm -> fc . y_mode_prob [ size_group ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ","<S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> MACROBLOCKD * xd , vpx_reader <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> "
224,<S2SV_StartBug> if ( file -> name ) XFREE ( file -> name ) ; <S2SV_EndBug> <S2SV_StartBug> file -> len = a -> values [ 0 ] . len ; <S2SV_EndBug> <S2SV_StartBug> if ( file -> mime_type ) XFREE ( file -> mime_type ) ; <S2SV_EndBug> <S2SV_StartBug> if ( file -> content_id ) XFREE ( file -> content_id ) ; <S2SV_EndBug> ,<S2SV_ModStart> assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> assert ( ( a -> type == szMAPI_BINARY ) || ( a -> type == szMAPI_OBJECT ) ) ; <S2SV_ModStart> assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> assert ( a -> type == szMAPI_STRING ) ; 
225,"<S2SV_StartBug> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> fl6 -> saddr = ireq -> ir_v6_loc_addr ; <S2SV_EndBug> ",<S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) <S2SV_ModStart> rcu_read_unlock ( ) ; 
226,<S2SV_StartBug> new -> cid_mask = new -> lid_mask = 0xffff ; <S2SV_EndBug> ,<S2SV_ModStart> ( 1 << KVM_X2APIC_CID_BITS ) - 1 ; 
227,<S2SV_StartBug> ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( rr -> u . ER . len_id + offsetof ( struct rock_ridge , u . ER . data ) > rr -> len ) goto out ; "
228,<S2SV_StartBug> return ( mhlen ) ; <S2SV_EndBug> ,<S2SV_ModStart> - 1 <S2SV_ModEnd> 
229,<S2SV_StartBug> int rc = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! scontext_len ) return - EINVAL 
230,"<S2SV_StartBug> if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> <S2SV_StartBug> l_row -- ; <S2SV_EndBug> ",<S2SV_ModStart> 3 == <S2SV_ModStart> && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> <S2SV_ModStart> LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ; 
231,"<S2SV_StartBug> float * w = get_window ( f , n ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( w == NULL ) return 0 
232,"<S2SV_StartBug> if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> for ( n = 0 ; n < num_images ; n ++ ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( num_images < 1 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; "
233,"<S2SV_StartBug> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> skip_recode ) <S2SV_EndBug> <S2SV_StartBug> vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; <S2SV_EndBug> <S2SV_StartBug> optimize_b ( plane , block , plane_bsize , tx_size , x , a , l ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( tx_size ) { <S2SV_EndBug> <S2SV_StartBug> vp9_idct32x32_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_idct16x16_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_idct8x8_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> <S2SV_StartBug> xd -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> { if ( x -> quant_fp ) { if ( x -> skip_txfm [ 0 ] == SKIP_TXFM_AC_DC && plane == 0 ) { p -> eobs [ block ] = 0 ; * a = * l = 0 ; return ; } else { vp9_xform_quant_fp ( x , plane , block , plane_bsize , tx_size ) ; } } else { if ( max_txsize_lookup [ plane_bsize ] == tx_size ) { int txfm_blk_index = ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ; if ( x -> skip_txfm [ txfm_blk_index ] == SKIP_TXFM_NONE ) { <S2SV_ModStart> } else if ( x -> skip_txfm [ txfm_blk_index ] == SKIP_TXFM_AC_ONLY ) { vp9_xform_quant_dc ( x , plane , block , plane_bsize , tx_size ) ; } else { p -> eobs [ block ] = 0 ; * a = * l = 0 ; return ; } } else { vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; } } } <S2SV_ModStart> const int ctx = combine_entropy_contexts ( * a , * l ) ; * a = * l = optimize_b ( x , plane , block , tx_size , ctx ) > 0 <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> vp9_highbd_idct32x32_add <S2SV_ModEnd> <S2SV_ModStart> p -> eobs [ block ] , xd -> bd <S2SV_ModEnd> <S2SV_ModStart> vp9_highbd_idct16x16_add <S2SV_ModEnd> <S2SV_ModStart> p -> eobs [ block ] , xd -> bd <S2SV_ModEnd> <S2SV_ModStart> vp9_highbd_idct8x8_add <S2SV_ModEnd> <S2SV_ModStart> p -> eobs [ block ] , xd -> bd <S2SV_ModEnd> <S2SV_ModStart> x -> highbd_itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd <S2SV_ModEnd> <S2SV_ModStart> return ; } # endif switch ( tx_size ) { case TX_32X32 : vp9_idct32x32_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; case TX_16X16 : vp9_idct16x16_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; case TX_8X8 : vp9_idct8x8_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; case TX_4X4 : x -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; default : assert ( 0 && ""Invalid<S2SV_blank>transform<S2SV_blank>size"" ) ; break ; } "
234,<S2SV_StartBug> iris_info . dimension = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; if ( ( iris_info . dimension == 0 ) || ( iris_info . dimension > 3 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" "
235,<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> int rowstep ; <S2SV_EndBug> ,<S2SV_ModStart> jas_matind_t i ; jas_matind_t <S2SV_ModEnd> <S2SV_ModStart> jas_matind_t <S2SV_ModEnd> 
236,<S2SV_StartBug> for ( ifa1 = in_dev -> ifa_list ; ifa1 ; ifa1 = ifa1 -> ifa_next ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( in_dev -> dead ) goto no_promotions ; <S2SV_ModStart> no_promotions : 
237,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> 
238,<S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> return false ; } } else if ( r -> CRn == 0 && r -> CRm == 9 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; <S2SV_ModEnd> <S2SV_ModStart> return false <S2SV_ModEnd> 
239,"<S2SV_StartBug> static void xen_netbk_idx_release ( struct xen_netbk * netbk , u16 pending_idx ) <S2SV_EndBug> <S2SV_StartBug> make_tx_response ( vif , & pending_tx_info -> req , XEN_NETIF_RSP_OKAY ) ; <S2SV_EndBug> ","<S2SV_ModStart> , u8 status <S2SV_ModStart> status <S2SV_ModEnd> "
240,"<S2SV_StartBug> status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ; <S2SV_EndBug> <S2SV_StartBug> goto release_write_pending_unlocked ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> release_write_pending_unlocked : <S2SV_EndBug> ","<S2SV_ModStart> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_ModStart> release_write_pending <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
241,"<S2SV_StartBug> ret = mount ( path , destpath , ""none"" , MS_BIND , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> safe_mount ( path , destpath , ""none"" , MS_BIND , NULL , conf -> rootfs . mount <S2SV_ModEnd> "
242,"<S2SV_StartBug> status = ocfs2_rw_lock ( inode , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> goto bail_unlock ; <S2SV_EndBug> ",<S2SV_ModStart> inode_dio_wait ( inode ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
243,"<S2SV_StartBug> count = yr_max ( 64 , ( index + 1 ) * 2 ) ; <S2SV_EndBug> <S2SV_StartBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc ( <S2SV_EndBug> ",<S2SV_ModStart> 64 ; while ( count <= index ) count *= 2 <S2SV_ModEnd> <S2SV_ModStart> while ( count <= index ) count *= 2 ; 
244,<S2SV_StartBug> if ( len > count ) <S2SV_EndBug> ,<S2SV_ModStart> ( unsigned long ) len > ( unsigned long ) <S2SV_ModEnd> 
245,<S2SV_StartBug> return KADM5_BAD_MASK ; <S2SV_EndBug> ,<S2SV_ModStart> if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail != NULL ; tl_data_tail = tl_data_tail -> tl_data_next ) { if ( tl_data_tail -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; } } 
246,"<S2SV_StartBug> int rose_parse_facilities ( unsigned char * p , <S2SV_EndBug> <S2SV_StartBug> if ( facilities_len == 0 ) <S2SV_EndBug> <S2SV_StartBug> while ( facilities_len > 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ","<S2SV_ModStart> , unsigned packet_len <S2SV_ModStart> || ( unsigned ) facilities_len > packet_len <S2SV_ModStart> >= 3 && <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> break ; default : printk ( KERN_DEBUG ""ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\n"" , * p ) ; len = 1 ; break ; } <S2SV_ModStart> ) return 0 ; if ( WARN_ON ( len >= facilities_len ) <S2SV_ModStart> } return facilities_len == 0 <S2SV_ModEnd> "
247,<S2SV_StartBug> if ( ( creds -> pid == task_tgid_vnr ( current ) || nsown_capable ( CAP_SYS_ADMIN ) ) && <S2SV_EndBug> ,"<S2SV_ModStart> ns_capable ( current -> nsproxy -> pid_ns -> user_ns , <S2SV_ModEnd> "
248,<S2SV_StartBug> outpos += <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sendClean ( outputbuffer ) ; 
249,"<S2SV_StartBug> media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ; <S2SV_EndBug> <S2SV_StartBug> media_device_kpad_to_upad ( entity -> links [ l ] . source , <S2SV_EndBug> ","<S2SV_ModStart> memset ( & pad , 0 , sizeof ( pad ) ) ; <S2SV_ModStart> memset ( & link , 0 , sizeof ( link ) ) ; "
250,<S2SV_StartBug> efx -> rxq_entries = efx -> txq_entries = EFX_DEFAULT_DMAQ_SIZE ; <S2SV_EndBug> ,<S2SV_ModStart> BUILD_BUG_ON ( EFX_DEFAULT_DMAQ_SIZE < EFX_RXQ_MIN_ENT ) ; if ( WARN_ON ( EFX_DEFAULT_DMAQ_SIZE < EFX_TXQ_MIN_ENT ( efx ) ) ) { rc = - EINVAL ; goto fail3 ; } 
251,<S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> <S2SV_StartBug> if ( ! err ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && msg -> msg_name ) { struct sockaddr_at * sat = msg -> msg_name ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
252,"<S2SV_StartBug> if ( ( st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbprincipalkey"" , <S2SV_EndBug> <S2SV_StartBug> LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ) != 0 ) <S2SV_EndBug> ",<S2SV_ModStart> bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } if ( bersecretkey [ 0 ] != NULL || ! create_standalone_prinicipal ) { <S2SV_ModEnd> <S2SV_ModStart> ; if ( st != 0 ) goto cleanup ; } <S2SV_ModEnd> 
253,<S2SV_StartBug> pirlvl = pi -> picomp -> pirlvls ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || <S2SV_EndBug> <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || <S2SV_EndBug> ,"<S2SV_ModStart> if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> "
254,<S2SV_StartBug> bh -> b_size = map . m_len << inode -> i_blkbits ; <S2SV_EndBug> ,<S2SV_ModStart> ( u64 ) 
255,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && frame -> linesize [ plane ] 
256,"<S2SV_StartBug> memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( l > ll ) l = ll ; 
257,<S2SV_StartBug> addr -> sap_family = AF_ATMPVC ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( addr , 0 , sizeof ( * addr ) ) ; "
258,<S2SV_StartBug> file_sb_list_del ( file ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
259,<S2SV_StartBug> for ( i = 0 ; i < 4 && out -> data [ i ] ; i ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && out -> linesize [ i ] 
260,<S2SV_StartBug> WORD16 i2_level_arr [ 16 ] ; <S2SV_EndBug> ,<S2SV_ModStart> ai2_level_arr [ 19 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> 
261,"<S2SV_StartBug> image = 0 ; <S2SV_EndBug> <S2SV_StartBug> jas_eprintf ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> bmp_dec_importopts_t opts ; size_t num_samples ; image = 0 ; info = 0 ; if ( bmp_dec_parseopts ( optstr , & opts ) ) { goto error <S2SV_ModEnd> <S2SV_ModStart> ) ; goto error ; } if ( ! jas_safe_size_mul3 ( info -> width , info -> height , info -> numplanes , & num_samples ) ) { jas_eprintf ( ""image<S2SV_blank>size<S2SV_blank>too<S2SV_blank>large\\n"" ) ; goto error ; } if ( opts . max_samples > 0 && num_samples > opts . max_samples ) { jas_eprintf ( ""maximum<S2SV_blank>number<S2SV_blank>of<S2SV_blank>pixels<S2SV_blank>exceeded<S2SV_blank>(%zu)\\n"" , opts . max_samples "
262,"<S2SV_StartBug> q = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> <S2SV_StartBug> q = strchr ( uri , '<S2SV_blank>' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> 
263,<S2SV_StartBug> BUG_ON ( ! thresholds ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & memcg -> thresholds_lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! thresholds -> primary ) goto unlock <S2SV_ModStart> unlock : 
264,"<S2SV_StartBug> char query [ 255 ] ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( query , ""SELECT<S2SV_blank>COUNT(*)<S2SV_blank>FROM<S2SV_blank>`%s`"" , trow [ 0 ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> NAME_LEN + 100 <S2SV_ModEnd> <S2SV_ModStart> my_snprintf <S2SV_ModEnd> <S2SV_ModStart> sizeof ( query ) , "
265,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> return - ENOMEM ; } return <S2SV_ModEnd> 
266,"<S2SV_StartBug> skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ; <S2SV_EndBug> ",<S2SV_ModStart> m -> msg_namelen = 0 ; 
267,<S2SV_StartBug> tok -> err = json_tokener_success ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ( len < - 1 ) || ( len == - 1 && strlen ( str ) > INT32_MAX ) ) { tok -> err = json_tokener_error_size ; return NULL ; } 
268,<S2SV_StartBug> ascii = malloc ( strlen ( str ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ascii = malloc ( str_len ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> <S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
269,<S2SV_StartBug> prepenv ( const struct rule * rule ) <S2SV_EndBug> <S2SV_StartBug> env = createenv ( rule ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , const struct passwd * mypw , const struct passwd * targpw ) { <S2SV_ModEnd> <S2SV_ModStart> , mypw , targpw <S2SV_ModEnd> "
270,<S2SV_StartBug> if ( hashbin -> hb_type & HB_LOCK ) { <S2SV_EndBug> <S2SV_StartBug> queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> while ( queue ) { <S2SV_EndBug> <S2SV_StartBug> ( * free_func ) ( queue ) ; <S2SV_EndBug> <S2SV_StartBug> if ( hashbin -> hb_type & HB_LOCK ) { <S2SV_EndBug> <S2SV_StartBug> # ifdef CONFIG_LOCKDEP <S2SV_EndBug> ,"<S2SV_ModStart> spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; <S2SV_ModEnd> <S2SV_ModStart> while ( 1 ) { <S2SV_ModStart> if ( ! queue ) break ; <S2SV_ModEnd> <S2SV_ModStart> { if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ; free_func ( queue ) ; if ( hashbin -> hb_type & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
271,<S2SV_StartBug> section -> spatial_layer_id = frame -> spatial_layer_id ; <S2SV_EndBug> <S2SV_StartBug> section -> ssim_weighted_pred_err += frame -> ssim_weighted_pred_err ; <S2SV_EndBug> <S2SV_StartBug> section -> pcnt_neutral += frame -> pcnt_neutral ; <S2SV_EndBug> ,<S2SV_ModStart> weight += frame -> weight ; section -> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; section -> intra_skip_pct += frame -> intra_skip_pct ; section -> inactive_zone_rows += frame -> inactive_zone_rows ; section -> inactive_zone_cols += frame -> inactive_zone_cols 
272,<S2SV_StartBug> struct loop_device * lo = disk -> private_data ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & lo -> lo_ctl_mutex ) ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & loop_index_mutex ) ; __lo_release ( <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart> loop_index_mutex <S2SV_ModEnd> 
273,"<S2SV_StartBug> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { <S2SV_EndBug> ","<S2SV_ModStart> caller_may_see_dir ( fc -> pid , controller , cgroup ) ) { ret = - ENOENT ; goto out ; } if ( ! "
274,<S2SV_StartBug> error = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
275,<S2SV_StartBug> countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ; <S2SV_EndBug> ,<S2SV_ModStart> tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ; 
276,"<S2SV_StartBug> unsigned char * buf ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && bufsize 
277,<S2SV_StartBug> if ( val > sysctl_wmem_max ) <S2SV_EndBug> <S2SV_StartBug> if ( ( val * 2 ) < SOCK_MIN_SNDBUF ) <S2SV_EndBug> <S2SV_StartBug> if ( val > sysctl_rmem_max ) <S2SV_EndBug> <S2SV_StartBug> if ( ( val * 2 ) < SOCK_MIN_RCVBUF ) <S2SV_EndBug> ,"<S2SV_ModStart> val = min_t ( u32 , val , sysctl_wmem_max ) <S2SV_ModEnd> <S2SV_ModStart> sk -> sk_sndbuf = max_t ( u32 , <S2SV_ModEnd> <S2SV_ModStart> , SOCK_MIN_SNDBUF ) <S2SV_ModEnd> <S2SV_ModStart> val = min_t ( u32 , val , sysctl_rmem_max ) <S2SV_ModEnd> <S2SV_ModStart> sk -> sk_rcvbuf = max_t ( u32 , <S2SV_ModEnd> <S2SV_ModStart> , SOCK_MIN_RCVBUF ) <S2SV_ModEnd> "
278,"<S2SV_StartBug> GetPixelIndex ( image , q ) , q ) ; <S2SV_EndBug> ","<S2SV_ModStart> ConstrainColormapIndex ( image , <S2SV_ModStart> ) , exception "
279,"<S2SV_StartBug> while ( ( ch = getopt ( ac , av , ""cDdksE:a:t:"" ) ) != - 1 ) { <S2SV_EndBug> <S2SV_StartBug> k_flag ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ac == 0 && ! c_flag && ! s_flag ) { <S2SV_EndBug> <S2SV_StartBug> if ( pledge ( ""stdio<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec"" , NULL ) == - 1 ) <S2SV_EndBug> ","<S2SV_ModStart> ""cDdksE:a:P:t:"" <S2SV_ModEnd> <S2SV_ModStart> ; break ; case 'P' : if ( pkcs11_whitelist != NULL ) fatal ( ""-P<S2SV_blank>option<S2SV_blank>already<S2SV_blank>specified"" ) ; pkcs11_whitelist = xstrdup ( optarg ) <S2SV_ModStart> pkcs11_whitelist == NULL ) pkcs11_whitelist = xstrdup ( DEFAULT_PKCS11_WHITELIST ) ; if ( <S2SV_ModStart> ""stdio<S2SV_blank>rpath<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec"" <S2SV_ModEnd> "
280,<S2SV_StartBug> int i ; <S2SV_EndBug> ,<S2SV_ModStart> jas_matind_t i ; jas_matind_t <S2SV_ModEnd> 
281,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( packet -> payload [ 0 ] == 0x16 && packet -> payload [ 1 ] == 0x80 && packet -> payload [ 4 ] == 0x06 && packet -> payload [ 5 ] == 0x00 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> { if ( ( packet -> payload_packet_len >= 5 ) && <S2SV_ModEnd> <S2SV_ModStart> ) && ( <S2SV_ModEnd> <S2SV_ModStart> ) && ( <S2SV_ModEnd> <S2SV_ModStart> ) && ( <S2SV_ModEnd> <S2SV_ModStart> ) 
282,<S2SV_StartBug> mnt_flags |= mnt -> mnt . mnt_flags & MNT_PROPAGATION_MASK ; <S2SV_EndBug> ,<S2SV_ModStart> ~ MNT_USER_SETTABLE_MASK <S2SV_ModEnd> 
283,<S2SV_StartBug> path = g_get_tmp_dir ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> g_get_home_dir <S2SV_ModEnd> 
284,<S2SV_StartBug> align = ( 1 << xcs ) - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! img ) { <S2SV_EndBug> ,"<S2SV_ModStart> w = d_w ; h = d_h ; s = ( fmt & VPX_IMG_FMT_PLANAR ) ? w : bps * w / 8 ; s = ( s + stride_align - 1 ) & ~ ( stride_align - 1 ) ; stride_in_bytes = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? s * 2 : s ; if ( ! img ) { img = ( vpx_image_t * ) calloc ( 1 , sizeof ( vpx_image_t ) ) ; if ( ! img ) goto fail ; img -> self_allocd = 1 ; } else { memset ( img , 0 , sizeof ( vpx_image_t ) ) ; } img -> img_data = img_data ; if ( ! img_data ) { uint64_t alloc_size ; <S2SV_ModStart>  <S2SV_ModEnd> "
285,<S2SV_StartBug> INIT_LIST_HEAD ( & f -> f_u . fu_list ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
286,<S2SV_StartBug> saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> ,<S2SV_ModStart> INADDR_LOOPBACK <S2SV_ModEnd> 
287,<S2SV_StartBug> if ( count < sizeof hdr ) <S2SV_EndBug> ,<S2SV_ModStart> WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ; if ( 
288,<S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> <S2SV_StartBug> offset += 4 + len ; <S2SV_EndBug> <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> <S2SV_StartBug> offset += 4 + len ; <S2SV_EndBug> ,<S2SV_ModStart> if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload <S2SV_ModStart> if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload 
289,<S2SV_StartBug> jumpstack [ stackidx ++ ] = e ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; } 
290,<S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( int ) 
291,"<S2SV_StartBug> list_add_tail ( & info -> list , & xen_irq_list_head ) ; <S2SV_EndBug> ",<S2SV_ModStart> INIT_LIST_HEAD ( & info -> eoi_list ) ; 
292,"<S2SV_StartBug> const VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> rc -> bits_off_target += rc -> av_per_frame_bandwidth - encoded_frame_size ; <S2SV_EndBug> <S2SV_StartBug> rc -> bits_off_target = MIN ( rc -> bits_off_target , oxcf -> maximum_buffer_size ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> use_svc && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> rc <S2SV_ModEnd> <S2SV_ModStart> is_one_pass_cbr_svc ( cpi ) <S2SV_ModEnd> 
293,"<S2SV_StartBug> sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) sun_info . length , <S2SV_EndBug> <S2SV_StartBug> sizeof ( * sun_data ) ) ; <S2SV_EndBug> <S2SV_StartBug> height = sun_info . height ; <S2SV_EndBug> ","<S2SV_ModStart> bytes_per_line = sun_info . width * sun_info . depth ; <S2SV_ModStart> MagickMax ( <S2SV_ModStart> bytes_per_line * sun_info . width ) , <S2SV_ModStart>  <S2SV_ModEnd> "
294,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> skip_metadata ( ps ) ; 
295,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> # if 0 <S2SV_ModStart> # endif 
296,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
297,"<S2SV_StartBug> error = copy_to_user ( buf , & socket_packet -> icmp_packet , <S2SV_EndBug> <S2SV_StartBug> socket_packet -> icmp_len ) ; <S2SV_EndBug> ","<S2SV_ModStart> packet_len = min ( count , socket_packet -> icmp_len ) ; <S2SV_ModStart> packet_len ) <S2SV_ModEnd> "
298,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( up -> replay_window > up -> bmp_len * sizeof ( __u32 ) * 8 ) return - EINVAL ; 
299,"<S2SV_StartBug> uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ; <S2SV_EndBug> <S2SV_StartBug> WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || <S2SV_EndBug> ","<S2SV_ModStart> = 0 , desc_chunk <S2SV_ModStart> ; desc_chunk = 1 <S2SV_ModStart> desc_chunk || ! "
300,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> set_acl_inode ( inode , inode -> i_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( error <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
301,<S2SV_StartBug> } else { <S2SV_EndBug> ,"<S2SV_ModStart> { uint8_t computedHvi [ 32 ] ; uint16_t HelloMessageLength = zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength ; uint16_t DHPartHelloMessageStringLength = zrtpPacket -> messageLength + HelloMessageLength ; uint8_t * DHPartHelloMessageString = ( uint8_t * ) malloc ( DHPartHelloMessageStringLength * sizeof ( uint8_t ) ) ; memcpy ( DHPartHelloMessageString , input + ZRTP_PACKET_HEADER_LENGTH , zrtpPacket -> messageLength ) ; memcpy ( DHPartHelloMessageString + zrtpPacket -> messageLength , zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , HelloMessageLength ) ; zrtpChannelContext -> hashFunction ( DHPartHelloMessageString , DHPartHelloMessageStringLength , 32 , computedHvi ) ; free ( DHPartHelloMessageString ) ; if ( memcmp ( computedHvi , peerCommitMessageData -> hvi , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHVI ; } } "
302,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ca . name [ sizeof ( ca . name ) - 1 ] = 0 ; 
303,<S2SV_StartBug> if ( keyring ) <S2SV_EndBug> ,<S2SV_ModStart> && link_ret == 0 
304,"<S2SV_StartBug> size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ; <S2SV_EndBug> <S2SV_StartBug> luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; luaL_argcheck ( L , pos > 0 , 3 , ""offset<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ) ; pos -- <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && pos <= ld - size , <S2SV_ModEnd> "
305,<S2SV_StartBug> up_read ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> & control -> id ) ; <S2SV_EndBug> ,<S2SV_ModStart> struct snd_ctl_elem_id id = control -> id ; <S2SV_ModStart> & <S2SV_ModEnd> 
306,<S2SV_StartBug> evtchn = info -> evtchn ; <S2SV_EndBug> <S2SV_StartBug> if ( ! VALID_EVTCHN ( evtchn ) ) <S2SV_EndBug> ,"<S2SV_ModStart> unsigned int cpu ; <S2SV_ModStart> || ! list_empty ( & info -> eoi_list ) ) return ; cpu = info -> eoi_cpu ; if ( info -> eoi_time && info -> irq_epoch == per_cpu ( irq_epoch , cpu ) ) { lateeoi_list_add ( info ) ; return ; } info -> eoi_time = 0 <S2SV_ModEnd> "
307,"<S2SV_StartBug> static vpx_codec_err_t vp8_set_postproc ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> <S2SV_StartBug> return VPX_CODEC_INCAPABLE ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( void ) ctx ; ( void ) args ; 
308,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , regs -> ARM_pc ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
309,<S2SV_StartBug> file_update_time ( vma -> vm_file ) ; <S2SV_EndBug> <S2SV_StartBug> sb_end_pagefault ( inode -> i_sb ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; down_read ( & EXT4_I ( inode ) -> i_mmap_sem <S2SV_ModStart> up_read ( & EXT4_I ( inode ) -> i_mmap_sem ) ; 
310,"<S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> ",<S2SV_ModStart> 3 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 3 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
311,"<S2SV_StartBug> char * buf , * payload ; <S2SV_EndBug> <S2SV_StartBug> int ret = - 1 , result = - 1 ; <S2SV_EndBug> <S2SV_StartBug> int total = 0 ; <S2SV_EndBug> <S2SV_StartBug> } else if ( 0 == ret ) { <S2SV_EndBug> ","<S2SV_ModStart> int result <S2SV_ModEnd> <S2SV_ModStart> ; ws_ctx_t * wsctx = ( ws_ctx_t * ) cl -> wsctx ; rfbLog ( ""%s_enter:<S2SV_blank>len=%d;<S2SV_blank>"" ""CTX:<S2SV_blank>readlen=%d<S2SV_blank>readPos=%p<S2SV_blank>"" ""writeTo=%p<S2SV_blank>"" ""state=%d<S2SV_blank>toRead=%d<S2SV_blank>remaining=%d<S2SV_blank>"" ""<S2SV_blank>nReadRaw=%d<S2SV_blank>carrylen=%d<S2SV_blank>carryBuf=%p\\n"" , __func__ , len , wsctx -> readlen , wsctx -> readPos , wsctx -> writePos , wsctx -> hybiDecodeState , wsctx -> nToRead , hybiRemaining ( wsctx ) , wsctx -> nReadRaw , wsctx -> carrylen , wsctx -> carryBuf ) ; switch ( wsctx -> hybiDecodeState ) { case WS_HYBI_STATE_HEADER_PENDING : wsctx -> hybiDecodeState = hybiReadHeader ( cl , & result ) ; if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_ERR ) { goto spor ; } if ( wsctx -> hybiDecodeState != WS_HYBI_STATE_HEADER_PENDING ) { wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; } break ; case WS_HYBI_STATE_DATA_AVAILABLE : wsctx -> hybiDecodeState = hybiReturnData ( dst , len , wsctx , & result ) ; break ; case WS_HYBI_STATE_DATA_NEEDED : wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; break ; case WS_HYBI_STATE_CLOSE_REASON_PENDING : wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; break ; default : rfbErr ( ""%s:<S2SV_blank>called<S2SV_blank>with<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>%d\\n"" , wsctx -> hybiDecodeState ) ; <S2SV_ModEnd> <S2SV_ModStart> errno = EIO ; wsctx -> hybiDecodeState = WS_HYBI_STATE_ERR ; } spor : if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE ) { rfbLog ( ""frame<S2SV_blank>received<S2SV_blank>successfully,<S2SV_blank>cleaning<S2SV_blank>up:<S2SV_blank>read=%d<S2SV_blank>hlen=%d<S2SV_blank>plen=%d\\n"" , wsctx -> header . nRead , wsctx -> header . headerLen , wsctx -> header . payloadLen ) ; hybiDecodeCleanup ( wsctx ) <S2SV_ModEnd> <S2SV_ModStart> wsctx -> hybiDecodeState == WS_HYBI_STATE_ERR ) { hybiDecodeCleanup ( wsctx ) ; } rfbLog ( ""%s_exit:<S2SV_blank>len=%d;<S2SV_blank>"" ""CTX:<S2SV_blank>readlen=%d<S2SV_blank>readPos=%p<S2SV_blank>"" ""writePos=%p<S2SV_blank>"" ""state=%d<S2SV_blank>toRead=%d<S2SV_blank>remaining=%d<S2SV_blank>"" ""nRead=%d<S2SV_blank>carrylen=%d<S2SV_blank>carryBuf=%p<S2SV_blank>"" ""result=%d\\n"" , __func__ , len , wsctx -> readlen , wsctx -> readPos , wsctx -> writePos , wsctx -> hybiDecodeState , wsctx -> nToRead , hybiRemaining ( wsctx ) , wsctx -> nReadRaw , wsctx -> carrylen , wsctx -> carryBuf , result ) ; return <S2SV_ModEnd> "
312,<S2SV_StartBug> double motion_pct = next_frame -> pcnt_motion ; <S2SV_EndBug> ,<S2SV_ModStart> ; ( void ) cpi 
313,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
314,<S2SV_StartBug> opt -> optlen = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt ) <S2SV_EndBug> ,"<S2SV_ModStart> struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> inet_opt ) memcpy ( optbuf , & inet_opt -> opt , sizeof ( struct ip_options ) + inet_opt -> opt . <S2SV_ModEnd> "
315,"<S2SV_StartBug> UINT32 PathLength ; <S2SV_EndBug> <S2SV_StartBug> Stream_Seek ( irp -> input , 28 ) ; <S2SV_EndBug> <S2SV_StartBug> status = ConvertFromUnicode ( CP_UTF8 , 0 , ( WCHAR * ) Stream_Pointer ( irp -> input ) , PathLength / 2 , <S2SV_EndBug> ","<S2SV_ModStart> WCHAR * ptr ; <S2SV_ModStart> if ( ! Stream_SafeSeek <S2SV_ModEnd> <S2SV_ModStart> ) return ERROR_INVALID_DATA ; if ( Stream_GetRemainingLength ( irp -> input ) < 4 ) return ERROR_INVALID_DATA <S2SV_ModStart> ptr = ( WCHAR * ) Stream_Pointer ( irp -> input ) ; if ( ! Stream_SafeSeek ( irp -> input , PathLength ) ) return ERROR_INVALID_DATA ; <S2SV_ModStart> ptr <S2SV_ModEnd> "
316,<S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> ,<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> 
317,<S2SV_StartBug> void * buffer ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( params -> buffer . fragment_size == 0 || params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) return - EINVAL 
318,<S2SV_StartBug> if ( md_sk != NULL ) { <S2SV_EndBug> <S2SV_StartBug> if ( PKCS7_is_detached ( p7 ) || ( in_bio != NULL ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> data_body == NULL && in_bio == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; goto err ; } if ( <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
319,<S2SV_StartBug> touch_atime ( & path ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! IS_ERR ( raw ) ) 
320,<S2SV_StartBug> proc = rqstp -> rq_procinfo ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( nfs_request_too_big ( rqstp , proc ) ) { dprintk ( ""nfsd:<S2SV_blank>NFSv%d<S2SV_blank>argument<S2SV_blank>too<S2SV_blank>large\\n"" , rqstp -> rq_vers ) ; * statp = rpc_garbage_args ; return 1 ; } "
321,"<S2SV_StartBug> if ( my_copystat ( org_name , tmp_name , MyFlags ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> goto end ; <S2SV_EndBug> ",<S2SV_ModStart> ! ( MyFlags & MY_REDEL_NO_COPY_STAT ) ) { if ( <S2SV_ModStart> } 
322,<S2SV_StartBug> e . ifindex = port -> dev -> ifindex ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & e , 0 , sizeof ( e ) ) ; "
323,"<S2SV_StartBug> u_int len , j ; <S2SV_EndBug> ","<S2SV_ModStart> if ( * rdnSeqBuf_offset >= rdnSeqBuf_len ) { # ifdef DEBUG_TLS printf ( ""[TLS]<S2SV_blank>%s()<S2SV_blank>[buffer<S2SV_blank>capacity<S2SV_blank>reached][%u]\\n"" , __FUNCTION__ , rdnSeqBuf_len ) ; # endif return - 1 ; } "
324,<S2SV_StartBug> sec = t % 86400 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( days > 2932896 ) { days = 2932896 ; sec = 86399 ; } 
325,"<S2SV_StartBug> struct rose_sock * rose = rose_sk ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( srose != NULL ) { <S2SV_EndBug> <S2SV_StartBug> memset ( srose , 0 , msg -> msg_namelen ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> msg -> msg_name ) { struct sockaddr_rose * srose ; memset ( msg -> msg_name <S2SV_ModEnd> <S2SV_ModStart> sizeof ( struct full_sockaddr_rose ) ) ; srose = msg -> msg_name <S2SV_ModEnd> 
326,"<S2SV_StartBug> if ( ( o + s < o ) || ( o + s < s ) || ( o + s > ds ) || ( o > ds ) ) { <S2SV_EndBug> <S2SV_StartBug> exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , <S2SV_EndBug> ","<S2SV_ModStart> o >= ds <S2SV_ModEnd> <S2SV_ModStart> ""Bogus<S2SV_blank>thumbnail<S2SV_blank>offset<S2SV_blank>(%u)."" , o ) ; return ; } if ( s > ds - o ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Bogus<S2SV_blank>thumbnail<S2SV_blank>size<S2SV_blank>(%u),<S2SV_blank>max<S2SV_blank>would<S2SV_blank>be<S2SV_blank>%u."" , s , ds - o <S2SV_ModEnd> "
327,<S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> ,<S2SV_ModStart> || ! SecIsValidHandle ( handle ) 
328,<S2SV_StartBug> fdput ( f ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
329,<S2SV_StartBug> if ( len < 20 ) <S2SV_EndBug> ,"<S2SV_ModStart> 32 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]"" <S2SV_ModEnd> "
330,<S2SV_StartBug> ( ( YR_OBJECT_INTEGER * ) copy ) -> value = UNDEFINED ; <S2SV_EndBug> <S2SV_StartBug> ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ( ( YR_OBJECT_INTEGER * ) object ) -> value <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModStart> object ) -> value != NULL ) { ( ( YR_OBJECT_STRING * ) copy ) -> value = sized_string_dup ( ( ( YR_OBJECT_STRING * ) object ) -> value ) ; } else { ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ; } break ; case OBJECT_TYPE_FLOAT : ( ( YR_OBJECT_DOUBLE * ) copy ) -> value = ( ( YR_OBJECT_DOUBLE * ) object ) -> value <S2SV_ModEnd> 
331,<S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ipt_entry ) && <S2SV_EndBug> <S2SV_StartBug> t -> verdict < 0 && unconditional ( & e -> ip ) ) || <S2SV_EndBug> ,<S2SV_ModStart> unconditional ( e <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
332,<S2SV_StartBug> if ( ( p -> flags & XFRM_STATE_ESN ) && ! rt ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> ,<S2SV_ModStart> struct xfrm_replay_state_esn * rs ; if <S2SV_ModEnd> <S2SV_ModStart> { if ( <S2SV_ModEnd> <S2SV_ModStart> rs = nla_data ( rt ) ; if ( rs -> bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof ( rs -> bmp [ 0 ] ) / 8 ) return - EINVAL ; if ( nla_len ( rt ) < xfrm_replay_state_esn_len ( rs ) && nla_len ( rt ) != sizeof ( * rs ) ) return - EINVAL ; } 
333,"<S2SV_StartBug> int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ; <S2SV_EndBug> ",<S2SV_ModStart> unlink ( path ) ; <S2SV_ModStart> O_EXCL <S2SV_ModEnd> 
334,"<S2SV_StartBug> krb5_principal client_principal , <S2SV_EndBug> <S2SV_StartBug> krb5_principal_get_realm ( context , krbtgt -> entry . principal ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> , const char * tgt_realm <S2SV_ModStart> tgt_realm <S2SV_ModEnd> "
335,"<S2SV_StartBug> static void evtchn_fifo_handle_events ( unsigned cpu ) <S2SV_EndBug> <S2SV_StartBug> __evtchn_fifo_handle_events ( cpu , false ) ; <S2SV_EndBug> ","<S2SV_ModStart> , struct evtchn_loop_ctrl * ctrl <S2SV_ModStart> ctrl <S2SV_ModEnd> "
336,<S2SV_StartBug> fdput ( f ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
337,<S2SV_StartBug> queueItem -> srcPort = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> interface = interface ; queueItem -> 
338,"<S2SV_StartBug> static void encode_sb ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int output_enabled , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; <S2SV_EndBug> <S2SV_StartBug> BLOCK_SIZE subsize ; <S2SV_EndBug> <S2SV_StartBug> subsize = * get_sb_partitioning ( x , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> partition = partition_lookup [ bsl ] [ subsize ] ; <S2SV_EndBug> <S2SV_StartBug> if ( output_enabled && bsize >= BLOCK_8X8 ) <S2SV_EndBug> <S2SV_StartBug> encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> <S2SV_StartBug> if ( mi_col + hbs < cm -> mi_cols ) { <S2SV_EndBug> <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> <S2SV_StartBug> if ( mi_row + hbs < cm -> mi_rows ) { <S2SV_EndBug> <S2SV_StartBug> subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; <S2SV_EndBug> <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , <S2SV_ModStart> , PC_TREE * pc_tree <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> b_width_log2_lookup [ bsize ] <S2SV_ModEnd> <S2SV_ModStart> = bsize <S2SV_ModStart> get_subsize ( bsize , pc_tree -> partitioning <S2SV_ModEnd> <S2SV_ModStart> ; if ( output_enabled && bsize != BLOCK_4X4 ) td -> counts -> partition [ ctx ] [ partition ] ++ <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none <S2SV_ModEnd> <S2SV_ModStart> encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> && bsize > BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> && bsize > BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> if ( bsize == BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> leaf_split [ 0 ] ) ; } else { <S2SV_ModEnd> <S2SV_ModStart> td , tile , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> split [ 0 ] ) ; encode_sb ( cpi , td , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 1 ] ) <S2SV_ModEnd> <S2SV_ModStart> td , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> <S2SV_ModStart> td , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 3 ] ) ; } <S2SV_ModEnd> <S2SV_ModStart> 0 && ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; break <S2SV_ModEnd> "
339,<S2SV_StartBug> spin_lock_bh ( & g_cdev . lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( count > sizeof ( ei -> data ) - sizeof ( * elt ) - sizeof ( * app_hdr ) ) return - EINVAL ; 
340,"<S2SV_StartBug> list_add_tail ( & sp -> auto_asconf_list , <S2SV_EndBug> <S2SV_StartBug> sp -> do_auto_asconf = 1 ; <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> sp -> do_auto_asconf = 0 ; <S2SV_EndBug> ",<S2SV_ModStart> spin_lock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; <S2SV_ModStart> ; spin_unlock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) <S2SV_ModStart> { <S2SV_ModStart> } 
341,<S2SV_StartBug> file_sb_list_del ( file ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
342,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( ! item -> valuestring ) { cJSON_Delete ( item ) ; return 0 ; } } <S2SV_ModEnd> 
343,<S2SV_StartBug> sizeof ( uint16_t ) ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ) || ( ( effect_param_t * ) pCmdData ) -> psize > * replySize - sizeof ( effect_param_t 
344,<S2SV_StartBug> return - EEXIST ; <S2SV_EndBug> ,<S2SV_ModStart> 0 <S2SV_ModEnd> 
345,"<S2SV_StartBug> strncpy ( result , ""undefined"" , 10 ) ; <S2SV_EndBug> ",<S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
346,<S2SV_StartBug> FreeStmt ( ( ParseCommon * ) & append ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
347,<S2SV_StartBug> out_release_nounlock : <S2SV_EndBug> ,<S2SV_ModStart> if ( vm_shared ) unlock_page ( page ) ; out_release_nounlock : <S2SV_ModEnd> 
348,<S2SV_StartBug> frag = ( hm_fragment * ) item -> data ; <S2SV_EndBug> ,<S2SV_ModStart> rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data <S2SV_ModEnd> 
349,"<S2SV_StartBug> struct range * range ; <S2SV_EndBug> <S2SV_StartBug> size_t content_length ; <S2SV_EndBug> <S2SV_StartBug> int code = 500 , fd = - 1 , i , nranges , ret ; <S2SV_EndBug> <S2SV_StartBug> if ( ( range = parse_range ( range_str , st -> st_size , & nranges ) ) == NULL ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( evb = evbuffer_new ( ) ) == NULL ) { <S2SV_EndBug> <S2SV_StartBug> ( void ) snprintf ( content_range , sizeof ( content_range ) , <S2SV_EndBug> <S2SV_StartBug> content_length = range -> end - range -> start + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( buffer_add_range ( fd , evb , range ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> content_length = 0 ; <S2SV_EndBug> <S2SV_StartBug> content_length += i ; <S2SV_EndBug> <S2SV_StartBug> range ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ( i = evbuffer_add_printf ( evb , ""\\r\\n--%ud--\\r\\n"" , <S2SV_EndBug> <S2SV_StartBug> content_length += i ; <S2SV_EndBug> <S2SV_StartBug> ""byteranges;<S2SV_blank>boundary=%ud"" , boundary ) ; <S2SV_EndBug> <S2SV_StartBug> close ( fd ) ; <S2SV_EndBug> <S2SV_StartBug> goto done ; <S2SV_EndBug> <S2SV_StartBug> if ( server_bufferevent_write_buffer ( clt , evb ) == - 1 ) <S2SV_EndBug> <S2SV_StartBug> bufferevent_enable ( clt -> clt_bev , EV_READ | EV_WRITE ) ; <S2SV_EndBug> <S2SV_StartBug> if ( clt -> clt_persist ) <S2SV_EndBug> <S2SV_StartBug> if ( evb != NULL ) <S2SV_EndBug> ","<S2SV_ModStart> range_data * r = & clt -> clt_ranges ; struct range * range <S2SV_ModEnd> <S2SV_ModStart> = 0 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> nranges = parse_ranges ( clt , <S2SV_ModEnd> <S2SV_ModStart> ) ) < 1 <S2SV_ModEnd> <S2SV_ModStart> r -> range_media = media ; <S2SV_ModEnd> <S2SV_ModStart> range = & r -> range [ 0 ] ; <S2SV_ModStart> range = & r -> range [ 0 ] ; content_length += <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> arc4random_buf ( & clt -> clt_boundary , sizeof ( clt -> clt_boundary ) ) ; for ( i = 0 ; i < nranges ; i ++ ) { range = & r -> range [ i ] ; if ( ( ret = snprintf ( NULL , 0 , ""\\r\\n--%llu\\r\\n"" ""Content-Type:<S2SV_blank>%s/%s\\r\\n"" ""Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\r\\n\\r\\n"" , clt -> clt_boundary , media -> media_type , media -> media_subtype , range -> start , range -> end , st -> st_size ) ) < 0 <S2SV_ModEnd> <S2SV_ModStart> ret + <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ret = snprintf ( NULL , 0 , ""\\r\\n--%llu--\\r\\n"" , clt -> clt_boundary ) ) < 0 <S2SV_ModEnd> <S2SV_ModStart> ret <S2SV_ModEnd> <S2SV_ModStart> ""byteranges;<S2SV_blank>boundary=%llu"" , clt -> clt_boundary <S2SV_ModEnd> <S2SV_ModStart> r -> range_toread = TOREAD_HTTP_RANGE <S2SV_ModEnd> <S2SV_ModStart> close ( fd ) ; <S2SV_ModStart> clt -> clt_fd = fd ; if ( clt -> clt_srvbev != NULL ) bufferevent_free ( clt -> clt_srvbev ) ; clt -> clt_srvbev_throttled = 0 ; clt -> clt_srvbev = bufferevent_new ( clt -> clt_fd , server_read_httprange , server_write , server_file_error , clt ) ; if ( clt -> clt_srvbev == NULL ) { errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer<S2SV_blank>event"" ; <S2SV_ModEnd> <S2SV_ModStart> } bufferevent_setwatermark ( clt -> clt_srvbev , EV_READ , 0 , clt -> clt_sndbufsiz ) ; bufferevent_settimeout ( clt -> clt_srvbev , srv_conf -> timeout . tv_sec , srv_conf -> timeout . tv_sec ) ; bufferevent_enable ( clt -> clt_srvbev , EV_READ ) ; bufferevent_disable ( clt -> clt_bev , EV_READ ) ; done : server_reset_http ( clt ) ; return ( 0 ) ; fail : bufferevent_disable <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
350,<S2SV_StartBug> io -> io_cleanup = port_cleanup ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> io -> io_cleanup = port_cleanup ; 
351,"<S2SV_StartBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%s);\\n"" <S2SV_EndBug> <S2SV_StartBug> if ( s_poll_interval == NULL ) <S2SV_EndBug> <S2SV_StartBug> session_state , op_iframe_id , s_poll_interval , redirect_uri , <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%d);\\n"" <S2SV_ModEnd> <S2SV_ModStart> int poll_interval = s_poll_interval ? strtol ( s_poll_interval , NULL , 10 ) : 0 ; if ( ( poll_interval <= 0 ) || ( poll_interval > 3600 * 24 ) ) poll_interval = 3000 <S2SV_ModEnd> <S2SV_ModStart> poll_interval <S2SV_ModEnd> "
352,<S2SV_StartBug> exit ( i ) ; <S2SV_EndBug> ,"<S2SV_ModStart> # ifdef HAVE_MKDTEMP if ( no_rc_dir && tmp_dir != rc_dir ) if ( rmdir ( tmp_dir ) != 0 ) { fprintf ( stderr , ""Can\'t<S2SV_blank>remove<S2SV_blank>temporary<S2SV_blank>directory<S2SV_blank>(%s)!\\n"" , tmp_dir ) ; exit ( 1 ) ; } # endif "
353,"<S2SV_StartBug> remaining = tvb_captured_length_remaining ( tvb , offset ) ; <S2SV_EndBug> ",<S2SV_ModStart> tvb_reported_length_remaining <S2SV_ModEnd> 
354,<S2SV_StartBug> new_timer -> it_overrun = - 1 ; <S2SV_EndBug> ,<S2SV_ModStart> 1LL <S2SV_ModEnd> 
355,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && in -> linesize [ plane ] 
356,<S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp && tmp == cluster -> cl_has_local && <S2SV_EndBug> <S2SV_StartBug> return - EBUSY ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp && ! cluster -> cl_has_local ) { <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> <S2SV_StartBug> return count ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { ret = - EINVAL ; goto out ; } <S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto out ; } <S2SV_ModStart> goto out <S2SV_ModEnd> <S2SV_ModStart> ret = count ; out : o2nm_unlock_subsystem ( ) ; return ret <S2SV_ModEnd> 
357,<S2SV_StartBug> if ( ! vcpu -> arch . time_page ) <S2SV_EndBug> ,<S2SV_ModStart> pv_time_enabled <S2SV_ModEnd> 
358,"<S2SV_StartBug> while ( nr > 0 ) { <S2SV_EndBug> <S2SV_StartBug> c = tty -> ops -> write ( tty , b , nr ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct n_tty_data * ldata = tty -> disc_data ; <S2SV_ModStart> mutex_lock ( & ldata -> output_lock ) ; <S2SV_ModStart> ) ; mutex_unlock ( & ldata -> output_lock 
359,"<S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> ","<S2SV_ModStart> | CVAR_PROTECTED <S2SV_ModStart> if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; } "
360,<S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
361,"<S2SV_StartBug> subobj_type = EXTRACT_8BITS ( obj_tptr + offset ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , <S2SV_EndBug> <S2SV_StartBug> EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_tptr + offset + 8 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u"" , <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_16BITS ( obj_tptr + offset ) ; <S2SV_ModStart> ND_TCHECK_8BITS ( obj_tptr + offset + 2 ) ; <S2SV_ModStart> ) ; ND_TCHECK_8BITS ( obj_tptr + offset + 3 <S2SV_ModStart> ND_TCHECK_32BITS ( obj_tptr + offset + 8 ) ; <S2SV_ModStart> ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ; 
362,"<S2SV_StartBug> static BLOCK_SIZE get_rd_var_based_fixed_partition ( VP9_COMP * cpi , <S2SV_EndBug> <S2SV_StartBug> unsigned int var = get_sby_perpixel_diff_variance ( cpi , & cpi -> mb , <S2SV_EndBug> ","<S2SV_ModStart> , MACROBLOCK * x <S2SV_ModStart> x -> plane [ 0 ] . src <S2SV_ModEnd> "
363,<S2SV_StartBug> nfca_poll -> nfcid1_len = * data ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> min_t ( __u8 , <S2SV_ModStart> , NFC_NFCID1_MAXSIZE ) "
364,"<S2SV_StartBug> int mi_row , int mi_col , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> const int mb_row = mi_row >> 1 ; <S2SV_EndBug> <S2SV_StartBug> x -> mb_activity_ptr = & cpi -> mb_activity_map [ idx_map ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_setup_dst_planes ( xd , get_frame_new_buffer ( cm ) , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> x -> rddiv = cpi -> RDDIV ; <S2SV_EndBug> <S2SV_StartBug> x -> rdmult = cpi -> RDMULT ; <S2SV_EndBug> <S2SV_StartBug> mbmi -> segment_id = vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> MACROBLOCK * const x , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> set_mode_info_offsets ( cm , x <S2SV_ModEnd> <S2SV_ModStart> -> plane <S2SV_ModStart> rd . <S2SV_ModStart> rd . <S2SV_ModStart> get_segment_id <S2SV_ModEnd> <S2SV_ModStart> xd -> tile = * tile ; "
365,<S2SV_StartBug> if ( ( options -> flags & UV_PROCESS_SETGID ) && setgid ( options -> gid ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> options -> flags & ( UV_PROCESS_SETUID | UV_PROCESS_SETGID ) ) { SAVE_ERRNO ( setgroups ( 0 , NULL ) ) ; } if ( "
366,<S2SV_StartBug> ps_codec -> s_parse . s_cu . i4_cu_qp_delta = cu_qp_delta_abs ; <S2SV_EndBug> ,<S2SV_ModStart> if ( cu_qp_delta_abs < MIN_CU_QP_DELTA_ABS ( ps_sps -> i1_bit_depth_luma_minus8 ) || cu_qp_delta_abs > MAX_CU_QP_DELTA_ABS ( ps_sps -> i1_bit_depth_luma_minus8 ) ) { return IHEVCD_INVALID_PARAMETER ; } 
367,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ret = key_read_state ( key ) ; if ( ret < 0 ) return ret ; <S2SV_ModEnd> 
368,"<S2SV_StartBug> u64 t = ca -> sum_rtt ; <S2SV_EndBug> <S2SV_StartBug> do_div ( t , ca -> cnt_rtt ) ; <S2SV_EndBug> <S2SV_StartBug> info . tcpv_rtt = t ; <S2SV_EndBug> ",<S2SV_ModStart> if ( info . tcpv_rttcnt > 0 ) { <S2SV_ModStart> info . tcpv_rttcnt <S2SV_ModEnd> <S2SV_ModStart> } 
369,<S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> < <S2SV_ModEnd> 
370,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
371,"<S2SV_StartBug> static void write_ref_frames ( const VP9_COMP * cpi , vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { <S2SV_EndBug> <S2SV_StartBug> assert ( ! is_compound ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , mbmi -> ref_frame [ 0 ] == GOLDEN_FRAME , <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , bit0 , vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , bit1 , vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> VP9_COMMON * cm , const MACROBLOCKD * xd , vpx_writer * w ) { const MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; const int is_compound = has_second_ref ( mbmi ) ; const int segment_id = mbmi -> segment_id ; if ( segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { assert ( ! is_compound ) ; assert ( mbmi -> ref_frame [ 0 ] == get_segdata ( & <S2SV_ModEnd> <S2SV_ModStart> ; } else { if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { vpx_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ; } else <S2SV_ModStart> == <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> "
372,"<S2SV_StartBug> strlcpy ( racomp . type , ""acomp"" , sizeof ( racomp . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> 
373,<S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) { <S2SV_EndBug> <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , u32 num ) { if ( size > UINT32_MAX / num ) { ALOGE ( ""can\'t<S2SV_blank>allocate<S2SV_blank>%u<S2SV_blank>*<S2SV_blank>%u<S2SV_blank>bytes"" , size , num ) ; android_errorWriteLog ( 0x534e4554 , ""27855419"" ) ; return NULL ; } <S2SV_ModEnd> <S2SV_ModStart> * num "
374,<S2SV_StartBug> hdrlen = sizeof ( * h . h2 ) ; <S2SV_EndBug> ,<S2SV_ModStart> h . h2 -> tp_padding = 0 ; 
375,<S2SV_StartBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
376,"<S2SV_StartBug> strcpy ( m , name ) ; <S2SV_EndBug> ","<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> , nlen + 1 "
377,"<S2SV_StartBug> nmv_context * fc = & cm -> fc . nmvc ; <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_mv_joint_tree , pre_fc -> joints , counts -> joints , fc -> joints ) ; <S2SV_EndBug> <S2SV_StartBug> comp -> sign = adapt_prob ( pre_comp -> sign , c -> sign ) ; <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_mv_class_tree , pre_comp -> classes , c -> classes , <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_mv_class0_tree , pre_comp -> class0 , c -> class0 , comp -> class0 ) ; <S2SV_EndBug> <S2SV_StartBug> comp -> bits [ j ] = adapt_prob ( pre_comp -> bits [ j ] , c -> bits [ j ] ) ; <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_mv_fp_tree , pre_comp -> class0_fp [ j ] , c -> class0_fp [ j ] , <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_mv_fp_tree , pre_comp -> fp , c -> fp , comp -> fp ) ; <S2SV_EndBug> <S2SV_StartBug> comp -> class0_hp = adapt_prob ( pre_comp -> class0_hp , c -> class0_hp ) ; <S2SV_EndBug> <S2SV_StartBug> comp -> hp = adapt_prob ( pre_comp -> hp , c -> hp ) ; <S2SV_EndBug> ",<S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_merge_probs <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_merge_probs <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_merge_probs <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_merge_probs <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_merge_probs <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs <S2SV_ModEnd> 
378,<S2SV_StartBug> if ( len != set_arglen [ SET_CMDID ( cmd ) ] ) { <S2SV_EndBug> ,<S2SV_ModStart> cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX ) return - EINVAL ; if ( len < 0 || len > MAX_ARG_LEN ) return - EINVAL ; if ( 
379,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> warn ( ""[http]<S2SV_blank>Missing<S2SV_blank>final<S2SV_blank>\\""boundary\\""<S2SV_blank>for<S2SV_blank>\\""multipart/form-data\\""!"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> else <S2SV_ModEnd> <S2SV_ModStart> ""[http]<S2SV_blank>Ignorning<S2SV_blank>broken<S2SV_blank>multipart/form-data"" ) ; break ; } } if ( lastPart ) { warn ( "
380,<S2SV_StartBug> interface = socket -> interface ; <S2SV_EndBug> ,<S2SV_ModStart> if ( message -> interface != NULL ) { interface = message -> interface ; } else { interface = socket -> interface ; } <S2SV_ModEnd> 
381,<S2SV_StartBug> variance_node node ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & node , 0 , sizeof ( node ) ) "
382,"<S2SV_StartBug> const vp9_prob * oldp , <S2SV_EndBug> <S2SV_StartBug> vp9_prob upd ) { <S2SV_EndBug> <S2SV_StartBug> vp9_prob bestnewp , newplist [ ENTROPY_NODES ] , oldplist [ ENTROPY_NODES ] ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( newplist , oldp , sizeof ( vp9_prob ) * UNCONSTRAINED_NODES ) ; <S2SV_EndBug> <S2SV_StartBug> step = ( * bestp > oldp [ PIVOT_NODE ] ? - 1 : 1 ) ; <S2SV_EndBug> <S2SV_StartBug> * bestp = bestnewp ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_prob * oldp , vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob upd , int stepsize ) { int <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> if ( * bestp > oldp [ PIVOT_NODE ] ) { step = - stepsize ; for ( newp = * bestp ; newp > <S2SV_ModEnd> <S2SV_ModStart> } else { step = stepsize ; for ( newp = * bestp ; newp < oldp [ PIVOT_NODE ] ; newp += step ) { if ( newp < 1 || newp > 255 ) continue ; newplist [ PIVOT_NODE ] = newp ; vp9_model_to_full_probs ( newplist , newplist ) ; for ( i = UNCONSTRAINED_NODES , new_b = 0 ; i < ENTROPY_NODES ; ++ i ) new_b += cost_branch256 ( ct + 2 * i , newplist [ i ] ) ; new_b += cost_branch256 ( ct + 2 * PIVOT_NODE , newplist [ PIVOT_NODE ] ) ; update_b = prob_diff_update_cost ( newp , oldp [ PIVOT_NODE ] ) + vp9_cost_upd256 ; savings = old_b - new_b - update_b ; if ( savings > bestsavings ) { bestsavings = savings ; bestnewp = newp ; } } } * bestp = bestnewp <S2SV_ModEnd> "
383,"<S2SV_StartBug> static int target_xcopy_locate_se_dev_e4 ( const unsigned char * dev_wwn , <S2SV_EndBug> <S2SV_StartBug> struct se_device * * found_dev ) <S2SV_EndBug> <S2SV_StartBug> struct xcopy_dev_search_info info ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> struct se_session * sess , <S2SV_ModStart> _found_dev , struct percpu_ref * * _found_lun_ref <S2SV_ModEnd> <S2SV_ModStart> se_dev_entry * deve ; struct se_node_acl * nacl ; struct se_lun * this_lun = NULL ; struct se_device * found_dev = NULL ; if ( ! sess ) goto err_out ; pr_debug ( ""XCOPY<S2SV_blank>0xe4:<S2SV_blank>searching<S2SV_blank>for:<S2SV_blank>%*ph\\n"" , XCOPY_NAA_IEEE_REGEX_LEN , dev_wwn ) ; nacl = sess -> se_node_acl ; rcu_read_lock ( ) ; hlist_for_each_entry_rcu ( deve , & nacl -> lun_entry_hlist , link ) { struct se_device * this_dev ; int rc ; this_lun = rcu_dereference ( deve -> se_lun ) ; this_dev = rcu_dereference_raw ( this_lun -> lun_se_dev ) ; rc = target_xcopy_locate_se_dev_e4_iter ( this_dev , dev_wwn ) ; if ( rc ) { if ( percpu_ref_tryget_live ( & this_lun -> lun_ref ) ) found_dev = this_dev ; break ; } } rcu_read_unlock ( ) ; if ( found_dev == NULL ) goto err_out ; pr_debug ( ""lun_ref<S2SV_blank>held<S2SV_blank>for<S2SV_blank>se_dev:<S2SV_blank>%p<S2SV_blank>se_dev->se_dev_group:<S2SV_blank>%p\\n"" , found_dev , & found_dev -> dev_group ) ; * _found_dev = found_dev ; * _found_lun_ref = & this_lun -> lun_ref <S2SV_ModEnd> <S2SV_ModStart> err_out : <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
384,<S2SV_StartBug> if ( idx >= ARRAY_SIZE ( hwsim_world_regdom_custom ) ) <S2SV_EndBug> <S2SV_StartBug> param . regd = hwsim_world_regdom_custom [ idx ] ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree ( hwname ) ; <S2SV_ModStart> } 
385,<S2SV_StartBug> reason = malloc ( ( uint64_t ) reasonLen + 1 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( reasonLen > 1 << 20 ) { rfbClientLog ( ""VNC<S2SV_blank>connection<S2SV_blank>failed,<S2SV_blank>but<S2SV_blank>sent<S2SV_blank>reason<S2SV_blank>length<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>exceeds<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>1MB"" , ( unsigned int ) reasonLen ) ; return ; } <S2SV_ModStart>  <S2SV_ModEnd> "
386,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( cpu_has_secondary_exec_ctrls ( ) ) { if ( kvm_vcpu_apicv_active ( vcpu ) ) vmcs_set_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; else vmcs_clear_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; } if ( cpu_has_vmx_msr_bitmap ( ) ) vmx_set_msr_bitmap ( vcpu ) ; "
387,"<S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 3 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_24BITS ( p + 2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 
388,"<S2SV_StartBug> char * dbuf ; <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = process_one_ticket ( ac , secret , & p , end , <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> ret = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return ret ; } return 0 <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
389,<S2SV_StartBug> for ( arc = 0 ; arc < dfa_state -> s_narcs ; ++ arc ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( ch_type == suite && TYPE ( tree ) == funcdef ) { ch_type = func_body_suite ; } 
390,<S2SV_StartBug> bitlen2 = VARBITLEN ( arg2 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; if ( bitlen1 > VARBITMAXLEN - bitlen2 ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , VARBITMAXLEN ) ) "
391,<S2SV_StartBug> return alg -> cra_rng . rng_make_random ? <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
392,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % ( 4 * stride ) ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horAcc32"" , ""%s"" , ""cc%(4*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; "
393,<S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> ,<S2SV_ModStart> { if ( unlikely ( ! try_get_page ( page ) ) ) { page = ERR_PTR ( - ENOMEM ) ; goto out ; } } <S2SV_ModEnd> 
394,"<S2SV_StartBug> err = scm_send ( sock , msg , siocb -> scm ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false "
395,"<S2SV_StartBug> if ( credit < 0 ) <S2SV_EndBug> <S2SV_StartBug> state = decrease_reservation ( - credit , GFP_BALLOON ) ; <S2SV_EndBug> ","<S2SV_ModStart> { long n_pages ; n_pages = min ( - credit , si_mem_available ( ) ) ; <S2SV_ModStart> n_pages <S2SV_ModEnd> <S2SV_ModStart> if ( state == BP_DONE && n_pages != - credit && n_pages < totalreserve_pages ) state = BP_EAGAIN ; } "
396,<S2SV_StartBug> ps_dec -> u2_disp_height = i4_cropped_ht ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ( u2_pic_wd << ps_seq -> u1_mb_aff_flag ) > H264_MAX_FRAME_WIDTH ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; } 
397,"<S2SV_StartBug> void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) <S2SV_EndBug> <S2SV_StartBug> get_page ( buf -> page ) ; <S2SV_EndBug> ",<S2SV_ModStart> bool <S2SV_ModEnd> <S2SV_ModStart> return try_get_page <S2SV_ModEnd> 
398,<S2SV_StartBug> byteStrm = byteStrmStart = ( u8 * ) H264SwDecMalloc ( sizeof ( u8 ) * strmLen ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , <S2SV_ModEnd> "
399,"<S2SV_StartBug> static INLINE void add_token ( TOKENEXTRA * * t , const vp9_prob * context_tree , <S2SV_EndBug> <S2SV_StartBug> int16_t extra , uint8_t token , <S2SV_EndBug> ",<S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> int32_t <S2SV_ModEnd> 
400,<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> int rowstep ; <S2SV_EndBug> ,<S2SV_ModStart> jas_matind_t i ; jas_matind_t <S2SV_ModEnd> <S2SV_ModStart> jas_matind_t <S2SV_ModEnd> 
401,<S2SV_StartBug> struct siginfo info ; <S2SV_EndBug> ,<S2SV_ModStart> = { } 
402,<S2SV_StartBug> # ifdef CONFIG_SMP <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
403,"<S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> 1 , <S2SV_ModStart> 1 , <S2SV_ModStart> 0 , "
404,"<S2SV_StartBug> const uint8_t * const src = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> <S2SV_StartBug> uint8_t * const dst = & pd -> dst . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> <S2SV_StartBug> const InterpKernel * kernel = vp9_get_interp_kernel ( mi -> mbmi . interp_filter ) ; <S2SV_EndBug> <S2SV_StartBug> const uint8_t * pre = & pd -> pre [ ref ] . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> <S2SV_StartBug> vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , <S2SV_EndBug> <S2SV_StartBug> & xd -> block_refs [ ref ] -> sf , width , height , ref , <S2SV_EndBug> <S2SV_StartBug> mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_subtract_block ( height , width , <S2SV_EndBug> <S2SV_StartBug> dst , pd -> dst . stride ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * coeff ; <S2SV_EndBug> <S2SV_StartBug> x -> fwd_txm4x4 ( raster_block_offset_int16 ( BLOCK_8X8 , k , p -> src_diff ) , <S2SV_EndBug> <S2SV_StartBug> vp9_regular_quantize_b_4x4 ( x , 0 , k , so -> scan , so -> iscan ) ; <S2SV_EndBug> <S2SV_StartBug> thissse += ssz ; <S2SV_EndBug> ","<S2SV_ModStart> vp9_raster_block_offset <S2SV_ModEnd> <S2SV_ModStart> vp9_raster_block_offset <S2SV_ModEnd> <S2SV_ModStart> vp9_filter_kernels [ <S2SV_ModEnd> <S2SV_ModStart> ] <S2SV_ModEnd> <S2SV_ModStart> vp9_raster_block_offset <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_highbd_build_inter_predictor <S2SV_ModEnd> <S2SV_ModStart> ref , <S2SV_ModEnd> <S2SV_ModStart> , xd -> bd <S2SV_ModStart> else { vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , & xd -> block_refs [ ref ] -> sf , width , height , ref , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; } # else vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , & xd -> block_refs [ ref ] -> sf , width , height , ref , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; # endif } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vpx_highbd_subtract_block ( height , width , vp9_raster_block_offset_int16 <S2SV_ModEnd> <S2SV_ModStart> dst , pd -> dst . stride , xd -> bd ) ; } else { vpx_subtract_block ( height , width , vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , dst , pd -> dst . stride ) ; } # else vpx_subtract_block ( height , width , vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , dst , pd -> dst . stride ) ; # endif <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vp9_raster_block_offset_int16 <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { thisdistortion += vp9_highbd_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz , xd -> bd ) ; } else { <S2SV_ModStart> } # else thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz ) ; # endif "
405,<S2SV_StartBug> sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels 
406,<S2SV_StartBug> const char * old_name ; <S2SV_EndBug> <S2SV_StartBug> old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ; <S2SV_EndBug> <S2SV_StartBug> fsnotify_oldname_free ( old_name ) ; <S2SV_EndBug> ,"<S2SV_ModStart> struct name_snapshot <S2SV_ModEnd> <S2SV_ModStart> take_dentry_name_snapshot ( & old_name , old_dentry ) ; error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ; if ( error ) { release_dentry_name_snapshot ( & old_name ) ; goto exit ; } d_move ( old_dentry , dentry ) ; fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name . name <S2SV_ModEnd> <S2SV_ModStart> release_dentry_name_snapshot ( & <S2SV_ModEnd> "
407,<S2SV_StartBug> if ( ! offset ) { <S2SV_EndBug> ,<S2SV_ModStart> || ! ht 
408,<S2SV_StartBug> * flags &= ~ FOLL_WRITE ; <S2SV_EndBug> ,<S2SV_ModStart> |= FOLL_COW <S2SV_ModEnd> 
409,"<S2SV_StartBug> sprintf ( op -> buf_asm , ""packed-switch-payload<S2SV_blank>%d,<S2SV_blank>%d"" , array_size , first_key ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( op -> buf_asm , ""sparse-switch-payload<S2SV_blank>%d"" , array_size ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i"" , vA ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#04hx"" , vA , sB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%"" PFMT64x , vA , vA + 1 , lB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>[%04x]"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%"" PFMT64x ""]"" , vA , vB , offset ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>thing+%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>%s"" , vC , vC + vA - 1 , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>class+%i"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>%s"" , vC , vC + vA - 1 , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>method+%i"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x"" , flag_str , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>class+%i"" , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x"" , flag_str , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>method+%i"" , vB ) ; <S2SV_EndBug> ","<S2SV_ModStart> snprintf <S2SV_ModEnd> <S2SV_ModStart> sizeof ( op -> buf_asm ) , <S2SV_ModStart> snprintf <S2SV_ModEnd> <S2SV_ModStart> , sizeof ( op -> buf_asm ) <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> "
410,"<S2SV_StartBug> gf_bs_read_data ( bs , ptr -> key_info + 21 , iv_size ) ; <S2SV_EndBug> <S2SV_StartBug> return GF_OK ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ( iv_size != 8 ) && ( iv_size != 16 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>constant<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\n"" , ( u32 ) iv_size ) ) ; ptr -> key_info [ 20 ] = 16 ; return GF_NON_COMPLIANT_BITSTREAM ; } <S2SV_ModStart> else if ( ( iv_size != 0 ) && ( iv_size != 8 ) && ( iv_size != 16 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>0,<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\n"" , ( u32 ) iv_size ) ) ; return GF_NON_COMPLIANT_BITSTREAM ; } "
411,<S2SV_StartBug> if ( ret == - EEXIST ) <S2SV_EndBug> ,<S2SV_ModStart> || ret == - EOVERFLOW 
412,<S2SV_StartBug> if ( i4_prev_row != i4_row ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> < <S2SV_ModEnd> <S2SV_ModStart> else if ( i4_prev_row > i4_row ) { android_errorWriteLog ( 0x534e4554 , ""26070014"" ) ; } "
413,"<S2SV_StartBug> struct hstate * h = hstate_vma ( vma ) ; <S2SV_EndBug> <S2SV_StartBug> struct page * page ; <S2SV_EndBug> <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug> <S2SV_StartBug> set_page_private ( page , ( unsigned long ) mapping ) ; <S2SV_EndBug> ",<S2SV_ModStart> hugepage_subpool * spool = subpool_vma ( vma ) ; struct <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> hugepage_subpool_get_pages ( spool <S2SV_ModEnd> <S2SV_ModStart> hugepage_subpool_put_pages ( spool <S2SV_ModEnd> <S2SV_ModStart> spool <S2SV_ModEnd> 
414,"<S2SV_StartBug> if ( svm_set_msr ( & svm -> vcpu , & msr ) ) { <S2SV_EndBug> ",<S2SV_ModStart> kvm_set_msr <S2SV_ModEnd> 
415,<S2SV_StartBug> uchar * dp ; <S2SV_EndBug> ,<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
416,<S2SV_StartBug> len -= EVP_CCM_TLS_EXPLICIT_IV_LEN ; <S2SV_EndBug> <S2SV_StartBug> if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) <S2SV_EndBug> <S2SV_StartBug> len -= cctx -> M ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len < EVP_CCM_TLS_EXPLICIT_IV_LEN ) return 0 ; <S2SV_ModStart> { if ( len < cctx -> M ) return 0 ; <S2SV_ModStart> } 
417,"<S2SV_StartBug> MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> { MATLAB_KO : clone_info = DestroyImageInfo ( clone_info ) ; <S2SV_ModEnd> <S2SV_ModStart> } 
418,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
419,<S2SV_StartBug> char * ptr ; <S2SV_EndBug> ,"<S2SV_ModStart> return bad_format_check ( ""^"" SAFE_STRING ""%s"" SAFE_STRING ""%lu"" SAFE_STRING ""%lu"" SAFE_STRING ""$"" , fmt <S2SV_ModEnd> "
420,"<S2SV_StartBug> buf = PyObject_CallObject ( tok -> decoding_readline , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> _PyObject_CallNoArg <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
421,"<S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
422,"<S2SV_StartBug> struct ip_options * opt = NULL ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( opt -> __data , buf , buf_len ) ; <S2SV_EndBug> <S2SV_StartBug> opt -> optlen = opt_len ; <S2SV_EndBug> <S2SV_StartBug> opt -> cipso = sizeof ( struct iphdr ) ; <S2SV_EndBug> <S2SV_StartBug> kfree ( opt ) ; <S2SV_EndBug> ","<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> if ( opt ) call_rcu ( & opt -> rcu , opt_kfree_rcu <S2SV_ModEnd> "
423,"<S2SV_StartBug> char * curl_env = r_sys_getenv ( ""R2_CURL"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> return socket_http_get_recursive ( url , code , rlen , SOCKET_HTTP_MAX_REDIRECTS <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
424,"<S2SV_StartBug> flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( ! memcmp ( p , ff_asf_ext_stream_header , sizeof ( ff_asf_guid ) ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> if ( end - p >= ( sizeof ( ff_asf_guid ) * 3 + 26 ) ) { <S2SV_ModStart> } <S2SV_ModStart> if ( chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , ""Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%"" PRId64 ""<S2SV_blank>is<S2SV_blank>invalid)\\n"" , chunksize ) ; return AVERROR_INVALIDDATA ; } "
425,"<S2SV_StartBug> kref_put ( & reservations -> refs , resv_map_release ) ; <S2SV_EndBug> ",<S2SV_ModStart> resv_map_put ( vma <S2SV_ModEnd> 
426,"<S2SV_StartBug> int file_is_raw ( struct VpxInputContext * input ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! vpx_codec_peek_stream_info ( decoder -> interface ( ) , <S2SV_EndBug> ",<S2SV_ModStart> static <S2SV_ModStart> codec_interface <S2SV_ModEnd> 
427,"<S2SV_StartBug> vpx_memcpy ( seg -> feature_data , feature_data , sizeof ( seg -> feature_data ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> 
428,"<S2SV_StartBug> & key_datums , & key_nulls , & key_count ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) "
429,<S2SV_StartBug> return ( ( iova < mem -> iova ) || <S2SV_EndBug> <S2SV_StartBug> ( ( iova + length ) > ( mem -> iova + mem -> length ) ) ) ? <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> || length > mem -> length || iova > <S2SV_ModEnd> <S2SV_ModStart> - length ) return - EFAULT ; return <S2SV_ModEnd> 
430,<S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> ,<S2SV_ModStart> UINT64_MAX <S2SV_ModEnd> 
431,"<S2SV_StartBug> static void write_tile_info ( VP9_COMMON * cm , struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> const VP9_COMMON * const <S2SV_ModEnd> <S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> 
432,"<S2SV_StartBug> memcpy ( & global_options , & new_global_options , sizeof ( GLOBAL_OPTIONS ) ) ; <S2SV_EndBug> <S2SV_StartBug> number_of_sections = num ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( GLOBAL_OPTIONS ) ) ; memset ( & new_global_options , 0 <S2SV_ModStart> memset ( & new_service_options , 0 , sizeof ( SERVICE_OPTIONS ) ) ; "
433,"<S2SV_StartBug> int j , len = apdu . resp [ i + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( file -> name , d , len ) ; <S2SV_EndBug> <S2SV_StartBug> file -> namelen = len ; <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> file -> namelen = MIN ( sizeof file -> name , len ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> "
434,<S2SV_StartBug> dentry -> d_fsdata = ( void * ) ns -> ops ; <S2SV_EndBug> ,<S2SV_ModStart> d_flags |= DCACHE_RCUACCESS ; dentry -> 
435,"<S2SV_StartBug> LPSTR tmp = NULL ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( NULL == tmp ) <S2SV_EndBug> ",<S2SV_ModStart> = NULL ; LPSTR tmp2 <S2SV_ModStart> { tmp2 <S2SV_ModEnd> <S2SV_ModStart> if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 ; } <S2SV_ModStart> tmp2 <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> tmp2 <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> tmp2 <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> tmp2 <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> tmp2 <S2SV_ModEnd> <S2SV_ModStart> ! tmp2 ) free ( tmp ) ; tmp = tmp2 ; if ( 
436,<S2SV_StartBug> uint8_t verify_crls = cred -> x509Credential . x509CrlVerifyMode ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> verify_crls = cred -> x509Credential . x509CrlVerifyMode ; 
437,"<S2SV_StartBug> char * pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"" ; <S2SV_EndBug> ","<S2SV_ModStart> ""/lxc/lock/var/lib/lxc/"" <S2SV_ModEnd> "
438,"<S2SV_StartBug> _iov -> iov_len = min ( ( u64 ) len , size ) ; <S2SV_EndBug> ",<S2SV_ModStart> - s 
439,<S2SV_StartBug> if ( err < 0 ) <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree ( partdata ) ; <S2SV_ModStart> } 
440,<S2SV_StartBug> if ( unlikely ( chunk_length < required_length ) ) <S2SV_EndBug> ,<S2SV_ModStart> chunk -> pdiscard ) ) return 0 ; if ( unlikely ( 
441,"<S2SV_StartBug> show ( obj , base , name , cb_data ) ; <S2SV_EndBug> ","<S2SV_ModStart> strbuf_addstr ( base , name ) ; <S2SV_ModStart> -> buf , cb_data <S2SV_ModEnd> "
442,<S2SV_StartBug> else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) && <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
443,<S2SV_StartBug> switch ( bps / 8 ) <S2SV_EndBug> ,"<S2SV_ModStart> if ( bytes_per_pixel > sizeof ( swapbuff ) ) { TIFFError ( ""reverseSamplesBytes"" , ""bytes_per_pixel<S2SV_blank>too<S2SV_blank>large"" ) ; return ( 1 ) ; } "
444,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ND_TCHECK ( opt -> rpl_dio_len ) ; <S2SV_ModStart> ""%s"" , rpl_tstr <S2SV_ModEnd> "
445,<S2SV_StartBug> done : <S2SV_EndBug> <S2SV_StartBug> ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> done : 
446,<S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart> if ( strlen ( password ) > MAX_PASSWORD_LEN ) return 0 ; 
447,<S2SV_StartBug> value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> <S2SV_StartBug> value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | <S2SV_EndBug> <S2SV_StartBug> ( ( unsigned char * ) buffer ) [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned short ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> buffer <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned short ) buffer <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
448,"<S2SV_StartBug> btrfs_file_extent_compression ( leaf , fi ) == 0 && <S2SV_EndBug> <S2SV_StartBug> if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) <S2SV_EndBug> <S2SV_StartBug> new_size ) ; <S2SV_EndBug> ","<S2SV_ModStart> btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) { if ( <S2SV_ModStart> != BTRFS_COMPRESS_NONE && pending_del_nr ) { err = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } pending_del_nr = 0 ; } err = truncate_inline_extent ( inode , path , & found_key , item_end , new_size ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } } else <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart>  <S2SV_ModEnd> "
449,"<S2SV_StartBug> wait_for_unix_gc ( ) ; <S2SV_EndBug> <S2SV_StartBug> unix_state_lock ( other ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_flag ( other , SOCK_DEAD ) ) { <S2SV_EndBug> <S2SV_StartBug> err = 0 ; <S2SV_EndBug> <S2SV_StartBug> unix_state_lock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> unix_peer ( sk ) = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( unix_peer ( other ) != sk && unix_recvq_full ( other ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! timeo ) { <S2SV_EndBug> <S2SV_StartBug> goto out_unlock ; <S2SV_EndBug> <S2SV_StartBug> timeo = unix_wait_for_peer ( other , timeo ) ; <S2SV_EndBug> <S2SV_StartBug> unix_state_unlock ( other ) ; <S2SV_EndBug> ","<S2SV_ModStart> int sk_locked ; <S2SV_ModStart> sk_locked = 0 ; <S2SV_ModStart> restart_locked : <S2SV_ModStart> unlikely ( <S2SV_ModStart> ) <S2SV_ModStart> if ( ! sk_locked ) unix_state_lock ( sk ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; unix_dgram_peer_wake_disconnect_wakeup ( sk , other ) <S2SV_ModStart> unlikely ( <S2SV_ModStart> ) { if ( timeo ) { timeo = unix_wait_for_peer ( other , timeo ) ; err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } <S2SV_ModEnd> <S2SV_ModStart> sk_locked ) { unix_state_unlock ( other ) ; unix_state_double_lock ( sk , other ) ; } if ( unix_peer ( sk ) != other || unix_dgram_peer_wake_me ( sk , other ) <S2SV_ModEnd> <S2SV_ModStart> sk_locked = 1 ; <S2SV_ModStart> if ( ! sk_locked ) { sk_locked = 1 ; goto restart_locked ; } } if ( unlikely ( sk_locked ) ) unix_state_unlock ( sk ) ; <S2SV_ModEnd> <S2SV_ModStart> if ( sk_locked ) unix_state_unlock ( sk ) ; "
450,<S2SV_StartBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
451,<S2SV_StartBug> load_xid_epoch ( & state ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; StaticAssertStmt ( MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP , ""possible<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>txid_current_snapshot()"" "
452,"<S2SV_StartBug> err = - EMSGSIZE ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> hdrincl ) <S2SV_EndBug> <S2SV_StartBug> inet -> hdrincl ? IPPROTO_RAW : sk -> sk_protocol , <S2SV_EndBug> <S2SV_StartBug> ( inet -> hdrincl ? FLOWI_FLAG_KNOWN_NH : 0 ) , <S2SV_EndBug> <S2SV_StartBug> if ( ! inet -> hdrincl ) { <S2SV_EndBug> <S2SV_StartBug> if ( inet -> hdrincl ) <S2SV_EndBug> ",<S2SV_ModStart> int hdrincl ; <S2SV_ModStart> ; hdrincl = inet -> hdrincl <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
453,<S2SV_StartBug> case IO_DISCONNECTED : <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
454,<S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ,<S2SV_ModStart> rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if ( 
455,<S2SV_StartBug> if ( ! chart || ! * chart ) { <S2SV_EndBug> ,<S2SV_ModStart> fix_google_param ( google_out ) ; fix_google_param ( google_sig ) ; fix_google_param ( google_reqId ) ; fix_google_param ( google_version ) ; fix_google_param ( responseHandler ) ; fix_google_param ( outFileName ) ; 
456,<S2SV_StartBug> if ( ! ( flags & TTM_PAGE_FLAG_DMA32 ) ) { <S2SV_EndBug> <S2SV_StartBug> while ( i < npages ) { <S2SV_EndBug> ,<S2SV_ModStart> && ( npages - i ) >= HPAGE_PMD_NR <S2SV_ModStart> ( npages - i ) >= HPAGE_PMD_NR <S2SV_ModEnd> 
457,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> siginfo_t info ; void __user * pc = ( void __user * ) instruction_pointer ( regs ) ; <S2SV_ModStart> __show_regs ( regs ) ; info . si_signo = SIGILL ; info . si_errno = 0 ; info . si_code = ILL_ILLOPC ; info . si_addr = pc ; arm64_notify_die <S2SV_ModEnd> <S2SV_ModStart> & info , 0 <S2SV_ModEnd> "
458,<S2SV_StartBug> status = sBtInterface -> enable ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> false 
459,"<S2SV_StartBug> l_strnstart ( const char * tstr1 , u_int tl1 , const char * str2 , u_int l2 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ","<S2SV_ModStart> netdissect_options * ndo , <S2SV_ModStart> if ( ! ND_TTEST2 ( * str2 , tl1 ) ) { return 0 ; } "
460,<S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> iif = l3mdev_master_ifindex ( skb_dst ( skb ) -> dev ) ; <S2SV_EndBug> ,<S2SV_ModStart> { dst = skb_dst ( skb ) ; <S2SV_ModStart> dst ? dst -> dev : skb -> dev ) ; } <S2SV_ModEnd> 
461,"<S2SV_StartBug> int ntlm_read_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> <S2SV_StartBug> if ( ( fields -> BufferOffset + fields -> Len ) > Stream_Length ( s ) ) <S2SV_EndBug> ",<S2SV_ModStart> static <S2SV_ModStart> const UINT64 offset = ( UINT64 ) <S2SV_ModEnd> <S2SV_ModStart> ( UINT64 ) <S2SV_ModStart> ; if ( offset <S2SV_ModEnd> 
462,"<S2SV_StartBug> if ( ( tf = fopen ( tfile -> file_path , ""w"" ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart> fopen_safe <S2SV_ModEnd> 
463,"<S2SV_StartBug> rad_get_vendor_attr ( u_int32_t * vendor , const void * * data , size_t * len ) <S2SV_EndBug> <S2SV_StartBug> attr = ( struct vendor_attribute * ) * data ; <S2SV_EndBug> <S2SV_StartBug> * vendor = ntohl ( attr -> vendor_value ) ; <S2SV_EndBug> <S2SV_StartBug> return ( attr -> attrib_type ) ; <S2SV_EndBug> ","<S2SV_ModStart> , unsigned char * type <S2SV_ModStart> , const void * raw , size_t raw_len <S2SV_ModStart> if ( raw_len < sizeof ( struct vendor_attribute ) ) { return - 1 ; } <S2SV_ModStart> raw <S2SV_ModEnd> <S2SV_ModStart> ; * type = attr -> attrib_type <S2SV_ModStart> if ( ( attr -> attrib_len + 4 ) > raw_len ) { return - 1 ; } "
464,<S2SV_StartBug> mutex_lock ( & tu -> tread_sem ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & tu -> tread_sem ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
465,"<S2SV_StartBug> strlcpy ( comp1_str , comp1 -> data , comp1 -> length + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_SRV_HST || <S2SV_EndBug> <S2SV_StartBug> strlcpy ( temp_buf , comp2 -> data , comp2 -> length + 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> != NULL ) memcpy ( comp1_str , comp1 -> data , comp1 -> length ) ; if ( ( krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_SRV_HST || krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_SRV_INST || ( krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_UNKNOWN && kdc_active_realm -> realm_host_based_services != NULL && ( krb5_match_config_pattern ( kdc_active_realm -> realm_host_based_services , comp1_str ) == TRUE || krb5_match_config_pattern ( kdc_active_realm -> realm_host_based_services , KRB5_CONF_ASTERISK ) == TRUE ) ) ) && ( kdc_active_realm -> realm_no_host_referral == NULL || ( krb5_match_config_pattern ( kdc_active_realm -> realm_no_host_referral , KRB5_CONF_ASTERISK ) == FALSE && krb5_match_config_pattern ( kdc_active_realm -> realm_no_host_referral , comp1_str ) == FALSE ) ) ) { if ( memchr ( comp2 -> data , '.' , comp2 -> length ) == NULL ) goto cleanup ; temp_buf = calloc ( 1 , comp2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( comp2 -> data != NULL ) memcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
466,"<S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) ( GetQuantumRange ( depth ) + 1 ) ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> pixel . red = scale [ pixel . red ] ; <S2SV_EndBug> <S2SV_StartBug> pixel . green = scale [ pixel . green ] ; <S2SV_EndBug> <S2SV_StartBug> pixel . blue = scale [ pixel . blue ] ; <S2SV_EndBug> ",<S2SV_ModStart> if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> <= <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( pixel . red <= GetQuantumRange ( depth ) ) <S2SV_ModStart> if ( pixel . green <= GetQuantumRange ( depth ) ) <S2SV_ModStart> if ( pixel . blue <= GetQuantumRange ( depth ) ) 
467,"<S2SV_StartBug> size_t ss = CDF_SEC_SIZE ( h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( pos > ss * sst -> sst_len ) { <S2SV_EndBug> <S2SV_StartBug> pos , ss * sst -> sst_len ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> CDF_SHORT_SEC_SIZE <S2SV_ModEnd> <S2SV_ModStart> CDF_SEC_SIZE ( h ) <S2SV_ModEnd> <S2SV_ModStart> CDF_SEC_SIZE ( h ) <S2SV_ModEnd> 
468,<S2SV_StartBug> ( * offset ) = ( u64 ) stco -> offsets [ sampleNumber - 1 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( ! co64 -> offsets ) return GF_ISOM_INVALID_FILE ; <S2SV_EndBug> ,<S2SV_ModStart> if ( stco -> nb_entries < sampleNumber ) return GF_ISOM_INVALID_FILE ; <S2SV_ModStart> ) return GF_ISOM_INVALID_FILE ; if ( co64 -> nb_entries < sampleNumber 
469,"<S2SV_StartBug> memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL 
470,"<S2SV_StartBug> vpx_memcpy ( cpi -> common . fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_a , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_g , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_n , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
471,"<S2SV_StartBug> rsrc . type_count = read_rsrc_short ( & rsrc , rsrc . map_offset + 28 ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> { marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( rsrc . map_offset + 28 > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>map<S2SV_blank>offset.\\n"" ) ; goto parse_rsrc_fork_cleanup ; } ; <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>rsrc<S2SV_blank>marker.\\n"" ) ; goto parse_rsrc_fork_cleanup ; } ; marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8 "
472,"<S2SV_StartBug> int start = 0 ; <S2SV_EndBug> <S2SV_StartBug> kvm_pit_load_count ( kvm , 0 , kvm -> arch . vpit -> pit_state . channels [ 0 ] . count , start ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; int i <S2SV_ModStart> for ( i = 0 ; i < 3 ; i ++ ) <S2SV_ModStart> i <S2SV_ModEnd> <S2SV_ModStart> i <S2SV_ModEnd> 
473,"<S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> ","<S2SV_ModStart> alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE "
474,<S2SV_StartBug> if ( ( s -> options & SSL_OP_EPHEMERAL_RSA ) <S2SV_EndBug> <S2SV_StartBug> s -> s3 -> tmp . use_rsa_tmp = 1 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 0 ; if ( <S2SV_ModEnd> 
475,"<S2SV_StartBug> ! inode_capable ( VFS_I ( ip ) , CAP_FSETID ) ) <S2SV_EndBug> ",<S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> 
476,<S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> msg -> msg_namelen = 0 ; 
477,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> else if ( ( too_many_pipe_buffers_hard ( pipe -> user ) || too_many_pipe_buffers_soft ( pipe -> user ) ) && ! capable ( CAP_SYS_RESOURCE ) && ! capable ( CAP_SYS_ADMIN ) ) { ret = - EPERM ; goto out ; } 
478,<S2SV_StartBug> # ifdef CONFIG_SWAP <S2SV_EndBug> <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> ,<S2SV_ModStart> * prev = vma ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
479,<S2SV_StartBug> sig_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
480,"<S2SV_StartBug> uint8_t i ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>Sel:<S2SV_blank>%d"" , <S2SV_EndBug> <S2SV_StartBug> tval >> 5 , ( tval >> 3 ) & 0x03 , ( tval & 0x07 ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> u_int <S2SV_ModEnd> <S2SV_ModStart> ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>RES:<S2SV_blank>%u,<S2SV_blank>Sel:<S2SV_blank>%u,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%u"" <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> "
481,<S2SV_StartBug> if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) { <S2SV_EndBug> ,<S2SV_ModStart> numrows < 0 || numcols < 0 ) { return 0 ; } if ( 
482,"<S2SV_StartBug> int len = mutt_b64_decode ( buffer , encoded ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( buffer ) "
483,<S2SV_StartBug> if ( enable_ertm ) <S2SV_EndBug> ,<S2SV_ModStart> case L2CAP_MODE_STREAMING : 
484,<S2SV_StartBug> if ( bIntToNull && pDup && pDup -> op == TK_INTEGER ) { <S2SV_EndBug> <S2SV_StartBug> pDup -> flags &= ~ ( EP_IntValue | EP_IsTrue | EP_IsFalse ) ; <S2SV_EndBug> ,"<S2SV_ModStart> assert ( pDup == 0 || ! ExprHasProperty ( pDup , EP_MemToken ) ) ; <S2SV_ModStart> ; pDup -> u . zToken = 0 "
485,<S2SV_StartBug> return self ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( p_key ) rb_ivar_set ( self , id_key_set , Qtrue ) ; "
486,<S2SV_StartBug> rhost_old [ 0 ] = '\\0' ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( desc == NULL ) desc = """" ; "
487,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , tstr <S2SV_ModEnd> "
488,"<S2SV_StartBug> uint64 nstrips64 ; <S2SV_EndBug> <S2SV_StartBug> nstrips64 = TIFFhowmany_64 ( bytecount , stripbytes ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( nstrips64 == 0 ) || ( nstrips64 > 0xFFFFFFFF ) ) <S2SV_EndBug> <S2SV_StartBug> newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> <S2SV_StartBug> newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> <S2SV_StartBug> for ( strip = 0 ; strip < nstrips32 ; strip ++ ) { <S2SV_EndBug> <S2SV_StartBug> newoffsets [ strip ] = offset ; <S2SV_EndBug> <S2SV_StartBug> td -> td_stripsperimage = td -> td_nstrips = nstrips32 ; <S2SV_EndBug> ","<S2SV_ModStart> uint32 nstrips <S2SV_ModEnd> <S2SV_ModStart> nstrips = TIFFhowmany_32 ( td -> td_imagelength , rowsperstrip ) ; if ( nstrips <S2SV_ModEnd> <S2SV_ModStart> return ; <S2SV_ModEnd> <S2SV_ModStart> nstrips <S2SV_ModEnd> <S2SV_ModStart> nstrips <S2SV_ModEnd> <S2SV_ModStart> nstrips <S2SV_ModEnd> <S2SV_ModStart> stripbytes ? offset : 0 <S2SV_ModEnd> <S2SV_ModStart> nstrips <S2SV_ModEnd> "
489,<S2SV_StartBug> static ssize_t aio_setup_single_vector ( struct kiocb * kiocb ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> kiocb -> ki_iovec -> iov_len = kiocb -> ki_left ; <S2SV_EndBug> ,"<S2SV_ModStart> int type , struct file * file , <S2SV_ModStart> int bytes ; bytes = rw_verify_area ( type , file , & kiocb -> ki_pos , kiocb -> ki_left ) ; if ( bytes < 0 ) return bytes ; <S2SV_ModStart> bytes <S2SV_ModEnd> "
490,<S2SV_StartBug> switch ( c = ( * dis_getc ) ( stream ) ) <S2SV_EndBug> ,"<S2SV_ModStart> if ( count >= dis_umaxd ) { if ( count > dis_umaxd ) goto overflow ; if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) goto overflow ; } "
491,"<S2SV_StartBug> if ( ioctl ( socket -> fd , FIONREAD , & size ) == - 1 ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
492,"<S2SV_StartBug> static void write_partition ( VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_EndBug> <S2SV_StartBug> PARTITION_TYPE p , BLOCK_SIZE bsize , vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * const probs = get_partition_probs ( cm , ctx ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , p == PARTITION_SPLIT , probs [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , p == PARTITION_SPLIT , probs [ 2 ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> const VP9_COMMON * const cm , const MACROBLOCKD * const <S2SV_ModEnd> <S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> vpx_prob * const probs = xd -> partition_probs [ ctx ] <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> "
493,<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> for ( i = NELEMENTS ( ctx -> mmaps ) - 1 ; i >= 0 ; i -- ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_free ( ctx ) ; <S2SV_ModEnd> 
494,<S2SV_StartBug> void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> ,<S2SV_ModStart> static 
495,"<S2SV_StartBug> USB_DT_SECURITY , ( void * * ) & secd ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( * secd ) "
496,"<S2SV_StartBug> vpx_memcpy ( udp , up , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( vdp , vp , 4 ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
497,<S2SV_StartBug> regs [ value_regno ] . var_off = <S2SV_EndBug> ,"<S2SV_ModStart> coerce_reg_to_size ( & <S2SV_ModStart> , size <S2SV_ModEnd> "
498,"<S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> char line [ NETSCREEN_LINE_LENGTH ] ; <S2SV_EndBug> <S2SV_StartBug> pkt_len = parse_netscreen_rec_hdr ( & wth -> phdr , line , cap_int , & cap_dir , <S2SV_EndBug> <S2SV_StartBug> if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int , <S2SV_EndBug> <S2SV_StartBug> cap_dst , & wth -> phdr , wth -> frame_buffer , err , err_info ) ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> parse_netscreen_packet <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , line "
499,"<S2SV_StartBug> off_t pos = sys -> tell ( fh ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! fn ) return MSPACK_ERR_NOMEMORY ; <S2SV_EndBug> <S2SV_StartBug> hdr -> filename = fn ; <S2SV_EndBug> <S2SV_StartBug> if ( sys -> read ( fh , & buf [ 0 ] , 9 ) != 9 ) return MSPACK_ERR_READ ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 9 ; i ++ , fn ++ ) if ( ! ( * fn = buf [ i ] ) ) break ; <S2SV_EndBug> <S2SV_StartBug> pos += ( i < 9 ) ? i + 1 : 9 ; <S2SV_EndBug> <S2SV_StartBug> return MSPACK_ERR_SEEK ; <S2SV_EndBug> <S2SV_StartBug> if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 4 ; i ++ , fn ++ ) if ( ! ( * fn = buf [ i ] ) ) break ; <S2SV_EndBug> <S2SV_StartBug> pos += ( i < 4 ) ? i + 1 : 4 ; <S2SV_EndBug> <S2SV_StartBug> return MSPACK_ERR_SEEK ; <S2SV_EndBug> ","<S2SV_ModStart> int len <S2SV_ModEnd> <S2SV_ModStart> ( hdr -> filename = fn ) ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( len = <S2SV_ModStart> ) < 2 <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> ) if ( ! ( * fn ++ <S2SV_ModEnd> <S2SV_ModStart> if ( i == 9 && buf [ 8 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( <S2SV_ModEnd> <S2SV_ModStart> - len ) , MSPACK_SYS_SEEK_CUR <S2SV_ModEnd> <S2SV_ModStart> ; fn -- <S2SV_ModStart> ( len = <S2SV_ModStart> ) < 2 <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> ) if ( ! ( * fn ++ <S2SV_ModEnd> <S2SV_ModStart> if ( i == 4 && buf [ 3 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( <S2SV_ModEnd> <S2SV_ModStart> - len ) , MSPACK_SYS_SEEK_CUR <S2SV_ModEnd> <S2SV_ModStart> ; fn -- "
500,<S2SV_StartBug> size_t * buf_size_out ) <S2SV_EndBug> <S2SV_StartBug> if ( iovcnt < 0 || ( iovcnt > 0 && ! iov ) || ! buf_out || ! buf_size_out ) <S2SV_EndBug> <S2SV_StartBug> * buf_size_out = buf_size ; <S2SV_EndBug> <S2SV_StartBug> buf = NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> , size_t * data_size_out <S2SV_ModStart> data_size_out ) * data_size_out = 0 ; if ( <S2SV_ModStart> || ! data_size_out <S2SV_ModStart> ; * data_size_out = data_size <S2SV_ModStart> * data_size_out = data_size ; "
501,"<S2SV_StartBug> if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { <S2SV_EndBug> ","<S2SV_ModStart> siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) { jas_eprintf ( ""all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\n"" ) ; return - 1 ; } if ( "
502,"<S2SV_StartBug> if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ; <S2SV_EndBug> <S2SV_StartBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_default , <S2SV_EndBug> <S2SV_StartBug> out_drop_write : <S2SV_EndBug> ","<S2SV_ModStart> error = fh_want_write ( fh ) ; if ( error ) <S2SV_ModEnd> <S2SV_ModStart> fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( error ) goto out_drop_lock ; fh_unlock ( fh ) <S2SV_ModEnd> <S2SV_ModStart> out_drop_lock : fh_unlock ( fh ) ; <S2SV_ModEnd> "
503,"<S2SV_StartBug> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , <S2SV_EndBug> <S2SV_StartBug> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , <S2SV_EndBug> <S2SV_StartBug> data + offset , <S2SV_EndBug> ","<S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> offset , data_size - "
504,"<S2SV_StartBug> bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ++ rs -> cont_loops >= RR_MAX_CE_ENTRIES ) goto out ; 
505,"<S2SV_StartBug> SEPARATE_ZVAL ( var2 ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_double ( * var2 ) ; <S2SV_EndBug> <S2SV_StartBug> matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( var2 ) ; <S2SV_EndBug> <S2SV_StartBug> php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> if ( Z_TYPE_PP <S2SV_ModEnd> <S2SV_ModStart> != IS_DOUBLE ) { zval dval ; dval = * * var ; zval_copy_ctor ( & dval ) <S2SV_ModStart> & dval ) ; matrix [ i ] [ j ] = ( float ) Z_DVAL ( dval ) ; } else { matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( <S2SV_ModEnd> <S2SV_ModStart> } } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix"" ) ; RETURN_FALSE ; } } } } res = gdImageConvolution ( im_src , matrix , <S2SV_ModEnd> <S2SV_ModStart> div , ( float ) offset ) ; if ( res ) { RETURN_TRUE <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
506,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> set_acl_inode ( inode , inode -> i_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( error <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
507,"<S2SV_StartBug> vpx_memset ( cpi -> segmentation_map , 0 , mbs_in_frame ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> common . frame_type != KEY_FRAME ) <S2SV_EndBug> <S2SV_StartBug> cpi -> cyclic_refresh_mode_index = i ; <S2SV_EndBug> ",<S2SV_ModStart> if ( cpi -> oxcf . screen_content_mode ) { int qp_thresh = ( cpi -> oxcf . screen_content_mode == 2 ) ? 80 : 100 ; if ( Q >= qp_thresh ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 10 ; } else if ( cpi -> frames_since_key > 250 && Q < 20 && cpi -> mb . skip_true_count > ( int ) ( 0.95 * mbs_in_frame ) ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = 0 ; } else { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 20 ; } block_count = cpi -> cyclic_refresh_mode_max_mbs_perframe ; } memset <S2SV_ModEnd> <S2SV_ModStart> && block_count > 0 <S2SV_ModStart> # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) { if ( cpi -> denoiser . denoiser_mode == kDenoiserOnYUVAggressive && Q < ( int ) cpi -> denoiser . denoise_pars . qp_thresh && ( cpi -> frames_since_key > 2 * cpi -> denoiser . denoise_pars . consec_zerolast ) ) { cpi -> cyclic_refresh_q = Q ; lf_adjustment = - 40 ; for ( i = 0 ; i < mbs_in_frame ; ++ i ) { seg_map [ i ] = ( cpi -> consec_zero_last [ i ] > cpi -> denoiser . denoise_pars . consec_zerolast ) ? 1 : 0 ; } } } # endif 
508,<S2SV_StartBug> struct serial_icounter_struct icount ; <S2SV_EndBug> ,<S2SV_ModStart> = { } 
509,"<S2SV_StartBug> other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false "
510,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( check_secure ( ) ) return ; 
511,<S2SV_StartBug> msc -> ntouches = 0 ; <S2SV_EndBug> <S2SV_StartBug> npoints = ( size - 6 ) / 8 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( npoints > 15 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>TRACKPAD_REPORT_ID\\n"" , size ) ; return 0 ; } <S2SV_ModStart> if ( npoints > 15 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>MOUSE_REPORT_ID\\n"" , size ) ; return 0 ; } "
512,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( inode_capable ( inode , CAP_FOWNER ) ) <S2SV_EndBug> ","<S2SV_ModStart> struct user_namespace * ns ; <S2SV_ModStart> ns = current_user_ns ( ) ; if ( ns_capable ( ns , CAP_FOWNER ) && kuid_has_mapping ( ns , inode -> i_uid <S2SV_ModEnd> "
513,<S2SV_StartBug> filename [ filename_size ++ ] = '\\0' ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
514,<S2SV_StartBug> goto error ; <S2SV_EndBug> ,<S2SV_ModStart> usb_free_urb ( urb ) ; 
515,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
516,"<S2SV_StartBug> OPJ_UINT32 * p_data_written , <S2SV_EndBug> <S2SV_StartBug> opj_write_bytes ( p_data , J2K_MS_SOT , <S2SV_EndBug> ","<S2SV_ModStart> p_total_data_size , OPJ_UINT32 <S2SV_ModStart> if ( p_total_data_size < 12 ) { opj_event_msg ( p_manager , EVT_ERROR , ""Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOT<S2SV_blank>marker\\n"" ) ; return OPJ_FALSE ; } "
517,"<S2SV_StartBug> void fadst16_sse2 ( __m128i * in0 , __m128i * in1 ) { <S2SV_EndBug> ",<S2SV_ModStart> static 
518,<S2SV_StartBug> ! SSL_USE_ETM ( s ) && SSL_USE_EXPLICIT_IV ( s ) && <S2SV_EndBug> ,<S2SV_ModStart> SSL_WRITE_ETM <S2SV_ModEnd> 
519,"<S2SV_StartBug> const u_char * p , const u_char * ep , <S2SV_EndBug> <S2SV_StartBug> if ( p [ 0 ] & 0x80 ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> if ( ep < p + totlen ) { <S2SV_EndBug> <S2SV_StartBug> return ep + 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""value="" ) ) ; <S2SV_EndBug> <S2SV_StartBug> rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , EXTRACT_16BITS ( & p [ 2 ] ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , EXTRACT_16BITS ( & p [ 2 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> return p + totlen ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ep2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <S2SV_ModStart> } if ( ep2 <S2SV_ModEnd> <S2SV_ModStart> ep2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( & p [ 0 ] ) ; <S2SV_ModStart> ) ; ND_TCHECK_16BITS ( & p [ 2 ] <S2SV_ModStart> { if ( ! <S2SV_ModStart> ) { ND_PRINT ( ( ndo , "")"" ) ) ; goto trunc ; } } <S2SV_ModEnd> <S2SV_ModStart> totlen - 4 ) ) ; if ( ! <S2SV_ModEnd> <S2SV_ModStart> totlen - 4 ) ) { <S2SV_ModEnd> <S2SV_ModStart> goto trunc ; } } ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_ModStart> trunc : return NULL ; "
520,<S2SV_StartBug> u32 offset ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
521,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( ! i ) return NULL ; 
522,<S2SV_StartBug> if ( pixdepth == 1 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( pixdepth == 8 ) { <S2SV_EndBug> ,<S2SV_ModStart> bpp == 1 && <S2SV_ModStart> bpp == 8 && 
523,"<S2SV_StartBug> void vp9_loop_filter_frame ( VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_EndBug> <S2SV_StartBug> vp9_loop_filter_rows ( cm -> frame_to_show , cm , xd , <S2SV_EndBug> ","<S2SV_ModStart> YV12_BUFFER_CONFIG * frame , <S2SV_ModStart> frame <S2SV_ModEnd> <S2SV_ModStart> -> plane "
524,<S2SV_StartBug> queueItem -> srcPort = ntohs ( header -> srcPort ) ; <S2SV_EndBug> ,<S2SV_ModStart> interface = interface ; queueItem -> 
525,"<S2SV_StartBug> server . vm_enabled = 0 ; <S2SV_EndBug> <S2SV_StartBug> server . vm_swap_file = zstrdup ( ""/tmp/redis-%p.vm"" ) ; <S2SV_EndBug> <S2SV_StartBug> server . vm_max_memory = 1024LL * 1024 * 1024 * 1 ; <S2SV_EndBug> ","<S2SV_ModStart> ds_enabled = 0 ; server . ds_path <S2SV_ModEnd> <S2SV_ModStart> ""/tmp/redis.ds"" ) ; server . cache_max_memory = 64LL <S2SV_ModEnd> <S2SV_ModStart> ; server . cache_blocked_clients <S2SV_ModEnd> "
526,<S2SV_StartBug> int this_rd ; <S2SV_EndBug> <S2SV_StartBug> if ( this_mode == ZEROMV ) <S2SV_EndBug> <S2SV_StartBug> if ( ( cpi -> ref_frame_flags & VP8_LAST_FRAME & <S2SV_EndBug> ,<S2SV_ModStart> ; int denoise_aggressive = 0 <S2SV_ModStart> # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) { denoise_aggressive = ( cpi -> denoiser . denoiser_mode == kDenoiserOnYUVAggressive ) ? 1 : 0 ; } # endif if ( ! cpi -> oxcf . screen_content_mode && <S2SV_ModEnd> <S2SV_ModStart> && x -> e_mbd . mode_info_context -> mbmi . ref_frame == LAST_FRAME && ( denoise_aggressive || ( cpi -> closest_reference_frame == LAST_FRAME ) ) <S2SV_ModStart> x -> is_skin <S2SV_ModEnd> 
527,<S2SV_StartBug> if ( ! adis -> buffer ) <S2SV_EndBug> <S2SV_StartBug> rx = adis -> buffer ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree ( adis -> xfer ) ; adis -> xfer = NULL ; <S2SV_ModStart> } 
528,"<S2SV_StartBug> static inline void jmp_rel ( struct x86_emulate_ctxt * ctxt , int rel ) <S2SV_EndBug> <S2SV_StartBug> assign_eip_near ( ctxt , ctxt -> _eip + rel ) ; <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return 
529,<S2SV_StartBug> option_number += option_ext ; <S2SV_EndBug> <S2SV_StartBug> option_number += 269 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( sn_coap_parser_add_u16_limit ( option_number , option_ext , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> <S2SV_ModStart> if ( sn_coap_parser_add_u16_limit ( option_number , 269 , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> "
530,"<S2SV_StartBug> if ( io -> status ) { <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & io -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> || io -> count == 0 <S2SV_ModStart> io -> count ++ ; <S2SV_ModStart> spin_lock_irqsave ( & io -> lock , flags ) ; io -> count -- ; if ( ! io -> count ) complete ( & io -> complete ) ; spin_unlock_irqrestore ( & io -> lock , flags ) ; "
531,"<S2SV_StartBug> else if ( n <= 15 && ! strchr ( name , '.' ) && type == HOST_TYPE_IPV4 ) <S2SV_EndBug> <S2SV_StartBug> else if ( ! strchr ( name , '.' ) ) <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> 
532,"<S2SV_StartBug> hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( hlen < 0 ) { err = hlen ; goto fail ; } 
533,"<S2SV_StartBug> rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , size , msg_flags , timeo ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> ; msg -> msg_namelen = 0 <S2SV_ModStart> msg -> msg_namelen = sizeof ( * sin ) ; 
534,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> * addr_len = sizeof ( * saddr ) ; } <S2SV_ModEnd> 
535,<S2SV_StartBug> void fadst8_sse2 ( __m128i * in ) { <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug> ,<S2SV_ModStart> static <S2SV_ModStart> ( int16_t ) 
536,"<S2SV_StartBug> int rc ; <S2SV_EndBug> <S2SV_StartBug> rc = ecryptfs_parse_options ( sbi , raw_data ) ; <S2SV_EndBug> <S2SV_StartBug> ecryptfs_set_superblock_lower ( s , path . dentry -> d_sb ) ; <S2SV_EndBug> ","<S2SV_ModStart> uid_t check_ruid ; <S2SV_ModStart> , & check_ruid <S2SV_ModStart> if ( check_ruid && path . dentry -> d_inode -> i_uid != current_uid ( ) ) { rc = - EPERM ; printk ( KERN_ERR ""Mount<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(uid:<S2SV_blank>%d)<S2SV_blank>not<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>"" ""requested<S2SV_blank>user<S2SV_blank>(uid:<S2SV_blank>%d)\\n"" , path . dentry -> d_inode -> i_uid , current_uid ( ) ) ; goto out_free ; } "
537,"<S2SV_StartBug> ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & kvm -> lock ) ; <S2SV_EndBug> <S2SV_StartBug> kvm_get_kvm ( kvm ) ; <S2SV_EndBug> ",<S2SV_ModStart> kvm_get_kvm ( kvm ) ; <S2SV_ModStart> kvm_put_kvm ( kvm ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
538,<S2SV_StartBug> int is_entity ; <S2SV_EndBug> <S2SV_StartBug> if ( obj -> fixedtype == DWG_TYPE_TABLE ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> else if ( obj -> fixedtype == DWG_TYPE_DATATABLE ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> unhandled : <S2SV_ModEnd> <S2SV_ModStart> DWG_TYPE_UNKNOWN_ENT ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> DWG_TYPE_UNKNOWN_OBJ ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
539,<S2SV_StartBug> evtchn_to_irq [ row ] [ col ] = irq ; <S2SV_EndBug> ,"<S2SV_ModStart> WRITE_ONCE ( <S2SV_ModStart> , irq ) <S2SV_ModEnd> "
540,"<S2SV_StartBug> inl = i2d ( data , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; goto err ; } "
541,"<S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
542,<S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> BUG_ON ( ! ptr ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! cursor ) goto gc_complete ; <S2SV_ModStart> cursor <S2SV_ModEnd> 
543,<S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock 
544,<S2SV_StartBug> goto present_leaves_cluster_but_not_new_leaf ; <S2SV_EndBug> <S2SV_StartBug> present_leaves_cluster_but_not_new_leaf : <S2SV_EndBug> ,"<S2SV_ModStart> pr_devel ( ""present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n"" ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
545,<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; msg -> msg_namelen = 0 
546,"<S2SV_StartBug> struct mount * m , * child ; <S2SV_EndBug> <S2SV_StartBug> source = get_source ( m , prev_dest_mnt , prev_src_mnt , & type ) ; <S2SV_EndBug> ",<S2SV_ModStart> user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ; struct <S2SV_ModStart> ; if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED 
547,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> INTL_CHECK_LOCALE_LEN ( slocale_len ) ; 
548,<S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; } 
549,<S2SV_StartBug> if ( client -> priv -> protocol_timeout > 0 ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
550,<S2SV_StartBug> args -> valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; <S2SV_EndBug> <S2SV_StartBug> args -> valuelen ) ; <S2SV_EndBug> ,<S2SV_ModStart> rmtvaluelen = be32_to_cpu ( name_rmt -> valuelen ) ; args -> rmtblkno <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rmtvaluelen <S2SV_ModEnd> 
551,"<S2SV_StartBug> void sum_2_variances ( const var * a , const var * b , var * r ) { <S2SV_EndBug> <S2SV_StartBug> a -> sum_error + b -> sum_error , a -> count + b -> count , r ) ; <S2SV_EndBug> ",<S2SV_ModStart> static <S2SV_ModStart> assert ( a -> log2_count == b -> log2_count ) ; <S2SV_ModStart> log2_count + 1 <S2SV_ModEnd> 
552,<S2SV_StartBug> goto next_desc ; <S2SV_EndBug> ,"<S2SV_ModStart> ; } if ( ( buflen < elength ) || ( elength < 3 ) ) { dev_err ( & intf -> dev , ""invalid<S2SV_blank>descriptor<S2SV_blank>buffer<S2SV_blank>length\\n"" ) ; break "
553,<S2SV_StartBug> DevInfo . MaxRDMBufferSize = BUFFER_4K ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & DevInfo , 0 , sizeof ( DevInfo ) ) ; "
554,"<S2SV_StartBug> for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> data [ i ] = jas_matrix_create ( 1 , jas_image_width ( image ) ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> z = ( z << 8 ) | c ; <S2SV_EndBug> ","<S2SV_ModStart> assert ( <S2SV_ModEnd> <S2SV_ModStart> <= 3 ) ; for ( i = 0 ; i < 3 ; ++ i ) { data [ i ] = 0 ; } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( ! ( <S2SV_ModEnd> <S2SV_ModStart> ) ) { goto error ; } <S2SV_ModEnd> <S2SV_ModStart> goto error ; } z = ( z << 8 ) | c ; nz += 8 ; } v = ( z >> ( nz - hdr -> depth ) ) & RAS_ONES ( hdr -> depth ) ; z &= RAS_ONES ( nz - hdr -> depth ) ; nz -= hdr -> depth ; if ( jas_image_numcmpts ( image ) == 3 ) { jas_matrix_setv ( data [ 0 ] , x , ( RAS_GETRED ( v ) ) ) ; jas_matrix_setv ( data [ 1 ] , x , ( RAS_GETGREEN ( v ) ) ) ; jas_matrix_setv ( data [ 2 ] , x , ( RAS_GETBLUE ( v ) ) ) ; } else { jas_matrix_setv ( data [ 0 ] , x , ( v ) ) ; } } if ( pad ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { goto error ; } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( jas_image_writecmpt ( image , i , 0 , y , hdr -> width , 1 , data [ i ] ) ) { goto error ; } } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; data [ i ] = 0 ; } return 0 ; error : for ( i = 0 ; i < 3 ; ++ i ) { if ( data [ i ] ) { jas_matrix_destroy ( data [ i ] ) ; } } <S2SV_ModStart>  <S2SV_ModEnd> "
555,"<S2SV_StartBug> # ifndef _MSC_VER <S2SV_EndBug> <S2SV_StartBug> char fpath [ grub_strlen ( currpath ) + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> * currfound = currnode ; <S2SV_EndBug> <S2SV_StartBug> return grub_error ( GRUB_ERR_BAD_FILE_TYPE , ""not<S2SV_blank>a<S2SV_blank>directory"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( grub_errno ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> return grub_error ( GRUB_ERR_SYMLINK_LOOP , <S2SV_EndBug> <S2SV_StartBug> free_node ( oldnode , c ) ; <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return grub_error ( GRUB_ERR_FILE_NOT_FOUND , ""file<S2SV_blank>not<S2SV_blank>found"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> char * fpath = grub_malloc ( <S2SV_ModEnd> <S2SV_ModStart> ) ; char * name = fpath ; char * next ; enum grub_fshelp_filetype type = GRUB_FSHELP_DIR ; grub_fshelp_node_t currnode = currroot ; grub_fshelp_node_t oldnode = currroot ; c -> currroot = currroot ; grub_strncpy ( fpath , currpath , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; free ( fpath ) <S2SV_ModStart> free ( fpath ) ; <S2SV_ModStart> { free ( fpath ) ; <S2SV_ModStart> } <S2SV_ModStart> free ( fpath ) ; <S2SV_ModStart> ) ; free ( fpath <S2SV_ModStart> free ( fpath ) ; <S2SV_ModStart> free ( fpath ) ; <S2SV_ModStart> free ( fpath ) ; "
556,"<S2SV_StartBug> clips = kzalloc ( num_clips * sizeof ( * clips ) , GFP_KERNEL ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS ) { ret = - EINVAL ; goto out_err1 ; } 
557,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> match_data -> cmp = asymmetric_key_cmp ; 
558,"<S2SV_StartBug> ret = security_file_permission ( file , MAY_READ ) ; <S2SV_EndBug> <S2SV_StartBug> ret = security_file_permission ( file , MAY_WRITE ) ; <S2SV_EndBug> <S2SV_StartBug> ret = security_file_permission ( file , MAY_READ ) ; <S2SV_EndBug> <S2SV_StartBug> ret = security_file_permission ( file , MAY_WRITE ) ; <S2SV_EndBug> ","<S2SV_ModStart> aio_setup_single_vector ( READ , file , <S2SV_ModEnd> <S2SV_ModStart> aio_setup_single_vector ( WRITE , file , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
559,<S2SV_StartBug> long start ; <S2SV_EndBug> <S2SV_StartBug> char * header ; <S2SV_EndBug> <S2SV_StartBug> start = ftell ( fp ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = safe_calloc ( <S2SV_ModEnd> <S2SV_ModStart> long 
560,<S2SV_StartBug> dev -> netdev_ops = & bnep_netdev_ops ; <S2SV_EndBug> ,<S2SV_ModStart> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> 
561,<S2SV_StartBug> return ret != - EEXIST ? ret : 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
562,<S2SV_StartBug> for ( pass = 0 ; pass < 10 ; pass ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> || image 
563,<S2SV_StartBug> int64_t old_off = s -> off ; <S2SV_EndBug> <S2SV_StartBug> else if ( ( s -> filesize == - 1 && whence == SEEK_END ) ) <S2SV_EndBug> ,<S2SV_ModStart> uint64_t <S2SV_ModEnd> <S2SV_ModStart> UINT64_MAX <S2SV_ModEnd> 
564,<S2SV_StartBug> vpx_scale_rtcd ( ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
565,"<S2SV_StartBug> int len = OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> BIO_write ( bio , obj_txt , len ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> BIO_printf <S2SV_ModEnd> <S2SV_ModStart> ""%s\\n"" , obj_txt <S2SV_ModEnd> "
566,<S2SV_StartBug> return in ; <S2SV_EndBug> ,<S2SV_ModStart> NULL <S2SV_ModEnd> 
567,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> list_for_each_entry ( event , & current -> perf_event_list , owner_entry ) <S2SV_EndBug> <S2SV_StartBug> perf_event_for_each_child ( event , perf_event_disable ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct perf_event_context * ctx ; <S2SV_ModStart> { ctx = perf_event_ctx_lock ( event ) ; <S2SV_ModStart> _perf_event_disable ) ; perf_event_ctx_unlock ( event , ctx ) ; } <S2SV_ModEnd> "
568,<S2SV_StartBug> if ( ! unconditional ( & e -> ipv6 ) ) <S2SV_EndBug> ,<S2SV_ModStart> e <S2SV_ModEnd> 
569,<S2SV_StartBug> return code ; <S2SV_EndBug> ,"<S2SV_ModStart> { * status = ""DECODE_PA_S4U_X509_USER"" ; return code ; } <S2SV_ModEnd> "
570,"<S2SV_StartBug> arg ( identifier arg , expr_ty annotation , int lineno , int col_offset , int <S2SV_EndBug> <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug> ","<S2SV_ModStart> string type_comment , <S2SV_ModStart> type_comment = type_comment ; p -> "
571,"<S2SV_StartBug> int hdrlen ; <S2SV_EndBug> <S2SV_StartBug> if ( caplen < 3 ) { <S2SV_EndBug> <S2SV_StartBug> switch ( ( fc >> 10 ) & 0x3 ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> case 0x03 : <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( ( fc >> 14 ) & 0x3 ) { <S2SV_EndBug> <S2SV_StartBug> case 0x00 : <S2SV_EndBug> <S2SV_StartBug> case 0x01 : <S2SV_EndBug> <S2SV_StartBug> case 0x02 : <S2SV_EndBug> <S2SV_StartBug> if ( ! ( fc & ( 1 << 6 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case 0x03 : <S2SV_EndBug> <S2SV_StartBug> if ( ! ( fc & ( 1 << 6 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> caplen -= hdrlen ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> u_int <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( caplen < 3 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ; switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return hdrlen ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> <S2SV_ModStart> caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> + 2 ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen <S2SV_ModEnd> <S2SV_ModStart> FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> <S2SV_ModStart> caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> + 2 <S2SV_ModStart> caplen -= 8 ; hdrlen += 8 ; <S2SV_ModStart> if ( ndo -> ndo_vflag ) <S2SV_ModStart> FC_SRC_ADDRESSING_MODE ( fc ) <S2SV_ModEnd> <S2SV_ModStart> FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) <S2SV_ModEnd> <S2SV_ModStart> FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) <S2SV_ModEnd> <S2SV_ModStart> FC_ADDRESSING_MODE_SHORT <S2SV_ModEnd> <S2SV_ModStart> FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> <S2SV_ModStart> caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModEnd> <S2SV_ModStart> caplen -= 2 ; hdrlen += 2 ; <S2SV_ModStart> FC_ADDRESSING_MODE_LONG <S2SV_ModEnd> <S2SV_ModStart> FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> <S2SV_ModStart> caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModEnd> <S2SV_ModStart> caplen -= 8 ; hdrlen += 8 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> hdrlen <S2SV_ModEnd> "
572,"<S2SV_StartBug> l2tp_framing_type_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> <S2SV_StartBug> const uint32_t * ptr = ( const uint32_t * ) dat ; <S2SV_EndBug> ","<S2SV_ModStart> , u_int length <S2SV_ModStart> if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } "
573,"<S2SV_StartBug> int filt_mid = cm -> filter_level ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ss_err , 0 , sizeof ( ss_err ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
574,"<S2SV_StartBug> strlcpy ( rcipher . type , ""cipher"" , sizeof ( rcipher . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> 
575,<S2SV_StartBug> vpx_active_map_t map = { 0 } ; <S2SV_EndBug> ,"<S2SV_ModStart> 0 , 0 , "
576,<S2SV_StartBug> return NGHTTP2_ERR_INVALID_ARGUMENT ; <S2SV_EndBug> ,<S2SV_ModStart> ; } if ( settings_payloadlen / NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH > session -> max_settings ) { return NGHTTP2_ERR_TOO_MANY_SETTINGS 
577,<S2SV_StartBug> then = now ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! cfg -> rc_target_bitrate ) return ; 
578,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> } if ( free < 0 ) { err = - ENOMEM ; goto out ; 
579,<S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit ) { <S2SV_EndBug> ,<S2SV_ModStart> limit || ( unsigned char * ) e + e -> next_offset > 
580,<S2SV_StartBug> wp -> socket_mode = 0666 ; <S2SV_EndBug> ,<S2SV_ModStart> 0660 <S2SV_ModEnd> 
581,"<S2SV_StartBug> strncpy ( str , ""?["" , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> espruino_snprintf ( str , len , ""?[%d]"" , token <S2SV_ModEnd> "
582,"<S2SV_StartBug> rds_info_copy ( iter , & minfo , sizeof ( minfo ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> minfo . flags = 0 ; 
583,<S2SV_StartBug> srose -> srose_family = AF_ROSE ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( srose , 0 , msg -> msg_namelen ) ; "
584,"<S2SV_StartBug> if ( ! ND_TTEST2 ( cp , len ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
585,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
586,<S2SV_StartBug> newinet -> opt = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> inet_opt <S2SV_ModEnd> 
587,"<S2SV_StartBug> static double get_prediction_decay_rate ( const VP9_COMMON * cm , <S2SV_EndBug> <S2SV_StartBug> const double mb_sr_err_diff = ( next_frame -> sr_coded_error - <S2SV_EndBug> <S2SV_StartBug> const double second_ref_decay = mb_sr_err_diff <= 512.0 <S2SV_EndBug> <S2SV_StartBug> ? fclamp ( pow ( 1.0 - ( mb_sr_err_diff / 512.0 ) , 0.5 ) , 0.85 , 1.0 ) <S2SV_EndBug> ","<S2SV_ModStart> VP9_COMP * cpi <S2SV_ModEnd> <S2SV_ModStart> sr_decay_rate = get_sr_decay_rate ( cpi , next_frame ) <S2SV_ModEnd> <S2SV_ModStart> zero_motion_factor = ( 0.95 * pow ( ( next_frame -> pcnt_inter - next_frame -> pcnt_motion ) , ZM_POWER_FACTOR ) ) ; return MAX ( zero_motion_factor , ( sr_decay_rate + ( <S2SV_ModEnd> <S2SV_ModStart> sr_decay_rate ) * zero_motion_factor ) ) <S2SV_ModEnd> "
588,"<S2SV_StartBug> ret = put_user ( task_thread_info ( child ) -> tp_value , <S2SV_EndBug> ",<S2SV_ModStart> [ 0 ] 
589,"<S2SV_StartBug> vpx_codec_enc_init ( & stream -> encoder , global -> codec -> interface ( ) , <S2SV_EndBug> <S2SV_StartBug> vpx_codec_dec_init ( & stream -> decoder , decoder -> interface ( ) , NULL , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH flags |= stream -> config . use_16bit_internal ? VPX_CODEC_USE_HIGHBITDEPTH : 0 ; # endif <S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> codec_interface <S2SV_ModEnd> 
590,"<S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> <S2SV_StartBug> dev_name ( & qedi -> pdev -> dev ) , nfunc , line , <S2SV_EndBug> <S2SV_StartBug> pr_notice ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> 
591,<S2SV_StartBug> * head = NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> giterr_set_str ( GITERR_NET , ""Invalid<S2SV_blank>empty<S2SV_blank>packet"" ) ; return GIT_ERROR <S2SV_ModEnd> "
592,"<S2SV_StartBug> static struct ion_handle * ion_handle_get_by_id ( struct ion_client * client , <S2SV_EndBug> <S2SV_StartBug> handle = idr_find ( & client -> idr , id ) ; <S2SV_EndBug> <S2SV_StartBug> return handle ? handle : ERR_PTR ( - EINVAL ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ion_handle_get_by_id_nolock ( client , id <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
593,"<S2SV_StartBug> void Huff_offsetTransmit ( huff_t * huff , int ch , byte * fout , int * offset ) { <S2SV_EndBug> <S2SV_StartBug> send ( huff -> loc [ ch ] , NULL , fout ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int maxoffset <S2SV_ModStart> , maxoffset "
594,"<S2SV_StartBug> int i , j , offset ; <S2SV_EndBug> <S2SV_StartBug> uint32_t loc ; <S2SV_EndBug> <S2SV_StartBug> struct sparablePartitionMap * spm = <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( udf_load_sparable_map ( sb , map , ( <S2SV_ModEnd> <S2SV_ModStart> ) gpm ) < 0 ) goto out_bh <S2SV_ModEnd> "
595,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ( void ) _y4m ; ( void ) _dst ; ( void ) _aux ; 
596,"<S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_get ( ext2_xattr_cache , bh -> b_bdev , bh -> b_blocknr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> <S2SV_StartBug> le32_add_cpu ( & HDR ( bh ) -> h_refcount , - 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> __u32 hash = le32_to_cpu ( HDR ( bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( EXT2_SB ( inode -> i_sb ) -> s_mb_cache , hash , bh -> b_blocknr <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
597,<S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ,<S2SV_ModStart> rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if ( 
598,<S2SV_StartBug> int m ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( n < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_gobble"" ) ; } "
599,<S2SV_StartBug> kfree ( resp ) ; <S2SV_EndBug> ,<S2SV_ModStart> req ) ; kfree ( 
600,"<S2SV_StartBug> char buf [ MAX_PKT_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> len = recvfrom ( sd , buf , sizeof ( buf ) , MSG_DONTWAIT , & sa , & salen ) ; <S2SV_EndBug> <S2SV_StartBug> buf [ len ] = 0 ; <S2SV_EndBug> ",<S2SV_ModStart> + 1 <S2SV_ModStart> - 1 <S2SV_ModStart>  <S2SV_ModEnd> 
601,"
","
"
602,"<S2SV_StartBug> unsigned int maxw , maxh , max ; <S2SV_EndBug> <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0U ; i < ( maxh & ~ ( unsigned int ) 1U ) ; i += 2U ) <S2SV_EndBug> <S2SV_StartBug> ny = y + maxw ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> <S2SV_StartBug> if ( j < maxw ) <S2SV_EndBug> <S2SV_StartBug> if ( i < maxh ) <S2SV_EndBug> <S2SV_StartBug> for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> <S2SV_StartBug> # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_EndBug> <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> <S2SV_StartBug> if ( g ) free ( g ) ; <S2SV_EndBug> <S2SV_StartBug> if ( b ) free ( b ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t maxw , maxh , max , offx , loopmaxw , offy , loopmaxh ; int offset , upb ; size_t i <S2SV_ModEnd> <S2SV_ModStart> size_t ) img -> comps [ 0 ] . w ; maxh = ( size_t ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ; d1 = g <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> d2 = b <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; offy = img -> y0 & 1U ; loopmaxh = maxh - offy ; if ( offy > 0U ) { size_t j ; for ( j = 0 ; j < maxw ; ++ j ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } } <S2SV_ModStart> loopmaxh <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t j ; <S2SV_ModStart> if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; } <S2SV_ModStart> loopmaxw <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> loopmaxw <S2SV_ModEnd> <S2SV_ModStart> loopmaxh ) { size_t j ; <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> <S2SV_ModStart> dx = img -> comps [ 0 ] . dx ; <S2SV_ModEnd> <S2SV_ModStart> dy = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
603,<S2SV_StartBug> if ( * p == '#' ) { <S2SV_EndBug> ,"<S2SV_ModStart> len = FFMIN ( FFMAX ( len , 0 ) , sizeof ( color_name ) - 1 ) ; "
604,<S2SV_StartBug> print_bpf_insn ( insn ) ; <S2SV_EndBug> ,"<S2SV_ModStart> env , "
605,"<S2SV_StartBug> if ( uid_eq ( uid , current_fsuid ( ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( gid_eq ( gid , current_fsgid ( ) ) ) <S2SV_EndBug> ",<S2SV_ModStart> file -> f_cred -> fsuid <S2SV_ModEnd> <S2SV_ModStart> file -> f_cred -> fsgid <S2SV_ModEnd> 
606,<S2SV_StartBug> return true ; <S2SV_EndBug> ,<S2SV_ModStart> nf_generic_should_process ( nf_ct_protonum ( ct ) ) <S2SV_ModEnd> 
607,"<S2SV_StartBug> im = ( gdImage * ) gdCalloc ( 1 , sizeof ( gdImage ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( overflow2 ( sizeof ( unsigned char * ) , sx ) ) { return NULL ; } "
608,<S2SV_StartBug> if ( cpi -> pass == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) <S2SV_EndBug> <S2SV_StartBug> if ( q == 0 ) <S2SV_EndBug> ,<S2SV_ModStart> oxcf . <S2SV_ModStart> rc_mode == VPX_CBR <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
609,<S2SV_StartBug> if ( packet -> size + act_size > MT_PACKET_LEN ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> - packet -> size 
610,"<S2SV_StartBug> while ( * s && * s != \'\\""\' ) <S2SV_EndBug> <S2SV_StartBug> while ( isdigit ( ( unsigned char ) * s ) ) <S2SV_EndBug> ",<S2SV_ModStart> ( <S2SV_ModStart> ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) ) <S2SV_ModStart> ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) 
611,"
","
"
612,<S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> ,<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> 
613,<S2SV_StartBug> s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> <S2SV_StartBug> s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> ,<S2SV_ModStart> tlsext_use_etm = 0 <S2SV_ModEnd> <S2SV_ModStart> tlsext_use_etm = 1 <S2SV_ModEnd> 
614,<S2SV_StartBug> int cpu = smp_processor_id ( ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ) ; read_lock ( & evtchn_rwlock <S2SV_ModStart> read_unlock ( & evtchn_rwlock ) ; 
615,"<S2SV_StartBug> const char * path = conn -> data -> state . path ; <S2SV_EndBug> <S2SV_StartBug> smtpc -> domain = curl_easy_unescape ( conn -> data , path , 0 , & len ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> result = Curl_urldecode ( conn -> data , path , 0 , & <S2SV_ModStart> , NULL , TRUE ) ; if ( result ) return result <S2SV_ModEnd> "
616,<S2SV_StartBug> while ( ! * ( iter -> substr_cur ) ) <S2SV_EndBug> ,"<S2SV_ModStart> iter -> substr_end = strchr ( iter -> substr_cur , ',' ) ; if ( ! iter -> substr_end ) iter -> substr_end = iter -> eostr ; else * ( iter -> substr_end ++ <S2SV_ModEnd> "
617,<S2SV_StartBug> const struct aodv_hello * ah ; <S2SV_EndBug> <S2SV_StartBug> goto trunc ; <S2SV_EndBug> ,"<S2SV_ModStart> ; ND_TCHECK ( * ep ) <S2SV_ModStart> if ( ep -> length < 4 ) { ND_PRINT ( ( ndo , ""\\n\\text<S2SV_blank>HELLO<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>length<S2SV_blank>%u"" , ep -> length ) ) ; break ; } "
618,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && frame -> linesize [ plane ] 
619,"<S2SV_StartBug> if ( drop_privileges ( nagios_user , nagios_group ) == ERROR ) { <S2SV_EndBug> <S2SV_StartBug> exit ( EXIT_FAILURE ) ; <S2SV_EndBug> ","<S2SV_ModStart> daemon_mode == TRUE && sigrestart == FALSE ) { result = daemon_init ( ) ; if ( result == ERROR ) { logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , ""Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)"" , ( int ) getpid ( ) ) ; cleanup ( ) ; exit ( EXIT_FAILURE ) ; } nagios_pid = ( int ) getpid ( ) ; } if ( <S2SV_ModStart>  <S2SV_ModEnd> "
620,<S2SV_StartBug> if ( ( ( int ) arg >= cdi -> capacity ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
621,<S2SV_StartBug> rc -> sb64_target_rate = ( ( int64_t ) rc -> this_frame_target * 64 * 64 ) / <S2SV_EndBug> ,<S2SV_ModStart> if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC && rc -> frame_size_selector != UNSCALED ) rc -> this_frame_target = ( int ) ( rc -> this_frame_target * rate_thresh_mult [ rc -> frame_size_selector ] ) ; 
622,<S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( int ) 
623,"<S2SV_StartBug> if ( ! fdt_getprop ( fit , 0 , FIT_DESC_PROP , NULL ) ) { <S2SV_EndBug> ","<S2SV_ModStart> CONFIG_IS_ENABLED ( FIT_FULL_CHECK ) ) { if ( size == IMAGE_SIZE_INVAL ) size = fdt_totalsize ( fit ) ; ret = fdt_check_full ( fit , size ) ; if ( ret ) { log_debug ( ""FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\n"" , ret ) ; return - EINVAL ; } } if ( "
624,"<S2SV_StartBug> dwc3_gadget_giveback ( dep , req , ret ) ; <S2SV_EndBug> ",<S2SV_ModStart> dwc3_gadget_del_and_unmap_request <S2SV_ModEnd> 
625,"<S2SV_StartBug> return r ? : __blkdev_driver_ioctl ( bdev , mode , cmd , arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! r && ti -> len != i_size_read ( bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; "
626,<S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
627,<S2SV_StartBug> if ( rs -> rs_bound_addr == 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> || ! rs -> rs_transport 
628,"<S2SV_StartBug> iwl_sta_ucode_activate ( priv , sta_id ) ; <S2SV_EndBug> ","<S2SV_ModStart> ret = iwl_sta_ucode_activate ( priv , sta_id ) <S2SV_ModEnd> "
629,<S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ip6t_entry ) && <S2SV_EndBug> <S2SV_StartBug> t -> verdict < 0 && <S2SV_EndBug> ,<S2SV_ModStart> unconditional ( e <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
630,"<S2SV_StartBug> nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { <S2SV_EndBug> <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug> ",<S2SV_ModStart> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
631,"<S2SV_StartBug> sraSpanInsertBefore ( sraSpan * newspan , sraSpan * before ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> before ) { if ( newspan && <S2SV_ModStart> } 
632,<S2SV_StartBug> int just_opened = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! v -> finished && <S2SV_EndBug> ,<S2SV_ModStart> = 0 ; int reload_count <S2SV_ModStart> reload_count ++ ; if ( reload_count > c -> max_reload ) return AVERROR_EOF ; 
633,<S2SV_StartBug> spin_lock_init ( & sta -> lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; spin_lock_init ( & sta -> ps_lock 
634,<S2SV_StartBug> out_size = in_len + 32 ; <S2SV_EndBug> ,<S2SV_ModStart> int max_input_expansion = ( ( int ) ( in_len / 32000 ) + 1 ) * 5 ; out_size = 10 + 8 + max_input_expansion + in_len <S2SV_ModEnd> 
635,<S2SV_StartBug> cmap_len = get_ushort ( & tga [ 5 ] ) ; <S2SV_EndBug> <S2SV_StartBug> x_origin = get_ushort ( & tga [ 8 ] ) ; <S2SV_EndBug> <S2SV_StartBug> y_origin = get_ushort ( & tga [ 10 ] ) ; <S2SV_EndBug> <S2SV_StartBug> image_w = get_ushort ( & tga [ 12 ] ) ; <S2SV_EndBug> <S2SV_StartBug> image_h = get_ushort ( & tga [ 14 ] ) ; <S2SV_EndBug> ,<S2SV_ModStart> get_tga_ushort <S2SV_ModEnd> <S2SV_ModStart> get_tga_ushort <S2SV_ModEnd> <S2SV_ModStart> get_tga_ushort <S2SV_ModEnd> <S2SV_ModStart> get_tga_ushort <S2SV_ModEnd> <S2SV_ModStart> get_tga_ushort <S2SV_ModEnd> 
636,"<S2SV_StartBug> ( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) <S2SV_EndBug> <S2SV_StartBug> iris_info . name ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) count ; <S2SV_EndBug> <S2SV_StartBug> if ( EOFBlob ( image ) != MagickFalse ) <S2SV_EndBug> ","<S2SV_ModStart> count = <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" <S2SV_ModStart> if ( count != sizeof ( iris_info . filler ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
637,<S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> ,<S2SV_ModStart> key_is_positive <S2SV_ModEnd> 
638,<S2SV_StartBug> if ( retval ) <S2SV_EndBug> ,<S2SV_ModStart> ! retval ) <S2SV_ModEnd> 
639,"<S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
640,"<S2SV_StartBug> if ( icsk -> icsk_af_ops -> conn_request ( sk , skb ) < 0 ) <S2SV_EndBug> ",<S2SV_ModStart> th -> fin ) goto discard ; if ( 
641,"<S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> <S2SV_StartBug> if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || <S2SV_EndBug> <S2SV_StartBug> if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || <S2SV_EndBug> ","<S2SV_ModStart> ; u32 dst = insn -> dst_reg ; int ret <S2SV_ModStart> ret = sanitize_val_alu ( env , insn ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\n"" , dst ) ; return ret ; } <S2SV_ModStart> ret = sanitize_val_alu ( env , insn ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\n"" , dst ) ; return ret ; } "
642,"<S2SV_StartBug> static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * d ) <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> d -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ; <S2SV_EndBug> <S2SV_StartBug> if ( d -> fe_adap [ 0 ] . fe == NULL ) <S2SV_EndBug> <S2SV_StartBug> if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ) { <S2SV_EndBug> ","<S2SV_ModStart> adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
643,<S2SV_StartBug> if ( ! vcpu -> arch . time_page ) <S2SV_EndBug> ,<S2SV_ModStart> pv_time_enabled <S2SV_ModEnd> 
644,<S2SV_StartBug> default : <S2SV_EndBug> ,<S2SV_ModStart> case MAGIC_PARAM_ELF_NOTES_MAX : ms -> elf_notes_max = * ( const size_t * ) val ; return 0 ; 
645,"<S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> fs , VCPU_SREG_FS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> gs , VCPU_SREG_GS , cpl , true ) ; <S2SV_EndBug> ","<S2SV_ModStart> cpl , true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> "
646,"<S2SV_StartBug> atomic_inc ( & ( ( struct bpf_prog * ) raw ) -> aux -> refcnt ) ; <S2SV_EndBug> <S2SV_StartBug> bpf_map_inc ( raw , true ) ; <S2SV_EndBug> ",<S2SV_ModStart> raw = bpf_prog_inc ( raw <S2SV_ModEnd> <S2SV_ModStart> raw = 
647,"<S2SV_StartBug> signed long personality ; <S2SV_EndBug> <S2SV_StartBug> ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ; <S2SV_EndBug> <S2SV_StartBug> . exec_payload = exec_payload <S2SV_EndBug> ","<S2SV_ModStart> int procfd ; <S2SV_ModStart> procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY ) ; if ( procfd < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> , . procfd = procfd "
648,"<S2SV_StartBug> timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; <S2SV_EndBug> ",<S2SV_ModStart> m -> msg_namelen = 0 ; 
649,<S2SV_StartBug> if ( * rsize >= 30 && rdesc [ 29 ] == 0x05 && rdesc [ 30 ] == 0x09 ) { <S2SV_EndBug> ,<S2SV_ModStart> 31 <S2SV_ModEnd> 
650,"<S2SV_StartBug> pfn = kvm_pin_pages ( slot , gfn , page_size ) ; <S2SV_EndBug> <S2SV_StartBug> kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_EndBug> ",<S2SV_ModStart> >> PAGE_SHIFT <S2SV_ModStart> >> PAGE_SHIFT 
651,<S2SV_StartBug> if ( skb_is_nonlinear ( skb ) ) <S2SV_EndBug> ,<S2SV_ModStart> ) ) return 0 ; if ( skb -> len < sizeof ( struct nlattr 
652,<S2SV_StartBug> int is_udplite = IS_UDPLITE ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( udp_lib_checksum_complete ( skb ) ) <S2SV_EndBug> <S2SV_StartBug> if ( skb_csum_unnecessary ( skb ) ) <S2SV_EndBug> ,<S2SV_ModStart> ; bool checksum_valid = false <S2SV_ModStart> checksum_valid = ! <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! checksum_valid <S2SV_ModStart> checksum_valid || 
653,<S2SV_StartBug> Z_STRVAL_P ( return_value ) = emalloc ( length + 1 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d"" , INT_MAX ) ; RETURN_FALSE ; } "
654,"<S2SV_StartBug> jas_iccprof_t * jas_iccprof_createfrombuf ( uchar * buf , int len ) <S2SV_EndBug> ",<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
655,<S2SV_StartBug> return ret != - EEXIST ? ret : 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
656,<S2SV_StartBug> TfLiteIntArray * ret = <S2SV_EndBug> <S2SV_StartBug> ( TfLiteIntArray * ) malloc ( TfLiteIntArrayGetSizeInBytes ( size ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> int alloc_size = TfLiteIntArrayGetSizeInBytes ( size ) ; if ( alloc_size <= 0 ) return NULL ; <S2SV_ModStart> alloc_size ) ; if ( ! ret ) return ret <S2SV_ModEnd> 
657,"<S2SV_StartBug> struct gs_host_config hconf = { <S2SV_EndBug> <S2SV_StartBug> struct gs_device_config dconf ; <S2SV_EndBug> <S2SV_StartBug> & hconf , <S2SV_EndBug> <S2SV_StartBug> sizeof ( hconf ) , <S2SV_EndBug> <S2SV_StartBug> if ( rc < 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> & dconf , <S2SV_EndBug> <S2SV_StartBug> sizeof ( dconf ) , <S2SV_EndBug> <S2SV_StartBug> return rc ; <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> if ( ! dev ) <S2SV_EndBug> <S2SV_StartBug> init_usb_anchor ( & dev -> rx_submitted ) ; <S2SV_EndBug> <S2SV_StartBug> dev -> canch [ i ] = gs_make_candev ( i , intf , & dconf ) ; <S2SV_EndBug> <S2SV_StartBug> kfree ( dev ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> * hconf <S2SV_ModEnd> <S2SV_ModStart> * dconf ; hconf = kmalloc ( sizeof ( * hconf ) , GFP_KERNEL ) ; if ( ! hconf ) return - ENOMEM ; hconf -> byte_order = 0x0000beef <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModStart> kfree ( hconf ) ; <S2SV_ModStart> dconf = kmalloc ( sizeof ( * dconf ) , GFP_KERNEL ) ; if ( ! dconf ) return - ENOMEM ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModStart> kfree ( dconf ) ; return rc ; } icount = dconf -> <S2SV_ModEnd> <S2SV_ModStart> kfree ( dconf ) ; <S2SV_ModStart> { kfree ( dconf ) ; <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dconf ) ; kfree ( <S2SV_ModStart> kfree ( dconf ) ; "
658,<S2SV_StartBug> p += 2 ; <S2SV_EndBug> <S2SV_StartBug> p += 3 ; <S2SV_EndBug> <S2SV_StartBug> p += 4 ; <S2SV_EndBug> <S2SV_StartBug> l = p [ 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 2 ) return - 1 ; <S2SV_ModStart> if ( len < 3 ) return - 1 ; <S2SV_ModStart> if ( len < 4 ) return - 1 ; <S2SV_ModStart> if ( len < 2 ) return - 1 ; 
659,"<S2SV_StartBug> utee_param_to_param ( param , callee_params ) ; <S2SV_EndBug> ","<S2SV_ModStart> res = utee_param_to_param ( utc , <S2SV_ModEnd> <S2SV_ModStart> ; if ( res != TEE_SUCCESS ) return res "
660,<S2SV_StartBug> if ( image -> storage_class == PseudoClass ) <S2SV_EndBug> ,"<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
661,<S2SV_StartBug> vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( vcpu -> arch . time_offset & ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break 
662,<S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> < <S2SV_ModEnd> 
663,<S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> * objp = NULL ; 
664,<S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> iif = l3mdev_master_ifindex ( skb_dst ( skb ) -> dev ) ; <S2SV_EndBug> ,<S2SV_ModStart> { dst = skb_dst ( skb ) ; <S2SV_ModStart> dst ? dst -> dev : skb -> dev ) ; } <S2SV_ModEnd> 
665,"<S2SV_StartBug> const char * data , int optional ) <S2SV_EndBug> <S2SV_StartBug> if ( mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data ) ) { <S2SV_EndBug> <S2SV_StartBug> mountflags | MS_REMOUNT , data ) ) { <S2SV_EndBug> ","<S2SV_ModStart> , const char * rootfs <S2SV_ModStart> safe_mount <S2SV_ModEnd> <S2SV_ModStart> , rootfs <S2SV_ModStart> < 0 "
666,"<S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
667,"<S2SV_StartBug> cleanup_free char * base_path = NULL ; <S2SV_EndBug> <S2SV_StartBug> base_path = xasprintf ( ""/run/user/%d/.bubblewrap"" , real_uid ) ; <S2SV_EndBug> ","<S2SV_ModStart> const <S2SV_ModEnd> <S2SV_ModStart> ""/tmp"" ; <S2SV_ModEnd> "
668,"<S2SV_StartBug> void vp9_fht4x4_c ( const int16_t * input , int16_t * output , <S2SV_EndBug> <S2SV_StartBug> vp9_fdct4x4_c ( input , output , stride ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t out [ 4 * 4 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = & out [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t temp_in [ 4 ] , temp_out [ 4 ] ; <S2SV_EndBug> <S2SV_StartBug> outptr [ j * 4 + i ] = temp_out [ j ] ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_fdct4x4_c <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> 
669,"<S2SV_StartBug> static const char * parse_array ( cJSON * item , const char * value ) <S2SV_EndBug> <S2SV_StartBug> ep = value ; <S2SV_EndBug> <S2SV_StartBug> return value + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( item -> child = child = cJSON_New_Item ( ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ( value = skip ( parse_value ( child , skip ( value ) ) ) ) ) <S2SV_EndBug> <S2SV_StartBug> child = new_item ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) <S2SV_EndBug> <S2SV_StartBug> return value + 1 ; <S2SV_EndBug> ","<S2SV_ModStart> , const char * * ep <S2SV_ModStart> * ep = value ; return 0 ; <S2SV_ModEnd> <S2SV_ModStart> return value + 1 ; <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! item -> child ) return 0 ; <S2SV_ModEnd> <S2SV_ModStart> , ep ) ) ; if ( ! value ) <S2SV_ModEnd> <S2SV_ModStart> child = new_item ; <S2SV_ModEnd> <S2SV_ModStart> , ep ) ) ; if ( ! value ) <S2SV_ModEnd> <S2SV_ModStart> return value + 1 ; * ep = value ; <S2SV_ModEnd> "
670,"<S2SV_StartBug> int yy , mm , dd , hr , min , sec , csec ; <S2SV_EndBug> <S2SV_StartBug> ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , <S2SV_EndBug> <S2SV_StartBug> ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , <S2SV_EndBug> <S2SV_StartBug> yy = mm = dd = hr = min = sec = csec = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" <S2SV_ModEnd> <S2SV_ModStart> ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" <S2SV_ModEnd> <S2SV_ModStart> ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ; return FALSE "
671,"<S2SV_StartBug> const char * args [ 11 ] ; <S2SV_EndBug> <S2SV_StartBug> args [ i ++ ] = ""--"" ; <S2SV_EndBug> <S2SV_StartBug> execvp ( EXECUTABLE , ( char * * ) args ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> char tmp_directory [ ] = LARGE_DATA_TMP_DIR ""/abrt-tmp-debuginfo.XXXXXX"" ; if ( mkdtemp ( tmp_directory ) == NULL ) perror_msg_and_die ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>working<S2SV_blank>directory"" ) ; log_info ( ""Created<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , tmp_directory ) ; const char * args [ 13 <S2SV_ModEnd> <S2SV_ModStart> ""--tmpdir"" ; args [ i ++ ] = tmp_directory ; args [ i ++ ] = <S2SV_ModStart> pid_t pid = fork ( ) ; if ( pid < 0 ) perror_msg_and_die ( ""fork"" ) ; if ( pid == 0 ) { <S2SV_ModStart> int status ; if ( safe_waitpid ( pid , & status , 0 ) < 0 ) perror_msg_and_die ( ""waitpid"" ) ; if ( rmdir ( tmp_directory ) >= 0 ) log_info ( ""Removed<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , tmp_directory ) ; else if ( errno != ENOENT ) perror_msg ( ""Failed<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>working<S2SV_blank>directory"" ) ; if ( WIFEXITED ( status ) ) return WEXITSTATUS ( status ) ; if ( WIFSIGNALED ( status ) ) error_msg_and_die ( ""Child<S2SV_blank>terminated<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d"" , WTERMSIG ( status ) ) ; error_msg_and_die ( ""Child<S2SV_blank>exit<S2SV_blank>failed"" ) ; } "
672,<S2SV_StartBug> kern_msg -> msg_name = kern_address ; <S2SV_EndBug> ,<S2SV_ModStart> if ( kern_msg -> msg_name ) 
673,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> id_key_set = rb_intern_const ( ""key_set"" ) ; "
674,"<S2SV_StartBug> if ( strchr ( page , '/' ) ) <S2SV_EndBug> ",<S2SV_ModStart> ! page_name_is_good ( page <S2SV_ModEnd> 
675,"<S2SV_StartBug> int do_rf64 = 0 , write_junk = 1 ; <S2SV_EndBug> <S2SV_StartBug> DS64Chunk ds64_chunk ; <S2SV_EndBug> <S2SV_StartBug> if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ; <S2SV_EndBug> <S2SV_StartBug> ds64hdr . ckSize = sizeof ( ds64_chunk ) ; <S2SV_EndBug> <S2SV_StartBug> ds64_chunk . sampleCount64 = total_samples ; <S2SV_EndBug> <S2SV_StartBug> WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ; <S2SV_EndBug> <S2SV_StartBug> ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) || <S2SV_EndBug> ","<S2SV_ModStart> , table_length = 0 <S2SV_ModStart> ; CS64Chunk cs64_chunk <S2SV_ModStart> total_riff_bytes += table_length * sizeof ( CS64Chunk ) ; if ( write_junk ) total_riff_bytes += <S2SV_ModEnd> <S2SV_ModStart> + ( table_length * sizeof ( CS64Chunk ) ) <S2SV_ModStart> ; ds64_chunk . tableLength = table_length <S2SV_ModStart> if ( table_length ) { strncpy ( cs64_chunk . ckID , ""dmmy"" , sizeof ( cs64_chunk . ckID ) ) ; cs64_chunk . chunkSize64 = 12345678 ; WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ; } <S2SV_ModStart> ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } if ( <S2SV_ModEnd> "
676,<S2SV_StartBug> pipe -> curbuf = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> account_pipe_buffers ( pipe , pipe -> buffers , nr_pages ) ; "
677,"<S2SV_StartBug> cli_writeint32 ( & exe [ pe + 0x28 ] , cli_readint32 ( wwsect + 0x295 ) + sects [ scount ] . rva + 0x299 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 , 4 ) || ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 + sects [ scount ] . rva , 4 ) || ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 + sects [ scount ] . rva + 0x299 , 4 ) ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>unpack<S2SV_blank>memory<S2SV_blank>address<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds.\\n"" ) ; return CL_EFORMAT ; } "
678,<S2SV_StartBug> if ( shdr -> sh_size < 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> || shdr -> sh_size > SIZE_MAX 
679,"<S2SV_StartBug> int ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( d2i_ECDSA_SIG ( & s , & sigbuf , sig_len ) == NULL ) goto err ; <S2SV_EndBug> <S2SV_StartBug> ECDSA_SIG_free ( s ) ; <S2SV_EndBug> ","<S2SV_ModStart> const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> p <S2SV_ModEnd> <S2SV_ModStart> goto err ; derlen = i2d_ECDSA_SIG ( s , & der ) ; if ( derlen != sig_len || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; } "
680,<S2SV_StartBug> NAPI_GRO_CB ( skb ) -> udp_mark = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> encap_mark <S2SV_ModEnd> 
681,"
","
"
682,"<S2SV_StartBug> struct mb_cache_entry * ce = NULL ; <S2SV_EndBug> <S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_get ( ext4_mb_cache , bs -> bh -> b_bdev , <S2SV_EndBug> <S2SV_StartBug> if ( ce ) { <S2SV_EndBug> <S2SV_StartBug> if ( ce ) { <S2SV_EndBug> <S2SV_StartBug> le32_add_cpu ( & BHDR ( new_bh ) -> h_refcount , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> ","<S2SV_ModStart> mb2_cache_entry <S2SV_ModEnd> <S2SV_ModStart> mb2_cache <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> __u32 hash = le32_to_cpu ( BHDR ( bs -> bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( ext4_mb_cache , hash , bs -> bh -> b_blocknr ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) { unlock_buffer ( new_bh ) ; dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; brelse ( new_bh ) ; mb2_cache_entry_put ( ext4_mb_cache , ce ) ; ce = NULL ; new_bh = NULL ; goto inserted ; } <S2SV_ModStart> mb2_cache_entry_touch ( ext4_mb_cache , ce ) ; mb2_cache_entry_put ( ext4_mb_cache , <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_entry_put ( ext4_mb_cache , <S2SV_ModEnd> "
683,<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> ,<S2SV_ModStart> void 
684,<S2SV_StartBug> static void oidc_scrub_headers ( request_rec * r ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
685,"<S2SV_StartBug> readBytes = readFromSocket ( self , buffer + bufPos , self -> packetSize - bufPos ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( self -> packetSize <= bufPos ) goto exit_error ; 
686,<S2SV_StartBug> size_t e ; <S2SV_EndBug> <S2SV_StartBug> if ( mrb_basic_ptr ( v ) -> tt == MRB_TT_FREE ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ; mrb_value nil <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> e = c -> stend - c -> stbase ; nil = mrb_nil_value ( ) ; for ( ; i < e ; i ++ ) { c -> stbase [ i ] = nil ; 
687,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> ",<S2SV_ModStart> key_is_negative ( key <S2SV_ModEnd> 
688,<S2SV_StartBug> if ( ! new_buffer ) <S2SV_EndBug> <S2SV_StartBug> return AVERROR ( ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! new_buffer ) <S2SV_EndBug> <S2SV_StartBug> return AVERROR ( ENOMEM ) ; <S2SV_EndBug> ,<S2SV_ModStart> { pc -> index = 0 ; <S2SV_ModStart> } <S2SV_ModStart> { pc -> overread_index = pc -> index = 0 ; <S2SV_ModStart> } 
689,"<S2SV_StartBug> const cdf_stream_t * sst , const uint64_t clsid [ 2 ] ) <S2SV_EndBug> <S2SV_StartBug> str = cdf_clsid_to_mime ( clsid , clsid2desc ) ; <S2SV_EndBug> <S2SV_StartBug> return - 2 ; <S2SV_EndBug> <S2SV_StartBug> m = cdf_file_property_info ( ms , info , count , clsid ) ; <S2SV_EndBug> ",<S2SV_ModStart> cdf_directory_t * root_storage <S2SV_ModEnd> <S2SV_ModStart> if ( root_storage ) { <S2SV_ModStart> root_storage -> d_storage_uuid <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> root_storage <S2SV_ModEnd> 
690,<S2SV_StartBug> op -> regs [ reg_index ] = reg ; <S2SV_EndBug> <S2SV_StartBug> ++ reg_index ; <S2SV_EndBug> <S2SV_StartBug> op -> offset += temp ; <S2SV_EndBug> <S2SV_StartBug> op -> regs [ reg_index ] = X86R_UNDEFINED ; <S2SV_EndBug> ,<S2SV_ModStart> if ( reg_index < 2 ) { <S2SV_ModStart> } <S2SV_ModStart> if ( reg_index < 2 ) { <S2SV_ModStart> } 
691,"<S2SV_StartBug> gpio_dev -> pctrl = pinctrl_register ( & amd_pinctrl_desc , <S2SV_EndBug> <S2SV_StartBug> & pdev -> dev , gpio_dev ) ; <S2SV_EndBug> <S2SV_StartBug> goto out1 ; <S2SV_EndBug> <S2SV_StartBug> out1 : <S2SV_EndBug> ","<S2SV_ModStart> devm_pinctrl_register ( & pdev -> dev , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return ret <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
692,"<S2SV_StartBug> decoder_info -> log2_sb_size = get_flc ( 3 , stream ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; decoder_info -> log2_sb_size = clip ( decoder_info -> log2_sb_size , log2i ( MIN_BLOCK_SIZE ) , log2i ( MAX_SB_SIZE ) "
693,<S2SV_StartBug> int is_udplite = IS_UDPLITE ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( udp_lib_checksum_complete ( skb ) ) <S2SV_EndBug> <S2SV_StartBug> if ( skb_csum_unnecessary ( skb ) ) <S2SV_EndBug> ,<S2SV_ModStart> ; bool checksum_valid = false <S2SV_ModStart> checksum_valid = ! <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! checksum_valid <S2SV_ModStart> checksum_valid || 
694,"<S2SV_StartBug> int ret , last_pwd ; <S2SV_EndBug> <S2SV_StartBug> ret = decrypt_key_data ( handle -> context , <S2SV_EndBug> <S2SV_StartBug> kdb -> n_key_data , kdb -> key_data , <S2SV_EndBug> ","<S2SV_ModStart> , n_new_keys <S2SV_ModStart> n_new_keys = count_new_keys ( kdb -> n_key_data , kdb -> key_data ) ; <S2SV_ModStart> n_new_keys <S2SV_ModEnd> "
695,"<S2SV_StartBug> int isopen ; <S2SV_EndBug> <S2SV_StartBug> size = offsetof ( POLYGON , p [ 0 ] ) + sizeof ( poly -> p [ 0 ] ) * npts ; <S2SV_EndBug> ","<S2SV_ModStart> base_size ; int <S2SV_ModStart> base_size = sizeof ( poly -> p [ 0 ] ) * npts ; <S2SV_ModStart> base_size ; if ( base_size / npts != <S2SV_ModStart> || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested"" ) ) ) <S2SV_ModEnd> "
696,"<S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_32BITS <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
697,<S2SV_StartBug> # if CONFIG_MULTIPLE_ARF <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
698,"<S2SV_StartBug> _iov -> iov_len = min ( ( u64 ) len , size ) ; <S2SV_EndBug> ",<S2SV_ModStart> - s 
699,<S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> <S2SV_StartBug> limit = get_desc_limit ( desc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( desc -> g ) <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_desc ( & desc , sel ) <S2SV_ModEnd> <S2SV_ModStart> & <S2SV_ModStart> . <S2SV_ModEnd> "
700,<S2SV_StartBug> ( void ) CloseBlob ( pwp_image ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
701,<S2SV_StartBug> count = Z_LVAL_P ( pcount ) ; <S2SV_EndBug> <S2SV_StartBug> if ( Z_TYPE ( entry ) != IS_OBJECT ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ,<S2SV_ModStart> ) ; ZVAL_UNDEF ( & entry ) ; ZVAL_UNDEF ( & inf <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( Z_TYPE ( entry ) != IS_OBJECT ) { zval_ptr_dtor ( & entry ) ; zval_ptr_dtor ( & inf ) ; goto outexcept <S2SV_ModEnd> 
702,"<S2SV_StartBug> unsigned long tpgt ; <S2SV_EndBug> <S2SV_StartBug> if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) <S2SV_EndBug> ",<S2SV_ModStart> u16 <S2SV_ModEnd> <S2SV_ModStart> kstrtou16 <S2SV_ModEnd> <S2SV_ModStart> >= VHOST_SCSI_MAX_TARGET <S2SV_ModEnd> 
703,"<S2SV_StartBug> void headerMergeLegacySigs ( Header h , Header sigh ) <S2SV_EndBug> <S2SV_StartBug> hi = headerInitIterator ( sigh ) ; <S2SV_EndBug> <S2SV_StartBug> td . tag = RPMTAG_SIGSIZE ; <S2SV_EndBug> <S2SV_StartBug> td . tag = RPMTAG_SIGPGP ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( td . tag >= HEADER_SIGBASE && td . tag < HEADER_TAGBASE ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! headerIsEntry ( h , td . tag ) ) { <S2SV_EndBug> <S2SV_StartBug> ( void ) headerPut ( h , & td , HEADERPUT_DEFAULT ) ; <S2SV_EndBug> ","<S2SV_ModStart> rpmTagVal <S2SV_ModEnd> <S2SV_ModStart> , char * * msg ) { const struct taglate_s * xl <S2SV_ModEnd> <S2SV_ModStart> rpmtdReset ( & td ) ; for ( xl = xlateTags ; xl -> stag ; xl ++ ) { if ( headerIsEntry ( h , xl -> xtag ) ) break ; if ( headerGet ( sigh , xl -> stag , & td , HEADERGET_RAW | HEADERGET_MINMEM ) ) { if ( xl -> stag != xl -> xtag ) <S2SV_ModEnd> <S2SV_ModStart> xl -> xtag ; if ( td . type != rpmTagGetTagType ( <S2SV_ModEnd> <S2SV_ModStart> ) ) break ; if ( td . count < 1 || td . count > 16 * 1024 * 1024 ) break ; if ( xl -> count && td . count != xl -> count ) break ; <S2SV_ModEnd> <S2SV_ModStart> headerPut <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) break ; rpmtdFreeData ( & td ) ; } } rpmtdFreeData ( & td ) ; if ( xl -> stag ) { rasprintf ( msg , ""invalid<S2SV_blank>signature<S2SV_blank>tag<S2SV_blank>%s<S2SV_blank>(%d)"" , rpmTagGetName ( xl -> xtag ) , xl -> xtag ) ; } return xl -> stag <S2SV_ModEnd> "
704,"<S2SV_StartBug> ""Pushing<S2SV_blank>input<S2SV_blank>%d<S2SV_blank>:<S2SV_blank>%.30s\\n"" , ctxt -> inputNr + 1 , input -> cur ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; } if ( ( ( ctxt -> inputNr > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> inputNr > 1024 ) ) { xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ; while ( ctxt -> inputNr > 1 ) xmlFreeInputStream ( inputPop ( ctxt ) ) ; return ( - 1 "
705,<S2SV_StartBug> if ( ! ext4_handle_valid ( handle ) ) <S2SV_EndBug> ,<S2SV_ModStart> EXT4_SB ( sb ) -> s_journal <S2SV_ModEnd> 
706,<S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK2 ( * ext , sizeof ( a ) <S2SV_ModEnd> "
707,"<S2SV_StartBug> netdev -> dcbnl_ops -> getpermhwaddr ( netdev , perm_addr ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( perm_addr , 0 , sizeof ( perm_addr ) ) ; "
708,"<S2SV_StartBug> if ( NFS_PROTO ( inode ) -> have_delegation ( inode , FMODE_WRITE ) ) <S2SV_EndBug> <S2SV_StartBug> if ( nfs_write_pageuptodate ( page , inode ) && ( inode -> i_flock == NULL || <S2SV_EndBug> <S2SV_StartBug> inode -> i_flock -> fl_type != F_RDLCK ) ) ) <S2SV_EndBug> ","<S2SV_ModStart> ! nfs_write_pageuptodate ( page , inode ) ) return 0 ; if ( <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
709,"<S2SV_StartBug> struct ext4_ext_path * path ) <S2SV_EndBug> <S2SV_StartBug> struct ext4_extent * ex ; <S2SV_EndBug> <S2SV_StartBug> ext_debug ( ""ext4_convert_unwritten_extents_endio:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" <S2SV_EndBug> <S2SV_StartBug> ( unsigned long long ) le32_to_cpu ( ex -> ee_block ) , <S2SV_EndBug> ","<S2SV_ModStart> ext4_map_blocks * map , struct <S2SV_ModStart> ; ext4_lblk_t ee_block ; unsigned int ee_len <S2SV_ModStart> ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; <S2SV_ModStart> ee_block , ee_len ) ; if ( ee_block != map -> m_lblk || ee_len > map -> m_len ) { err = ext4_split_unwritten_extents ( handle , inode , map , path , EXT4_GET_BLOCKS_CONVERT ) ; if ( err < 0 ) goto out ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; goto out ; } depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; } <S2SV_ModEnd> "
710,<S2SV_StartBug> return ret ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ; "
711,<S2SV_StartBug> if ( noblock ) <S2SV_EndBug> ,<S2SV_ModStart> cond_resched ( ) <S2SV_ModEnd> 
712,"<S2SV_StartBug> if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) { <S2SV_EndBug> ",<S2SV_ModStart> | O_NOFOLLOW 
713,<S2SV_StartBug> init_thread : <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! test_opt ( sbi , FLUSH_MERGE ) ) return err ; "
714,"<S2SV_StartBug> bool valid_handle ; <S2SV_EndBug> <S2SV_StartBug> valid_handle = ion_handle_validate ( client , handle ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ion_free_nolock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
715,"<S2SV_StartBug> else umount_tree ( mnt , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> UMOUNT_CONNECTED <S2SV_ModEnd> 
716,<S2SV_StartBug> s -> decode_mb = mpeg4_decode_studio_mb ; <S2SV_EndBug> ,<S2SV_ModStart> interlaced_dct = 0 ; s -> 
717,"<S2SV_StartBug> k -> get_config ( vdev , vdev -> config ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; } <S2SV_ModStart>  <S2SV_ModEnd> 
718,"<S2SV_StartBug> static void encode_frame ( vpx_codec_ctx_t * ctx , <S2SV_EndBug> <S2SV_StartBug> VpxVideoWriter * writer ) { <S2SV_EndBug> <S2SV_StartBug> while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int got_pkts = 0 ; <S2SV_ModStart> got_pkts = 1 ; <S2SV_ModStart> return got_pkts ; 
719,"<S2SV_StartBug> static double calc_frame_boost ( VP9_COMP * cpi , FIRSTPASS_STATS * this_frame , <S2SV_EndBug> <S2SV_StartBug> double this_frame_mv_in_out ) { <S2SV_EndBug> <S2SV_StartBug> if ( this_frame -> intra_error > cpi -> twopass . gf_intra_err_min ) <S2SV_EndBug> <S2SV_StartBug> frame_boost = ( IIFACTOR * this_frame -> intra_error / <S2SV_EndBug> <S2SV_StartBug> DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ; <S2SV_EndBug> <S2SV_StartBug> return MIN ( frame_boost , GF_RMAX ) ; <S2SV_EndBug> ","<S2SV_ModStart> const <S2SV_ModStart> , double max_boost <S2SV_ModStart> const double lq = vp9_convert_qindex_to_q ( cpi -> rc . avg_frame_qindex [ INTER_FRAME ] , cpi -> common . bit_depth ) ; const double boost_q_correction = MIN ( ( 0.5 + ( lq * 0.015 ) ) , 1.5 ) ; int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ; num_mbs = ( int ) MAX ( 1 , num_mbs * calculate_active_area ( cpi , this_frame ) ) ; <S2SV_ModEnd> <S2SV_ModStart> BASELINE_ERR_PER_MB * num_mbs ) <S2SV_ModEnd> <S2SV_ModStart> ; frame_boost = frame_boost * BOOST_FACTOR * boost_q_correction <S2SV_ModEnd> <S2SV_ModStart> max_boost * boost_q_correction <S2SV_ModEnd> "
720,"<S2SV_StartBug> static void __update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , const nfs4_stateid * deleg_stateid , int open_flags ) <S2SV_EndBug> <S2SV_StartBug> nfs_set_open_stateid_locked ( state , open_stateid , open_flags ) ; <S2SV_EndBug> <S2SV_StartBug> update_open_stateflags ( state , open_flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> 
721,"<S2SV_StartBug> ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( input <= 0.0 || output <= 0.0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Gamma<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>positive"" ) ; RETURN_FALSE ; } "
722,"<S2SV_StartBug> q = ( const uint8_t * ) ( const void * ) <S2SV_EndBug> <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ; <S2SV_EndBug> <S2SV_StartBug> DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , <S2SV_EndBug> <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <S2SV_ModStart> ofs <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> i , <S2SV_ModEnd> <S2SV_ModStart> offs <S2SV_ModEnd> "
723,"<S2SV_StartBug> char linebuf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> if ( fgets ( linebuf , L_BUF_SIZE , fp ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> sscanf ( linebuf , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%s<S2SV_blank><S2SV_blank>------"" , selname ) ; <S2SV_EndBug> ","<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%200s<S2SV_blank><S2SV_blank>------"" <S2SV_ModEnd> "
724,<S2SV_StartBug> struct net_device * dev = vif -> dev ; <S2SV_EndBug> <S2SV_StartBug> if ( netif_carrier_ok ( dev ) ) { <S2SV_EndBug> <S2SV_StartBug> xenvif_down ( vif ) ; <S2SV_EndBug> <S2SV_StartBug> rtnl_unlock ( ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vif -> <S2SV_ModEnd> <S2SV_ModStart> xenvif_carrier_off <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
725,"<S2SV_StartBug> static u32 __ipv6_select_ident ( struct net * net , u32 hashrnd , <S2SV_EndBug> <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( dst , hashrnd ) ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( src , hash ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const struct { struct in6_addr dst ; struct in6_addr src ; } __aligned ( SIPHASH_ALIGNMENT ) combined = { . dst = * dst , . src = * src , } ; <S2SV_ModStart> if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key , sizeof ( net -> ipv4 . ip_id_key ) <S2SV_ModEnd> <S2SV_ModStart> siphash ( & combined , sizeof ( combined ) , & net -> ipv4 . ip_id_key <S2SV_ModEnd> "
726,"<S2SV_StartBug> err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS."" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; err = - errno ; goto close_sock ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVHOPLIMIT , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVHOPLIMIT,."" "
727,<S2SV_StartBug> hlist_del ( & pin -> m_list ) ; <S2SV_EndBug> <S2SV_StartBug> hlist_del ( & pin -> s_list ) ; <S2SV_EndBug> ,<S2SV_ModStart> hlist_del_init <S2SV_ModEnd> <S2SV_ModStart> hlist_del_init <S2SV_ModEnd> 
728,"<S2SV_StartBug> MACROBLOCK * x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> int step_param ; <S2SV_EndBug> <S2SV_StartBug> int bestsme = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> speed < 8 ) <S2SV_EndBug> <S2SV_StartBug> step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , & best_ref_mv1 , ref_mv ) ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ","<S2SV_ModStart> const x = & cpi -> td . <S2SV_ModEnd> <S2SV_ModStart> const MV_SPEED_FEATURES * const mv_sf = & cpi -> sf . mv ; <S2SV_ModStart> ; int distortion ; unsigned int sse ; int cost_list [ 5 ] <S2SV_ModStart> step_param = mv_sf -> reduce_first_step_size ; step_param = MIN ( step_param , MAX_MVSEARCH_STEPS <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cond_cost_list ( cpi , cost_list ) , <S2SV_ModStart> bestsme = cpi -> find_fractional_mv_step ( x , ref_mv , & best_ref_mv1 , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , mv_sf -> subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , NULL , NULL , & distortion , & sse , NULL , 0 , 0 ) ; <S2SV_ModEnd> "
729,<S2SV_StartBug> packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ; 
730,"<S2SV_StartBug> ses = cifs_find_smb_ses ( server , volume_info -> username ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
731,<S2SV_StartBug> ybf -> uv_width = uv_width ; <S2SV_EndBug> ,<S2SV_ModStart> uv_crop_width = ( width + 1 ) / 2 ; ybf -> uv_crop_height = ( height + 1 ) / 2 ; ybf -> 
732,<S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , true "
733,<S2SV_StartBug> s += padlen + 3 ; <S2SV_EndBug> <S2SV_StartBug> ( * psig ) = s ; <S2SV_EndBug> ,"<S2SV_ModStart> ( * psig ) = s + <S2SV_ModEnd> <S2SV_ModStart> { const u_char * p ; size_t cnt_ffs = 0 ; for ( p = s + 2 ; p < s + padlen + 2 ; p ++ ) if ( * p == 0xFF ) cnt_ffs ++ ; if ( cnt_ffs != padlen ) return ""4"" ""invalid<S2SV_blank>Padding<S2SV_blank>String"" ; } <S2SV_ModEnd> "
734,<S2SV_StartBug> if ( ctx -> mb_height > 68 || <S2SV_EndBug> <S2SV_StartBug> ctx -> data_offset = 0x280 ; <S2SV_EndBug> ,"<S2SV_ModStart> ) { av_log ( ctx -> avctx , AV_LOG_ERROR , ""mb<S2SV_blank>height<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%d\\n"" , ctx -> mb_height ) ; return AVERROR_INVALIDDATA ; } ctx -> data_offset = 0x280 ; } if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
735,<S2SV_StartBug> if ( likely ( port -> exists && ! filtered ) ) <S2SV_EndBug> ,<S2SV_ModStart> serio <S2SV_ModEnd> 
736,"<S2SV_StartBug> reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ; <S2SV_EndBug> <S2SV_StartBug> band -> prec = av_malloc_array ( reslevel -> num_precincts_x * <S2SV_EndBug> ",<S2SV_ModStart> av_calloc <S2SV_ModEnd> <S2SV_ModStart> av_calloc <S2SV_ModEnd> 
737,<S2SV_StartBug> free_netdev ( net ) ; <S2SV_EndBug> ,<S2SV_ModStart> cancel_work_sync ( & dev -> kevent ) ; del_timer_sync ( & dev -> delay ) ; 
738,<S2SV_StartBug> char fstr [ MAXDATELEN + 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart> 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> 
739,<S2SV_StartBug> ctxt -> dst . type = OP_REG ; <S2SV_EndBug> <S2SV_StartBug> ctxt -> dst . bytes = ctxt -> op_bytes ; <S2SV_EndBug> ,"<S2SV_ModStart> int rc ; unsigned long eip ; rc = emulate_pop ( ctxt , & eip , <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; return assign_eip_near ( ctxt , eip <S2SV_ModEnd> "
740,<S2SV_StartBug> if ( calldata -> arg . open_flags == 0 ) <S2SV_EndBug> ,<S2SV_ModStart> fmode <S2SV_ModEnd> 
741,<S2SV_StartBug> if ( prev ) { <S2SV_EndBug> <S2SV_StartBug> int i = ( FRAG6_CB ( prev ) -> offset + prev -> len ) - offset ; <S2SV_EndBug> <S2SV_StartBug> if ( i > 0 ) { <S2SV_EndBug> <S2SV_StartBug> while ( next && FRAG6_CB ( next ) -> offset < end ) { <S2SV_EndBug> <S2SV_StartBug> err : <S2SV_EndBug> ,<S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> goto discard_fq ; if <S2SV_ModEnd> <S2SV_ModStart> goto discard_fq ; <S2SV_ModEnd> <S2SV_ModStart> discard_fq : fq_kill ( fq ) ; 
742,<S2SV_StartBug> if ( sbinfo -> max_blocks >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> buf -> f_blocks = sbinfo -> max_blocks ; <S2SV_EndBug> <S2SV_StartBug> buf -> f_bavail = buf -> f_bfree = sbinfo -> free_blocks ; <S2SV_EndBug> ,<S2SV_ModStart> spool ) { long free_pages ; spin_lock ( & sbinfo -> spool -> lock ) ; <S2SV_ModEnd> <S2SV_ModStart> spool -> max_hpages ; free_pages = sbinfo -> spool -> max_hpages - sbinfo -> spool -> used_hpages <S2SV_ModEnd> <S2SV_ModStart> free_pages ; spin_unlock ( & sbinfo -> spool -> lock ) <S2SV_ModEnd> 
743,<S2SV_StartBug> if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { <S2SV_EndBug> ,<S2SV_ModStart> strlen ( token ) > 4 && 
744,<S2SV_StartBug> ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
745,"<S2SV_StartBug> vpx_memset ( pbi -> mt_yabove_row [ 0 ] + VP8BORDERINPIXELS - 1 , 127 , yv12_fb_new -> y_width + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_yabove_row [ j ] + VP8BORDERINPIXELS - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_yleft_col [ j ] , ( unsigned char ) 129 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uleft_col [ j ] , ( unsigned char ) 129 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vleft_col [ j ] , ( unsigned char ) 129 , 8 ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
746,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> # line 2369 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 832 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> # line 2405 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 868 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2451 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 914 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2474 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 936 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2487 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 945 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2500 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 954 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2519 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 969 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2535 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 981 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2553 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 995 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2570 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1008 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2585 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1019 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> # line 1027 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2631 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1057 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2670 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1092 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2753 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1171 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2787 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1201 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2840 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1250 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2850 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1256 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2860 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1262 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2890 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1288 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2930 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1324 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2959 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1349 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2999 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1385 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3012 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1394 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3025 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1403 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3038 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1412 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3051 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1421 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3064 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1430 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3077 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1439 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3085 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1443 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3093 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1450 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3099 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1451 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3105 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1457 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3127 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1479 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3143 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1491 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3158 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1506 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3167 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1512 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3178 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1529 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3189 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1536 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3200 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1548 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3208 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1552 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3216 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1560 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3224 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1564 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3238 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1574 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3256 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1588 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3276 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1604 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3290 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1614 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3303 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1623 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3332 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1648 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3348 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1660 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3364 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1672 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3384 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1688 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3400 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1700 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3420 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1716 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3469 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1761 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3492 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1780 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3514 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1798 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3536 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1816 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3558 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1834 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3588 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1860 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3610 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1878 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3624 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1888 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3638 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1898 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3652 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1908 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3666 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1918 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3680 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1928 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3694 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1938 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3702 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 3706 ""grammar.c"" <S2SV_EndBug> ",<S2SV_ModStart> default : assert ( FALSE ) ; <S2SV_ModStart> 2371 <S2SV_ModEnd> <S2SV_ModStart> 834 <S2SV_ModEnd> <S2SV_ModStart> default : assert ( FALSE ) ; <S2SV_ModStart> 2409 <S2SV_ModEnd> <S2SV_ModStart> 872 <S2SV_ModEnd> <S2SV_ModStart> 2455 <S2SV_ModEnd> <S2SV_ModStart> 918 <S2SV_ModEnd> <S2SV_ModStart> 2478 <S2SV_ModEnd> <S2SV_ModStart> 940 <S2SV_ModEnd> <S2SV_ModStart> 2491 <S2SV_ModEnd> <S2SV_ModStart> 949 <S2SV_ModEnd> <S2SV_ModStart> 2504 <S2SV_ModEnd> <S2SV_ModStart> 958 <S2SV_ModEnd> <S2SV_ModStart> 2523 <S2SV_ModEnd> <S2SV_ModStart> 973 <S2SV_ModEnd> <S2SV_ModStart> 2539 <S2SV_ModEnd> <S2SV_ModStart> 985 <S2SV_ModEnd> <S2SV_ModStart> 2557 <S2SV_ModEnd> <S2SV_ModStart> 999 <S2SV_ModEnd> <S2SV_ModStart> 2574 <S2SV_ModEnd> <S2SV_ModStart> 1012 <S2SV_ModEnd> <S2SV_ModStart> 2589 <S2SV_ModEnd> <S2SV_ModStart> 1023 <S2SV_ModEnd> <S2SV_ModStart> YYERROR ; } # line 2603 <S2SV_ModEnd> <S2SV_ModStart> 1033 <S2SV_ModEnd> <S2SV_ModStart> 2637 <S2SV_ModEnd> <S2SV_ModStart> 1063 <S2SV_ModEnd> <S2SV_ModStart> 2676 <S2SV_ModEnd> <S2SV_ModStart> 1098 <S2SV_ModEnd> <S2SV_ModStart> 2759 <S2SV_ModEnd> <S2SV_ModStart> 1177 <S2SV_ModEnd> <S2SV_ModStart> 2793 <S2SV_ModEnd> <S2SV_ModStart> 1207 <S2SV_ModEnd> <S2SV_ModStart> 2846 <S2SV_ModEnd> <S2SV_ModStart> 1256 <S2SV_ModEnd> <S2SV_ModStart> 2856 <S2SV_ModEnd> <S2SV_ModStart> 1262 <S2SV_ModEnd> <S2SV_ModStart> 2866 <S2SV_ModEnd> <S2SV_ModStart> 1268 <S2SV_ModEnd> <S2SV_ModStart> 2896 <S2SV_ModEnd> <S2SV_ModStart> 1294 <S2SV_ModEnd> <S2SV_ModStart> 2936 <S2SV_ModEnd> <S2SV_ModStart> 1330 <S2SV_ModEnd> <S2SV_ModStart> 2965 <S2SV_ModEnd> <S2SV_ModStart> 1355 <S2SV_ModEnd> <S2SV_ModStart> 3005 <S2SV_ModEnd> <S2SV_ModStart> 1391 <S2SV_ModEnd> <S2SV_ModStart> 3018 <S2SV_ModEnd> <S2SV_ModStart> 1400 <S2SV_ModEnd> <S2SV_ModStart> 3031 <S2SV_ModEnd> <S2SV_ModStart> 1409 <S2SV_ModEnd> <S2SV_ModStart> 3044 <S2SV_ModEnd> <S2SV_ModStart> 1418 <S2SV_ModEnd> <S2SV_ModStart> 3057 <S2SV_ModEnd> <S2SV_ModStart> 1427 <S2SV_ModEnd> <S2SV_ModStart> 3070 <S2SV_ModEnd> <S2SV_ModStart> 1436 <S2SV_ModEnd> <S2SV_ModStart> 3083 <S2SV_ModEnd> <S2SV_ModStart> 1445 <S2SV_ModEnd> <S2SV_ModStart> 3091 <S2SV_ModEnd> <S2SV_ModStart> 1449 <S2SV_ModEnd> <S2SV_ModStart> 3099 <S2SV_ModEnd> <S2SV_ModStart> 1456 <S2SV_ModEnd> <S2SV_ModStart> 3105 <S2SV_ModEnd> <S2SV_ModStart> 1457 <S2SV_ModEnd> <S2SV_ModStart> 3111 <S2SV_ModEnd> <S2SV_ModStart> 1463 <S2SV_ModEnd> <S2SV_ModStart> 3133 <S2SV_ModEnd> <S2SV_ModStart> 1485 <S2SV_ModEnd> <S2SV_ModStart> 3149 <S2SV_ModEnd> <S2SV_ModStart> 1497 <S2SV_ModEnd> <S2SV_ModStart> 3164 <S2SV_ModEnd> <S2SV_ModStart> 1512 <S2SV_ModEnd> <S2SV_ModStart> 3173 <S2SV_ModEnd> <S2SV_ModStart> 1518 <S2SV_ModEnd> <S2SV_ModStart> 3184 <S2SV_ModEnd> <S2SV_ModStart> 1535 <S2SV_ModEnd> <S2SV_ModStart> 3195 <S2SV_ModEnd> <S2SV_ModStart> 1542 <S2SV_ModEnd> <S2SV_ModStart> 3206 <S2SV_ModEnd> <S2SV_ModStart> 1554 <S2SV_ModEnd> <S2SV_ModStart> 3214 <S2SV_ModEnd> <S2SV_ModStart> 1558 <S2SV_ModEnd> <S2SV_ModStart> 3222 <S2SV_ModEnd> <S2SV_ModStart> 1566 <S2SV_ModEnd> <S2SV_ModStart> 3230 <S2SV_ModEnd> <S2SV_ModStart> 1570 <S2SV_ModEnd> <S2SV_ModStart> 3244 <S2SV_ModEnd> <S2SV_ModStart> 1580 <S2SV_ModEnd> <S2SV_ModStart> 3262 <S2SV_ModEnd> <S2SV_ModStart> 1594 <S2SV_ModEnd> <S2SV_ModStart> 3282 <S2SV_ModEnd> <S2SV_ModStart> 1610 <S2SV_ModEnd> <S2SV_ModStart> 3296 <S2SV_ModEnd> <S2SV_ModStart> 1620 <S2SV_ModEnd> <S2SV_ModStart> 3309 <S2SV_ModEnd> <S2SV_ModStart> 1629 <S2SV_ModEnd> <S2SV_ModStart> 3338 <S2SV_ModEnd> <S2SV_ModStart> 1654 <S2SV_ModEnd> <S2SV_ModStart> 3354 <S2SV_ModEnd> <S2SV_ModStart> 1666 <S2SV_ModEnd> <S2SV_ModStart> 3370 <S2SV_ModEnd> <S2SV_ModStart> 1678 <S2SV_ModEnd> <S2SV_ModStart> 3390 <S2SV_ModEnd> <S2SV_ModStart> 1694 <S2SV_ModEnd> <S2SV_ModStart> 3406 <S2SV_ModEnd> <S2SV_ModStart> 1706 <S2SV_ModEnd> <S2SV_ModStart> 3426 <S2SV_ModEnd> <S2SV_ModStart> 1722 <S2SV_ModEnd> <S2SV_ModStart> 3475 <S2SV_ModEnd> <S2SV_ModStart> 1767 <S2SV_ModEnd> <S2SV_ModStart> 3498 <S2SV_ModEnd> <S2SV_ModStart> 1786 <S2SV_ModEnd> <S2SV_ModStart> 3520 <S2SV_ModEnd> <S2SV_ModStart> 1804 <S2SV_ModEnd> <S2SV_ModStart> 3542 <S2SV_ModEnd> <S2SV_ModStart> 1822 <S2SV_ModEnd> <S2SV_ModStart> 3564 <S2SV_ModEnd> <S2SV_ModStart> 1840 <S2SV_ModEnd> <S2SV_ModStart> 3594 <S2SV_ModEnd> <S2SV_ModStart> 1866 <S2SV_ModEnd> <S2SV_ModStart> 3616 <S2SV_ModEnd> <S2SV_ModStart> 1884 <S2SV_ModEnd> <S2SV_ModStart> 3630 <S2SV_ModEnd> <S2SV_ModStart> 1894 <S2SV_ModEnd> <S2SV_ModStart> 3644 <S2SV_ModEnd> <S2SV_ModStart> 1904 <S2SV_ModEnd> <S2SV_ModStart> 3658 <S2SV_ModEnd> <S2SV_ModStart> 1914 <S2SV_ModEnd> <S2SV_ModStart> 3672 <S2SV_ModEnd> <S2SV_ModStart> 1924 <S2SV_ModEnd> <S2SV_ModStart> 3686 <S2SV_ModEnd> <S2SV_ModStart> 1934 <S2SV_ModEnd> <S2SV_ModStart> 3700 <S2SV_ModEnd> <S2SV_ModStart> 1944 <S2SV_ModEnd> <S2SV_ModStart> 3708 <S2SV_ModEnd> <S2SV_ModStart> 3712 <S2SV_ModEnd> 
747,<S2SV_StartBug> if ( roishift == 0 && bgshift == 0 ) { <S2SV_EndBug> <S2SV_StartBug> mask = ( 1 << numbps ) - 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> < 0 ) { jas_eprintf ( ""warning:<S2SV_blank>forcing<S2SV_blank>negative<S2SV_blank>ROI<S2SV_blank>shift<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>"" ""(bitstream<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>corrupt)\\n"" ) ; roishift = 0 ; } if ( roishift <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> "
748,"<S2SV_StartBug> static void get_frame_stats ( vpx_codec_ctx_t * ctx , <S2SV_EndBug> <S2SV_StartBug> vpx_fixed_buf_t * stats ) { <S2SV_EndBug> <S2SV_StartBug> if ( pkt -> kind == VPX_CODEC_STATS_PKT ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int got_pkts = 0 ; <S2SV_ModStart> got_pkts = 1 ; <S2SV_ModStart> return got_pkts ; 
749,"<S2SV_StartBug> int vp9_loop_filter_worker ( void * arg1 , void * arg2 ) { <S2SV_EndBug> <S2SV_StartBug> LFWorkerData * const lf_data = ( LFWorkerData * ) arg1 ; <S2SV_EndBug> <S2SV_StartBug> ( void ) arg2 ; <S2SV_EndBug> <S2SV_StartBug> vp9_loop_filter_rows ( lf_data -> frame_buffer , lf_data -> cm , & lf_data -> xd , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , void * unused ) { <S2SV_ModEnd> <S2SV_ModStart> unused <S2SV_ModEnd> <S2SV_ModStart> lf_data -> planes <S2SV_ModEnd> "
750,"<S2SV_StartBug> ( void ) memmove ( cp , cp + 2 , strlen ( file ) - 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> cp <S2SV_ModEnd> 
751,<S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct arpt_entry ) && <S2SV_EndBug> <S2SV_StartBug> t -> verdict < 0 && unconditional ( & e -> arp ) ) || <S2SV_EndBug> ,<S2SV_ModStart> unconditional ( e <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
752,<S2SV_StartBug> int event_id = event -> attr . config ; <S2SV_EndBug> ,<S2SV_ModStart> u64 <S2SV_ModEnd> 
753,<S2SV_StartBug> alarm_timer = alarm_new ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> btif_config_devcache_cleanup ( ) ; 
754,<S2SV_StartBug> int groups_per_flex = 0 ; <S2SV_EndBug> <S2SV_StartBug> groups_per_flex = 1 << sbi -> s_log_groups_per_flex ; <S2SV_EndBug> <S2SV_StartBug> if ( groups_per_flex < 2 ) { <S2SV_EndBug> ,<S2SV_ModStart> unsigned <S2SV_ModStart> if ( sbi -> s_log_groups_per_flex < 1 || sbi -> s_log_groups_per_flex > 31 ) { sbi -> s_log_groups_per_flex = 0 ; return 1 ; } <S2SV_ModStart>  <S2SV_ModEnd> 
755,<S2SV_StartBug> for ( k = passIC + 2 ; k < passIC + 2 + passInstructions [ passIC + 1 ] ; k ++ ) <S2SV_EndBug> ,<S2SV_ModStart> ( ( <S2SV_ModStart> ) && ( kk < input -> length ) ) 
756,<S2SV_StartBug> kfree_skb ( skb ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
757,"<S2SV_StartBug> int rc ; <S2SV_EndBug> <S2SV_StartBug> struct crypto_skcipher * tfm_des ; <S2SV_EndBug> <S2SV_StartBug> tfm_des = crypto_alloc_skcipher ( ""ecb(des)"" , 0 , CRYPTO_ALG_ASYNC ) ; <S2SV_EndBug> <S2SV_StartBug> rc = PTR_ERR ( tfm_des ) ; <S2SV_EndBug> <S2SV_StartBug> goto smbhash_err ; <S2SV_EndBug> <S2SV_StartBug> sg_init_one ( & sgin , in , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> smbhash_err : <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> crypto_cipher * tfm_des <S2SV_ModEnd> <S2SV_ModStart> crypto_alloc_cipher ( ""des"" <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return PTR_ERR ( tfm_des ) ; } crypto_cipher_setkey <S2SV_ModEnd> <S2SV_ModStart> crypto_cipher_encrypt_one ( tfm_des , out , in ) ; crypto_free_cipher <S2SV_ModEnd> <S2SV_ModStart> return 0 <S2SV_ModEnd> "
758,<S2SV_StartBug> Jpeg2000Prec * prec = band -> prec + precno ; <S2SV_EndBug> <S2SV_StartBug> av_freep ( & band -> prec ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( band -> prec ) { <S2SV_ModStart> } 
759,<S2SV_StartBug> if ( ret ) { <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> ,"<S2SV_ModStart> ret = - EINVAL ; if ( ! ret && CONFIG_IS_ENABLED ( FIT_SIGNATURE ) ) { ret = fdt_check_no_at ( fit , 0 ) ; if ( ret ) <S2SV_ModStart> ret ; } } if ( ret ) { log_debug ( ""FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\n"" , ret ) ; return ret <S2SV_ModEnd> "
760,<S2SV_StartBug> if ( len > BUFSIZE + sizeof ( struct nbd_reply ) ) <S2SV_EndBug> ,<S2SV_ModStart> - <S2SV_ModEnd> 
761,<S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> lvd = ( struct logicalVolDesc * ) bh -> b_data ; <S2SV_EndBug> <S2SV_StartBug> i < sbi -> s_partitions && offset < le32_to_cpu ( lvd -> mapTableLength ) ; <S2SV_EndBug> ,"<S2SV_ModStart> unsigned int table_len ; <S2SV_ModStart> table_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) { udf_err ( sb , ""error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>"" ""Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\n"" , table_len , sb -> s_blocksize - sizeof ( * lvd ) ) ; goto out_bh ; } <S2SV_ModStart> table_len <S2SV_ModEnd> "
762,<S2SV_StartBug> int shift = VP8_BD_VALUE_SIZE - 8 - ( count + 8 ) ; <S2SV_EndBug> <S2SV_StartBug> size_t n = bytes_left > sizeof ( decrypted ) ? sizeof ( decrypted ) : bytes_left ; <S2SV_EndBug> ,"<S2SV_ModStart> CHAR_BIT <S2SV_ModEnd> <S2SV_ModStart> CHAR_BIT <S2SV_ModEnd> <S2SV_ModStart> MIN ( sizeof ( decrypted ) , bytes_left ) <S2SV_ModEnd> "
763,"<S2SV_StartBug> if ( in ) { <S2SV_EndBug> <S2SV_StartBug> dev -> out_pipe = usb_sndbulkpipe ( udev , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( out ) <S2SV_ModStart>  <S2SV_ModEnd> 
764,<S2SV_StartBug> for ( y = 0 ; y < s -> height ; ++ y ) { <S2SV_EndBug> ,<S2SV_ModStart> av_assert0 ( s -> bit_depth > 1 ) ; 
765,"<S2SV_StartBug> static void nfs4_return_incompatible_delegation ( struct inode * inode , mode_t open_flags ) <S2SV_EndBug> <S2SV_StartBug> if ( delegation == NULL || ( delegation -> type & open_flags ) == open_flags ) { <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode ) == fmode <S2SV_ModEnd> 
766,"<S2SV_StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <S2SV_EndBug> <S2SV_StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED<S2SV_blank>STRING"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED<S2SV_blank>REGEX"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED<S2SV_blank>COMMENT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( len >= 10 ) ; <S2SV_EndBug> ",<S2SV_ModStart> assert ( len > 28 ) ; <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
767,<S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> ,<S2SV_ModStart> || ! SecIsValidHandle ( handle ) 
768,<S2SV_StartBug> sax -> sax25_family = AF_NETROM ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( sax , 0 , sizeof ( sax ) ) ; "
769,"<S2SV_StartBug> static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val ) <S2SV_EndBug> ",<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> 
770,<S2SV_StartBug> return res ; <S2SV_EndBug> ,<S2SV_ModStart> cleanup : <S2SV_ModEnd> 
771,"<S2SV_StartBug> } else if ( cmd == CMD_FREE ) { <S2SV_EndBug> <S2SV_StartBug> if ( section == & service_options || section == & new_service_options ) <S2SV_EndBug> <S2SV_StartBug> s_log ( LOG_DEBUG , ""Deallocating<S2SV_blank>section<S2SV_blank>defaults"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> s_log ( LOG_NOTICE , <S2SV_EndBug> <S2SV_StartBug> if ( section == & service_options ) <S2SV_EndBug> ","<S2SV_ModStart> if ( section == & service_options ) s_log ( LOG_ERR , ""INTERNAL<S2SV_blank>ERROR:<S2SV_blank>Initializing<S2SV_blank>deployed<S2SV_blank>section<S2SV_blank>defaults"" ) ; else if ( section == & new_service_options ) s_log ( LOG_INFO , ""Initializing<S2SV_blank>inetd<S2SV_blank>mode<S2SV_blank>configuration"" ) ; else s_log ( LOG_INFO , ""Initializing<S2SV_blank>service<S2SV_blank>[%s]"" , section -> servname ) ; <S2SV_ModStart> ) s_log ( LOG_DEBUG , ""Deallocating<S2SV_blank>deployed<S2SV_blank>section<S2SV_blank>defaults"" ) ; else if ( <S2SV_ModEnd> <S2SV_ModStart> ""Deallocating<S2SV_blank>temporary<S2SV_blank>section<S2SV_blank>defaults"" <S2SV_ModEnd> <S2SV_ModStart> # if OPENSSL_VERSION_NUMBER >= 0x10100000L switch ( cmd ) { case CMD_SET_DEFAULTS : section -> security_level = - 1 ; break ; case CMD_SET_COPY : section -> security_level = new_service_options . security_level ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""securityLevel"" ) ) break ; { char * tmp_str ; int tmp_int = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str || tmp_int < 0 || tmp_int > 5 ) return ""Illegal<S2SV_blank>security<S2SV_blank>level"" ; section -> security_level = tmp_int ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%d"" , ""securityLevel"" , DEFAULT_SECURITY_LEVEL ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>set<S2SV_blank>the<S2SV_blank>security<S2SV_blank>level"" , ""securityLevel"" ) ; break ; } # endif <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> || section == & new_service_options "
772,<S2SV_StartBug> lockdep_assert_irqs_disabled ( ) ; <S2SV_EndBug> <S2SV_StartBug> preempt_count_sub ( cnt ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; if ( preempt_count ( ) == cnt ) trace_preempt_on ( CALLER_ADDR0 , get_lock_parent_ip ( ) <S2SV_ModStart> __preempt_count_sub <S2SV_ModEnd> "
773,"<S2SV_StartBug> vp8_clamp_mv ( ref_mv , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ; <S2SV_EndBug> <S2SV_StartBug> bestsad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , UINT_MAX ) <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> ",<S2SV_ModStart> ( void ) mvcost ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> else ( void ) search_param ; # <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
774,"<S2SV_StartBug> struct mount * child , * p ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_MNT_SHARED ( dest_mnt ) ) { <S2SV_EndBug> <S2SV_StartBug> err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ; <S2SV_EndBug> <S2SV_StartBug> umount_tree ( child , UMOUNT_SYNC ) ; <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> ","<S2SV_ModStart> mnt_namespace * ns = dest_mnt -> mnt_ns ; struct <S2SV_ModStart> ! parent_path ) { err = count_mounts ( ns , source_mnt <S2SV_ModEnd> <S2SV_ModStart> } if ( IS_MNT_SHARED ( dest_mnt ) ) { err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; <S2SV_ModStart> child -> mnt_parent -> mnt_ns -> pending_mounts = 0 ; <S2SV_ModStart> ns -> pending_mounts = 0 ; "
775,"<S2SV_StartBug> int contentlen = 0 ; <S2SV_EndBug> <S2SV_StartBug> contentlen = atoi ( sb ) ; <S2SV_EndBug> <S2SV_StartBug> printstr ( & pp , ""<form<S2SV_blank>method=\\""POST\\""<S2SV_blank>action=\\""/U\\""><textarea<S2SV_blank>cols=\\""80\\""<S2SV_blank>rows=\\""30\\""<S2SV_blank>name=\\""conffile\\"">"" ) ; <S2SV_EndBug> <S2SV_StartBug> int l = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! writable || fseek ( writable , 0 , 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '+' , conf . timeouts [ STRING_S ] ) ) > 0 ) { <S2SV_EndBug> <S2SV_StartBug> buf [ i ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! error ) { <S2SV_EndBug> <S2SV_StartBug> l += i ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned <S2SV_ModEnd> <S2SV_ModStart> sscanf ( sb , ""%u"" , & contentlen ) ; if ( contentlen > LINESIZE * 1024 ) contentlen = 0 <S2SV_ModEnd> <S2SV_ModStart> ""<form<S2SV_blank>method=\\""POST\\""<S2SV_blank>action=\\""/U\\""<S2SV_blank>enctype=\\""application/x-www-form-urlencoded\\""><textarea<S2SV_blank>cols=\\""80\\""<S2SV_blank>rows=\\""30\\""<S2SV_blank>name=\\""conffile\\"">"" <S2SV_ModEnd> <S2SV_ModStart> unsigned <S2SV_ModEnd> <S2SV_ModStart> ! contentlen || <S2SV_ModStart> l < contentlen && <S2SV_ModStart> ( contentlen - l ) > <S2SV_ModStart> ? LINESIZE - 1 : contentlen - l <S2SV_ModStart> if ( ! l ) { if ( i < 9 || <S2SV_ModEnd> <S2SV_ModStart> buf [ i ] = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> "
776,"<S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false "
777,"<S2SV_StartBug> static int nfs4_intent_set_file ( struct nameidata * nd , struct path * path , struct nfs4_state * state ) <S2SV_EndBug> <S2SV_StartBug> if ( nd -> intent . open . flags & FMODE_EXEC ) { <S2SV_EndBug> <S2SV_StartBug> nfs4_close_sync ( path , state , nd -> intent . open . flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> , fmode_t fmode <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode & ( FMODE_READ | FMODE_WRITE ) <S2SV_ModEnd> "
778,"<S2SV_StartBug> bpf_map_inc ( map , true ) ; <S2SV_EndBug> ",<S2SV_ModStart> map = 
779,"<S2SV_StartBug> value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> w = MinF ( 1.0f , MaxF ( 0.0f , value -> w ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> MagickMax <S2SV_ModEnd> <S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> MagickMax <S2SV_ModEnd> <S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> MagickMax <S2SV_ModEnd> <S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> MagickMax <S2SV_ModEnd> 
780,"<S2SV_StartBug> int col_offset , end_col_offset ; <S2SV_EndBug> <S2SV_StartBug> ps -> p_flags |= CO_FUTURE_BARRY_AS_BDFL ; <S2SV_EndBug> <S2SV_StartBug> if ( ( err_ret -> error = <S2SV_EndBug> <S2SV_StartBug> ps -> p_tree = NULL ; <S2SV_EndBug> ","<S2SV_ModStart> growable_int_array type_ignores ; if ( ! growable_int_array_init ( & type_ignores , 10 ) ) { err_ret -> error = E_NOMEM ; PyTokenizer_Free ( tok ) ; return NULL ; } <S2SV_ModStart> ; if ( * flags & PyPARSE_TYPE_COMMENTS ) ps -> p_flags |= PyCF_TYPE_COMMENTS <S2SV_ModStart> type == TYPE_IGNORE ) { if ( ! growable_int_array_add ( & type_ignores , tok -> lineno ) ) { err_ret -> error = E_NOMEM ; break ; } continue ; } if ( <S2SV_ModStart> ; if ( n -> n_type == file_input ) { int num ; node * ch ; size_t i ; num = NCH ( n ) ; ch = CHILD ( n , num - 1 ) ; REQ ( ch , ENDMARKER ) ; for ( i = 0 ; i < type_ignores . num_items ; i ++ ) { PyNode_AddChild ( ch , TYPE_IGNORE , NULL , type_ignores . items [ i ] , 0 , type_ignores . items [ i ] , 0 ) ; } } growable_int_array_deallocate ( & type_ignores ) "
781,"<S2SV_StartBug> vpx_memcpy ( cpi -> segmentation_map , segmentation_map , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> 
782,<S2SV_StartBug> cpi -> common . last_frame_type = cpi -> common . frame_type ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cpi -> rc . rc_2_frame = 0 ; cpi -> rc . rc_1_frame = 0 ; 
783,"<S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> <S2SV_StartBug> height ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""ImproperImageHeader"" <S2SV_ModEnd> <S2SV_ModStart> ""ImproperImageHeader"" <S2SV_ModEnd> <S2SV_ModStart> ""ImproperImageHeader"" <S2SV_ModEnd> <S2SV_ModStart> else { if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; } "
784,"<S2SV_StartBug> total_len = iov_length ( iov , nr_segs ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> void * addr ; <S2SV_EndBug> <S2SV_StartBug> size_t chars = buf -> len ; <S2SV_EndBug> <S2SV_StartBug> int error , atomic ; <S2SV_EndBug> <S2SV_StartBug> atomic = ! iov_fault_in_pages_write ( iov , chars ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct iov_iter iter ; <S2SV_ModStart> ; iov_iter_init ( & iter , iov , nr_segs , total_len , 0 ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; size_t written <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> written = copy_page_to_iter ( buf -> page , buf -> offset , chars , & iter ) ; if ( unlikely ( written < chars ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> "
785,<S2SV_StartBug> ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; <S2SV_EndBug> <S2SV_StartBug> libreswan_log ( <S2SV_EndBug> <S2SV_StartBug> return v2N_INVALID_KE_PAYLOAD ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! md -> chain [ ISAKMP_NEXT_v2KE ] ) { if ( md -> chain [ ISAKMP_NEXT_v2N ] ) { libreswan_log ( ""Received<S2SV_blank>Notify(%d):<S2SV_blank>%s"" , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type , enum_name ( & ikev2_notify_names , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type ) ) ; } libreswan_log ( ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>no<S2SV_blank>KE<S2SV_blank>payload<S2SV_blank>present"" , fromname , md -> sender_port ) ; return STF_FAIL + v2N_INVALID_KE_PAYLOAD ; } ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { libreswan_log ( <S2SV_ModEnd> <S2SV_ModStart> STF_FAIL + "
786,<S2SV_StartBug> if ( count < DJREPORT_SHORT_LENGTH - 2 ) <S2SV_EndBug> ,<S2SV_ModStart> > <S2SV_ModEnd> 
787,"<S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
788,"<S2SV_StartBug> id = idr_alloc ( & ids -> ipcs_idr , new , <S2SV_EndBug> <S2SV_StartBug> current_euid_egid ( & euid , & egid ) ; <S2SV_EndBug> ","<S2SV_ModStart> current_euid_egid ( & euid , & egid ) ; new -> cuid = new -> uid = euid ; new -> gid = new -> cgid = egid ; <S2SV_ModStart>  <S2SV_ModEnd> "
789,<S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> * tl_data_head = NULL ; 
790,"<S2SV_StartBug> spin_lock ( & desc -> iuspin ) ; <S2SV_EndBug> <S2SV_StartBug> desc -> reslength = urb -> actual_length ; <S2SV_EndBug> <S2SV_StartBug> memmove ( desc -> ubuf + desc -> length , desc -> inbuf , desc -> reslength ) ; <S2SV_EndBug> ","<S2SV_ModStart> int length = urb -> actual_length ; <S2SV_ModStart> if ( length + desc -> length > desc -> wMaxCommand ) { set_bit ( WDM_OVERFLOW , & desc -> flags ) ; } else { if ( ! test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { <S2SV_ModEnd> <S2SV_ModStart> length ) ; desc -> length += length ; <S2SV_ModStart> = length ; } } <S2SV_ModEnd> "
791,<S2SV_StartBug> goto no_match ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( cd -> flags & DETECT_CONTENT_RELATIVE_NEXT ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( det_ctx -> discontinue_matching ) <S2SV_EndBug> ,"<S2SV_ModStart> if ( ( cd -> flags & ( DETECT_CONTENT_DISTANCE | DETECT_CONTENT_WITHIN ) ) == 0 ) { det_ctx -> discontinue_matching = 1 ; } <S2SV_ModStart> smd -> is_last ) { goto match <S2SV_ModEnd> <S2SV_ModStart> SCLogDebug ( ""no<S2SV_blank>match<S2SV_blank>for<S2SV_blank>\'next<S2SV_blank>sm\'"" ) ; <S2SV_ModStart> { SCLogDebug ( ""\'next<S2SV_blank>sm\'<S2SV_blank>said<S2SV_blank>to<S2SV_blank>discontinue<S2SV_blank>this<S2SV_blank>right<S2SV_blank>now"" ) ; goto no_match ; } if ( ( cd -> flags & DETECT_CONTENT_RELATIVE_NEXT ) == 0 ) { SCLogDebug ( ""\'next<S2SV_blank>sm\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>depend<S2SV_blank>on<S2SV_blank>me,<S2SV_blank>so<S2SV_blank>we<S2SV_blank>can<S2SV_blank>give<S2SV_blank>up"" ) ; det_ctx -> discontinue_matching = 1 ; goto no_match ; } SCLogDebug ( ""\'next<S2SV_blank>sm\'<S2SV_blank>depends<S2SV_blank>on<S2SV_blank>me<S2SV_blank>%p,<S2SV_blank>lets<S2SV_blank>see<S2SV_blank>what<S2SV_blank>we<S2SV_blank>can<S2SV_blank>do<S2SV_blank>(flags<S2SV_blank>%u)"" , cd , cd -> flags ) <S2SV_ModEnd> "
792,<S2SV_StartBug> usleep ( 10000 ) ; <S2SV_EndBug> ,<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
793,<S2SV_StartBug> struct trusted_key_payload * p = key -> payload . data [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> struct trusted_key_payload * new_p ; <S2SV_EndBug> ,"<S2SV_ModStart> p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY ; <S2SV_ModStart>  <S2SV_ModEnd> "
794,"<S2SV_StartBug> return ( xdr_opaque ( xdrs , * objp , size ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! <S2SV_ModEnd> <S2SV_ModStart> return FALSE ; if ( ( * objp ) [ size - 1 ] != '\\0' ) return FALSE ; if ( memchr ( * objp , '\\0' , size - 1 ) != NULL ) return FALSE ; return TRUE "
795,<S2SV_StartBug> FreeStmt ( ( ParseCommon * ) & append ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
796,"<S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> <S2SV_StartBug> pr_warn ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> 
797,<S2SV_StartBug> for ( i = 0 ; i < name_len ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> int name_len ; <S2SV_EndBug> ,"<S2SV_ModStart> avio_skip ( pb , name_len <S2SV_ModEnd> <S2SV_ModStart> ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA "
798,"<S2SV_StartBug> int len ; <S2SV_EndBug> <S2SV_StartBug> imapc -> mailbox = curl_easy_unescape ( data , path , 0 , & len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! imapc -> mailbox ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return Curl_urldecode <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , NULL , TRUE ) <S2SV_ModEnd> "
799,<S2SV_StartBug> if ( ! npages ) { <S2SV_EndBug> ,<S2SV_ModStart> || base_gfn != old . base_gfn 
800,<S2SV_StartBug> return FALSE ; <S2SV_EndBug> ,<S2SV_ModStart> transport -> credssp = NULL ; 
801,<S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) { <S2SV_EndBug> ,<S2SV_ModStart> limit || ( unsigned char * ) e + e -> next_offset > 
802,"<S2SV_StartBug> sParse . rc = SQLITE_OK ; <S2SV_EndBug> <S2SV_StartBug> sqlite3SelectPrep ( & sParse , sParse . pNewTable -> pSelect , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> pSelect -> selFlags &= ~ SF_View ; <S2SV_ModStart>  <S2SV_ModEnd> 
803,<S2SV_StartBug> pthread_mutex_lock ( & lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> btif_config_write ( <S2SV_ModEnd> 
804,<S2SV_StartBug> gctx = group_leader -> ctx ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & gctx -> mutex ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & gctx -> mutex ) ; <S2SV_EndBug> ,"<S2SV_ModStart> __perf_event_ctx_lock_double ( group_leader , ctx <S2SV_ModEnd> <S2SV_ModStart> if ( ! ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) { if ( gctx != ctx ) { err = - EINVAL ; goto err_locked ; } else { perf_event_ctx_unlock ( group_leader , gctx ) ; move_group = 0 ; } } <S2SV_ModStart> perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> <S2SV_ModStart> perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> "
805,<S2SV_StartBug> EVP_MD_CTX_init ( & ctx ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; return - 1 ; } "
806,"<S2SV_StartBug> # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) <S2SV_EndBug> <S2SV_StartBug> ""<S2SV_blank>HDRI"" <S2SV_EndBug> <S2SV_StartBug> ; <S2SV_EndBug> ","<S2SV_ModStart> MAGICKCORE_WINDOWS_SUPPORT ) && defined ( _DEBUG ) ""<S2SV_blank>Debug"" # endif # if defined ( MAGICKCORE_CIPHER_SUPPORT ) ""<S2SV_blank>Cipher"" <S2SV_ModEnd> <S2SV_ModStart> # endif # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) ""<S2SV_blank>Modules"" <S2SV_ModStart> # if defined ( ZERO_CONFIGURATION_SUPPORT ) ""<S2SV_blank>Zero-configuration"" # endif "
807,"<S2SV_StartBug> vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ; <S2SV_EndBug> <S2SV_StartBug> vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned long cr4 ; <S2SV_ModStart> HOST_CR3 , read_cr3 ( ) ) ; cr4 = read_cr4 ( ) ; vmcs_writel ( HOST_CR4 , cr4 ) ; vmx -> host_state . vmcs_host_cr4 = cr4 <S2SV_ModEnd> "
808,"<S2SV_StartBug> int64_t * time_stamp , int64_t * time_end_stamp , <S2SV_EndBug> <S2SV_StartBug> vp9_ppflags_t * flags ) { <S2SV_EndBug> <S2SV_StartBug> int ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( pbi -> common . show_frame == 0 ) <S2SV_EndBug> <S2SV_StartBug> * time_stamp = pbi -> last_time_stamp ; <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_VP9_POSTPROC <S2SV_EndBug> <S2SV_StartBug> ret = vp9_post_proc_frame ( & pbi -> common , sd , flags ) ; <S2SV_EndBug> <S2SV_StartBug> * sd = * pbi -> common . frame_to_show ; <S2SV_EndBug> <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> VP9_COMMON * const cm = & pbi -> common ; <S2SV_ModStart> # if ! CONFIG_VP9_POSTPROC ( void ) * flags ; # endif <S2SV_ModStart> pbi -> ready_for_new_data = 1 ; if ( ! cm -> show_frame <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! cm -> show_existing_frame ) { <S2SV_ModStart> cm <S2SV_ModEnd> <S2SV_ModStart> } else { * sd = * cm -> frame_to_show ; ret = 0 ; } <S2SV_ModStart> cm -> frame_to_show <S2SV_ModEnd> <S2SV_ModStart> vpx_clear_system_state <S2SV_ModEnd> 
809,"<S2SV_StartBug> dev_net_set ( dev , net ) ; <S2SV_EndBug> ","<S2SV_ModStart> err = dev_get_valid_name ( net , dev , name ) ; if ( err ) goto err_free_dev ; "
810,"<S2SV_StartBug> isoclns_print ( ndo , p , length , length ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
811,"<S2SV_StartBug> DPRINTF ( ""Data<S2SV_blank>ready<S2SV_blank>tag=0x%x<S2SV_blank>len=%zd\\n"" , r -> req . tag , r -> iov . iov_len ) ; <S2SV_EndBug> <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> <S2SV_StartBug> scsi_req_data ( & r -> req , r -> iov . iov_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> qiov . size <S2SV_ModEnd> <S2SV_ModStart> qiov . size <S2SV_ModEnd> <S2SV_ModStart> qiov . size <S2SV_ModEnd> 
812,<S2SV_StartBug> ( cm -> frame_flags & FRAMEFLAGS_KEY ) || <S2SV_EndBug> <S2SV_StartBug> ( cpi -> oxcf . auto_key && test_for_kf_one_pass ( cpi ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> rc -> frames_to_key = cpi -> key_frame_frequency ; <S2SV_EndBug> <S2SV_StartBug> rc -> source_alt_ref_active = 0 ; <S2SV_EndBug> <S2SV_StartBug> target = calc_pframe_target_size_one_pass_cbr ( cpi ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> rc -> frames_till_gf_update_due = INT_MAX ; <S2SV_EndBug> ,<S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> oxcf . key_freq <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } if ( rc -> frames_till_gf_update_due == 0 ) { if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_golden_update ( cpi ) ; else rc -> baseline_gf_interval = ( rc -> min_gf_interval + rc -> max_gf_interval ) / 2 ; rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; if ( rc -> frames_till_gf_update_due > rc -> frames_to_key ) rc -> frames_till_gf_update_due = rc -> frames_to_key ; cpi -> refresh_golden_frame = 1 ; rc -> gfu_boost = DEFAULT_GF_BOOST ; } if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_update_parameters ( cpi ) ; if ( cm -> frame_type == KEY_FRAME ) target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; else target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC ) cpi -> resize_pending = vp9_resize_one_pass_cbr ( cpi ) ; else cpi -> resize_pending = 0 <S2SV_ModEnd> 
813,"<S2SV_StartBug> u8 * data , * output ; <S2SV_EndBug> <S2SV_StartBug> u32 pck_size , prev_pck_size ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> data = ( char * ) gf_filter_pck_get_data ( pck , & pck_size ) ; <S2SV_EndBug> ",<S2SV_ModStart> = NULL <S2SV_ModStart> = 0 <S2SV_ModStart> else { <S2SV_ModStart> } 
814,<S2SV_StartBug> if ( radiotap_header -> it_version ) <S2SV_EndBug> <S2SV_StartBug> ( unsigned long ) iterator -> _rtheader > <S2SV_EndBug> ,<S2SV_ModStart> max_length < sizeof ( struct ieee80211_radiotap_header ) ) return - EINVAL ; if ( <S2SV_ModStart> + sizeof ( uint32_t ) 
815,"<S2SV_StartBug> opt = flowlabel ? flowlabel -> opt : np -> opt ; <S2SV_EndBug> <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , opt , & final ) ; <S2SV_EndBug> ",<S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) <S2SV_ModStart> ) ; rcu_read_unlock ( 
816,"<S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> pkt_len = parse_cosine_rec_hdr ( phdr , line , err , err_info ) ; <S2SV_EndBug> <S2SV_StartBug> return parse_cosine_hex_dump ( wth -> random_fh , phdr , pkt_len , buf , err , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return parse_cosine_packet <S2SV_ModEnd> <S2SV_ModStart> buf , line <S2SV_ModEnd> "
817,<S2SV_StartBug> if ( class == BPF_ALU || class == BPF_ALU64 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ,<S2SV_ModStart> env -> insn_aux_data [ insn_idx ] . seen = true ; <S2SV_ModStart> env -> insn_aux_data [ insn_idx ] . seen = true ; 
818,<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> int rowstep ; <S2SV_EndBug> ,<S2SV_ModStart> jas_matind_t i ; jas_matind_t <S2SV_ModEnd> <S2SV_ModStart> jas_matind_t <S2SV_ModEnd> 
819,"<S2SV_StartBug> Huff_transmit ( & huff , ch , seq ) ; <S2SV_EndBug> ","<S2SV_ModStart> , size << 3 "
820,"<S2SV_StartBug> ( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ; <S2SV_EndBug> ",<S2SV_ModStart> TIFFGetFieldDefaulted <S2SV_ModEnd> 
821,"<S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> if ( length != 0x000a ) <S2SV_EndBug> <S2SV_StartBug> if ( ReadRectangle ( image , & frame ) == MagickFalse ) <S2SV_EndBug> <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> if ( length == 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( length > 154 ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <S2SV_EndBug> ","<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length <S2SV_ModStart> length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( <S2SV_ModStart> ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length <S2SV_ModStart> GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length > <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; "
822,"<S2SV_StartBug> Assign ( asdl_seq * targets , expr_ty value , int lineno , int col_offset , int <S2SV_EndBug> <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug> ","<S2SV_ModStart> string type_comment , <S2SV_ModStart> v . Assign . type_comment = type_comment ; p -> "
823,<S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; } 
824,"<S2SV_StartBug> u64 nr , int nmi , <S2SV_EndBug> <S2SV_StartBug> perf_swevent_event ( event , nr , nmi , data , regs ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
825,"<S2SV_StartBug> uint32_t _WM_SetupMidiEvent ( struct _mdi * mdi , uint8_t * event_data , uint8_t running_event ) { <S2SV_EndBug> <S2SV_StartBug> if ( event_data [ 0 ] >= 0x80 ) { <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> <S2SV_StartBug> midi_setup_sequenceno ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( ( event_data [ 0 ] == 0x20 ) && ( event_data [ 1 ] == 0x01 ) ) { <S2SV_EndBug> <S2SV_StartBug> midi_setup_portprefix ( mdi , event_data [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> _WM_midi_setup_endoftrack ( mdi ) ; <S2SV_EndBug> <S2SV_StartBug> _WM_midi_setup_tempo ( mdi , ( ( event_data [ 2 ] << 16 ) + ( event_data [ 3 ] << 8 ) + event_data [ 4 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( ( event_data [ 0 ] == 0x54 ) && ( event_data [ 1 ] == 0x05 ) ) { <S2SV_EndBug> <S2SV_StartBug> midi_setup_timesignature ( mdi , ( ( event_data [ 2 ] << 24 ) + ( event_data [ 3 ] << 16 ) + ( event_data [ 4 ] << 8 ) + event_data [ 5 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> midi_setup_keysignature ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! sysex_len ) break ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> uint32_t siz , <S2SV_ModStart> ! siz ) goto shortbuf ; if ( <S2SV_ModStart> ; if ( -- siz == 0 ) goto shortbuf <S2SV_ModStart> if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 4 ) goto shortbuf ; <S2SV_ModStart> -- siz && <S2SV_ModStart> if ( ! siz ) break ; <S2SV_ModStart> siz -- ; <S2SV_ModStart> if ( ! siz ) goto shortbuf ; <S2SV_ModStart> if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> -- siz && <S2SV_ModStart> if ( ! siz ) break ; <S2SV_ModStart> siz -- ; <S2SV_ModStart> if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break <S2SV_ModStart> -- siz && <S2SV_ModStart> if ( ! siz ) break ; <S2SV_ModStart> siz -- ; <S2SV_ModStart> if ( ! siz ) goto shortbuf ; <S2SV_ModStart> if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> -- siz && <S2SV_ModStart> if ( ! siz ) break ; <S2SV_ModStart> siz -- ; <S2SV_ModStart> if ( ! siz ) goto shortbuf ; <S2SV_ModStart> if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> -- siz && <S2SV_ModStart> if ( ! siz ) break ; <S2SV_ModStart> siz -- ; <S2SV_ModStart> if ( ! siz ) goto shortbuf ; <S2SV_ModStart> if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> -- siz && <S2SV_ModStart> if ( ! siz ) break ; <S2SV_ModStart> siz -- ; <S2SV_ModStart> if ( ! siz ) goto shortbuf ; <S2SV_ModStart> if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> -- siz && <S2SV_ModStart> if ( ! siz ) break ; <S2SV_ModStart> siz -- ; <S2SV_ModStart> if ( ! siz ) goto shortbuf ; <S2SV_ModStart> if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> if ( siz < 3 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 3 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 5 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 7 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 6 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 4 ) goto shortbuf ; <S2SV_ModStart> -- siz && <S2SV_ModStart> if ( ! siz ) break ; <S2SV_ModStart> siz -- ; <S2SV_ModStart> if ( ! siz ) goto shortbuf ; <S2SV_ModStart> if ( -- siz < tmp_length ) goto shortbuf ; <S2SV_ModStart> if ( ! siz ) break ; <S2SV_ModStart> siz -- ; <S2SV_ModStart> if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < sysex_len ) goto shortbuf ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> shortbuf : _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(input<S2SV_blank>too<S2SV_blank>short)"" , 0 ) ; return 0 ; "
826,"<S2SV_StartBug> sprintf ( outfilename , ""%s_%05d.j2k"" , argv [ 2 ] , snum ) ; <S2SV_EndBug> ","<S2SV_ModStart> int num = snprintf <S2SV_ModEnd> <S2SV_ModStart> sizeof ( outfilename ) , <S2SV_ModStart> if ( num >= sizeof ( outfilename ) ) { fprintf ( stderr , ""maximum<S2SV_blank>length<S2SV_blank>of<S2SV_blank>output<S2SV_blank>prefix<S2SV_blank>exceeded\\n"" ) ; return 1 ; } "
827,"<S2SV_StartBug> memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
828,"<S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_iter ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( ifs , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_is_async ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> ","<S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> <S2SV_ModStart> { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> <S2SV_ModStart> { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_ifs , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> <S2SV_ModStart> { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""is_async\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
829,"<S2SV_StartBug> hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( hlen < 0 ) { err = hlen ; goto fail ; } 
830,"<S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> struct buf_2d backup_yv12 [ MAX_MB_PLANE ] = { { 0 } } ; <S2SV_EndBug> <S2SV_StartBug> int further_steps , step_param ; <S2SV_EndBug> <S2SV_StartBug> MV ref_mv = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> int tmp_row_max = x -> mv_row_max ; <S2SV_EndBug> <S2SV_StartBug> pred_mv [ 0 ] = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> pred_mv [ 1 ] = mbmi -> ref_mvs [ ref ] [ 1 ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> pred_mv [ 2 ] = x -> pred_mv [ ref ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . auto_mv_step_size && cpi -> common . show_frame ) { <S2SV_EndBug> <S2SV_StartBug> step_param = ( vp9_init_search_range ( cpi , x -> max_mv_context [ ref ] ) + <S2SV_EndBug> <S2SV_StartBug> cpi -> mv_step_param ) >> 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . adaptive_motion_search && bsize < BLOCK_64X64 && <S2SV_EndBug> <S2SV_StartBug> int boffset = 2 * ( b_width_log2 ( BLOCK_64X64 ) - MIN ( b_height_log2 ( bsize ) , <S2SV_EndBug> <S2SV_StartBug> int bhl = b_height_log2_lookup [ bsize ] ; <S2SV_EndBug> <S2SV_StartBug> for ( i = LAST_FRAME ; i <= ALTREF_FRAME && cpi -> common . show_frame ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> x -> pred_mv [ ref ] . as_int = 0 ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> further_steps = ( cpi -> sf . max_step_search_steps - 1 ) - step_param ; <S2SV_EndBug> <S2SV_StartBug> bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , <S2SV_EndBug> <S2SV_StartBug> & cpi -> fn_ptr [ bsize ] , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> sf . search_method == FAST_HEX ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> sf . search_method == HEX ) { <S2SV_EndBug> <S2SV_StartBug> & dis , & x -> pred_sse [ ref ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . adaptive_motion_search && cpi -> common . show_frame ) <S2SV_EndBug> <S2SV_StartBug> x -> pred_mv [ ref ] . as_int = tmp_mv -> as_int ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> , 0 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> x -> mbmi_ext <S2SV_ModEnd> <S2SV_ModStart> ; int cost_list [ 5 ] <S2SV_ModStart> x -> mbmi_ext <S2SV_ModEnd> <S2SV_ModStart> x -> mbmi_ext <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mv . auto_mv_step_size && cm -> <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> / 2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> b_width_log2_lookup [ BLOCK_64X64 ] <S2SV_ModEnd> <S2SV_ModStart> b_height_log2_lookup [ bsize ] , b_width_log2_lookup [ bsize ] <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ) { int i ; <S2SV_ModStart> cm -> <S2SV_ModEnd> <S2SV_ModStart> row = 0 ; x -> pred_mv [ ref ] . col <S2SV_ModEnd> <S2SV_ModStart> ++ i <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> bestsme = vp9_full_pixel_search ( cpi , x , bsize , & mvp_full , step_param , sadpb , cond_cost_list ( cpi , cost_list ) , & ref_mv , & tmp_mv -> as_mv , INT_MAX , 1 ) ; x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max <S2SV_ModEnd> <S2SV_ModStart> { int dis ; cpi -> find_fractional_mv_step <S2SV_ModEnd> <S2SV_ModStart> cm -> allow_high_precision_mv , x -> errorperbit , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mv . subpel_force_stop , <S2SV_ModEnd> <S2SV_ModStart> mv . subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , x -> nmvjointcost , x -> mvcost , & dis <S2SV_ModEnd> <S2SV_ModStart> , NULL , 0 , 0 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> as_mv <S2SV_ModEnd> "
831,<S2SV_StartBug> u16 offset = sizeof ( struct ipv6hdr ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( * * nexthdr ) { <S2SV_EndBug> <S2SV_StartBug> offset += ipv6_optlen ( exthdr ) ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned int <S2SV_ModEnd> <S2SV_ModStart> unsigned int len ; <S2SV_ModStart> len = ipv6_optlen ( exthdr ) ; if ( len + offset >= IPV6_MAXPLEN ) return - EINVAL ; offset += len <S2SV_ModEnd> 
832,"<S2SV_StartBug> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , <S2SV_EndBug> <S2SV_StartBug> CRYPTO_MAX_ALG_NAME ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""larval"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> strncpy ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strncpy ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strncpy ( <S2SV_ModEnd> <S2SV_ModStart> sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 <S2SV_ModEnd> <S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> ""larval"" , sizeof ( rl . type ) <S2SV_ModEnd> "
833,"<S2SV_StartBug> if ( ( fp = pcap_open_live ( source , <S2SV_EndBug> ","<S2SV_ModStart> is_url ( source ) ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , ""Source<S2SV_blank>string<S2SV_blank>refers<S2SV_blank>to<S2SV_blank>a<S2SV_blank>remote<S2SV_blank>device"" ) ; goto error ; } if ( "
834,"<S2SV_StartBug> imap_quote_string ( dest , dlen , buf ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false "
835,"<S2SV_StartBug> u16 selector , int seg , u8 cpl , bool in_task_switch ) <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> ","<S2SV_ModStart> , struct desc_struct * desc <S2SV_ModStart> if ( desc ) * desc = seg_desc ; "
836,"<S2SV_StartBug> struct blkif_response resp ; <S2SV_EndBug> <S2SV_StartBug> resp . id = id ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) , <S2SV_EndBug> <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) , <S2SV_EndBug> <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> * <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> resp = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> resp = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> resp = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> resp -> id = id ; resp -> operation = op ; resp -> status = st ; 
837,"<S2SV_StartBug> fprintf ( dump , ""%s"" , sdp ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( sdp && size ) 
838,<S2SV_StartBug> if ( read != entry . uncompressed_filesize ) { <S2SV_EndBug> ,<S2SV_ModStart> || read <= 8 
839,<S2SV_StartBug> r1 . event = SNDRV_TIMER_EVENT_RESOLUTION ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & r1 , 0 , sizeof ( r1 ) ) ; "
840,"<S2SV_StartBug> ret = block_write_begin ( file , mapping , pos , len , flags , pagep , fsdata , <S2SV_EndBug> <S2SV_StartBug> ext4_get_block ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ext4_should_dioread_nolock ( inode ) ) <S2SV_ModStart> ext4_get_block_write ) ; else ret = block_write_begin ( file , mapping , pos , len , flags , pagep , fsdata , "
841,"<S2SV_StartBug> int16_t vp9_ac_quant ( int qindex , int delta ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , vpx_bit_depth_t bit_depth ) { # if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) { case VPX_BITS_8 : <S2SV_ModEnd> <S2SV_ModStart> case VPX_BITS_10 : return ac_qlookup_10 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; case VPX_BITS_12 : return ac_qlookup_12 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12"" ) ; return - 1 ; } # else ( void ) bit_depth ; return ac_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ; # endif "
842,"<S2SV_StartBug> add_mibfile ( const char * tmpstr , const char * d_name , FILE * ip ) <S2SV_EndBug> <S2SV_StartBug> if ( ip ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
843,<S2SV_StartBug> if ( wp -> listening_socket != STDIN_FILENO ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
844,"<S2SV_StartBug> int i , retval ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ",<S2SV_ModStart> test_parser_param ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
845,<S2SV_StartBug> assert ( c != NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( c -> rbytes >= c -> rsize ) { <S2SV_EndBug> ,<S2SV_ModStart> int num_allocs = 0 ; <S2SV_ModStart> if ( num_allocs == 4 ) { return gotdata ; } ++ num_allocs ; 
846,"<S2SV_StartBug> Rd_WP_DWORD ( image , & Rec . RecordLength ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; if ( Rec . RecordLength > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" "
847,"<S2SV_StartBug> int len , err = - ENOBUFS ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( nlk -> cb_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> module_put ( cb -> module ) ; <S2SV_EndBug> <S2SV_StartBug> consume_skb ( cb -> skb ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct module * module ; <S2SV_ModStart> module = cb -> module ; skb = cb -> skb ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
848,"<S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> ","<S2SV_ModStart> | CVAR_PROTECTED <S2SV_ModStart> if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; } "
849,<S2SV_StartBug> if ( envs [ h_env -> envc ] . env == HTML_DL_COMPACT ) { <S2SV_EndBug> ,<S2SV_ModStart> h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if ( 
850,"<S2SV_StartBug> if ( * p ) { <S2SV_EndBug> <S2SV_StartBug> * q = 0 ; <S2SV_EndBug> <S2SV_StartBug> cmd = p + 1 ; <S2SV_EndBug> <S2SV_StartBug> * p = \'""\' ; <S2SV_EndBug> ",<S2SV_ModStart> char op0 = 0 ; <S2SV_ModStart> op0 = * q ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> op0 <S2SV_ModEnd> 
851,<S2SV_StartBug> return AUTH_FOUND ; <S2SV_EndBug> ,<S2SV_ModStart> fclose ( opwfile ) ; 
852,<S2SV_StartBug> return parser_flags ; <S2SV_EndBug> ,<S2SV_ModStart> if ( flags -> cf_flags & PyCF_TYPE_COMMENTS ) parser_flags |= PyPARSE_TYPE_COMMENTS ; 
853,"<S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK ( bp -> bp_flags ) ; 
854,"<S2SV_StartBug> if ( cid <= 0 ) <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) <S2SV_EndBug> <S2SV_StartBug> return dctx -> remaining ; <S2SV_EndBug> ",<S2SV_ModStart> int remaining ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> 
855,<S2SV_StartBug> blockcnt = ( ( len + pos ) + blocksize - 1 ) >> <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 1 || len == 0xffffffff ) { return - 1 ; } 
856,"<S2SV_StartBug> int expected_count = 1 + extra_count ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> radix_tree_replace_slot ( pslot , newpage ) ; <S2SV_EndBug> <S2SV_StartBug> __dec_zone_page_state ( page , NR_FILE_PAGES ) ; <S2SV_EndBug> <S2SV_StartBug> __inc_zone_page_state ( newpage , NR_FILE_PAGES ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! PageSwapCache ( page ) && PageSwapBacked ( page ) ) { <S2SV_EndBug> ","<S2SV_ModStart> struct zone * oldzone , * newzone ; int dirty ; <S2SV_ModStart> oldzone = page_zone ( page ) ; newzone = page_zone ( newpage ) ; <S2SV_ModStart> dirty = PageDirty ( page ) ; if ( dirty ) { ClearPageDirty ( page ) ; SetPageDirty ( newpage ) ; } <S2SV_ModStart> spin_unlock ( & mapping -> tree_lock ) ; if ( newzone != oldzone ) { __dec_zone_state ( oldzone <S2SV_ModEnd> <S2SV_ModStart> __inc_zone_state ( newzone <S2SV_ModEnd> <S2SV_ModStart> PageSwapBacked ( page ) && <S2SV_ModStart> ) { __dec_zone_state ( oldzone , NR_SHMEM ) ; __inc_zone_state ( newzone , NR_SHMEM ) ; } if ( dirty && mapping_cap_account_dirty ( mapping ) ) { __dec_zone_state ( oldzone , NR_FILE_DIRTY ) ; __inc_zone_state ( newzone , NR_FILE_DIRTY ) ; } } local_irq_enable ( <S2SV_ModEnd> "
857,"<S2SV_StartBug> guint32 off = offset ; <S2SV_EndBug> <S2SV_StartBug> level , offset ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , last_off <S2SV_ModStart> ; last_off = off <S2SV_ModStart> if ( off < last_off ) { THROW ( ReportedBoundsError ) ; } last_off = off ; "
858,"<S2SV_StartBug> Stream_Read_UINT32 ( s , scopeCount ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( Stream_GetRemainingLength ( s ) / sizeof ( LICENSE_BLOB ) < scopeCount ) return FALSE 
859,<S2SV_StartBug> count = be32_to_cpu ( aclp -> acl_cnt ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED 
860,<S2SV_StartBug> # ifdef KEY_DEBUGGING <S2SV_EndBug> ,<S2SV_ModStart> if ( flags & KEY_ALLOC_UID_KEYRING ) key -> flags |= 1 << KEY_FLAG_UID_KEYRING ; 
861,<S2SV_StartBug> if ( ! send && ! SSL_USE_ETM ( ssl ) && <S2SV_EndBug> <S2SV_StartBug> if ( ! send && ! SSL_USE_ETM ( ssl ) && FIPS_mode ( ) ) <S2SV_EndBug> ,<S2SV_ModStart> SSL_READ_ETM <S2SV_ModEnd> <S2SV_ModStart> SSL_READ_ETM <S2SV_ModEnd> 
862,<S2SV_StartBug> mark_files_ro ( sb ) ; <S2SV_EndBug> ,<S2SV_ModStart> sb -> s_readonly_remount = 1 ; smp_wmb ( <S2SV_ModEnd> 
863,<S2SV_StartBug> g_object_unref ( subdir ) ; <S2SV_EndBug> <S2SV_StartBug> dir = GSF_INFILE_TAR ( subdir ) ; <S2SV_EndBug> ,<S2SV_ModStart> dir = GSF_IS_INFILE_TAR ( subdir ) ? GSF_INFILE_TAR ( subdir ) : dir ; <S2SV_ModStart>  <S2SV_ModEnd> 
864,"<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> struct stat st ; <S2SV_EndBug> <S2SV_StartBug> if ( lstat ( filename , & st ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> file = fopen ( filename , ""a"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> struct stat st ; FILE * file = NULL ; int fd = - 1 ; <S2SV_ModStart> fd = open ( filename , O_WRONLY | O_APPEND | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY ) ; if ( fd >= 0 && ( fstat ( fd <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> fdopen ( fd <S2SV_ModEnd> <S2SV_ModStart> cfg -> is_custom_debug_file = 1 ; file = NULL ; fd = - 1 ; <S2SV_ModEnd> <S2SV_ModStart> if ( fd != - 1 ) close ( fd ) ; if ( file != NULL ) fclose ( file ) ; "
865,<S2SV_StartBug> int buflen = bin -> buf -> length ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <S2SV_ModStart> - <S2SV_ModEnd> 
866,<S2SV_StartBug> gdFree ( tmp_im ) ; <S2SV_EndBug> ,<S2SV_ModStart> gdImageDestroy <S2SV_ModEnd> 
867,<S2SV_StartBug> if ( SCTP_CID_SHUTDOWN_ACK == ch -> type ) <S2SV_EndBug> <S2SV_StartBug> ch = ( sctp_chunkhdr_t * ) ch_end ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( SCTP_CID_SHUTDOWN_ACK == ch -> type ) ootb_shut_ack = 1 ; if ( SCTP_CID_ABORT == ch -> type ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; if ( SCTP_CID_COOKIE_ACK == ch -> type ) ootb_cookie_ack = 1 ; if ( SCTP_CID_ERROR == ch -> type ) { sctp_walk_errors ( err , ch ) { if ( SCTP_ERROR_STALE_COOKIE == err -> cause ) { ootb_cookie_ack = 1 ; break ; } } } "
868,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
869,"<S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> <S2SV_StartBug> l2cap_send_cmd ( conn , cmd -> ident , L2CAP_CONF_RSP , len , rsp ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> { struct l2cap_disconn_req req ; req . dcid = cpu_to_le16 ( l2cap_pi ( sk ) -> dcid ) ; req . scid = cpu_to_le16 ( l2cap_pi ( sk ) -> scid ) ; l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & req ) ; <S2SV_ModStart> } <S2SV_ModStart> ; l2cap_pi ( sk ) -> num_conf_rsp ++ <S2SV_ModStart> l2cap_pi ( sk ) -> num_conf_req ++ ; "
870,"<S2SV_StartBug> struct inode * inode , int regard_xa ) <S2SV_EndBug> <S2SV_StartBug> int cnt , sig ; <S2SV_EndBug> <S2SV_StartBug> if ( regard_xa ) { <S2SV_EndBug> <S2SV_StartBug> ISOFS_I ( inode ) -> i_first_extent = <S2SV_EndBug> <S2SV_StartBug> isofs_iget ( inode -> i_sb , <S2SV_EndBug> <S2SV_StartBug> ISOFS_I ( inode ) -> i_first_extent , <S2SV_EndBug> ","<S2SV_ModStart> flags <S2SV_ModEnd> <S2SV_ModStart> ; unsigned int reloc_block <S2SV_ModStart> flags & RR_REGARD_XA <S2SV_ModEnd> <S2SV_ModStart> if ( flags & RR_RELOC_DE ) { printk ( KERN_ERR ""ISOFS:<S2SV_blank>Recursive<S2SV_blank>directory<S2SV_blank>relocation<S2SV_blank>"" ""is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; goto eio ; } reloc_block = isonum_733 ( rr -> u . CL . location ) ; if ( reloc_block == <S2SV_ModStart> i_iget5_block && ISOFS_I ( inode ) -> i_iget5_offset == 0 ) { printk ( KERN_ERR ""ISOFS:<S2SV_blank>Directory<S2SV_blank>relocation<S2SV_blank>points<S2SV_blank>to<S2SV_blank>"" ""itself\\n"" ) ; goto eio ; } ISOFS_I ( inode ) -> i_first_extent = reloc_block <S2SV_ModEnd> <S2SV_ModStart> isofs_iget_reloc <S2SV_ModEnd> <S2SV_ModStart> reloc_block , <S2SV_ModEnd> "
871,"<S2SV_StartBug> DEBUG ( ""snmp<S2SV_blank>plugin:<S2SV_blank>all<S2SV_blank>variables<S2SV_blank>have<S2SV_blank>left<S2SV_blank>their<S2SV_blank>subtree"" ) ; <S2SV_EndBug> <S2SV_StartBug> req = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( req != NULL ) <S2SV_EndBug> ",<S2SV_ModStart> ) ; snmp_free_pdu ( req <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
872,"<S2SV_StartBug> int res ; <S2SV_EndBug> <S2SV_StartBug> const void * data ; <S2SV_EndBug> <S2SV_StartBug> u_int32_t vendor ; <S2SV_EndBug> <S2SV_StartBug> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""s"" , & data , & len ) == FAILURE ) { <S2SV_EndBug> <S2SV_StartBug> res = rad_get_vendor_attr ( & vendor , & data , ( size_t * ) & len ) ; <S2SV_EndBug> <S2SV_StartBug> add_assoc_long ( return_value , ""attr"" , res ) ; <S2SV_EndBug> <S2SV_StartBug> add_assoc_stringl ( return_value , ""data"" , ( char * ) data , len , 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , * raw <S2SV_ModStart> ; unsigned char type ; size_t data_len <S2SV_ModStart> raw <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> type , & data , & data_len , raw , len ) <S2SV_ModEnd> <S2SV_ModStart> type <S2SV_ModEnd> <S2SV_ModStart> data_len <S2SV_ModEnd> "
873,<S2SV_StartBug> if ( ! encoding && c -> palette_size && c -> bpp <= 8 ) { <S2SV_EndBug> ,<S2SV_ModStart> && c -> format != CHUNKY 
874,"<S2SV_StartBug> if ( strchr ( "",<S2SV_blank>\\t"" , param -> value [ i + n ] ) ) <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> != NULL ) { break ; } <S2SV_ModEnd> 
875,<S2SV_StartBug> if ( par -> color_primaries != AVCOL_PRI_UNSPECIFIED ) <S2SV_EndBug> ,"<S2SV_ModStart> print_primaries ( w , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
876,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> return num ; <S2SV_EndBug> ,<S2SV_ModStart> fpl -> user = NULL ; <S2SV_ModStart> if ( ! fpl -> user ) fpl -> user = get_uid ( current_user ( ) ) ; 
877,"<S2SV_StartBug> static void show_object ( struct object * object , struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , void * data ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> 
878,<S2SV_StartBug> assert ( c != NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( c -> rbytes >= c -> rsize ) { <S2SV_EndBug> ,<S2SV_ModStart> int num_allocs = 0 ; <S2SV_ModStart> if ( num_allocs == 4 ) { return gotdata ; } ++ num_allocs ; 
879,<S2SV_StartBug> draw_info -> geometry = AcquireString ( geometry ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ( void ) CloneString ( & <S2SV_ModStart> , <S2SV_ModEnd> "
880,<S2SV_StartBug> __be32 * pdata = ( __be32 * ) data ; <S2SV_EndBug> ,<S2SV_ModStart> pdata ; if ( datalen != 4 ) return - EINVAL ; 
881,<S2SV_StartBug> if ( dctx -> bytes ) { <S2SV_EndBug> ,<S2SV_ModStart> ! ctx -> gf128 ) return - ENOKEY ; if ( 
882,<S2SV_StartBug> int i ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! config -> sample_rate ) { strcpy ( wpc -> error_message , ""sample<S2SV_blank>rate<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>zero!"" ) ; return FALSE ; } "
883,<S2SV_StartBug> 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> false <S2SV_ModEnd> 
884,"<S2SV_StartBug> uint32_t len ; <S2SV_EndBug> <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> <S2SV_StartBug> len = r -> sector_count * 512 ; <S2SV_EndBug> <S2SV_StartBug> DPRINTF ( ""Write<S2SV_blank>complete<S2SV_blank>tag=0x%x<S2SV_blank>more=%d\\n"" , r -> req . tag , len ) ; <S2SV_EndBug> <S2SV_StartBug> scsi_req_data ( & r -> req , len ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> qiov . size <S2SV_ModEnd> <S2SV_ModStart> scsi_init_iovec ( r ) <S2SV_ModEnd> <S2SV_ModStart> r -> qiov . size <S2SV_ModEnd> <S2SV_ModStart> r -> qiov . size <S2SV_ModEnd> 
885,"<S2SV_StartBug> static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * image ) <S2SV_EndBug> <S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> GetMagickPixelPacket ( image , & pixels [ i ] [ j ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> images ) { const Image * next ; <S2SV_ModEnd> <S2SV_ModStart> columns , <S2SV_ModStart> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> images <S2SV_ModEnd> "
886,"<S2SV_StartBug> vpx_memset ( oci -> ref_frame_sign_bias , 0 , sizeof ( oci -> ref_frame_sign_bias ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> 
887,<S2SV_StartBug> if ( ! ext_dp -> icmp_length ) { <S2SV_EndBug> <S2SV_StartBug> vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; <S2SV_EndBug> <S2SV_StartBug> hlen -= 4 ; <S2SV_EndBug> ,"<S2SV_ModStart> && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) <S2SV_ModStart> if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) { <S2SV_ModStart> } "
888,"<S2SV_StartBug> u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & value -> tv_nsec ) ; <S2SV_EndBug> ","<S2SV_ModStart> u32 rem ; value -> tv_sec = div_u64_rem ( <S2SV_ModEnd> <S2SV_ModStart> , NSEC_PER_SEC , & rem ) <S2SV_ModStart> tv_nsec = rem <S2SV_ModEnd> "
889,"<S2SV_StartBug> duplexMode = enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_PHYDPX ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 , MACON2_DEFER | <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MABBIPG , 0x15 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 , MACON2_DEFER | <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MABBIPG , 0x12 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ENC624J600_ESTAT ) & ENC624J600_ESTAT_PHYDPX <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT | ENC624J600_MACON2_FULDPX <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MABBIPG , ENC624J600_MABBIPG_BBIPG_DEFAULT_FD <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MABBIPG , ENC624J600_MABBIPG_BBIPG_DEFAULT_HD <S2SV_ModEnd> "
890,"<S2SV_StartBug> adts_dmx_check_pid ( filter , ctx ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ctx -> hdr . frame_size < ctx -> hdr . hdr_size ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_PARSER , ( ""[ADTSDmx]<S2SV_blank>Corrupted<S2SV_blank>ADTS<S2SV_blank>frame<S2SV_blank>header,<S2SV_blank>resyncing\\n"" ) ) ; ctx -> nb_frames = 0 ; goto drop_byte ; } "
891,"<S2SV_StartBug> void vp9_rc_update_rate_correction_factors ( VP9_COMP * cpi , int damp_var ) { <S2SV_EndBug> <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> <S2SV_StartBug> rate_correction_factor ) ; <S2SV_EndBug> <S2SV_StartBug> if ( projected_size_based_on_q > 0 ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> rc . is_src_frame_alt_ref ) return ; vpx_clear_system_state ( ) ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cpi -> common . seg . enabled ) { projected_size_based_on_q = vp9_cyclic_refresh_estimate_bits_at_q ( cpi , rate_correction_factor ) ; } else { projected_size_based_on_q = vp9_estimate_bits_at_q ( cpi -> common . <S2SV_ModEnd> <S2SV_ModStart> , cm -> bit_depth ) ; } <S2SV_ModEnd> <S2SV_ModStart> FRAME_OVERHEAD_BITS ) correction_factor = ( int ) ( ( 100 * ( int64_t ) cpi -> rc . projected_frame_size ) / projected_size_based_on_q ) ; adjustment_limit = 0.25 + 0.5 * MIN ( 1 , fabs ( log10 ( 0.01 * correction_factor ) ) ) ; cpi -> rc . q_2_frame = cpi -> rc . q_1_frame ; cpi -> rc . q_1_frame = cm -> base_qindex ; cpi -> rc . rc_2_frame = cpi -> rc . rc_1_frame ; if ( correction_factor > 110 ) cpi -> rc . rc_1_frame = - 1 ; else if ( correction_factor < 90 ) cpi -> rc . rc_1_frame = 1 ; else cpi -> rc . rc_1_frame = 0 ; <S2SV_ModEnd> "
892,"<S2SV_StartBug> if ( isparam ( ""value"" ) && * getparam ( ""value"" ) ) <S2SV_EndBug> <S2SV_StartBug> rsputs ( loc ( getparam ( ""value"" ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> { strencode2 ( str , getparam ( ""value"" ) , sizeof ( str ) ) ; <S2SV_ModStart> str ) ) ; } <S2SV_ModEnd> "
893,"<S2SV_StartBug> for ( k = 0 ; k < bufsize - 1 ; k ++ ) <S2SV_EndBug> <S2SV_StartBug> { if ( psf -> headindex < psf -> headend ) <S2SV_EndBug> <S2SV_StartBug> { psf -> headend += psf_fread ( psf -> header + psf -> headend , 1 , 1 , psf ) ; <S2SV_EndBug> <S2SV_StartBug> ptr [ k ] = psf -> header [ psf -> headindex ] ; <S2SV_EndBug> ","<S2SV_ModStart> if ( psf -> header . indx + bufsize >= psf -> header . len && psf_bump_header_allocation ( psf , bufsize ) ) return 0 ; <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . end ) { ptr [ k ] = psf -> header . ptr [ psf -> header . indx ] ; psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . end <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . end <S2SV_ModEnd> <S2SV_ModStart> . ptr [ psf -> header . indx ] ; psf -> header . indx = psf -> header . end <S2SV_ModEnd> "
894,"<S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , delim ) ; <S2SV_EndBug> <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false <S2SV_ModStart> , false <S2SV_ModStart> , false <S2SV_ModStart> , false <S2SV_ModStart> , false "
895,"<S2SV_StartBug> int jas_matrix_resize ( jas_matrix_t * matrix , int numrows , int numcols ) <S2SV_EndBug> <S2SV_StartBug> int size ; <S2SV_EndBug> ","<S2SV_ModStart> jas_matind_t numrows , jas_matind_t <S2SV_ModEnd> <S2SV_ModStart> jas_matind_t size ; jas_matind_t <S2SV_ModEnd> "
896,<S2SV_StartBug> if ( info -> stagemasks [ ( int ) partword [ j ] [ i ] ] & ( 1 << s ) ) { <S2SV_EndBug> ,<S2SV_ModStart> int idx = ( int ) partword [ j ] [ i ] ; if ( idx < info -> partitions && <S2SV_ModEnd> <S2SV_ModStart> idx <S2SV_ModEnd> 
897,"<S2SV_StartBug> const struct oe_sockaddr * src_addr , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
898,"<S2SV_StartBug> err = ops -> cee_peer_getpg ( netdev , & pg ) ; <S2SV_EndBug> <S2SV_StartBug> struct cee_pfc pfc ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( & pg , 0 , sizeof ( pg ) ) ; <S2SV_ModStart> ; memset ( & pfc , 0 , sizeof ( pfc ) ) "
899,<S2SV_StartBug> if ( vcpu -> mmio_cur_fragment == vcpu -> mmio_nr_fragments ) { <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> 
900,"<S2SV_StartBug> ret = get_tag ( * der , len , tag_out , & contents , & clen , & remainder , & rlen ) ; <S2SV_EndBug> ","<S2SV_ModStart> , 0 "
901,<S2SV_StartBug> free ( name ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! strcmp ( key , ""path"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_PATH , ""disallowed<S2SV_blank>submodule<S2SV_blank>path:<S2SV_blank>%s"" , value ) ; "
902,<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! tty ) return 
903,<S2SV_StartBug> unsigned char buffer [ 3 ] ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ,"<S2SV_ModStart> * buffer ; int ret ; buffer = kmalloc ( 3 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> kfree ( buffer ) ; "
904,"<S2SV_StartBug> HANDLE Token ; <S2SV_EndBug> <S2SV_StartBug> if ( LogonUser ( username , ""."" , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & Token ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> pcap_fmt_errmsg_for_win32_err ( errbuf , PCAP_ERRBUF_SIZE , <S2SV_EndBug> <S2SV_StartBug> GetLastError ( ) , ""LogonUser()<S2SV_blank>failed"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ImpersonateLoggedOnUser ( Token ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> # else <S2SV_EndBug> <S2SV_StartBug> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect"" ) ; <S2SV_EndBug> <S2SV_StartBug> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect"" ) ; <S2SV_EndBug> <S2SV_StartBug> crypt_password = crypt ( password , user_password ) ; <S2SV_EndBug> <S2SV_StartBug> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" ) ; <S2SV_EndBug> <S2SV_StartBug> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect"" ) ; <S2SV_EndBug> <S2SV_StartBug> pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , <S2SV_EndBug> <S2SV_StartBug> errno , ""setuid"" ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> ","<S2SV_ModStart> DWORD error ; <S2SV_ModStart> char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; <S2SV_ModStart> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" ) ; error = GetLastError ( ) ; if ( error != ERROR_LOGON_FAILURE ) { pcap_fmt_errmsg_for_win32_err ( errmsgbuf , PCAP_ERRBUF_SIZE , error , ""LogonUser()<S2SV_blank>failed"" ) ; rpcapd_log ( LOGPRIO_ERROR , ""%s"" , errmsgbuf ) ; } return - 1 ; } if ( ImpersonateLoggedOnUser ( Token ) == 0 ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" ) ; pcap_fmt_errmsg_for_win32_err ( errmsgbuf <S2SV_ModEnd> <S2SV_ModStart> ""ImpersonateLoggedOnUser()<S2SV_blank>failed"" ) ; rpcapd_log ( LOGPRIO_ERROR , ""%s"" , errmsgbuf ) ; CloseHandle <S2SV_ModEnd> <S2SV_ModStart> ; return - 1 ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int error ; <S2SV_ModStart> ""Authentication<S2SV_blank>failed"" <S2SV_ModEnd> <S2SV_ModStart> ""Authentication<S2SV_blank>failed"" <S2SV_ModEnd> <S2SV_ModStart> errno = 0 ; <S2SV_ModStart> error = errno ; pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" ) ; if ( error == 0 ) { rpcapd_log ( LOGPRIO_ERROR , ""crypt()<S2SV_blank>failed"" ) ; } else { rpcapd_log ( LOGPRIO_ERROR , ""crypt()<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( error ) ) ; } <S2SV_ModEnd> <S2SV_ModStart> ""Authentication<S2SV_blank>failed"" <S2SV_ModEnd> <S2SV_ModStart> error = errno ; <S2SV_ModStart> error <S2SV_ModEnd> <S2SV_ModStart> rpcapd_log ( LOGPRIO_ERROR , ""setuid()<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( error ) ) ; "
905,"<S2SV_StartBug> _Unpickler_MemoGet ( UnpicklerObject * self , Py_ssize_t idx ) <S2SV_EndBug> <S2SV_StartBug> if ( idx < 0 || idx >= self -> memo_size ) <S2SV_EndBug> ",<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
906,<S2SV_StartBug> sas_port_delete ( port -> port ) ; <S2SV_EndBug> ,<S2SV_ModStart> sas_destruct_devices ( port ) ; 
907,"<S2SV_StartBug> ast_for_with_stmt ( struct compiling * c , const node * n , int is_async ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> return AsyncWith ( items , body , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; <S2SV_EndBug> ","<S2SV_ModStart> n0 , bool <S2SV_ModEnd> <S2SV_ModStart> const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; <S2SV_ModStart> n0 ) , n0 <S2SV_ModEnd> "
908,"<S2SV_StartBug> struct request * rq = tags -> rqs [ tag ] ; <S2SV_EndBug> <S2SV_StartBug> struct blk_flush_queue * fq = blk_get_flush_queue ( rq -> q , rq -> mq_ctx ) ; <S2SV_EndBug> ",<S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
909,<S2SV_StartBug> if ( f -> map & ( 1 << rec ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> rec >= f -> num ) { ldm_error ( ""REC<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>NUM<S2SV_blank>value<S2SV_blank>(%d)"" , rec , f -> num ) ; return false ; } if ( "
910,<S2SV_StartBug> goto retry_rebind ; <S2SV_EndBug> ,<S2SV_ModStart> switch ( task -> tk_status ) { case - EACCES : case - EIO : goto die ; default : <S2SV_ModStart> } 
911,<S2SV_StartBug> if ( request -> ssids [ i ] . ssid_len > <S2SV_EndBug> <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug> ,<S2SV_ModStart> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
912,<S2SV_StartBug> if ( iter > CIPSO_V4_TAG_MAXCNT ) <S2SV_EndBug> <S2SV_StartBug> if ( iter < CIPSO_V4_TAG_MAXCNT ) <S2SV_EndBug> <S2SV_StartBug> doi_def -> tags [ iter ] = CIPSO_V4_TAG_INVALID ; <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> <S2SV_ModStart> while <S2SV_ModEnd> <S2SV_ModStart> ++ 
913,"<S2SV_StartBug> int is_async ; <S2SV_EndBug> <S2SV_StartBug> if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { <S2SV_EndBug> <S2SV_StartBug> if ( NCH ( n ) == ( 5 + is_async ) ) { <S2SV_EndBug> <S2SV_StartBug> n = CHILD ( n , 4 + is_async ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> count_comp_for : <S2SV_ModEnd> <S2SV_ModStart> NCH ( n ) == 2 ) { REQ ( CHILD ( n , 0 ) , NAME ) ; assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , ""async"" ) == 0 ) ; n = CHILD ( n , 1 ) ; } else if ( NCH ( n ) == 1 ) { n = CHILD ( n , 0 ) ; } else { goto error <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> error : "
914,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>n<S2SV_blank>len=%d"" , ntohs ( e . len ) - 4 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( 2 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( 1 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ike_show_somedata ( ndo , ( const u_char * ) ( const uint8_t * ) ( ext + 1 ) , ep ) ) <S2SV_EndBug> <S2SV_StartBug> return ( const u_char * ) ext + ntohs ( e . len ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank>n<S2SV_blank>len=%u"" <S2SV_ModEnd> <S2SV_ModStart> ntohs ( e . len ) > 4 ) { if ( <S2SV_ModEnd> <S2SV_ModStart> > 2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> > 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } "
915,"<S2SV_StartBug> futex_wait_queue_me ( hb , & q , to ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( match_futex ( & q . key , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; } "
916,<S2SV_StartBug> last_source = source_mnt ; <S2SV_EndBug> ,<S2SV_ModStart> first_source = source_mnt ; 
917,"<S2SV_StartBug> struct dw2102_state * state = d -> priv ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x02 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0x51 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0x0 ; <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data , 1 , state -> data <S2SV_ModEnd> <S2SV_ModStart> ) ; mutex_unlock ( & d -> data_mutex "
918,"<S2SV_StartBug> u8 * gb_cur , * version_tlv , version , version_length ; <S2SV_EndBug> <S2SV_StartBug> gb_len += version_length ; <S2SV_EndBug> <S2SV_StartBug> gb_len += lto_length ; <S2SV_EndBug> <S2SV_StartBug> gb_len += wks_length ; <S2SV_EndBug> <S2SV_StartBug> & miux_length ) ; <S2SV_EndBug> ","<S2SV_ModStart> version , version_length ; u8 lto_length , wks_length , miux_length ; u8 * version_tlv = NULL , * lto_tlv = NULL , * wks_tlv = NULL , * miux_tlv = NULL <S2SV_ModEnd> <S2SV_ModStart> if ( ! version_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> if ( ! lto_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> if ( ! wks_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> if ( ! miux_tlv ) { ret = - ENOMEM ; goto out ; } "
919,<S2SV_StartBug> * state = CCS_VALUE ; <S2SV_EndBug> ,<S2SV_ModStart> if ( * state != CCS_START ) 
920,"<S2SV_StartBug> int pkt_len , pktnum , hr , min , sec , csec ; <S2SV_EndBug> <S2SV_StartBug> num_items_scanned = sscanf ( line + 64 , ""LEN=%9d"" , & pkt_len ) ; <S2SV_EndBug> <S2SV_StartBug> phdr -> rec_type = REC_TYPE_PACKET ; <S2SV_EndBug> <S2SV_StartBug> ws_buffer_assure_space ( buf , TOSHIBA_MAX_PACKET_LEN ) ; <S2SV_EndBug> ","<S2SV_ModStart> guint pkt_len ; int <S2SV_ModEnd> <S2SV_ModStart> ""LEN=%9u"" <S2SV_ModEnd> <S2SV_ModStart> if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( ""toshiba:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u"" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } <S2SV_ModStart> pkt_len <S2SV_ModEnd> "
921,"<S2SV_StartBug> void * p = au -> reply_buf ; <S2SV_EndBug> <S2SV_StartBug> ret = ceph_x_decrypt ( & th -> session_key , & p , end , & reply , sizeof ( reply ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> preply = & reply ; void * <S2SV_ModStart> preply <S2SV_ModEnd> 
922,<S2SV_StartBug> if ( length > 0 ) <S2SV_EndBug> ,<S2SV_ModStart> 1 <S2SV_ModEnd> 
923,"<S2SV_StartBug> isoclns_print ( ndo , p , length , length ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
924,"<S2SV_StartBug> atomic_inc ( & ( ( struct bpf_prog * ) raw ) -> aux -> refcnt ) ; <S2SV_EndBug> <S2SV_StartBug> bpf_map_inc ( raw , true ) ; <S2SV_EndBug> ",<S2SV_ModStart> raw = bpf_prog_inc ( raw <S2SV_ModEnd> <S2SV_ModStart> raw = 
925,"<S2SV_StartBug> static void predict_and_reconstruct_intra_block ( int plane , int block , <S2SV_EndBug> <S2SV_StartBug> TX_SIZE tx_size , void * arg ) { <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * const mi = xd -> mi [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE mode = ( plane == 0 ) ? get_y_mode ( mi , block ) <S2SV_EndBug> <S2SV_StartBug> txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & x , & y ) ; <S2SV_EndBug> <S2SV_StartBug> dst = & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * x ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_predict_intra_block ( xd , block >> ( tx_size << 1 ) , <S2SV_EndBug> <S2SV_StartBug> if ( ! mi -> mbmi . skip ) { <S2SV_EndBug> <S2SV_StartBug> const int eob = vp9_decode_block_tokens ( cm , xd , plane , block , <S2SV_EndBug> ","<S2SV_ModStart> MACROBLOCKD * const xd , vpx_reader * r , MB_MODE_INFO * const mbmi , int plane , int row , int col <S2SV_ModEnd> <S2SV_ModStart> ) { <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> mbmi -> mode : mbmi -> uv_mode ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> row <S2SV_ModEnd> <S2SV_ModStart> col ] ; if ( mbmi -> sb_type < BLOCK_8X8 ) if ( plane == 0 ) mode = xd -> mi [ 0 ] -> bmi [ ( row <S2SV_ModEnd> <S2SV_ModStart> + col ] . as_mode ; vp9_predict_intra_block ( xd , pd -> n4_wl , tx_size , mode , dst , pd -> dst . stride , dst , pd -> dst . stride , col , row <S2SV_ModEnd> <S2SV_ModStart> mbmi -> <S2SV_ModEnd> <S2SV_ModStart> TX_TYPE tx_type = ( plane || xd -> lossless ) ? DCT_DCT : intra_mode_to_tx_type_lookup [ mode ] ; const scan_order * sc = ( plane || xd -> lossless ) ? & vp9_default_scan_orders [ tx_size ] : & vp9_scan_orders [ tx_size ] [ tx_type ] ; const <S2SV_ModStart> xd , plane , sc , col , row , tx_size , r , mbmi -> segment_id ) ; inverse_transform_block_intra ( xd , plane , tx_type , tx_size , dst , pd -> dst . stride , <S2SV_ModEnd> "
926,"<S2SV_StartBug> impeg2d_next_code ( ps_dec , SEQUENCE_HEADER_CODE ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = 0 ; ps_dec -> u2_header_done = 0 ; ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_reinit_max_height ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_reinit_max_width ; } 
927,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> [ plane ] && in -> linesize 
928,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> ",<S2SV_ModStart> int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> rc = <S2SV_ModStart> rc <S2SV_ModEnd> 
929,<S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> * data ; data = kmalloc ( 2 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> goto out ; <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> goto out ; } ret = snprintf ( buf , PAGE_SIZE , ""%s\\n"" , macro_mode ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> "
930,"<S2SV_StartBug> cntsize ( in , & sumlen , & nnode ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; if ( TSQUERY_TOO_BIG ( nnode , sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) "
931,<S2SV_StartBug> line = picture -> data [ plane ] + y * picture -> linesize [ plane ] ; <S2SV_EndBug> <S2SV_StartBug> dst = line + x * pixelsize + compno * ! planar ; <S2SV_EndBug> <S2SV_StartBug> linel = ( uint16_t * ) picture -> data [ plane ] + y * ( picture -> linesize [ plane ] >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> dst = linel + ( x * pixelsize + compno * ! planar ) ; <S2SV_EndBug> ,<S2SV_ModStart> / s -> cdy [ compno ] <S2SV_ModStart> / s -> cdx [ compno ] <S2SV_ModStart> / s -> cdy [ compno ] <S2SV_ModStart> / s -> cdx [ compno ] 
932,"<S2SV_StartBug> void oz_hcd_get_desc_cnf ( void * hport , u8 req_id , int status , const u8 * desc , <S2SV_EndBug> <S2SV_StartBug> int length , int offset , int total_size ) <S2SV_EndBug> <S2SV_StartBug> int copy_len ; <S2SV_EndBug> <S2SV_StartBug> int required_size = urb -> transfer_buffer_length ; <S2SV_EndBug> ","<S2SV_ModStart> u8 <S2SV_ModEnd> <S2SV_ModStart> u8 length , u16 offset , u16 <S2SV_ModEnd> <S2SV_ModStart> unsigned <S2SV_ModStart> unsigned "
933,"<S2SV_StartBug> int len = OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> BIO_write ( bio , obj_txt , len ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> BIO_printf <S2SV_ModEnd> <S2SV_ModStart> ""%s\\n"" , obj_txt <S2SV_ModEnd> "
934,<S2SV_StartBug> if ( idx >= ARRAY_SIZE ( hwsim_world_regdom_custom ) ) <S2SV_EndBug> <S2SV_StartBug> param . regd = hwsim_world_regdom_custom [ idx ] ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree ( hwname ) ; <S2SV_ModStart> } 
935,"<S2SV_StartBug> BLOCK_SIZE bsize , int use_rd ) { <S2SV_EndBug> <S2SV_StartBug> ( mbmi -> mv [ 0 ] . as_int != 0 && <S2SV_EndBug> <S2SV_StartBug> cr -> projected_dist_sb > cr -> thresh_dist_sb ) || <S2SV_EndBug> <S2SV_StartBug> ! is_inter_block ( mbmi ) ) <S2SV_EndBug> <S2SV_StartBug> if ( bsize < cr -> min_block_size || <S2SV_EndBug> <S2SV_StartBug> mbmi -> mv [ 0 ] . as_int != 0 || <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ","<S2SV_ModStart> int64_t rate , int64_t dist , int bsize ) { MV mv = <S2SV_ModEnd> <S2SV_ModStart> as_mv ; if ( dist <S2SV_ModEnd> <S2SV_ModStart> && ( mv . row > cr -> motion_thresh || mv . row < - cr -> motion_thresh || mv . col > cr -> motion_thresh || mv . col < - cr -> motion_thresh <S2SV_ModEnd> <S2SV_ModStart> ) return CR_SEGMENT_ID_BASE ; else <S2SV_ModEnd> <S2SV_ModStart> >= BLOCK_16X16 && rate <S2SV_ModStart> thresh_rate_sb && is_inter_block ( mbmi ) && <S2SV_ModEnd> <S2SV_ModStart> == 0 && cr -> rate_boost_fac > 10 ) return CR_SEGMENT_ID_BOOST2 <S2SV_ModEnd> <S2SV_ModStart> CR_SEGMENT_ID_BOOST1 ; } <S2SV_ModEnd> "
936,"<S2SV_StartBug> int ntlm_read_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> ",<S2SV_ModStart> static 
937,"<S2SV_StartBug> int offs , int count , int pmgr_flag ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( & ( ( char * ) & sysex ) [ offs ] , & ( addr ) [ offs ] , hdr_size - offs ) ) <S2SV_EndBug> <S2SV_StartBug> if ( count < sysex . len ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sysex , addr , hdr_size <S2SV_ModEnd> <S2SV_ModStart> ( unsigned ) count < ( unsigned ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
938,"<S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ret ) { <S2SV_EndBug> <S2SV_StartBug> uwq = list_first_entry ( & fork_event , <S2SV_EndBug> <S2SV_StartBug> userfaultfd_event_complete ( ctx , uwq ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug> ",<S2SV_ModStart> userfaultfd_ctx_get ( fork_nctx ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> userfaultfd_ctx_put ( fork_nctx ) ; <S2SV_ModStart> if ( likely ( ! ret ) ) <S2SV_ModStart> else { if ( ret ) userfaultfd_ctx_put ( fork_nctx ) ; } spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_ModEnd> 
939,"<S2SV_StartBug> static int decode_coefs ( VP9_COMMON * cm , const MACROBLOCKD * xd , PLANE_TYPE type , <S2SV_EndBug> <S2SV_StartBug> int16_t * dqcoeff , TX_SIZE tx_size , const int16_t * dq , <S2SV_EndBug> <S2SV_StartBug> vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> const FRAME_CONTEXT * const fc = & cm -> fc ; <S2SV_EndBug> <S2SV_StartBug> const vp9_prob ( * coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] = <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * prob ; <S2SV_EndBug> <S2SV_StartBug> unsigned int ( * coef_counts ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES + 1 ] = <S2SV_EndBug> <S2SV_StartBug> unsigned int ( * eob_branch_count ) [ COEFF_CONTEXTS ] = <S2SV_EndBug> <S2SV_StartBug> uint8_t token_cache [ 32 * 32 ] ; <S2SV_EndBug> <S2SV_StartBug> int val ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_read ( r , prob [ EOB_CONTEXT_NODE ] ) ) { <S2SV_EndBug> <S2SV_StartBug> while ( ! vp9_read ( r , prob [ ZERO_CONTEXT_NODE ] ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_read ( r , prob [ ONE_CONTEXT_NODE ] ) ) { <S2SV_EndBug> <S2SV_StartBug> WRITE_COEF_CONTINUE ( 1 , ONE_TOKEN ) ; <S2SV_EndBug> <S2SV_StartBug> prob = vp9_pareto8_full [ prob [ PIVOT_NODE ] - 1 ] ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_reader * r ) { FRAME_COUNTS * counts = xd -> counts ; <S2SV_ModEnd> <S2SV_ModStart> xd -> fc <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> ; unsigned int ( * eob_branch_count ) [ COEFF_CONTEXTS ] ; uint8_t token_cache [ 32 * 32 ] ; const uint8_t * band_translate = get_band_translate ( tx_size ) ; const int dq_shift = ( tx_size == TX_32X32 ) ; int v , token ; int16_t dqv = dq [ 0 ] ; const uint8_t * cat1_prob ; const uint8_t * cat2_prob ; const uint8_t * cat3_prob ; const uint8_t * cat4_prob ; const uint8_t * cat5_prob ; const uint8_t * cat6_prob ; if ( counts ) { coef_counts = <S2SV_ModEnd> <S2SV_ModStart> eob_branch_count = <S2SV_ModEnd> <S2SV_ModStart> } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> bd > VPX_BITS_8 ) { if ( xd -> bd == VPX_BITS_10 ) { cat1_prob = vp9_cat1_prob_high10 ; cat2_prob = vp9_cat2_prob_high10 ; cat3_prob = vp9_cat3_prob_high10 ; cat4_prob = vp9_cat4_prob_high10 ; cat5_prob = vp9_cat5_prob_high10 ; cat6_prob = vp9_cat6_prob_high10 ; } else { cat1_prob = vp9_cat1_prob_high12 ; cat2_prob = vp9_cat2_prob_high12 ; cat3_prob = vp9_cat3_prob_high12 ; cat4_prob = vp9_cat4_prob_high12 ; cat5_prob = vp9_cat5_prob_high12 ; cat6_prob = vp9_cat6_prob_high12 ; } } else { cat1_prob = vp9_cat1_prob ; cat2_prob = vp9_cat2_prob ; cat3_prob = vp9_cat3_prob ; cat4_prob = vp9_cat4_prob ; cat5_prob = vp9_cat5_prob ; cat6_prob = vp9_cat6_prob ; } # else cat1_prob = vp9_cat1_prob ; cat2_prob = vp9_cat2_prob ; cat3_prob = vp9_cat3_prob ; cat4_prob = vp9_cat4_prob ; cat5_prob = vp9_cat5_prob ; cat6_prob = vp9_cat6_prob ; # endif <S2SV_ModEnd> <S2SV_ModStart> = - 1 <S2SV_ModStart> counts <S2SV_ModEnd> <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> token = ONE_TOKEN ; val = 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart> token = vpx_read_tree ( r , vp9_coef_con_tree , <S2SV_ModEnd> <S2SV_ModStart> ) ; switch ( token ) { case TWO_TOKEN : case THREE_TOKEN : case FOUR_TOKEN : val = token ; break ; case CATEGORY1_TOKEN : val = CAT1_MIN_VAL + read_coeff ( cat1_prob , 1 , r ) ; break ; case CATEGORY2_TOKEN : val = CAT2_MIN_VAL + read_coeff ( cat2_prob , 2 , r ) ; break ; case CATEGORY3_TOKEN : val = CAT3_MIN_VAL + read_coeff ( cat3_prob , 3 , r ) ; break ; case CATEGORY4_TOKEN : val = CAT4_MIN_VAL + read_coeff ( cat4_prob , 4 , r ) ; break ; case CATEGORY5_TOKEN : val = CAT5_MIN_VAL + read_coeff ( cat5_prob , 5 , r ) ; break ; case CATEGORY6_TOKEN : # if CONFIG_VP9_HIGHBITDEPTH switch ( xd -> bd ) { case VPX_BITS_8 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 14 , r ) ; break ; case VPX_BITS_10 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 16 , r ) ; break ; case VPX_BITS_12 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 18 , r ) ; break ; default : assert ( 0 ) ; return - 1 ; } # else val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 14 , r ) ; # endif break ; } } v = ( val * dqv ) >> dq_shift ; # if CONFIG_COEFFICIENT_RANGE_CHECKING # if CONFIG_VP9_HIGHBITDEPTH dqcoeff [ scan [ c ] ] = highbd_check_range ( ( vpx_read_bit ( r ) ? - v : v ) , xd -> bd ) ; # else dqcoeff [ scan [ c ] ] = check_range ( vpx_read_bit ( r ) ? - v : v ) ; # endif # else dqcoeff [ scan [ c ] ] = vpx_read_bit ( r ) ? - v : v ; # endif token_cache [ scan [ c ] ] = vp9_pt_energy_class [ token ] ; ++ c ; ctx = get_coef_context ( nb , token_cache , c ) ; dqv = dq [ 1 ] <S2SV_ModEnd> "
940,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> return ; 
941,"<S2SV_StartBug> void vp9_fht4x4_sse2 ( const int16_t * input , int16_t * output , <S2SV_EndBug> <S2SV_StartBug> vp9_fdct4x4_sse2 ( input , output , stride ) ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_fdct4x4_sse2 <S2SV_ModEnd> 
942,"<S2SV_StartBug> error_t mqttSnClientDisconnect ( MqttSnClientContext * context ) <S2SV_EndBug> <S2SV_StartBug> error = mqttSnClientSendDisconnect ( context , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> error = mqttSnClientSendDisconnect ( context , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , systime_t duration <S2SV_ModStart> duration / 1000 <S2SV_ModEnd> <S2SV_ModStart> duration / 1000 <S2SV_ModEnd> "
943,"<S2SV_StartBug> hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset , <S2SV_EndBug> <S2SV_StartBug> hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset , <S2SV_EndBug> ",<S2SV_ModStart> if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) { err = - EIO ; goto out ; } <S2SV_ModStart> if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) { err = - EIO ; goto out ; } 
944,"<S2SV_StartBug> SET_NETDEV_DEV ( dev , dmdev ) ; <S2SV_EndBug> ",<S2SV_ModStart> dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; 
945,<S2SV_StartBug> sd -> gspca_dev . usb_err = - EIO ; <S2SV_EndBug> ,<S2SV_ModStart> ; return ; } if ( alt -> desc . bNumEndpoints < 1 ) { sd -> gspca_dev . usb_err = - ENODEV 
946,"<S2SV_StartBug> num = port >= 0 ? port : 0 ; <S2SV_EndBug> <S2SV_StartBug> write_unlock_irqrestore ( & client -> ports_lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & client -> ports_mutex ) ; <S2SV_EndBug> ","<S2SV_ModStart> snd_use_lock_use ( & new_port -> use_lock ) ; <S2SV_ModStart> sprintf ( new_port -> name , ""port-%d"" , num ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
947,<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; msg -> msg_namelen = 0 
948,<S2SV_StartBug> NULL ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , true "
949,"<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; ret = posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( ret ) return ret <S2SV_ModEnd> "
950,<S2SV_StartBug> mflags = EXTRACT_LE_8BITS ( rhp -> rh_short . sh_flags ) ; <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK ( rhp -> rh_short . sh_flags ) ; 
951,"<S2SV_StartBug> char aacFileName [ 255 ] ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( audioFileName , optarg ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( adtsFileName , optarg ) ; <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> strcpy ( audioFileName , aacFileName ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> * aacFileName = NULL ; char * audioFileName = NULL ; char * adtsFileName = NULL <S2SV_ModEnd> <S2SV_ModStart> audioFileName = ( char * ) malloc ( sizeof ( char ) * ( strlen ( optarg ) + 1 ) ) ; if ( audioFileName == NULL ) { faad_fprintf ( stderr , ""Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>audioFileName.\\n"" ) ; return 1 ; } <S2SV_ModStart> adtsFileName = ( char * ) malloc ( sizeof ( char ) * ( strlen ( optarg ) + 1 ) ) ; if ( adtsFileName == NULL ) { faad_fprintf ( stderr , ""Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>adtsFileName.\\n"" ) ; return 1 ; } <S2SV_ModStart> aacFileName = ( char * ) malloc ( sizeof ( char ) * ( strlen ( argv [ optind ] ) + 1 ) ) ; if ( aacFileName == NULL ) { faad_fprintf ( stderr , ""Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>aacFileName.\\n"" ) ; return 1 ; } <S2SV_ModStart> audioFileName = ( char * ) malloc ( sizeof ( char ) * ( strlen ( aacFileName ) + strlen ( file_ext [ format ] ) + 1 ) ) ; if ( audioFileName == NULL ) { faad_fprintf ( stderr , ""Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>audioFileName.\\n"" ) ; return 1 ; } <S2SV_ModStart> if ( audioFileName != NULL ) free ( audioFileName ) ; if ( adtsFileName != NULL ) free ( adtsFileName ) ; <S2SV_ModStart> if ( aacFileName != NULL ) free ( aacFileName ) ; "
952,<S2SV_StartBug> key_put ( ci -> ci_keyring_key ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
953,"<S2SV_StartBug> rv = zsocket_connect ( * sock , info -> description ) ; <S2SV_EndBug> <S2SV_StartBug> rv = zsocket_bind ( * sock , info -> description ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , <S2SV_ModStart> ""%s"" , "
954,<S2SV_StartBug> fptr = ( struct frag_hdr * ) ( ( u8 * ) ipv6h + unfrag_ip6hlen ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ; 
955,<S2SV_StartBug> if ( ! ( fhdr -> frag_off & htons ( 0xFFF9 ) ) ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
956,<S2SV_StartBug> client -> auth_end_offset = AUTH_END_INIT_OFFSET ; <S2SV_EndBug> ,<S2SV_ModStart> auth_buffer = g_byte_array_new ( ) <S2SV_ModEnd> 
957,"<S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) ) <S2SV_EndBug> <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) ) <S2SV_EndBug> <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) ) <S2SV_EndBug> <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) ) <S2SV_EndBug> ",<S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> <S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> <S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> <S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> 
958,<S2SV_StartBug> key_pairs = palloc ( sizeof ( Pairs ) * key_count ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ; "
959,"<S2SV_StartBug> struct ip_options * opt = NULL ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt ) <S2SV_EndBug> <S2SV_StartBug> icsk -> icsk_ext_hdr_len -= inet -> opt -> optlen ; <S2SV_EndBug> <S2SV_StartBug> icsk -> icsk_ext_hdr_len += opt -> optlen ; <S2SV_EndBug> <S2SV_StartBug> opt = xchg ( & inet -> opt , opt ) ; <S2SV_EndBug> ","<S2SV_ModStart> ip_options_rcu * old , <S2SV_ModEnd> <S2SV_ModStart> ; old = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) <S2SV_ModStart> old <S2SV_ModEnd> <S2SV_ModStart> old -> opt . <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> rcu_assign_pointer ( inet -> inet_opt , opt ) ; if ( old ) call_rcu ( & old -> rcu , opt_kfree_rcu <S2SV_ModEnd> "
960,"<S2SV_StartBug> l2tp_framing_cap_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> <S2SV_StartBug> const uint32_t * ptr = ( const uint32_t * ) dat ; <S2SV_EndBug> ","<S2SV_ModStart> , u_int length <S2SV_ModStart> if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } "
961,"<S2SV_StartBug> } else if ( ! av_strcasecmp ( tag , ""Content-Length"" ) && s -> filesize == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> s -> filesize = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> <S2SV_StartBug> ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; <S2SV_EndBug> <S2SV_StartBug> s -> icy_metaint = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> ","<S2SV_ModStart> UINT64_MAX <S2SV_ModEnd> <S2SV_ModStart> strtoull <S2SV_ModEnd> <S2SV_ModStart> UINT64_MAX ; s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , ""WWW-Authenticate"" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Authentication-Info"" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Proxy-Authenticate"" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Connection"" ) ) { if ( ! strcmp ( p , ""close"" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , ""Server"" ) ) { if ( ! av_strcasecmp ( p , ""AkamaiGHost"" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , ""MediaGateway"" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , ""Content-Type"" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , ""Set-Cookie"" ) ) { if ( parse_cookie ( s , p , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strtoull <S2SV_ModEnd> "
962,"<S2SV_StartBug> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <S2SV_EndBug> ",<S2SV_ModStart> HeapOverflowSanityCheck <S2SV_ModEnd> 
963,<S2SV_StartBug> out_dqrele : <S2SV_EndBug> ,"<S2SV_ModStart> xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ; "
964,"<S2SV_StartBug> case 'c' : return getnum ( fmt , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> int sz = getnum ( fmt , sizeof ( int ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> L , <S2SV_ModStart> L , "
965,"<S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> eobs , 0 , 25 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> eobs , 0 , 25 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> else ( void ) mb_idx ; # <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
966,"<S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x"" , EXTRACT_32BITS ( tptr ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> while ( tptr < ( pptr + length ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_32BITS ( tptr ) ; <S2SV_ModStart> ND_TCHECK_8BITS ( tptr ) ; 
967,<S2SV_StartBug> ssize_t count ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( bytes == 0 || items == 0 ) return 0 
968,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""seq<S2SV_blank>0x%03x,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" , <S2SV_EndBug> ","<S2SV_ModStart> if ( length < 2 ) { ND_PRINT ( ( ndo , ""[|mlppp]"" ) ) ; return ; } if ( ! ND_TTEST_16BITS ( p ) ) { ND_PRINT ( ( ndo , ""[|mlppp]"" ) ) ; return ; } "
969,"<S2SV_StartBug> if ( ! __archive_ppmd7_functions . Ppmd7_Alloc ( & rar -> ppmd7_context , <S2SV_EndBug> ","<S2SV_ModStart> rar -> dictionary_size == 0 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>zero<S2SV_blank>dictionary<S2SV_blank>size"" ) ; return ( ARCHIVE_FATAL ) ; } if ( "
970,"<S2SV_StartBug> int offs , int count , int pmgr_flag ) <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( & ( ( char * ) & ins ) [ offs ] , addr + offs , sizeof ( ins ) - offs ) ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ins , addr <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
971,<S2SV_StartBug> if ( dctx -> bytes ) { <S2SV_EndBug> ,<S2SV_ModStart> ! ctx -> gf128 ) return - ENOKEY ; if ( 
972,"<S2SV_StartBug> if ( cgroup && ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) { <S2SV_EndBug> ","<S2SV_ModStart> ) { if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) return - ENOENT ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
973,<S2SV_StartBug> len = INT_MAX ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( unlikely ( ! access_ok ( VERIFY_READ , buff , len ) ) ) return - EFAULT "
974,"<S2SV_StartBug> throttle_event . header . size , 1 , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
975,"<S2SV_StartBug> if ( svm_set_msr ( & svm -> vcpu , & msr ) ) { <S2SV_EndBug> ",<S2SV_ModStart> kvm_set_msr <S2SV_ModEnd> 
976,"<S2SV_StartBug> Stream_Read_UINT16 ( licenseStream , os_minor ) ; <S2SV_EndBug> <S2SV_StartBug> Stream_Read_UINT32 ( licenseStream , cbCompanyName ) ; <S2SV_EndBug> <S2SV_StartBug> Stream_Read_UINT32 ( licenseStream , cbProductId ) ; <S2SV_EndBug> <S2SV_StartBug> Stream_Read_UINT32 ( licenseStream , cbLicenseInfo ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( Stream_GetRemainingLength ( licenseStream ) < 8 ) goto out_free_stream ; <S2SV_ModStart> if ( Stream_GetRemainingLength ( licenseStream ) < 4 ) goto out_free_stream ; <S2SV_ModStart> if ( Stream_GetRemainingLength ( licenseStream ) < 4 ) goto out_free_stream ; <S2SV_ModStart> if ( Stream_GetRemainingLength ( licenseStream ) < 4 ) goto out_free_stream ; 
977,"<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> gossip_err ( ""%s:<S2SV_blank>posix_acl_equiv_mode<S2SV_blank>err:<S2SV_blank>%d\\n"" , <S2SV_EndBug> <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> ","<S2SV_ModStart> ; error = posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( error <S2SV_ModEnd> <S2SV_ModStart> ""%s:<S2SV_blank>posix_acl_update_mode<S2SV_blank>err:<S2SV_blank>%d\\n"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
978,<S2SV_StartBug> return SECURE_ELEMENT_ERROR_NPE ; <S2SV_EndBug> ,<S2SV_ModStart> ; } if ( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE ) { return SECURE_ELEMENT_ERROR_BUF_SIZE 
979,<S2SV_StartBug> if ( skb -> len && ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <S2SV_EndBug> ,<S2SV_ModStart> skb_is_err_queue ( skb ) && 
980,<S2SV_StartBug> while ( f != upto ) ; <S2SV_EndBug> ,<S2SV_ModStart> && f 
981,"<S2SV_StartBug> pfd . events = POLLIN ; <S2SV_EndBug> <S2SV_StartBug> len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len < 0 ) { <S2SV_EndBug> <S2SV_StartBug> syslog ( LOG_ERR , ""recv<S2SV_blank>failed;<S2SV_blank>error:%d"" , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; socklen_t addr_l = sizeof ( addr ) ; <S2SV_ModStart> recvfrom <S2SV_ModEnd> <S2SV_ModStart> , addr_p , & addr_l <S2SV_ModStart> || addr . nl_pid <S2SV_ModStart> ""recvfrom<S2SV_blank>failed;<S2SV_blank>pid:%u<S2SV_blank>error:%d<S2SV_blank>%s"" , addr . nl_pid , errno , strerror ( errno ) <S2SV_ModEnd> "
982,<S2SV_StartBug> inode_init_once ( & ei -> vfs_inode ) ; <S2SV_EndBug> ,<S2SV_ModStart> init_rwsem ( & ei -> i_mmap_sem ) ; 
983,<S2SV_StartBug> if ( pbi -> common . frame_to_show ) <S2SV_EndBug> ,<S2SV_ModStart> ( void ) flags ; 
984,"<S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( max_packets , <S2SV_EndBug> ","<S2SV_ModStart> MagickMax ( number_pixels , max_packets ) , <S2SV_ModEnd> "
985,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
986,"<S2SV_StartBug> ReflectionMethodBuilder rmb ; <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> mb -> mhandle = reflection_methodbuilder_to_mono_method ( klass , & rmb , sig ) ; <S2SV_EndBug> ","<S2SV_ModStart> MonoReferenceQueue * queue ; MonoMethod * handle ; DynamicMethodReleaseData * release_data ; <S2SV_ModStart> if ( mono_runtime_is_shutting_down ( ) ) mono_raise_exception ( mono_get_exception_invalid_operation ( """" ) ) ; if ( ! ( queue = dynamic_method_queue ) ) { mono_loader_lock ( ) ; if ( ! ( queue = dynamic_method_queue ) ) queue = dynamic_method_queue = mono_gc_reference_queue_new ( free_dynamic_method ) ; mono_loader_unlock ( ) ; } <S2SV_ModStart> handle = <S2SV_ModStart> ) ; release_data = g_new ( DynamicMethodReleaseData , 1 ) ; release_data -> handle = handle ; release_data -> domain = mono_object_get_domain ( ( MonoObject * ) mb ) ; if ( ! mono_gc_reference_queue_add ( queue , ( MonoObject * ) mb , release_data ) ) g_free ( release_data "
987,<S2SV_StartBug> double correction_factor ) { <S2SV_EndBug> <S2SV_StartBug> const double q = vp9_convert_qindex_to_q ( qindex ) ; <S2SV_EndBug> <S2SV_StartBug> int enumerator = frame_type == KEY_FRAME ? 3300000 : 2250000 ; <S2SV_EndBug> <S2SV_StartBug> return ( int ) ( 0.5 + ( enumerator * correction_factor / q ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , vpx_bit_depth_t bit_depth <S2SV_ModStart> , bit_depth <S2SV_ModStart> 2700000 : 1800000 ; assert ( correction_factor <= MAX_BPB_FACTOR && correction_factor >= MIN_BPB_FACTOR ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
988,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>ho=0x%04x<S2SV_blank>co=0x%04x)"" , <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_TCHECK_16BITS ( & bp [ i + 4 ] ) ; 
989,<S2SV_StartBug> mark_files_ro ( sb ) ; <S2SV_EndBug> ,<S2SV_ModStart> sb -> s_readonly_remount = 1 ; smp_wmb ( <S2SV_ModEnd> 
990,"<S2SV_StartBug> while ( ( s = mcs_recv ( & channel , is_fastpath , & fastpath_hdr ) ) != NULL ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> in_uint8s ( s , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> uint8 swapbyte ; <S2SV_EndBug> ","<S2SV_ModStart> struct stream packet ; <S2SV_ModStart> packet = * s ; <S2SV_ModStart> if ( ! s_check_rem ( s , 8 ) ) { rdp_protocol_error ( ""sec_recv(),<S2SV_blank>consume<S2SV_blank>fastpath<S2SV_blank>signature<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } <S2SV_ModStart> if ( ! s_check_rem ( s , 8 ) ) { rdp_protocol_error ( ""sec_recv(),<S2SV_blank>consume<S2SV_blank>encrypt<S2SV_blank>signature<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } <S2SV_ModStart> if ( ! s_check_rem ( s , 8 ) ) { rdp_protocol_error ( ""sec_recv(),<S2SV_blank>consume<S2SV_blank>redirect<S2SV_blank>signature<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } "
991,"<S2SV_StartBug> static void ip6_append_data_mtu ( int * mtu , <S2SV_EndBug> <S2SV_StartBug> struct rt6_info * rt ) <S2SV_EndBug> <S2SV_StartBug> * mtu = dst_mtu ( rt -> dst . path ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned <S2SV_ModStart> , bool pmtuprobe <S2SV_ModStart> min ( * mtu , pmtuprobe ? rt -> dst . dev -> mtu : <S2SV_ModStart> ) "
992,"<S2SV_StartBug> vpx_memset ( & lfm -> lfl_y [ index ] , filter_level , w ) ; <S2SV_EndBug> <S2SV_StartBug> * int_4x4_y |= ( size_mask [ block_size ] & 0xffffffffffffffff ) << shift_y ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> 0xffffffffffffffffULL <S2SV_ModEnd> 
993,<S2SV_StartBug> rfcomm_dlc_accept ( d ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; msg -> msg_namelen = 0 
994,<S2SV_StartBug> if ( ! vct_iscrlf ( hp -> rxbuf [ l ] ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! vct_iscrlf ( hp -> rxbuf [ l + 1 ] ) ) <S2SV_EndBug> ,<S2SV_ModStart> & <S2SV_ModStart> & 
995,<S2SV_StartBug> if ( trk -> vos_len == 0 && par -> extradata_size > 0 && <S2SV_EndBug> ,"<S2SV_ModStart> samples_in_chunk < 1 ) { av_log ( s , AV_LOG_ERROR , ""fatal<S2SV_blank>error,<S2SV_blank>input<S2SV_blank>packet<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>samples\\n"" ) ; return AVERROR_PATCHWELCOME ; } if ( "
996,"
","
"
997,"<S2SV_StartBug> if ( strcmp ( ( const char * ) ( data1 + 2 ) , ""\\\\MAILSLOT\\\\BROWSE"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( ( const char * ) ( data1 + 2 ) , ""\\\\PIPE\\\\LANMAN"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( paramlen ) <S2SV_EndBug> ","<S2SV_ModStart> # define MAILSLOT_BROWSE_STR ""\\\\MAILSLOT\\\\BROWSE"" ND_TCHECK2 ( * ( data1 + 2 ) , strlen ( MAILSLOT_BROWSE_STR ) + 1 ) ; <S2SV_ModStart> MAILSLOT_BROWSE_STR <S2SV_ModEnd> <S2SV_ModStart> # undef MAILSLOT_BROWSE_STR # define PIPE_LANMAN_STR ""\\\\PIPE\\\\LANMAN"" ND_TCHECK2 ( * ( data1 + 2 ) , strlen ( PIPE_LANMAN_STR ) + 1 ) ; <S2SV_ModStart> PIPE_LANMAN_STR <S2SV_ModEnd> <S2SV_ModStart> # undef PIPE_LANMAN_STR "
998,"<S2SV_StartBug> void open_input_file ( struct VpxInputContext * input ) { <S2SV_EndBug> <S2SV_StartBug> input -> detect . buf_read = fread ( input -> detect . buf , 1 , 4 , input -> file ) ; <S2SV_EndBug> <S2SV_StartBug> input -> framerate . numerator = input -> y4m . fps_n ; <S2SV_EndBug> <S2SV_StartBug> input -> use_i420 = 0 ; <S2SV_EndBug> ",<S2SV_ModStart> static <S2SV_ModStart> pixel_aspect_ratio . numerator = 1 ; input -> pixel_aspect_ratio . denominator = 1 ; input -> <S2SV_ModStart> pixel_aspect_ratio . numerator = input -> y4m . par_n ; input -> pixel_aspect_ratio . denominator = input -> y4m . par_d ; input -> <S2SV_ModStart> fmt = input -> y4m . vpx_fmt ; input -> bit_depth = input -> y4m . bit_depth <S2SV_ModEnd> 
999,<S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug> ,<S2SV_ModStart> ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> 
1000,"<S2SV_StartBug> err = ops -> ieee_getets ( netdev , & ets ) ; <S2SV_EndBug> <S2SV_StartBug> err = ops -> ieee_getmaxrate ( netdev , & maxrate ) ; <S2SV_EndBug> <S2SV_StartBug> struct ieee_pfc pfc ; <S2SV_EndBug> <S2SV_StartBug> err = ops -> ieee_peer_getets ( netdev , & ets ) ; <S2SV_EndBug> <S2SV_StartBug> struct ieee_pfc pfc ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( & ets , 0 , sizeof ( ets ) ) ; <S2SV_ModStart> memset ( & maxrate , 0 , sizeof ( maxrate ) ) ; <S2SV_ModStart> ; memset ( & pfc , 0 , sizeof ( pfc ) ) <S2SV_ModStart> memset ( & ets , 0 , sizeof ( ets ) ) ; <S2SV_ModStart> ; memset ( & pfc , 0 , sizeof ( pfc ) ) "
1001,"<S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> case CFM_CHASSIS_ID_MAC_ADDRESS : <S2SV_EndBug> <S2SV_StartBug> hexdump |= cfm_network_addr_print ( ndo , tptr ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> if ( mgmt_addr_length ) { <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> cfm_tlv_len -= mgmt_addr_length ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mgmt_addr_length ) { <S2SV_EndBug> <S2SV_StartBug> cfm_tlv_len -= mgmt_addr_length ; <S2SV_EndBug> <S2SV_StartBug> tptr += cfm_tlv_len ; <S2SV_EndBug> ","<S2SV_ModStart> goto next_tlv <S2SV_ModEnd> <S2SV_ModStart> goto next_tlv <S2SV_ModEnd> <S2SV_ModStart> goto next_tlv <S2SV_ModEnd> <S2SV_ModStart> if ( chassis_id_length != ETHER_ADDR_LEN ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>MAC<S2SV_blank>address<S2SV_blank>length)"" ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> + 1 , chassis_id_length <S2SV_ModStart> break <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Domain<S2SV_blank>Length<S2SV_blank>%u"" , mgmt_addr_length ) ) ; <S2SV_ModStart> goto next_tlv <S2SV_ModEnd> <S2SV_ModStart> ; hex_print ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Domain:<S2SV_blank>"" , tptr , mgmt_addr_length ) <S2SV_ModStart> ""<S2SV_blank>(Management<S2SV_blank>Address<S2SV_blank>Length<S2SV_blank>is<S2SV_blank>missing)"" ) ) ; hexdump = TRUE ; break <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Length<S2SV_blank>%u"" , mgmt_addr_length ) ) ; <S2SV_ModStart> ; hex_print ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address:<S2SV_blank>"" , tptr , mgmt_addr_length ) <S2SV_ModStart> next_tlv : "
1002,<S2SV_StartBug> void fadst4_sse2 ( __m128i * in ) { <S2SV_EndBug> <S2SV_StartBug> const __m128i k__sinpi_p03_p03 = _mm_set1_epi16 ( sinpi_3_9 ) ; <S2SV_EndBug> ,<S2SV_ModStart> static <S2SV_ModStart> ( int16_t ) 
1003,"<S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> ",<S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> codec_interface <S2SV_ModEnd> 
1004,"<S2SV_StartBug> int copied , error = - EINVAL ; <S2SV_EndBug> ",<S2SV_ModStart> ; msg -> msg_namelen = 0 
1005,"<S2SV_StartBug> rc = target_xcopy_locate_se_dev_e4 ( xop -> dst_tid_wwn , <S2SV_EndBug> <S2SV_StartBug> & xop -> dst_dev ) ; <S2SV_EndBug> <S2SV_StartBug> rc = target_xcopy_locate_se_dev_e4 ( xop -> src_tid_wwn , <S2SV_EndBug> <S2SV_StartBug> & xop -> src_dev ) ; <S2SV_EndBug> ","<S2SV_ModStart> se_cmd -> se_sess , <S2SV_ModStart> , & xop -> remote_lun_ref <S2SV_ModStart> se_cmd -> se_sess , <S2SV_ModStart> , & xop -> remote_lun_ref "
1006,"<S2SV_StartBug> void ipc_rcu_getref ( void * ptr ) <S2SV_EndBug> <S2SV_StartBug> container_of ( ptr , struct ipc_rcu_hdr , data ) -> refcount ++ ; <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return atomic_inc_not_zero ( & <S2SV_ModStart> ) <S2SV_ModEnd> 
1007,"<S2SV_StartBug> err = scm_send ( sock , msg , siocb -> scm ) ; <S2SV_EndBug> ","<S2SV_ModStart> , true "
1008,"<S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( max_packets , <S2SV_EndBug> ","<S2SV_ModStart> MagickMax ( number_pixels , max_packets ) , <S2SV_ModEnd> "
1009,"<S2SV_StartBug> size_t size ; <S2SV_EndBug> <S2SV_StartBug> JAS_DBGLOG ( 10 , ( ""jpeg_start_decompress(%p)\\n"" , & cinfo ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opts . max_size ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! jas_safe_size_mul ( cinfo . output_width , cinfo . output_height , <S2SV_EndBug> <S2SV_StartBug> if ( size > opts . max_size ) { <S2SV_EndBug> <S2SV_StartBug> jas_eprintf ( ""image<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> num_samples ; JAS_DBGLOG ( 100 , ( ""jpg_decode(%p,<S2SV_blank>\\""%s\\"")\\n"" , in , optstr ) ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> max_samples > 0 <S2SV_ModEnd> <S2SV_ModStart> jas_safe_size_mul3 ( cinfo . image_width , cinfo . image_height , cinfo . num_components , & num_samples <S2SV_ModEnd> <S2SV_ModStart> num_samples <S2SV_ModEnd> <S2SV_ModStart> max_samples <S2SV_ModEnd> <S2SV_ModStart> ""image<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%zu<S2SV_blank>><S2SV_blank>%zu)\\n"" , num_samples , opts . max_samples <S2SV_ModEnd> <S2SV_ModStart> JAS_DBGLOG ( 10 , ( ""jpeg_start_decompress(%p)\\n"" , & cinfo ) ) ; ret = jpeg_start_decompress ( & cinfo ) ; JAS_DBGLOG ( 10 , ( ""jpeg_start_decompress<S2SV_blank>return<S2SV_blank>value<S2SV_blank>%d\\n"" , ret ) ) ; JAS_DBGLOG ( 10 , ( ""header:<S2SV_blank>output_width<S2SV_blank>%d;<S2SV_blank>output_height<S2SV_blank>%d;<S2SV_blank>output_components<S2SV_blank>%d\\n"" , cinfo . output_width , cinfo . output_height , cinfo . output_components ) ) ; "
1010,<S2SV_StartBug> mutex_lock ( & tu -> tread_sem ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & tu -> tread_sem ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1011,<S2SV_StartBug> if ( IS_NOT_NULL ( Else ) ) { <S2SV_EndBug> <S2SV_StartBug> len += SIZE_OP_JUMP ; <S2SV_EndBug> ,<S2SV_ModStart> len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END ; <S2SV_ModStart>  <S2SV_ModEnd> 
1012,<S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> ,<S2SV_ModStart> ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> 
1013,"<S2SV_StartBug> int i , protocol ; <S2SV_EndBug> <S2SV_StartBug> switch ( protocol ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! h1 -> bInCollection ) { <S2SV_EndBug> <S2SV_StartBug> dev_info ( & dev -> dev , ""skipping<S2SV_blank>empty<S2SV_blank>audio<S2SV_blank>interface<S2SV_blank>(v1)\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; int rest_bytes <S2SV_ModStart> rest_bytes = ( void * ) ( host_iface -> extra + host_iface -> extralen ) - control_header ; if ( rest_bytes <= 0 ) { dev_err ( & dev -> dev , ""invalid<S2SV_blank>control<S2SV_blank>header\\n"" ) ; return - EINVAL ; } <S2SV_ModStart> rest_bytes < sizeof ( * h1 ) ) { dev_err ( & dev -> dev , ""too<S2SV_blank>short<S2SV_blank>v1<S2SV_blank>buffer<S2SV_blank>descriptor\\n"" ) ; return - EINVAL ; } if ( <S2SV_ModStart> ) ; return - EINVAL ; } if ( rest_bytes < h1 -> bLength ) { dev_err ( & dev -> dev , ""invalid<S2SV_blank>buffer<S2SV_blank>length<S2SV_blank>(v1)\\n"" "
1014,"<S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> <S2SV_StartBug> pr_info ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> 
1015,<S2SV_StartBug> if ( sock_owned_by_user ( sk ) ) { <S2SV_EndBug> ,<S2SV_ModStart> sk != rcvr -> sk ) { sctp_bh_unlock_sock ( sk ) ; sk = rcvr -> sk ; sctp_bh_lock_sock ( sk ) ; } if ( 
1016,"<S2SV_StartBug> Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; return ; } if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) { Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".cfg\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" "
1017,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % ( 4 * stride ) ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horDiff32"" , ""%s"" , ""(cc%(4*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; "
1018,"<S2SV_StartBug> struct r_bin_dyldcache_obj_t * bin ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( bin = malloc ( sizeof ( struct r_bin_dyldcache_obj_t ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> memset ( bin , 0 , sizeof ( struct r_bin_dyldcache_obj_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! r_buf_set_bytes ( bin -> b , buf , size ) ) { <S2SV_EndBug> ",<S2SV_ModStart> = R_NEW0 ( struct r_bin_dyldcache_obj_t ) <S2SV_ModStart> bin <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ! bin -> b || 
1019,<S2SV_StartBug> static unsigned short len = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> 
1020,"<S2SV_StartBug> static int shash_no_setkey ( struct crypto_shash * tfm , const u8 * key , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1021,"<S2SV_StartBug> tile -> mi_row_start = get_tile_offset ( row , cm -> mi_rows , cm -> log2_tile_rows ) ; <S2SV_EndBug> ","<S2SV_ModStart> vp9_tile_set_row ( tile , cm , row ) ; vp9_tile_set_col ( tile , cm , col <S2SV_ModEnd> "
1022,<S2SV_StartBug> static double get_rate_correction_factor ( const VP9_COMP * cpi ) { <S2SV_EndBug> <S2SV_StartBug> return cpi -> rc . key_frame_rate_correction_factor ; <S2SV_EndBug> <S2SV_StartBug> ! cpi -> rc . is_src_frame_alt_ref && <S2SV_EndBug> <S2SV_StartBug> ! ( cpi -> use_svc && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) ) <S2SV_EndBug> ,"<S2SV_ModStart> const RATE_CONTROL * const rc = & cpi -> rc ; double rcf ; <S2SV_ModStart> rcf = rc -> rate_correction_factors [ KF_STD ] ; } else if ( cpi -> oxcf . pass == 2 ) { RATE_FACTOR_LEVEL rf_lvl = cpi -> twopass . gf_group . rf_level [ cpi -> twopass . gf_group . index ] ; rcf = rc -> rate_correction_factors [ rf_lvl ] <S2SV_ModEnd> <S2SV_ModStart> rc -> <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( <S2SV_ModStart> rc_mode != VPX_CBR || cpi -> oxcf . gf_cbr_boost_pct > 20 ) ) rcf = rc -> rate_correction_factors [ GF_ARF_STD ] ; else rcf = rc -> rate_correction_factors [ INTER_NORMAL ] ; } rcf *= rcf_mult [ rc -> frame_size_selector ] ; return fclamp ( rcf , MIN_BPB_FACTOR , MAX_BPB_FACTOR ) ; <S2SV_ModEnd> "
1023,"<S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> if ( tag == 0xFFFEE0DD ) <S2SV_EndBug> ","<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( "
1024,<S2SV_StartBug> int val = 1 ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ssocket == NULL ) return - ENOTSOCK 
1025,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> recovery_started = false ; 
1026,"<S2SV_StartBug> char query [ 255 ] , rows [ NAME_LEN ] , fields [ 16 ] ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( query , ""SELECT<S2SV_blank>COUNT(*)<S2SV_blank>FROM<S2SV_blank>`%s`"" , row [ 0 ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> NAME_LEN + 100 <S2SV_ModEnd> <S2SV_ModStart> my_snprintf <S2SV_ModEnd> <S2SV_ModStart> sizeof ( query ) , "
1027,<S2SV_StartBug> mlock_vma_page ( page ) ; <S2SV_EndBug> <S2SV_StartBug> if ( page == check_page ) <S2SV_EndBug> <S2SV_StartBug> ret = SWAP_MLOCK ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { mlock_vma_page ( page ) ; <S2SV_ModStart> } else if ( trylock_page ( page ) ) { mlock_vma_page ( page ) ; unlock_page ( page ) ; } 
1028,<S2SV_StartBug> if ( rs -> rs_bound_addr == 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> || ! rs -> rs_transport 
1029,<S2SV_StartBug> int n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! body -> unit_size ) break ; n 
1030,<S2SV_StartBug> data = malloc ( blk_sz * n_blks ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc ( <S2SV_ModEnd> 
1031,"<S2SV_StartBug> int vp8_denoiser_filter_sse2 ( YV12_BUFFER_CONFIG * mc_running_avg , <S2SV_EndBug> <S2SV_StartBug> unsigned char * sig = signal -> thismb ; <S2SV_EndBug> <S2SV_StartBug> unsigned char * mc_running_avg_y = mc_running_avg -> y_buffer + y_offset ; <S2SV_EndBug> <S2SV_StartBug> unsigned char * running_avg_y = running_avg -> y_buffer + y_offset ; <S2SV_EndBug> <S2SV_StartBug> __m128i acc_diff = _mm_setzero_si128 ( ) ; <S2SV_EndBug> <S2SV_StartBug> ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 7 : 6 ) ; <S2SV_EndBug> <S2SV_StartBug> union sum_union s ; <S2SV_EndBug> <S2SV_StartBug> s . v = acc_diff ; <S2SV_EndBug> <S2SV_StartBug> sum_diff = s . e [ 0 ] + s . e [ 1 ] + s . e [ 2 ] + s . e [ 3 ] + s . e [ 4 ] + s . e [ 5 ] <S2SV_EndBug> <S2SV_StartBug> if ( abs ( sum_diff ) > SUM_DIFF_THRESHOLD ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> signal -> thismb , sig_stride ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mc_running_avg_y , int mc_avg_y_stride , <S2SV_ModEnd> <S2SV_ModStart> running_avg_y , int avg_y_stride , <S2SV_ModEnd> <S2SV_ModStart> sig , int sig_stride , unsigned int motion_magnitude , int increase_denoising ) { unsigned char * running_avg_y_start = running_avg_y ; unsigned char * sig_start = sig ; unsigned int sum_diff_thresh <S2SV_ModEnd> <S2SV_ModStart> int shift_inc = ( increase_denoising && <S2SV_ModEnd> <S2SV_ModStart> 1 : 0 ; __m128i acc_diff = _mm_setzero_si128 ( ) ; const __m128i k_0 = _mm_setzero_si128 ( ) ; const __m128i k_4 = _mm_set1_epi8 ( 4 + shift_inc ) ; const __m128i k_8 = _mm_set1_epi8 ( 8 ) ; const __m128i k_16 = _mm_set1_epi8 ( 16 ) ; const __m128i l3 = _mm_set1_epi8 ( ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 7 + shift_inc <S2SV_ModEnd> <S2SV_ModStart> unsigned int abs_sum_diff = abs_sum_diff_16x1 ( acc_diff ) ; sum_diff_thresh = SUM_DIFF_THRESHOLD ; if ( increase_denoising ) sum_diff_thresh = SUM_DIFF_THRESHOLD_HIGH ; if ( abs_sum_diff > sum_diff_thresh ) { int delta = ( ( abs_sum_diff - sum_diff_thresh ) >> 8 ) + 1 ; if ( delta < 4 ) { const __m128i k_delta = _mm_set1_epi8 ( delta ) ; sig -= sig_stride * 16 ; mc_running_avg_y -= mc_avg_y_stride * 16 ; running_avg_y -= avg_y_stride * 16 ; for ( r <S2SV_ModEnd> <S2SV_ModStart> r < 16 ; ++ r ) { __m128i v_running_avg_y = _mm_loadu_si128 ( ( __m128i * ) ( & running_avg_y <S2SV_ModEnd> <S2SV_ModStart> ) ) ; const __m128i v_sig = _mm_loadu_si128 ( ( __m128i * ) ( & sig [ 0 ] ) ) ; const __m128i v_mc_running_avg_y = _mm_loadu_si128 ( ( __m128i * ) ( & mc_running_avg_y [ 0 ] ) ) ; const __m128i pdiff = _mm_subs_epu8 ( v_mc_running_avg_y , v_sig ) ; const __m128i ndiff = _mm_subs_epu8 ( v_sig , v_mc_running_avg_y ) ; const __m128i diff_sign = _mm_cmpeq_epi8 ( pdiff , k_0 ) ; const __m128i adj = _mm_min_epu8 ( _mm_or_si128 ( pdiff , ndiff ) , k_delta ) ; __m128i padj , nadj ; padj = _mm_andnot_si128 ( diff_sign , adj ) ; nadj = _mm_and_si128 ( diff_sign , adj ) ; v_running_avg_y = _mm_subs_epu8 ( v_running_avg_y , padj ) ; v_running_avg_y = _mm_adds_epu8 ( v_running_avg_y , nadj ) ; _mm_storeu_si128 ( ( __m128i * ) running_avg_y , v_running_avg_y ) ; acc_diff = _mm_subs_epi8 ( acc_diff , padj ) ; acc_diff = _mm_adds_epi8 ( acc_diff , nadj ) ; sig += sig_stride ; mc_running_avg_y += mc_avg_y_stride ; running_avg_y += avg_y_stride ; } abs_sum_diff = abs_sum_diff_16x1 ( acc_diff ) <S2SV_ModEnd> <S2SV_ModStart> abs_sum_diff > sum_diff_thresh ) <S2SV_ModEnd> <S2SV_ModStart> else { return COPY_BLOCK ; } } } vp8_copy_mem16x16 ( running_avg_y_start <S2SV_ModEnd> <S2SV_ModStart> sig_start <S2SV_ModEnd> "
1032,<S2SV_StartBug> r = vapic_enter ( vcpu ) ; <S2SV_EndBug> <S2SV_StartBug> vapic_exit ( vcpu ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1033,"<S2SV_StartBug> unsigned char type , void * * ptr ) <S2SV_EndBug> <S2SV_StartBug> if ( header -> bLength < 2 ) { <S2SV_EndBug> <S2SV_StartBug> if ( header -> bDescriptorType == type ) { <S2SV_EndBug> ","<S2SV_ModStart> , size_t minsize <S2SV_ModStart> || header -> bLength > size <S2SV_ModStart> && header -> bLength >= minsize "
1034,<S2SV_StartBug> case DH6OPT_RECONF_MSG : <S2SV_EndBug> ,"<S2SV_ModStart> if ( optlen != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } "
1035,"<S2SV_StartBug> wait_event_interruptible_timeout ( sunkbd -> wait , sunkbd -> reset >= 0 , HZ ) ; <S2SV_EndBug> <S2SV_StartBug> serio_write ( sunkbd -> serio , SUNKBD_CMD_SETLED ) ; <S2SV_EndBug> ",<S2SV_ModStart> || ! sunkbd -> enabled <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> reset >= 0 && sunkbd -> enabled ) sunkbd_set_leds_beeps ( sunkbd <S2SV_ModEnd> 
1036,"<S2SV_StartBug> MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> { MATLAB_KO : clone_info = DestroyImageInfo ( clone_info ) ; <S2SV_ModEnd> <S2SV_ModStart> } 
1037,"<S2SV_StartBug> buffer_copy_buffer ( con -> physical . basedir , ds -> value ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( uri_ptr [ alias_len ] == '.' ) { char * s = uri_ptr + alias_len + 1 ; if ( * s == '.' ) ++ s ; if ( * s == '/' || * s == '\\0' ) { size_t vlen = buffer_string_length ( ds -> value ) ; if ( 0 != alias_len && ds -> key -> ptr [ alias_len - 1 ] != '/' && 0 != vlen && ds -> value -> ptr [ vlen - 1 ] == '/' ) { con -> http_status = 403 ; return HANDLER_FINISHED ; } } } 
1038,"<S2SV_StartBug> unsigned int len ; <S2SV_EndBug> <S2SV_StartBug> fbdev = to_au1100fb_device ( fbi ) ; <S2SV_EndBug> <S2SV_StartBug> if ( io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return vm_iomap_memory <S2SV_ModEnd> <S2SV_ModStart> fbdev -> fb_phys , fbdev -> fb_len ) <S2SV_ModEnd> "
1039,"<S2SV_StartBug> if ( mount ( ""none"" , path , ""tmpfs"" , 0 , ""size=100000,mode=755"" ) ) { <S2SV_EndBug> ","<S2SV_ModStart> safe_mount <S2SV_ModEnd> <S2SV_ModStart> , rootfs -> path ? rootfs -> mount : NULL "
1040,<S2SV_StartBug> assert ( pMatch -> iCursor == pExpr -> iTable ) ; <S2SV_EndBug> ,<S2SV_ModStart> pExpr -> y . pTab != 0 ) ; assert ( <S2SV_ModStart> if ( pExpr -> y . pTab -> tabFlags & TF_HasGenerated ) { Column * pCol = pExpr -> y . pTab -> aCol + pExpr -> iColumn ; if ( pCol -> colFlags & COLFLAG_GENERATED ) n = BMS - 1 ; } 
1041,<S2SV_StartBug> const vp9_tree_index * tree ) { <S2SV_EndBug> ,<S2SV_ModStart> vpx_tree_index <S2SV_ModEnd> 
1042,<S2SV_StartBug> # ifdef _WITH_VRRP_ <S2SV_EndBug> ,"<S2SV_ModStart> fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-u,<S2SV_blank>--umask=MASK<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>umask<S2SV_blank>for<S2SV_blank>file<S2SV_blank>creation<S2SV_blank>(in<S2SV_blank>numeric<S2SV_blank>form)\\n"" ) ; "
1043,<S2SV_StartBug> if ( conf . strip ) { <S2SV_EndBug> ,<S2SV_ModStart> have_hashseed ) json_object_seed ( conf . hashseed ) ; if ( conf . 
1044,"<S2SV_StartBug> if ( cid <= 0 ) <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = ff_dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) <S2SV_EndBug> <S2SV_StartBug> return dctx -> remaining ; <S2SV_EndBug> ",<S2SV_ModStart> int remaining ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> 
1045,<S2SV_StartBug> slave -> master = master ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irq ( & slave_active_lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> spin_lock ( & master -> timer -> lock ) ; <S2SV_ModStart> spin_unlock ( & master -> timer -> lock ) ; 
1046,"<S2SV_StartBug> int offs , int count , int pmgr_flag ) <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( & ( ( char * ) & ins ) [ offs ] , addr + offs , sizeof ( ins ) - offs ) ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ins , addr <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1047,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> [ plane ] && in -> linesize 
1048,"<S2SV_StartBug> int hours , minutes , seconds ; <S2SV_EndBug> ",<S2SV_ModStart> int64_t <S2SV_ModEnd> 
1049,<S2SV_StartBug> # ifndef PGEN <S2SV_EndBug> ,<S2SV_ModStart> if ( * flags & PyPARSE_TYPE_COMMENTS ) { tok -> type_comments = 1 ; } 
1050,<S2SV_StartBug> if ( * rsize >= 74 && <S2SV_EndBug> <S2SV_StartBug> rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 && <S2SV_EndBug> ,"<S2SV_ModStart> 75 && rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 && rdesc [ 63 ] == 0x19 && rdesc [ 64 ] == 0x08 && rdesc [ 65 ] == 0x29 && rdesc [ 66 ] == 0x0f && rdesc [ 71 ] == 0x75 && rdesc [ 72 ] == 0x08 && rdesc [ 73 ] == 0x95 && rdesc [ 74 ] == 0x01 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Kye/Genius<S2SV_blank>Ergo<S2SV_blank>Mouse<S2SV_blank>"" ""report<S2SV_blank>descriptor\\n"" ) ; <S2SV_ModEnd> <S2SV_ModStart> = 0x09 ; rdesc [ 64 ] = 0x04 ; rdesc [ 66 ] = 0x07 ; rdesc [ 72 ] = 0x01 ; rdesc [ 74 ] = 0x08 <S2SV_ModEnd> "
1051,"<S2SV_StartBug> char * ksep , * vsep , * val ; <S2SV_EndBug> <S2SV_StartBug> vsep = memchr ( var -> ptr , '&' , var -> end - var -> ptr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! eof ) { <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ","<S2SV_ModStart> start , * <S2SV_ModStart> start = var -> ptr + var -> already_scanned ; <S2SV_ModStart> start <S2SV_ModEnd> <S2SV_ModStart> start <S2SV_ModEnd> <S2SV_ModStart> var -> already_scanned = var -> end - var -> ptr ; <S2SV_ModStart> var -> already_scanned = 0 ; "
1052,"<S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , mp4 -> metaoffsets [ index ] , SEEK_SET ) ; <S2SV_EndBug> <S2SV_StartBug> return MP4buffer ; <S2SV_EndBug> ",<S2SV_ModStart> if ( mp4 -> filesize > mp4 -> metaoffsets [ index ] + mp4 -> metasizes [ index ] ) { <S2SV_ModStart> mp4 -> filepos = mp4 -> metaoffsets [ index ] + mp4 -> metasizes [ index ] ; <S2SV_ModStart> } 
1053,"<S2SV_StartBug> RefBuffer * ref_buf = NULL ; <S2SV_EndBug> <S2SV_StartBug> cm -> frame_bufs [ free_fb ] . ref_count -- ; <S2SV_EndBug> <S2SV_StartBug> ref_cnt_fb ( cm -> frame_bufs , ref_fb_ptr , free_fb ) ; <S2SV_EndBug> <S2SV_StartBug> ref_buf -> buf = & cm -> frame_bufs [ * ref_fb_ptr ] . buf ; <S2SV_EndBug> ",<S2SV_ModStart> ; RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs <S2SV_ModStart> if ( cm -> new_fb_idx == INVALID_IDX ) return VPX_CODEC_MEM_ERROR ; -- <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1054,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( ! uc_more_data_flag && ( 0 == ( i2_cur_mb_addr & 1 ) ) ) { return ERROR_EOB_FLUSHBITS_T ; } 
1055,"<S2SV_StartBug> static int write_skip ( const VP9_COMP * cpi , int segment_id , const MODE_INFO * mi , <S2SV_EndBug> <S2SV_StartBug> vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , skip , vp9_get_skip_prob ( & cpi -> common , xd ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> VP9_COMMON * cm , const MACROBLOCKD * xd , <S2SV_ModEnd> <S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> if ( segfeature_active ( & cm -> <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> cm <S2SV_ModEnd> "
1056,"<S2SV_StartBug> ip_printts ( ndo , cp , option_len ) ; <S2SV_EndBug> <S2SV_StartBug> case IPOPT_RA : <S2SV_EndBug> ","<S2SV_ModStart> if ( ip_printts <S2SV_ModEnd> <S2SV_ModStart> IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ; break ; case "
1057,"<S2SV_StartBug> pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" <S2SV_EndBug> ",<S2SV_ModStart> pr_debug <S2SV_ModEnd> 
1058,<S2SV_StartBug> if ( _payload ) { <S2SV_EndBug> ,<S2SV_ModStart> plen <S2SV_ModEnd> 
1059,<S2SV_StartBug> name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ; <S2SV_EndBug> ,<S2SV_ModStart> rmtvaluelen <S2SV_ModEnd> 
1060,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1061,<S2SV_StartBug> if ( env -> allow_ptr_leaks || BPF_SRC ( insn -> code ) == BPF_K ) <S2SV_EndBug> <S2SV_StartBug> if ( aux -> alu_state && <S2SV_EndBug> <S2SV_StartBug> return - EACCES ; <S2SV_EndBug> ,"<S2SV_ModStart> can_skip_alu_sanitation ( env , insn ) <S2SV_ModEnd> <S2SV_ModStart> update_alu_sanitation_state ( aux , alu_state , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1062,"<S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_name ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_name ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_identifier ( tmp , & name , arena ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ","<S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>alias"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 <S2SV_ModEnd> <S2SV_ModStart> Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_asname , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; asname = NULL ; } else { int res ; <S2SV_ModStart> asname <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1063,"<S2SV_StartBug> offset += q -> buf_offset ; <S2SV_EndBug> <S2SV_StartBug> skb_add_rx_frag ( skb , skb_shinfo ( skb ) -> nr_frags , page , offset , len , <S2SV_EndBug> <S2SV_StartBug> q -> buf_size ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; if ( shinfo -> nr_frags < ARRAY_SIZE ( shinfo -> frags ) ) { <S2SV_ModStart> shinfo <S2SV_ModEnd> <S2SV_ModStart> } 
1064,"<S2SV_StartBug> int mutt_b64_decode ( char * out , const char * in ) <S2SV_EndBug> <S2SV_StartBug> * out ++ = ( base64val ( digit1 ) << 2 ) | ( base64val ( digit2 ) >> 4 ) ; <S2SV_EndBug> <S2SV_StartBug> * out ++ = ( ( base64val ( digit2 ) << 4 ) & 0xf0 ) | ( base64val ( digit3 ) >> 2 ) ; <S2SV_EndBug> <S2SV_StartBug> * out ++ = ( ( base64val ( digit3 ) << 6 ) & 0xc0 ) | base64val ( digit4 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , size_t olen <S2SV_ModStart> if ( len == olen ) return len ; <S2SV_ModStart> if ( len == olen ) return len ; <S2SV_ModStart> if ( len == olen ) return len ; "
1065,"<S2SV_StartBug> err = security_sb_remount ( sb , data ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NODEV ) && ! ( mnt_flags & MNT_NODEV ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOSUID ) && ! ( mnt_flags & MNT_NOSUID ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOEXEC ) && ! ( mnt_flags & MNT_NOEXEC ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_ATIME ) && ( ( mnt -> mnt . mnt_flags & MNT_ATIME_MASK ) != ( mnt_flags & MNT_ATIME_MASK ) ) ) { return - EPERM ; } 
1066,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> recovery_started = false ; 
1067,"<S2SV_StartBug> device = btrfs_find_device ( fs_info -> fs_devices , devid , NULL , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> , true "
1068,<S2SV_StartBug> for ( i = 0 ; i < planes ; i ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( ymax < avctx -> height ) 
1069,<S2SV_StartBug> if ( ( * name != '\\0' ) && ( * name != '#' ) ) <S2SV_EndBug> ,<S2SV_ModStart> count < 0 ) || ( ( size_t ) count > length ) ) { length = 0 ; continue ; } if ( ( 
1070,<S2SV_StartBug> port -> exists = false ; <S2SV_EndBug> <S2SV_StartBug> port -> serio = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> spin_lock_irq ( & i8042_lock ) ; <S2SV_ModStart> ; port -> serio = NULL ; spin_unlock_irq ( & i8042_lock ) <S2SV_ModStart>  <S2SV_ModEnd> 
1071,<S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( opened & FILE_OPENED ) ) { <S2SV_EndBug> ,<S2SV_ModStart> out2 <S2SV_ModEnd> <S2SV_ModStart> out2 : 
1072,"<S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1073,<S2SV_StartBug> while ( begin && isspace ( ( ut8 ) str [ * begin ] ) ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( isalpha ( ( ut8 ) str [ * begin ] ) ) { <S2SV_EndBug> <S2SV_StartBug> while ( end && isalnum ( ( ut8 ) str [ * end ] ) ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( isdigit ( ( ut8 ) str [ * begin ] ) ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( * begin > strlen ( str ) ) { return TT_EOF ; } <S2SV_ModStart> str [ * begin ] && <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> str [ * end ] && <S2SV_ModStart>  <S2SV_ModEnd> 
1074,"<S2SV_StartBug> int contentlen = 0 ; <S2SV_EndBug> <S2SV_StartBug> contentlen = atoi ( sb ) ; <S2SV_EndBug> <S2SV_StartBug> printstr ( & pp , ""<form<S2SV_blank>method=\\""POST\\""<S2SV_blank>action=\\""/U\\""><textarea<S2SV_blank>cols=\\""80\\""<S2SV_blank>rows=\\""30\\""<S2SV_blank>name=\\""conffile\\"">"" ) ; <S2SV_EndBug> <S2SV_StartBug> int l = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! writable || fseek ( writable , 0 , 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '+' , conf . timeouts [ STRING_S ] ) ) > 0 ) { <S2SV_EndBug> <S2SV_StartBug> buf [ i ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! error ) { <S2SV_EndBug> <S2SV_StartBug> l += i ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned <S2SV_ModEnd> <S2SV_ModStart> sscanf ( sb , ""%u"" , & contentlen ) ; if ( contentlen > LINESIZE * 1024 ) contentlen = 0 <S2SV_ModEnd> <S2SV_ModStart> ""<form<S2SV_blank>method=\\""POST\\""<S2SV_blank>action=\\""/U\\""<S2SV_blank>enctype=\\""application/x-www-form-urlencoded\\""><textarea<S2SV_blank>cols=\\""80\\""<S2SV_blank>rows=\\""30\\""<S2SV_blank>name=\\""conffile\\"">"" <S2SV_ModEnd> <S2SV_ModStart> unsigned <S2SV_ModEnd> <S2SV_ModStart> ! contentlen || <S2SV_ModStart> l < contentlen && <S2SV_ModStart> ( contentlen - l ) > <S2SV_ModStart> ? LINESIZE - 1 : contentlen - l <S2SV_ModStart> if ( ! l ) { if ( i < 9 || <S2SV_ModEnd> <S2SV_ModStart> buf [ i ] = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> "
1075,<S2SV_StartBug> struct mlx5_ib_create_qp_resp resp ; <S2SV_EndBug> ,<S2SV_ModStart> = { } 
1076,"<S2SV_StartBug> vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> const nmv_context * nmvc = & cm -> fc . nmvc ; <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE mode = mbmi -> mode ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , pred_flag , pred_prob ) ; <S2SV_EndBug> <S2SV_StartBug> skip = write_skip ( cpi , segment_id , mi , w ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , is_inter , vp9_get_intra_inter_prob ( cm , xd ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( skip || vp9_segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> write_selected_tx_size ( cpi , mbmi -> tx_size , bsize , w ) ; <S2SV_EndBug> <S2SV_StartBug> write_intra_mode ( w , mode , cm -> fc . y_mode_prob [ size_group_lookup [ bsize ] ] ) ; <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE b_mode = mi -> bmi [ idy * 2 + idx ] . as_mode ; <S2SV_EndBug> <S2SV_StartBug> write_intra_mode ( w , b_mode , cm -> fc . y_mode_prob [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> write_intra_mode ( w , mbmi -> uv_mode , cm -> fc . uv_mode_prob [ mode ] ) ; <S2SV_EndBug> <S2SV_StartBug> const int mode_ctx = mbmi -> mode_context [ mbmi -> ref_frame [ 0 ] ] ; <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * const inter_probs = cm -> fc . inter_mode_probs [ mode_ctx ] ; <S2SV_EndBug> <S2SV_StartBug> write_ref_frames ( cpi , w ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ) { <S2SV_EndBug> <S2SV_StartBug> ++ cm -> counts . inter_mode [ mode_ctx ] [ INTER_OFFSET ( mode ) ] ; <S2SV_EndBug> <S2SV_StartBug> cm -> fc . switchable_interp_prob [ ctx ] , <S2SV_EndBug> <S2SV_StartBug> & switchable_interp_encodings [ mbmi -> interp_filter ] ) ; <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE b_mode = mi -> bmi [ j ] . as_mode ; <S2SV_EndBug> <S2SV_StartBug> write_inter_mode ( w , b_mode , inter_probs ) ; <S2SV_EndBug> <S2SV_StartBug> & mbmi -> ref_mvs [ mbmi -> ref_frame [ ref ] ] [ 0 ] . as_mv , <S2SV_EndBug> <S2SV_StartBug> & mbmi -> ref_mvs [ mbmi -> ref_frame [ ref ] ] [ 0 ] . as_mv , nmvc , <S2SV_EndBug> ","<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> -> nmvc ; const MACROBLOCK * const x = & cpi -> td . <S2SV_ModEnd> <S2SV_ModStart> MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext ; const PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> cm , xd <S2SV_ModEnd> <S2SV_ModStart> segfeature_active <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> skip <S2SV_ModEnd> <S2SV_ModStart> cm , xd <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> mbmi_ext <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> cm , xd <S2SV_ModEnd> <S2SV_ModStart> segfeature_active <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> ; ++ cpi -> interp_filter_selected [ 0 ] [ mbmi -> interp_filter ] <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mbmi_ext <S2SV_ModEnd> <S2SV_ModStart> mbmi_ext <S2SV_ModEnd> "
1077,"<S2SV_StartBug> unsigned int len = sizeof ( * ctx ) + crypto_skcipher_reqsize ( private ) ; <S2SV_EndBug> <S2SV_StartBug> ctx -> iv = sock_kmalloc ( sk , crypto_skcipher_ivsize ( private ) , <S2SV_EndBug> <S2SV_StartBug> memset ( ctx -> iv , 0 , crypto_skcipher_ivsize ( private ) ) ; <S2SV_EndBug> <S2SV_StartBug> skcipher_request_set_tfm ( & ctx -> req , private ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct skcipher_tfm * tfm = private ; struct crypto_skcipher * skcipher = tfm -> skcipher ; <S2SV_ModStart> skcipher ) ; if ( ! tfm -> has_key ) return - ENOKEY <S2SV_ModEnd> <S2SV_ModStart> skcipher <S2SV_ModEnd> <S2SV_ModStart> skcipher ) ) ; INIT_LIST_HEAD ( & ctx -> tsgl ) ; ctx -> len = len ; ctx -> used = 0 ; ctx -> more = 0 ; ctx -> merge = 0 ; ctx -> enc = 0 ; atomic_set ( & ctx -> inflight , 0 ) ; af_alg_init_completion ( & ctx -> completion ) ; ask -> private <S2SV_ModEnd> <S2SV_ModStart> skcipher <S2SV_ModEnd> "
1078,"<S2SV_StartBug> while ( ( c != '\\n' ) && ( c != '\\0' ) ) <S2SV_EndBug> <S2SV_StartBug> ( void ) sscanf ( value , ""%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g"" , <S2SV_EndBug> <S2SV_StartBug> & white_point [ 0 ] , & white_point [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> ( void ) sscanf ( value , ""%d<S2SV_blank>+X<S2SV_blank>%d"" , & height , & width ) ; <S2SV_EndBug> <S2SV_StartBug> image -> rows = ( size_t ) height ; <S2SV_EndBug> ",<S2SV_ModStart> && ( c != EOF ) <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> == 8 ) { <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> == 2 ) { <S2SV_ModEnd> <S2SV_ModStart> } 
1079,"<S2SV_StartBug> return mutt_bcache_del ( bcache , id ) ; <S2SV_EndBug> ",<S2SV_ModStart> cache_id ( id ) <S2SV_ModEnd> 
1080,<S2SV_StartBug> uint16_t keylen ; <S2SV_EndBug> <S2SV_StartBug> uint16_t keylen ; <S2SV_EndBug> ,<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int <S2SV_ModEnd> 
1081,"<S2SV_StartBug> # define ThrowCUTReaderException ( severity , tag ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( severity , tag ) ; } <S2SV_EndBug> <S2SV_StartBug> offset = SeekBlob ( image , 6 , SEEK_SET ) ; <S2SV_EndBug> ","<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ; "
1082,"<S2SV_StartBug> NOEXPORT char * parse_global_option ( CMD cmd , char * opt , char * arg ) { <S2SV_EndBug> <S2SV_StartBug> new_global_options . chroot_dir = NULL ; <S2SV_EndBug> <S2SV_StartBug> tmp = global_options . chroot_dir ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . chroot_dir = str_dup ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . compression = COMP_NONE ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . compression = COMP_DEFLATE ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . compression = COMP_ZLIB ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . egd_sock = EGD_SOCKET ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . egd_sock = NULL ; <S2SV_EndBug> <S2SV_StartBug> tmp = global_options . egd_sock ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . egd_sock = str_dup ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . fips = 0 ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( ! strcasecmp ( arg , ""yes"" ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( ! strcasecmp ( arg , ""no"" ) ) <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . fips = 0 ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> # else <S2SV_EndBug> <S2SV_StartBug> case CMD_PRINT_DEFAULTS : <S2SV_EndBug> <S2SV_StartBug> s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>FIPS<S2SV_blank>140-2<S2SV_blank>mode"" , <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . foreground = 0 ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . log_stderr = 0 ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . foreground = 1 ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . log_stderr = 1 ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . foreground = 1 ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . log_stderr = 0 ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . foreground = 0 ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . log_stderr = 0 ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . icon [ ICON_ACTIVE ] = load_icon_default ( ICON_ACTIVE ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( new_global_options . icon [ ICON_ACTIVE ] = load_icon_file ( arg ) ) ) <S2SV_EndBug> <S2SV_StartBug> new_global_options . icon [ ICON_ERROR ] = load_icon_default ( ICON_ERROR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( new_global_options . icon [ ICON_ERROR ] = load_icon_file ( arg ) ) ) <S2SV_EndBug> <S2SV_StartBug> new_global_options . icon [ ICON_IDLE ] = load_icon_default ( ICON_IDLE ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( new_global_options . icon [ ICON_IDLE ] = load_icon_file ( arg ) ) ) <S2SV_EndBug> <S2SV_StartBug> new_global_options . log_file_mode = FILE_MODE_APPEND ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . log_file_mode = FILE_MODE_APPEND ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . log_file_mode = FILE_MODE_OVERWRITE ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . output_file = NULL ; <S2SV_EndBug> <S2SV_StartBug> tmp = global_options . output_file ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . output_file = str_dup ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! new_global_options . option . foreground && <S2SV_EndBug> <S2SV_StartBug> new_global_options . output_file && <S2SV_EndBug> <S2SV_StartBug> new_global_options . pidfile = NULL ; <S2SV_EndBug> <S2SV_StartBug> tmp = global_options . pidfile ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . pidfile = str_dup ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . pidfile = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ! new_global_options . option . foreground && <S2SV_EndBug> <S2SV_StartBug> new_global_options . pidfile && <S2SV_EndBug> <S2SV_StartBug> new_global_options . random_bytes = RANDOM_BYTES ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . random_bytes = ( long ) strtol ( arg , & tmp_str , 10 ) ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . rand_file = str_dup ( RANDOM_FILE ) ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . rand_file = NULL ; <S2SV_EndBug> <S2SV_StartBug> tmp = global_options . rand_file ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . rand_file = str_dup ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . rand_write = 1 ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . rand_write = 1 ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . rand_write = 0 ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . log_syslog = 1 ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . log_syslog = 1 ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . log_syslog = 0 ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . taskbar = 1 ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . taskbar = 1 ; <S2SV_EndBug> <S2SV_StartBug> new_global_options . option . taskbar = 0 ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( ssl_configure ( & new_global_options ) ) <S2SV_EndBug> ","<S2SV_ModStart> , GLOBAL_OPTIONS * options <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> chroot_dir ; options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> egd_sock ; options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> FIPS_mode ( ) ? 1 : <S2SV_ModStart> if ( ! strcasecmp ( arg , ""yes"" ) ) { <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> # else return ""FIPS<S2SV_blank>support<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available"" ; # endif } else <S2SV_ModEnd> <S2SV_ModStart> { # ifdef USE_FIPS if ( FIPS_mode ( ) ) return ""Failed<S2SV_blank>to<S2SV_blank>override<S2SV_blank>system-wide<S2SV_blank>FIPS<S2SV_blank>mode"" ; options -> <S2SV_ModEnd> <S2SV_ModStart> # endif } else { <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""fips"" , FIPS_mode ( ) ? ""yes"" : ""no"" ) ; # endif break ; case CMD_PRINT_HELP : # ifdef USE_FIPS s_log ( LOG_NOTICE , <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> output_file ; options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> output_file && options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> pidfile ; options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> pidfile && options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> rand_file ; options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> options -> <S2SV_ModEnd> <S2SV_ModStart> memset ( options , 0 , sizeof ( GLOBAL_OPTIONS ) ) ; <S2SV_ModStart> options <S2SV_ModEnd> "
1083,"<S2SV_StartBug> len = strlen ( ""/lock/lxc/"" ) + strlen ( n ) + strlen ( p ) + 3 ; <S2SV_EndBug> <S2SV_StartBug> ret = snprintf ( dest , len , ""%s/lock/lxc/%s"" , rundir , p ) ; <S2SV_EndBug> <S2SV_StartBug> int l2 = 22 + strlen ( n ) + strlen ( p ) ; <S2SV_EndBug> <S2SV_StartBug> free ( rundir ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""/lxc/lock/"" <S2SV_ModEnd> <S2SV_ModStart> ""%s/lxc/lock/%s"" <S2SV_ModEnd> <S2SV_ModStart> free ( dest ) ; free ( rundir ) ; return NULL ; } ret = snprintf ( dest , len , ""%s/lxc/lock/%s/.%s"" , rundir , p , n ) ; free ( rundir <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1084,"<S2SV_StartBug> void * data ) <S2SV_EndBug> <S2SV_StartBug> if ( ! se_dev -> dev_attrib . emulate_3pc ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> rc = memcmp ( & tmp_dev_wwn [ 0 ] , info -> dev_wwn , XCOPY_NAA_IEEE_REGEX_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc != 0 ) <S2SV_EndBug> <S2SV_StartBug> info -> found_dev = se_dev ; <S2SV_EndBug> <S2SV_StartBug> rc = target_depend_item ( & se_dev -> dev_group . cg_item ) ; <S2SV_EndBug> ","<S2SV_ModStart> const unsigned char * dev_wwn ) { <S2SV_ModEnd> <S2SV_ModStart> { pr_debug ( ""XCOPY:<S2SV_blank>emulate_3pc<S2SV_blank>disabled<S2SV_blank>on<S2SV_blank>se_dev<S2SV_blank>%p\\n"" , se_dev ) ; <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { pr_debug ( ""XCOPY:<S2SV_blank>skip<S2SV_blank>non-matching:<S2SV_blank>%*ph\\n"" , XCOPY_NAA_IEEE_REGEX_LEN , tmp_dev_wwn ) ; <S2SV_ModStart> } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1085,"<S2SV_StartBug> struct i2s_platform_data * i2s_pdata ; <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> <S2SV_StartBug> adev -> acp . acp_res = kcalloc ( 5 , sizeof ( struct resource ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> kfree ( adev -> acp . acp_cell ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> kfree ( adev -> acp . acp_res ) ; <S2SV_EndBug> <S2SV_StartBug> return r ; <S2SV_EndBug> <S2SV_StartBug> return r ; <S2SV_EndBug> <S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug> <S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> = NULL <S2SV_ModStart> { r = <S2SV_ModEnd> <S2SV_ModStart> goto failure ; } <S2SV_ModStart> r = <S2SV_ModEnd> <S2SV_ModStart> goto failure ; <S2SV_ModStart> r = - ENOMEM ; goto failure <S2SV_ModEnd> <S2SV_ModStart> goto failure <S2SV_ModEnd> <S2SV_ModStart> goto failure <S2SV_ModEnd> <S2SV_ModStart> r = - ETIMEDOUT ; goto failure <S2SV_ModEnd> <S2SV_ModStart> r = - ETIMEDOUT ; goto failure <S2SV_ModEnd> <S2SV_ModStart> failure : kfree ( i2s_pdata ) ; kfree ( adev -> acp . acp_res ) ; kfree ( adev -> acp . acp_cell ) ; kfree ( adev -> acp . acp_genpd ) ; return r ; 
1086,"<S2SV_StartBug> int old_bin_num , bin_num ; <S2SV_EndBug> <S2SV_StartBug> bin_num = ZEND_MM_SMALL_SIZE_TO_BIN ( size ) ; <S2SV_EndBug> <S2SV_StartBug> return ptr ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( size <= ZEND_MM_MAX_SMALL_SIZE ) { int <S2SV_ModStart> } 
1087,<S2SV_StartBug> coerce_reg_to_32 ( dst_reg ) ; <S2SV_EndBug> <S2SV_StartBug> coerce_reg_to_32 ( & src_reg ) ; <S2SV_EndBug> ,"<S2SV_ModStart> coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size <S2SV_ModEnd> <S2SV_ModStart> , 4 "
1088,<S2SV_StartBug> free ( p ) ; <S2SV_EndBug> ,<S2SV_ModStart> * pp = p -> next ; 
1089,"<S2SV_StartBug> struct oabi_flock64 user ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( & user , ( struct oabi_flock64 __user * ) arg , <S2SV_EndBug> <S2SV_StartBug> ret = sys_fcntl64 ( fd , cmd , local_arg ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return do_locks ( fd , cmd , arg ) ; default : return <S2SV_ModEnd> <S2SV_ModStart> arg <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1090,"<S2SV_StartBug> state -> frame [ 0 ] = kzalloc ( sizeof ( struct bpf_func_state ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> verbose ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n"" , <S2SV_EndBug> <S2SV_StartBug> env -> prev_insn_idx , env -> insn_idx ) ; <S2SV_EndBug> <S2SV_StartBug> verbose ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:"" , <S2SV_EndBug> <S2SV_StartBug> env -> prev_insn_idx , env -> insn_idx ) ; <S2SV_EndBug> ","<S2SV_ModStart> speculative = false ; state -> <S2SV_ModStart> ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d%s:<S2SV_blank>safe\\n"" <S2SV_ModEnd> <S2SV_ModStart> , env -> cur_state -> speculative ? ""<S2SV_blank>(speculative<S2SV_blank>execution)"" : """" <S2SV_ModStart> ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d%s:"" <S2SV_ModEnd> <S2SV_ModStart> , env -> cur_state -> speculative ? ""<S2SV_blank>(speculative<S2SV_blank>execution)"" : """" "
1091,"<S2SV_StartBug> input = xmlNewEntityInputStream ( ctxt , entity ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) && ( ( ctxt -> options & XML_PARSE_NOENT ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDVALID ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDLOAD ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDATTR ) == 0 ) && ( ctxt -> replaceEntities == 0 ) && ( ctxt -> validate == 0 ) ) return ; 
1092,"<S2SV_StartBug> static void dist_block ( int plane , int block , TX_SIZE tx_size , <S2SV_EndBug> <S2SV_StartBug> struct rdcost_block_args * args ) { <S2SV_EndBug> <S2SV_StartBug> const int ss_txfrm_size = tx_size << 1 ; <S2SV_EndBug> <S2SV_StartBug> int16_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> args -> dist = vp9_block_error ( coeff , dqcoeff , 16 << ss_txfrm_size , <S2SV_EndBug> <S2SV_StartBug> & this_sse ) >> shift ; <S2SV_EndBug> <S2SV_StartBug> ( 1 << ss_txfrm_size ) ) >> ( shift + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> args -> sse += p ; <S2SV_EndBug> ","<S2SV_ModStart> MACROBLOCK * x , <S2SV_ModStart> int64_t * out_dist , int64_t * out_sse <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH const int bd = ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) ? xd -> bd : 8 ; * out_dist = vp9_highbd_block_error <S2SV_ModEnd> <S2SV_ModStart> , bd ) >> shift ; # else * out_dist = vp9_block_error ( coeff , dqcoeff , 16 << ss_txfrm_size , & this_sse ) >> shift ; # endif * out_sse <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH <S2SV_ModStart> + ( bd - 8 ) * 2 ) ; # else ( shift + 2 ) ; # endif * out_dist <S2SV_ModEnd> <S2SV_ModStart> * out_sse <S2SV_ModEnd> "
1093,"<S2SV_StartBug> ""The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request:<S2SV_blank>%s"" , <S2SV_EndBug> ","<S2SV_ModStart> ""The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request"" ) , <S2SV_ModEnd> "
1094,<S2SV_StartBug> ps_dec -> u4_cur_bs_mb_num = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> = 0 ; ps_dec -> u4_start_recon_deblk 
1095,<S2SV_StartBug> unix_inflight ( scm -> fp -> fp [ i ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> user , scm -> fp -> "
1096,<S2SV_StartBug> static int cipso_v4_delopt ( struct ip_options * * opt_ptr ) <S2SV_EndBug> <S2SV_StartBug> struct ip_options * opt = * opt_ptr ; <S2SV_EndBug> <S2SV_StartBug> if ( opt -> srr || opt -> rr || opt -> ts || opt -> router_alert ) { <S2SV_EndBug> <S2SV_StartBug> cipso_off = opt -> cipso - sizeof ( struct iphdr ) ; <S2SV_EndBug> <S2SV_StartBug> cipso_ptr = & opt -> __data [ cipso_off ] ; <S2SV_EndBug> <S2SV_StartBug> if ( opt -> srr > opt -> cipso ) <S2SV_EndBug> <S2SV_StartBug> if ( opt -> rr > opt -> cipso ) <S2SV_EndBug> <S2SV_StartBug> if ( opt -> ts > opt -> cipso ) <S2SV_EndBug> <S2SV_StartBug> if ( opt -> router_alert > opt -> cipso ) <S2SV_EndBug> <S2SV_StartBug> opt -> cipso = 0 ; <S2SV_EndBug> <S2SV_StartBug> opt -> optlen - cipso_off - cipso_len ) ; <S2SV_EndBug> <S2SV_StartBug> while ( iter < opt -> optlen ) <S2SV_EndBug> <S2SV_StartBug> iter += opt -> __data [ iter + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> hdr_delta = opt -> optlen ; <S2SV_EndBug> <S2SV_StartBug> hdr_delta -= opt -> optlen ; <S2SV_EndBug> <S2SV_StartBug> hdr_delta = opt -> optlen ; <S2SV_EndBug> ,"<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> opt . cipso ) opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . cipso ) opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . cipso ) opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . cipso ) opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> opt . optlen ) if ( opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . optlen ; opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . optlen ; call_rcu ( & opt -> rcu , opt_kfree_rcu <S2SV_ModEnd> "
1097,"<S2SV_StartBug> char * command , * args = value ; <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> if ( size == PAGE_SIZE ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> args [ size ] = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( name , ""current"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( command , ""permhat"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( name , ""exec"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> aad . error = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> ","<S2SV_ModStart> largs = NULL , * <S2SV_ModStart> ; if ( current != task ) return - EACCES <S2SV_ModStart> largs = args = kmalloc ( size + 1 , GFP_KERNEL ) ; if ( ! args <S2SV_ModEnd> <S2SV_ModStart> ENOMEM ; memcpy ( args , value , size ) ; args [ size ] = '\\0' ; } error = - <S2SV_ModStart> = strim ( args ) ; command = strsep ( & args , ""<S2SV_blank>"" ) ; if ( ! args ) goto out ; args = skip_spaces ( args ) ; if ( ! * args ) goto out ; arg_size = size - ( args - ( char * ) value ) ; if ( strcmp ( name , ""current"" ) == 0 ) { if ( strcmp ( command , ""changehat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permhat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , ""changeprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else goto fail ; } else <S2SV_ModEnd> <S2SV_ModStart> ""exec"" ) == 0 ) { if ( strcmp ( command , ""exec"" ) == 0 ) error = aa_setprocattr_changeprofile ( args , AA_ONEXEC <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! error ) error = size ; out : kfree ( largs ) <S2SV_ModEnd> <S2SV_ModStart> error = <S2SV_ModStart> goto out <S2SV_ModEnd> "
1098,<S2SV_StartBug> long timeo ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1099,"<S2SV_StartBug> void vp9_write_prob_diff_update ( vp9_writer * w , vp9_prob newp , vp9_prob oldp ) { <S2SV_EndBug> ","<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> vpx_prob newp , vpx_prob <S2SV_ModEnd> "
1100,"<S2SV_StartBug> static int getnum ( lua_State * L , const char * * fmt , int df ) { <S2SV_EndBug> <S2SV_StartBug> if ( a > ( INT_MAX / 10 ) || a * 10 > ( INT_MAX - ( * * fmt - '0' ) ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1101,<S2SV_StartBug> usb_kill_urb ( mixer -> urb ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( mixer -> disconnected ) return ; if ( mixer -> urb ) <S2SV_ModStart> if ( mixer -> rc_urb ) <S2SV_ModStart> mixer -> disconnected = true ; 
1102,"<S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> <S2SV_StartBug> pr_err ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> 
1103,"<S2SV_StartBug> memcpy ( ie -> ie_buffer + le16_to_cpu ( ie -> ie_length ) , <S2SV_EndBug> ",<S2SV_ModStart> if ( le16_to_cpu ( ie -> ie_length ) + vs_ie -> len + 2 > IEEE_MAX_IE_SIZE ) return - EINVAL ; 
1104,"<S2SV_StartBug> ssize_t ret = write ( uart_fd , data + transmitted_length , length ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1105,<S2SV_StartBug> evtchn_to_irq [ row ] [ col ] = - 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> WRITE_ONCE ( <S2SV_ModStart> , - 1 ) <S2SV_ModEnd> "
1106,"<S2SV_StartBug> CALL_AND_WAIT ( error = bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> ",<S2SV_ModStart> false 
1107,"<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""\\nStream<S2SV_blank>timebase<S2SV_blank>(--timebase):\\n"" <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < get_vpx_encoder_count ( ) ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-6s<S2SV_blank>-<S2SV_blank>%s\\n"" , <S2SV_EndBug> <S2SV_StartBug> encoder -> name , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> void <S2SV_ModStart> ; const int num_encoder = get_vpx_encoder_count ( ) <S2SV_ModStart> # if CONFIG_VP10_ENCODER fprintf ( stderr , ""\\nVP10<S2SV_blank>Specific<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , vp10_args ) ; # endif <S2SV_ModStart> num_encoder <S2SV_ModEnd> <S2SV_ModStart> const char * defstr = ( i == ( num_encoder - 1 ) ) ? ""(default)"" : """" ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-6s<S2SV_blank>-<S2SV_blank>%s<S2SV_blank>%s\\n"" <S2SV_ModEnd> <S2SV_ModStart> codec_interface ( ) ) , defstr <S2SV_ModEnd> <S2SV_ModStart> fprintf ( stderr , ""\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ; fprintf ( stderr , ""Use<S2SV_blank>--codec<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>a<S2SV_blank>non-default<S2SV_blank>encoder.\\n\\n"" ) ; "
1108,"<S2SV_StartBug> ( void ) memmove ( cp , cp + 2 , strlen ( file ) - 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> cp <S2SV_ModEnd> 
1109,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( clk_src ) ; 
1110,<S2SV_StartBug> if ( ! ( buf = g_try_malloc ( size ) ) ) { <S2SV_EndBug> ,<S2SV_ModStart> g_try_malloc0 <S2SV_ModEnd> 
1111,<S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> if ( j >= MAX_REF_BUFS ) { ALOGE ( ""b/25818142"" ) ; android_errorWriteLog ( 0x534e4554 , ""25818142"" ) ; ps_dpb_cmds -> u1_num_of_commands = 0 ; return - 1 ; } "
1112,<S2SV_StartBug> read_lock ( & evtchn_rwlock ) ; <S2SV_EndBug> <S2SV_StartBug> xen_evtchn_handle_events ( cpu ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> struct evtchn_loop_ctrl ctrl = { 0 } ; <S2SV_ModStart> , & ctrl <S2SV_ModStart> __this_cpu_inc ( irq_epoch ) ; "
1113,<S2SV_StartBug> length = 1 ; <S2SV_EndBug> <S2SV_StartBug> else if ( header -> flags & TCP_FLAG_FIN ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } else { length = queueItem -> length ; } <S2SV_ModEnd> 
1114,<S2SV_StartBug> struct user_struct * user = group -> inotify_data . user ; <S2SV_EndBug> <S2SV_StartBug> atomic_dec ( & user -> inotify_devs ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1115,"<S2SV_StartBug> atomic_set ( & new -> count , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! atomic_add_unless ( & ucounts -> count , 1 , INT_MAX ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> == INT_MAX ) ucounts = NULL ; else ucounts -> count += 1 <S2SV_ModEnd> 
1116,"<S2SV_StartBug> mark_desktop_file_trusted ( job , <S2SV_EndBug> ",<S2SV_ModStart> mark_desktop_file_executable <S2SV_ModEnd> 
1117,<S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( ! try_get_page ( page ) ) ) { spin_unlock ( ptl ) ; return ERR_PTR ( - ENOMEM ) ; } <S2SV_ModEnd> 
1118,"<S2SV_StartBug> case 0 : <S2SV_EndBug> <S2SV_StartBug> ( intmax_t ) rsrc -> uncompressed_size ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( mp , p , bytes_avail ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( rsrc -> uncompressed_size != rsrc -> compressed_size ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Malformed<S2SV_blank>OS<S2SV_blank>X<S2SV_blank>metadata<S2SV_blank>entry:<S2SV_blank>inconsistent<S2SV_blank>size"" ) ; return ( ARCHIVE_FATAL ) ; } <S2SV_ModStart> ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> compressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes"" , ( intmax_t ) rsrc -> compressed_size <S2SV_ModStart> if ( ( size_t ) bytes_avail > metadata_bytes ) bytes_avail = metadata_bytes ; "
1119,"<S2SV_StartBug> jas_eprintf ( ""warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> jas_eprintf ( ""warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(IHDR)\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> dec -> image ) ) ) { <S2SV_EndBug> <S2SV_StartBug> jas_eprintf ( ""warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(BPCC)\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""error:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch<S2SV_blank>(IHDR)\\n"" ) ; goto error <S2SV_ModEnd> <S2SV_ModStart> ""error:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(IHDR)\\n"" ) ; goto error <S2SV_ModEnd> <S2SV_ModStart> dec -> image ) ) ) { jas_eprintf ( ""error:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch<S2SV_blank>(BPCC)\\n"" ) ; goto error <S2SV_ModEnd> <S2SV_ModStart> ""error:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(BPCC)\\n"" ) ; goto error <S2SV_ModEnd> "
1120,<S2SV_StartBug> char lowstr [ MAXDATELEN + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> ,<S2SV_ModStart> MAXDATEFIELDS <S2SV_ModEnd> <S2SV_ModStart> > MAXDATELEN <S2SV_ModEnd> 
1121,"<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <S2SV_EndBug> ","<S2SV_ModStart> result ; int <S2SV_ModStart> result = <S2SV_ModEnd> <S2SV_ModStart> ; if ( result < 0 ) js_error ( J , ""regexec<S2SV_blank>failed"" ) ; if ( result == 0 "
1122,"<S2SV_StartBug> if ( ( event -> sigev_notify & SIGEV_THREAD_ID ) && <S2SV_EndBug> <S2SV_StartBug> ( ! ( rtn = find_task_by_vpid ( event -> sigev_notify_thread_id ) ) || <S2SV_EndBug> <S2SV_StartBug> ! same_thread_group ( rtn , current ) || <S2SV_EndBug> <S2SV_StartBug> if ( ( ( event -> sigev_notify & ~ SIGEV_THREAD_ID ) != SIGEV_NONE ) && <S2SV_EndBug> <S2SV_StartBug> ( ( event -> sigev_signo <= 0 ) || ( event -> sigev_signo > SIGRTMAX ) ) ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> switch <S2SV_ModEnd> <S2SV_ModStart> ) { case SIGEV_SIGNAL | SIGEV_THREAD_ID : <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! rtn <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> case SIGEV_SIGNAL : case SIGEV_THREAD : if <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> case SIGEV_NONE : <S2SV_ModStart> default : return NULL ; } 
1123,"<S2SV_StartBug> # ifdef __linux__ <S2SV_EndBug> <S2SV_StartBug> sun . sun_path [ 0 ] = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> sun_len = offsetof ( struct sockaddr_un , sun_path ) + strlen ( path ) + 1 ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sizeof <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> 
1124,<S2SV_StartBug> local_vec = ( struct rds_iovec __user * ) ( unsigned long ) args -> local_vec_addr ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( args -> nr_local == 0 ) return - EINVAL 
1125,"<S2SV_StartBug> vpx_memset ( ybf , 0 , sizeof ( YV12_BUFFER_CONFIG ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> 
1126,"<S2SV_StartBug> headerMergeLegacySigs ( h , sigh ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( <S2SV_ModStart> , & msg ) ) goto exit <S2SV_ModEnd> "
1127,<S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! head -> dev ) <S2SV_EndBug> <S2SV_StartBug> if ( qp -> user == IP_DEFRAG_CONNTRACK_IN && ! skb_dst ( head ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> const struct iphdr * iph ; int err ; <S2SV_ModStart> ) goto out_rcu_unlock ; skb_dst_drop ( head ) ; iph = ip_hdr ( head ) ; err = ip_route_input_noref ( head , iph -> daddr , iph -> saddr , iph -> tos , head -> dev ) ; if ( err <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1128,"<S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> <S2SV_StartBug> coerce_reg_to_size ( & src_reg , 4 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( insn_bitness == 32 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } <S2SV_ModStart>  <S2SV_ModEnd> "
1129,"<S2SV_StartBug> for ( ac = 0 ; ac < IEEE80211_NUM_ACS ; ac ++ ) { <S2SV_EndBug> <S2SV_StartBug> ieee80211_add_pending_skbs_fn ( local , & pending , clear_sta_ps_flags , sta ) ; <S2SV_EndBug> ",<S2SV_ModStart> spin_lock ( & sta -> ps_lock ) ; <S2SV_ModStart> ) ; spin_unlock ( & sta -> ps_lock 
1130,"<S2SV_StartBug> cJSON_AddIntToObject ( test -> json_start , ""tcp_mss"" , test -> settings -> mss ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddIntToObject ( test -> json_start , ""tcp_mss_default"" , opt ) ; <S2SV_EndBug> ",<S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> <S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> 
1131,<S2SV_StartBug> ret = fscrypt_get_crypt_info ( dir ) ; <S2SV_EndBug> ,<S2SV_ModStart> fscrypt_get_encryption_info <S2SV_ModEnd> 
1132,<S2SV_StartBug> if ( nh . nh_type == 1 && i == 0 ) <S2SV_EndBug> ,<S2SV_ModStart> len > 1024 || len < 0 ) continue ; if ( 
1133,"<S2SV_StartBug> static void send ( node_t * node , node_t * child , byte * fout ) { <S2SV_EndBug> <S2SV_StartBug> send ( node -> parent , node , fout ) ; <S2SV_EndBug> <S2SV_StartBug> if ( child ) { <S2SV_EndBug> ","<S2SV_ModStart> , int maxoffset <S2SV_ModStart> , maxoffset <S2SV_ModStart> if ( bloc >= maxoffset ) { bloc = maxoffset + 1 ; return ; } "
1134,"<S2SV_StartBug> BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; memset ( la , 0 , sizeof ( struct sockaddr_l2 ) "
1135,"<S2SV_StartBug> if ( js_regexec ( re -> prog , text , & m , 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <S2SV_EndBug> ","<S2SV_ModStart> js_doregexec ( J , <S2SV_ModEnd> <S2SV_ModStart> js_doregexec ( J , <S2SV_ModEnd> "
1136,"<S2SV_StartBug> if ( ! file || ( iovcnt && ! iov ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_sync ( iov , iovcnt , buf , buf_size ) != 0 ) <S2SV_EndBug> ","<S2SV_ModStart> size_t data_size = 0 ; <S2SV_ModStart> , & data_size <S2SV_ModStart> ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( "
1137,"<S2SV_StartBug> JSObjectRef globalobject ; <S2SV_EndBug> <S2SV_StartBug> globalobject = JSContextGetGlobalObject ( context ) ; <S2SV_EndBug> <S2SV_StartBug> JSObjectDeleteProperty ( context , globalobject , var_name , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1138,"<S2SV_StartBug> ut8 * directory_base ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( int ) obj -> hdr -> number_of_streams ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> entry = ( struct minidump_directory * ) ( directory_base + ( i * sizeof ( struct minidump_directory ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> r_bin_mdmp_init_directory_entry ( obj , entry ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct minidump_directory entry <S2SV_ModEnd> <S2SV_ModStart> ut64 rvadir = obj -> hdr -> stream_directory_rva ; <S2SV_ModStart> ut32 delta = <S2SV_ModEnd> <S2SV_ModStart> ; int r = r_buf_read_at ( obj -> b , rvadir + delta , ( ut8 * ) & entry , sizeof ( struct minidump_directory <S2SV_ModStart> if ( r ) { <S2SV_ModStart> & <S2SV_ModStart> } "
1139,<S2SV_StartBug> intra_pred_var = vp8_get_mb_ss ( x -> src_diff ) ; <S2SV_EndBug> ,<S2SV_ModStart> vpx_get_mb_ss <S2SV_ModEnd> 
1140,<S2SV_StartBug> ih264d_init_arch ( ps_dec ) ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( ps_dec -> ps_cur_slice , 0 , sizeof ( dec_slice_params_t ) ) ; "
1141,<S2SV_StartBug> if ( pin_code == NULL ) <S2SV_EndBug> ,<S2SV_ModStart> || pin_len > PIN_CODE_LEN 
1142,"<S2SV_StartBug> pathlen = get_node_path_locked ( node -> parent , buf , bufsize - namelen - 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart> 1 <S2SV_ModEnd> 
1143,"<S2SV_StartBug> ! DoReadFile ( infile , & ds64_chunk , chunk_header . ckSize , & bcount ) || <S2SV_EndBug> <S2SV_StartBug> bcount != chunk_header . ckSize ) { <S2SV_EndBug> <S2SV_StartBug> ! WavpackAddWrapper ( wpc , & ds64_chunk , chunk_header . ckSize ) ) { <S2SV_EndBug> ",<S2SV_ModStart> sizeof ( DS64Chunk ) <S2SV_ModEnd> <S2SV_ModStart> sizeof ( DS64Chunk ) <S2SV_ModEnd> <S2SV_ModStart> sizeof ( DS64Chunk ) <S2SV_ModEnd> 
1144,<S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart> else ( void ) cfg ; ( void ) mem_loc ; # 
1145,<S2SV_StartBug> unsigned long kflags = key -> flags ; <S2SV_EndBug> <S2SV_StartBug> if ( kflags & ( 1 << KEY_FLAG_NEGATIVE ) ) { <S2SV_EndBug> <S2SV_StartBug> ctx -> result = ERR_PTR ( key -> reject_error ) ; <S2SV_EndBug> ,<S2SV_ModStart> READ_ONCE ( key -> flags ) ; short state = READ_ONCE ( key -> state ) <S2SV_ModEnd> <S2SV_ModStart> state < 0 ) { <S2SV_ModEnd> <S2SV_ModStart> state <S2SV_ModEnd> 
1146,"<S2SV_StartBug> char b64 [ len + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> i_data = vlc_b64_decode_binary ( & p_orig , b64 ) ; <S2SV_EndBug> ",<S2SV_ModStart> * b64 = malloc ( <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( ! b64 ) return VLC_EGENERIC <S2SV_ModEnd> <S2SV_ModStart> b64 ) ; free ( 
1147,"<S2SV_StartBug> isoclns_print ( ndo , p - 1 , length + 1 , ndo -> ndo_snapend - p + 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; break ; case NLPID_SNAP : if ( snap_print ( ndo , p , length <S2SV_ModStart>  <S2SV_ModEnd> "
1148,<S2SV_StartBug> record = addStyleRecord ( shape ) ; <S2SV_EndBug> ,"<S2SV_ModStart> else if ( idx >= 255 && shape -> useVersion == SWF_SHAPE1 ) { SWF_error ( ""Too<S2SV_blank>many<S2SV_blank>fills<S2SV_blank>for<S2SV_blank>SWFShape<S2SV_blank>V1.\\n"" ""Use<S2SV_blank>a<S2SV_blank>higher<S2SV_blank>SWFShape<S2SV_blank>version\\n"" ) ; } "
1149,<S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> <S2SV_StartBug> if ( ! err ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && msg -> msg_name ) { struct sockaddr_at * sat = msg -> msg_name ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1150,"<S2SV_StartBug> umount_tree ( mnt , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ; umount_mnt ( p ) ; } } else "
1151,<S2SV_StartBug> if ( cpi -> common . frame_to_show ) <S2SV_EndBug> ,<S2SV_ModStart> ( void ) flags ; 
1152,"<S2SV_StartBug> rq = blk_mq_tag_to_rq ( hctx -> tags , off + bit ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> -> rqs [ <S2SV_ModEnd> <S2SV_ModStart> ] <S2SV_ModEnd> 
1153,<S2SV_StartBug> MODE new_qc = MODE_BESTQUALITY ; <S2SV_EndBug> <S2SV_StartBug> if ( deadline ) { <S2SV_EndBug> <S2SV_StartBug> ( uint64_t ) ctx -> cfg . g_timebase . num / <S2SV_EndBug> <S2SV_StartBug> ( uint64_t ) ctx -> cfg . g_timebase . den ; <S2SV_EndBug> <S2SV_StartBug> new_qc = ( deadline > duration_us ) ? MODE_GOODQUALITY : MODE_REALTIME ; <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> oxcf . mode != new_qc ) { <S2SV_EndBug> <S2SV_StartBug> ctx -> oxcf . mode = new_qc ; <S2SV_EndBug> ,<S2SV_ModStart> new_mode = BEST ; switch ( ctx -> cfg . g_pass ) { case VPX_RC_ONE_PASS : <S2SV_ModEnd> <S2SV_ModStart> > 0 ) { const vpx_codec_enc_cfg_t * const cfg = & ctx -> cfg ; <S2SV_ModEnd> <S2SV_ModStart> cfg -> <S2SV_ModEnd> <S2SV_ModStart> cfg -> <S2SV_ModEnd> <S2SV_ModStart> new_mode <S2SV_ModEnd> <S2SV_ModStart> GOOD : REALTIME ; } else { new_mode = BEST ; } break ; case VPX_RC_FIRST_PASS : break ; case VPX_RC_LAST_PASS : new_mode = deadline > 0 ? GOOD : BEST ; break ; } <S2SV_ModEnd> <S2SV_ModStart> new_mode <S2SV_ModEnd> <S2SV_ModStart> new_mode <S2SV_ModEnd> 
1154,"<S2SV_StartBug> static int get_minq_index ( double maxq , double x3 , double x2 , double x1 ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < QINDEX_RANGE ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( minqtarget <= vp9_convert_qindex_to_q ( i ) ) <S2SV_EndBug> <S2SV_StartBug> return i ; <S2SV_EndBug> ","<S2SV_ModStart> , vpx_bit_depth_t bit_depth <S2SV_ModStart> { <S2SV_ModStart> , bit_depth <S2SV_ModStart> } "
1155,<S2SV_StartBug> bmp_info . number_colors = ReadBlobLSBLong ( image ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; if ( bmp_info . number_colors > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" "
1156,"<S2SV_StartBug> struct strbuf * path , const char * component , <S2SV_EndBug> <S2SV_StartBug> finish_object ( obj , path , component , cb_data ) ; <S2SV_EndBug> <S2SV_StartBug> show_object_with_name ( stdout , obj , path , component ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> 
1157,"<S2SV_StartBug> const struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( np -> opt != NULL ) <S2SV_EndBug> <S2SV_StartBug> newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ; <S2SV_EndBug> <S2SV_StartBug> if ( newnp -> opt != NULL ) <S2SV_EndBug> <S2SV_StartBug> inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + <S2SV_EndBug> <S2SV_StartBug> newnp -> opt -> opt_flen ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; struct ipv6_txoptions * opt <S2SV_ModStart> opt = rcu_dereference <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( opt ) { <S2SV_ModEnd> <S2SV_ModStart> opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } <S2SV_ModEnd> <S2SV_ModStart> opt <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1158,<S2SV_StartBug> if ( SCTP_CID_SHUTDOWN_ACK == ch -> type ) <S2SV_EndBug> <S2SV_StartBug> ch = ( sctp_chunkhdr_t * ) ch_end ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( SCTP_CID_SHUTDOWN_ACK == ch -> type ) ootb_shut_ack = 1 ; if ( SCTP_CID_ABORT == ch -> type ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; if ( SCTP_CID_COOKIE_ACK == ch -> type ) ootb_cookie_ack = 1 ; if ( SCTP_CID_ERROR == ch -> type ) { sctp_walk_errors ( err , ch ) { if ( SCTP_ERROR_STALE_COOKIE == err -> cause ) { ootb_cookie_ack = 1 ; break ; } } } "
1159,"<S2SV_StartBug> up_read ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_TLV , & kctl -> id ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct snd_ctl_elem_id id = kctl -> id ; <S2SV_ModStart>  <S2SV_ModEnd> 
1160,"<S2SV_StartBug> printf ( ""%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%u<S2SV_blank>sectors)\\n"" , fs -> fat_size , <S2SV_EndBug> <S2SV_StartBug> fs -> fat_size / lss ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%10lld<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%llu<S2SV_blank>sectors)\\n"" , ( long long ) <S2SV_ModEnd> <S2SV_ModStart> ( long long ) "
1161,"<S2SV_StartBug> if ( copy_from_user ( & u_ent . id , & uent -> id , sizeof ( u_ent . id ) ) ) <S2SV_EndBug> ","<S2SV_ModStart> memset ( & u_ent , 0 , sizeof ( u_ent ) ) ; "
1162,"<S2SV_StartBug> unsigned int maxw , maxh , max , i ; <S2SV_EndBug> <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> ",<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> img -> color_space = OPJ_CLRSPC_SRGB ; <S2SV_ModStart> free ( r ) ; free ( g ) ; <S2SV_ModEnd> 
1163,"<S2SV_StartBug> sync . clock_rate = FST_RDL ( card , portConfig [ i ] . lineSpeed ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( & sync , 0 , sizeof ( sync ) ) ; "
1164,"<S2SV_StartBug> int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ; <S2SV_EndBug> <S2SV_StartBug> f -> colorspace = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( f -> version > 0 ) <S2SV_EndBug> <S2SV_StartBug> f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> chroma_planes = get_rac ( c , state ) ; <S2SV_EndBug> <S2SV_StartBug> chroma_h_shift = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( chroma_planes != f -> chroma_planes <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , colorspace , bits_per_raw_sample <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> bits_per_raw_sample = <S2SV_ModEnd> <S2SV_ModStart> ? get_symbol ( c , state , 0 ) : <S2SV_ModEnd> <S2SV_ModStart> ; chroma_planes = get_rac ( c , state ) ; chroma_h_shift <S2SV_ModStart> chroma_v_shift = get_symbol ( c , state , 0 ) ; transparency <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> colorspace != f -> colorspace || bits_per_raw_sample != f -> avctx -> bits_per_raw_sample || <S2SV_ModStart> f -> colorspace = colorspace ; f -> avctx -> bits_per_raw_sample = bits_per_raw_sample ; "
1165,<S2SV_StartBug> struct fscrypt_info * ci = inode -> i_crypt_info ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ci || <S2SV_EndBug> ,"<S2SV_ModStart> crypt_info ; struct fscrypt_context ctx ; struct crypto_skcipher * ctfm ; const char * cipher_str ; int keysize ; u8 * raw_key = NULL ; int res ; if ( <S2SV_ModEnd> <S2SV_ModStart> ) return 0 ; res = fscrypt_initialize ( inode -> i_sb -> s_cop -> flags ) ; if ( res ) return res <S2SV_ModStart> inode -> i_sb -> s_cop -> get_context ) return - EOPNOTSUPP ; res = inode -> i_sb -> s_cop -> get_context ( inode , & ctx , sizeof ( ctx ) ) ; if ( res < 0 ) { if ( ! fscrypt_dummy_context_enabled ( inode ) || inode -> i_sb -> s_cop -> is_encrypted ( inode ) ) return res ; memset ( & ctx , 0 , sizeof ( ctx ) ) ; ctx . format = FS_ENCRYPTION_CONTEXT_FORMAT_V1 ; ctx . contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS ; ctx . filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS ; memset ( ctx . master_key_descriptor , 0x42 , FS_KEY_DESCRIPTOR_SIZE ) ; } else if ( res != sizeof ( ctx ) ) { return - EINVAL ; } if ( ctx . format != FS_ENCRYPTION_CONTEXT_FORMAT_V1 ) return - EINVAL ; if ( ctx . flags & ~ FS_POLICY_FLAGS_VALID ) return - EINVAL ; crypt_info = kmem_cache_alloc ( fscrypt_info_cachep , GFP_NOFS ) ; if ( ! crypt_info ) return - ENOMEM ; crypt_info -> ci_flags = ctx . flags ; crypt_info -> ci_data_mode = ctx . contents_encryption_mode ; crypt_info -> ci_filename_mode = ctx . filenames_encryption_mode ; crypt_info -> ci_ctfm = NULL ; memcpy ( crypt_info -> ci_master_key , ctx . master_key_descriptor , sizeof ( crypt_info -> ci_master_key ) ) ; res = determine_cipher_type ( crypt_info , inode , & cipher_str , & keysize ) ; if ( res ) goto out ; res = - ENOMEM ; raw_key = kmalloc ( FS_MAX_KEY_SIZE , GFP_NOFS ) ; if ( ! raw_key ) goto out ; res = validate_user_key ( crypt_info , & ctx , raw_key , FS_KEY_DESC_PREFIX ) ; if ( res && inode -> i_sb -> s_cop -> key_prefix ) { int res2 = validate_user_key ( crypt_info , & ctx , raw_key , inode -> i_sb -> s_cop -> key_prefix ) ; if ( res2 ) { if ( res2 == - ENOKEY ) res = - ENOKEY ; goto out ; } } else if ( res ) { goto out ; } ctfm = crypto_alloc_skcipher ( cipher_str , 0 , 0 ) ; if ( ! ctfm || IS_ERR ( ctfm ) ) { res = ctfm ? PTR_ERR ( ctfm ) : - ENOMEM ; printk ( KERN_DEBUG ""%s:<S2SV_blank>error<S2SV_blank>%d<S2SV_blank>(inode<S2SV_blank>%u)<S2SV_blank>allocating<S2SV_blank>crypto<S2SV_blank>tfm\\n"" , __func__ , res , ( unsigned ) inode -> i_ino ) ; goto out ; } crypt_info -> ci_ctfm = ctfm ; crypto_skcipher_clear_flags ( ctfm , ~ 0 ) ; crypto_skcipher_set_flags ( ctfm , CRYPTO_TFM_REQ_WEAK_KEY ) ; res = crypto_skcipher_setkey ( ctfm , raw_key , keysize ) ; if ( res ) goto out ; if ( cmpxchg ( & inode -> i_crypt_info , NULL , crypt_info ) == NULL ) crypt_info = NULL ; out : if ( res == - ENOKEY ) res = 0 ; put_crypt_info ( crypt_info ) ; kzfree ( raw_key ) ; return res <S2SV_ModEnd> "
1166,"<S2SV_StartBug> static void update_skip_probs ( VP9_COMMON * cm , vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> vp9_cond_prob_diff_update ( w , & cm -> fc . skip_probs [ k ] , cm -> counts . skip [ k ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_writer * w , FRAME_COUNTS * counts <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> "
1167,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1168,<S2SV_StartBug> touch_atime ( & path ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! IS_ERR ( raw ) ) 
1169,"<S2SV_StartBug> if ( ! state ) <S2SV_EndBug> <S2SV_StartBug> screen = vterm_allocator_malloc ( vt , sizeof ( VTermScreen ) ) ; <S2SV_EndBug> <S2SV_StartBug> vterm_state_set_callbacks ( screen -> state , & state_cbs , screen ) ; <S2SV_EndBug> ",<S2SV_ModStart> state == NULL <S2SV_ModEnd> <S2SV_ModStart> ; if ( screen == NULL ) return NULL <S2SV_ModStart> if ( screen -> buffer == NULL || screen -> sb_buffer == NULL ) { vterm_screen_free ( screen ) ; return NULL ; } 
1170,"<S2SV_StartBug> list_add ( & mnt -> mnt_list , & new_ns -> list ) ; <S2SV_EndBug> ",<S2SV_ModStart> new_ns -> mounts ++ ; 
1171,"<S2SV_StartBug> memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( len < j + msg -> len + 1 ) { LM_ERR ( ""not<S2SV_blank>enough<S2SV_blank>space<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>sip<S2SV_blank>message\\n"" ) ; return - 1 ; } "
1172,<S2SV_StartBug> msg -> msg_namelen = sizeof ( * sipx ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( sipx ) { sipx -> sipx_family = AF_IPX ; sipx -> sipx_port = ipx -> ipx_source . sock ; memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ) ; sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net ; sipx -> sipx_type = ipx -> ipx_type ; sipx -> sipx_zero = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> "
1173,<S2SV_StartBug> vhost_net_ubuf_put_and_wait ( oldubufs ) ; <S2SV_EndBug> <S2SV_StartBug> vhost_net_ubuf_put_and_wait ( ubufs ) ; <S2SV_EndBug> ,<S2SV_ModStart> vhost_net_ubuf_put_wait_and_free <S2SV_ModEnd> <S2SV_ModStart> vhost_net_ubuf_put_wait_and_free <S2SV_ModEnd> 
1174,"<S2SV_StartBug> size_t buf_size = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_sync ( iov , iovcnt , buf , buf_size ) != 0 ) <S2SV_EndBug> ","<S2SV_ModStart> = 0 ; size_t data_size <S2SV_ModStart> , & data_size <S2SV_ModStart> ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( "
1175,<S2SV_StartBug> str_free ( b64 ) ; <S2SV_EndBug> ,<S2SV_ModStart> BIO_free <S2SV_ModEnd> 
1176,"<S2SV_StartBug> JAS_DBGLOG ( 101 , ( ""jas_malloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%zu\\n"" , size ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""jas_malloc(%zu)\\n"" <S2SV_ModEnd> "
1177,<S2SV_StartBug> len = INT_MAX ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( unlikely ( ! access_ok ( VERIFY_READ , buff , len ) ) ) return - EFAULT "
1178,"<S2SV_StartBug> err = ops -> ieee_getets ( netdev , & ets ) ; <S2SV_EndBug> <S2SV_StartBug> err = ops -> ieee_getmaxrate ( netdev , & maxrate ) ; <S2SV_EndBug> <S2SV_StartBug> struct ieee_pfc pfc ; <S2SV_EndBug> <S2SV_StartBug> err = ops -> ieee_peer_getets ( netdev , & ets ) ; <S2SV_EndBug> <S2SV_StartBug> struct ieee_pfc pfc ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( & ets , 0 , sizeof ( ets ) ) ; <S2SV_ModStart> memset ( & maxrate , 0 , sizeof ( maxrate ) ) ; <S2SV_ModStart> ; memset ( & pfc , 0 , sizeof ( pfc ) ) <S2SV_ModStart> memset ( & ets , 0 , sizeof ( ets ) ) ; <S2SV_ModStart> ; memset ( & pfc , 0 , sizeof ( pfc ) ) "
1179,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1180,<S2SV_StartBug> c -> req -> res = NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> memcpy ( c -> req -> remote , c -> remote , sizeof ( c -> remote ) ) ; "
1181,<S2SV_StartBug> WORD32 ret ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1182,<S2SV_StartBug> if ( ctx -> state == BODY_CHUNK_END ) { <S2SV_EndBug> <S2SV_StartBug> ctx -> state = BODY_CHUNK ; <S2SV_EndBug> <S2SV_StartBug> return APR_EGENERAL ; <S2SV_EndBug> <S2SV_StartBug> ctx -> chunkbits = sizeof ( long ) * 8 ; <S2SV_EndBug> <S2SV_StartBug> if ( c == ';' || c == CR ) { <S2SV_EndBug> <S2SV_StartBug> else if ( c == LF ) { <S2SV_EndBug> <S2SV_StartBug> int xvalue = 0 ; <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> return APR_EGENERAL ; <S2SV_EndBug> <S2SV_StartBug> ctx -> chunkbits -= 4 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> || ctx -> state == BODY_CHUNK_END_LF <S2SV_ModStart> ; } else if ( c == CR && ctx -> state == BODY_CHUNK_END ) { ctx -> state = BODY_CHUNK_END_LF ; } else { return APR_EINVAL <S2SV_ModStart> APR_EINVAL <S2SV_ModEnd> <S2SV_ModStart> apr_off_t <S2SV_ModEnd> <S2SV_ModStart> LF ) { if ( ctx -> remaining ) { ctx -> state = BODY_CHUNK_DATA ; } else { ctx -> state = BODY_CHUNK_TRAILER ; } } else if ( ctx -> state == BODY_CHUNK_LF ) { return APR_EINVAL ; } else if ( c == CR ) { ctx -> state = BODY_CHUNK_LF ; } else if ( c == ';' <S2SV_ModEnd> <S2SV_ModStart> ctx -> state == BODY_CHUNK_EXT ) { if ( c != '\\t' && apr_iscntrl ( c ) ) { return APR_EINVAL ; } } else if ( ctx -> state == BODY_CHUNK_PART <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; } ctx -> chunkbits -= 4 ; if ( ctx -> chunkbits < 0 ) { return APR_ENOSPC <S2SV_ModStart> APR_EINVAL <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> } else { return APR_EGENERAL ; 
1183,"<S2SV_StartBug> int net ; <S2SV_EndBug> <S2SV_StartBug> CLIENT * client ; <S2SV_EndBug> <S2SV_StartBug> if ( ( net = accept ( sock , ( struct sockaddr * ) & addrin , & addrinlen ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> client = negotiate ( net , NULL , servers , NEG_INIT | NEG_MODERN ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> handle_modern_connection ( servers , sock ) ; } for ( i = 0 ; i < servers -> len ; i ++ ) { int net ; SERVER * serve ; serve = & ( g_array_index ( servers , SERVER , i ) ) ; if ( serve -> socket < 0 ) { continue ; } if ( FD_ISSET ( serve -> socket , & rset ) ) { <S2SV_ModEnd> <S2SV_ModStart> serve -> socket <S2SV_ModEnd> <S2SV_ModStart> handle_connection ( servers , net , serve , NULL <S2SV_ModEnd> "
1184,"<S2SV_StartBug> ! CU_add_test ( pSuite , ""session_removed_closed_stream"" , <S2SV_EndBug> ","<S2SV_ModStart> ""session_too_many_settings"" , test_nghttp2_session_too_many_settings ) || ! CU_add_test ( pSuite , "
1185,<S2SV_StartBug> WORD32 slice_address ; <S2SV_EndBug> <S2SV_StartBug> slice_header_t * ps_slice_hdr_next ; <S2SV_EndBug> <S2SV_StartBug> ps_codec -> i4_slice_error = 1 ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ,<S2SV_ModStart> ; WORD32 prev_slice_incomplete_flag = 0 <S2SV_ModStart> prev_slice_incomplete_flag = 1 <S2SV_ModEnd> <S2SV_ModStart> prev_slice_incomplete_flag = 1 ; ASSERT ( ps_codec -> s_parse . i4_cur_slice_idx == 1 ) <S2SV_ModEnd> <S2SV_ModStart> if ( prev_slice_incomplete_flag ) { ps_codec -> i4_slice_error = 1 ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; } 
1186,"<S2SV_StartBug> eprintf ( ""Can\'t<S2SV_blank>find<S2SV_blank>debug<S2SV_blank>filename\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; return 1 ; } if ( ! is_valid_guid ( info -> guid ) ) { eprintf ( ""Invalid<S2SV_blank>GUID<S2SV_blank>for<S2SV_blank>file\\n"" "
1187,<S2SV_StartBug> if ( msg -> msg_name && msg -> msg_namelen > 0 ) <S2SV_EndBug> ,"<S2SV_ModStart> ) { size_t len = sizeof ( call -> conn -> trans -> peer -> srx ) ; memcpy ( msg -> msg_name , & call -> conn -> trans -> peer -> srx , len ) ; <S2SV_ModEnd> <S2SV_ModStart> = len ; } <S2SV_ModEnd> "
1188,"<S2SV_StartBug> virCheckDomainReturn ( dom , - 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; virCheckReadOnlyGoto ( dom -> conn -> flags , error "
1189,"<S2SV_StartBug> struct mount * n , * p ; <S2SV_EndBug> <S2SV_StartBug> if ( p == dest_master || IS_MNT_MARKED ( p ) ) { <S2SV_EndBug> ","<S2SV_ModStart> ; bool done <S2SV_ModStart> break ; } do { struct mount * parent = last_source -> mnt_parent ; if ( last_source == first_source ) break ; done = parent -> mnt_master == p ; if ( done && peers ( n , parent ) ) break ; last_source = last_source -> mnt_master ; } while ( ! done ) ; <S2SV_ModEnd> "
1190,<S2SV_StartBug> disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( ( ( how & UMOUNT_CONNECTED ) && mnt_has_parent ( p ) && ( p -> mnt_parent -> mnt . mnt_flags & MNT_UMOUNT ) ) || <S2SV_ModStart> ) 
1191,"<S2SV_StartBug> pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" <S2SV_EndBug> ",<S2SV_ModStart> pr_debug <S2SV_ModEnd> 
1192,"<S2SV_StartBug> static inline void jmp_rel ( struct x86_emulate_ctxt * ctxt , int rel ) <S2SV_EndBug> <S2SV_StartBug> assign_eip_near ( ctxt , ctxt -> _eip + rel ) ; <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return 
1193,"<S2SV_StartBug> struct ext4_extent * ex , newex , orig_ex ; <S2SV_EndBug> <S2SV_StartBug> struct ext4_extent * ex1 = NULL ; <S2SV_EndBug> <S2SV_StartBug> ext4_fsblk_t newblock ; <S2SV_EndBug> <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> eh = path [ depth ] . p_hdr ; <S2SV_EndBug> <S2SV_StartBug> newblock = map -> m_lblk - ee_block + ext4_ext_pblock ( ex ) ; <S2SV_EndBug> <S2SV_StartBug> may_zeroout = ee_block + ee_len <= eof_block ; <S2SV_EndBug> <S2SV_StartBug> if ( ee_len <= 2 * EXT4_EXT_ZERO_LEN && may_zeroout ) { <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_zeroout ( inode , & orig_ex ) ; <S2SV_EndBug> <S2SV_StartBug> goto fix_extent_len ; <S2SV_EndBug> <S2SV_StartBug> return allocated ; <S2SV_EndBug> <S2SV_StartBug> if ( allocated <= EXT4_EXT_ZERO_LEN && may_zeroout ) { <S2SV_EndBug> <S2SV_StartBug> ex -> ee_len = cpu_to_le16 ( ee_len - allocated ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ; <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_zeroout ( inode , & orig_ex ) ; <S2SV_EndBug> <S2SV_StartBug> goto fix_extent_len ; <S2SV_EndBug> <S2SV_StartBug> } else if ( err ) <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_zeroout ( inode , ex3 ) ; <S2SV_EndBug> <S2SV_StartBug> eh = path [ depth ] . p_hdr ; <S2SV_EndBug> <S2SV_StartBug> if ( err == - ENOSPC && may_zeroout ) { <S2SV_EndBug> <S2SV_StartBug> ext4_ext_show_leaf ( inode , path ) ; <S2SV_EndBug> <S2SV_StartBug> return err ? err : allocated ; <S2SV_EndBug> ","<S2SV_ModStart> ext4_map_blocks split_map ; struct ext4_extent zero_ex <S2SV_ModEnd> <S2SV_ModStart> ex <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> split_flag = 0 <S2SV_ModEnd> <S2SV_ModStart> ex <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> WARN_ON ( map -> m_lblk < ee_block ) ; split_flag |= <S2SV_ModEnd> <S2SV_ModStart> ? EXT4_EXT_MAY_ZEROOUT : 0 <S2SV_ModEnd> <S2SV_ModStart> ( EXT4_EXT_MAY_ZEROOUT & split_flag ) <S2SV_ModEnd> <S2SV_ModStart> ex <S2SV_ModEnd> <S2SV_ModStart> out ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; ext4_ext_mark_initialized ( ex ) ; ext4_ext_try_to_merge ( inode , path , ex ) ; err = <S2SV_ModEnd> <S2SV_ModStart> goto out ; } split_map . m_lblk = map -> m_lblk ; split_map . m_len = map -> m_len ; if ( allocated > map -> m_len ) { <S2SV_ModEnd> <S2SV_ModStart> ( EXT4_EXT_MAY_ZEROOUT & split_flag ) ) { zero_ex . ee_block = cpu_to_le32 ( map -> m_lblk + map -> m_len ) ; zero_ex . <S2SV_ModEnd> <S2SV_ModStart> allocated - map -> m_len <S2SV_ModEnd> <S2SV_ModStart> & zero_ex , ext4_ext_pblock ( ex ) + map -> m_lblk - ee_block ) ; <S2SV_ModEnd> <S2SV_ModStart> zero_ex <S2SV_ModEnd> <S2SV_ModStart> out ; split_map . m_lblk = map -> m_lblk ; split_map . m_len = <S2SV_ModEnd> <S2SV_ModStart> ( map -> m_lblk - ee_block + map -> m_len < EXT4_EXT_ZERO_LEN ) && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) ) { if ( map -> m_lblk != ee_block ) { zero_ex . ee_block = ex -> ee_block ; zero_ex . ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ; ext4_ext_store_pblock ( & zero_ex , ext4_ext_pblock ( ex ) ) <S2SV_ModEnd> <S2SV_ModStart> & zero_ex ) ; if ( err ) <S2SV_ModEnd> <S2SV_ModStart> allocated = map -> m_lblk - ee_block + map -> m_len ; split_map . m_lblk = ee_block ; split_map . m_len = allocated ; } } allocated = ext4_split_extent ( handle , inode , path , & split_map , split_flag <S2SV_ModEnd> <S2SV_ModStart> allocated < 0 ) err = allocated <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1194,"<S2SV_StartBug> return parsetok ( tok , g , start , err_ret , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( * flags & PyPARSE_ASYNC_ALWAYS ) tok -> async_always = 1 ; 
1195,<S2SV_StartBug> if ( ! prev_pkt [ channel_id ] . read ) { <S2SV_EndBug> ,"<S2SV_ModStart> prev_pkt [ channel_id ] . read && size != prev_pkt [ channel_id ] . size ) { av_log ( NULL , AV_LOG_ERROR , ""RTMP<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>mismatch<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>%d\\n"" , size , prev_pkt [ channel_id ] . size ) ; ff_rtmp_packet_destroy ( & prev_pkt [ channel_id ] ) ; prev_pkt [ channel_id ] . read = 0 ; } if ( "
1196,"<S2SV_StartBug> static VALUE read_memory ( VALUE klass , VALUE content ) <S2SV_EndBug> <S2SV_StartBug> ) ; <S2SV_EndBug> <S2SV_StartBug> VALUE errors = rb_ary_new ( ) ; <S2SV_EndBug> <S2SV_StartBug> return rb_schema ; <S2SV_EndBug> ","<S2SV_ModStart> int argc , VALUE * argv , VALUE klass ) { VALUE content ; VALUE parse_options ; xmlRelaxNGParserCtxtPtr ctx ; xmlRelaxNGPtr schema ; VALUE errors ; VALUE rb_schema ; int scanned_args = 0 ; scanned_args = rb_scan_args ( argc , argv , ""11"" , & content , & parse_options ) ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( ""ParseOptions"" ) ) , rb_intern ( ""DEFAULT_SCHEMA"" ) ) ; } ctx <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rb_iv_set ( rb_schema , ""@parse_options"" , parse_options ) ; "
1197,<S2SV_StartBug> case '+' : <S2SV_EndBug> <S2SV_StartBug> else if ( * string == 0 ) <S2SV_EndBug> ,<S2SV_ModStart> '/' : if ( open ) open = 0 ; case <S2SV_ModStart> open && * string == '/' ) { string ++ ; continue ; } else if ( 
1198,"<S2SV_StartBug> memcpy ( bss_cfg -> rates , rate_ie + 1 , rate_ie -> len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rate_ie ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( bss_cfg -> rates + rate_len , rate_ie + 1 , rate_ie -> len ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES ) return ; <S2SV_ModStart> { if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES - rate_len ) return ; <S2SV_ModStart> } 
1199,"<S2SV_StartBug> pfkey_broadcast ( skb , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; <S2SV_EndBug> ",<S2SV_ModStart> hdr -> sadb_msg_reserved = 0 ; 
1200,"<S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MIREGADR , MIREGADR_R8 | address ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MICMD , MICMD_MIIRD ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MICMD , 0x00 ) ; <S2SV_EndBug> <S2SV_StartBug> return enc624j600ReadReg ( interface , ENC624J600_REG_MIRD ) ; <S2SV_EndBug> ","<S2SV_ModStart> uint16_t status ; <S2SV_ModStart> ENC624J600_MIREGADR , ENC624J600_MIREGADR_R12_8_DEFAULT <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MICMD , ENC624J600_MICMD_MIIRD <S2SV_ModEnd> <S2SV_ModStart> do { status = <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MISTAT ) ; } while ( ( status & ENC624J600_MISTAT_BUSY <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MICMD <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MIRD <S2SV_ModEnd> "
1201,"<S2SV_StartBug> ( * respond ) ( arg , 0 , NULL , NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> ( * respond ) ( arg , 0 , NULL , NULL , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> EINVAL <S2SV_ModEnd> <S2SV_ModStart> EINVAL <S2SV_ModEnd> 
1202,"<S2SV_StartBug> static u32 ip6_proxy_idents_hashrnd __read_mostly ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip6_proxy_idents_hashrnd , <S2SV_EndBug> <S2SV_StartBug> id = __ipv6_select_ident ( net , ip6_proxy_idents_hashrnd , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1203,"<S2SV_StartBug> int64_t time , offset ; <S2SV_EndBug> ",<S2SV_ModStart> if ( avio_feof ( f ) ) { index -> item_count = 0 ; av_freep ( & index -> items ) ; return AVERROR_INVALIDDATA ; } 
1204,<S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> ,<S2SV_ModStart> ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> 
1205,"<S2SV_StartBug> opj_write_bytes ( p_data , J2K_MS_SOD , <S2SV_EndBug> ","<S2SV_ModStart> if ( p_total_data_size < 4 ) { opj_event_msg ( p_manager , EVT_ERROR , ""Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOD<S2SV_blank>marker\\n"" ) ; return OPJ_FALSE ; } "
1206,"<S2SV_StartBug> perror ( ""malloc<S2SV_blank>(ret)"" ) ; <S2SV_EndBug> <S2SV_StartBug> image_infos = ( struct dyld_cache_image_info * ) ( bin -> b -> buf + bin -> hdr . startaddr ) ; <S2SV_EndBug> <S2SV_StartBug> dyld_vmbase = * ( ut64 * ) ( bin -> b -> buf + bin -> hdr . baseaddroff ) ; <S2SV_EndBug> <S2SV_StartBug> if ( image_infos [ idx ] . pathFileOffset > bin -> size ) { <S2SV_EndBug> <S2SV_StartBug> eprintf ( ""corrupted<S2SV_blank>file\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> libname = ( char * ) ( bin -> b -> buf + image_infos [ idx ] . pathFileOffset ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int sz = bin -> nlibs * sizeof ( struct dyld_cache_image_info ) ; image_infos = malloc ( sz ) ; if ( ! image_infos ) { free ( ret ) ; return NULL ; } r_buf_read_at <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , ( ut8 * ) image_infos , sz <S2SV_ModStart> r_buf_read64le <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> int pfo = <S2SV_ModEnd> <S2SV_ModStart> ; if ( pfo < 0 || pfo <S2SV_ModStart> ""corrupted<S2SV_blank>file:<S2SV_blank>pathFileOffset<S2SV_blank>><S2SV_blank>bin->size<S2SV_blank>(%d)\\n"" , pfo <S2SV_ModEnd> <S2SV_ModStart> r_buf_read_string <S2SV_ModEnd> <S2SV_ModStart> , pfo , 64 <S2SV_ModEnd> "
1207,"<S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> ","<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
1208,"<S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> STREAM s ; <S2SV_EndBug> <S2SV_StartBug> ber_parse_header ( s , MCS_CONNECT_RESPONSE , & length ) ; <S2SV_EndBug> <S2SV_StartBug> mcs_parse_domain_params ( s ) ; <S2SV_EndBug> ","<S2SV_ModStart> uint32 <S2SV_ModEnd> <S2SV_ModStart> ; struct stream packet <S2SV_ModStart> packet = * s ; <S2SV_ModStart> if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""mcs_recv_connect_response(),<S2SV_blank>consume<S2SV_blank>connect<S2SV_blank>id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } "
1209,<S2SV_StartBug> e . ifindex = port -> dev -> ifindex ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & e , 0 , sizeof ( e ) ) ; "
1210,<S2SV_StartBug> value = ( unsigned short ) ( buffer [ 0 ] << 8 ) ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( unsigned short ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1211,"<S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT0 , hashTable [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT1 , hashTable [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT2 , hashTable [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT3 , hashTable [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT4 , hashTable [ 4 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT5 , hashTable [ 5 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT6 , hashTable [ 6 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EHT7 , hashTable [ 7 ] ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT0<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT0<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT4 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT5 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT6 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\r\\n"" , enc28j60ReadReg ( interface , ENC28J60_REG_EHT7 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ENC28J60_EHT0 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EHT1 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EHT2 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EHT3 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EHT4 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EHT5 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EHT6 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EHT7 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EHT0 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EHT1 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EHT2 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EHT3 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EHT4 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EHT5 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EHT6 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EHT7 <S2SV_ModEnd> 
1212,"<S2SV_StartBug> char * sockaddr_url , * stratum_port , * tmp ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_disable_client_reconnect ) { <S2SV_EndBug> <S2SV_StartBug> url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( address , ""%s:%s"" , url , port ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( opt_disable_client_reconnect ) { applog ( LOG_WARNING , ""Stratum<S2SV_blank>client.reconnect<S2SV_blank>received<S2SV_blank>but<S2SV_blank>is<S2SV_blank>disabled,<S2SV_blank>not<S2SV_blank>reconnecting."" ) ; return false ; } <S2SV_ModEnd> <S2SV_ModStart> char * sockaddr_url , * stratum_port , * tmp ; url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ; if ( ! url ) url = pool -> sockaddr_url ; port <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> snprintf ( address , sizeof ( address ) <S2SV_ModEnd> "
1213,<S2SV_StartBug> goto out ; <S2SV_EndBug> ,<S2SV_ModStart> out2 <S2SV_ModEnd> 
1214,<S2SV_StartBug> subobj_len = EXTRACT_16BITS ( obj_tptr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( subobj_len == 0 ) <S2SV_EndBug> ,<S2SV_ModStart> if ( total_subobj_len < 4 ) goto invalid ; <S2SV_ModStart> < 4 || subobj_len > total_subobj_len <S2SV_ModEnd> 
1215,<S2SV_StartBug> if ( REMAIN > INT_MAX ) <S2SV_EndBug> ,<S2SV_ModStart> == 0 || REMAIN 
1216,"<S2SV_StartBug> if ( disk != NULL ) { <S2SV_EndBug> <S2SV_StartBug> const int blocksize = 512 ; <S2SV_EndBug> <S2SV_StartBug> if ( bio ) iob = bio ; <S2SV_EndBug> <S2SV_StartBug> ret = iob -> read_at ( iob -> io , delta + ( blocksize * sector ) , <S2SV_EndBug> <S2SV_StartBug> ( ut8 * ) buf , size * blocksize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret == - 1 ) <S2SV_EndBug> <S2SV_StartBug> } else eprintf ( ""oops.<S2SV_blank>no<S2SV_blank>disk\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ! disk ) { eprintf ( ""oops.<S2SV_blank>no<S2SV_blank>disk\\n"" ) ; return 1 ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart>  <S2SV_ModEnd> "
1217,"<S2SV_StartBug> sas_unregister_dev ( port , dev ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; sas_destruct_devices ( port 
1218,<S2SV_StartBug> ps_dec -> u2_total_mbs_coded ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( u1_tfr_n_mb ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ps_dec -> u2_total_mbs_coded += u1_num_mbs ; 
1219,<S2SV_StartBug> buffer = malloc ( ( uint64_t ) msg . sct . length + 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1220,"<S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_lineno ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_lineno ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_int ( tmp , & lineno , arena ) ; <S2SV_EndBug> <S2SV_StartBug> if ( res != 0 ) goto failed ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> ","<S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>TypeIgnore"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_int ( tmp , & lineno , arena ) ; if ( res != 0 <S2SV_ModEnd> <S2SV_ModStart> Py_CLEAR ( tmp ) ; } * out = TypeIgnore ( <S2SV_ModEnd> <S2SV_ModStart> * out == NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1221,"<S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> ",<S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> codec_interface <S2SV_ModEnd> 
1222,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> return VPX_CODEC_INCAPABLE ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( void ) ctx ; ( void ) args ; 
1223,<S2SV_StartBug> ACPI_FUNCTION_TRACE ( NsTerminate ) ; <S2SV_EndBug> <S2SV_StartBug> ACPI_OPERAND_OBJECT * Next ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; ACPI_FUNCTION_TRACE ( NsTerminate ) <S2SV_ModStart>  <S2SV_ModEnd> 
1224,<S2SV_StartBug> uint_t i ; <S2SV_EndBug> <S2SV_StartBug> if ( ( segment -> dataOffset * 4 + length ) > TCP_MAX_HEADER_LENGTH ) <S2SV_EndBug> <S2SV_StartBug> i = segment -> dataOffset * 4 - sizeof ( TcpHeader ) ; <S2SV_EndBug> <S2SV_StartBug> segment -> options [ i ++ ] = TCP_OPTION_NOP ; <S2SV_EndBug> <S2SV_StartBug> option = ( TcpOption * ) ( segment -> options + i ) ; <S2SV_EndBug> <S2SV_StartBug> return NO_ERROR ; <S2SV_EndBug> ,<S2SV_ModStart> error_t error ; size_t <S2SV_ModEnd> <S2SV_ModStart> <= TCP_MAX_HEADER_LENGTH ) { i = ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> error = NO_ERROR ; } else { error = ERROR_FAILURE ; } return error <S2SV_ModEnd> 
1225,"<S2SV_StartBug> return crypto_skcipher_setkey ( private , key , keylen ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> struct skcipher_tfm * tfm = private ; int err ; err = crypto_skcipher_setkey ( tfm -> skcipher <S2SV_ModEnd> <S2SV_ModStart> tfm -> has_key = ! err ; return err ; 
1226,<S2SV_StartBug> if ( bt_terminal ( wp -> w_buffer ) ) <S2SV_EndBug> ,<S2SV_ModStart> curwin <S2SV_ModEnd> 
1227,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> [ plane ] && in -> linesize 
1228,"<S2SV_StartBug> struct twopass_rc * const twopass = & cpi -> twopass ; <S2SV_EndBug> <S2SV_StartBug> const FIRSTPASS_STATS * start_position = twopass -> stats_in ; <S2SV_EndBug> <S2SV_StartBug> double decay_accumulator = 1.0 ; <S2SV_EndBug> <S2SV_StartBug> rc -> this_key_frame_forced = rc -> next_key_frame_forced ; <S2SV_EndBug> <S2SV_StartBug> rc -> frames_till_gf_update_due = 0 ; <S2SV_EndBug> <S2SV_StartBug> kf_mod_err = calculate_modified_err ( cpi , this_frame ) ; <S2SV_EndBug> <S2SV_StartBug> while ( twopass -> stats_in < twopass -> stats_in_end ) { <S2SV_EndBug> <S2SV_StartBug> kf_group_err += calculate_modified_err ( cpi , this_frame ) ; <S2SV_EndBug> <S2SV_StartBug> lookup_next_frame_stats ( twopass , & next_frame ) != EOF ) { <S2SV_EndBug> <S2SV_StartBug> if ( test_candidate_kf ( twopass , & last_frame , this_frame , & next_frame ) ) <S2SV_EndBug> <S2SV_StartBug> loop_decay_rate = get_prediction_decay_rate ( & cpi -> common , & next_frame ) ; <S2SV_EndBug> <S2SV_StartBug> if ( detect_transition_to_still ( twopass , i , cpi -> key_frame_frequency - i , <S2SV_EndBug> <S2SV_StartBug> if ( rc -> frames_to_key >= 2 * ( int ) cpi -> key_frame_frequency ) <S2SV_EndBug> <S2SV_StartBug> rc -> frames_to_key > ( int ) cpi -> key_frame_frequency ) { <S2SV_EndBug> <S2SV_StartBug> kf_group_err = 0 ; <S2SV_EndBug> <S2SV_StartBug> kf_group_err += calculate_modified_err ( cpi , & tmp_frame ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( twopass -> stats_in == twopass -> stats_in_end ) { <S2SV_EndBug> <S2SV_StartBug> if ( twopass -> stats_in >= twopass -> stats_in_end ) { <S2SV_EndBug> <S2SV_StartBug> kf_group_err += calculate_modified_err ( cpi , this_frame ) ; <S2SV_EndBug> <S2SV_StartBug> reset_fpf_position ( twopass , start_position ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < rc -> frames_to_key ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( next_frame . pcnt_inter - next_frame . pcnt_motion ) < <S2SV_EndBug> <S2SV_StartBug> if ( i <= ( rc -> max_gf_interval * 2 ) ) { <S2SV_EndBug> <S2SV_StartBug> const double loop_decay_rate = get_prediction_decay_rate ( & cpi -> common , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> boost_score += ( decay_accumulator * r ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < rc -> frames_to_key ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> twopass -> section_intra_rating = ( int ) ( sectionstats . intra_error / <S2SV_EndBug> <S2SV_StartBug> kf_boost = ( rc -> frames_to_key * 3 ) ; <S2SV_EndBug> <S2SV_StartBug> allocation_chunks = ( ( rc -> frames_to_key - 1 ) * 10 ) + kf_boost ; <S2SV_EndBug> <S2SV_StartBug> allocation_chunks = ( ( rc -> frames_to_key - 1 ) * 100 ) + kf_boost ; <S2SV_EndBug> <S2SV_StartBug> twopass -> kf_group_bits -= twopass -> kf_bits ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> TWO_PASS <S2SV_ModEnd> <S2SV_ModStart> ; GF_GROUP * const gf_group = & twopass -> gf_group ; const VP9EncoderConfig * const oxcf = & cpi -> oxcf <S2SV_ModStart> const <S2SV_ModStart> int kf_bits = 0 ; int loop_decay_counter = 0 ; <S2SV_ModStart> ; double av_decay_accumulator = 0.0 <S2SV_ModStart> vp9_zero ( * gf_group ) ; <S2SV_ModStart> cpi -> multi_arf_last_grp_enabled = 0 ; <S2SV_ModStart> , twopass , oxcf <S2SV_ModStart> && rc -> frames_to_key < cpi -> oxcf . key_freq <S2SV_ModStart> twopass , oxcf , <S2SV_ModStart> twopass -> stats_in < twopass -> stats_in_end <S2SV_ModEnd> <S2SV_ModStart> twopass -> stats_in <S2SV_ModEnd> <S2SV_ModStart> cpi , twopass -> stats_in <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> oxcf . key_freq <S2SV_ModEnd> <S2SV_ModStart> cpi -> oxcf . key_freq <S2SV_ModEnd> <S2SV_ModStart> cpi -> oxcf . key_freq <S2SV_ModEnd> <S2SV_ModStart> 0.0 <S2SV_ModEnd> <S2SV_ModStart> twopass , oxcf , <S2SV_ModStart> || rc -> frames_to_key >= cpi -> oxcf . key_freq <S2SV_ModStart> is_two_pass_svc ( cpi ) && cpi -> svc . number_temporal_layers > 1 ) { int count = ( 1 << ( cpi -> svc . number_temporal_layers - 1 ) ) - 1 ; int new_frame_to_key = ( rc -> frames_to_key + count ) & ( ~ count ) ; int j ; for ( j = 0 ; j < new_frame_to_key - rc -> frames_to_key ; ++ j ) { if ( EOF == input_stats ( twopass , this_frame ) ) break ; <S2SV_ModEnd> <S2SV_ModStart> twopass , oxcf , this_frame ) ; } rc -> frames_to_key = new_frame_to_key ; } if ( twopass -> stats_in >= twopass -> stats_in_end ) { kf_group_err += calculate_modified_err ( cpi , twopass , oxcf , <S2SV_ModStart> twopass -> kf_group_bits = MAX ( 0 , twopass -> kf_group_bits ) ; <S2SV_ModStart> ( rc -> frames_to_key - 1 ) <S2SV_ModEnd> <S2SV_ModStart> zero_motion_accumulator = MIN ( zero_motion_accumulator , get_zero_motion_factor ( cpi , & next_frame ) ) ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) || ( ( i <= ( rc -> max_gf_interval * 4 ) ) && ( decay_accumulator > 0.5 ) ) ) { const double frame_boost = calc_frame_boost ( cpi , this_frame , 0 , KF_MAX_BOOST ) <S2SV_ModEnd> <S2SV_ModStart> cpi , <S2SV_ModEnd> <S2SV_ModStart> av_decay_accumulator += decay_accumulator ; ++ loop_decay_counter ; <S2SV_ModStart> frame_boost ) ; } } av_decay_accumulator /= ( double ) loop_decay_counter <S2SV_ModEnd> <S2SV_ModStart> twopass -> kf_zeromotion_pct = ( int ) ( zero_motion_accumulator * 100.0 <S2SV_ModEnd> <S2SV_ModStart> calculate_section_intra_ratio ( start_position , twopass -> stats_in_end , rc -> frames_to_key ) ; rc -> kf_boost = <S2SV_ModStart> av_decay_accumulator * boost_score ) ; rc -> kf_boost = MAX ( rc -> kf_boost , <S2SV_ModEnd> <S2SV_ModStart> ; rc -> kf_boost = MAX ( rc -> kf_boost , MIN_KF_BOOST ) ; kf_bits = calculate_boost_bits <S2SV_ModEnd> <S2SV_ModStart> , rc -> kf_boost , twopass -> kf_group_bits ) ; if ( twopass -> kf_group_bits ) { twopass -> kfgroup_inter_fraction = ( double ) ( twopass -> kf_group_bits - kf_bits ) / ( double ) twopass -> kf_group_bits <S2SV_ModEnd> <S2SV_ModStart> twopass -> kfgroup_inter_fraction = 1.0 <S2SV_ModEnd> <S2SV_ModStart> kf_bits ; gf_group -> bit_allocation [ 0 ] = kf_bits ; gf_group -> update_type [ 0 ] = KF_UPDATE ; gf_group -> rf_level [ 0 ] = KF_STD ; <S2SV_ModEnd> <S2SV_ModStart> if ( oxcf -> resize_mode == RESIZE_DYNAMIC ) { cpi -> rc . next_frame_size_selector = UNSCALED ; } "
1229,"<S2SV_StartBug> static inline bool unconditional ( const struct ip6t_ip6 * ipv6 ) <S2SV_EndBug> <S2SV_StartBug> return memcmp ( ipv6 , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug> ",<S2SV_ModStart> ip6t_entry * e <S2SV_ModEnd> <S2SV_ModStart> e -> target_offset == sizeof ( struct ip6t_entry ) && memcmp ( & e -> <S2SV_ModEnd> 
1230,<S2SV_StartBug> if ( i > ( sizeof ( outbuff ) - 20 ) ) { <S2SV_EndBug> ,<S2SV_ModStart> 128 <S2SV_ModEnd> 
1231,"<S2SV_StartBug> assert ( pow ( ( float ) r + 1 , dim ) > entries ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ( int ) floor ( pow ( ( float ) r , dim ) ) <= entries ) ; <S2SV_EndBug> ",<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> <= entries ) return - 1 ; if <S2SV_ModEnd> <S2SV_ModStart> > entries ) return - 1 <S2SV_ModEnd> 
1232,"<S2SV_StartBug> sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> SCTP_CMD_SET_ASOC <S2SV_ModEnd> 
1233,"<S2SV_StartBug> nego_process_negotiation_response ( nego , s ) ; <S2SV_EndBug> <S2SV_StartBug> nego_process_negotiation_failure ( nego , s ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) return - 1 <S2SV_ModStart> if ( ! <S2SV_ModStart> ) return - 1 
1234,<S2SV_StartBug> int max_plane ) { <S2SV_EndBug> <S2SV_StartBug> struct macroblock_plane * const p = x -> plane ; <S2SV_EndBug> <S2SV_StartBug> struct macroblockd_plane * const pd = x -> e_mbd . plane ; <S2SV_EndBug> <S2SV_StartBug> p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> ctx -> qcoeff_pbuf [ i ] [ 0 ] = p [ i ] . qcoeff ; <S2SV_EndBug> <S2SV_StartBug> ctx -> dqcoeff_pbuf [ i ] [ 0 ] = pd [ i ] . dqcoeff ; <S2SV_EndBug> <S2SV_StartBug> ctx -> eobs_pbuf [ i ] [ 0 ] = p [ i ] . eobs ; <S2SV_EndBug> ,"<S2SV_ModStart> m , int n , int min_plane , int <S2SV_ModStart> int i ; for ( i = min_plane ; i < max_plane ; ++ i ) { <S2SV_ModStart> & <S2SV_ModStart> [ i ] <S2SV_ModStart> & <S2SV_ModStart> [ i ] ; p -> <S2SV_ModEnd> <S2SV_ModStart> m ] ; p -> <S2SV_ModEnd> <S2SV_ModStart> m <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> m ] ; p -> <S2SV_ModEnd> <S2SV_ModStart> m ] ; ctx -> coeff_pbuf [ i ] [ m ] = ctx -> coeff_pbuf [ i ] [ n ] ; ctx -> qcoeff_pbuf [ i ] [ m ] = ctx -> qcoeff_pbuf [ i ] [ n ] ; ctx -> dqcoeff_pbuf [ i ] [ m ] = ctx -> dqcoeff_pbuf [ i ] [ n ] ; ctx -> eobs_pbuf [ i ] [ m ] = ctx -> eobs_pbuf [ i ] [ n ] ; ctx -> coeff_pbuf [ i ] [ n ] = p -> <S2SV_ModEnd> <S2SV_ModStart> n ] = p -> <S2SV_ModEnd> <S2SV_ModStart> n <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> n ] = p -> <S2SV_ModEnd> "
1235,"<S2SV_StartBug> memset ( mp4 , 0 , sizeof ( mp4object ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len == 8 ) <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> fread ( & qtsize , 1 , 8 , mp4 -> mediafp ) ; <S2SV_EndBug> <S2SV_StartBug> qttag == MAKEID ( 'u' , 'd' , 't' , 'a' ) ) <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 'a' , 'l' , 'i' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 'a' , 'l' , 'i' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 'b' , 'l' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 't' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 's' , 'c' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 's' , 'z' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 'c' , 'o' ) && <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( temp != MAKEID ( 'a' , 'l' , 'i' , 's' ) ) <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> mp4 -> metastsc = ( SampleToChunk * ) malloc ( num * 12 ) ; <S2SV_EndBug> <S2SV_StartBug> uint32_t total_stsc = num ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metastsc_count == 1 && mp4 -> metastsc [ 0 ] . samples == 1 ) <S2SV_EndBug> <S2SV_StartBug> mp4 -> metastsc_count = 0 ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> mp4 -> metasizes = ( uint32_t * ) malloc ( num * 4 ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metastsc_count > 0 && num != mp4 -> metasize_count ) <S2SV_EndBug> <S2SV_StartBug> mp4 -> indexcount = mp4 -> metasize_count ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> <S2SV_StartBug> mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> metasize_count * 8 ) ; <S2SV_EndBug> <S2SV_StartBug> while ( num < mp4 -> metasize_count ) <S2SV_EndBug> <S2SV_StartBug> stco_pos ++ ; <S2SV_EndBug> <S2SV_StartBug> repeat = 1 ; <S2SV_EndBug> <S2SV_StartBug> repeat ++ ; <S2SV_EndBug> <S2SV_StartBug> mp4 -> indexcount = num ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( num * 8 <= qtsize - 8 - len ) <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> <S2SV_StartBug> mp4 -> indexcount = num ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ; struct stat64 mp4stat ; stat64 ( filename , & mp4stat ) ; mp4 -> filesize = mp4stat . st_size ; if ( mp4 -> filesize < 64 ) return 0 <S2SV_ModStart> mp4 -> filepos += len ; <S2SV_ModStart> && mp4 -> filepos < mp4 -> filesize <S2SV_ModStart> CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break <S2SV_ModEnd> <S2SV_ModStart> len = <S2SV_ModStart> ; mp4 -> filepos += len <S2SV_ModStart> || qttag == MAKEID ( 'f' , 'r' , 'e' , 'e' ) ) { LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 's' , 't' , 'b' , 'l' <S2SV_ModEnd> <S2SV_ModStart> 's' , 't' , 't' <S2SV_ModEnd> <S2SV_ModStart> 's' , 'c' <S2SV_ModEnd> <S2SV_ModStart> 's' , 'z' <S2SV_ModEnd> <S2SV_ModStart> 'c' , 'o' <S2SV_ModEnd> <S2SV_ModStart> 'c' , 'o' , '6' , '4' <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && temp != MAKEID ( 'u' , 'r' , 'l' , '<S2SV_blank>' ) <S2SV_ModStart> mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( num > 0 ) { <S2SV_ModStart> sizeof ( SampleToChunk ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } else { CloseSource ( ( size_t ) mp4 ) ; mp4 <S2SV_ModEnd> <S2SV_ModStart> break ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( num > 0 ) { <S2SV_ModStart> else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> uint32_t metastco_count = num ; <S2SV_ModStart> num <S2SV_ModEnd> <S2SV_ModStart> if ( num > 0 ) { <S2SV_ModStart> num <S2SV_ModEnd> <S2SV_ModStart> indexcount ) { if ( ( uint32_t ) <S2SV_ModEnd> <S2SV_ModStart> if ( ( uint32_t ) stco_pos + 1 < metastco_count ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } if ( ( uint32_t ) stsc_pos + 1 < mp4 -> metastsc_count ) if ( mp4 -> metastsc [ stsc_pos + 1 ] . chunk_num == ( uint32_t ) stco_pos + 1 ) stsc_pos ++ ; repeat = 1 ; } else { fileoffset += ( uint64_t ) mp4 -> metasizes [ num - 1 ] ; <S2SV_ModStart> CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } else { <S2SV_ModStart> if ( num > 0 ) { <S2SV_ModStart> else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> == 0 ) { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } if ( num <S2SV_ModStart> if ( mp4 -> metasize_count ) { <S2SV_ModStart> CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } else { <S2SV_ModStart> mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( mp4 ) { if ( mp4 -> metasizes == NULL || mp4 -> metaoffsets == NULL ) { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; } } "
1236,<S2SV_StartBug> line = picture -> data [ plane ] + y * picture -> linesize [ plane ] ; <S2SV_EndBug> <S2SV_StartBug> dst = line + x * pixelsize + compno * ! planar ; <S2SV_EndBug> <S2SV_StartBug> linel = ( uint16_t * ) picture -> data [ plane ] + y * ( picture -> linesize [ plane ] >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> dst = linel + ( x * pixelsize + compno * ! planar ) ; <S2SV_EndBug> ,<S2SV_ModStart> / s -> cdy [ compno ] <S2SV_ModStart> / s -> cdx [ compno ] <S2SV_ModStart> / s -> cdy [ compno ] <S2SV_ModStart> / s -> cdx [ compno ] 
1237,"<S2SV_StartBug> split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ? <S2SV_EndBug> <S2SV_StartBug> err = ext4_split_extent_at ( handle , inode , path , <S2SV_EndBug> <S2SV_StartBug> split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ? <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( split_flag & EXT4_EXT_DATA_VALID2 ) split_flag1 |= EXT4_EXT_DATA_VALID1 ; <S2SV_ModStart> ( EXT4_EXT_MAY_ZEROOUT | EXT4_EXT_DATA_VALID2 ) <S2SV_ModEnd> 
1238,"<S2SV_StartBug> err = bnep_add_connection ( & ca , nsock ) ; <S2SV_EndBug> ",<S2SV_ModStart> ca . device [ sizeof ( ca . device ) - 1 ] = 0 ; 
1239,"<S2SV_StartBug> strcpy ( buf , mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> else strcpy ( mode , """" ) ; "
1240,<S2SV_StartBug> if ( q > e ) { <S2SV_EndBug> ,"<S2SV_ModStart> < p ) { DPRINTF ( ( ""Wrapped<S2SV_blank>around<S2SV_blank>%p<S2SV_blank><<S2SV_blank>%p\\n"" , q , p ) ) ; goto out ; } if ( q "
1241,<S2SV_StartBug> ps_dec -> ps_parse_cur_slice ++ ; <S2SV_EndBug> <S2SV_StartBug> ps_dec -> u2_cur_slice_num ++ ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> ps_dec -> u2_cur_slice_num ++ ; } <S2SV_ModStart>  <S2SV_ModEnd> 
1242,"<S2SV_StartBug> sqlite3VdbeChangeP5 ( v , OPFLAG_TYPEOFARG ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( sqlite3VdbeGetOp ( v , - 1 ) -> opcode == OP_Column ) { <S2SV_ModStart> } "
1243,<S2SV_StartBug> ( Rec2 . RecordLength - 2 - 2 ) / 3 ) <S2SV_EndBug> ,"<S2SV_ModStart> ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries "
1244,"<S2SV_StartBug> if ( js_regexec ( re -> prog , source , & m , 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! js_regexec ( re -> prog , source , & m , REG_NOTBOL ) ) <S2SV_EndBug> ","<S2SV_ModStart> js_doregexec ( J , <S2SV_ModEnd> <S2SV_ModStart> js_doregexec ( J , <S2SV_ModEnd> "
1245,<S2SV_StartBug> while ( 0xff == u4_bits ) <S2SV_EndBug> <S2SV_StartBug> while ( 0xff == u4_bits ) <S2SV_EndBug> <S2SV_StartBug> while ( 0 == ih264d_check_byte_aligned ( ps_bitstrm ) ) <S2SV_EndBug> ,<S2SV_ModStart> && ! EXCEED_OFFSET ( ps_bitstrm ) <S2SV_ModStart> && ! EXCEED_OFFSET ( ps_bitstrm ) <S2SV_ModStart> ( ps_bitstrm ) && ! EXCEED_OFFSET 
1246,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> usb_conv_info -> class_data_type = USB_CONV_VIDEO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_VIDEO ) { return descriptor_len ; 
1247,<S2SV_StartBug> while ( header_buf [ i ] == '\\r' || header_buf [ i ] == '\\n' ) <S2SV_EndBug> ,<S2SV_ModStart> ( i < ( int ) header_buf_used ) && ( <S2SV_ModStart> ) 
1248,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
1249,<S2SV_StartBug> if ( ! static_key_enabled ( work -> key ) ) <S2SV_EndBug> ,<S2SV_ModStart> BUG_ON <S2SV_ModEnd> <S2SV_ModStart> ; static_key_slow_dec <S2SV_ModEnd> 
1250,"<S2SV_StartBug> if ( strchr ( topicName , '#' ) == NULL && strchr ( topicName , '+' ) == NULL ) <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> 
1251,"<S2SV_StartBug> pipe -> bufs = kzalloc ( sizeof ( struct pipe_buffer ) * PIPE_DEF_BUFFERS , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> pipe -> buffers = PIPE_DEF_BUFFERS ; <S2SV_EndBug> <S2SV_StartBug> kfree ( pipe ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned long pipe_bufs = PIPE_DEF_BUFFERS ; struct user_struct * user = get_current_user ( ) ; if ( ! too_many_pipe_buffers_hard ( user ) ) { if ( too_many_pipe_buffers_soft ( user ) ) pipe_bufs = 1 ; <S2SV_ModStart> pipe_bufs <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> pipe_bufs ; pipe -> user = user ; account_pipe_buffers ( pipe , 0 , pipe_bufs ) <S2SV_ModEnd> <S2SV_ModStart> free_uid ( user ) ; "
1252,<S2SV_StartBug> if ( trk -> vos_len == 0 && par -> extradata_size > 0 && <S2SV_EndBug> ,"<S2SV_ModStart> samples_in_chunk < 1 ) { av_log ( s , AV_LOG_ERROR , ""fatal<S2SV_blank>error,<S2SV_blank>input<S2SV_blank>packet<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>samples\\n"" ) ; return AVERROR_PATCHWELCOME ; } if ( "
1253,<S2SV_StartBug> xmlNodePtr cur = NULL ; <S2SV_EndBug> <S2SV_StartBug> xmlXPathObjectPtr obj ; <S2SV_EndBug> <S2SV_StartBug> xmlXPathFreeObject ( obj ) ; <S2SV_EndBug> <S2SV_StartBug> val = ( long ) ( ( char * ) cur - ( char * ) doc ) ; <S2SV_EndBug> ,<S2SV_ModStart> = NULL ; xmlXPathObjectPtr obj <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( obj ) xmlXPathFreeObject ( obj ) ; 
1254,<S2SV_StartBug> if ( ! fs_searchpaths ) <S2SV_EndBug> <S2SV_StartBug> for ( search = fs_searchpaths ; search ; search = search -> next ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> qboolean isLocalConfig ; <S2SV_ModStart> isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> if ( isLocalConfig && search -> pack ) continue ; "
1255,"<S2SV_StartBug> walk -> private += __mincore_unmapped_range ( addr , end , <S2SV_EndBug> ","<S2SV_ModStart> unsigned char * vec = walk -> private ; unsigned long nr = ( end - addr ) >> PAGE_SHIFT ; memset ( vec , 0 , nr ) ; <S2SV_ModStart> nr <S2SV_ModEnd> "
1256,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return 0 ; 
1257,"<S2SV_StartBug> int rc ; <S2SV_EndBug> <S2SV_StartBug> rc = ecryptfs_parse_options ( sbi , raw_data ) ; <S2SV_EndBug> <S2SV_StartBug> ecryptfs_set_superblock_lower ( s , path . dentry -> d_sb ) ; <S2SV_EndBug> ","<S2SV_ModStart> uid_t check_ruid ; <S2SV_ModStart> , & check_ruid <S2SV_ModStart> if ( check_ruid && path . dentry -> d_inode -> i_uid != current_uid ( ) ) { rc = - EPERM ; printk ( KERN_ERR ""Mount<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(uid:<S2SV_blank>%d)<S2SV_blank>not<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>"" ""requested<S2SV_blank>user<S2SV_blank>(uid:<S2SV_blank>%d)\\n"" , path . dentry -> d_inode -> i_uid , current_uid ( ) ) ; goto out_free ; } "
1258,<S2SV_StartBug> return AUTH_FOUND ; <S2SV_EndBug> ,<S2SV_ModStart> fclose ( opwfile ) ; 
1259,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % ( 4 * stride ) ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horAcc32"" , ""%s"" , ""cc%(4*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; "
1260,<S2SV_StartBug> random_ether_addr ( dev -> dev_addr ) ; <S2SV_EndBug> ,<S2SV_ModStart> dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; 
1261,<S2SV_StartBug> timr -> it_overrun += ( unsigned int ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1262,"<S2SV_StartBug> tlv = cp + i ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 4 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( i + 4 > length ) return - 1 ; <S2SV_ModStart> ; if ( i + 4 + optlen > length ) return - 1 
1263,"<S2SV_StartBug> vpx_memset ( ypred_ptr , expected_dc , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ypred_ptr , yleft_col [ r ] , 16 ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
1264,<S2SV_StartBug> if ( ! asoc -> temp ) { <S2SV_EndBug> ,<S2SV_ModStart> list_empty ( & asoc -> asocs ) <S2SV_ModEnd> 
1265,<S2SV_StartBug> default : <S2SV_EndBug> ,"<S2SV_ModStart> case Opt_dioread_nolock : set_opt ( sbi -> s_mount_opt , DIOREAD_NOLOCK ) ; break ; case Opt_dioread_lock : clear_opt ( sbi -> s_mount_opt , DIOREAD_NOLOCK ) ; break ; "
1266,<S2SV_StartBug> if ( noblock ) <S2SV_EndBug> ,<S2SV_ModStart> cond_resched ( ) <S2SV_ModEnd> 
1267,"<S2SV_StartBug> TX_SIZE max_tx_size , vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> const int ctx = vp9_get_tx_size_context ( xd ) ; <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * tx_probs = get_tx_probs ( max_tx_size , ctx , & cm -> fc . tx_probs ) ; <S2SV_EndBug> <S2SV_StartBug> int tx_size = vp9_read ( r , tx_probs [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> tx_size += vp9_read ( r , tx_probs [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> tx_size += vp9_read ( r , tx_probs [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> <S2SV_StartBug> ++ get_tx_counts ( max_tx_size , ctx , & cm -> counts . tx ) [ tx_size ] ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> FRAME_COUNTS * counts = xd -> counts ; <S2SV_ModStart> get_tx_size_context <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> counts <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> 
1268,<S2SV_StartBug> evt -> event . lun [ 1 ] = tpg -> tport_tpgt & 0xFF ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1269,<S2SV_StartBug> int64_t cur_offset = avio_tell ( pb ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( par -> codec_type == AVMEDIA_TYPE_AUDIO && ! pkt -> size ) { av_log ( s , AV_LOG_WARNING , ""Empty<S2SV_blank>audio<S2SV_blank>Packet\\n"" ) ; return AVERROR ( EINVAL ) ; } "
1270,"<S2SV_StartBug> if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) <S2SV_EndBug> <S2SV_StartBug> if ( sk -> sk_state != TCP_CLOSE ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out_unlock ; if ( "
1271,"<S2SV_StartBug> strncpy ( result , ""undefined"" , 10 ) ; <S2SV_EndBug> ",<S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1272,"<S2SV_StartBug> GsmXSMPClient * client ; <S2SV_EndBug> <S2SV_StartBug> client = ice_conn -> context ; <S2SV_EndBug> <S2SV_StartBug> g_return_val_if_fail ( client != NULL , TRUE ) ; <S2SV_EndBug> <S2SV_StartBug> gsm_xsmp_client_connect ( client , sms_conn , mask_ret , callbacks_ret ) ; <S2SV_EndBug> ","<S2SV_ModStart> GsmClient * client ; GsmIceConnectionWatch * data <S2SV_ModEnd> <S2SV_ModStart> data <S2SV_ModEnd> <S2SV_ModStart> free_ice_connection_watch ( data ) ; client = gsm_xsmp_client_new ( ice_conn ) ; gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ; g_object_unref ( client <S2SV_ModEnd> <S2SV_ModStart> GSM_XSMP_CLIENT ( client ) <S2SV_ModEnd> "
1273,"<S2SV_StartBug> udf_pc_to_char ( inode -> i_sb , symlink , inode -> i_size , p ) ; <S2SV_EndBug> <S2SV_StartBug> brelse ( bh ) ; <S2SV_EndBug> ","<S2SV_ModStart> err = <S2SV_ModStart> , PAGE_SIZE <S2SV_ModStart> ; if ( err ) goto out_unlock_inode "
1274,"<S2SV_StartBug> static char * print_array ( cJSON * item , int depth , int fmt ) <S2SV_EndBug> <S2SV_StartBug> while ( child ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! ( entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ) ) <S2SV_EndBug> <S2SV_StartBug> while ( child && ! fail ) { <S2SV_EndBug> <S2SV_StartBug> ret = print_value ( child , depth + 1 , fmt ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! fail ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < numentries ; ++ i ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < numentries ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> ptr += strlen ( entries [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( i != numentries - 1 ) { <S2SV_EndBug> <S2SV_StartBug> cJSON_free ( entries [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> * ptr ++ = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> , printbuffer * p <S2SV_ModStart> size_t tmplen = 0 ; <S2SV_ModStart> numentries ++ , <S2SV_ModEnd> <S2SV_ModStart> if ( ! numentries ) { if ( p ) out = ensure ( p , 3 ) ; else out = ( char <S2SV_ModEnd> <S2SV_ModStart> 3 ) ; if ( out ) strcpy ( out , ""[]"" ) ; return out ; } if ( p ) { i = p -> offset ; ptr = ensure ( p , 1 ) ; if ( ! ptr ) return 0 ; * ptr = '[' ; p -> offset ++ <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModEnd> <S2SV_ModStart> , p ) ; p -> offset = update ( p ) ; if ( child -> next ) { len = fmt ? 2 : 1 ; ptr = ensure ( p , len + 1 ) ; if ( ! ptr ) return 0 ; * ptr ++ = ',' ; if ( fmt ) * ptr ++ = '<S2SV_blank>' ; * ptr = 0 ; p -> offset += len ; } child = child -> next ; } ptr = ensure ( p , 2 ) ; if ( ! ptr ) return 0 ; * ptr ++ = ']' ; * ptr = 0 ; out = ( p -> buffer ) + i ; } else { entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ; if ( ! entries ) return 0 ; memset ( entries , 0 , numentries * sizeof ( char * ) ) ; child = item -> child ; while ( child && ! fail ) { ret = print_value ( child , depth + 1 , fmt , 0 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> i ++ ) <S2SV_ModEnd> <S2SV_ModStart> i ++ ) { tmplen = strlen ( <S2SV_ModEnd> <S2SV_ModStart> memcpy ( ptr , entries [ i ] , tmplen ) ; ptr += tmplen ; if ( i != numentries - 1 ) { * ptr ++ = ',' ; if ( fmt ) * ptr ++ = '<S2SV_blank>' ; * ptr = 0 ; } cJSON_free <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * ptr ++ = 0 ; } <S2SV_ModEnd> "
1275,<S2SV_StartBug> if ( ! vma -> vm_userfaultfd_ctx . ctx ) <S2SV_EndBug> ,<S2SV_ModStart> WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ; 
1276,"<S2SV_StartBug> if ( ! fc_may_access ( fc , controller , path1 , path2 , fi -> flags ) ) { <S2SV_EndBug> ","<S2SV_ModStart> caller_may_see_dir ( fc -> pid , controller , path1 ) ) { ret = - ENOENT ; goto out ; } if ( ! "
1277,<S2SV_StartBug> # if CONFIG_ALPHA <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1278,<S2SV_StartBug> if ( serial -> port [ 0 ] == usbcons_info . port ) { <S2SV_EndBug> ,<S2SV_ModStart> serial -> port [ 0 ] && 
1279,"<S2SV_StartBug> static int ion_handle_put ( struct ion_handle * handle ) <S2SV_EndBug> <S2SV_StartBug> ret = kref_put ( & handle -> ref , ion_handle_destroy ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ion_handle_put_nolock ( handle <S2SV_ModEnd> 
1280,<S2SV_StartBug> DEFINE_WAKE_Q ( wake_q ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( nr_wake < 0 || nr_requeue < 0 ) return - EINVAL 
1281,"<S2SV_StartBug> vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , el ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dest_ptr1 + el , src_ptr1 , w ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , linesize ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dest_ptr2 , src_ptr2 , linesize ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memcpy ( dest_ptr1 + el , src_ptr1 , w ) ; memset <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> "
1282,"<S2SV_StartBug> if ( my_copystat ( org_name , tmp_name , MyFlags ) < 0 ) <S2SV_EndBug> ",<S2SV_ModStart> ! my_disable_copystat_in_redel && 
1283,<S2SV_StartBug> static inline int <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1284,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> usb_conv_info -> class_data_type = USB_CONV_VIDEO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_VIDEO ) { return descriptor_len ; 
1285,"<S2SV_StartBug> if ( mount ( console -> name , lxcpath , ""none"" , MS_BIND , 0 ) ) { <S2SV_EndBug> ","<S2SV_ModStart> safe_mount ( console -> name , lxcpath , ""none"" , MS_BIND , 0 , rootfs -> mount ) ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'"" , <S2SV_ModEnd> <S2SV_ModStart> ) ; return - 1 ; } ret = snprintf ( lxcpath , sizeof ( lxcpath ) , ""%s/console"" , ttydir ) ; if ( ret >= sizeof ( lxcpath ) ) { ERROR ( ""lxc/console<S2SV_blank>path<S2SV_blank>too<S2SV_blank>long"" ) ; return - 1 ; } ret = symlink ( lxcpath , path ) ; if ( ret ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>symlink<S2SV_blank>for<S2SV_blank>console"" ) ; return - 1 ; } INFO ( ""console<S2SV_blank>has<S2SV_blank>been<S2SV_blank>setup<S2SV_blank>on<S2SV_blank>%s"" , lxcpath ) ; return 0 <S2SV_ModEnd> "
1286,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
1287,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , mldv2_tstr <S2SV_ModEnd> "
1288,"<S2SV_StartBug> strcpy ( m , name ) ; <S2SV_EndBug> ","<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> , nlen + 1 "
1289,<S2SV_StartBug> ps_dec -> u4_first_slice_in_pic = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1290,<S2SV_StartBug> mptctl_eventenable ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> struct mpt_ioctl_eventenable karg ; <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,"<S2SV_ModStart> MPT_ADAPTER * ioc , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1291,<S2SV_StartBug> if ( ! sock || ( count && ! buf ) ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ,<S2SV_ModStart> || count > OE_SSIZE_MAX <S2SV_ModStart> if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } 
1292,<S2SV_StartBug> MACROBLOCKD * const xd = args -> xd ; <S2SV_EndBug> <S2SV_StartBug> struct macroblock_plane * p = & args -> cpi -> mb . plane [ plane ] ; <S2SV_EndBug> ,<S2SV_ModStart> ThreadData * const td = args -> td ; MACROBLOCK * const x = & td -> mb ; <S2SV_ModStart> & x -> e_mbd <S2SV_ModEnd> <S2SV_ModStart> x -> <S2SV_ModEnd> 
1293,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> <S2SV_StartBug> exit_func : <S2SV_EndBug> ",<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : <S2SV_ModStart>  <S2SV_ModEnd> 
1294,"<S2SV_StartBug> ps_dec -> u2_frame_rate_code = impeg2d_bit_stream_get ( ps_stream , 4 ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ps_dec -> u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE ) { return IMPEG2D_FRM_HDR_DECODE_ERR ; } 
1295,"<S2SV_StartBug> return print_value ( item , 0 , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , 0 "
1296,"<S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_args ) ) { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> arg_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_arg ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( args , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_vararg ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_vararg ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> arg_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_arg ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( kwonlyargs , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_kw_defaults ) ) { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( kw_defaults , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_kwarg ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_kwarg ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( defaults , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> * out = arguments ( args , vararg , kwonlyargs , kw_defaults , kwarg , defaults , <S2SV_EndBug> ","<S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_vararg , & tmp ) < 0 ) { <S2SV_ModEnd> <S2SV_ModStart> tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; vararg = NULL ; } else { int res ; res = obj2ast_arg ( tmp , & vararg , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_kwonlyargs , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""kwonlyargs\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_kw_defaults , & tmp ) < 0 ) { <S2SV_ModEnd> <S2SV_ModStart> tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""kw_defaults\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_kwarg , & tmp ) < 0 ) { <S2SV_ModEnd> <S2SV_ModStart> tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; kwarg = NULL ; } else { int res ; res = obj2ast_arg ( tmp , & kwarg , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_defaults , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""defaults\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> * out = arguments ( args , vararg , kwonlyargs , kw_defaults , kwarg , defaults , arena ) ; return 0 ; failed : Py_XDECREF ( tmp <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1297,<S2SV_StartBug> if ( ! ( ifa1 -> ifa_flags & IFA_F_SECONDARY ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> in_dev -> dead ) goto no_promotions ; if ( <S2SV_ModStart> no_promotions : 
1298,<S2SV_StartBug> if ( likely ( walk . nbytes == nbytes ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1299,"<S2SV_StartBug> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> dst = __inet6_csk_dst_check ( sk , np -> dst_cookie ) ; <S2SV_EndBug> ",<S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) <S2SV_ModStart> rcu_read_unlock ( ) ; 
1300,"<S2SV_StartBug> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <S2SV_EndBug> ",<S2SV_ModStart> HeapOverflowSanityCheck <S2SV_ModEnd> 
1301,"<S2SV_StartBug> number_planes , <S2SV_EndBug> <S2SV_StartBug> if ( ( number_pixels * number_planes ) != ( size_t ) ( number_pixels * number_planes ) ) <S2SV_EndBug> <S2SV_StartBug> pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes , 4 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , number_planes_filled <S2SV_ModStart> number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; <S2SV_ModStart> number_planes_filled <S2SV_ModEnd> <S2SV_ModStart> number_planes_filled <S2SV_ModEnd> <S2SV_ModStart> number_planes_filled <S2SV_ModEnd> "
1302,"<S2SV_StartBug> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> fl6 -> saddr = ireq -> ir_v6_loc_addr ; <S2SV_EndBug> ",<S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) <S2SV_ModStart> rcu_read_unlock ( ) ; 
1303,<S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> abort ( <S2SV_ModEnd> 
1304,"<S2SV_StartBug> char * ksep , * vsep , * val ; <S2SV_EndBug> <S2SV_StartBug> vsep = memchr ( var -> ptr , '&' , var -> end - var -> ptr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! eof ) { <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ","<S2SV_ModStart> start , * <S2SV_ModStart> start = var -> ptr + var -> already_scanned ; <S2SV_ModStart> start <S2SV_ModEnd> <S2SV_ModStart> start <S2SV_ModEnd> <S2SV_ModStart> var -> already_scanned = var -> end - var -> ptr ; <S2SV_ModStart> var -> already_scanned = 0 ; "
1305,<S2SV_StartBug> if ( ape -> totalframes > UINT_MAX / sizeof ( APEFrame ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> ! ape -> totalframes ) { av_log ( s , AV_LOG_ERROR , ""No<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>the<S2SV_blank>file!\\n"" ) ; return AVERROR ( EINVAL ) ; } if ( "
1306,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> hrtimer_try_to_cancel ( & stime -> hrt ) ; 
1307,"<S2SV_StartBug> static void update_state_rt ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> * ( xd -> mi [ 0 ] ) = ctx -> mic ; <S2SV_EndBug> <S2SV_StartBug> if ( ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) && seg -> enabled ) { <S2SV_EndBug> <S2SV_StartBug> vp9_cyclic_refresh_update_segment ( cpi , & xd -> mi [ 0 ] -> mbmi , <S2SV_EndBug> <S2SV_StartBug> mi_row , mi_col , bsize , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_update_mv_count ( cm , xd ) ; <S2SV_EndBug> <S2SV_StartBug> ++ cm -> counts . switchable_interp [ pred_ctx ] [ mbmi -> interp_filter ] ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> MODE_INFO * const mi = xd -> mi [ 0 ] ; <S2SV_ModStart> const int bw = num_8x8_blocks_wide_lookup [ mi -> mbmi . sb_type ] ; const int bh = num_8x8_blocks_high_lookup [ mi -> mbmi . sb_type ] ; const int x_mis = MIN ( bw , cm -> mi_cols - mi_col ) ; const int y_mis = MIN ( bh , cm -> mi_rows - mi_row ) ; <S2SV_ModStart> * ( x -> mbmi_ext ) = ctx -> mbmi_ext ; if ( seg -> enabled && cpi -> oxcf . aq_mode ) { if <S2SV_ModEnd> <S2SV_ModStart> COMPLEXITY_AQ || cpi -> oxcf . aq_mode == VARIANCE_AQ ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; mbmi -> segment_id = get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; } else <S2SV_ModEnd> <S2SV_ModStart> mbmi , <S2SV_ModEnd> <S2SV_ModStart> ctx -> rate , ctx -> dist , x -> skip ) ; } <S2SV_ModEnd> <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> td -> counts -> <S2SV_ModEnd> <S2SV_ModStart> if ( mbmi -> sb_type < BLOCK_8X8 ) { mbmi -> mv [ 0 ] . as_int = mi -> bmi [ 3 ] . as_mv [ 0 ] . as_int ; mbmi -> mv [ 1 ] . as_int = mi -> bmi [ 3 ] . as_mv [ 1 ] . as_int ; } } if ( cm -> use_prev_frame_mvs ) { MV_REF * const frame_mvs = cm -> cur_frame -> mvs + mi_row * cm -> mi_cols + mi_col ; int w , h ; for ( h = 0 ; h < y_mis ; ++ h ) { MV_REF * const frame_mv = frame_mvs + h * cm -> mi_cols ; for ( w = 0 ; w < x_mis ; ++ w ) { MV_REF * const mv = frame_mv + w ; mv -> ref_frame [ 0 ] = mi -> mbmi . ref_frame [ 0 ] ; mv -> ref_frame [ 1 ] = mi -> mbmi . ref_frame [ 1 ] ; mv -> mv [ 0 ] . as_int = mi -> mbmi . mv [ 0 ] . as_int ; mv -> mv [ 1 ] . as_int = mi -> mbmi . mv [ 1 ] . as_int ; } } <S2SV_ModStart> x -> skip_txfm [ 0 ] = mbmi -> segment_id ? 0 : ctx -> skip_txfm [ 0 ] ; "
1308,"<S2SV_StartBug> p ++ ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 <S2SV_ModStart> 1 <S2SV_ModEnd> "
1309,"<S2SV_StartBug> # ifndef _MSC_VER <S2SV_EndBug> <S2SV_StartBug> char filename [ dirent . namelen + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( hook ( filename , type , fdiro , closure ) ) <S2SV_EndBug> ",<S2SV_ModStart> char * filename = grub_malloc ( <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart> if ( ! filename ) { break ; } <S2SV_ModStart> { free ( filename ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> { free ( filename ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> { free ( filename ) ; <S2SV_ModEnd> <S2SV_ModStart> { free ( filename ) ; return 1 ; } free ( filename ) <S2SV_ModEnd> 
1310,<S2SV_StartBug> if ( o == NULL ) return ; <S2SV_EndBug> ,"<S2SV_ModStart> || checkType ( c , o , OBJ_STREAM ) "
1311,<S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit ) { <S2SV_EndBug> ,<S2SV_ModStart> limit || ( unsigned char * ) e + e -> next_offset > 
1312,"<S2SV_StartBug> rad_get_vendor_attr ( u_int32_t * vendor , const void * * data , size_t * len ) <S2SV_EndBug> <S2SV_StartBug> attr = ( struct vendor_attribute * ) * data ; <S2SV_EndBug> <S2SV_StartBug> * vendor = ntohl ( attr -> vendor_value ) ; <S2SV_EndBug> <S2SV_StartBug> return ( attr -> attrib_type ) ; <S2SV_EndBug> ","<S2SV_ModStart> , unsigned char * type <S2SV_ModStart> , const void * raw , size_t raw_len <S2SV_ModStart> if ( raw_len < sizeof ( struct vendor_attribute ) ) { return - 1 ; } <S2SV_ModStart> raw <S2SV_ModEnd> <S2SV_ModStart> ; * type = attr -> attrib_type <S2SV_ModStart> if ( ( attr -> attrib_len + 4 ) > raw_len ) { return - 1 ; } "
1313,<S2SV_StartBug> if ( clone_info ) <S2SV_EndBug> <S2SV_StartBug> DeleteImageFromList ( & tmp ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( tmp == image2 ) image2 = ( Image * ) NULL ; 
1314,<S2SV_StartBug> buffer = malloc ( ( uint64_t ) msg . sct . length + 1 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( msg . sct . length > 1 << 20 ) { rfbClientErr ( ""Ignoring<S2SV_blank>too<S2SV_blank>big<S2SV_blank>cut<S2SV_blank>text<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\n"" , ( unsigned int ) msg . sct . length ) ; return FALSE ; } "
1315,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mode != inode -> i_mode ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error ) return error <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1316,"<S2SV_StartBug> int64_t target_end = s -> end_off ? s -> end_off : s -> filesize ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ! s -> willclose || s -> chunksize < 0 ) && <S2SV_EndBug> <S2SV_StartBug> if ( ! len && ( ! s -> willclose || s -> chunksize < 0 ) && <S2SV_EndBug> <S2SV_StartBug> ""Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%"" PRId64 "",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%"" PRId64 ""\\n"" , <S2SV_EndBug> ","<S2SV_ModStart> uint64_t <S2SV_ModEnd> <S2SV_ModStart> == UINT64_MAX ) <S2SV_ModEnd> <S2SV_ModStart> == UINT64_MAX ) && s -> off < <S2SV_ModEnd> <S2SV_ModStart> PRIu64 "",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%"" PRIu64 <S2SV_ModEnd> "
1317,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ( void ) cpi ; 
1318,<S2SV_StartBug> if ( length > 0 ) <S2SV_EndBug> ,<S2SV_ModStart> 1 <S2SV_ModEnd> 
1319,"<S2SV_StartBug> if ( ! bin ) <S2SV_EndBug> <S2SV_StartBug> ret = v3d_job_init ( v3d , file_priv , & bin -> base , <S2SV_EndBug> <S2SV_StartBug> v3d_job_put ( & render -> base ) ; <S2SV_EndBug> ",<S2SV_ModStart> { v3d_job_put ( & render -> base ) ; <S2SV_ModStart> } <S2SV_ModStart> ) ; kfree ( bin 
1320,"<S2SV_StartBug> With ( asdl_seq * items , asdl_seq * body , int lineno , int col_offset , int <S2SV_EndBug> <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug> ","<S2SV_ModStart> string type_comment , <S2SV_ModStart> v . With . type_comment = type_comment ; p -> "
1321,<S2SV_StartBug> bool compat ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> , struct iov_iter * iter <S2SV_ModStart> iov_iter_init ( iter , rw , * iovec , * nr_segs , * len ) ; "
1322,<S2SV_StartBug> struct tpacket_req * req = & req_u -> req ; <S2SV_EndBug> <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( pg_vec ) <S2SV_EndBug> ,"<S2SV_ModStart> ; lock_sock ( sk ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( pg_vec ) free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ; out : <S2SV_ModStart>  <S2SV_ModEnd> "
1323,<S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_16 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 32 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_32 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 64 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_64 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 128 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_128 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 256 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_256 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 512 ) <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_512 ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = COAP_BLOCK_SIZE_1024 ; <S2SV_EndBug> <S2SV_StartBug> request -> txBlockSzx = coapClientGetMaxBlockSize ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } 
1324,"<S2SV_StartBug> struct sas_task * task = TO_SAS_TASK ( cmd ) ; <S2SV_EndBug> <S2SV_StartBug> scsi_eh_finish_cmd ( cmd , & sas_ha -> eh_done_q ) ; <S2SV_EndBug> ","<S2SV_ModStart> domain_device * dev = cmd_to_domain_dev ( cmd ) ; struct <S2SV_ModStart> if ( dev_is_sata ( dev ) ) { list_move_tail ( & cmd -> eh_entry , & sas_ha -> eh_ata_q ) ; return ; } "
1325,"<S2SV_StartBug> char * * values = NULL , * strval [ 10 ] = { NULL } , errbuf [ 1024 ] ; <S2SV_EndBug> <S2SV_StartBug> krb5_boolean krb_identity_exists = FALSE , establish_links = FALSE ; <S2SV_EndBug> <S2SV_StartBug> int dnlen = 0 , subtreelen = 0 ; <S2SV_EndBug> <S2SV_StartBug> goto cleanup ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( subtreelist == NULL ) { st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ; if ( st ) goto cleanup ; } st = validate_xargs ( context , ldap_server_handle , & xargs , standalone_principal_dn , subtreelist , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1326,"<S2SV_StartBug> ! ( e -> ip . flags & IPT_F_GOTO ) ) <S2SV_EndBug> <S2SV_StartBug> e = get_entry ( table_base , v ) ; <S2SV_EndBug> ",<S2SV_ModStart> { if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; } <S2SV_ModStart> } 
1327,<S2SV_StartBug> copy_flags |= CL_SHARED_TO_SLAVE ; <S2SV_EndBug> ,<S2SV_ModStart> | CL_UNPRIVILEGED 
1328,"<S2SV_StartBug> num_pages = get_user_pages_fast ( base , size , 0 , & page [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( num_pages != size ) || <S2SV_EndBug> ",<S2SV_ModStart> if ( i + size > MAX_SKB_FRAGS ) return - EMSGSIZE ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1329,<S2SV_StartBug> for ( y = 0 ; y < s -> height ; ++ y ) { <S2SV_EndBug> ,<S2SV_ModStart> av_assert0 ( s -> bit_depth > 1 ) ; 
1330,"<S2SV_StartBug> static void utee_param_to_param ( struct tee_ta_param * p , struct utee_params * up ) <S2SV_EndBug> <S2SV_StartBug> switch ( TEE_PARAM_TYPE_GET ( types , n ) ) { <S2SV_EndBug> <S2SV_StartBug> case TEE_PARAM_TYPE_MEMREF_INPUT : <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> TEE_Result utee_param_to_param ( struct user_ta_ctx * utc , <S2SV_ModEnd> <S2SV_ModStart> uint32_t flags = TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER ; <S2SV_ModStart> TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : flags |= TEE_MEMORY_ACCESS_WRITE ; case TEE_PARAM_TYPE_MEMREF_INPUT <S2SV_ModEnd> <S2SV_ModStart> if ( tee_mmu_check_access_rights ( utc , flags , a , b ) ) return TEE_ERROR_ACCESS_DENIED ; <S2SV_ModStart> return TEE_SUCCESS ; "
1331,<S2SV_StartBug> if ( sk != asoc -> base . sk ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1332,"<S2SV_StartBug> gchar * filename ; <S2SV_EndBug> <S2SV_StartBug> filename = g_build_filename ( g_get_tmp_dir ( ) , ""gimp-test.xcf"" , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> = NULL ; gint file_handle <S2SV_ModStart> file_handle = g_file_open_tmp ( ""gimp-test-XXXXXX.xcf"" , & filename , NULL ) ; g_assert ( file_handle != - 1 ) ; close ( file_handle <S2SV_ModEnd> "
1333,"<S2SV_StartBug> stride = ( ( Info_h . biWidth * Info_h . biBitCount + 31U ) / 32U ) * 4U ; <S2SV_EndBug> <S2SV_StartBug> if ( Info_h . biBitCount == 4 && Info_h . biCompression == 2 ) { <S2SV_EndBug> <S2SV_StartBug> pData = ( OPJ_UINT8 * ) calloc ( 1 , stride * Info_h . biHeight * sizeof ( OPJ_UINT8 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( Info_h . biWidth == 0 || Info_h . biHeight == 0 ) { fclose ( IN ) ; return NULL ; } if ( Info_h . biBitCount > ( ( ( OPJ_UINT32 ) - 1 ) - 31 ) / Info_h . biWidth ) { fclose ( IN ) ; return NULL ; } <S2SV_ModStart> if ( 8 > ( ( ( OPJ_UINT32 ) - 1 ) - 31 ) / Info_h . biWidth ) { fclose ( IN ) ; return NULL ; } <S2SV_ModStart> if ( stride > ( ( OPJ_UINT32 ) - 1 ) / sizeof ( OPJ_UINT8 ) / Info_h . biHeight ) { fclose ( IN ) ; return NULL ; } 
1334,<S2SV_StartBug> pte_unmap ( page_table ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! vma -> vm_ops -> fault ) return VM_FAULT_SIGBUS 
1335,"<S2SV_StartBug> struct nfs_open_context * nfs_find_open_context ( struct inode * inode , struct rpc_cred * cred , int mode ) <S2SV_EndBug> ",<S2SV_ModStart> fmode_t <S2SV_ModEnd> 
1336,<S2SV_StartBug> } else if ( event -> type == et_char ) { <S2SV_EndBug> ,"<S2SV_ModStart> et_controlevent && event -> u . control . subtype == et_textchanged ) { sd -> fv -> script_unsaved = ! GTextFieldIsEmpty ( GWidgetGetControl ( sd -> gw , CID_Script ) ) ; } else if ( event -> type == et_controlevent && event -> u . control . subtype == et_save ) { sd -> fv -> script_unsaved = false ; } else if ( event -> type == "
1337,"<S2SV_StartBug> for ( i = 0 ; i < numcmpts ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> data [ i ] = jas_matrix_create ( jas_image_height ( image ) , jas_image_width ( image ) ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> nz -= 8 ; <S2SV_EndBug> ","<S2SV_ModStart> assert ( numcmpts <= 3 ) ; for ( i = 0 ; i < 3 ; ++ i ) { data [ i ] = 0 ; } <S2SV_ModStart> if ( ! ( <S2SV_ModStart> ) ) { goto error ; } <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error ; } nz -= 8 ; z &= RAS_ONES ( nz ) ; } } if ( nz > 0 ) { c = ( z >> ( 8 - nz ) ) & RAS_ONES ( nz ) ; if ( jas_stream_putc ( out , c ) == EOF ) { goto error ; } } if ( pad % 2 ) { if ( jas_stream_putc ( out , 0 ) == EOF ) { goto error ; } } } for ( i = 0 ; i < numcmpts ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; data [ i ] = 0 ; } return 0 ; error : for ( i = 0 ; i < numcmpts ; ++ i ) { if ( data [ i ] ) { jas_matrix_destroy ( data [ i ] ) ; } } <S2SV_ModStart>  <S2SV_ModEnd> "
1338,"<S2SV_StartBug> quit ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>header<S2SV_blank>to<S2SV_blank>header_bin<S2SV_blank>in<S2SV_blank>parse_notify"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> { applog ( LOG_WARNING , ""%s:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>header<S2SV_blank>to<S2SV_blank>header_bin,<S2SV_blank>got<S2SV_blank>%s"" , __func__ , header ) ; pool_failed ( pool ) ; return false ; } <S2SV_ModEnd> "
1339,<S2SV_StartBug> vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( vcpu -> arch . time_offset & ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break 
1340,"<S2SV_StartBug> if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> memset ( box , 0 , sizeof ( jp2_box_t ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> jp2_box_create0 ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1341,"<S2SV_StartBug> int align ; <S2SV_EndBug> <S2SV_StartBug> default : <S2SV_EndBug> <S2SV_StartBug> xcs = 1 ; <S2SV_EndBug> <S2SV_StartBug> case VPX_IMG_FMT_YV12 : <S2SV_EndBug> <S2SV_StartBug> case VPX_IMG_FMT_VPXYV12 : <S2SV_EndBug> <S2SV_StartBug> if ( ! img ) { <S2SV_EndBug> <S2SV_StartBug> img -> img_data = img_buf_memalign ( buf_align , ( ( fmt & VPX_IMG_FMT_PLANAR ) ? <S2SV_EndBug> <S2SV_StartBug> h * s * bps / 8 : h * s ) ) ; <S2SV_EndBug> <S2SV_StartBug> img -> fmt = fmt ; <S2SV_EndBug> <S2SV_StartBug> img -> stride [ VPX_PLANE_Y ] = img -> stride [ VPX_PLANE_ALPHA ] = s ; <S2SV_EndBug> <S2SV_StartBug> img -> stride [ VPX_PLANE_U ] = img -> stride [ VPX_PLANE_V ] = s >> xcs ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned int stride_in_bytes ; <S2SV_ModStart> case VPX_IMG_FMT_I422 : case VPX_IMG_FMT_I440 : bps = 16 ; break ; case VPX_IMG_FMT_I444 : bps = 24 ; break ; case VPX_IMG_FMT_I42016 : bps = 24 ; break ; case VPX_IMG_FMT_I42216 : case VPX_IMG_FMT_I44016 : bps = 32 ; break ; case VPX_IMG_FMT_I44416 : bps = 48 ; break ; <S2SV_ModStart> case VPX_IMG_FMT_I422 : case VPX_IMG_FMT_I42016 : case VPX_IMG_FMT_I42216 : <S2SV_ModStart> VPX_IMG_FMT_I440 : case <S2SV_ModStart> : case VPX_IMG_FMT_I42016 : case VPX_IMG_FMT_I44016 <S2SV_ModStart> stride_in_bytes = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? s * 2 : s ; <S2SV_ModStart> const uint64_t alloc_size = <S2SV_ModEnd> <S2SV_ModStart> ( uint64_t ) <S2SV_ModStart> ( uint64_t ) <S2SV_ModStart> ; if ( alloc_size != ( size_t ) alloc_size <S2SV_ModEnd> <S2SV_ModStart> img_data = ( uint8_t * ) vpx_memalign ( buf_align , ( size_t ) alloc_size ) ; img -> img_data_owner = 1 ; } if ( ! img -> img_data ) goto fail ; img -> fmt = fmt ; img -> bit_depth = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 16 : 8 <S2SV_ModEnd> <S2SV_ModStart> stride_in_bytes <S2SV_ModEnd> <S2SV_ModStart> stride_in_bytes <S2SV_ModEnd> "
1342,"<S2SV_StartBug> static int match ( Reinst * pc , const char * sp , const char * bol , int flags , Resub * out ) <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( match ( pc -> x , sp , bol , flags , & scratch ) ) { <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! match ( pc -> x , sp , bol , flags , out ) ) <S2SV_EndBug> <S2SV_StartBug> if ( match ( pc -> x , sp , bol , flags , & scratch ) ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> , int depth <S2SV_ModStart> result ; int <S2SV_ModStart> if ( depth > MAXREC ) return - 1 ; <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> result = <S2SV_ModEnd> <S2SV_ModStart> , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 0 <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> result = <S2SV_ModEnd> <S2SV_ModStart> , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 1 ) return 1 <S2SV_ModEnd> <S2SV_ModStart> result = <S2SV_ModEnd> <S2SV_ModStart> , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 0 ) return 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> "
1343,"<S2SV_StartBug> unix_state_double_unlock ( sk , other ) ; <S2SV_EndBug> ","<S2SV_ModStart> unix_dgram_peer_wake_disconnect_wakeup ( sk , old_peer ) ; "
1344,"<S2SV_StartBug> return luaL_argerror ( L , 0 , ""MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input."" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; if ( ! lua_checkstack ( L , nargs ) ) return luaL_argerror ( L , 0 , ""Too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>MessagePack<S2SV_blank>pack."" "
1345,<S2SV_StartBug> # undef _ <S2SV_EndBug> ,<S2SV_ModStart> _ ( NPNVprivateModeBool ) ; _ ( NPNVsupportsAdvancedKeyHandling ) ; 
1346,<S2SV_StartBug> tilebuf = _TIFFmalloc ( tile_buffsize ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( tile_buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size."" ) ; exit ( - 1 ) ; } <S2SV_ModStart> + 3 <S2SV_ModStart> 0 ; tilebuf [ tile_buffsize ] = 0 ; tilebuf [ tile_buffsize + 1 ] = 0 ; tilebuf [ tile_buffsize + 2 ] = "
1347,<S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ; <S2SV_EndBug> ,"<S2SV_ModStart> size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> alloc_size <S2SV_ModEnd> "
1348,"<S2SV_StartBug> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> <S2SV_StartBug> i += verdef -> vd_next ; <S2SV_EndBug> ","<S2SV_ModStart> i >= 0 && <S2SV_ModStart> if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( ""Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n"" ) ; break ; } "
1349,"<S2SV_StartBug> ( * sp -> decodepfunc ) ( tif , op0 , occ0 ) ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ",<S2SV_ModStart> return <S2SV_ModStart>  <S2SV_ModEnd> 
1350,<S2SV_StartBug> for ( i = 0 ; mechbuf [ i ] ; i ++ ) mechbuf [ i ] = tolower ( mechbuf [ i ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>mech<S2SV_blank>(mech=%s)"" , mechbuf "
1351,"<S2SV_StartBug> static int jas_iccputsint ( jas_stream_t * out , int n , longlong val ) <S2SV_EndBug> <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> ",<S2SV_ModStart> jas_longlong <S2SV_ModEnd> <S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> 
1352,"<S2SV_StartBug> size_t buf_size = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_pack ( msg -> msg_iov , ( int ) msg -> msg_iovlen , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> & msg -> msg_namelen , <S2SV_EndBug> <S2SV_StartBug> & msg -> msg_controllen , <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_sync ( msg -> msg_iov , ( int ) msg -> msg_iovlen , buf , buf_size ) != 0 ) <S2SV_EndBug> ","<S2SV_ModStart> = 0 ; size_t data_size = 0 ; oe_socklen_t namelen_out = 0 ; size_t controllen_out <S2SV_ModStart> , & data_size <S2SV_ModStart> if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_ModStart> namelen_out <S2SV_ModEnd> <S2SV_ModStart> controllen_out <S2SV_ModEnd> <S2SV_ModStart> ! msg -> msg_name ) msg -> msg_namelen = 0 ; else { if ( namelen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( msg -> msg_namelen >= namelen_out ) msg -> msg_namelen = namelen_out ; } if ( ! msg -> msg_control ) msg -> msg_controllen = 0 ; else { if ( msg -> msg_controllen >= controllen_out ) msg -> msg_controllen = controllen_out ; else msg -> msg_flags |= OE_MSG_CTRUNC ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( "
1353,<S2SV_StartBug> struct usb_serial * serial = port -> serial ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1354,<S2SV_StartBug> if ( ! handle -> h_transaction ) { <S2SV_EndBug> <S2SV_StartBug> err = jbd2_journal_stop ( handle ) ; <S2SV_EndBug> <S2SV_StartBug> return handle -> h_err ? handle -> h_err : err ; <S2SV_EndBug> <S2SV_StartBug> sb = handle -> h_transaction -> t_journal -> j_private ; <S2SV_EndBug> ,<S2SV_ModStart> err = handle -> h_err ; <S2SV_ModStart> rc <S2SV_ModEnd> <S2SV_ModStart> err ? err : rc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1355,<S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) { <S2SV_EndBug> ,<S2SV_ModStart> limit || ( unsigned char * ) e + e -> next_offset > 
1356,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""gnuplot<S2SV_blank>%s"" , cmdname ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""wgnuplot<S2SV_blank>%s"" , cmdname ) ; <S2SV_EndBug> ",<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> 
1357,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1358,"<S2SV_StartBug> char * * values = NULL , * strval [ 10 ] = { NULL } , errbuf [ 1024 ] ; <S2SV_EndBug> <S2SV_StartBug> krb5_boolean krb_identity_exists = FALSE , establish_links = FALSE ; <S2SV_EndBug> <S2SV_StartBug> int dnlen = 0 , subtreelen = 0 ; <S2SV_EndBug> <S2SV_StartBug> goto cleanup ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( subtreelist == NULL ) { st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ; if ( st ) goto cleanup ; } st = validate_xargs ( context , ldap_server_handle , & xargs , standalone_principal_dn , subtreelist , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1359,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error < 0 ) <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl <S2SV_ModStart> ) return error <S2SV_ModEnd> "
1360,<S2SV_StartBug> bufsize = file -> size ; <S2SV_EndBug> ,"<S2SV_ModStart> MIN ( <S2SV_ModStart> , sizeof buf ) "
1361,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> break ; default : fastd_buffer_free ( buffer ) ; pr_debug ( ""received<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>invalid<S2SV_blank>type<S2SV_blank>from<S2SV_blank>unknown<S2SV_blank>address<S2SV_blank>%I"" , remote_addr ) ; "
1362,<S2SV_StartBug> static LAYER_CONTEXT * get_layer_context ( SVC * svc ) { <S2SV_EndBug> <S2SV_StartBug> return svc -> number_temporal_layers > 1 ? <S2SV_EndBug> <S2SV_StartBug> & svc -> layer_context [ svc -> spatial_layer_id ] ; <S2SV_EndBug> ,<S2SV_ModStart> VP9_COMP * const cpi ) { if ( is_one_pass_cbr_svc ( cpi ) ) return & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers + cpi -> svc . temporal_layer_id ] ; else return ( cpi -> svc . <S2SV_ModEnd> <S2SV_ModStart> && cpi -> oxcf . rc_mode == VPX_CBR ) ? & cpi -> svc . layer_context [ cpi -> svc . <S2SV_ModEnd> <S2SV_ModStart> cpi -> svc . layer_context [ cpi -> svc . <S2SV_ModEnd> 
1363,<S2SV_StartBug> void unix_inflight ( struct file * fp ) <S2SV_EndBug> <S2SV_StartBug> fp -> f_cred -> user -> unix_inflight ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> struct user_struct * user , <S2SV_ModStart>  <S2SV_ModEnd> "
1364,"<S2SV_StartBug> SCV_NB10_HEADER nb10_hdr ; <S2SV_EndBug> <S2SV_StartBug> ""%x%x"" , nb10_hdr . timestamp , nb10_hdr . age ) ; <S2SV_EndBug> <S2SV_StartBug> nb10_hdr . file_name , sizeof ( res -> file_name ) - 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( dbg_data_len < 20 ) { eprintf ( ""Truncated<S2SV_blank>NB10<S2SV_blank>entry,<S2SV_blank>not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>parse\\n"" ) ; return 0 ; } SCV_NB10_HEADER nb10_hdr = { { 0 } } <S2SV_ModEnd> <S2SV_ModStart> res -> file_name [ 0 ] = 0 ; if ( nb10_hdr . file_name ) { <S2SV_ModStart> } "
1365,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( dcfg -> xml_external_entity == NOT_SET ) dcfg -> xml_external_entity = 0 ; 
1366,"<S2SV_StartBug> Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; return ; } if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) { Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".cfg\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" "
1367,<S2SV_StartBug> num ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( num > MaxAllocSize / ITEMSIZE ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , num , ( int ) ( MaxAllocSize / ITEMSIZE ) ) ) ) "
1368,<S2SV_StartBug> case MFR_CTRL_IE_MAGIC_NUM : <S2SV_EndBug> ,"<S2SV_ModStart> if ( ie_len != 4 ) { ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>length)"" ) ) ; break ; } "
1369,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> usb_conv_info -> class_data_type = USB_CONV_MASS_STORAGE ; } else if ( usb_conv_info -> class_data_type != USB_CONV_MASS_STORAGE ) { return 0 ; 
1370,<S2SV_StartBug> port -> exists = true ; <S2SV_EndBug> <S2SV_StartBug> mb ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> spin_lock_irq ( & i8042_lock ) ; <S2SV_ModStart> spin_unlock_irq ( & i8042_lock <S2SV_ModEnd> 
1371,"<S2SV_StartBug> nl_parse ( pipenum , & config ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ensure_cloned_binary ( ) < 0 ) bail ( ""could<S2SV_blank>not<S2SV_blank>ensure<S2SV_blank>we<S2SV_blank>are<S2SV_blank>a<S2SV_blank>cloned<S2SV_blank>binary"" ) ; "
1372,"<S2SV_StartBug> 1 , 0 , regs , regs -> cp0_badvaddr ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1373,<S2SV_StartBug> VM_SHARED | VM_MAYSHARE | <S2SV_EndBug> <S2SV_StartBug> VM_SHARED | VM_MAYSHARE | <S2SV_EndBug> ,<S2SV_ModStart> VM_NO_THP <S2SV_ModEnd> <S2SV_ModStart> VM_NO_THP <S2SV_ModEnd> 
1374,"<S2SV_StartBug> rsrc . type_count = read_rsrc_short ( & rsrc , rsrc . map_offset + 28 ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> { marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( rsrc . map_offset + 28 > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>map<S2SV_blank>offset.\\n"" ) ; goto parse_rsrc_fork_cleanup ; } ; <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>rsrc<S2SV_blank>marker.\\n"" ) ; goto parse_rsrc_fork_cleanup ; } ; marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8 "
1375,<S2SV_StartBug> return HTTP_FORBIDDEN ; <S2SV_EndBug> ,"<S2SV_ModStart> SSL_set_verify ( ssl , verify_old , ssl_callback_SSLVerify ) ; "
1376,"<S2SV_StartBug> vpx_codec_ctx_t codec = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> vpx_codec_enc_cfg_t cfg = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> vpx_image_t raw = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> VpxVideoInfo info = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> encoder = get_vpx_encoder_by_name ( argv [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! encoder ) <S2SV_EndBug> <S2SV_StartBug> die ( ""Unsupported<S2SV_blank>codec."" ) ; <S2SV_EndBug> <S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) ) <S2SV_EndBug> <S2SV_StartBug> encode_frame ( & codec , NULL , - 1 , writer ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memset ( & info , 0 , sizeof ( info ) ) ; <S2SV_ModStart> encoder == NULL ) { <S2SV_ModEnd> <S2SV_ModStart> ) ; } assert ( encoder != NULL <S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> while ( <S2SV_ModStart> ) { } <S2SV_ModEnd> "
1377,<S2SV_StartBug> if ( vcpu -> arch . time_page ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pv_time_enabled = false ; } <S2SV_ModEnd> 
1378,<S2SV_StartBug> void close_connection ( h2o_http2_conn_t * conn ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return - 1 ; } return 0 ; <S2SV_ModEnd> 
1379,"<S2SV_StartBug> avio_skip ( pb , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> sscanf ( val , ""%"" SCNu32 ""%"" SCNu32 ""%"" SCNu32 ""%"" SCNu32 , <S2SV_EndBug> <S2SV_StartBug> for ( idx = 0 ; idx < 4 ; idx ++ ) { <S2SV_EndBug> ",<S2SV_ModStart> int ret ; <S2SV_ModStart> ret = <S2SV_ModStart> if ( ret != 4 ) return AVERROR_INVALIDDATA ; 
1380,"<S2SV_StartBug> struct vp9_read_bit_buffer * rb ) { <S2SV_EndBug> <S2SV_StartBug> size_t sz ; <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_rb_read_literal ( rb , 2 ) != VP9_FRAME_MARKER ) <S2SV_EndBug> <S2SV_StartBug> cm -> profile = read_profile ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> show_existing_frame = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> const int frame_to_show = cm -> ref_frame_map [ vp9_rb_read_literal ( rb , 3 ) ] ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_bufs [ frame_to_show ] . ref_count < 1 ) <S2SV_EndBug> <S2SV_StartBug> ref_cnt_fb ( cm -> frame_bufs , & cm -> new_fb_idx , frame_to_show ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> cm -> frame_type = ( FRAME_TYPE ) vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> show_frame = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> error_resilient_mode = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> check_sync_code ( cm , rb ) ; <S2SV_EndBug> <S2SV_StartBug> ""RGB<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank>0"" ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> frame_refs [ i ] . idx = cm -> new_fb_idx ; <S2SV_EndBug> <S2SV_StartBug> cm -> frame_refs [ i ] . buf = get_frame_new_buffer ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> setup_frame_size ( cm , rb ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> intra_only = cm -> show_frame ? 0 : vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> 0 : vp9_rb_read_literal ( rb , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> check_sync_code ( cm , rb ) ; <S2SV_EndBug> <S2SV_StartBug> pbi -> refresh_frame_flags = vp9_rb_read_literal ( rb , REF_FRAMES ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> pbi -> refresh_frame_flags = vp9_rb_read_literal ( rb , REF_FRAMES ) ; <S2SV_EndBug> <S2SV_StartBug> const int ref = vp9_rb_read_literal ( rb , REF_FRAMES_LOG2 ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> frame_refs [ i ] . idx = idx ; <S2SV_EndBug> <S2SV_StartBug> cm -> frame_refs [ i ] . buf = & cm -> frame_bufs [ idx ] . buf ; <S2SV_EndBug> <S2SV_StartBug> cm -> ref_frame_sign_bias [ LAST_FRAME + i ] = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> allow_high_precision_mv = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_setup_scale_factors_for_frame ( & ref_buf -> sf , <S2SV_EndBug> <S2SV_StartBug> cm -> width , cm -> height ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_is_scaled ( & ref_buf -> sf ) ) <S2SV_EndBug> <S2SV_StartBug> vp9_extend_frame_borders ( ref_buf -> buf ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> coding_use_prev_mi = 1 ; <S2SV_EndBug> <S2SV_StartBug> cm -> refresh_frame_context = vp9_rb_read_bit ( rb ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> coding_use_prev_mi = 0 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> setup_tile_info ( cm , rb ) ; <S2SV_EndBug> <S2SV_StartBug> sz = vp9_rb_read_literal ( rb , 16 ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_read_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> BufferPool * const pool = cm -> buffer_pool ; RefCntBuffer * const frame_bufs = pool -> frame_bufs ; int i , mask , ref_index = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cm -> last_intra_only = cm -> intra_only ; if ( vpx_rb_read_literal <S2SV_ModEnd> <S2SV_ModStart> vp9_read_profile ( rb ) ; # if CONFIG_VP9_HIGHBITDEPTH <S2SV_ModEnd> <S2SV_ModStart> # else if ( cm -> profile >= PROFILE_2 ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Unsupported<S2SV_blank>bitstream<S2SV_blank>profile"" ) ; # endif <S2SV_ModStart> vpx_rb_read_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_rb_read_literal <S2SV_ModEnd> <S2SV_ModStart> lock_buffer_pool ( pool ) ; if ( frame_to_show < 0 || <S2SV_ModEnd> <S2SV_ModStart> { unlock_buffer_pool ( pool ) ; <S2SV_ModStart> } ref_cnt_fb ( <S2SV_ModEnd> <S2SV_ModStart> ) ; unlock_buffer_pool ( pool <S2SV_ModStart> if ( pbi -> frame_parallel_decode ) { for ( i = 0 ; i < REF_FRAMES ; ++ i ) cm -> next_ref_frame_map [ i ] = cm -> ref_frame_map [ i ] ; } <S2SV_ModStart> vpx_rb_read_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_rb_read_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_rb_read_bit <S2SV_ModEnd> <S2SV_ModStart> if ( ! vp9_read_sync_code ( rb ) ) <S2SV_ModEnd> <S2SV_ModStart> ""Invalid<S2SV_blank>frame<S2SV_blank>sync<S2SV_blank>code"" ) ; read_bitdepth_colorspace_sampling ( cm , rb ) ; <S2SV_ModEnd> <S2SV_ModStart> INVALID_IDX <S2SV_ModEnd> <S2SV_ModStart> NULL <S2SV_ModEnd> <S2SV_ModStart> if ( pbi -> need_resync ) { memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ; pbi -> need_resync = 0 ; } <S2SV_ModStart> vpx_rb_read_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_rb_read_literal <S2SV_ModEnd> <S2SV_ModStart> if ( ! vp9_read_sync_code ( rb ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Invalid<S2SV_blank>frame<S2SV_blank>sync<S2SV_blank>code"" ) ; if ( cm -> profile > PROFILE_0 ) { read_bitdepth_colorspace_sampling ( cm , rb ) ; } else { cm -> color_space = VPX_CS_BT_601 ; cm -> subsampling_y = cm -> subsampling_x = 1 ; cm -> bit_depth = VPX_BITS_8 ; # if CONFIG_VP9_HIGHBITDEPTH cm -> use_highbitdepth = 0 ; # endif } <S2SV_ModEnd> <S2SV_ModStart> vpx_rb_read_literal <S2SV_ModEnd> <S2SV_ModStart> if ( pbi -> need_resync ) { memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ; pbi -> need_resync = 0 ; } } else if ( pbi -> need_resync != 1 ) <S2SV_ModEnd> <S2SV_ModStart> vpx_rb_read_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_rb_read_literal <S2SV_ModEnd> <S2SV_ModStart> RefBuffer * const ref_frame = & <S2SV_ModStart> ; ref_frame -> <S2SV_ModEnd> <S2SV_ModStart> ref_frame -> buf = & frame_bufs [ idx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_rb_read_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_rb_read_bit <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH <S2SV_ModStart> , cm -> use_highbitdepth ) ; # else vp9_setup_scale_factors_for_frame <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> -> y_crop_width , ref_buf -> buf -> y_crop_height , cm -> width , cm -> height ) ; # endif } } } # if CONFIG_VP9_HIGHBITDEPTH get_frame_new_buffer ( cm ) -> bit_depth = cm -> bit_depth ; # endif get_frame_new_buffer ( cm ) -> color_space = cm -> color_space ; if ( pbi -> need_resync ) { vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Keyframe<S2SV_blank>/<S2SV_blank>intra-only<S2SV_blank>frame<S2SV_blank>required<S2SV_blank>to<S2SV_blank>reset<S2SV_blank>decoder"" ""<S2SV_blank>state"" ) ; <S2SV_ModEnd> <S2SV_ModStart> refresh_frame_context = vpx_rb_read_bit ( rb ) ; cm -> frame_parallel_decoding_mode = vpx_rb_read_bit ( rb ) ; } else { cm -> refresh_frame_context = 0 ; cm -> frame_parallel_decoding_mode <S2SV_ModEnd> <S2SV_ModStart> } cm -> frame_context_idx = vpx_rb_read_literal ( rb , FRAME_CONTEXTS_LOG2 ) ; lock_buffer_pool ( pool ) ; for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { if ( mask & 1 ) { cm -> next_ref_frame_map [ ref_index ] = cm -> new_fb_idx ; ++ frame_bufs [ cm -> new_fb_idx ] . ref_count <S2SV_ModEnd> <S2SV_ModStart> next_ref_frame_map [ ref_index ] = cm -> ref_frame_map [ ref_index ] ; } if ( cm -> ref_frame_map [ ref_index ] >= 0 ) ++ frame_bufs [ cm -> ref_frame_map [ ref_index ] ] . ref_count ; ++ ref_index ; } for ( ; ref_index < REF_FRAMES ; ++ ref_index ) { cm -> next_ref_frame_map [ ref_index ] = cm -> ref_frame_map [ ref_index ] ; if ( cm -> ref_frame_map [ ref_index ] >= 0 ) ++ frame_bufs [ cm -> ref_frame_map [ ref_index ] ] . ref_count ; } unlock_buffer_pool ( pool ) ; pbi -> hold_ref_buf <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> setup_segmentation_dequant ( cm ) ; <S2SV_ModStart> vpx_rb_read_literal <S2SV_ModEnd> "
1381,<S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ,"<S2SV_ModStart> ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) "
1382,<S2SV_StartBug> if ( tu -> timeri ) <S2SV_EndBug> <S2SV_StartBug> snd_timer_close ( tu -> timeri ) ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_ModStart> ) ; mutex_unlock ( & tu -> ioctl_lock 
1383,"<S2SV_StartBug> if ( ( tf = fopen ( tfile -> file_path , ""w"" ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart> fopen_safe <S2SV_ModEnd> 
1384,<S2SV_StartBug> kfree ( user ) ; <S2SV_EndBug> ,<S2SV_ModStart> cleanup_srcu_struct ( & user -> release_barrier ) ; 
1385,"<S2SV_StartBug> int blockstodecode ; <S2SV_EndBug> <S2SV_StartBug> if ( ! nblocks || nblocks > INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size , <S2SV_EndBug> <S2SV_StartBug> 2 * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; uint64_t decoded_buffer_size <S2SV_ModStart> / 2 / sizeof ( * s -> decoded_buffer ) - 8 <S2SV_ModStart> decoded_buffer_size = 2LL * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ; av_assert0 ( decoded_buffer_size <= INT_MAX ) ; <S2SV_ModStart> decoded_buffer_size <S2SV_ModEnd> "
1386,<S2SV_StartBug> if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal ) <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) && ! ( EXT4_SB ( inode -> i_sb ) -> s_mount_state & EXT4_ORPHAN_FS ) 
1387,"<S2SV_StartBug> signed long personality ; <S2SV_EndBug> <S2SV_StartBug> ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ; <S2SV_EndBug> <S2SV_StartBug> . exec_payload = exec_payload <S2SV_EndBug> ","<S2SV_ModStart> int procfd ; <S2SV_ModStart> procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY ) ; if ( procfd < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> , . procfd = procfd "
1388,"<S2SV_StartBug> static void fdct4 ( const int16_t * input , int16_t * output ) { <S2SV_EndBug> <S2SV_StartBug> int16_t step [ 4 ] ; <S2SV_EndBug> <S2SV_StartBug> int temp1 , temp2 ; <S2SV_EndBug> <S2SV_StartBug> output [ 0 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 1 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) fdct_round_shift ( temp1 ) ; output [ 2 ] = ( tran_low_t ) <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) fdct_round_shift ( temp1 ) ; output [ 3 ] = ( tran_low_t ) <S2SV_ModEnd> 
1389,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.cmd"" , rootname ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.png"" , newroot ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.ps"" , newroot ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.eps"" , newroot ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.tex"" , newroot ) ; <S2SV_EndBug> ",<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> 
1390,<S2SV_StartBug> if ( tlen < oid_len ) { <S2SV_EndBug> ,<S2SV_ModStart> 1U + 
1391,<S2SV_StartBug> client -> auth_end_offset = AUTH_END_INIT_OFFSET ; <S2SV_EndBug> ,<S2SV_ModStart> auth_buffer = g_byte_array_new ( ) <S2SV_ModEnd> 
1392,"<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> <S2SV_StartBug> decoder -> name , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> void <S2SV_ModStart> codec_interface <S2SV_ModEnd> 
1393,"<S2SV_StartBug> if ( ( read = recv ( fd , p , len , MSG_NOSIGNAL ) ) == - 1 ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1394,<S2SV_StartBug> YV12_BUFFER_CONFIG * lst_yv12 = <S2SV_EndBug> <S2SV_StartBug> lst_yv12 -> y_width * lst_yv12 -> y_height ; <S2SV_EndBug> <S2SV_StartBug> lst_yv12 -> y_width * lst_yv12 -> y_height ; <S2SV_EndBug> <S2SV_StartBug> vp8_remove_common ( & cpi -> common ) ; <S2SV_EndBug> <S2SV_StartBug> # if 0 <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cpi -> common . Width * cpi -> common . Height <S2SV_ModEnd> <S2SV_ModStart> cpi -> common . Width * cpi -> common . Height <S2SV_ModEnd> <S2SV_ModStart> vpx_free ( cpi -> consec_zero_last ) ; vpx_free ( cpi -> consec_zero_last_mvbias ) ; <S2SV_ModStart> ifdef OUTPUT_YUV_DENOISED fclose ( yuv_denoised_file ) ; # endif # 
1395,<S2SV_StartBug> static void init_decoder ( vpx_codec_alg_priv_t * ctx ) { <S2SV_EndBug> <S2SV_StartBug> VP9D_CONFIG oxcf ; <S2SV_EndBug> <S2SV_StartBug> oxcf . max_threads = ctx -> cfg . threads ; <S2SV_EndBug> <S2SV_StartBug> ctx -> pbi = vp9_decoder_create ( & oxcf ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> vpx_codec_err_t <S2SV_ModEnd> <S2SV_ModStart> int i ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; ctx -> last_show_frame = - 1 ; ctx -> next_submit_worker_id = 0 ; ctx -> last_submit_worker_id = 0 ; ctx -> next_output_worker_id = 0 ; ctx -> frame_cache_read = 0 ; ctx -> frame_cache_write = 0 ; ctx -> num_cache_frames = 0 ; ctx -> need_resync = 1 ; ctx -> num_frame_workers = ( ctx -> frame_parallel_decode == 1 ) ? <S2SV_ModEnd> <S2SV_ModStart> : 1 ; if ( ctx -> num_frame_workers > MAX_DECODE_THREADS ) ctx -> num_frame_workers = MAX_DECODE_THREADS ; ctx -> available_threads = ctx -> num_frame_workers ; ctx -> flushed = 0 ; ctx -> buffer_pool = ( BufferPool * ) vpx_calloc ( 1 , sizeof ( BufferPool ) ) ; if ( ctx -> buffer_pool == NULL ) return VPX_CODEC_MEM_ERROR ; # if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & ctx -> buffer_pool -> pool_mutex , NULL ) ) { set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>buffer<S2SV_blank>pool<S2SV_blank>mutex"" ) ; return VPX_CODEC_MEM_ERROR ; } # endif ctx -> frame_workers = ( VPxWorker * ) vpx_malloc ( ctx -> num_frame_workers * sizeof ( * ctx -> frame_workers ) ) ; if ( ctx -> frame_workers == NULL ) { set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_workers"" ) ; return VPX_CODEC_MEM_ERROR ; } for ( i = 0 ; i < ctx -> num_frame_workers ; ++ i ) { VPxWorker * const worker = & ctx -> frame_workers [ i ] ; FrameWorkerData * frame_worker_data = NULL ; winterface -> init ( worker ) ; worker -> data1 = vpx_memalign ( 32 , sizeof ( FrameWorkerData ) ) ; if ( worker -> data1 == NULL ) { set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data"" ) ; return VPX_CODEC_MEM_ERROR ; } frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; frame_worker_data <S2SV_ModEnd> <S2SV_ModStart> ctx -> buffer_pool ) ; if ( frame_worker_data <S2SV_ModEnd> <S2SV_ModStart> { set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data"" ) ; return VPX_CODEC_MEM_ERROR ; } frame_worker_data -> pbi -> frame_worker_owner = worker ; frame_worker_data -> worker_id = i ; frame_worker_data -> scratch_buffer = NULL ; frame_worker_data -> scratch_buffer_size = 0 ; frame_worker_data -> frame_context_ready = 0 ; frame_worker_data -> received_frame = 0 ; # if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & frame_worker_data -> stats_mutex , NULL ) ) { set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data<S2SV_blank>mutex"" ) ; return VPX_CODEC_MEM_ERROR ; } if ( pthread_cond_init ( & frame_worker_data -> stats_cond , NULL ) ) { set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data<S2SV_blank>cond"" ) ; return VPX_CODEC_MEM_ERROR ; } # endif frame_worker_data -> pbi -> max_threads = ( ctx -> frame_parallel_decode == 0 ) ? ctx -> cfg . threads : 0 ; frame_worker_data -> pbi -> inv_tile_order = ctx -> invert_tile_order ; frame_worker_data -> pbi -> frame_parallel_decode = ctx -> frame_parallel_decode ; frame_worker_data -> pbi -> common . frame_parallel_decode = ctx -> frame_parallel_decode ; worker -> hook = ( VPxWorkerHook ) frame_worker_hook ; if ( ! winterface -> reset ( worker ) ) { set_error_detail ( ctx , ""Frame<S2SV_blank>Worker<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed"" ) ; return VPX_CODEC_MEM_ERROR ; } } <S2SV_ModEnd> <S2SV_ModStart> return VPX_CODEC_OK ; "
1396,<S2SV_StartBug> mptctl_eventreport ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,"<S2SV_ModStart> MPT_ADAPTER * ioc , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1397,<S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> ret = - EIO ; goto out <S2SV_ModEnd> <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> goto out ; } ret = snprintf ( buf , PAGE_SIZE , ""%d\\n"" , current_profile ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> "
1398,<S2SV_StartBug> r = - ENOMEM ; <S2SV_EndBug> ,<S2SV_ModStart> EINVAL ; if ( atomic_read ( & kvm -> online_vcpus ) ) goto create_irqchip_unlock ; r = - 
1399,<S2SV_StartBug> if ( node -> v == & node -> sorted ) <S2SV_EndBug> <S2SV_StartBug> tr_free ( node -> sorted . val . l . vals ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> TR_ASSERT ( node != NULL ) ; <S2SV_ModStart> sorted != NULL <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> tr_free ( node -> sorted ) ; 
1400,<S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> ,"<S2SV_ModStart> size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> alloc_size <S2SV_ModEnd> "
1401,"<S2SV_StartBug> if ( fscanf ( fp , ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%s\\n"" , & n , typestr ) != 2 ) <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%127s\\n"" <S2SV_ModEnd> "
1402,<S2SV_StartBug> switch ( * arg ) { <S2SV_EndBug> <S2SV_StartBug> case '\\n' : <S2SV_EndBug> <S2SV_StartBug> * b ++ = * arg ; <S2SV_EndBug> ,<S2SV_ModStart> char ch = * arg ; switch ( ch <S2SV_ModEnd> <S2SV_ModStart> '=' : case <S2SV_ModStart> ch <S2SV_ModEnd> 
1403,"<S2SV_StartBug> ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> { quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_ModStart> } 
1404,<S2SV_StartBug> return in ; <S2SV_EndBug> ,<S2SV_ModStart> NULL <S2SV_ModEnd> 
1405,<S2SV_StartBug> if ( setpwnam ( pw ) < 0 ) <S2SV_EndBug> ,"<S2SV_ModStart> , "".chsh"" "
1406,"<S2SV_StartBug> diff = ndpi_min ( packet -> payload_packet_len - a1 , sizeof ( flow -> initial_binary_bytes ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( diff > 0 ) { <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> diff = ndpi_min ( diff , sizeof ( flow -> initial_binary_bytes ) ) ; "
1407,<S2SV_StartBug> if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { <S2SV_EndBug> <S2SV_StartBug> ut32 len = sec -> payload_len ; <S2SV_EndBug> <S2SV_StartBug> while ( i < len && r < count ) { <S2SV_EndBug> <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ut32 len = sec -> payload_len ; <S2SV_ModStart> int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data <S2SV_ModEnd> <S2SV_ModStart> && len < buflen <S2SV_ModStart> goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> <S2SV_ModStart> goto beach <S2SV_ModEnd> <S2SV_ModStart> goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> <S2SV_ModStart> beach : free ( ptr ) ; return ret ; 
1408,<S2SV_StartBug> string -> space = 1 ; <S2SV_EndBug> <S2SV_StartBug> string -> space *= 2 ; <S2SV_EndBug> <S2SV_StartBug> if ( string -> space < 0 ) <S2SV_EndBug> <S2SV_StartBug> new_len = string -> space = G_MAXINT - 8 ; <S2SV_EndBug> ,"<S2SV_ModStart> { <S2SV_ModStart> 4 ; } else { const guint max_space = MIN ( G_MAXINT , G_MAXSIZE / MAX ( sizeof ( PangoGlyphInfo ) , sizeof ( gint ) ) ) ; guint more_space = ( guint ) <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModEnd> <S2SV_ModStart> more_space > max_space ) { more_space = max_space ; if ( ( guint ) new_len > max_space ) { g_error ( ""%s:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>glyph<S2SV_blank>string<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%i\\n"" , G_STRLOC , new_len ) ; } } <S2SV_ModEnd> <S2SV_ModStart> more_space <S2SV_ModEnd> "
1409,<S2SV_StartBug> if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { <S2SV_EndBug> <S2SV_StartBug> ut32 len = sec -> payload_len ; <S2SV_EndBug> <S2SV_StartBug> while ( i < len && r < count ) { <S2SV_EndBug> <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ut32 len = sec -> payload_len ; <S2SV_ModStart> int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data <S2SV_ModEnd> <S2SV_ModStart> && len < buflen <S2SV_ModStart> goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> <S2SV_ModStart> goto beach <S2SV_ModEnd> <S2SV_ModStart> goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> <S2SV_ModStart> beach : free ( ptr ) ; return ret ; 
1410,<S2SV_StartBug> ufs -> upper_mnt = clone_private_mount ( & upperpath ) ; <S2SV_EndBug> ,"<S2SV_ModStart> sb -> s_stack_depth = max ( upperpath . mnt -> mnt_sb -> s_stack_depth , lowerpath . mnt -> mnt_sb -> s_stack_depth ) + 1 ; err = - EINVAL ; if ( sb -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( ""overlayfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n"" ) ; goto out_put_workpath ; } "
1411,"<S2SV_StartBug> if ( ! kvm_read_cr4_bits ( vcpu , X86_CR4_VMXE ) ) { <S2SV_EndBug> ","<S2SV_ModStart> ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } if ( vmx_get_cpl ( vcpu "
1412,<S2SV_StartBug> r = verify_vc_kbmode ( fd ) ; <S2SV_EndBug> ,<S2SV_ModStart> vt_verify_kbmode <S2SV_ModEnd> 
1413,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> ptr = cp [ 2 ] - 1 ; <S2SV_EndBug> <S2SV_StartBug> switch ( cp [ 3 ] & 0xF ) { <S2SV_EndBug> <S2SV_StartBug> type = ""<S2SV_blank>^<S2SV_blank>"" ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> ( 0 ) <S2SV_ModStart> ND_TCHECK ( cp [ 2 ] ) ; <S2SV_ModStart> ND_TCHECK ( cp [ 3 ] ) ; <S2SV_ModStart> ; ND_TCHECK2 ( cp [ len ] , hoplen ) <S2SV_ModStart> return ( 0 ) ; trunc : return ( - 1 ) ; "
1414,<S2SV_StartBug> local_bh_disable ( ) ; <S2SV_EndBug> <S2SV_StartBug> local_bh_enable ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> spin_lock_bh ( & net -> sctp . addr_wq_lock <S2SV_ModEnd> <S2SV_ModStart> spin_unlock_bh ( & net -> sctp . addr_wq_lock <S2SV_ModEnd> 
1415,"<S2SV_StartBug> hlist_add_head ( & mp -> mglist , & br -> mglist ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( hlist_unhashed ( & mp -> mglist ) ) 
1416,"<S2SV_StartBug> vt -> allocator = funcs ; <S2SV_EndBug> <S2SV_StartBug> vt -> outbuffer_len = 200 ; <S2SV_EndBug> <S2SV_StartBug> vt -> outbuffer = vterm_allocator_malloc ( vt , vt -> outbuffer_len ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( vt == NULL ) return NULL ; <S2SV_ModStart> if ( vt -> parser . strbuffer == NULL ) { vterm_allocator_free ( vt , vt ) ; return NULL ; } <S2SV_ModStart> if ( vt -> outbuffer == NULL ) { vterm_allocator_free ( vt , vt -> parser . strbuffer ) ; vterm_allocator_free ( vt , vt ) ; return NULL ; } "
1417,"<S2SV_StartBug> struct ext4_extent * ex , newex , orig_ex ; <S2SV_EndBug> <S2SV_StartBug> unsigned int allocated , ee_len , depth ; <S2SV_EndBug> <S2SV_StartBug> allocated = ee_len - ( map -> m_lblk - ee_block ) ; <S2SV_EndBug> <S2SV_StartBug> may_zeroout = ee_block + ee_len <= eof_block ; <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_get_access ( handle , inode , path + depth ) ; <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_insert_extent ( handle , inode , path , ex3 , flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> ext4_lblk_t eof_block ; ext4_lblk_t ee_block ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ee_len ; int split_flag = 0 , depth <S2SV_ModEnd> <S2SV_ModStart> split_flag |= <S2SV_ModEnd> <S2SV_ModStart> ? EXT4_EXT_MAY_ZEROOUT : 0 ; split_flag |= EXT4_EXT_MARK_UNINIT2 ; flags |= EXT4_GET_BLOCKS_PRE_IO ; return ext4_split_extent <S2SV_ModEnd> <S2SV_ModStart> , map , split_flag <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1418,"<S2SV_StartBug> encT ) ; <S2SV_EndBug> <S2SV_StartBug> return _gcry_aes_arm_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , encT ) ; <S2SV_EndBug> ",<S2SV_ModStart> enc_tables . T <S2SV_ModEnd> <S2SV_ModStart> enc_tables . T <S2SV_ModEnd> 
1419,"<S2SV_StartBug> struct strbuf * path , const char * component , <S2SV_EndBug> <S2SV_StartBug> finish_object ( obj , path , component , cb_data ) ; <S2SV_EndBug> <S2SV_StartBug> show_object_with_name ( stdout , obj , path , component ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> 
1420,<S2SV_StartBug> r -> rtm_flags |= RTM_F_NOTIFY ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT ) r -> rtm_flags |= RTCF_DOREDIRECT 
1421,"<S2SV_StartBug> if ( X509_check_host ( cert , common_name , FIELD_SIZE , 0 , NULL ) ) <S2SV_EndBug> ",<S2SV_ModStart> == 1 
1422,"<S2SV_StartBug> static inline bool unconditional ( const struct ipt_ip * ip ) <S2SV_EndBug> <S2SV_StartBug> return memcmp ( ip , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug> ",<S2SV_ModStart> ipt_entry * e <S2SV_ModEnd> <S2SV_ModStart> e -> target_offset == sizeof ( struct ipt_entry ) && memcmp ( & e -> <S2SV_ModEnd> 
1423,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> av_freep ( & x -> buf ) ; x -> buf_size = 0 ; 
1424,"<S2SV_StartBug> u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & tv_usec ) ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_usec = tv_usec ; <S2SV_EndBug> ","<S2SV_ModStart> u32 rem ; value -> tv_sec = div_u64_rem ( <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> rem ) <S2SV_ModEnd> <S2SV_ModStart> rem / NSEC_PER_USEC <S2SV_ModEnd> "
1425,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> tty -> disc_data = NULL ; tty -> receive_room = 0 ; 
1426,<S2SV_StartBug> init_thread : <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! test_opt ( sbi , FLUSH_MERGE ) ) return err ; "
1427,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> else if ( auth_end == FIND_AUTH_END_ABORT ) { buffer_unref ( buffer ) ; if ( client -> proxy -> log_messages ) g_print ( ""Invalid<S2SV_blank>AUTH<S2SV_blank>line,<S2SV_blank>aborting\\n"" ) ; side_closed ( side ) ; break ; } "
1428,"<S2SV_StartBug> struct mb_cache_entry * ce = NULL ; <S2SV_EndBug> <S2SV_StartBug> int error = 0 ; <S2SV_EndBug> <S2SV_StartBug> ea_bdebug ( bh , ""refcount<S2SV_blank>now=0;<S2SV_blank>freeing"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> __u32 hash = le32_to_cpu ( BHDR ( bh ) -> h_hash ) ; <S2SV_ModStart> mb2_cache_entry_delete_block ( EXT4_GET_MB_CACHE ( inode ) , hash , bh -> b_blocknr <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1429,<S2SV_StartBug> p -> y . pTab = pItem -> pTab ; <S2SV_EndBug> <S2SV_StartBug> testcase ( iCol == BMS ) ; <S2SV_EndBug> <S2SV_StartBug> return p ; <S2SV_EndBug> ,<S2SV_ModStart> Table * pTab = <S2SV_ModStart> if ( pTab -> tabFlags & TF_HasGenerated ) { Column * pColumn = pTab -> aCol + iCol ; if ( pColumn -> colFlags & COLFLAG_GENERATED ) { testcase ( pTab -> nCol == 63 ) ; testcase ( pTab -> nCol == 64 ) ; if ( pTab -> nCol >= 64 ) { pItem -> colUsed = ALLBITS ; } else { pItem -> colUsed = MASKBIT ( pTab -> nCol ) - 1 ; } } } else { <S2SV_ModStart> } 
1430,<S2SV_StartBug> pStorage -> mbLayer = ( macroblockLayer_t * ) H264SwDecMalloc ( size ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , 1 "
1431,"<S2SV_StartBug> vpx_memcpy ( mbd -> segment_feature_data , xd -> segment_feature_data , sizeof ( xd -> segment_feature_data ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> ref_lf_deltas , xd -> ref_lf_deltas , sizeof ( xd -> ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> mode_lf_deltas , xd -> mode_lf_deltas , sizeof ( xd -> mode_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_y1_dc , xd -> dequant_y1_dc , sizeof ( xd -> dequant_y1_dc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_y1 , xd -> dequant_y1 , sizeof ( xd -> dequant_y1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_y2 , xd -> dequant_y2 , sizeof ( xd -> dequant_y2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_uv , xd -> dequant_uv , sizeof ( xd -> dequant_uv ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
1432,"<S2SV_StartBug> raw_ptr = ( unsigned char * ) ( raw_buffer -> y_buffer + recon_yoffset <S2SV_EndBug> <S2SV_StartBug> vp8_mse16x16 ( src_ptr , src_stride , raw_ptr , raw_stride , <S2SV_EndBug> <S2SV_StartBug> vp8_mse16x16 ( src_ptr , src_stride , ref_ptr , ref_stride , <S2SV_EndBug> ",<S2SV_ModStart> ( void ) cpi ; <S2SV_ModStart> vpx_mse16x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_mse16x16 <S2SV_ModEnd> 
1433,"<S2SV_StartBug> static vpx_codec_err_t vp8e_set_roi_map ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1434,"<S2SV_StartBug> int cflags = REG_EXTENDED | REG_NOSUB ; <S2SV_EndBug> <S2SV_StartBug> if ( regexec ( & preg , string , 0 , NULL , 0 ) != 0 ) <S2SV_EndBug> ",<S2SV_ModStart> ; int ret <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> ; regfree ( & preg ) ; if ( ret 
1435,<S2SV_StartBug> if ( SSL_USE_ETM ( s ) && s -> read_hash ) { <S2SV_EndBug> <S2SV_StartBug> ( EVP_MD_CTX_md ( s -> read_hash ) != NULL ) && ! SSL_USE_ETM ( s ) ) { <S2SV_EndBug> ,<S2SV_ModStart> SSL_READ_ETM <S2SV_ModEnd> <S2SV_ModStart> ! SSL_READ_ETM ( s ) && <S2SV_ModStart>  <S2SV_ModEnd> 
1436,"<S2SV_StartBug> static unsigned int XBMInteger ( Image * image , short int * hex_digits ) <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> return ( value ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> - 1 <S2SV_ModEnd> <S2SV_ModStart> - 1 <S2SV_ModEnd> <S2SV_ModStart> ( int ) 
1437,<S2SV_StartBug> struct completion * vfork_done = tsk -> vfork_done ; <S2SV_EndBug> ,<S2SV_ModStart> # ifdef CONFIG_FUTEX if ( unlikely ( tsk -> robust_list ) ) exit_robust_list ( tsk ) ; # ifdef CONFIG_COMPAT if ( unlikely ( tsk -> compat_robust_list ) ) compat_exit_robust_list ( tsk ) ; # endif # endif 
1438,<S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> ,<S2SV_ModStart> status = MagickFalse ; break <S2SV_ModEnd> 
1439,"<S2SV_StartBug> len = min_t ( unsigned int , len , sizeof ( sec ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> sec . key_size = 0 ; 
1440,"<S2SV_StartBug> char buf [ MAX_PKT_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> len = recvfrom ( sd , buf , sizeof ( buf ) , MSG_DONTWAIT , & sa , & salen ) ; <S2SV_EndBug> <S2SV_StartBug> buf [ len ] = 0 ; <S2SV_EndBug> ",<S2SV_ModStart> + 1 <S2SV_ModStart> - 1 <S2SV_ModStart>  <S2SV_ModEnd> 
1441,"<S2SV_StartBug> * prev = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vma -> vm_file || ! vma -> vm_file -> f_mapping <S2SV_EndBug> <S2SV_StartBug> || ! vma -> vm_file -> f_mapping -> host ) { <S2SV_EndBug> <S2SV_StartBug> up_read ( & current -> mm -> mmap_sem ) ; <S2SV_EndBug> <S2SV_StartBug> error = do_fallocate ( vma -> vm_file , <S2SV_EndBug> <S2SV_StartBug> offset , end - start ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct file * f ; <S2SV_ModStart> f = vma -> vm_file ; <S2SV_ModStart> f || ! f <S2SV_ModEnd> <S2SV_ModStart> f <S2SV_ModEnd> <S2SV_ModStart> get_file ( f ) ; <S2SV_ModStart> f <S2SV_ModEnd> <S2SV_ModStart> ) ; fput ( f 
1442,"<S2SV_StartBug> err = - EMSGSIZE ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> hdrincl ) <S2SV_EndBug> <S2SV_StartBug> inet -> hdrincl ? IPPROTO_RAW : sk -> sk_protocol , <S2SV_EndBug> <S2SV_StartBug> ( inet -> hdrincl ? FLOWI_FLAG_KNOWN_NH : 0 ) , <S2SV_EndBug> <S2SV_StartBug> if ( ! inet -> hdrincl ) { <S2SV_EndBug> <S2SV_StartBug> if ( inet -> hdrincl ) <S2SV_EndBug> ",<S2SV_ModStart> int hdrincl ; <S2SV_ModStart> ; hdrincl = inet -> hdrincl <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1443,"<S2SV_StartBug> size_t count , const uint64_t clsid [ 2 ] ) <S2SV_EndBug> <S2SV_StartBug> if ( ! NOTMIME ( ms ) ) <S2SV_EndBug> <S2SV_StartBug> str = cdf_clsid_to_mime ( clsid , clsid2mime ) ; <S2SV_EndBug> ",<S2SV_ModStart> cdf_directory_t * root_storage <S2SV_ModEnd> <S2SV_ModStart> && root_storage <S2SV_ModStart> root_storage -> d_storage_uuid <S2SV_ModEnd> 
1444,<S2SV_StartBug> struct mount * parent = ACCESS_ONCE ( mnt -> mnt_parent ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( dentry != vfsmnt -> mnt_root ) { bptr = * buffer ; blen = * buflen ; error = 3 ; break ; } 
1445,<S2SV_StartBug> return ( mhlen ) ; <S2SV_EndBug> ,<S2SV_ModStart> - 1 <S2SV_ModEnd> 
1446,"<S2SV_StartBug> static bool tailmatch ( const char * little , const char * bigone ) <S2SV_EndBug> <S2SV_StartBug> size_t littlelen = strlen ( little ) ; <S2SV_EndBug> <S2SV_StartBug> size_t biglen = strlen ( bigone ) ; <S2SV_EndBug> <S2SV_StartBug> if ( littlelen > biglen ) <S2SV_EndBug> <S2SV_StartBug> return Curl_raw_equal ( little , bigone + biglen - littlelen ) ? TRUE : FALSE ; <S2SV_EndBug> ","<S2SV_ModStart> cooke_domain <S2SV_ModEnd> <S2SV_ModStart> hostname <S2SV_ModEnd> <S2SV_ModStart> cookie_domain_len <S2SV_ModEnd> <S2SV_ModStart> cooke_domain <S2SV_ModEnd> <S2SV_ModStart> hostname_len <S2SV_ModEnd> <S2SV_ModStart> hostname <S2SV_ModEnd> <S2SV_ModStart> hostname_len < cookie_domain_len <S2SV_ModEnd> <S2SV_ModStart> if ( ! Curl_raw_equal ( cooke_domain , hostname + hostname_len - cookie_domain_len ) ) return FALSE ; if ( hostname_len == cookie_domain_len ) return TRUE ; if ( '.' == * ( hostname + hostname_len - cookie_domain_len - 1 ) ) return TRUE ; return <S2SV_ModEnd> "
1447,<S2SV_StartBug> if ( ! values [ k ] . name ) <S2SV_EndBug> ,<S2SV_ModStart> { continue ; } <S2SV_ModEnd> 
1448,<S2SV_StartBug> siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . hsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . vsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } "
1449,<S2SV_StartBug> s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> <S2SV_StartBug> s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> ,<S2SV_ModStart> tlsext_use_etm = 0 <S2SV_ModEnd> <S2SV_ModStart> tlsext_use_etm = 1 <S2SV_ModEnd> 
1450,"<S2SV_StartBug> int cond_len , then_len , jump_len ; <S2SV_EndBug> <S2SV_StartBug> jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END ; <S2SV_EndBug> <S2SV_StartBug> int else_len = compile_length_tree ( Else , reg ) ; <S2SV_EndBug> <S2SV_StartBug> COP ( reg ) -> jump . addr = else_len + SIZE_INC_OP ; <S2SV_EndBug> <S2SV_StartBug> r = compile_tree ( Else , reg , env ) ; <S2SV_EndBug> ","<S2SV_ModStart> else_len , <S2SV_ModStart> + <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( else_len < 0 ) return else_len ; } else else_len = 0 <S2SV_ModStart> SIZE_OP_ATOMIC_END + <S2SV_ModStart> add_op ( reg , OP_ATOMIC_END ) ; if ( r != 0 ) return r ; if ( IS_NOT_NULL ( Else ) ) { r = "
1451,<S2SV_StartBug> int valuelen = args -> valuelen ; <S2SV_EndBug> <S2SV_StartBug> ASSERT ( ! ( args -> flags & ATTR_KERNOVAL ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; ASSERT ( args -> rmtvaluelen == args -> valuelen ) ; valuelen = args -> rmtvaluelen 
1452,"<S2SV_StartBug> if ( -- container_of ( ptr , struct ipc_rcu_hdr , data ) -> refcount > 0 ) <S2SV_EndBug> ",<S2SV_ModStart> ! atomic_dec_and_test ( & <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> 
1453,<S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> ,<S2SV_ModStart> k <S2SV_ModEnd> 
1454,"<S2SV_StartBug> static int expandRegular ( rpmfi fi , const char * dest , rpmpsm psm , int nodigest , int nocontent ) <S2SV_EndBug> <S2SV_StartBug> wfd = Fopen ( dest , ""w.ufdio"" ) ; <S2SV_EndBug> <S2SV_StartBug> umask ( old_umask ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int exclusive <S2SV_ModStart> exclusive ? ""wx.ufdio"" : ""a.ufdio"" <S2SV_ModEnd> <S2SV_ModStart> if ( ! exclusive && wfd != NULL && ! linkSane ( wfd , dest ) ) { rc = RPMERR_OPEN_FAILED ; goto exit ; } "
1455,<S2SV_StartBug> image -> inmem_ = true ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1456,<S2SV_StartBug> if ( prefixlen < len ) { <S2SV_EndBug> ,<S2SV_ModStart> <= <S2SV_ModEnd> 
1457,<S2SV_StartBug> if ( label_exec ( opt_exec_label ) == - 1 ) <S2SV_EndBug> ,"<S2SV_ModStart> setsid ( ) == ( pid_t ) - 1 ) die_with_error ( ""setsid"" ) ; if ( "
1458,"<S2SV_StartBug> chip -> data_buffer = kmalloc ( TPM_BUFSIZE * sizeof ( u8 ) , GFP_KERNEL ) ; <S2SV_EndBug> ",<S2SV_ModStart> kzalloc ( TPM_BUFSIZE <S2SV_ModEnd> 
1459,"<S2SV_StartBug> set_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ; <S2SV_EndBug> <S2SV_StartBug> clear_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ; <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return err ; } set_bit <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1460,<S2SV_StartBug> line += PKT_LEN_SIZE ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ; 
1461,<S2SV_StartBug> ut32 len = sec -> payload_len ; <S2SV_EndBug> <S2SV_StartBug> while ( i < len && r < count ) { <S2SV_EndBug> <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data ; <S2SV_ModStart> && len < buflen <S2SV_ModStart> goto beach <S2SV_ModEnd> <S2SV_ModStart> goto beach <S2SV_ModEnd> <S2SV_ModStart> goto beach <S2SV_ModEnd> <S2SV_ModStart> beach : free ( ptr ) ; return ret ; 
1462,"<S2SV_StartBug> if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) <S2SV_EndBug> <S2SV_StartBug> status = SetImageExtent ( image , image -> columns , image -> rows ) ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ","<S2SV_ModStart> image -> colormap = ( PixelPacket * ) AcquireQuantumMemory ( <S2SV_ModEnd> <S2SV_ModStart> + 1 , sizeof ( * image -> colormap ) ) ; if ( image -> colormap == ( PixelPacket * ) NULL <S2SV_ModEnd> <S2SV_ModStart> if ( ( AcquireMagickResource ( WidthResource <S2SV_ModEnd> <S2SV_ModStart> ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ThrowReaderException ( ImageError , ""WidthOrHeightExceedsLimit"" ) ; <S2SV_ModEnd> "
1463,<S2SV_StartBug> struct ip_options * sopt ; <S2SV_EndBug> <S2SV_StartBug> if ( sopt -> optlen == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> const <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1464,<S2SV_StartBug> unsigned long size ) <S2SV_EndBug> <S2SV_StartBug> end_gfn = gfn + ( size >> PAGE_SHIFT ) ; <S2SV_EndBug> ,<S2SV_ModStart> npages <S2SV_ModEnd> <S2SV_ModStart> npages <S2SV_ModEnd> 
1465,"<S2SV_StartBug> res = ctx -> iface -> enc . cfg_set ( ctx -> priv -> alg_priv , cfg ) ; <S2SV_EndBug> ",<S2SV_ModStart> get_alg_priv ( ctx ) <S2SV_ModEnd> 
1466,<S2SV_StartBug> status = sctp_v4_protosw_init ( ) ; <S2SV_EndBug> <S2SV_StartBug> status = register_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> <S2SV_StartBug> unregister_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> <S2SV_StartBug> err_protosw_init : <S2SV_EndBug> ,<S2SV_ModStart> register_pernet_subsys ( & sctp_defaults_ops ) ; if ( status ) goto err_register_defaults ; status = <S2SV_ModStart> sctp_ctrlsock_ops ) ; if ( status ) goto err_register_ctrlsock <S2SV_ModEnd> <S2SV_ModStart> sctp_ctrlsock_ops ) ; err_register_ctrlsock <S2SV_ModEnd> <S2SV_ModStart> : unregister_pernet_subsys ( & sctp_defaults_ops ) ; err_register_defaults 
1467,<S2SV_StartBug> bpm = nlmsg_data ( nlh ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; memset ( bpm , 0 , sizeof ( * bpm ) "
1468,<S2SV_StartBug> * flags &= ~ FOLL_WRITE ; <S2SV_EndBug> ,<S2SV_ModStart> |= FOLL_COW <S2SV_ModEnd> 
1469,"<S2SV_StartBug> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> xd -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> { # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { x -> highbd_itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd ) ; return ; } # endif x <S2SV_ModEnd> <S2SV_ModStart> } "
1470,"<S2SV_StartBug> void vp9_idct8x8_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) { <S2SV_EndBug> <S2SV_StartBug> vp9_idct8x8_1_add ( input , dest , stride ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( eob <= 10 ) <S2SV_EndBug> <S2SV_StartBug> vp9_idct8x8_64_add ( input , dest , stride ) ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_idct8x8_1_add <S2SV_ModEnd> <S2SV_ModStart> 12 ) vpx_idct8x8_12_add <S2SV_ModEnd> <S2SV_ModStart> vpx_idct8x8_64_add <S2SV_ModEnd> 
1471,"<S2SV_StartBug> strcpy ( the_url , evt -> navigate . to_url ) ; <S2SV_EndBug> ","<S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <S2SV_ModEnd> "
1472,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> keymap -> num_key_aliases = num_key_aliases ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } 
1473,"<S2SV_StartBug> static inline struct enamemem * <S2SV_EndBug> <S2SV_StartBug> struct enamemem * tp ; <S2SV_EndBug> <S2SV_StartBug> while ( tp -> e_nxt ) <S2SV_EndBug> <S2SV_StartBug> tp -> e_addr1 == j && <S2SV_EndBug> <S2SV_StartBug> tp -> e_addr2 == k && <S2SV_EndBug> <S2SV_StartBug> memcmp ( ( const char * ) bs , ( const char * ) ( tp -> e_bs ) , nlen ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> tp = tp -> e_nxt ; <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_bs == NULL ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( tp -> e_bs , bs , nlen ) ; <S2SV_EndBug> <S2SV_StartBug> tp -> e_nxt = ( struct enamemem * ) calloc ( 1 , sizeof ( * tp ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_nxt == NULL ) <S2SV_EndBug> ","<S2SV_ModStart> bsnamemem <S2SV_ModEnd> <S2SV_ModStart> bsnamemem <S2SV_ModEnd> <S2SV_ModStart> bs_nxt ) if ( nlen == tp -> bs_nbytes <S2SV_ModEnd> <S2SV_ModStart> bs_addr0 == i <S2SV_ModEnd> <S2SV_ModStart> bs_addr1 == j && tp -> bs_addr2 <S2SV_ModEnd> <S2SV_ModStart> bs_bytes <S2SV_ModEnd> <S2SV_ModStart> bs_nxt ; tp -> bs_addr0 = i ; tp -> bs_addr1 = j ; tp -> bs_addr2 = k ; tp -> bs_bytes <S2SV_ModEnd> <S2SV_ModStart> bs_bytes <S2SV_ModEnd> <S2SV_ModStart> bs_bytes , bs , nlen ) ; tp -> bs_nbytes = nlen ; tp -> bs_nxt <S2SV_ModEnd> <S2SV_ModStart> bsnamemem <S2SV_ModEnd> <S2SV_ModStart> bs_nxt <S2SV_ModEnd> "
1474,"<S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) ) <S2SV_EndBug> <S2SV_StartBug> encode_frame ( & codec , NULL , - 1 , 0 , writer ) ; <S2SV_EndBug> ",<S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> while ( <S2SV_ModStart> ) { } 
1475,<S2SV_StartBug> avail = vec -> iov_len - ( old - ( char * ) vec -> iov_base ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ( void * ) old > vec -> iov_base + vec -> iov_len ) return 0 ; 
1476,"<S2SV_StartBug> recv ( signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1477,"<S2SV_StartBug> void Huff_offsetTransmit ( huff_t * huff , int ch , byte * fout , int * offset ) { <S2SV_EndBug> <S2SV_StartBug> send ( huff -> loc [ ch ] , NULL , fout ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int maxoffset <S2SV_ModStart> , maxoffset "
1478,<S2SV_StartBug> box -> info = boxinfo ; <S2SV_EndBug> <S2SV_StartBug> box -> ops = & jp2_boxinfo_unk . ops ; <S2SV_EndBug> <S2SV_StartBug> jas_stream_rewind ( tmpstream ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; box -> ops = & boxinfo -> ops 
1479,"<S2SV_StartBug> struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> 
1480,<S2SV_StartBug> if ( key_is_instantiated ( key ) && <S2SV_EndBug> ,<S2SV_ModStart> key_is_positive <S2SV_ModEnd> 
1481,"<S2SV_StartBug> int res , bytes , i , indexes , index_bytes , ids ; <S2SV_EndBug> <S2SV_StartBug> if ( flag ) { <S2SV_EndBug> <S2SV_StartBug> return id_table . xattr_ids ; <S2SV_EndBug> <S2SV_StartBug> res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start + sizeof ( id_table ) , <S2SV_EndBug> <S2SV_StartBug> bytes = SQUASHFS_XATTR_BYTES ( ids ) ; <S2SV_EndBug> <S2SV_StartBug> ( i * SQUASHFS_METADATA_SIZE ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> i , indexes , index_bytes ; unsigned int ids ; long long bytes <S2SV_ModEnd> <S2SV_ModStart> ids = id_table . xattr_ids ; xattr_table_start <S2SV_ModEnd> <S2SV_ModStart> index_bytes = SQUASHFS_XATTR_BLOCK_BYTES ( ( long long ) ids ) ; indexes = SQUASHFS_XATTR_BLOCKS ( ( long long ) ids ) ; if ( index_bytes != ( sBlk -> bytes_used - ( <S2SV_ModEnd> <S2SV_ModStart> ) ) ) { ERROR ( ""read_xattrs_from_disk:<S2SV_blank>Bad<S2SV_blank>xattr_ids<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; return 0 ; } if ( table_start != NULL ) * table_start = id_table . xattr_table_start ; if ( flag ) return id_table . xattr_ids ; index = malloc ( index_bytes ) ; if ( index == NULL ) MEM_ERROR ( ) ; res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start + sizeof ( id_table ) <S2SV_ModStart> ( long long ) <S2SV_ModStart> ( long long ) "
1482,"<S2SV_StartBug> int result = RLC_OK ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( ! bn_is_zero ( t ) ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> <S2SV_StartBug> pad |= h1 [ i ] - h2 [ i ] ; <S2SV_EndBug> <S2SV_StartBug> if ( result == RLC_OK ) { <S2SV_EndBug> <S2SV_StartBug> bn_mod_2b ( m , m , 8 * m_len ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( bn_cmp_dig ( t , RSA_PSS ) != RLC_EQ ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! bn_is_zero ( m ) ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> ","<S2SV_ModStart> RLC_ERR <S2SV_ModEnd> <S2SV_ModStart> result = RLC_OK ; <S2SV_ModStart> result = RLC_OK ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ^ <S2SV_ModEnd> <S2SV_ModStart> bn_mod_2b ( m , m , 8 * m_len ) ; * p_len = bn_size_bin ( m ) ; ( * p_len ) -- ; bn_rsh ( t , m , * p_len * 8 ) ; if ( pad == 0 && bn_cmp_dig ( t , 1 ) == RLC_EQ ) { result = RLC_OK <S2SV_ModEnd> <S2SV_ModStart> * p_len * 8 ) ; * p_len = k_len - * p_len ; } <S2SV_ModEnd> <S2SV_ModStart> result = RLC_OK ; <S2SV_ModStart> result = RLC_OK ; <S2SV_ModStart> pad = ( uint8_t ) t -> dp [ 0 ] ; if ( pad == RSA_PSS ) { int r = 1 ; for ( int i = m_len ; i < 8 * k_len ; i ++ ) { if ( bn_get_bit ( m , i ) != 0 ) { r = 0 <S2SV_ModEnd> <S2SV_ModStart> r == 1 && <S2SV_ModEnd> <S2SV_ModStart> RLC_OK <S2SV_ModEnd> "
1483,"<S2SV_StartBug> MODE_INFO * * mi_8x8 , const int mode_info_stride , <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mip = mi_8x8 ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mip2 = mi_8x8 ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( * lfm ) ; <S2SV_EndBug> <S2SV_StartBug> const uint64_t mask_y = ( ( ( 1 << columns ) - 1 ) ) * 0x0101010101010101 ; <S2SV_EndBug> <S2SV_StartBug> lfm -> left_y [ i ] &= 0xfefefefefefefefe ; <S2SV_EndBug> ",<S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> ) ; assert ( mip [ 0 ] != NULL <S2SV_ModStart> 0x0101010101010101ULL <S2SV_ModEnd> <S2SV_ModStart> 0xfefefefefefefefeULL <S2SV_ModEnd> 
1484,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> cl_assert_equal_b ( false , git_path_isvalid ( NULL , "".gitmodules<S2SV_blank>.<S2SV_blank>.::$DATA"" , S_IFLNK , GIT_PATH_REJECT_DOT_GIT_NTFS ) ) ; "
1485,<S2SV_StartBug> redisAssert ( ! server . vm_enabled || obj -> storage == REDIS_VM_MEMORY ) ; <S2SV_EndBug> ,<S2SV_ModStart> ds_enabled <S2SV_ModEnd> 
1486,<S2SV_StartBug> location = ngx_list_push ( & r -> headers_out . headers ) ; <S2SV_EndBug> ,<S2SV_ModStart> r -> expect_tested = 1 ; if ( ngx_http_discard_request_body ( r ) != NGX_OK ) { r -> keepalive = 0 ; } 
1487,<S2SV_StartBug> if ( ! unconditional ( & e -> ipv6 ) ) <S2SV_EndBug> ,<S2SV_ModStart> e <S2SV_ModEnd> 
1488,<S2SV_StartBug> # endif <S2SV_EndBug> ,"<S2SV_ModStart> conf_write ( fp , ""<S2SV_blank>umask<S2SV_blank>=<S2SV_blank>0%o"" , global_data -> umask ) ; "
1489,"<S2SV_StartBug> transhdrlen , mtu , flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> , rt "
1490,"<S2SV_StartBug> if ( js_regexec ( re -> prog , text , & m , 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <S2SV_EndBug> ","<S2SV_ModStart> js_doregexec ( J , <S2SV_ModEnd> <S2SV_ModStart> js_doregexec ( J , <S2SV_ModEnd> "
1491,<S2SV_StartBug> for ( i = 0 ; i < table_entries_used ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ; <S2SV_EndBug> ,<S2SV_ModStart> { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } 
1492,"<S2SV_StartBug> static bool do_write_pids ( pid_t tpid , const char * contrl , const char * cg , const char * file , const char * buf ) <S2SV_EndBug> <S2SV_StartBug> if ( fprintf ( pids_file , ""%d"" , ( int ) cred . pid ) < 0 ) <S2SV_EndBug> ","<S2SV_ModStart> uid_t tuid , <S2SV_ModStart> ! may_move_pid ( tpid , tuid , <S2SV_ModEnd> <S2SV_ModStart> ) { fail = true ; break ; } if ( fprintf ( pids_file , ""%d"" , ( int ) cred . pid ) "
1493,"<S2SV_StartBug> u64 t = ca -> sum_rtt ; <S2SV_EndBug> <S2SV_StartBug> do_div ( t , ca -> cnt_rtt ) ; <S2SV_EndBug> <S2SV_StartBug> info . tcpv_rtt = t ; <S2SV_EndBug> ",<S2SV_ModStart> if ( info . tcpv_rttcnt > 0 ) { <S2SV_ModStart> info . tcpv_rttcnt <S2SV_ModEnd> <S2SV_ModStart> } 
1494,"<S2SV_StartBug> put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ; <S2SV_EndBug> ",<S2SV_ModStart> aux . tp_padding = 0 ; 
1495,<S2SV_StartBug> BUG_ON ( sk != asoc -> base . sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> goto do_error 
1496,<S2SV_StartBug> # undef _ <S2SV_EndBug> ,<S2SV_ModStart> _ ( NPNVprivateModeBool ) ; _ ( NPNVsupportsAdvancedKeyHandling ) ; 
1497,"<S2SV_StartBug> alarm_set ( alarm_timer , CONFIG_SETTLE_PERIOD_MS , timer_config_save , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> timer_config_save_cb <S2SV_ModEnd> 
1498,"<S2SV_StartBug> while ( c && cJSON_strcasecmp ( c -> string , string ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> i ++ , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1499,"<S2SV_StartBug> if ( pt [ 6 ] & AX25_HBIT ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> memcpy ( & facilities -> source_digis [ facilities -> source_ndigis ++ ] , pt , AX25_ADDR_LEN ) ; <S2SV_EndBug> ",<S2SV_ModStart> { if ( facilities -> dest_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; <S2SV_ModStart> } else { if ( facilities -> source_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; <S2SV_ModEnd> <S2SV_ModStart> } 
1500,<S2SV_StartBug> hdrlen = sizeof ( * h . h2 ) ; <S2SV_EndBug> ,<S2SV_ModStart> h . h2 -> tp_padding = 0 ; 
1501,<S2SV_StartBug> goto out ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( path . mnt == exp -> ex_path . mnt && path . dentry == dentry && nfsd_mountpoint ( dentry , exp ) == 2 ) { path_put ( & path ) ; goto out ; } "
1502,"<S2SV_StartBug> list_for_each_entry_safe ( chain , nc , & ctx -> table -> chains , list ) { <S2SV_EndBug> <S2SV_StartBug> err = nft_delchain ( ctx ) ; <S2SV_EndBug> <S2SV_StartBug> list_for_each_entry_safe ( set , ns , & ctx -> table -> sets , list ) { <S2SV_EndBug> <S2SV_StartBug> if ( set -> flags & NFT_SET_ANONYMOUS && <S2SV_EndBug> ","<S2SV_ModStart> list_for_each_entry ( chain <S2SV_ModEnd> <S2SV_ModStart> } list_for_each_entry_safe ( set , ns , & ctx -> table -> sets , list ) { if ( set -> flags & NFT_SET_ANONYMOUS && ! list_empty ( & set -> bindings ) ) continue ; err = nft_delset ( ctx , set <S2SV_ModEnd> <S2SV_ModStart> chain , nc <S2SV_ModEnd> <S2SV_ModStart> chains <S2SV_ModEnd> <S2SV_ModStart> ctx -> chain = chain ; err = nft_delchain ( ctx <S2SV_ModEnd> "
1503,<S2SV_StartBug> if ( stringset == ETH_SS_STATS ) <S2SV_EndBug> ,<S2SV_ModStart> || stringset == ETH_SS_PRIV_FLAGS 
1504,<S2SV_StartBug> if ( ( ubridge_config = iniparser_load ( filename ) ) == NULL ) { <S2SV_EndBug> ,"<S2SV_ModStart> , HIDE_ERRORED_LINE_CONTENT "
1505,<S2SV_StartBug> if ( ( skb_headroom ( skb ) < frag_hdr_sz ) && <S2SV_EndBug> ,<S2SV_ModStart> skb_mac_header <S2SV_ModEnd> <S2SV_ModStart> skb -> head + 
1506,<S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; } 
1507,<S2SV_StartBug> bitlen = slen * 4 ; <S2SV_EndBug> ,"<S2SV_ModStart> { if ( slen > VARBITMAXLEN / 4 ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , VARBITMAXLEN ) ) ) ; <S2SV_ModStart> } "
1508,"<S2SV_StartBug> int udf_get_filename ( struct super_block * sb , uint8_t * sname , uint8_t * dname , <S2SV_EndBug> <S2SV_StartBug> int flen ) <S2SV_EndBug> <S2SV_StartBug> if ( udf_build_ustr_exact ( unifilename , sname , flen ) ) <S2SV_EndBug> <S2SV_StartBug> len = udf_translate_to_linux ( dname , filename -> u_name , filename -> u_len , <S2SV_EndBug> ","<S2SV_ModStart> int slen , <S2SV_ModStart> int dlen <S2SV_ModEnd> <S2SV_ModStart> slen <S2SV_ModEnd> <S2SV_ModStart> dlen , "
1509,<S2SV_StartBug> if ( Stream_GetRemainingLength ( irp -> input ) < PathLength ) <S2SV_EndBug> <S2SV_StartBug> return ERROR_INVALID_DATA ; <S2SV_EndBug> ,"<S2SV_ModStart> ! Stream_SafeSeek ( irp -> input , PathLength ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1510,"<S2SV_StartBug> unsigned_relts_print ( ndo , EXTRACT_16BITS ( bp ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""0x%08x"" , EXTRACT_32BITS ( bp ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""v%d"" , * bp ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>?0x%04x?"" , EXTRACT_16BITS ( bp + 2 ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( olen != 2 ) { ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>2<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ; } else { <S2SV_ModStart> } <S2SV_ModStart> if ( olen != 4 ) { ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ; } else { <S2SV_ModStart> } <S2SV_ModStart> if ( olen != 4 ) { ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ; } else { <S2SV_ModStart> } "
1511,"<S2SV_StartBug> if ( ! strlen ( text ) ) return ""empty<S2SV_blank>string"" ; <S2SV_EndBug> ","<S2SV_ModStart> """" <S2SV_ModEnd> "
1512,"<S2SV_StartBug> arg = arg ( argname , annotation , LINENO ( ch ) , ch -> n_col_offset , <S2SV_EndBug> <S2SV_StartBug> i += 2 ; <S2SV_EndBug> ","<S2SV_ModStart> NULL , <S2SV_ModStart> 1 ; if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 <S2SV_ModEnd> "
1513,"<S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> ","<S2SV_ModStart> , XEN_NETIF_RSP_OKAY "
1514,"<S2SV_StartBug> BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( unsigned char ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> double <S2SV_ModEnd> 
1515,"<S2SV_StartBug> } else if ( strcmp ( tokens [ 1 ] . value , ""mode"" ) == 0 && ntokens >= 3 && <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( tokens [ 1 ] . value , ""temp_ttl"" ) == 0 && ntokens >= 3 && <S2SV_EndBug> ",<S2SV_ModStart> 4 <S2SV_ModEnd> <S2SV_ModStart> 4 <S2SV_ModEnd> 
1516,<S2SV_StartBug> for ( i = rows ; i < rows + 17 ; i ++ ) <S2SV_EndBug> ,<S2SV_ModStart> 0 ; i < 17 ; i ++ ) s [ ( i + rows ) <S2SV_ModEnd> 
1517,"<S2SV_StartBug> if ( name && memchr ( name , '\\0' , namelen ) ) <S2SV_EndBug> ",<S2SV_ModStart> != NULL && namelen == 0 ) namelen = strlen ( name ) ; if ( name 
1518,"<S2SV_StartBug> ( void ) mch_setperm ( curbuf -> b_ml . ml_mfp -> mf_fname , ( long ) swap_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> { char_u * swap_fname = <S2SV_ModEnd> <S2SV_ModStart> ; if ( ( swap_mode & 044 ) == 040 ) { stat_T swap_st ; if ( mch_stat ( ( char * ) swap_fname , & swap_st ) >= 0 && st . st_gid != swap_st . st_gid && fchown ( curbuf -> b_ml . ml_mfp -> mf_fd , - 1 , st . st_gid ) == - 1 ) swap_mode &= 0600 ; } ( void ) mch_setperm ( swap_fname <S2SV_ModStart> } "
1519,<S2SV_StartBug> bpm = nlmsg_data ( nlh ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; memset ( bpm , 0 , sizeof ( * bpm ) "
1520,<S2SV_StartBug> rect . x = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . y = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . width = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . height = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . x = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . y = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . width = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . height = <S2SV_ModStart> } 
1521,"<S2SV_StartBug> int temporal_layer = 0 ; <S2SV_EndBug> <S2SV_StartBug> for ( temporal_layer = current_temporal_layer + 1 ; <S2SV_EndBug> <S2SV_StartBug> temporal_layer < svc -> number_temporal_layers ; ++ temporal_layer ) { <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * lc = & svc -> layer_context [ temporal_layer ] ; <S2SV_EndBug> <S2SV_StartBug> lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lc -> maximum_buffer_size ) ; <S2SV_EndBug> ","<S2SV_ModStart> i <S2SV_ModEnd> <S2SV_ModStart> i <S2SV_ModEnd> <S2SV_ModStart> i <S2SV_ModEnd> <S2SV_ModStart> i ) { const int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , i , svc -> number_temporal_layers ) ; <S2SV_ModEnd> <S2SV_ModStart> layer <S2SV_ModEnd> <S2SV_ModStart> lrc <S2SV_ModEnd> "
1522,<S2SV_StartBug> get_net ( peer ) ; <S2SV_EndBug> ,<S2SV_ModStart> peer = maybe_get_net <S2SV_ModEnd> 
1523,<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> msg -> msg_namelen = 0 ; 
1524,<S2SV_StartBug> speakup_tty = tty ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ldisc_data ) <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & speakup_tty_mutex ) ; if ( speakup_tty ) { mutex_unlock ( & speakup_tty_mutex ) ; return - EBUSY ; } <S2SV_ModStart> { speakup_tty = NULL ; mutex_unlock ( & speakup_tty_mutex ) ; <S2SV_ModStart> } <S2SV_ModStart> mutex_unlock ( & speakup_tty_mutex ) ; 
1525,<S2SV_StartBug> if ( val > sysctl_wmem_max ) <S2SV_EndBug> <S2SV_StartBug> if ( ( val * 2 ) < SOCK_MIN_SNDBUF ) <S2SV_EndBug> <S2SV_StartBug> if ( val > sysctl_rmem_max ) <S2SV_EndBug> <S2SV_StartBug> if ( ( val * 2 ) < SOCK_MIN_RCVBUF ) <S2SV_EndBug> ,"<S2SV_ModStart> val = min_t ( u32 , val , sysctl_wmem_max ) <S2SV_ModEnd> <S2SV_ModStart> sk -> sk_sndbuf = max_t ( u32 , <S2SV_ModEnd> <S2SV_ModStart> , SOCK_MIN_SNDBUF ) <S2SV_ModEnd> <S2SV_ModStart> val = min_t ( u32 , val , sysctl_rmem_max ) <S2SV_ModEnd> <S2SV_ModStart> sk -> sk_rcvbuf = max_t ( u32 , <S2SV_ModEnd> <S2SV_ModStart> , SOCK_MIN_RCVBUF ) <S2SV_ModEnd> "
1526,<S2SV_StartBug> uchar buf [ 2 ] ; <S2SV_EndBug> ,<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
1527,<S2SV_StartBug> newtok = PyMem_MALLOC ( buflen + 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( newtok == NULL ) { Py_DECREF ( u ) ; tok -> done = E_NOMEM ; return EOF ; } 
1528,"<S2SV_StartBug> first_block_offset = round_up ( offset , sb -> s_blocksize ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( last_block_offset > first_block_offset ) <S2SV_EndBug> <S2SV_StartBug> ext4_inode_resume_unlocked_dio ( inode ) ; <S2SV_EndBug> ",<S2SV_ModStart> ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; 
1529,<S2SV_StartBug> kiocb -> ki_nr_segs = kiocb -> ki_nbytes ; <S2SV_EndBug> ,"<S2SV_ModStart> ret = rw_verify_area ( type , kiocb -> ki_filp , & kiocb -> ki_pos , ret ) ; if ( ret < 0 ) goto out ; "
1530,"<S2SV_StartBug> YV12_BUFFER_CONFIG sd = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> const vpx_codec_err_t res = <S2SV_EndBug> <S2SV_StartBug> ctx -> base . iface -> dec . peek_si ( * data , data_sz , & ctx -> si ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! ctx -> decoder_init ) { <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> pbi == NULL ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; ( void ) deadline <S2SV_ModEnd> <S2SV_ModStart> int is_intra_only = 0 ; <S2SV_ModStart> decoder_peek_si_internal <S2SV_ModEnd> <S2SV_ModStart> , & is_intra_only , ctx -> decrypt_cb , ctx -> decrypt_state <S2SV_ModStart> if ( ! ctx -> si . is_kf && ! is_intra_only ) return VPX_CODEC_ERROR ; <S2SV_ModStart> frame_parallel_decode ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; frame_worker_data -> data = * data ; frame_worker_data -> data_size = data_sz ; frame_worker_data -> user_priv = user_priv ; frame_worker_data -> received_frame = 1 ; frame_worker_data -> pbi -> decrypt_cb = ctx -> decrypt_cb ; frame_worker_data -> pbi -> decrypt_state = ctx -> decrypt_state ; worker -> had_error = 0 ; winterface -> execute ( worker ) ; * data = frame_worker_data -> data_end ; if ( worker -> had_error ) return update_error_state ( ctx , & frame_worker_data -> pbi -> common . error ) ; check_resync ( ctx , frame_worker_data -> pbi ) ; } else { VPxWorker * const worker = & ctx -> frame_workers [ ctx -> next_submit_worker_id ] ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; if ( ctx -> next_submit_worker_id != ctx -> last_submit_worker_id ) vp9_frameworker_copy_context ( & ctx -> frame_workers [ ctx -> next_submit_worker_id ] , & ctx -> frame_workers [ ctx -> last_submit_worker_id ] ) ; frame_worker_data -> pbi -> ready_for_new_data = 0 ; if ( frame_worker_data -> scratch_buffer_size < data_sz ) { frame_worker_data -> scratch_buffer = ( uint8_t * ) vpx_realloc ( frame_worker_data -> scratch_buffer , data_sz ) ; if ( frame_worker_data -> scratch_buffer <S2SV_ModEnd> <S2SV_ModStart> { set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>reallocate<S2SV_blank>scratch<S2SV_blank>buffer"" ) ; return VPX_CODEC_MEM_ERROR ; } frame_worker_data -> scratch_buffer_size = data_sz ; } frame_worker_data -> data_size = data_sz ; memcpy ( frame_worker_data -> scratch_buffer , * data , data_sz ) ; frame_worker_data -> frame_decoded = 0 ; frame_worker_data -> frame_context_ready = 0 ; frame_worker_data -> received_frame <S2SV_ModEnd> <S2SV_ModStart> frame_worker_data -> data = frame_worker_data -> scratch_buffer ; frame_worker_data -> user_priv = user_priv ; if ( ctx -> next_submit_worker_id != ctx -> last_submit_worker_id ) ctx -> last_submit_worker_id = ( ctx -> last_submit_worker_id + 1 ) % ctx -> num_frame_workers ; ctx -> next_submit_worker_id = ( ctx -> next_submit_worker_id + 1 ) % ctx -> num_frame_workers ; -- ctx -> available_threads ; worker -> had_error = 0 ; winterface -> launch ( worker ) ; } <S2SV_ModEnd> "
1531,"<S2SV_StartBug> CAFChannelLayout * caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; <S2SV_EndBug> <S2SV_StartBug> ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || <S2SV_EndBug> <S2SV_StartBug> int bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ; <S2SV_EndBug> <S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> caf_chunk_header . mChunkSize > 1024 ) { error_line ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\'chan\'<S2SV_blank>chunk!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""\'chan\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes"" , ( int ) caf_chunk_header . mChunkSize ) ; caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; if ( <S2SV_ModStart> uint32_t <S2SV_ModEnd> <S2SV_ModStart> buff ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } "
1532,<S2SV_StartBug> usleep ( 200000 ) ; <S2SV_EndBug> ,<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1533,"<S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> err = vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <S2SV_EndBug> <S2SV_StartBug> xd -> plane [ 0 ] . pre [ 0 ] . buf , xd -> plane [ 0 ] . pre [ 0 ] . stride , <S2SV_EndBug> ",<S2SV_ModStart> td . <S2SV_ModStart> vpx_sad16x16 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1534,"<S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_lineno ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_lineno ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_int ( tmp , & lineno , arena ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_name ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_name ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_args ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( decorator_list , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_returns ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_name ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_name ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_args ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( decorator_list , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_returns ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_name ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_name ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( bases , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> keyword_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_keyword ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( keywords , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( decorator_list , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_targets ) ) { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( targets , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_targets ) ) { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( targets , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( tmp , & target , arena ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( tmp , & target , arena ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign"" ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_annotation ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( tmp , & target , arena ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_iter ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( orelse , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( tmp , & target , arena ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_iter ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( orelse , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_test ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_test ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( orelse , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_test ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_test ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( orelse , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_items ) ) { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> withitem_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_withitem ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( items , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_items ) ) { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> withitem_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_withitem ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( items , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_exc ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_exc ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( tmp , & exc , arena ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> excepthandler_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_excepthandler ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( handlers , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( orelse , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( finalbody , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_test ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_test ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( tmp , & test , arena ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_names ) ) { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> alias_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_alias ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( names , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_module ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_module ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> alias_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_alias ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( names , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_level ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_names ) ) { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> identifier value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_identifier ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( names , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_names ) ) { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> identifier value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_identifier ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( names , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> ","<S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>stmt"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_int ( tmp , & lineno , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""col_offset\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>stmt"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> col_offset <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_args , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } else { int res ; res = obj2ast_arguments ( tmp , & args <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_decorator_list , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; returns = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_string ( tmp , & type_comment <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_args , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } else { int res ; res = obj2ast_arguments ( tmp , & args <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_decorator_list , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; returns = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_string ( tmp , & type_comment <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_bases , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""bases\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_keywords , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""keywords\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_decorator_list , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; value = NULL ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Delete"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assign"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val ) ; } Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assign"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_string ( tmp , & type_comment <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_op , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""op\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign"" ) ; return 1 ; } else { int res ; res = obj2ast_operator ( tmp , & op , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> value <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_annotation , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""annotation\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> annotation <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; value = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_simple , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { <S2SV_ModEnd> <S2SV_ModStart> ""required<S2SV_blank>field<S2SV_blank>\\""simple\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_int ( tmp , & simple <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_iter , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> iter <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_iter , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> iter <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""test\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""test\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>With"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>With"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncWith"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncWith"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; exc = NULL ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & exc , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_cause , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; cause = NULL ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> cause <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_handlers , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""handlers\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_finalbody , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""finalbody\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""test\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assert"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_msg , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; msg = NULL ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> msg <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Import"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; module = NULL ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_identifier ( tmp , & module , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_names , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ImportFrom"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_level , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; level = 0 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Global"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Nonlocal"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expr"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1535,"<S2SV_StartBug> pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ; <S2SV_EndBug> ",<S2SV_ModStart> PAGE_KERNEL <S2SV_ModEnd> 
1536,"<S2SV_StartBug> 1 , 0 , xcp , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1537,<S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> ,<S2SV_ModStart> n2size < 1 ) <S2SV_ModEnd> 
1538,"
","
"
1539,"<S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> <S2SV_StartBug> free_rsp_buf ( resp_buftype , rsp ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cifs_small_buf_release ( req ) ; 
1540,<S2SV_StartBug> addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> ,<S2SV_ModStart> INADDR_LOOPBACK <S2SV_ModEnd> 
1541,<S2SV_StartBug> bmp_info . number_colors = ReadBlobLSBLong ( image ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; if ( bmp_info . number_colors > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" "
1542,<S2SV_StartBug> ufs -> upper_mnt = clone_private_mount ( & upperpath ) ; <S2SV_EndBug> ,"<S2SV_ModStart> sb -> s_stack_depth = max ( upperpath . mnt -> mnt_sb -> s_stack_depth , lowerpath . mnt -> mnt_sb -> s_stack_depth ) + 1 ; err = - EINVAL ; if ( sb -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( ""overlayfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n"" ) ; goto out_put_workpath ; } "
1543,<S2SV_StartBug> static const int16_t * filter = vp9_down2_symodd_half_filter ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1544,"<S2SV_StartBug> mutt_error ( ""%s"" , s + 3 ) ; <S2SV_EndBug> ",<S2SV_ModStart> 2 <S2SV_ModEnd> 
1545,<S2SV_StartBug> bin -> dyld_info = malloc ( sizeof ( struct dyld_info_command ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( off + sizeof ( struct dyld_info_command ) > bin -> size ) { <S2SV_EndBug> <S2SV_StartBug> free ( bin -> dyld_info ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> calloc ( 1 , <S2SV_ModEnd> <S2SV_ModStart> bin -> dyld_info ) { if ( <S2SV_ModStart> R_FREE <S2SV_ModEnd> <S2SV_ModStart> } "
1546,"<S2SV_StartBug> int n ; <S2SV_EndBug> <S2SV_StartBug> long newbufsize ; <S2SV_EndBug> <S2SV_StartBug> newbufsize <<= 1 ; <S2SV_EndBug> <S2SV_StartBug> JAS_DBGLOG ( 100 , ( ""mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%z\\n"" , m -> bufsize_ , <S2SV_EndBug> <S2SV_StartBug> if ( m -> pos_ > m -> len_ ) { <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t newbufsize ; size_t <S2SV_ModEnd> <S2SV_ModStart> if ( ! jas_safe_size_mul ( newbufsize , 2 , & newbufsize ) ) { <S2SV_ModEnd> <S2SV_ModStart> ""new<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>would<S2SV_blank>cause<S2SV_blank>overflow\\n"" ) ) ; <S2SV_ModEnd> <S2SV_ModStart> JAS_DBGLOG ( 100 , ( ""mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%zu\\n"" , m -> bufsize_ , newbufsize ) ) ; assert ( newbufsize > 0 ) ; if ( mem_resize ( m , newbufsize ) ) { return - 1 ; } } "
1547,<S2SV_StartBug> void * dllhandle ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( COM_CompareExtension ( name , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , name ) ; return NULL ; } "
1548,<S2SV_StartBug> rfcomm_dlc_accept ( d ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1549,<S2SV_StartBug> d0u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> d1u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 1 ] ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1550,<S2SV_StartBug> # endif <S2SV_EndBug> ,"<S2SV_ModStart> conf_write ( fp , ""<S2SV_blank>umask<S2SV_blank>=<S2SV_blank>0%o"" , global_data -> umask ) ; "
1551,"<S2SV_StartBug> char sbuf [ 128 ] ; <S2SV_EndBug> <S2SV_StartBug> err = __video_do_ioctl ( file , cmd , parg ) ; <S2SV_EndBug> ","<S2SV_ModStart> return video_usercopy <S2SV_ModEnd> <S2SV_ModStart> arg , __video_do_ioctl ) <S2SV_ModEnd> "
1552,<S2SV_StartBug> return tok ; <S2SV_EndBug> ,<S2SV_ModStart> tok -> type_comments = 0 ; 
1553,<S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> strict = true ; 
1554,"<S2SV_StartBug> static void read_inter_mode_probs ( FRAME_CONTEXT * fc , vp9_reader * r ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> 
1555,"<S2SV_StartBug> static void get_sb_partition_size_range ( VP9_COMP * cpi , MODE_INFO * * mi_8x8 , <S2SV_EndBug> <S2SV_StartBug> BLOCK_SIZE * max_block_size ) { <S2SV_EndBug> <S2SV_StartBug> * min_block_size = MIN ( * min_block_size , sb_type ) ; <S2SV_EndBug> ","<S2SV_ModStart> MACROBLOCKD * xd <S2SV_ModEnd> <S2SV_ModStart> , int bs_hist [ BLOCK_SIZES ] ) { <S2SV_ModEnd> <S2SV_ModStart> bs_hist [ sb_type ] ++ ; "
1556,"<S2SV_StartBug> unsigned int len = sizeof ( * ctx ) + crypto_skcipher_reqsize ( private ) ; <S2SV_EndBug> <S2SV_StartBug> ctx -> iv = sock_kmalloc ( sk , crypto_skcipher_ivsize ( private ) , <S2SV_EndBug> <S2SV_StartBug> memset ( ctx -> iv , 0 , crypto_skcipher_ivsize ( private ) ) ; <S2SV_EndBug> <S2SV_StartBug> skcipher_request_set_tfm ( & ctx -> req , private ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct skcipher_tfm * tfm = private ; struct crypto_skcipher * skcipher = tfm -> skcipher ; <S2SV_ModStart> skcipher ) ; if ( ! tfm -> has_key ) return - ENOKEY <S2SV_ModEnd> <S2SV_ModStart> skcipher <S2SV_ModEnd> <S2SV_ModStart> skcipher ) ) ; INIT_LIST_HEAD ( & ctx -> tsgl ) ; ctx -> len = len ; ctx -> used = 0 ; ctx -> more = 0 ; ctx -> merge = 0 ; ctx -> enc = 0 ; atomic_set ( & ctx -> inflight , 0 ) ; af_alg_init_completion ( & ctx -> completion ) ; ask -> private <S2SV_ModEnd> <S2SV_ModStart> skcipher <S2SV_ModEnd> "
1557,"<S2SV_StartBug> uint32_t tag = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( tcm_tmr < 0 ) { <S2SV_EndBug> <S2SV_StartBug> rc = srpt_rx_mgmt_fn_tag ( send_ioctx , srp_tsk -> task_tag ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> unpacked_lun = srpt_unpack_lun ( ( uint8_t * ) & srp_tsk -> lun , sizeof ( srp_tsk -> lun ) ) ; rc = target_submit_tmr ( & send_ioctx -> cmd , sess , NULL , unpacked_lun , srp_tsk , tcm_tmr , GFP_KERNEL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1558,"<S2SV_StartBug> char * command , * args = value ; <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> if ( size == PAGE_SIZE ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> args [ size ] = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( name , ""current"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( command , ""permhat"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( name , ""exec"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> aad . error = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> ","<S2SV_ModStart> largs = NULL , * <S2SV_ModStart> ; if ( current != task ) return - EACCES <S2SV_ModStart> largs = args = kmalloc ( size + 1 , GFP_KERNEL ) ; if ( ! args <S2SV_ModEnd> <S2SV_ModStart> ENOMEM ; memcpy ( args , value , size ) ; args [ size ] = '\\0' ; } error = - <S2SV_ModStart> = strim ( args ) ; command = strsep ( & args , ""<S2SV_blank>"" ) ; if ( ! args ) goto out ; args = skip_spaces ( args ) ; if ( ! * args ) goto out ; arg_size = size - ( args - ( char * ) value ) ; if ( strcmp ( name , ""current"" ) == 0 ) { if ( strcmp ( command , ""changehat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permhat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , ""changeprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else goto fail ; } else <S2SV_ModEnd> <S2SV_ModStart> ""exec"" ) == 0 ) { if ( strcmp ( command , ""exec"" ) == 0 ) error = aa_setprocattr_changeprofile ( args , AA_ONEXEC <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! error ) error = size ; out : kfree ( largs ) <S2SV_ModEnd> <S2SV_ModStart> error = <S2SV_ModStart> goto out <S2SV_ModEnd> "
1559,<S2SV_StartBug> ret = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> key_put ( keyring ) ; 
1560,"<S2SV_StartBug> if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , <S2SV_EndBug> <S2SV_StartBug> if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , <S2SV_EndBug> ","<S2SV_ModStart> p_total_data_size , <S2SV_ModStart> p_total_data_size , "
1561,"<S2SV_StartBug> int ret = select ( ( max_curr_s + 1 ) , & curr_set , NULL , NULL , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1562,"<S2SV_StartBug> ssize_t sent = send ( fd , p_buf -> data + p_buf -> offset , p_buf -> len , MSG_DONTWAIT ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1563,"<S2SV_StartBug> spin_lock ( & inode -> i_lock ) ; <S2SV_EndBug> <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , ( chg - freed ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> hugepage_subpool_put_pages ( spool <S2SV_ModEnd> 
1564,<S2SV_StartBug> static void <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1565,"<S2SV_StartBug> struct in6_addr * saddr = NULL , * final_p , final ; <S2SV_EndBug> <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> if ( np -> opt ) <S2SV_EndBug> <S2SV_StartBug> icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen + <S2SV_EndBug> <S2SV_StartBug> np -> opt -> opt_nflen ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; struct ipv6_txoptions * opt <S2SV_ModStart> opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1566,"<S2SV_StartBug> dwc3_gadget_giveback ( dep , req , ret ) ; <S2SV_EndBug> ",<S2SV_ModStart> dwc3_gadget_del_and_unmap_request <S2SV_ModEnd> 
1567,<S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
1568,<S2SV_StartBug> if ( border < 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> || color < 0 
1569,<S2SV_StartBug> state -> indent = strdup ( RSTRING_PTR ( indent ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> fstrndup <S2SV_ModEnd> <S2SV_ModStart> , len "
1570,"<S2SV_StartBug> if ( strcmp ( ptr , ""get<S2SV_blank>"" ) && strcmp ( ptr , ""gets<S2SV_blank>"" ) ) { <S2SV_EndBug> ","<S2SV_ModStart> ptr - c -> rcurr > 100 || ( strncmp ( ptr , ""get<S2SV_blank>"" , 4 ) && strncmp <S2SV_ModEnd> <S2SV_ModStart> , 5 ) "
1571,<S2SV_StartBug> struct futex_hash_bucket * hb ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1572,"<S2SV_StartBug> addModuleArgument ( db , pTable , sqlite3NameFromToken ( db , pModuleName ) ) ; <S2SV_EndBug> <S2SV_StartBug> addModuleArgument ( db , pTable , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> addModuleArgument ( db , pTable , sqlite3DbStrDup ( db , pTable -> zName ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> pParse <S2SV_ModEnd> <S2SV_ModStart> pParse <S2SV_ModEnd> <S2SV_ModStart> pParse <S2SV_ModEnd> 
1573,"<S2SV_StartBug> switch ( type ) <S2SV_EndBug> <S2SV_StartBug> SetPixelIndex ( image , ( ( ( unsigned char ) pixel ) & <S2SV_EndBug> <S2SV_StartBug> ( 0x01 << ( 7 - bit ) ) ) != 0 ? 0 : 255 , q ) ; <S2SV_EndBug> <S2SV_StartBug> x -- ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ","<S2SV_ModStart> if ( image -> depth > 1 ) { SetPSDPixel ( image , channels , type , packet_size , pixel , q , exception ) ; q += GetPixelChannels ( image ) ; } else <S2SV_ModEnd> <S2SV_ModStart> SetPSDPixel ( image , channels , type , packet_size <S2SV_ModEnd> <S2SV_ModStart> , exception <S2SV_ModEnd> <S2SV_ModStart> if ( x != image -> columns ) <S2SV_ModStart>  <S2SV_ModEnd> "
1574,<S2SV_StartBug> if ( ! mp -> ports && ! mp -> mglist && <S2SV_EndBug> ,<S2SV_ModStart> mp -> timer_armed && 
1575,"<S2SV_StartBug> int sec ; <S2SV_EndBug> <S2SV_StartBug> guint pkt_len ; <S2SV_EndBug> <S2SV_StartBug> guint offset = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( sscanf ( line , ""%9d.%9d:<S2SV_blank>%15[a-z0-9/:.-](%1[io])<S2SV_blank>len=%9u:%12s->%12s/"" , <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> ","<S2SV_ModStart> pkt_len ; int <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> ""%9d.%9d:<S2SV_blank>%15[a-z0-9/:.-](%1[io])<S2SV_blank>len=%9d:%12s->%12s/"" <S2SV_ModEnd> <S2SV_ModStart> ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""netscreen:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ; return FALSE "
1576,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> id_key_set = rb_intern_const ( ""key_set"" ) ; "
1577,"<S2SV_StartBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> vp8_yv12_copy_frame ( <S2SV_EndBug> <S2SV_StartBug> for ( i = 2 ; i < MAX_REF_FRAMES - 1 ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> & cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> for ( i = LAST_FRAME <S2SV_ModEnd> <S2SV_ModStart> ; ++ i <S2SV_ModEnd> <S2SV_ModStart> cpi -> Source <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> oxcf . noise_sensitivity == 4 ) vp8_yv12_copy_frame ( cpi -> Source , & cpi -> denoiser . yv12_last_source ) ; "
1578,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1579,"<S2SV_StartBug> for ( i = 0 ; i < numcmpts ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> data [ i ] = jas_matrix_create ( jas_image_height ( image ) , jas_image_width ( image ) ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> nz -= 8 ; <S2SV_EndBug> ","<S2SV_ModStart> assert ( numcmpts <= 3 ) ; for ( i = 0 ; i < 3 ; ++ i ) { data [ i ] = 0 ; } <S2SV_ModStart> if ( ! ( <S2SV_ModStart> ) ) { goto error ; } <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error ; } nz -= 8 ; z &= RAS_ONES ( nz ) ; } } if ( nz > 0 ) { c = ( z >> ( 8 - nz ) ) & RAS_ONES ( nz ) ; if ( jas_stream_putc ( out , c ) == EOF ) { goto error ; } } if ( pad % 2 ) { if ( jas_stream_putc ( out , 0 ) == EOF ) { goto error ; } } } for ( i = 0 ; i < numcmpts ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; data [ i ] = 0 ; } return 0 ; error : for ( i = 0 ; i < numcmpts ; ++ i ) { if ( data [ i ] ) { jas_matrix_destroy ( data [ i ] ) ; } } <S2SV_ModStart>  <S2SV_ModEnd> "
1580,<S2SV_StartBug> if ( ! ( skb -> dev -> flags & IFF_LOOPBACK ) ) { <S2SV_EndBug> ,<S2SV_ModStart> skb == NULL || 
1581,"<S2SV_StartBug> if ( out ) { <S2SV_EndBug> <S2SV_StartBug> container_of ( out , struct ipc_rcu_hdr , data ) -> refcount = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( out ) { <S2SV_EndBug> <S2SV_StartBug> container_of ( out , struct ipc_rcu_hdr , data ) -> refcount = 1 ; <S2SV_EndBug> ","<S2SV_ModStart> ! out ) goto done ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ! out ) goto done ; <S2SV_ModEnd> <S2SV_ModStart> } atomic_set ( & <S2SV_ModStart> , 1 ) ; done : <S2SV_ModEnd> "
1582,<S2SV_StartBug> if ( last_sec > 0 && last_usec > 0 ) { <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> ,"<S2SV_ModStart> caplentoobig ) { printf ( ""\\n\\nCapture<S2SV_blank>file<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>damaged<S2SV_blank>or<S2SV_blank>corrupt.\\n"" ""Contains<S2SV_blank>packet<S2SV_blank>of<S2SV_blank>size<S2SV_blank>%u,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>snap<S2SV_blank>length<S2SV_blank>%u\\n"" , caplen , pcap_fh . snaplen ) ; close ( fd ) ; break ; } if ( <S2SV_ModStart> break <S2SV_ModEnd> "
1583,<S2SV_StartBug> uchar buf [ MIF_MAGICLEN ] ; <S2SV_EndBug> ,<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
1584,"<S2SV_StartBug> static void write_selected_tx_size ( const VP9_COMP * cpi , <S2SV_EndBug> <S2SV_StartBug> vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> & cpi -> common . fc . tx_probs ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , tx_size != TX_4X4 , tx_probs [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , tx_size != TX_8X8 , tx_probs [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , tx_size != TX_16X16 , tx_probs [ 2 ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> VP9_COMMON * cm , const MACROBLOCKD * xd , vpx_writer <S2SV_ModEnd> <S2SV_ModStart> TX_SIZE tx_size = xd -> mi [ 0 ] -> mbmi . tx_size ; BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> "
1585,"<S2SV_StartBug> MODE_INFO * * mi_8x8 , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> int row8x8_remaining = tile -> mi_row_end - mi_row ; <S2SV_EndBug> <S2SV_StartBug> int col8x8_remaining = tile -> mi_col_end - mi_col ; <S2SV_EndBug> <S2SV_StartBug> int r , c ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * mi_upper_left = cm -> mi + mi_row * mis + mi_col ; <S2SV_EndBug> <S2SV_StartBug> const int src_stride = x -> plane [ 0 ] . src . stride ; <S2SV_EndBug> <S2SV_StartBug> const int pre_stride = cpi -> Last_Source -> y_stride ; <S2SV_EndBug> <S2SV_StartBug> const uint8_t * pre_src = cpi -> Last_Source -> y_buffer + pre_offset ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 4 ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> diff d16 [ 4 ] ; <S2SV_EndBug> <S2SV_StartBug> pre_stride , & d16 [ j ] . sse , & d16 [ j ] . sum ) ; <S2SV_EndBug> <S2SV_StartBug> ( ( ( uint32_t ) d16 [ j ] . sum * d16 [ j ] . sum ) >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ( cm -> current_video_frame - 1 ) % <S2SV_EndBug> <S2SV_StartBug> use16x16 = 1 ; <S2SV_EndBug> ","<S2SV_ModStart> MACROBLOCK * const x , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> const <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; vp9_setup_src_planes ( x , cpi -> Source , mi_row , mi_col ) <S2SV_ModStart> int i , j ; int index ; diff d32 [ 4 ] ; const int offset = ( mi_row >> 1 ) * cm -> mb_cols + ( mi_col >> 1 ) ; int is_larger_better = 0 ; int use32x32 = 0 ; unsigned int thr <S2SV_ModEnd> <S2SV_ModStart> source_var_thresh ; memset ( d32 , 0 , 4 * sizeof ( diff ) ) ; for ( i = 0 ; i < 4 ; i ++ ) { diff * d16 [ 4 ] ; for ( j = 0 ; j < 4 ; j ++ ) { int b_mi_row = coord_lookup [ i * 4 + j ] . row ; int b_mi_col = coord_lookup [ i * 4 + j ] . col ; int boffset = b_mi_row / 2 * cm -> mb_cols + b_mi_col / 2 ; d16 [ j ] <S2SV_ModEnd> <S2SV_ModStart> source_diff_var + offset + boffset ; index = b_mi_row * mis + b_mi_col ; mi_8x8 [ index ] = mi_upper_left + index ; mi_8x8 [ index ] -> mbmi . sb_type = BLOCK_16X16 ; } is_larger_better = ( d16 [ 0 ] -> var < thr ) && ( d16 [ 1 ] -> var < thr ) && ( d16 [ 2 ] -> var < thr ) && ( d16 [ 3 ] -> var < thr ) ; if ( is_larger_better ) { use32x32 += 1 <S2SV_ModEnd> <S2SV_ModStart> j = 0 ; j < 4 ; j <S2SV_ModEnd> <S2SV_ModStart> d32 [ i <S2SV_ModEnd> <S2SV_ModStart> += d16 [ j ] -> sse ; d32 [ i <S2SV_ModEnd> <S2SV_ModStart> += d16 [ j ] -> sum ; } d32 [ i ] . var = d32 [ i <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } } if ( use32x32 == 4 ) { thr <<= 1 ; is_larger_better = ( d32 [ 0 ] . var < thr ) && ( d32 [ 1 ] . var < thr ) && ( d32 [ 2 ] . var < thr ) && ( d32 [ 3 ] . var < thr ) ; if ( is_larger_better ) { mi_8x8 [ 0 ] = mi_upper_left ; mi_8x8 [ 0 ] -> mbmi . sb_type = BLOCK_64X64 ; } } <S2SV_ModEnd> <S2SV_ModStart> int bh = num_8x8_blocks_high_lookup [ BLOCK_16X16 ] ; int bw = num_8x8_blocks_wide_lookup [ BLOCK_16X16 ] ; set_partial_b64x64_partition ( mi_upper_left , mis , bh , bw , row8x8_remaining , col8x8_remaining , BLOCK_16X16 , mi_8x8 ) ; <S2SV_ModEnd> "
1586,<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! tty ) return 
1587,<S2SV_StartBug> static void parse_input ( h2o_http2_conn_t * conn ) <S2SV_EndBug> <S2SV_StartBug> close_connection ( conn ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModStart> return 0 ; 
1588,"<S2SV_StartBug> IBITS_NXT ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , u4_sym_len ) <S2SV_EndBug> <S2SV_StartBug> DecodedValue = gau2_impeg2d_tab_zero_1_9 [ u4_bits >> 8 ] ; <S2SV_EndBug> ",<S2SV_ModStart> lead_zeros = CLZ ( u4_bits ) - 15 ; if ( lead_zeros > 11 ) { return IMPEG2D_MB_DATA_DECODE_ERR ; } <S2SV_ModStart> lead_zeros = CLZ ( u4_bits ) - 15 ; if ( lead_zeros > 11 ) { return IMPEG2D_MB_DATA_DECODE_ERR ; } 
1589,"<S2SV_StartBug> security_decrypt ( s -> p , length , rdp ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) return FALSE 
1590,"<S2SV_StartBug> if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( ioctl ( sock -> our_fd , FIONREAD , & size ) <S2SV_EndBug> <S2SV_StartBug> int count = recv ( fd , buffer , L2CAP_MAX_SDU_LENGTH , <S2SV_EndBug> <S2SV_StartBug> MSG_NOSIGNAL | MSG_DONTWAIT ) ; <S2SV_EndBug> <S2SV_StartBug> if ( drop_it || ioctl ( sock -> our_fd , FIONREAD , & size ) != 0 || size == 0 ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1591,<S2SV_StartBug> bool disconnect ; <S2SV_EndBug> <S2SV_StartBug> __touch_mnt_namespace ( p -> mnt_ns ) ; <S2SV_EndBug> ,<S2SV_ModStart> struct mnt_namespace * ns ; <S2SV_ModStart> ns = p -> mnt_ns ; if ( ns ) { ns -> mounts -- ; __touch_mnt_namespace ( ns ) ; } <S2SV_ModEnd> 
1592,"<S2SV_StartBug> static int renameColumnSelectCb ( Walker * pWalker , Select * p ) { <S2SV_EndBug> ",<S2SV_ModStart> if ( p -> selFlags & SF_View ) return WRC_Prune ; 
1593,"<S2SV_StartBug> dtls1_record_bitmap_update ( s , & ( s -> d1 -> bitmap ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1594,<S2SV_StartBug> int iSrc ; <S2SV_EndBug> <S2SV_StartBug> for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { <S2SV_EndBug> <S2SV_StartBug> dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ] . 
1595,"<S2SV_StartBug> guint32 off = offset ; <S2SV_EndBug> <S2SV_StartBug> DebugLog ( ( ""parse_wbxml_tag_defined<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\n"" , * level , offset ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , last_off <S2SV_ModStart> ; last_off = off <S2SV_ModStart> if ( off < last_off ) { THROW ( ReportedBoundsError ) ; } last_off = off ; "
1596,<S2SV_StartBug> if ( sk_acceptq_is_full ( sk ) ) <S2SV_EndBug> <S2SV_StartBug> newinet -> opt = ireq -> opt ; <S2SV_EndBug> ,"<S2SV_ModStart> struct ip_options_rcu * inet_opt ; <S2SV_ModStart> inet_opt = ireq -> opt ; rcu_assign_pointer ( newinet -> inet_opt , inet_opt ) ; <S2SV_ModEnd> <S2SV_ModStart> = NULL ; newinet -> mc_index = inet_iif ( skb ) ; newinet -> mc_ttl = ip_hdr ( skb ) -> ttl ; inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( inet_opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = inet_opt -> opt . <S2SV_ModEnd> "
1597,"<S2SV_StartBug> USB_DT_SECURITY , ( void * * ) & secd ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( * secd ) "
1598,"<S2SV_StartBug> static void set_rt_speed_feature ( VP9_COMMON * cm , SPEED_FEATURES * sf , <S2SV_EndBug> <S2SV_StartBug> int speed ) { <S2SV_EndBug> <S2SV_StartBug> sf -> encode_breakout_thresh = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( speed == 1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( MIN ( cm -> width , cm -> height ) >= 720 ) <S2SV_EndBug> <S2SV_StartBug> sf -> auto_mv_step_size = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; <S2SV_EndBug> <S2SV_StartBug> sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> sf -> use_rd_breakout = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> auto_mv_step_size = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_LOW_MOTION ; <S2SV_EndBug> <S2SV_StartBug> sf -> adaptive_rd_thresh = 2 ; <S2SV_EndBug> <S2SV_StartBug> sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ; <S2SV_EndBug> <S2SV_StartBug> sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_ALL ; <S2SV_EndBug> <S2SV_StartBug> sf -> subpel_iters_per_step = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ; <S2SV_EndBug> <S2SV_StartBug> sf -> lpf_pick = LPF_PICK_FROM_Q ; <S2SV_EndBug> <S2SV_StartBug> ( cm -> current_video_frame + 1 ) % sf -> last_partitioning_redo_frequency ) ; <S2SV_EndBug> <S2SV_StartBug> sf -> subpel_force_stop = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> intra_uv_mode_mask [ i ] = INTRA_DC_ONLY ; <S2SV_EndBug> <S2SV_StartBug> sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC_ONLY ; <S2SV_EndBug> <S2SV_StartBug> sf -> encode_breakout_thresh = 1000 ; <S2SV_EndBug> <S2SV_StartBug> sf -> disable_inter_mode_mask [ BLOCK_32X32 ] = 1 << INTER_OFFSET ( ZEROMV ) ; <S2SV_EndBug> <S2SV_StartBug> sf -> disable_inter_mode_mask [ BLOCK_32X64 ] = ~ ( 1 << INTER_OFFSET ( NEARESTMV ) ) ; <S2SV_EndBug> <S2SV_StartBug> sf -> disable_inter_mode_mask [ BLOCK_64X32 ] = ~ ( 1 << INTER_OFFSET ( NEARESTMV ) ) ; <S2SV_EndBug> <S2SV_StartBug> sf -> disable_inter_mode_mask [ BLOCK_64X64 ] = ~ ( 1 << INTER_OFFSET ( NEARESTMV ) ) ; <S2SV_EndBug> <S2SV_StartBug> sf -> max_partition_size = BLOCK_32X32 ; <S2SV_EndBug> <S2SV_StartBug> sf -> min_partition_size = BLOCK_8X8 ; <S2SV_EndBug> <S2SV_StartBug> sf -> partition_check = <S2SV_EndBug> <S2SV_StartBug> sf -> max_delta_qindex = ( cm -> frame_type == KEY_FRAME ) ? 20 : 15 ; <S2SV_EndBug> <S2SV_StartBug> sf -> search_method = FAST_DIAMOND ; <S2SV_EndBug> <S2SV_StartBug> sf -> allow_skip_recode = 0 ; <S2SV_EndBug> <S2SV_StartBug> sf -> partition_search_type = SOURCE_VAR_BASED_PARTITION ; <S2SV_EndBug> <S2SV_StartBug> sf -> search_method = FAST_DIAMOND ; <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> ","<S2SV_ModStart> VP9_COMP * cpi <S2SV_ModEnd> <S2SV_ModStart> , vp9e_tune_content content ) { VP9_COMMON * const cm = & cpi -> common ; const int is_keyframe = cm -> frame_type == KEY_FRAME ; const int frames_since_key = is_keyframe ? 0 : cpi -> rc . frames_since_key ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> >= <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mv . <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mode_search_skip_flags = ( cm -> frame_type == KEY_FRAME ) ? 0 : <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> reference_masking = ( cpi -> oxcf . resize_mode != RESIZE_DYNAMIC && cpi -> svc . number_spatial_layers == 1 ) ? 1 : 0 <S2SV_ModEnd> <S2SV_ModStart> lf_motion_threshold = LOW_MOTION_THRESHOLD <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> TX_16X16 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mv . <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> frames_since_key <S2SV_ModEnd> <S2SV_ModStart> mv . <S2SV_ModStart> INTRA_DC <S2SV_ModEnd> <S2SV_ModStart> INTRA_DC <S2SV_ModEnd> <S2SV_ModStart> mv . <S2SV_ModEnd> <S2SV_ModStart> inter_mode_mask <S2SV_ModEnd> <S2SV_ModStart> INTER_NEAREST_NEAR_NEW ; sf -> inter_mode_mask <S2SV_ModEnd> <S2SV_ModStart> INTER_NEAREST ; sf -> inter_mode_mask <S2SV_ModEnd> <S2SV_ModStart> INTER_NEAREST ; sf -> inter_mode_mask <S2SV_ModEnd> <S2SV_ModStart> INTER_NEAREST <S2SV_ModEnd> <S2SV_ModStart> use_quant_fp = ! is_keyframe ; sf -> auto_min_max_partition_size = is_keyframe ? RELAXED_NEIGHBORING_MIN_MAX : STRICT_NEIGHBORING_MIN_MAX ; sf -> default_max_partition_size <S2SV_ModEnd> <S2SV_ModStart> default_min_partition_size <S2SV_ModEnd> <S2SV_ModStart> force_frame_boost = is_keyframe || ( frames_since_key % <S2SV_ModEnd> <S2SV_ModStart> is_keyframe <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sf -> inter_mode_mask [ BLOCK_32X32 ] = INTER_NEAREST_NEW_ZERO ; sf -> inter_mode_mask [ BLOCK_32X64 ] = INTER_NEAREST_NEW_ZERO ; sf -> inter_mode_mask [ BLOCK_64X32 ] = INTER_NEAREST_NEW_ZERO ; sf -> inter_mode_mask [ BLOCK_64X64 ] = INTER_NEAREST_NEW_ZERO ; sf -> adaptive_rd_thresh = 2 ; sf -> reuse_inter_pred_sby = 1 ; sf -> partition_search_breakout_rate_thr = 200 ; sf -> coeff_prob_appx_step = 4 ; sf -> use_fast_coef_updates = is_keyframe ? TWO_LOOP : ONE_LOOP_REDUCED ; sf -> mode_search_skip_flags = FLAG_SKIP_INTRA_DIRMISMATCH ; sf -> tx_size_search_method = is_keyframe ? USE_LARGESTALL : USE_TX_8X8 ; sf -> simple_model_rd_from_var = 1 ; if ( ! is_keyframe ) { int i ; if ( content == VP9E_CONTENT_SCREEN ) { for ( i = 0 ; i < BLOCK_SIZES ; ++ i ) sf -> intra_y_mode_bsize_mask [ i ] = INTRA_DC_TM_H_V ; } else { for ( i = 0 ; i < BLOCK_SIZES ; ++ i ) if ( i >= BLOCK_16X16 ) sf -> intra_y_mode_bsize_mask [ i ] = INTRA_DC ; else sf -> intra_y_mode_bsize_mask [ i ] = INTRA_DC_H_V ; } } <S2SV_ModStart> VAR_BASED_PARTITION <S2SV_ModEnd> <S2SV_ModStart> mv . search_method = NSTEP ; sf -> mv . reduce_first_step_size = 1 ; sf -> skip_encode_sb = 0 <S2SV_ModEnd> <S2SV_ModStart> sf -> adaptive_rd_thresh = 3 ; sf -> mv . search_method = FAST_DIAMOND ; sf -> mv . fullpel_search_step_param = 10 ; if ( cpi -> svc . number_temporal_layers > 2 && cpi -> svc . temporal_layer_id == 0 ) { sf -> mv . search_method = NSTEP ; sf -> mv . fullpel_search_step_param = 6 ; } } if ( speed >= 8 ) { sf -> adaptive_rd_thresh = 4 ; sf -> mv . subpel_force_stop = 2 ; sf -> lpf_pick = LPF_PICK_MINIMAL_LPF <S2SV_ModEnd> "
1599,"<S2SV_StartBug> zend_throw_error ( exception_ce , message ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , "
1600,"<S2SV_StartBug> box -> len = len ; <S2SV_EndBug> <S2SV_StartBug> jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; JAS_DBGLOG ( 10 , ( ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n"" , \'""\' , boxinfo -> name , \'""\' , box -> type , box -> len ) ) <S2SV_ModStart> box -> ops = & jp2_boxinfo_unk . ops ; "
1601,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1602,<S2SV_StartBug> if ( options . compression ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1603,<S2SV_StartBug> newnp -> ipv6_ac_list = NULL ; <S2SV_EndBug> <S2SV_StartBug> newinet -> inet_opt = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ipv6_mc_list = NULL ; newnp -> <S2SV_ModStart> = NULL ; newnp -> ipv6_mc_list 
1604,<S2SV_StartBug> unix_notinflight ( scm -> fp -> fp [ i ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> user , scm -> fp -> "
1605,"<S2SV_StartBug> int recon_uvoffset ) <S2SV_EndBug> <S2SV_StartBug> unsigned int motion_magnitude2 ; <S2SV_EndBug> <S2SV_StartBug> if ( zero_frame ) <S2SV_EndBug> <S2SV_StartBug> int sse_diff = zero_mv_sse - best_sse ; <S2SV_EndBug> <S2SV_StartBug> if ( frame == INTRA_FRAME || <S2SV_EndBug> <S2SV_StartBug> ( ( unsigned int ) ( mv_row * mv_row + mv_col * mv_col ) <S2SV_EndBug> <S2SV_StartBug> if ( best_sse > SSE_THRESHOLD || motion_magnitude2 <S2SV_EndBug> <S2SV_StartBug> > 8 * NOISE_MOTION_THRESHOLD ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> decision = vp8_denoiser_filter ( & denoiser -> yv12_mc_running_avg , <S2SV_EndBug> <S2SV_StartBug> vp8_copy_mem16x16 ( <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , loop_filter_info_n * lfi_n , int mb_row , int mb_col , int block_index <S2SV_ModStart> motion_threshold ; unsigned int motion_magnitude2 ; unsigned int sse_thresh ; int sse_diff_thresh = 0 ; int apply_spatial_loop_filter = 1 <S2SV_ModEnd> <S2SV_ModStart> enum vp8_denoiser_decision decision_u = COPY_BLOCK ; enum vp8_denoiser_decision decision_v = COPY_BLOCK ; <S2SV_ModStart> sse_diff = 0 ; const int zero_bias = denoiser -> denoise_pars . denoise_mv_bias ; zero_mv_sse = ( unsigned int ) ( ( int64_t ) zero_mv_sse * zero_bias / 100 ) ; <S2SV_ModStart> ( unsigned int ) ( mv_row * mv_row + mv_col * mv_col ) <= NOISE_MOTION_THRESHOLD ) sse_diff_thresh = ( int ) SSE_DIFF_THRESHOLD ; if ( <S2SV_ModStart> sse_diff <= sse_diff_thresh ) { x -> denoise_zeromv = 1 ; mbmi -> ref_frame = x -> best_zeromv_reference_frame ; src = & denoiser -> yv12_running_avg [ zero_frame ] ; mbmi -> mode = ZEROMV ; mbmi -> mv . as_int = 0 ; x -> best_sse_inter_mode = ZEROMV ; x -> best_sse_mv . as_int = 0 ; best_sse = zero_mv_sse ; } saved_pre = filter_xd -> pre ; saved_dst = filter_xd -> dst ; filter_xd -> pre . y_buffer = src -> y_buffer + recon_yoffset ; filter_xd -> pre . u_buffer = src -> u_buffer + recon_uvoffset ; filter_xd -> pre . v_buffer = src -> v_buffer + recon_uvoffset ; filter_xd -> dst . y_buffer = dst -> y_buffer + recon_yoffset ; filter_xd -> dst . u_buffer = dst -> u_buffer + recon_uvoffset ; filter_xd -> dst . v_buffer = dst -> v_buffer + recon_uvoffset ; if ( ! x -> skip ) { vp8_build_inter_predictors_mb ( filter_xd ) ; } else { vp8_build_inter16x16_predictors_mb ( filter_xd , filter_xd -> dst . y_buffer , filter_xd -> dst . u_buffer , filter_xd -> dst . v_buffer , filter_xd -> dst . y_stride , filter_xd -> dst . uv_stride ) ; } filter_xd -> pre = saved_pre ; filter_xd -> dst = saved_dst ; * mbmi = saved_mbmi ; } mv_row = x -> best_sse_mv . as_mv . row ; mv_col = x -> best_sse_mv . as_mv . col ; motion_magnitude2 = mv_row * mv_row <S2SV_ModEnd> <S2SV_ModStart> ; motion_threshold = denoiser -> denoise_pars . scale_motion_thresh * NOISE_MOTION_THRESHOLD ; if ( x -> is_skin ) motion_threshold = 1 ; if ( motion_magnitude2 < denoiser -> denoise_pars . scale_increase_filter * NOISE_MOTION_THRESHOLD ) x -> increase_denoising = 1 ; sse_thresh = denoiser -> denoise_pars . scale_sse_thresh * SSE_THRESHOLD ; if ( x -> increase_denoising ) sse_thresh = denoiser -> denoise_pars . scale_sse_thresh * SSE_THRESHOLD_HIGH <S2SV_ModEnd> <S2SV_ModStart> sse_thresh <S2SV_ModEnd> <S2SV_ModStart> motion_threshold ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> unsigned char * mc_running_avg_y = denoiser -> yv12_mc_running_avg . y_buffer + recon_yoffset ; int mc_avg_y_stride = denoiser -> yv12_mc_running_avg . y_stride ; unsigned char * running_avg_y = denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset ; int avg_y_stride = denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_stride ; <S2SV_ModStart> mc_running_avg_y , mc_avg_y_stride , running_avg_y , avg_y_stride , x -> thismb , 16 , motion_magnitude2 , x -> increase_denoising ) ; denoiser -> denoise_state [ block_index ] = motion_magnitude2 > 0 ? kFilterNonZeroMV : kFilterZeroMV ; if ( denoiser -> denoiser_mode != kDenoiserOnYOnly && motion_magnitude2 == 0 && decision == FILTER_BLOCK ) { unsigned char * mc_running_avg_u = <S2SV_ModEnd> <S2SV_ModStart> . u_buffer + recon_uvoffset ; unsigned char * running_avg_u = denoiser -> yv12_running_avg [ INTRA_FRAME ] . u_buffer + recon_uvoffset ; unsigned char * mc_running_avg_v = denoiser -> yv12_mc_running_avg . v_buffer + recon_uvoffset ; unsigned char * running_avg_v = denoiser -> yv12_running_avg [ INTRA_FRAME ] . v_buffer + recon_uvoffset ; int mc_avg_uv_stride = denoiser -> yv12_mc_running_avg . uv_stride ; int avg_uv_stride = denoiser -> yv12_running_avg [ INTRA_FRAME ] . uv_stride ; int signal_stride = x -> block [ 16 ] . src_stride ; decision_u = vp8_denoiser_filter_uv ( mc_running_avg_u , mc_avg_uv_stride , running_avg_u , avg_uv_stride , x -> block [ 16 ] . src + * x -> block [ 16 ] . base_src , signal_stride , motion_magnitude2 , 0 ) ; decision_v = vp8_denoiser_filter_uv ( mc_running_avg_v , mc_avg_uv_stride , running_avg_v , avg_uv_stride , x -> block [ 20 ] . src + * x -> block [ 20 ] . base_src , signal_stride , motion_magnitude2 , 0 ) ; } <S2SV_ModEnd> <S2SV_ModStart> x -> denoise_zeromv = 0 ; <S2SV_ModStart> denoiser -> denoise_state [ block_index ] = kNoFilter ; } if ( denoiser -> denoiser_mode != kDenoiserOnYOnly ) { if ( decision_u == COPY_BLOCK ) { vp8_copy_mem8x8 ( x -> block [ 16 ] . src + * x -> block [ 16 ] . base_src , x -> block [ 16 ] . src_stride , denoiser -> yv12_running_avg [ INTRA_FRAME ] . u_buffer + recon_uvoffset , denoiser -> yv12_running_avg [ INTRA_FRAME ] . uv_stride ) ; } if ( decision_v == COPY_BLOCK ) { vp8_copy_mem8x8 ( x -> block [ 20 ] . src + * x -> block [ 20 ] . base_src , x -> block [ 16 ] . src_stride , denoiser -> yv12_running_avg [ INTRA_FRAME ] . v_buffer + recon_uvoffset , denoiser -> yv12_running_avg [ INTRA_FRAME ] . uv_stride ) ; } } if ( apply_spatial_loop_filter ) { loop_filter_info lfi ; int apply_filter_col = 0 ; int apply_filter_row = 0 ; int apply_filter = 0 ; int y_stride = denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_stride ; int uv_stride = denoiser -> yv12_running_avg [ INTRA_FRAME ] . uv_stride ; int filter_level = 48 ; int hev_index = lfi_n -> hev_thr_lut [ INTER_FRAME ] [ filter_level ] ; lfi . mblim = lfi_n -> mblim [ filter_level ] ; lfi . blim = lfi_n -> blim [ filter_level ] ; lfi . lim = lfi_n -> lim [ filter_level ] ; lfi . hev_thr = lfi_n -> hev_thr [ hev_index ] ; if ( mb_col > 0 ) { apply_filter_col = ! ( ( denoiser -> denoise_state [ block_index ] == denoiser -> denoise_state [ block_index - 1 ] ) && denoiser -> denoise_state [ block_index ] != kFilterNonZeroMV ) ; if ( apply_filter_col ) { apply_filter = 1 ; vp8_loop_filter_mbv ( denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset , NULL , NULL , y_stride , uv_stride , & lfi ) ; } } if ( mb_row > 0 ) { apply_filter_row = ! ( ( denoiser -> denoise_state [ block_index ] == denoiser -> denoise_state [ block_index - denoiser -> num_mb_cols ] ) && denoiser -> denoise_state [ block_index ] != kFilterNonZeroMV ) ; if ( apply_filter_row ) { apply_filter = 1 ; vp8_loop_filter_mbh ( denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset , NULL , NULL , y_stride , uv_stride , & lfi ) ; } } if ( apply_filter ) { vp8_copy_mem16x16 ( denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset , y_stride , x -> thismb , 16 ) ; } "
1606,"<S2SV_StartBug> return mutt_bcache_del ( bcache , id ) ; <S2SV_EndBug> ",<S2SV_ModStart> cache_id ( id ) <S2SV_ModEnd> 
1607,<S2SV_StartBug> if ( ! unconditional ( & e -> ip ) ) <S2SV_EndBug> ,<S2SV_ModStart> e <S2SV_ModEnd> 
1608,<S2SV_StartBug> if ( ipv6_addr_type ( & lsa -> l2tp_addr ) & IPV6_ADDR_LINKLOCAL ) <S2SV_EndBug> ,<S2SV_ModStart> lsa -> l2tp_conn_id = 0 ; 
1609,<S2SV_StartBug> kvm_async_pf_hash_reset ( vcpu ) ; <S2SV_EndBug> ,<S2SV_ModStart> vcpu -> arch . pv_time_enabled = false ; 
1610,<S2SV_StartBug> tcon -> bad_network_name = true ; <S2SV_EndBug> ,<S2SV_ModStart> if ( tcon ) 
1611,"<S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false "
1612,<S2SV_StartBug> if ( xWantedSize > 0 ) <S2SV_EndBug> <S2SV_StartBug> xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ; <S2SV_EndBug> <S2SV_StartBug> mtCOVERAGE_TEST_MARKER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) && ( ( xWantedSize + xHeapStructSize ) > xWantedSize ) <S2SV_ModStart> if ( ( xWantedSize + <S2SV_ModEnd> <S2SV_ModStart> ) > xWantedSize ) { xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) <S2SV_ModStart> xWantedSize = 0 ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { xWantedSize = 0 <S2SV_ModEnd> 
1613,<S2SV_StartBug> if ( realms == NULL || realms [ 0 ] == '\\0' || <S2SV_EndBug> ,<S2SV_ModStart> NULL || * realms [ 0 ] == 
1614,"<S2SV_StartBug> static int read_mv_component ( vp9_reader * r , <S2SV_EndBug> <S2SV_StartBug> const int sign = vp9_read ( r , mvcomp -> sign ) ; <S2SV_EndBug> <S2SV_StartBug> const int mv_class = vp9_read_tree ( r , vp9_mv_class_tree , mvcomp -> classes ) ; <S2SV_EndBug> <S2SV_StartBug> d = vp9_read_tree ( r , vp9_mv_class0_tree , mvcomp -> class0 ) ; <S2SV_EndBug> <S2SV_StartBug> d |= vp9_read ( r , mvcomp -> bits [ i ] ) << i ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> fr = vp9_read_tree ( r , vp9_mv_fp_tree , class0 ? mvcomp -> class0_fp [ d ] <S2SV_EndBug> <S2SV_StartBug> hp = usehp ? vp9_read ( r , class0 ? mvcomp -> class0_hp : mvcomp -> hp ) <S2SV_EndBug> <S2SV_StartBug> mag = vp9_get_mv_mag ( mv_class , ( d << 3 ) | ( fr << 1 ) | hp ) + 1 ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> vpx_read_tree <S2SV_ModEnd> <S2SV_ModStart> vpx_read_tree <S2SV_ModEnd> <S2SV_ModStart> ; mag = 0 <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> mag = CLASS0_SIZE << ( mv_class + 2 ) ; <S2SV_ModStart> vpx_read_tree <S2SV_ModEnd> <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> += ( <S2SV_ModEnd> 
1615,<S2SV_StartBug> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ; <S2SV_EndBug> <S2SV_StartBug> if ( ses -> server -> sign ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> | NTLMSSP_NEGOTIATE_SEAL <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1616,<S2SV_StartBug> if ( info . si_code >= 0 ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug> ,<S2SV_ModStart> != SI_QUEUE ) { WARN_ON_ONCE ( info . si_code < 0 ) ; <S2SV_ModEnd> <S2SV_ModStart> } 
1617,"<S2SV_StartBug> lxc_attach_options_t * options = payload -> options ; <S2SV_EndBug> <S2SV_StartBug> if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) ) { <S2SV_EndBug> <S2SV_StartBug> int proc_mounted ; <S2SV_EndBug> <S2SV_StartBug> proc_mounted = mount_proc_if_needed ( ""/"" ) ; <S2SV_EndBug> <S2SV_StartBug> ret = lsm_process_label_set ( init_ctx -> lsm_label , <S2SV_EndBug> <S2SV_StartBug> rexit ( payload -> exec_function ( payload -> exec_payload ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> int procfd = payload -> procfd ; <S2SV_ModStart> && init_ctx -> lsm_label <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( lsm_set_label_at ( procfd , on_exec , <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> close ( procfd ) ; "
1618,<S2SV_StartBug> static void evtchn_2l_handle_events ( unsigned cpu ) <S2SV_EndBug> <S2SV_StartBug> irq = get_evtchn_to_irq ( port ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , struct evtchn_loop_ctrl * ctrl <S2SV_ModStart> handle_irq_for_port ( port , ctrl <S2SV_ModEnd> "
1619,<S2SV_StartBug> state -> space = strdup ( RSTRING_PTR ( space ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> fstrndup <S2SV_ModEnd> <S2SV_ModStart> , len "
1620,"<S2SV_StartBug> memcpy ( name , fp + n , name_len ) ; n += name_len ; <S2SV_EndBug> <S2SV_StartBug> attr_len = fp [ n ++ ] ; <S2SV_EndBug> ","<S2SV_ModStart> IRDA_ASSERT ( name_len < IAS_MAX_CLASSNAME + 1 , return ; ) ; <S2SV_ModStart> ; IRDA_ASSERT ( attr_len < IAS_MAX_ATTRIBNAME + 1 , return ; ) "
1621,<S2SV_StartBug> assert ( n >= 0 && n < 32 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( n < 0 || n >= 32 ) { return EOF ; } <S2SV_ModEnd> 
1622,"<S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> int active_best_quality ; <S2SV_EndBug> <S2SV_StartBug> if ( frame_is_intra_only ( cm ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( rc -> this_key_frame_forced ) { <S2SV_EndBug> <S2SV_StartBug> int qindex = rc -> last_boosted_qindex ; <S2SV_EndBug> <S2SV_StartBug> double last_boosted_q = vp9_convert_qindex_to_q ( qindex ) ; <S2SV_EndBug> <S2SV_StartBug> last_boosted_q * 0.75 ) ; <S2SV_EndBug> <S2SV_StartBug> active_best_quality = MAX ( qindex + delta_qindex , rc -> best_quality ) ; <S2SV_EndBug> <S2SV_StartBug> active_best_quality = get_active_quality ( active_worst_quality , <S2SV_EndBug> <S2SV_StartBug> q_val = vp9_convert_qindex_to_q ( active_best_quality ) ; <S2SV_EndBug> <S2SV_StartBug> q_val * q_adj_factor ) ; <S2SV_EndBug> <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> if ( q < cpi -> cq_target_quality ) <S2SV_EndBug> <S2SV_StartBug> } else if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> active_best_quality = cpi -> cq_target_quality ; <S2SV_EndBug> <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) && <S2SV_EndBug> <S2SV_StartBug> ( active_best_quality < cpi -> cq_target_quality ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced ) { <S2SV_EndBug> <S2SV_StartBug> * top_index = ( active_worst_quality + active_best_quality * 3 ) / 4 ; <S2SV_EndBug> <S2SV_StartBug> q = rc -> last_boosted_qindex ; <S2SV_EndBug> <S2SV_StartBug> if ( q > * top_index ) { <S2SV_EndBug> <S2SV_StartBug> * top_index = q ; <S2SV_EndBug> <S2SV_StartBug> * bottom_index = q ; <S2SV_EndBug> ","<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> const GF_GROUP * gf_group = & cpi -> twopass . gf_group ; const int cq_level = get_active_cq_level ( rc , oxcf ) ; int active_best_quality ; int active_worst_quality = cpi -> twopass . active_worst_quality ; int q ; int * inter_minq ; ASSIGN_MINQ_TABLE ( cm -> bit_depth , inter_minq ) <S2SV_ModEnd> <S2SV_ModStart> || vp9_is_upper_layer_key_frame ( cpi ) ) { <S2SV_ModEnd> <S2SV_ModStart> double last_boosted_q ; int delta_qindex ; int qindex ; if ( cpi -> twopass . last_kfgroup_zeromotion_pct >= STATIC_MOTION_THRESH ) { qindex = MIN ( rc -> last_kf_qindex , <S2SV_ModEnd> <S2SV_ModStart> ) ; active_best_quality = qindex ; <S2SV_ModEnd> <S2SV_ModStart> , cm -> bit_depth ) ; <S2SV_ModEnd> <S2SV_ModStart> 1.25 , cm -> bit_depth ) ; active_worst_quality = MIN <S2SV_ModEnd> <S2SV_ModStart> active_worst_quality ) ; } else { qindex = rc -> last_boosted_qindex ; last_boosted_q = vp9_convert_qindex_to_q ( qindex , cm -> bit_depth ) ; delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , last_boosted_q * 0.75 , cm -> bit_depth ) ; active_best_quality = MAX ( qindex + delta_qindex , <S2SV_ModStart> } <S2SV_ModStart> get_kf_active_quality ( rc , active_worst_quality , cm -> bit_depth <S2SV_ModEnd> <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> , cm -> bit_depth ) ; } <S2SV_ModEnd> <S2SV_ModStart> rc_mode == VPX_CQ <S2SV_ModEnd> <S2SV_ModStart> cq_level ) q = cq_level ; active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; <S2SV_ModEnd> <S2SV_ModStart> rc_mode == VPX_Q <S2SV_ModEnd> <S2SV_ModStart> cq_level ; } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; if ( gf_group -> rf_level [ gf_group -> index ] == GF_ARF_LOW ) active_best_quality = ( active_best_quality + cq_level + 1 ) / 2 ; } } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth <S2SV_ModEnd> <S2SV_ModStart> rc_mode == VPX_Q ) { active_best_quality = cq_level <S2SV_ModEnd> <S2SV_ModStart> rc_mode == VPX_CQ <S2SV_ModEnd> <S2SV_ModStart> cq_level ) ) { active_best_quality = cq_level ; } } } if ( ( cpi -> oxcf . rc_mode != VPX_Q ) && ( cpi -> twopass . gf_zeromotion_pct < VLOW_MOTION_THRESHOLD ) ) { if ( frame_is_intra_only ( cm ) || ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) ) { active_best_quality -= ( cpi -> twopass . extend_minq + cpi -> twopass . extend_minq_fast ) ; active_worst_quality += ( cpi -> twopass . extend_maxq / 2 ) ; } else { active_best_quality -= ( cpi -> twopass . extend_minq + cpi -> twopass . extend_minq_fast ) / 2 ; active_worst_quality += cpi -> twopass . extend_maxq ; } } <S2SV_ModEnd> <S2SV_ModStart> vpx_clear_system_state ( ) ; if ( ! ( ( frame_is_intra_only ( cm ) || vp9_is_upper_layer_key_frame ( cpi ) ) ) || ! rc -> this_key_frame_forced || ( cpi -> twopass . last_kfgroup_zeromotion_pct < STATIC_MOTION_THRESH ) ) { int qdelta = vp9_frame_type_qdelta ( cpi , gf_group -> rf_level [ gf_group -> index ] , active_worst_quality ) ; active_worst_quality = MAX ( active_worst_quality + qdelta , active_best_quality ) ; } # endif if ( rc -> frame_size_selector != UNSCALED && ! frame_is_kf_gf_arf ( cpi ) ) { int qdelta = vp9_compute_qdelta_by_rate ( rc , cm -> frame_type , active_best_quality , 2.0 , cm -> bit_depth ) ; active_best_quality = MAX ( active_best_quality + qdelta , rc -> best_quality ) ; } active_best_quality = clamp ( active_best_quality , rc -> best_quality , rc -> worst_quality ) ; active_worst_quality = clamp ( active_worst_quality , active_best_quality , rc -> worst_quality ) ; if ( oxcf -> rc_mode == VPX_Q ) { q = active_best_quality ; } else if ( ( frame_is_intra_only ( cm ) || vp9_is_upper_layer_key_frame ( cpi ) ) && <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> twopass . last_kfgroup_zeromotion_pct >= STATIC_MOTION_THRESH ) { q = MIN ( rc -> last_kf_qindex , <S2SV_ModEnd> <S2SV_ModStart> ) ; } else { q = rc -> last_boosted_qindex ; } <S2SV_ModEnd> <S2SV_ModStart> active_worst_quality <S2SV_ModEnd> <S2SV_ModStart> active_worst_quality = q ; else q = active_worst_quality ; } } clamp ( q , active_best_quality , active_worst_quality ) ; <S2SV_ModStart> active_worst_quality <S2SV_ModEnd> <S2SV_ModStart> active_best_quality ; <S2SV_ModEnd> "
1623,"<S2SV_StartBug> static void rate_block ( int plane , int block , BLOCK_SIZE plane_bsize , <S2SV_EndBug> <S2SV_StartBug> args -> rate = cost_coeffs ( args -> x , plane , block , args -> t_above + x_idx , <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> 
1624,<S2SV_StartBug> int is_udplite = IS_UDPLITE ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( udp_lib_checksum_complete ( skb ) ) <S2SV_EndBug> <S2SV_StartBug> if ( skb_csum_unnecessary ( skb ) ) <S2SV_EndBug> ,<S2SV_ModStart> ; bool checksum_valid = false <S2SV_ModStart> checksum_valid = ! <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! checksum_valid <S2SV_ModStart> checksum_valid || 
1625,"<S2SV_StartBug> static void udf_pc_to_char ( struct super_block * sb , unsigned char * from , <S2SV_EndBug> <S2SV_StartBug> int fromlen , unsigned char * to ) <S2SV_EndBug> <S2SV_StartBug> unsigned char * p = to ; <S2SV_EndBug> <S2SV_StartBug> p = to ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( p , ""./"" , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> p += udf_get_filename ( sb , pc -> componentIdent , p , <S2SV_EndBug> <S2SV_StartBug> * p ++ = '/' ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> , int tolen <S2SV_ModStart> int comp_len ; <S2SV_ModStart> ; tolen -- <S2SV_ModStart> if ( tolen == 0 ) return - ENAMETOOLONG ; <S2SV_ModStart> tolen -- ; break ; case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ; <S2SV_ModEnd> <S2SV_ModStart> tolen -= 3 ; <S2SV_ModStart> if ( tolen < 2 ) return - ENAMETOOLONG ; <S2SV_ModStart> tolen -= 2 ; <S2SV_ModStart> comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ; p += comp_len ; tolen -= comp_len ; if ( tolen == 0 ) return - ENAMETOOLONG <S2SV_ModEnd> <S2SV_ModStart> ; tolen -- <S2SV_ModStart> return 0 ; "
1626,"<S2SV_StartBug> memset ( sax , 0 , sizeof ( sax ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> * 
1627,"<S2SV_StartBug> if ( is_authenticated ( req , res ) ) { <S2SV_EndBug> ","<S2SV_ModStart> set_header ( res , ""Set-Cookie"" , ""securitytoken=%s;<S2SV_blank>Max-Age=600;<S2SV_blank>HttpOnly;<S2SV_blank>SameSite=strict%s"" , res -> token , Run . httpd . flags & Httpd_Ssl ? "";<S2SV_blank>Secure"" : """" ) ; "
1628,"<S2SV_StartBug> xref -> entries = calloc ( 1 , xref -> n_entries * sizeof ( struct _xref_entry ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> safe_calloc ( <S2SV_ModEnd> 
1629,"<S2SV_StartBug> memory_length += extra_length - available_length + BLOCK_QUEUE ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( cp , qp -> d_memory , memory_length ) ; <S2SV_EndBug> ",<S2SV_ModStart> size_t original_length = memory_length ; <S2SV_ModStart> original_length <S2SV_ModEnd> 
1630,<S2SV_StartBug> || no_port_forwarding_flag || options . disable_forwarding ) { <S2SV_EndBug> ,<S2SV_ModStart> || ! use_privsep 
1631,"<S2SV_StartBug> baswap ( ( void * ) dst , & l2cap_pi ( sock -> sk ) -> chan -> dst ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! l2cap_is_socket ( sock ) ) return - EBADFD ; 
1632,<S2SV_StartBug> kret = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( sprinc == NULL ) return NULL 
1633,"<S2SV_StartBug> if ( dst_group && ! netlink_capable ( sock , NL_NONROOT_SEND ) ) <S2SV_EndBug> ",<S2SV_ModStart> ( dst_group || dst_pid ) <S2SV_ModEnd> 
1634,"<S2SV_StartBug> MB_PREDICTION_MODE vp9_above_block_mode ( const MODE_INFO * cur_mi , <S2SV_EndBug> ",<S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> 
1635,<S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ; <S2SV_EndBug> ,"<S2SV_ModStart> size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> alloc_size <S2SV_ModEnd> "
1636,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> return IMPEG2D_MB_TEX_DECODE_ERR ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , u4_sym_len ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } "
1637,<S2SV_StartBug> enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ; <S2SV_EndBug> <S2SV_StartBug> rs -> respond = respond ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; rs -> enc_tkt_reply = enc_tkt_reply 
1638,<S2SV_StartBug> image -> colorspace = RGBColorspace ; <S2SV_EndBug> ,"<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; break ; } "
1639,"<S2SV_StartBug> const int w = vpx_img_plane_width ( img , plane ) ; <S2SV_EndBug> ",<S2SV_ModStart> * ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) 
1640,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> u64 irq_time ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( rq -> skip_clock_update ) return <S2SV_ModStart>  <S2SV_ModEnd> 
1641,"<S2SV_StartBug> void ntlm_write_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> ",<S2SV_ModStart> static 
1642,"<S2SV_StartBug> skb = sock_alloc_send_skb ( sk , <S2SV_EndBug> <S2SV_StartBug> skb -> csum = 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> struct frag_hdr fhdr ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) <S2SV_ModEnd> "
1643,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1644,<S2SV_StartBug> Z_STRVAL_P ( return_value ) = emalloc ( length + 1 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d"" , INT_MAX ) ; RETURN_FALSE ; } "
1645,<S2SV_StartBug> inode_init_once ( & ei -> vfs_inode ) ; <S2SV_EndBug> ,<S2SV_ModStart> init_rwsem ( & ei -> i_mmap_sem ) ; 
1646,"<S2SV_StartBug> return __load_segment_descriptor ( ctxt , selector , seg , cpl , false ) ; <S2SV_EndBug> ","<S2SV_ModStart> , NULL "
1647,"<S2SV_StartBug> char * out = mutt_mem_malloc ( 3 * len / 4 + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> int dlen = mutt_b64_decode ( out , it ) ; <S2SV_EndBug> ","<S2SV_ModStart> const int olen = <S2SV_ModEnd> <S2SV_ModStart> ; char * out = mutt_mem_malloc ( olen <S2SV_ModStart> , olen "
1648,<S2SV_StartBug> struct VpxEncoderConfig * global ) { <S2SV_EndBug> <S2SV_StartBug> global -> codec -> fourcc ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , const struct VpxRational * pixel_aspect_ratio <S2SV_ModStart> , pixel_aspect_ratio "
1649,"<S2SV_StartBug> free_ep_req ( midi -> out_ep , req ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( req -> buf != NULL ) 
1650,<S2SV_StartBug> if ( ctx -> might_cancel ) { <S2SV_EndBug> <S2SV_StartBug> spin_lock ( & cancel_lock ) ; <S2SV_EndBug> <S2SV_StartBug> list_del_rcu ( & ctx -> clist ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock ( & cancel_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ctx -> <S2SV_ModStart> __timerfd_remove_cancel ( ctx <S2SV_ModEnd> <S2SV_ModStart> ctx -> <S2SV_ModStart>  <S2SV_ModEnd> 
1651,"<S2SV_StartBug> vmcs_write32 ( TPR_THRESHOLD , vmcs12 -> tpr_threshold ) ; <S2SV_EndBug> ",<S2SV_ModStart> } else { # ifdef CONFIG_X86_64 exec_control |= CPU_BASED_CR8_LOAD_EXITING | CPU_BASED_CR8_STORE_EXITING ; # endif 
1652,"<S2SV_StartBug> static void prob_diff_update ( const vp9_tree_index * tree , <S2SV_EndBug> <S2SV_StartBug> vp9_prob probs [ ] , <S2SV_EndBug> <S2SV_StartBug> int n , vp9_writer * w ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_tree_index <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_writer <S2SV_ModEnd> 
1653,<S2SV_StartBug> list_del ( & ti -> active_list ) ; <S2SV_EndBug> ,<S2SV_ModStart> list_del_init <S2SV_ModEnd> 
1654,<S2SV_StartBug> char * message = NULL ; <S2SV_EndBug> <S2SV_StartBug> char * language = NULL ; <S2SV_EndBug> <S2SV_StartBug> size_t reason = _libssh2_ntohu32 ( data + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> message = ( char * ) data + 9 ; <S2SV_EndBug> <S2SV_StartBug> language = ( char * ) data + 9 + message_len + 4 ; <S2SV_EndBug> <S2SV_StartBug> message_len = _libssh2_ntohu32 ( data + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> message = ( char * ) data + 6 ; <S2SV_EndBug> <S2SV_StartBug> language = ( char * ) data + 10 + message_len ; <S2SV_EndBug> <S2SV_StartBug> if ( datalen >= ( 6 + len ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> unsigned <S2SV_ModStart> unsigned <S2SV_ModStart> uint32_t reason = 0 ; struct string_buf buf ; buf . data = ( unsigned <S2SV_ModEnd> <S2SV_ModStart> ; buf . dataptr = buf . data ; buf . len = datalen ; buf . dataptr ++ ; _libssh2_get_u32 ( & buf , & reason ) ; _libssh2_get_string ( & buf , & message , & message_len ) ; _libssh2_get_string ( & buf , & language , & language_len ) ; if ( session -> ssh_msg_disconnect ) { LIBSSH2_DISCONNECT ( session , reason , ( const <S2SV_ModEnd> <S2SV_ModStart> message , message_len , ( const char * ) language , <S2SV_ModEnd> <S2SV_ModStart> struct string_buf buf ; buf . data = ( unsigned <S2SV_ModEnd> <S2SV_ModStart> ; buf . dataptr = buf . data ; buf . len = datalen ; buf . dataptr += 2 ; _libssh2_get_string ( & buf , & message , & message_len ) ; _libssh2_get_string ( & buf , & language , & language_len ) ; } if ( session -> ssh_msg_debug ) { LIBSSH2_DEBUG ( session , always_display , ( const <S2SV_ModEnd> <S2SV_ModStart> message , message_len , ( const char * ) <S2SV_ModEnd> <S2SV_ModStart> ( len <= ( UINT_MAX - 6 ) ) && ( <S2SV_ModStart> ) "
1655,<S2SV_StartBug> SvcInternal * const si = ( SvcInternal * ) svc_ctx -> internal ; <S2SV_EndBug> ,<S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> <S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> 
1656,"<S2SV_StartBug> in_what_stride , UINT_MAX ) <S2SV_EndBug> <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1657,"<S2SV_StartBug> static struct btrfs_dir_item * btrfs_match_dir_item_name ( struct btrfs_root * root , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1658,<S2SV_StartBug> return ms ; <S2SV_EndBug> ,<S2SV_ModStart> ms -> elf_notes_max = FILE_ELF_NOTES_MAX ; 
1659,"<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_lock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1660,<S2SV_StartBug> mflags = EXTRACT_LE_8BITS ( rhp -> rh_short . sh_flags ) ; <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK ( rhp -> rh_short . sh_flags ) ; 
1661,<S2SV_StartBug> png_structp p = ( png_structp ) png_ptr ; <S2SV_EndBug> <S2SV_StartBug> png_uint_32 save_flags = p -> flags ; <S2SV_EndBug> ,<S2SV_ModStart> ; png_uint_32 save_flags ; png_uint_32 num_bytes ; if ( png_ptr == NULL ) return ( NULL ) ; p <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1662,<S2SV_StartBug> pkt . kind = VPX_CODEC_STATS_PKT ; <S2SV_EndBug> ,<S2SV_ModStart> ( void ) cpi ; 
1663,"<S2SV_StartBug> if ( buf ) <S2SV_EndBug> <S2SV_StartBug> grub_memcpy ( buf , data + pos + real_offset , len ) ; <S2SV_EndBug> ",<S2SV_ModStart> { if ( pos + real_offset + len >= size ) { grub_errno = GRUB_ERR_BAD_FS ; return grub_errno ; } <S2SV_ModStart> } 
1664,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> msg -> msg_namelen = sizeof ( struct sockaddr_x25 ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * sx25 ) ; } <S2SV_ModEnd> 
1665,<S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( ! try_get_page ( page ) ) ) { spin_unlock ( ptl ) ; return ERR_PTR ( - ENOMEM ) ; } <S2SV_ModEnd> 
1666,"<S2SV_StartBug> if ( WARN ( irq >= nr_irqs , ""Invalid<S2SV_blank>irq<S2SV_blank>%d!\\n"" , irq ) ) <S2SV_EndBug> <S2SV_StartBug> return info_for_irq ( irq ) -> evtchn ; <S2SV_EndBug> ",<S2SV_ModStart> const struct irq_info * info = NULL ; if ( likely ( irq < nr_irqs ) ) info = info_for_irq ( irq ) ; if ( ! info <S2SV_ModEnd> <S2SV_ModStart> info <S2SV_ModEnd> 
1667,<S2SV_StartBug> bufp += bytes_read ; <S2SV_EndBug> ,<S2SV_ModStart> stripsize <S2SV_ModEnd> 
1668,"<S2SV_StartBug> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <S2SV_EndBug> ","<S2SV_ModStart> elems , e -> "
1669,<S2SV_StartBug> args -> rmtblkno = 0 ; <S2SV_EndBug> <S2SV_StartBug> args -> rmtblkcnt = 0 ; <S2SV_EndBug> <S2SV_StartBug> args -> rmtblkcnt = args -> rmtblkcnt2 ; <S2SV_EndBug> ,<S2SV_ModStart> rmtvaluelen2 = args -> rmtvaluelen ; args -> <S2SV_ModStart> = 0 ; args -> rmtvaluelen <S2SV_ModStart> ; args -> rmtvaluelen = args -> rmtvaluelen2 
1670,"<S2SV_StartBug> union sctp_addr_param * addr_param ; <S2SV_EndBug> <S2SV_StartBug> addr_param = ( union sctp_addr_param * ) hdr -> params ; <S2SV_EndBug> <S2SV_StartBug> ( sctp_paramhdr_t * ) ( ( void * ) addr_param + length ) , <S2SV_EndBug> ","<S2SV_ModStart> __u32 serial <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> chunk , true , <S2SV_ModEnd> "
1671,"<S2SV_StartBug> vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end ) { <S2SV_EndBug> <S2SV_StartBug> int mi_row , mi_col ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( cpi -> mb . e_mbd . left_seg_context ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> const TOKENEXTRA * const <S2SV_ModEnd> <S2SV_ModStart> const VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & cpi -> td . mb . e_mbd ; <S2SV_ModStart> ; set_partition_probs ( cm , xd ) <S2SV_ModStart> xd -> <S2SV_ModEnd> "
1672,<S2SV_StartBug> bucket = apr_bucket_eos_create ( r -> connection -> bucket_alloc ) ; <S2SV_EndBug> ,<S2SV_ModStart> apr_brigade_cleanup ( brigade ) ; 
1673,"<S2SV_StartBug> checkstackGC ( L , p -> maxstacksize + 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> luaD_checkstack <S2SV_ModEnd> 
1674,<S2SV_StartBug> const char * sender ; <S2SV_EndBug> <S2SV_StartBug> sd_bus_message_handler_t callback ; <S2SV_EndBug> <S2SV_StartBug> assert ( registry ) ; <S2SV_EndBug> ,"<S2SV_ModStart> int c ; # endif <S2SV_ModStart> int r ; assert ( call ) ; assert ( action ) ; assert ( registry ) ; r = check_good_user ( call , good_user ) ; if ( r != 0 ) return r ; # if ENABLE_POLKIT q = hashmap_get ( * registry , call ) ; if ( q ) { int authorized , challenge ; assert ( q -> reply ) ; if ( ! streq ( q -> action , action ) || ! strv_equal ( q -> details , ( char * * ) details ) ) return - ESTALE ; if ( sd_bus_message_is_method_error ( q -> reply , NULL ) ) { const sd_bus_error * e ; e = sd_bus_message_get_error ( q -> reply ) ; if ( sd_bus_error_has_name ( e , SD_BUS_ERROR_SERVICE_UNKNOWN ) || sd_bus_error_has_name ( e , SD_BUS_ERROR_NAME_HAS_NO_OWNER ) ) return - EACCES ; sd_bus_error_copy ( ret_error , e ) ; return - sd_bus_error_get_errno ( e ) ; } r = sd_bus_message_enter_container ( q -> reply , 'r' , ""bba{ss}"" ) ; if ( r >= 0 ) r = sd_bus_message_read ( q -> reply , ""bb"" , & authorized , & challenge ) ; if ( r < 0 ) return r ; if ( authorized ) return 1 ; if ( challenge ) return sd_bus_error_set ( ret_error , SD_BUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED , ""Interactive<S2SV_blank>authentication<S2SV_blank>required."" ) ; return - EACCES ; } # endif r = sd_bus_query_sender_privilege ( call , capability ) ; if ( r < 0 ) return r ; else if ( r > 0 ) return 1 ; sender = sd_bus_message_get_sender ( call ) ; if ( ! sender ) return - EBADMSG ; # if ENABLE_POLKIT c = sd_bus_message_get_allow_interactive_authorization ( call ) ; if ( c < 0 ) return c ; if ( c > 0 ) interactive = true ; r = hashmap_ensure_allocated ( registry , NULL ) ; if ( r < 0 ) return r ; r = sd_bus_message_new_method_call ( call -> bus , & pk , ""org.freedesktop.PolicyKit1"" , ""/org/freedesktop/PolicyKit1/Authority"" , ""org.freedesktop.PolicyKit1.Authority"" , ""CheckAuthorization"" ) ; if ( r < 0 ) return r ; r = sd_bus_message_append ( pk , ""(sa{sv})s"" , ""system-bus-name"" , 1 , ""name"" , ""s"" , sender , <S2SV_ModEnd> <S2SV_ModStart> if ( r < 0 ) return r ; r = bus_message_append_strv_key_value ( pk , details ) ; if ( r < 0 ) return r ; r = sd_bus_message_append ( pk , ""us"" , interactive , NULL ) ; if ( r < 0 ) return r ; q = new ( AsyncPolkitQuery , 1 ) ; if ( ! q ) return - ENOMEM ; * q = ( AsyncPolkitQuery ) { . request = sd_bus_message_ref ( call ) , } ; q -> action = strdup ( action ) ; if ( ! q -> action ) { async_polkit_query_free ( q ) ; return - ENOMEM ; } q -> details = strv_copy ( ( char * * ) details ) ; if ( ! q -> details ) { async_polkit_query_free ( q ) ; return - ENOMEM ; } r = hashmap_put ( * registry , call , q ) ; if ( r < 0 ) { async_polkit_query_free ( q ) ; return r ; } q -> registry = * registry ; r = sd_bus_call_async ( call -> bus , & q -> slot , pk , async_polkit_callback , q , 0 ) ; if ( r < 0 ) { async_polkit_query_free ( q ) ; return r ; } return 0 ; # endif <S2SV_ModEnd> "
1675,<S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> ,<S2SV_ModStart> ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> 
1676,"<S2SV_StartBug> if ( ( * ++ ptr == \'""\' ) && ( strchr ( & ptr [ 1 ] , \'""\' ) != NULL ) ) { <S2SV_EndBug> ",<S2SV_ModStart> strlen ( ptr ) > 2 ) && ( 
1677,<S2SV_StartBug> goto err_reprs_clean ; <S2SV_EndBug> <S2SV_StartBug> nfp_repr_free ( repr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( err ) { <S2SV_EndBug> <S2SV_StartBug> nfp_port_free ( port ) ; <S2SV_EndBug> ,<S2SV_ModStart> nfp_repr_free ( repr ) ; <S2SV_ModStart> kfree ( repr_priv ) ; <S2SV_ModStart> kfree ( repr_priv ) ; <S2SV_ModStart> kfree ( repr_priv ) ; 
1678,<S2SV_StartBug> proc = rqstp -> rq_procinfo ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( nfs_request_too_big ( rqstp , proc ) ) { dprintk ( ""nfsd:<S2SV_blank>NFSv%d<S2SV_blank>argument<S2SV_blank>too<S2SV_blank>large\\n"" , rqstp -> rq_vers ) ; * statp = rpc_garbage_args ; return 1 ; } "
1679,"<S2SV_StartBug> NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> GSTD_GSS_ERROR ( maj , min , NULL , ""gss_accept_sec_context"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; gss_release_buffer ( & min , & in <S2SV_ModStart> gss_release_buffer ( & min , & out ) ; "
1680,"<S2SV_StartBug> ( * respond ) ( arg , 0 , NULL , NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> ( * respond ) ( arg , 0 , NULL , NULL , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> EINVAL <S2SV_ModEnd> <S2SV_ModStart> EINVAL <S2SV_ModEnd> 
1681,<S2SV_StartBug> struct twopass_rc * const twopass = & svc -> layer_context [ i ] . twopass ; <S2SV_EndBug> ,<S2SV_ModStart> TWO_PASS <S2SV_ModEnd> 
1682,<S2SV_StartBug> while ( peek ( s ) != '>' && ! eol ( s ) ) <S2SV_EndBug> ,<S2SV_ModStart> && ! eof ( s ) 
1683,"<S2SV_StartBug> avio_skip ( pb , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> sscanf ( val , ""%"" SCNu32 ""%"" SCNu32 ""%"" SCNu32 ""%"" SCNu32 , <S2SV_EndBug> <S2SV_StartBug> for ( idx = 0 ; idx < 4 ; idx ++ ) { <S2SV_EndBug> ",<S2SV_ModStart> int ret ; <S2SV_ModStart> ret = <S2SV_ModStart> if ( ret != 4 ) return AVERROR_INVALIDDATA ; 
1684,"<S2SV_StartBug> if ( drop_privileges ( nagios_user , nagios_group ) == ERROR ) { <S2SV_EndBug> <S2SV_StartBug> exit ( EXIT_FAILURE ) ; <S2SV_EndBug> ","<S2SV_ModStart> daemon_mode == TRUE && sigrestart == FALSE ) { result = daemon_init ( ) ; if ( result == ERROR ) { logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , ""Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)"" , ( int ) getpid ( ) ) ; cleanup ( ) ; exit ( EXIT_FAILURE ) ; } nagios_pid = ( int ) getpid ( ) ; } if ( <S2SV_ModStart>  <S2SV_ModEnd> "
1685,<S2SV_StartBug> if ( REMAIN > INT_MAX ) <S2SV_EndBug> ,<S2SV_ModStart> == 0 || REMAIN 
1686,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> check_stack_depth ( ) ; 
1687,"<S2SV_StartBug> vma = find_vma_prev ( mm , start , & prev ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! mmget_still_valid ( mm ) ) goto out_unlock ; 
1688,"<S2SV_StartBug> vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; memset <S2SV_ModEnd> <S2SV_ModStart> memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; memset <S2SV_ModEnd> <S2SV_ModStart> memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; memset <S2SV_ModEnd> "
1689,"<S2SV_StartBug> struct dentry * dir = nd -> path . dentry ; <S2SV_EndBug> <S2SV_StartBug> error = may_create_in_sticky ( dir , <S2SV_EndBug> ","<S2SV_ModStart> ; kuid_t dir_uid = dir -> d_inode -> i_uid ; umode_t dir_mode = dir -> d_inode -> i_mode <S2SV_ModStart> dir_mode , dir_uid <S2SV_ModEnd> "
1690,"<S2SV_StartBug> static vpx_codec_err_t vp8e_set_previewpp ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> <S2SV_StartBug> vp8_postproc_cfg_t * data = va_arg ( args , vp8_postproc_cfg_t * ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) ctr_id ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1691,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( clk_src ) ; 
1692,<S2SV_StartBug> args -> skippable [ 0 ] &= ( ! args -> x -> plane [ plane ] . eobs [ block ] ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( void ) plane ; ( void ) plane_bsize ; ( void ) tx_size ; <S2SV_ModStart>  <S2SV_ModEnd> 
1693,<S2SV_StartBug> int nAlloc = ( pIn ? pIn [ 0 ] * 2 : 10 ) + nInt ; <S2SV_EndBug> ,<S2SV_ModStart> sqlite3_int64 <S2SV_ModEnd> <S2SV_ModStart> 2 * ( sqlite3_int64 ) pIn [ 0 ] <S2SV_ModEnd> 
1694,"<S2SV_StartBug> if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> <S2SV_StartBug> l_row -- ; <S2SV_EndBug> ",<S2SV_ModStart> 3 == <S2SV_ModStart> && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> <S2SV_ModStart> LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ; 
1695,<S2SV_StartBug> if ( * s == '#' ) { <S2SV_EndBug> <S2SV_StartBug> if ( * s == 'x' || * s == 'X' ) { <S2SV_EndBug> <S2SV_StartBug> while ( * s ) { <S2SV_EndBug> <S2SV_StartBug> while ( isDIGIT ( * s ) ) { <S2SV_EndBug> <S2SV_StartBug> while ( isALNUM ( * s ) ) <S2SV_EndBug> <S2SV_StartBug> if ( * s == ';' ) <S2SV_EndBug> ,<S2SV_ModStart> s < end && <S2SV_ModStart> ( s < end && <S2SV_ModStart> ) <S2SV_ModStart> s < end <S2SV_ModEnd> <S2SV_ModStart> s < end && <S2SV_ModStart> s < end && <S2SV_ModStart> s < end && 
1696,"<S2SV_StartBug> node * n = Ta3Parser_ParseStringObject ( s , filename , <S2SV_EndBug> ",<S2SV_ModStart> n ; if ( feature_version >= 7 ) iflags |= PyPARSE_ASYNC_ALWAYS ; 
1697,"<S2SV_StartBug> int openasuser ; <S2SV_EndBug> <S2SV_StartBug> int should_free_authpending_file = 0 ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , authfile_dir_len , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> cfg -> auth_file = buf ; <S2SV_EndBug> <S2SV_StartBug> openasuser = geteuid ( ) == 0 && cfg -> openasuser ; <S2SV_EndBug> <S2SV_StartBug> if ( openasuser ) { <S2SV_EndBug> <S2SV_StartBug> if ( seteuid ( pw_s . pw_uid ) ) { <S2SV_EndBug> <S2SV_StartBug> DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; <S2SV_EndBug> <S2SV_StartBug> DBG ( ""Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; <S2SV_EndBug> <S2SV_StartBug> if ( seteuid ( 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> DBG ( ""Switched<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> = 0 <S2SV_ModStart> ; PAM_MODUTIL_DEF_PRIVS ( privs ) <S2SV_ModStart> openasuser = geteuid ( ) == 0 ? 1 : 0 ; <S2SV_ModStart> if ( ! openasuser ) { DBG ( ""WARNING:<S2SV_blank>not<S2SV_blank>dropping<S2SV_blank>privileges<S2SV_blank>when<S2SV_blank>reading<S2SV_blank>%s,<S2SV_blank>please<S2SV_blank>"" ""consider<S2SV_blank>setting<S2SV_blank>openasuser=1<S2SV_blank>in<S2SV_blank>the<S2SV_blank>module<S2SV_blank>configuration"" <S2SV_ModEnd> <S2SV_ModStart> } } DBG ( ""Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , buf ) ; <S2SV_ModStart> if ( ! openasuser ) { openasuser <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> DBG ( ""Dropping<S2SV_blank>privileges"" ) ; if ( pam_modutil_drop_priv ( pamh , & privs , pw <S2SV_ModEnd> <S2SV_ModStart> pw -> <S2SV_ModEnd> <S2SV_ModStart> pw -> <S2SV_ModEnd> <S2SV_ModStart> pam_modutil_regain_priv ( pamh , & privs ) ) { DBG ( ""could<S2SV_blank>not<S2SV_blank>restore<S2SV_blank>privileges"" <S2SV_ModEnd> <S2SV_ModStart> ""Restored<S2SV_blank>privileges"" <S2SV_ModEnd> "
1698,<S2SV_StartBug> if ( item_num > 65536 ) { <S2SV_EndBug> ,<S2SV_ModStart> || item_num < 0 
1699,<S2SV_StartBug> for ( ( pad = w % 4 ) ? ( 4 - w % 4 ) : 0 ; pad > 0 ; pad -- ) <S2SV_EndBug> ,<S2SV_ModStart> pad = ( <S2SV_ModEnd> 
1700,"<S2SV_StartBug> OPJ_UINT32 x , y ; <S2SV_EndBug> <S2SV_StartBug> x = y = 0U ; <S2SV_EndBug> <S2SV_StartBug> * pix = c1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> return OPJ_TRUE ; <S2SV_EndBug> ","<S2SV_ModStart> , written <S2SV_ModStart> written = <S2SV_ModStart> ; written ++ <S2SV_ModStart> written ++ ; <S2SV_ModStart> if ( written != width * height ) { fprintf ( stderr , ""warning,<S2SV_blank>image\'s<S2SV_blank>actual<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>advertized<S2SV_blank>one\\n"" ) ; return OPJ_FALSE ; } "
1701,"<S2SV_StartBug> id = ipc_addid ( & msg_ids ( ns ) , & msq -> q_perm , ns -> msg_ctlmni ) ; <S2SV_EndBug> <S2SV_StartBug> msq -> q_stime = msq -> q_rtime = 0 ; <S2SV_EndBug> ",<S2SV_ModStart> msq -> q_stime = msq -> q_rtime = 0 ; msq -> q_ctime = get_seconds ( ) ; msq -> q_cbytes = msq -> q_qnum = 0 ; msq -> q_qbytes = ns -> msg_ctlmnb ; msq -> q_lspid = msq -> q_lrpid = 0 ; INIT_LIST_HEAD ( & msq -> q_messages ) ; INIT_LIST_HEAD ( & msq -> q_receivers ) ; INIT_LIST_HEAD ( & msq -> q_senders ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
1702,"<S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , filter == SWITCHABLE ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , filter_to_literal [ filter ] , 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> 
1703,"<S2SV_StartBug> static void read_switchable_interp_probs ( FRAME_CONTEXT * fc , vp9_reader * r ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> 
1704,"<S2SV_StartBug> JAS_DBGLOG ( 101 , ( ""jas_malloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%zu\\n"" , size ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""jas_malloc(%zu)\\n"" <S2SV_ModEnd> "
1705,<S2SV_StartBug> return ret <= 0 ? ret : - EIO ; <S2SV_EndBug> ,<S2SV_ModStart> < <S2SV_ModEnd> 
