,cwe_id,source,target,project_and_commit_id,cve_id,original_address,time
0,CWE-119,"<S2SV_StartBug> if ( ! nonce1 ) { <S2SV_EndBug> <S2SV_StartBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> <S2SV_StartBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> valid_hex ( nonce1 ) <S2SV_ModEnd> <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" <S2SV_ModEnd> <S2SV_ModStart> n2size < 2 || n2size > 16 <S2SV_ModEnd> <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" <S2SV_ModEnd> ",sgminer-dev@sgminer/e1c5050734123973b99d181c45e74b2cbb00272e,CVE-2014-4502,https://github.com/sgminer-dev/sgminer/commit/e1c5050734123973b99d181c45e74b2cbb00272e,2014-07-23T14:55Z
1,CWE-125,"<S2SV_StartBug> type = * ( tptr ) ; <S2SV_EndBug> <S2SV_StartBug> subtype = * ( tptr + 4 ) ; <S2SV_EndBug> <S2SV_StartBug> tok2str ( eap_type_values , ""unknown"" , * ( tptr + 4 ) ) , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" , <S2SV_EndBug> <S2SV_StartBug> case EAP_TYPE_TLS : <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , <S2SV_EndBug> ","<S2SV_ModStart> ND_TCHECK_8BITS ( tptr ) ; <S2SV_ModStart> ) ; ND_TCHECK_16BITS ( tptr + 2 <S2SV_ModStart> ND_TCHECK_8BITS ( tptr + 4 ) ; <S2SV_ModStart> subtype ) , subtype <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_8BITS ( tptr + count ) ; <S2SV_ModStart> case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ; if ( subtype == EAP_TYPE_TTLS ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> ND_TCHECK_8BITS ( tptr + 5 ) ; <S2SV_ModStart> ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> ND_TCHECK_8BITS ( tptr + 5 ) ; ",the-tcpdump-group@tcpdump/985122081165753c7442bd7824c473eb9ff56308,CVE-2017-13015,https://github.com/the-tcpdump-group/tcpdump/commit/985122081165753c7442bd7824c473eb9ff56308,2017-09-14T06:29Z
2,CWE-401,<S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug> ,<S2SV_ModStart> kfree_skb ( skb ) ; ,torvalds@linux/728c1e2a05e4b5fc52fab3421dce772a806612a2,CVE-2019-19074,https://github.com/torvalds/linux/commit/728c1e2a05e4b5fc52fab3421dce772a806612a2,2019-11-18T06:15Z
3,CWE-399,<S2SV_StartBug> yi . cfg . mask = 0xffffffff ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & yi , 0 , sizeof ( yi ) ) ; ",torvalds@linux/8e3fbf870481eb53b2d3a322d1fc395ad8b367ed,CVE-2014-1446,https://github.com/torvalds/linux/commit/8e3fbf870481eb53b2d3a322d1fc395ad8b367ed,2014-01-18T22:55Z
4,CWE-189,<S2SV_StartBug> if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) { <S2SV_EndBug> ,<S2SV_ModStart> skb -> mac_header <S2SV_ModEnd> ,torvalds@linux/0e033e04c2678dbbe74a46b23fffb7bb918c288e,CVE-2013-4563,https://github.com/torvalds/linux/commit/0e033e04c2678dbbe74a46b23fffb7bb918c288e,2013-11-20T13:19Z
5,CWE-834,"<S2SV_StartBug> int64_t time , offset ; <S2SV_EndBug> ",<S2SV_ModStart> if ( avio_feof ( f ) ) { index -> item_count = 0 ; av_freep ( & index -> items ) ; return AVERROR_INVALIDDATA ; } ,FFmpeg@FFmpeg/9cb4eb772839c5e1de2855d126bf74ff16d13382,CVE-2017-14222,https://github.com/FFmpeg/FFmpeg/commit/9cb4eb772839c5e1de2855d126bf74ff16d13382,2017-09-09T01:29Z
6,CWE-119,"<S2SV_StartBug> unsigned long tpgt ; <S2SV_EndBug> <S2SV_StartBug> if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) <S2SV_EndBug> ",<S2SV_ModStart> u16 <S2SV_ModEnd> <S2SV_ModStart> kstrtou16 <S2SV_ModEnd> <S2SV_ModStart> >= VHOST_SCSI_MAX_TARGET <S2SV_ModEnd> ,torvalds@linux/59c816c1f24df0204e01851431d3bab3eb76719c,CVE-2015-4036,https://github.com/torvalds/linux/commit/59c816c1f24df0204e01851431d3bab3eb76719c,2015-08-31T20:59Z
7,CWE-416,"<S2SV_StartBug> TrackWriter * writer = ( TrackWriter * ) gf_list_get ( writers , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stco ) ; gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stsc ",gpac@gpac/5aba27604d957e960d8069d85ccaf868f8a7b07a,CVE-2020-35980,https://github.com/gpac/gpac/commit/5aba27604d957e960d8069d85ccaf868f8a7b07a,2021-04-21T16:15Z
8,CWE-20,<S2SV_StartBug> u32 data ; <S2SV_EndBug> <S2SV_StartBug> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> kvm_read_guest_cached ( vcpu -> kvm , & <S2SV_ModEnd> <S2SV_ModStart> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> ",torvalds@linux/fda4e2e85589191b123d31cdc21fd33ee70f50fd,CVE-2013-6368,https://github.com/torvalds/linux/commit/fda4e2e85589191b123d31cdc21fd33ee70f50fd,2013-12-14T18:08Z
9,CWE-20,<S2SV_StartBug> * dst = * src ; <S2SV_EndBug> ,<S2SV_ModStart> __switch_to_tm ( src ) ; tm_recheckpoint_new_task ( src ) ; ,torvalds@linux/621b5060e823301d0cba4cb52a7ee3491922d291,CVE-2014-2673,https://github.com/torvalds/linux/commit/621b5060e823301d0cba4cb52a7ee3491922d291,2014-04-01T06:35Z
10,CWE-119,<S2SV_StartBug> cJSON * c = array -> child ; <S2SV_EndBug> <S2SV_StartBug> while ( c && item > 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> ? array -> child : 0 <S2SV_ModEnd> <S2SV_ModStart> item -- , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
11,CWE-20,"<S2SV_StartBug> ext3_msg ( sb , ""error:<S2SV_blank>invalid<S2SV_blank>sb<S2SV_blank>specification:<S2SV_blank>%s"" , <S2SV_EndBug> ","<S2SV_ModStart> KERN_ERR , ",torvalds@linux/8d0c2d10dd72c5292eda7a06231056a4c972e4cc,CVE-2013-1848,https://github.com/torvalds/linux/commit/8d0c2d10dd72c5292eda7a06231056a4c972e4cc,2013-03-22T11:59Z
12,CWE-000,<S2SV_StartBug> ipv6_select_ident ( fptr ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , ( struct rt6_info * ) skb_dst ( skb ) ",torvalds@linux/87c48fa3b4630905f98268dde838ee43626a060c,CVE-2011-2699,https://github.com/torvalds/linux/commit/87c48fa3b4630905f98268dde838ee43626a060c,2012-05-24T23:55Z
13,CWE-400,"<S2SV_StartBug> void __perf_sw_event ( u32 event_id , u64 nr , int nmi , <S2SV_EndBug> <S2SV_StartBug> do_perf_sw_event ( PERF_TYPE_SOFTWARE , event_id , nr , nmi , & data , regs ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
14,CWE-119,"<S2SV_StartBug> # ifndef _MSC_VER <S2SV_EndBug> <S2SV_StartBug> char buf [ EXT2_BLOCK_SIZE ( data ) ] ; <S2SV_EndBug> <S2SV_StartBug> grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> return fileblock + start ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! indir ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> if ( ! indir ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> ",<S2SV_ModStart> char * buf = grub_malloc ( <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( ! buf ) { return - 1 ; } <S2SV_ModEnd> <S2SV_ModStart> ) ; free ( buf <S2SV_ModStart> { free ( buf ) ; <S2SV_ModStart> } <S2SV_ModStart> free ( buf ) ; <S2SV_ModStart> free ( buf ) ; <S2SV_ModStart> free ( buf ) ; <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } ,radare@radare2/65000a7fd9eea62359e6d6714f17b94a99a82edd,CVE-2017-9763,https://github.com/radare/radare2/commit/65000a7fd9eea62359e6d6714f17b94a99a82edd,2017-06-19T16:29Z
15,CWE-119,"<S2SV_StartBug> static void fdct16 ( const int16_t in [ 16 ] , int16_t out [ 16 ] ) { <S2SV_EndBug> <S2SV_StartBug> int step1 [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int step2 [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int step3 [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int input [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int temp1 , temp2 ; <S2SV_EndBug> <S2SV_StartBug> int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; <S2SV_EndBug> <S2SV_StartBug> int t0 , t1 , t2 , t3 ; <S2SV_EndBug> <S2SV_StartBug> int x0 , x1 , x2 , x3 ; <S2SV_EndBug> <S2SV_StartBug> out [ 0 ] = fdct_round_shift ( t0 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 4 ] = fdct_round_shift ( t2 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 8 ] = fdct_round_shift ( t1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 12 ] = fdct_round_shift ( t3 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 2 ] = fdct_round_shift ( t0 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 6 ] = fdct_round_shift ( t2 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 10 ] = fdct_round_shift ( t1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 14 ] = fdct_round_shift ( t3 ) ; <S2SV_EndBug> <S2SV_StartBug> temp2 = step3 [ 2 ] * - cospi_24_64 - step3 [ 5 ] * cospi_8_64 ; <S2SV_EndBug> <S2SV_StartBug> temp1 = step3 [ 2 ] * - cospi_8_64 + step3 [ 5 ] * cospi_24_64 ; <S2SV_EndBug> <S2SV_StartBug> step1 [ 2 ] = step3 [ 3 ] - step2 [ 2 ] ; <S2SV_EndBug> <S2SV_StartBug> out [ 1 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 9 ] = fdct_round_shift ( temp2 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 5 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 13 ] = fdct_round_shift ( temp2 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 3 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 11 ] = fdct_round_shift ( temp2 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 7 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 15 ] = fdct_round_shift ( temp2 ) ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> cospi_24_64 + <S2SV_ModEnd> <S2SV_ModStart> cospi_8_64 - <S2SV_ModEnd> <S2SV_ModStart> + step2 [ 2 ] ; step1 [ 3 ] = step3 [ 3 ] - step2 [ 2 ] ; step1 [ 4 ] = step3 [ 4 ] - step2 [ 5 ] ; step1 [ 5 ] = step3 [ 4 ] + <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
16,CWE-20,<S2SV_StartBug> ret = convert_ctx_accesses ( env ) ; <S2SV_EndBug> ,<S2SV_ModStart> sanitize_dead_code ( env ) ; if ( ret == 0 ) ,torvalds@linux/c131187db2d3fa2f8bf32fdf4e9a4ef805168467,CVE-2017-17862,https://github.com/torvalds/linux/commit/c131187db2d3fa2f8bf32fdf4e9a4ef805168467,2017-12-27T17:08Z
17,CWE-835,<S2SV_StartBug> int i ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! config -> sample_rate ) { strcpy ( wpc -> error_message , ""sample<S2SV_blank>rate<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>zero!"" ) ; return FALSE ; } ",dbry@WavPack/070ef6f138956d9ea9612e69586152339dbefe51,CVE-2018-19840,https://github.com/dbry/WavPack/commit/070ef6f138956d9ea9612e69586152339dbefe51,2018-12-04T09:29Z
18,CWE-787,"<S2SV_StartBug> SDev = cd -> device ; <S2SV_EndBug> <S2SV_StartBug> ( unsigned char * ) cgc -> sense , & sshdr , <S2SV_EndBug> ","<S2SV_ModStart> unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ; <S2SV_ModStart> ; if ( cgc -> sense ) senseptr = sense_buffer <S2SV_ModStart> senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( cgc -> sense ) memcpy ( cgc -> sense , sense_buffer , sizeof ( * <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> ",torvalds@linux/f7068114d45ec55996b9040e98111afa56e010fe,CVE-2018-11506,https://github.com/torvalds/linux/commit/f7068114d45ec55996b9040e98111afa56e010fe,2018-05-28T04:29Z
19,CWE-119,<S2SV_StartBug> if ( get4 ( ) == 0x48454150 ) <S2SV_EndBug> <S2SV_StartBug> imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_FixedLens ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && ( save + hlen ) >= 0 && ( save + hlen ) <= ifp -> size ( ) # endif ) { # ifdef LIBRAW_LIBRARY_BUILD ,LibRaw@LibRaw/d7c3d2cb460be10a3ea7b32e9443a83c243b2251,CVE-2017-6887,https://github.com/LibRaw/LibRaw/commit/d7c3d2cb460be10a3ea7b32e9443a83c243b2251,2017-05-16T16:29Z
20,CWE-119,"<S2SV_StartBug> static void search_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi , <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> struct loopfilter * const lf = & cm -> lf ; <S2SV_EndBug> <S2SV_StartBug> int best_err ; <S2SV_EndBug> <S2SV_StartBug> int filt_direction = 0 ; <S2SV_EndBug> <S2SV_StartBug> int ss_err [ MAX_LOOP_FILTER + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ss_err , 0xFF , sizeof ( ss_err ) ) ; <S2SV_EndBug> <S2SV_StartBug> int filt_err ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> twopass . section_intra_rating < 20 ) <S2SV_EndBug> <S2SV_StartBug> bias = bias * cpi -> twopass . section_intra_rating / 20 ; <S2SV_EndBug> <S2SV_StartBug> filt_err = try_filter_frame ( sd , cpi , filt_low , partial_frame ) ; <S2SV_EndBug> <S2SV_StartBug> ss_err [ filt_low ] = filt_err ; <S2SV_EndBug> <S2SV_StartBug> if ( filt_err < best_err ) <S2SV_EndBug> <S2SV_StartBug> filt_err = try_filter_frame ( sd , cpi , filt_high , partial_frame ) ; <S2SV_EndBug> <S2SV_StartBug> ss_err [ filt_high ] = filt_err ; <S2SV_EndBug> <S2SV_StartBug> best_err = filt_err ; <S2SV_EndBug> <S2SV_StartBug> lf -> filter_level = filt_best ; <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> const <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; int64_t best_err ; int filt_best <S2SV_ModStart> int64_t <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> int64_t <S2SV_ModEnd> <S2SV_ModStart> ( ( cpi -> oxcf . pass == 2 ) && <S2SV_ModStart> ) bias = ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> ss_err [ filt_low ] <S2SV_ModEnd> <S2SV_ModStart> } if ( ( ss_err [ filt_low ] <S2SV_ModEnd> <S2SV_ModStart> ss_err [ filt_low ] < best_err ) best_err = ss_err [ filt_low ] <S2SV_ModEnd> <S2SV_ModStart> ss_err [ filt_high ] <S2SV_ModEnd> <S2SV_ModStart> } if ( ss_err [ filt_high ] <S2SV_ModEnd> <S2SV_ModStart> ss_err [ filt_high ] <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
21,CWE-787,"<S2SV_StartBug> lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ; <S2SV_EndBug> ","<S2SV_ModStart> luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_unpack_full"" ) ; ",antirez@redis/5ccb6f7a791bf3490357b00a898885759d98bab0,CVE-2018-11218,https://github.com/antirez/redis/commit/5ccb6f7a791bf3490357b00a898885759d98bab0,2018-06-17T17:29Z
22,CWE-119,"<S2SV_StartBug> static void encode_mv_component ( vp9_writer * w , int comp , <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , sign , mvcomp -> sign ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , hp , <S2SV_EndBug> ",<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
23,CWE-476,<S2SV_StartBug> return alg -> cra_rng . rng_make_random ? <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,CVE-2017-15116,https://github.com/torvalds/linux/commit/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,2017-11-30T18:29Z
24,CWE-200,<S2SV_StartBug> if ( sp -> sa_protocol != PX_PROTO_PPTP ) <S2SV_EndBug> ,<S2SV_ModStart> sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ; if ( ,torvalds@linux/09ccfd238e5a0e670d8178cf50180ea81ae09ae1,CVE-2015-8569,https://github.com/torvalds/linux/commit/09ccfd238e5a0e670d8178cf50180ea81ae09ae1,2015-12-28T11:59Z
25,CWE-20,<S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_16 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 32 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_32 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 64 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_64 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 128 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_128 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 256 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_256 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 512 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_512 ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_1024 ; <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = coapClientGetMaxBlockSize ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } ,Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
26,CWE-476,"<S2SV_StartBug> char * fmtname ; <S2SV_EndBug> <S2SV_StartBug> while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> case OPT_INFILE : <S2SV_EndBug> <S2SV_StartBug> if ( infile ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ; int debug <S2SV_ModStart> debug = 0 ; <S2SV_ModStart> OPT_DEBUG : debug = atoi ( jas_optarg ) ; break ; case <S2SV_ModStart> jas_setdbglevel ( debug ) ; <S2SV_ModStart> jas_stream_close ( instream ) ; ,mdadams@jasper/8f62b4761711d036fd8964df256b938c809b7fca,CVE-2016-8690,https://github.com/mdadams/jasper/commit/8f62b4761711d036fd8964df256b938c809b7fca,2017-02-15T19:59Z
27,CWE-000,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> siginfo_t info ; void __user * pc = ( void __user * ) instruction_pointer ( regs ) ; <S2SV_ModStart> __show_regs ( regs ) ; info . si_signo = SIGILL ; info . si_errno = 0 ; info . si_code = ILL_ILLOPC ; info . si_addr = pc ; arm64_notify_die <S2SV_ModEnd> <S2SV_ModStart> & info , 0 <S2SV_ModEnd> ",torvalds@linux/9955ac47f4ba1c95ecb6092aeaefb40a22e99268,CVE-2013-4220,https://github.com/torvalds/linux/commit/9955ac47f4ba1c95ecb6092aeaefb40a22e99268,2013-08-25T03:27Z
28,CWE-125,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x,<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> ""Direction-#%u"" , * ( ( const u_char * ) ptr ++ ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( length > 5 ) { <S2SV_EndBug> <S2SV_StartBug> print_string ( ndo , ( const u_char * ) ptr , length - 5 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( length < 5 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModStart> dat <S2SV_ModEnd> <S2SV_ModStart> dat += 2 ; length -= 2 <S2SV_ModEnd> <S2SV_ModStart> dat <S2SV_ModEnd> <S2SV_ModStart> dat += 2 ; length -= 2 <S2SV_ModEnd> <S2SV_ModStart> EXTRACT_8BITS ( ptr <S2SV_ModEnd> <S2SV_ModStart> ptr ++ ; length -- ; <S2SV_ModStart> != 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z
29,CWE-125,"<S2SV_StartBug> int alt ; <S2SV_EndBug> <S2SV_StartBug> if ( alt < 0 ) <S2SV_EndBug> <S2SV_StartBug> intf -> altsetting [ 0 ] . desc . bInterfaceNumber , alt ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct usb_host_interface * <S2SV_ModEnd> <S2SV_ModStart> ! alt ) return - ENODEV <S2SV_ModEnd> <S2SV_ModStart> alt -> <S2SV_ModEnd> <S2SV_ModStart> -> desc . bAlternateSetting ,torvalds@linux/786de92b3cb26012d3d0f00ee37adf14527f35c4,CVE-2017-16530,https://github.com/torvalds/linux/commit/786de92b3cb26012d3d0f00ee37adf14527f35c4,2017-11-04T01:29Z
30,CWE-17,"<S2SV_StartBug> static void udf_pc_to_char ( struct super_block * sb , unsigned char * from , <S2SV_EndBug> <S2SV_StartBug> int fromlen , unsigned char * to ) <S2SV_EndBug> <S2SV_StartBug> unsigned char * p = to ; <S2SV_EndBug> <S2SV_StartBug> p = to ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( p , ""./"" , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> p += udf_get_filename ( sb , pc -> componentIdent , p , <S2SV_EndBug> <S2SV_StartBug> * p ++ = '/' ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> , int tolen <S2SV_ModStart> int comp_len ; <S2SV_ModStart> ; tolen -- <S2SV_ModStart> if ( tolen == 0 ) return - ENAMETOOLONG ; <S2SV_ModStart> tolen -- ; break ; case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ; <S2SV_ModEnd> <S2SV_ModStart> tolen -= 3 ; <S2SV_ModStart> if ( tolen < 2 ) return - ENAMETOOLONG ; <S2SV_ModStart> tolen -= 2 ; <S2SV_ModStart> comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ; p += comp_len ; tolen -= comp_len ; if ( tolen == 0 ) return - ENAMETOOLONG <S2SV_ModEnd> <S2SV_ModStart> ; tolen -- <S2SV_ModStart> return 0 ; ",torvalds@linux/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,CVE-2014-9731,https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,2015-08-31T10:59Z
31,CWE-119,<S2SV_StartBug> if ( class == - 1 ) { <S2SV_EndBug> ,"<S2SV_ModStart> || class == CLIENT_TYPE_MASTER ) { err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class:<S2SV_blank>the<S2SV_blank>user<S2SV_blank>specified<S2SV_blank>"" ""an<S2SV_blank>invalid<S2SV_blank>one,<S2SV_blank>or<S2SV_blank>\'master\'<S2SV_blank>which<S2SV_blank>has<S2SV_blank>no<S2SV_blank>buffer<S2SV_blank>limits."" <S2SV_ModEnd> ",antirez@redis/6d9f8e2462fc2c426d48c941edeb78e5df7d2977,CVE-2016-8339,https://github.com/antirez/redis/commit/6d9f8e2462fc2c426d48c941edeb78e5df7d2977,2016-10-28T14:59Z
32,CWE-119,<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( qid > NVMET_NR_QUEUES ) return NULL ,torvalds@linux/0c319d3a144d4b8f1ea2047fd614d2149b68f889,CVE-2017-18379,https://github.com/torvalds/linux/commit/0c319d3a144d4b8f1ea2047fd614d2149b68f889,2019-07-27T22:15Z
33,CWE-476,"<S2SV_StartBug> usb_set_intfdata ( interface , dev ) ; <S2SV_EndBug> <S2SV_StartBug> exit : <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> usb_set_intfdata ( interface , dev ) ; retval = usb_register_dev ( interface , & tower_class ) ; if ( retval ) { dev_err ( idev , ""Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\n"" ) ; usb_set_intfdata ( interface , NULL ) ; goto error ; } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>"" ""%d<S2SV_blank>minor<S2SV_blank>%d\\n"" , ( dev -> minor - LEGO_USB_TOWER_MINOR_BASE ) , USB_MAJOR , dev -> minor ) ; ",torvalds@linux/2fae9e5a7babada041e2e161699ade2447a01989,CVE-2017-15102,https://github.com/torvalds/linux/commit/2fae9e5a7babada041e2e161699ade2447a01989,2017-11-15T21:29Z
34,CWE-476,<S2SV_StartBug> if ( vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux ) { <S2SV_EndBug> ,<S2SV_ModStart> vstart + vdaux < vstart <S2SV_ModEnd> ,radare@radare2/d21e91f075a7a7a8ed23baa5c1bb1fac48313882,CVE-2017-16359,https://github.com/radare/radare2/commit/d21e91f075a7a7a8ed23baa5c1bb1fac48313882,2017-11-01T17:29Z
35,CWE-862,"<S2SV_StartBug> static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <S2SV_EndBug> <S2SV_StartBug> kenter ( ""%p"" , dest_keyring ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int ret ; <S2SV_ModStart> bool do_perm_check = true ; <S2SV_ModStart> { do_perm_check = false ; break ; } <S2SV_ModEnd> <S2SV_ModStart> if ( dest_keyring && do_perm_check ) { ret = key_permission ( make_key_ref ( dest_keyring , 1 ) , KEY_NEED_WRITE ) ; if ( ret ) { key_put ( dest_keyring ) ; return ret ; } } <S2SV_ModStart> 0 ",torvalds@linux/4dca6ea1d9432052afb06baf2e3ae78188a4410b,CVE-2017-17807,https://github.com/torvalds/linux/commit/4dca6ea1d9432052afb06baf2e3ae78188a4410b,2017-12-20T23:29Z
36,CWE-763,<S2SV_StartBug> sc = create_spnego_ctx ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> 1 ,krb5@krb5/b51b33f2bc5d1497ddf5bd107f791c101695000d,CVE-2015-2695,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,2015-11-09T03:59Z
37,CWE-416,"<S2SV_StartBug> if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) <S2SV_EndBug> <S2SV_StartBug> if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) <S2SV_EndBug> <S2SV_StartBug> if ( addr -> l2tp_family != AF_INET ) <S2SV_EndBug> <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ","<S2SV_ModStart> addr_len < sizeof ( struct sockaddr_l2tpip <S2SV_ModEnd> <S2SV_ModStart> addr -> l2tp_family != AF_INET <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out ",torvalds@linux/32c231164b762dddefa13af5a0101032c70b50ef,CVE-2016-10200,https://github.com/torvalds/linux/commit/32c231164b762dddefa13af5a0101032c70b50ef,2017-03-07T21:59Z
38,CWE-264,<S2SV_StartBug> static unsigned int stack_maxrandom_size ( void ) <S2SV_EndBug> <S2SV_StartBug> unsigned int max = 0 ; <S2SV_EndBug> <S2SV_StartBug> max = ( ( - 1U ) & STACK_RND_MASK ) << PAGE_SHIFT ; <S2SV_EndBug> ,<S2SV_ModStart> long <S2SV_ModEnd> <S2SV_ModStart> long <S2SV_ModEnd> <S2SV_ModStart> 1UL <S2SV_ModEnd> ,torvalds@linux/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,CVE-2015-1593,https://github.com/torvalds/linux/commit/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,2015-03-16T10:59Z
39,CWE-20,"<S2SV_StartBug> _ ( ""_Launch<S2SV_blank>Anyway"" ) , RESPONSE_RUN ) ; <S2SV_EndBug> <S2SV_StartBug> _ ( ""Mark<S2SV_blank>as<S2SV_blank>_Trusted"" ) , RESPONSE_MARK_TRUSTED ) ; <S2SV_EndBug> <S2SV_StartBug> gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , <S2SV_EndBug> ","<S2SV_ModStart> ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL <S2SV_ModEnd> <S2SV_ModStart> ""Trust<S2SV_blank>and<S2SV_blank>_Launch"" ) , GTK_RESPONSE_OK <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",GNOME@nautilus/1630f53481f445ada0a455e9979236d31a8d3bb0,CVE-2017-14604,https://github.com/GNOME/nautilus/commit/1630f53481f445ada0a455e9979236d31a8d3bb0,2017-09-20T08:29Z
40,CWE-416,<S2SV_StartBug> tm = localtime ( & t ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; if ( tm == NULL ) return g_strdup ( ""???"" ",irssi@irssi/5e26325317c72a04c1610ad952974e206384d291,CVE-2017-10966,https://github.com/irssi/irssi/commit/5e26325317c72a04c1610ad952974e206384d291,2017-07-07T14:29Z
41,CWE-787,"<S2SV_StartBug> memcpy ( hashed , password , strlen ( password ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> length <S2SV_ModEnd> ,FreeRADIUS@pam_radius/01173ec2426627dbb1e0d96c06c3ffa0b14d36d0,CVE-2015-9542,https://github.com/FreeRADIUS/pam_radius/commit/01173ec2426627dbb1e0d96c06c3ffa0b14d36d0,2020-02-24T15:15Z
42,CWE-119,"<S2SV_StartBug> static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * d ) <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> d -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ; <S2SV_EndBug> <S2SV_StartBug> if ( d -> fe_adap [ 0 ] . fe == NULL ) <S2SV_EndBug> <S2SV_StartBug> if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ) { <S2SV_EndBug> ","<S2SV_ModStart> adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/606142af57dad981b78707234cfbd15f9f7b7125,CVE-2017-8062,https://github.com/torvalds/linux/commit/606142af57dad981b78707234cfbd15f9f7b7125,2017-04-23T05:59Z
43,CWE-362,<S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> sock * sk = asoc -> base . sk ; struct <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/635682a14427d241bab7bbdeebb48a7d7b91638e,CVE-2015-8767,https://github.com/torvalds/linux/commit/635682a14427d241bab7bbdeebb48a7d7b91638e,2016-02-08T03:59Z
44,CWE-200,<S2SV_StartBug> if ( ! chart || ! * chart ) { <S2SV_EndBug> ,<S2SV_ModStart> fix_google_param ( google_out ) ; fix_google_param ( google_sig ) ; fix_google_param ( google_reqId ) ; fix_google_param ( google_version ) ; fix_google_param ( responseHandler ) ; fix_google_param ( outFileName ) ; ,netdata@netdata/92327c9ec211bd1616315abcb255861b130b97ca,CVE-2018-18839,https://github.com/netdata/netdata/commit/92327c9ec211bd1616315abcb255861b130b97ca,2019-06-18T16:15Z
45,CWE-119,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % stride ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horAcc8"" , ""%s"" , ""(cc%stride)!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; ",vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1,CVE-2016-9535,https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1,2016-11-22T19:59Z
46,CWE-119,<S2SV_StartBug> inbuf = _TIFFmalloc ( scanlinesizein ) ; <S2SV_EndBug> ,"<S2SV_ModStart> uint16 bps = 0 ; ( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; if ( bps != 8 ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s"" , ""cpContig2SeparateByRow"" ) ; return 0 ; } ",vadz@libtiff/5c080298d59efa53264d7248bbe3a04660db6ef7,CVE-2017-5225,https://github.com/vadz/libtiff/commit/5c080298d59efa53264d7248bbe3a04660db6ef7,2017-01-12T11:59Z
47,CWE-399,<S2SV_StartBug> struct address_space * mapping ; <S2SV_EndBug> <S2SV_StartBug> if ( mapping ) <S2SV_EndBug> ,<S2SV_ModStart> hugepage_subpool * spool = ( struct hugepage_subpool <S2SV_ModEnd> <S2SV_ModStart> hugepage_subpool_put_pages ( spool <S2SV_ModEnd> ,torvalds@linux/90481622d75715bfcb68501280a917dbfe516029,CVE-2012-2133,https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029,2012-07-03T16:40Z
48,CWE-835,<S2SV_StartBug> if ( pes_signal != 1 || pes_header_data_length == 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> avio_feof ( pb ) ) { return AVERROR_EOF ; } if ( ,FFmpeg@FFmpeg/9807d3976be0e92e4ece3b4b1701be894cd7c2e1,CVE-2018-1999012,https://github.com/FFmpeg/FFmpeg/commit/9807d3976be0e92e4ece3b4b1701be894cd7c2e1,2018-07-23T15:29Z
49,CWE-119,<S2SV_StartBug> if ( ! e || e == p ) <S2SV_EndBug> ,<S2SV_ModStart> ) goto not_found ; if ( e - p > HOST_NAME_MAX - 1 ,keszybz@systemd/cb31827d62066a04b02111df3052949fda4b6888,CVE-2015-7510,https://github.com/keszybz/systemd/commit/cb31827d62066a04b02111df3052949fda4b6888,2017-09-25T21:29Z
50,CWE-416,"<S2SV_StartBug> void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) <S2SV_EndBug> <S2SV_StartBug> get_page ( buf -> page ) ; <S2SV_EndBug> ",<S2SV_ModStart> bool <S2SV_ModEnd> <S2SV_ModStart> return try_get_page <S2SV_ModEnd> ,torvalds@linux/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,CVE-2019-11487,https://github.com/torvalds/linux/commit/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,2019-04-23T22:29Z
51,CWE-125,"<S2SV_StartBug> cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , <S2SV_EndBug> ","<S2SV_ModStart> ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart>  <S2SV_ModEnd> ",the-tcpdump-group@tcpdump/e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d,CVE-2017-13039,https://github.com/the-tcpdump-group/tcpdump/commit/e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d,2017-09-14T06:29Z
52,CWE-264,"<S2SV_StartBug> ! inode_capable ( inode , CAP_CHOWN ) ) <S2SV_EndBug> <S2SV_StartBug> ! inode_capable ( inode , CAP_CHOWN ) ) <S2SV_EndBug> <S2SV_StartBug> ! inode_capable ( inode , CAP_FSETID ) ) <S2SV_EndBug> ",<S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> <S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> <S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> ,torvalds@linux/23adbe12ef7d3d4195e80800ab36b37bee28cd03,CVE-2014-4014,https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03,2014-06-23T11:21Z
53,CWE-284,"<S2SV_StartBug> select ( reader -> bytes_available_fd + 1 , & read_fds , NULL , NULL , & timeout ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ,system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
54,CWE-400,<S2SV_StartBug> fpm_globals . max_requests = wp -> config -> pm_max_requests ; <S2SV_EndBug> ,<S2SV_ModStart> ; fpm_globals . listening_socket = dup ( wp -> listening_socket ) ,php@php-src/69dee5c732fe982c82edb17d0dbc3e79a47748d8,CVE-2015-9253,https://github.com/php/php-src/commit/69dee5c732fe982c82edb17d0dbc3e79a47748d8,2018-02-19T19:29Z
55,CWE-119,"<S2SV_StartBug> static int detect_transition_to_still ( struct twopass_rc * twopass , <S2SV_EndBug> <S2SV_StartBug> int trans_to_still = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( frame_interval > MIN_GF_INTERVAL && <S2SV_EndBug> <S2SV_StartBug> const FIRSTPASS_STATS * position = twopass -> stats_in ; <S2SV_EndBug> <S2SV_StartBug> if ( EOF == input_stats ( twopass , & tmp_next_frame ) ) <S2SV_EndBug> <S2SV_StartBug> if ( tmp_next_frame . pcnt_inter - tmp_next_frame . pcnt_motion < 0.999 ) <S2SV_EndBug> <S2SV_StartBug> reset_fpf_position ( twopass , position ) ; <S2SV_EndBug> <S2SV_StartBug> if ( j == still_interval ) <S2SV_EndBug> <S2SV_StartBug> return trans_to_still ; <S2SV_EndBug> ",<S2SV_ModStart> VP9_COMP * cpi <S2SV_ModEnd> <S2SV_ModStart> TWO_PASS * const twopass = & cpi -> twopass ; RATE_CONTROL * const rc = & cpi -> rc <S2SV_ModEnd> <S2SV_ModStart> rc -> min_gf_interval <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const FIRSTPASS_STATS * stats = & twopass -> stats_in [ j ] ; if ( stats >= twopass -> stats_in_end <S2SV_ModEnd> <S2SV_ModStart> stats -> pcnt_inter - stats -> <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
56,CWE-416,<S2SV_StartBug> if ( ! handle -> h_transaction ) { <S2SV_EndBug> <S2SV_StartBug> err = jbd2_journal_stop ( handle ) ; <S2SV_EndBug> <S2SV_StartBug> return handle -> h_err ? handle -> h_err : err ; <S2SV_EndBug> <S2SV_StartBug> sb = handle -> h_transaction -> t_journal -> j_private ; <S2SV_EndBug> ,<S2SV_ModStart> err = handle -> h_err ; <S2SV_ModStart> rc <S2SV_ModEnd> <S2SV_ModStart> err ? err : rc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/6934da9238da947628be83635e365df41064b09b,CVE-2015-8961,https://github.com/torvalds/linux/commit/6934da9238da947628be83635e365df41064b09b,2016-11-16T05:59Z
57,CWE-000,<S2SV_StartBug> if ( offset + size <= i_size_read ( inode ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z
58,CWE-19,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> args -> rmtvaluelen = args -> valuelen ; ,torvalds@linux/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,CVE-2015-0274,https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,2015-03-16T10:59Z
59,CWE-269,"<S2SV_StartBug> request_module ( ""%s"" , name ) ; <S2SV_EndBug> <S2SV_StartBug> request_module ( ""%s-all"" , name ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""crypto-%s"" <S2SV_ModEnd> <S2SV_ModStart> ""crypto-%s-all"" <S2SV_ModEnd> ",torvalds@linux/5d26a105b5a73e5635eae0629b42fa0a90e07b7b,CVE-2013-7421,https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b,2015-03-02T11:59Z
60,CWE-125,"<S2SV_StartBug> stlv_type = * ( tptr ++ ) ; <S2SV_EndBug> <S2SV_StartBug> len = len - 2 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> while ( tmp ) <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len ) <S2SV_ModStart> if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; <S2SV_ModStart> if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ; stlv_len = stlv_len <S2SV_ModStart> if ( stlv_len < 8 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> tptr += stlv_len ; len -= stlv_len ; ",the-tcpdump-group@tcpdump/b20e1639dbac84b3fcb393858521c13ad47a9d70,CVE-2017-13026,https://github.com/the-tcpdump-group/tcpdump/commit/b20e1639dbac84b3fcb393858521c13ad47a9d70,2017-09-14T06:29Z
61,CWE-000,"<S2SV_StartBug> return reply_msg ( c , MSG_JOB_TOO_BIG ) ; <S2SV_EndBug> ","<S2SV_ModStart> skip ( c , body_size + 2 <S2SV_ModEnd> ",kr@beanstalkd/2e8e8c6387ecdf5923dfc4d7718d18eba1b0873d,CVE-2010-2060,https://github.com/kr/beanstalkd/commit/2e8e8c6387ecdf5923dfc4d7718d18eba1b0873d,2010-06-08T00:30Z
62,CWE-200,<S2SV_StartBug> ddi . dinfo_nboards = dgnc_NumBoards ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & ddi , 0 , sizeof ( ddi ) ) ; ",torvalds@linux/4b6184336ebb5c8dc1eae7f7ab46ee608a748b05,CVE-2015-7885,https://github.com/torvalds/linux/commit/4b6184336ebb5c8dc1eae7f7ab46ee608a748b05,2015-12-28T11:59Z
63,CWE-125,<S2SV_StartBug> if ( ! ( opt_len == 12 && flags & TH_SYN ) && <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) ,the-tcpdump-group@tcpdump/4c3aee4bb0294c232d56b6d34e9eeb74f630fe8c,CVE-2017-13040,https://github.com/the-tcpdump-group/tcpdump/commit/4c3aee4bb0294c232d56b6d34e9eeb74f630fe8c,2017-09-14T06:29Z
64,CWE-264,"<S2SV_StartBug> int procfd = payload -> procfd ; <S2SV_EndBug> <S2SV_StartBug> uid_t new_uid ; <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0)"" ) ; <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1)"" ) ; <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>final<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(2)"" ) ; <S2SV_EndBug> <S2SV_StartBug> rexit ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ""gainable<S2SV_blank>privileges."" ) ; <S2SV_EndBug> <S2SV_StartBug> on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( lsm_set_label_at ( procfd , on_exec , init_ctx -> lsm_label ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> rexit ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> rexit ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> close ( procfd ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int lsm_labelfd ; <S2SV_ModStart> ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0):<S2SV_blank>%s."" , strerror ( errno ) <S2SV_ModEnd> <S2SV_ModStart> ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1):<S2SV_blank>%s."" , strerror ( errno ) <S2SV_ModEnd> <S2SV_ModStart> ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>message<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>"" ""that<S2SV_blank>it<S2SV_blank>is<S2SV_blank>done<S2SV_blank>pre-initializing<S2SV_blank>(2):<S2SV_blank>%s"" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModEnd> <S2SV_ModStart> shutdown ( ipc_socket , SHUT_RDWR ) ; <S2SV_ModStart> ) ; } status = 3 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>set<S2SV_blank>up<S2SV_blank>LSM<S2SV_blank>labels<S2SV_blank>(3):<S2SV_blank>%s."" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 <S2SV_ModStart> ret = lxc_abstract_unix_recv_fd ( ipc_socket , & lsm_labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s."" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> lsm_labelfd <S2SV_ModEnd> <S2SV_ModStart> SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label."" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; close ( lsm_labelfd ) ; rexit ( - 1 ) ; } close ( lsm_labelfd ) ; <S2SV_ModEnd> <S2SV_ModStart> shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",lxc@lxc/81f466d05f2a89cb4f122ef7f593ff3f279b165c,CVE-2016-8649,https://github.com/lxc/lxc/commit/81f466d05f2a89cb4f122ef7f593ff3f279b165c,2017-05-01T06:59Z
65,CWE-125,"<S2SV_StartBug> line += 3 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = strchr ( line , '<S2SV_blank>' ) ) ) <S2SV_EndBug> <S2SV_StartBug> line = ptr + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = strchr ( line , '\\n' ) ) ) <S2SV_EndBug> ","<S2SV_ModStart> if ( len < 3 ) goto out_err ; <S2SV_ModStart> len -= 3 ; <S2SV_ModStart> memchr <S2SV_ModEnd> <S2SV_ModStart> , len <S2SV_ModStart> if ( len < 1 ) goto out_err ; <S2SV_ModStart> len -= 1 ; <S2SV_ModStart> memchr <S2SV_ModEnd> <S2SV_ModStart> , len ",libgit2@libgit2/1f9a8510e1d2f20ed7334eeeddb92c4dd8e7c649,CVE-2018-15501,https://github.com/libgit2/libgit2/commit/1f9a8510e1d2f20ed7334eeeddb92c4dd8e7c649,2018-08-18T02:29Z
66,CWE-119,<S2SV_StartBug> if ( header -> biSize >= 40U ) { <S2SV_EndBug> ,"<S2SV_ModStart> biBitCount == 0 ) { fprintf ( stderr , ""Error,<S2SV_blank>invalid<S2SV_blank>biBitCount<S2SV_blank>%d\\n"" , 0 ) ; return OPJ_FALSE ; } if ( header -> ",uclouvain@openjpeg/baf0c1ad4572daa89caa3b12985bdd93530f0dd7,CVE-2017-12982,https://github.com/uclouvain/openjpeg/commit/baf0c1ad4572daa89caa3b12985bdd93530f0dd7,2017-08-21T07:29Z
67,CWE-000,"<S2SV_StartBug> SAS_DPRINTK ( ""DONE<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>result:%d\\n"" , port -> id , <S2SV_EndBug> ",<S2SV_ModStart> sas_probe_devices ( port ) ; ,torvalds@linux/0558f33c06bb910e2879e355192227a8e8f0219d,CVE-2017-18232,https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d,2018-03-15T04:29Z
68,CWE-415,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( image -> colors < tga_info . colormap_index ) image -> colors = tga_info . colormap_index ; ,ImageMagick@ImageMagick/4f68e9661518463fca523c9726bb5d940a2aa6d8,CVE-2015-8894,https://github.com/ImageMagick/ImageMagick/commit/4f68e9661518463fca523c9726bb5d940a2aa6d8,2017-03-15T19:59Z
69,CWE-190,<S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> ,<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> ,mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
70,CWE-399,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & line , 0 , sizeof ( line ) ) ; ",torvalds@linux/2b13d06c9584b4eb773f1e80bbaedab9a1c344e1,CVE-2014-1445,https://github.com/torvalds/linux/commit/2b13d06c9584b4eb773f1e80bbaedab9a1c344e1,2014-01-18T22:55Z
71,CWE-264,"<S2SV_StartBug> return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> int ret ; ret = scsi_verify_blk_ioctl ( bd , cmd ) ; if ( ret < 0 ) return ret ; ",torvalds@linux/0bfc96cb77224736dfa35c3c555d37b3646ef35e,CVE-2011-4127,https://github.com/torvalds/linux/commit/0bfc96cb77224736dfa35c3c555d37b3646ef35e,2012-07-03T16:40Z
72,CWE-125,"<S2SV_StartBug> void nego_process_negotiation_request ( rdpNego * nego , wStream * s ) <S2SV_EndBug> <S2SV_StartBug> UINT16 length ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> ; if ( Stream_GetRemainingLength ( s ) < 7 ) return FALSE <S2SV_ModStart> return TRUE ; ,FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z
73,CWE-119,<S2SV_StartBug> int req_len ; <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned <S2SV_ModStart> ; if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) ) return - EINVAL ,torvalds@linux/6fb392b1a63ae36c31f62bc3fc8630b49d602b62,CVE-2013-6381,https://github.com/torvalds/linux/commit/6fb392b1a63ae36c31f62bc3fc8630b49d602b62,2013-11-27T04:43Z
74,CWE-190,<S2SV_StartBug> int m ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( n < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_pad"" ) ; } ",mdadams@jasper/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,CVE-2016-9262,https://github.com/mdadams/jasper/commit/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,2017-03-23T18:59Z
75,CWE-787,<S2SV_StartBug> int xd_size = 0 ; <S2SV_EndBug> <S2SV_StartBug> xd_size += len ; <S2SV_EndBug> <S2SV_StartBug> if ( delta > data_len [ j ] ) { <S2SV_EndBug> <S2SV_StartBug> offset += data_len [ j ] ; <S2SV_EndBug> ,"<S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> + 1 + len / 255 ; } ret = ff_alloc_extradata ( st -> codecpar , xd_size <S2SV_ModEnd> <S2SV_ModStart> av_assert0 ( delta <= xd_size - offset ) ; <S2SV_ModEnd> <S2SV_ModStart> av_assert0 ( data_len [ j ] <= xd_size - offset ) ; ",FFmpeg@FFmpeg/27a99e2c7d450fef15594671eef4465c8a166bd7,CVE-2020-35964,https://github.com/FFmpeg/FFmpeg/commit/27a99e2c7d450fef15594671eef4465c8a166bd7,2021-01-03T19:15Z
76,CWE-125,"<S2SV_StartBug> av_log ( mxf , AV_LOG_TRACE , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> -> fc ,FFmpeg@FFmpeg/bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75,CVE-2018-1999014,https://github.com/FFmpeg/FFmpeg/commit/bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75,2018-07-23T15:29Z
77,CWE-59,"<S2SV_StartBug> return mount_entry_on_generic ( mntent , path ) ; <S2SV_EndBug> ","<S2SV_ModStart> , rootfs ",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z
78,CWE-119,"<S2SV_StartBug> psf_binheader_readf ( psf , ""p"" , psf -> fileoffset ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ",<S2SV_ModStart> if ( psf -> fileoffset < psf -> filelength ) { <S2SV_ModStart> } ; ,erikd@libsndfile/f457b7b5ecfe91697ed01cfc825772c4d8de1236,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/f457b7b5ecfe91697ed01cfc825772c4d8de1236,2017-04-07T20:59Z
79,CWE-125,<S2SV_StartBug> l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ; <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK_16BITS ( p + l2info -> cookie_len ) ; ,the-tcpdump-group@tcpdump/42073d54c53a496be40ae84152bbfe2c923ac7bc,CVE-2017-13004,https://github.com/the-tcpdump-group/tcpdump/commit/42073d54c53a496be40ae84152bbfe2c923ac7bc,2017-09-14T06:29Z
80,CWE-787,<S2SV_StartBug> return NF_ACCEPT ; <S2SV_EndBug> ,<S2SV_ModStart> err == 0 ? NF_ACCEPT : NF_DROP <S2SV_ModEnd> ,torvalds@linux/9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa,CVE-2016-9755,https://github.com/torvalds/linux/commit/9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa,2016-12-28T07:59Z
81,CWE-200,"<S2SV_StartBug> if ( ! rta ) <S2SV_EndBug> <S2SV_StartBug> p = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> pp = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> * replay_esn = p ; <S2SV_EndBug> ","<S2SV_ModStart> int klen , ulen ; <S2SV_ModStart> klen = <S2SV_ModEnd> <S2SV_ModStart> ; ulen = nla_len ( rta ) >= klen ? klen : sizeof ( * up ) ; p = kzalloc ( klen <S2SV_ModStart> kzalloc ( klen <S2SV_ModEnd> <S2SV_ModStart> memcpy ( p , up , ulen ) ; memcpy ( pp , up , ulen ) ; ",torvalds@linux/ecd7918745234e423dd87fcc0c077da557909720,CVE-2012-6536,https://github.com/torvalds/linux/commit/ecd7918745234e423dd87fcc0c077da557909720,2013-03-15T20:55Z
82,CWE-416,<S2SV_StartBug> io -> io_cleanup = mem_cleanup ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> io -> io_cleanup = mem_cleanup ; ,torvalds@linux/401e7e88d4ef80188ffa07095ac00456f901b8c4,CVE-2019-11811,https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4,2019-05-07T14:29Z
83,CWE-190,<S2SV_StartBug> result = ( MagickRealType ) ( ( size_t ) pixel & ( size_t ) ( value + 0.5 ) ) ; <S2SV_EndBug> <S2SV_StartBug> result = ( MagickRealType ) ( ( size_t ) pixel << ( size_t ) ( value + 0.5 ) ) ; <S2SV_EndBug> <S2SV_StartBug> result = ( MagickRealType ) ( ( size_t ) pixel | ( size_t ) ( value + 0.5 ) ) ; <S2SV_EndBug> <S2SV_StartBug> result = ( MagickRealType ) ( ( size_t ) pixel >> ( size_t ) ( value + 0.5 ) ) ; <S2SV_EndBug> <S2SV_StartBug> result = ( MagickRealType ) ( ( size_t ) pixel ^ ( size_t ) ( value + 0.5 ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ssize_t <S2SV_ModEnd> ,ImageMagick@ImageMagick6/3e21bc8a58b4ae38d24c7e283837cc279f35b6a5,CVE-2020-27764,https://github.com/ImageMagick/ImageMagick6/commit/3e21bc8a58b4ae38d24c7e283837cc279f35b6a5,2020-12-03T17:15Z
84,CWE-20,<S2SV_StartBug> btif_config_flush ( ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( is_restricted_mode ( ) ) { BTIF_TRACE_WARNING ( ""%s:<S2SV_blank>\'%s\'<S2SV_blank>pairing<S2SV_blank>will<S2SV_blank>be<S2SV_blank>removed<S2SV_blank>if<S2SV_blank>unrestricted"" , __func__ , bdstr ) ; btif_config_set_int ( bdstr , ""Restricted"" , 1 ) ; } ",system@bt/37c88107679d36c419572732b4af6e18bb2f7dce,CVE-2016-3760,https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce,2016-07-11T02:00Z
85,CWE-119,"<S2SV_StartBug> if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { <S2SV_EndBug> ","<S2SV_ModStart> jas_alloc3 ( bufsize , numcols <S2SV_ModEnd> ",mdadams@jasper/4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a,CVE-2016-8654,https://github.com/mdadams/jasper/commit/4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a,2018-08-01T16:29Z
86,CWE-119,<S2SV_StartBug> vpx_codec_enc_cfg_map_t * map ; <S2SV_EndBug> <S2SV_StartBug> for ( map = iface -> enc . cfg_maps ; map -> usage >= 0 ; map ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> ; int i <S2SV_ModStart> i = 0 ; i < iface -> enc . cfg_map_count ; ++ i ) { <S2SV_ModStart> + i ; <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
87,CWE-20,"<S2SV_StartBug> netdev_dbg ( vif -> dev , ""GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\n"" , gso -> u . gso . type ) ; <S2SV_EndBug> ",<S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif ,torvalds@linux/48856286b64e4b66ec62b94e504d0b29c1ade664,CVE-2013-0216,https://github.com/torvalds/linux/commit/48856286b64e4b66ec62b94e504d0b29c1ade664,2013-02-18T04:41Z
88,CWE-119,"<S2SV_StartBug> static void show_object ( struct object * object , struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , void * data ) <S2SV_EndBug> <S2SV_StartBug> if ( bitmap_pos < 0 ) { <S2SV_EndBug> <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,git@git/de1e67d0703894cb6ea782e36abb63976ab07e60,CVE-2016-2315,https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60,2016-04-08T14:59Z
89,CWE-77,"<S2SV_StartBug> run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,npat-efault@picocom/1ebc60b20fbe9a02436d5cbbf8951714e749ddb1,CVE-2015-9059,https://github.com/npat-efault/picocom/commit/1ebc60b20fbe9a02436d5cbbf8951714e749ddb1,2017-05-28T00:29Z
90,CWE-416,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> snd_usb_mixer_disconnect ( mixer ) ; ,torvalds@linux/124751d5e63c823092060074bd0abaae61aaa9c4,CVE-2017-16527,https://github.com/torvalds/linux/commit/124751d5e63c823092060074bd0abaae61aaa9c4,2017-11-04T01:29Z
91,CWE-416,"<S2SV_StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! po -> running ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> return - EALREADY ; <S2SV_EndBug> <S2SV_StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! po -> rollover ) <S2SV_EndBug> <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & fanout_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> if ( err ) { <S2SV_EndBug> ",<S2SV_ModStart> packet_rollover * rollover = NULL ; struct <S2SV_ModStart> mutex_lock ( & fanout_mutex ) ; err = - EINVAL ; <S2SV_ModStart> goto out ; err = - EALREADY <S2SV_ModEnd> <S2SV_ModStart> goto out <S2SV_ModEnd> <S2SV_ModStart> err = - ENOMEM ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rollover ) goto out <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> po -> rollover = rollover ; } <S2SV_ModEnd> <S2SV_ModStart> if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/d199fab63c11998a602205f7ee7ff7c05c97164b,CVE-2017-6346,https://github.com/torvalds/linux/commit/d199fab63c11998a602205f7ee7ff7c05c97164b,2017-03-01T20:59Z
92,CWE-000,"<S2SV_StartBug> memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ,torvalds@linux/fdcee2cbb8438702ea1b328fb6e0ac5e9a40c7f8,CVE-2017-9075,https://github.com/torvalds/linux/commit/fdcee2cbb8438702ea1b328fb6e0ac5e9a40c7f8,2017-05-19T07:29Z
93,CWE-401,<S2SV_StartBug> return NULL ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( table ) ; ,torvalds@linux/b4b814fec1a5a849383f7b3886b654a13abbda7d,CVE-2019-19058,https://github.com/torvalds/linux/commit/b4b814fec1a5a849383f7b3886b654a13abbda7d,2019-11-18T06:15Z
94,CWE-119,"<S2SV_StartBug> void show_progress ( int frame_in , int frame_out , uint64_t dx_time ) { <S2SV_EndBug> ",<S2SV_ModStart> static ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
95,CWE-416,<S2SV_StartBug> buffer -> buffer = ( char * ) fbh -> data ; <S2SV_EndBug> ,<S2SV_ModStart> buffer = ( char * ) fbh -> data ; imp_sth -> stmt -> bind [ i ] . buffer_length = fbh -> length ; imp_sth -> stmt -> bind [ i ] . ,perl5-dbi@DBD-mysql/3619c170461a3107a258d1fd2d00ed4832adb1b1,CVE-2016-1251,https://github.com/perl5-dbi/DBD-mysql/commit/3619c170461a3107a258d1fd2d00ed4832adb1b1,2016-11-29T20:59Z
96,CWE-20,"<S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_TXIF | EIR_TXERIF ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXSTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDL , LSB ( ENC28J60_TX_BUFFER_START + length ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDH , MSB ( ENC28J60_TX_BUFFER_START + length ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRTS ) ; <S2SV_EndBug> ","<S2SV_ModStart> ENC28J60_ECON1 , ENC28J60_ECON1_TXRST <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ECON1 , ENC28J60_ECON1_TXRST <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIR , ENC28J60_EIR_TXIF | ENC28J60_EIR_TXERIF ) ; enc28j60WriteReg ( interface , ENC28J60_ETXSTL <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ETXSTH <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EWRPTL <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EWRPTH <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ETXNDL <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ETXNDH <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ECON1 , ENC28J60_ECON1_TXRTS <S2SV_ModEnd> ",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
97,CWE-125,<S2SV_StartBug> value = ast2obj_int ( o -> lineno ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ast2obj_string ( o -> type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z
98,CWE-22,"<S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> <S2SV_StartBug> file_write ( page , wikitext ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> if ( page && ( unlink ( page ) > 0 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> ",<S2SV_ModStart> page_name_is_good ( page ) && <S2SV_ModStart> if ( page_name_is_good ( page ) ) { <S2SV_ModStart> } <S2SV_ModStart> page_name_is_good ( page ) && <S2SV_ModStart> && page_name_is_good ( page ) ,yarolig@didiwiki/5e5c796617e1712905dc5462b94bd5e6c08d15ea,CVE-2013-7448,https://github.com/yarolig/didiwiki/commit/5e5c796617e1712905dc5462b94bd5e6c08d15ea,2016-02-23T19:59Z
99,CWE-000,"<S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_PRE_IO ) { <S2SV_EndBug> <S2SV_StartBug> ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; <S2SV_EndBug> <S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_CONVERT ) { <S2SV_EndBug> ",<S2SV_ModStart> ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result <S2SV_ModStart> ( flags & EXT4_GET_BLOCKS_CONVERT ) <S2SV_ModEnd> ,torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z
100,CWE-125,"<S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> ,the-tcpdump-group@tcpdump/7029d15f148ef24bb7c6668bc640f5470d085e5a,CVE-2017-13029,https://github.com/the-tcpdump-group/tcpdump/commit/7029d15f148ef24bb7c6668bc640f5470d085e5a,2017-09-14T06:29Z
101,CWE-264,"<S2SV_StartBug> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { <S2SV_EndBug> ","<S2SV_ModStart> caller_may_see_dir ( fc -> pid , controller , cgroup ) ) { ret = - ENOENT ; goto out ; } if ( ! ",lxc@lxcfs/a8b6c3e0537e90fba3c55910fd1b7229d54a60a7,CVE-2015-1342,https://github.com/lxc/lxcfs/commit/a8b6c3e0537e90fba3c55910fd1b7229d54a60a7,2015-12-07T20:59Z
102,CWE-119,"<S2SV_StartBug> int flag ) <S2SV_EndBug> <S2SV_StartBug> int mb_rows = source -> y_width >> 4 ; <S2SV_EndBug> <S2SV_StartBug> int mb_cols = source -> y_height >> 4 ; <S2SV_EndBug> <S2SV_StartBug> int mbr , mbc ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( limits , ( unsigned char ) ppl , 16 * mb_cols ) ; <S2SV_EndBug> <S2SV_StartBug> vp8_post_proc_down_and_across_mb_row ( <S2SV_EndBug> <S2SV_StartBug> source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int uvfilter ) { int mbr ; <S2SV_ModEnd> <S2SV_ModStart> cm -> mb_rows <S2SV_ModEnd> <S2SV_ModStart> cm -> mb_cols <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> if ( uvfilter == 1 ) { <S2SV_ModStart> 8 ) ; } <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
103,CWE-264,"<S2SV_StartBug> ret = copy_to_user ( param , ptr , sizeof ( * ptr ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct floppy_raw_cmd cmd = * ptr ; cmd . next = NULL ; cmd . kernel_data = NULL ; <S2SV_ModStart> & cmd <S2SV_ModEnd> <S2SV_ModStart> cmd <S2SV_ModEnd> ,torvalds@linux/2145e15e0557a01b9195d1c7199a1b92cb9be81f,CVE-2014-1738,https://github.com/torvalds/linux/commit/2145e15e0557a01b9195d1c7199a1b92cb9be81f,2014-05-11T21:55Z
104,CWE-264,<S2SV_StartBug> if ( ( new -> euid != old -> uid || <S2SV_EndBug> ,"<S2SV_ModStart> ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) bprm -> per_clear |= PER_CLEAR_ON_SETID ; if ( ",torvalds@linux/d52fc5dde171f030170a6cb78034d166b13c9445,CVE-2012-2123,https://github.com/torvalds/linux/commit/d52fc5dde171f030170a6cb78034d166b13c9445,2012-05-17T11:00Z
105,CWE-19,"<S2SV_StartBug> ext4_xattr_cache_insert ( struct mb_cache * ext4_mb_cache , struct buffer_head * bh ) <S2SV_EndBug> <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ; <S2SV_EndBug> <S2SV_StartBug> error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_free ( ce ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error == - EBUSY ) { <S2SV_EndBug> <S2SV_StartBug> error = 0 ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> ","<S2SV_ModStart> mb2_cache <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> error = mb2_cache_entry_create <S2SV_ModEnd> <S2SV_ModStart> , hash , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/82939d7999dfc1f1998c4b1c12e2f19edbdff272,CVE-2015-8952,https://github.com/torvalds/linux/commit/82939d7999dfc1f1998c4b1c12e2f19edbdff272,2016-10-16T21:59Z
106,CWE-78,"<S2SV_StartBug> return r_socket_http_answer ( s , code , rlen ) ; <S2SV_EndBug> ","<S2SV_ModStart> socket_http_answer <S2SV_ModEnd> <S2SV_ModStart> , 0 ",radareorg@radare2/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9,CVE-2020-15121,https://github.com/radareorg/radare2/commit/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9,2020-07-20T18:15Z
107,CWE-17,"<S2SV_StartBug> tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p -> z , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,antirez@redis/fdf9d455098f54f7666c702ae464e6ea21e25411,CVE-2015-4335,https://github.com/antirez/redis/commit/fdf9d455098f54f7666c702ae464e6ea21e25411,2015-06-09T14:59Z
108,CWE-000,<S2SV_StartBug> int err ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL ,torvalds@linux/79462ad02e861803b3840cc782248c7359451cd9,CVE-2015-8543,https://github.com/torvalds/linux/commit/79462ad02e861803b3840cc782248c7359451cd9,2015-12-28T11:59Z
109,CWE-362,"<S2SV_StartBug> int ip_options_get_from_user ( struct net * net , struct ip_options * * optp , <S2SV_EndBug> <S2SV_StartBug> struct ip_options * opt = ip_options_get_alloc ( optlen ) ; <S2SV_EndBug> <S2SV_StartBug> if ( optlen && copy_from_user ( opt -> __data , data , optlen ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> opt . ,torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z
110,CWE-200,"<S2SV_StartBug> dl = kmalloc ( size , GFP_KERNEL ) ; <S2SV_EndBug> ",<S2SV_ModStart> kzalloc <S2SV_ModEnd> ,torvalds@linux/f9432c5ec8b1e9a09b9b0e5569e3c73db8de432a,CVE-2012-6545,https://github.com/torvalds/linux/commit/f9432c5ec8b1e9a09b9b0e5569e3c73db8de432a,2013-03-15T20:55Z
111,CWE-125,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , rpl_tstr <S2SV_ModEnd> ",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z
112,CWE-125,"<S2SV_StartBug> static int <S2SV_EndBug> <S2SV_StartBug> rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , u_int indent ) <S2SV_EndBug> <S2SV_StartBug> pdu_header = ( const rpki_rtr_pdu * ) tptr ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_EndBug> <S2SV_StartBug> pdu_type , pdu_len ) ) ; <S2SV_EndBug> <S2SV_StartBug> case RPKI_RTR_END_OF_DATA_PDU : <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case RPKI_RTR_CACHE_RESPONSE_PDU : <S2SV_EndBug> <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_ipv4_prefix * ) tptr ; <S2SV_EndBug> <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_ipv6_prefix * ) tptr ; <S2SV_EndBug> <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_error_report * ) tptr ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , encapsulated_pdu_length ) ; <S2SV_EndBug> <S2SV_StartBug> tptr += sizeof ( * pdu ) ; <S2SV_EndBug> <S2SV_StartBug> if ( encapsulated_pdu_length && <S2SV_EndBug> <S2SV_StartBug> if ( rpki_rtr_pdu_print ( ndo , tptr , indent + 2 ) ) <S2SV_EndBug> <S2SV_StartBug> tlen -= encapsulated_pdu_length ; <S2SV_EndBug> <S2SV_StartBug> text_length = 0 ; <S2SV_EndBug> <S2SV_StartBug> text_length = EXTRACT_32BITS ( tptr ) ; <S2SV_EndBug> <S2SV_StartBug> tlen -= 4 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , text_length ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ","<S2SV_ModStart> u_int <S2SV_ModEnd> <S2SV_ModStart> const u_int len , const u_char recurse , const <S2SV_ModStart> ND_TCHECK_8BITS ( tptr ) ; if ( * tptr != 0 ) { ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u<S2SV_blank>(unknown)"" , indent_string ( 8 ) , * tptr ) ) ; return len ; } if ( len < sizeof ( rpki_rtr_pdu ) ) { ND_PRINT ( ( ndo , ""(%u<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>few<S2SV_blank>to<S2SV_blank>decode)"" , len ) ) ; goto invalid ; } ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( pdu_len < sizeof ( rpki_rtr_pdu ) || pdu_len > len ) goto invalid <S2SV_ModStart> if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModStart> if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModStart> if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 12 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 24 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> tlen = sizeof ( rpki_rtr_pdu ) ; if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) ; <S2SV_ModStart> tlen += 4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) { if ( pdu_len < tlen + encapsulated_pdu_length ) goto invalid ; if ( ! recurse ) { ND_TCHECK2 ( * tptr , tlen + encapsulated_pdu_length ) ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> + tlen , encapsulated_pdu_length , 0 <S2SV_ModStart> ; } tlen <S2SV_ModEnd> <S2SV_ModStart> } if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> + tlen ) ; tlen <S2SV_ModEnd> <S2SV_ModStart> if ( text_length ) { if ( pdu_len < tlen + text_length ) goto invalid ; ND_PRINT ( ( ndo , ""%sError<S2SV_blank>text:<S2SV_blank>"" , indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo , tptr + tlen , text_length , ndo -> ndo_snapend ) ) goto trunc ; } } break ; default : <S2SV_ModEnd> <S2SV_ModStart> pdu_len ) ; <S2SV_ModEnd> <S2SV_ModStart> pdu_len ; invalid : ND_PRINT ( ( ndo , ""%s"" , istr ) ) ; ND_TCHECK2 ( * tptr , len ) ; return len <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""\\n\\t%s"" , tstr ) ) ; return len <S2SV_ModEnd> ",the-tcpdump-group@tcpdump/83c64fce3a5226b080e535f5131a8a318f30e79b,CVE-2017-13050,https://github.com/the-tcpdump-group/tcpdump/commit/83c64fce3a5226b080e535f5131a8a318f30e79b,2017-09-14T06:29Z
113,CWE-20,"<S2SV_StartBug> int n , len ; <S2SV_EndBug> <S2SV_StartBug> memset ( & facilities , 0x00 , sizeof ( struct rose_facilities_struct ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! rose_parse_facilities ( skb -> data + len + 4 , & facilities ) ) { <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ROSE_CALL_REQ_FACILITIES_OFF , skb -> len - ROSE_CALL_REQ_FACILITIES_OFF , <S2SV_ModEnd> ",torvalds@linux/e0bccd315db0c2f919e7fcf9cb60db21d9986f52,CVE-2011-4914,https://github.com/torvalds/linux/commit/e0bccd315db0c2f919e7fcf9cb60db21d9986f52,2012-06-21T23:55Z
114,CWE-284,<S2SV_StartBug> addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> ,<S2SV_ModStart> INADDR_LOOPBACK <S2SV_ModEnd> ,libimobiledevice@libimobiledevice/df1f5c4d70d0c19ad40072f5246ca457e7f9849e,CVE-2016-5104,https://github.com/libimobiledevice/libimobiledevice/commit/df1f5c4d70d0c19ad40072f5246ca457e7f9849e,2016-06-13T14:59Z
115,CWE-20,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( ! gui_mch_set_rendering_options ( p_rop ) ) <S2SV_EndBug> ,<S2SV_ModStart> if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ; else <S2SV_ModStart> ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_AUTOCMD else if ( gvarp == & p_ft ) { if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_SYN_HL else if ( gvarp == & p_syn ) { if ( ! valid_filetype ( * varp ,vim@vim/d0b5138ba4bccff8a744c99836041ef6322ed39a,CVE-2016-1248,https://github.com/vim/vim/commit/d0b5138ba4bccff8a744c99836041ef6322ed39a,2016-11-23T15:59Z
116,CWE-285,"<S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & new_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode , & new_mode , & acl ) ; if ( ret ) goto out <S2SV_ModEnd> ",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z
117,CWE-476,<S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> <S2SV_StartBug> ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ret ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> o2nm_unlock_subsystem ( ) ; ,torvalds@linux/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,CVE-2017-18216,https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,2018-03-05T18:29Z
118,CWE-125,"<S2SV_StartBug> isoclns_print ( ndo , p , length , caplen ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z
119,CWE-22,<S2SV_StartBug> separator = * src ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>is<S2SV_blank>absolute"" ) ; return ( ARCHIVE_FAILED ) ; } separator = * src ++ ; } <S2SV_ModEnd> ",libarchive@libarchive/59357157706d47c365b2227739e17daba3607526,CVE-2015-2304,https://github.com/libarchive/libarchive/commit/59357157706d47c365b2227739e17daba3607526,2015-03-15T19:59Z
120,CWE-522,"<S2SV_StartBug> TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , <S2SV_EndBug> <S2SV_StartBug> TPM2B_DIGEST tmpResult ; <S2SV_EndBug> <S2SV_StartBug> TPM_RC rval ; <S2SV_EndBug> <S2SV_StartBug> while ( resultKey -> t . size < bytes ) <S2SV_EndBug> <S2SV_StartBug> i_Swizzled = string_bytes_endian_convert_32 ( i ) ; <S2SV_EndBug> <S2SV_StartBug> bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; <S2SV_EndBug> <S2SV_StartBug> rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rval != TPM_RC_SUCCESS ) <S2SV_EndBug> <S2SV_StartBug> return TSS2_SYS_RC_BAD_VALUE ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = TPM_RC_SUCCESS <S2SV_ModStart> const EVP_MD * md = tpm_algorithm_to_openssl_digest ( hashAlg ) ; if ( ! md ) { LOG_ERR ( ""Algorithm<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>hmac:<S2SV_blank>%x"" , hashAlg ) ; return TPM_RC_HASH ; } HMAC_CTX ctx ; HMAC_CTX_init ( & ctx ) ; int rc = HMAC_Init_ex ( & ctx , key -> buffer , key -> size , md , NULL ) ; if ( ! rc ) { LOG_ERR ( ""HMAC<S2SV_blank>Init<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ; return TPM_RC_MEMORY ; } <S2SV_ModStart> TPM2B_DIGEST tmpResult ; <S2SV_ModStart> ] = ( TPM2B_DIGEST * ) 0 ; int c ; for ( c = 0 ; c < j ; c ++ ) { TPM2B_DIGEST * digest = bufferList [ c ] ; int rc = HMAC_Update ( & ctx , digest -> b . buffer , digest -> b . size ) ; if ( ! rc ) { LOG_ERR ( ""HMAC<S2SV_blank>Update<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) <S2SV_ModEnd> <S2SV_ModStart> TPM_RC_MEMORY ; goto err ; } } unsigned size = sizeof ( tmpResult . t . buffer ) ; int rc = HMAC_Final ( & ctx , tmpResult . t . buffer , & size <S2SV_ModEnd> <S2SV_ModStart> ! rc ) { LOG_ERR ( ""HMAC<S2SV_blank>Final<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ; rval = TPM_RC_MEMORY ; goto err ; } tmpResult . t . size = size ; <S2SV_ModEnd> <S2SV_ModStart> rval = TSS2_SYS_RC_BAD_VALUE ; goto err ; } } resultKey -> t . size = bytes ; err : HMAC_CTX_cleanup ( & ctx ) ; return rval <S2SV_ModEnd> ",01org@tpm2.0-tools/c5d72beaab1cbbbe68271f4bc4b6670d69985157,CVE-2017-7524,https://github.com/01org/tpm2.0-tools/commit/c5d72beaab1cbbbe68271f4bc4b6670d69985157,2017-06-27T14:29Z
121,CWE-190,"<S2SV_StartBug> cmpt = 0 ; <S2SV_EndBug> <S2SV_StartBug> ! jas_safe_intfast32_add ( tly , height , 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! jas_safe_size_mul ( cmpt -> width_ , cmpt -> height_ , & size ) || <S2SV_EndBug> ","<S2SV_ModStart> JAS_DBGLOG ( 100 , ( ""jas_image_cmpt_create(%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%d,<S2SV_blank>%d,<S2SV_blank>%d)\\n"" , JAS_CAST ( long , tlx ) , JAS_CAST ( long , tly ) , JAS_CAST ( long , hstep ) , JAS_CAST ( long , vstep ) , JAS_CAST ( long , width ) , JAS_CAST ( long , height ) , JAS_CAST ( int , depth ) , sgnd , inmem ) ) ; <S2SV_ModStart> , 0 ) ) { goto error ; } if ( ! jas_safe_intfast32_mul3 ( width , height , depth <S2SV_ModStart> jas_safe_size_mul3 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
122,CWE-369,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( s == 0 ) return ( ( void * ) NULL ) ; ,vadz@libtiff/3c5eb8b1be544e41d2c336191bc4936300ad7543,CVE-2014-8130,https://github.com/vadz/libtiff/commit/3c5eb8b1be544e41d2c336191bc4936300ad7543,2018-03-12T02:29Z
123,CWE-264,<S2SV_StartBug> if ( count < sizeof ( cmd . type ) ) { <S2SV_EndBug> ,<S2SV_ModStart> WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if ( ,torvalds@linux/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3,CVE-2016-4565,https://github.com/torvalds/linux/commit/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3,2016-05-23T10:59Z
124,CWE-200,<S2SV_StartBug> MinVal = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; ",ImageMagick@ImageMagick/51b0ae01709adc1e4a9245e158ef17b85a110960,CVE-2017-13143,https://github.com/ImageMagick/ImageMagick/commit/51b0ae01709adc1e4a9245e158ef17b85a110960,2017-08-23T06:29Z
125,CWE-416,<S2SV_StartBug> get_net ( peer ) ; <S2SV_EndBug> ,<S2SV_ModStart> peer = maybe_get_net <S2SV_ModEnd> ,torvalds@linux/21b5944350052d2583e82dd59b19a9ba94a007f0,CVE-2017-15129,https://github.com/torvalds/linux/commit/21b5944350052d2583e82dd59b19a9ba94a007f0,2018-01-09T19:29Z
126,CWE-000,<S2SV_StartBug> while ( header_buf [ i ] == '\\r' || header_buf [ i ] == '\\n' ) <S2SV_EndBug> ,<S2SV_ModStart> ( i < ( int ) header_buf_used ) && ( <S2SV_ModStart> ) ,miniupnp@miniupnp/3a87aa2f10bd7f1408e1849bdb59c41dd63a9fe9,CVE-2014-3985,https://github.com/miniupnp/miniupnp/commit/3a87aa2f10bd7f1408e1849bdb59c41dd63a9fe9,2014-09-11T18:55Z
127,CWE-617,<S2SV_StartBug> assert ( proto != LLDP_MGMT_ADDR_NONE ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( proto == LLDP_MGMT_ADDR_NONE ) continue <S2SV_ModEnd> ,vincentbernat@lldpd/793526f8884455f43daecd0a2c46772388417a00,CVE-2015-8012,https://github.com/vincentbernat/lldpd/commit/793526f8884455f43daecd0a2c46772388417a00,2020-01-28T19:15Z
128,CWE-310,<S2SV_StartBug> dp == datalen ) { <S2SV_EndBug> ,<S2SV_ModStart> ( op & ASN1_OP_MATCH__SKIP && <S2SV_ModStart> ) ,torvalds@linux/0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f,CVE-2016-2053,https://github.com/torvalds/linux/commit/0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f,2016-05-02T10:59Z
129,CWE-362,"<S2SV_StartBug> list_add_tail ( & sp -> auto_asconf_list , <S2SV_EndBug> <S2SV_StartBug> sp -> do_auto_asconf = 1 ; <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> sp -> do_auto_asconf = 0 ; <S2SV_EndBug> ",<S2SV_ModStart> spin_lock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; <S2SV_ModStart> ; spin_unlock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) <S2SV_ModStart> { <S2SV_ModStart> } ,torvalds@linux/2d45a02d0166caf2627fe91897c6ffc3b19514c4,CVE-2015-3212,https://github.com/torvalds/linux/commit/2d45a02d0166caf2627fe91897c6ffc3b19514c4,2015-08-31T10:59Z
130,CWE-476,"<S2SV_StartBug> static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb ) <S2SV_EndBug> <S2SV_StartBug> s -> avctx -> level = get_bits ( gb , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( s -> avctx -> profile == 0 && s -> avctx -> level == 8 ) { <S2SV_EndBug> <S2SV_StartBug> s -> avctx -> level = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> , int * profile , int * level ) { * <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModEnd> ",FFmpeg@FFmpeg/2aa9047486dbff12d9e040f917e5f799ed2fd78b,CVE-2018-13301,https://github.com/FFmpeg/FFmpeg/commit/2aa9047486dbff12d9e040f917e5f799ed2fd78b,2018-07-05T17:29Z
131,CWE-125,"<S2SV_StartBug> spin_lock_irqsave ( & mpu -> input_lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> while ( readw ( mpu -> dev -> MIDQ + JQS_wTail ) != <S2SV_EndBug> <S2SV_StartBug> wTmp = readw ( mpu -> dev -> MIDQ + JQS_wHead ) + 1 ; <S2SV_EndBug> ","<S2SV_ModStart> u16 head , tail , size ; <S2SV_ModStart> head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ; tail = readw ( mpu -> dev -> MIDQ + JQS_wTail ) ; size = readw ( mpu -> dev -> MIDQ + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { unsigned char val = readw ( pwMIDQData + 2 * head ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , & val <S2SV_ModEnd> <S2SV_ModStart> if ( ++ head > size ) head = 0 ; writew ( head , <S2SV_ModEnd> <S2SV_ModStart> ; } out : <S2SV_ModEnd> ",torvalds@linux/20e2b791796bd68816fa115f12be5320de2b8021,CVE-2017-9985,https://github.com/torvalds/linux/commit/20e2b791796bd68816fa115f12be5320de2b8021,2017-06-28T06:29Z
132,CWE-264,<S2SV_StartBug> return result ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! entry -> lsm [ lsm_rule ] . rule ) return - EINVAL ; ,torvalds@linux/867c20265459d30a01b021a9c1e81fb4c5832aa9,CVE-2011-0006,https://github.com/torvalds/linux/commit/867c20265459d30a01b021a9c1e81fb4c5832aa9,2012-06-21T23:55Z
133,CWE-17,<S2SV_StartBug> file_sb_list_del ( file ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/eee5cc2702929fd41cce28058dc6d6717f723f87,CVE-2014-8172,https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87,2015-03-16T10:59Z
134,CWE-20,<S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,libreswan@libreswan/2899351224fe2940aec37d7656e1e392c0fe07f0,CVE-2013-7294,https://github.com/libreswan/libreswan/commit/2899351224fe2940aec37d7656e1e392c0fe07f0,2014-01-16T05:05Z
135,CWE-79,"<S2SV_StartBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%s);\\n"" <S2SV_EndBug> <S2SV_StartBug> if ( s_poll_interval == NULL ) <S2SV_EndBug> <S2SV_StartBug> session_state , op_iframe_id , s_poll_interval , redirect_uri , <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%d);\\n"" <S2SV_ModEnd> <S2SV_ModStart> int poll_interval = s_poll_interval ? strtol ( s_poll_interval , NULL , 10 ) : 0 ; if ( ( poll_interval <= 0 ) || ( poll_interval > 3600 * 24 ) ) poll_interval = 3000 <S2SV_ModEnd> <S2SV_ModStart> poll_interval <S2SV_ModEnd> ",zmartzone@mod_auth_openidc/132a4111bf3791e76437619a66336dce2ce4c79b,CVE-2019-1010247,https://github.com/zmartzone/mod_auth_openidc/commit/132a4111bf3791e76437619a66336dce2ce4c79b,2019-07-19T15:15Z
136,CWE-189,"<S2SV_StartBug> size_t * acl_len ) <S2SV_EndBug> <S2SV_StartBug> __be32 * savep ; <S2SV_EndBug> <S2SV_StartBug> * acl_len = 0 ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ; <S2SV_EndBug> <S2SV_StartBug> dprintk ( ""NFS:<S2SV_blank>server<S2SV_blank>cheating<S2SV_blank>in<S2SV_blank>getattr"" <S2SV_EndBug> <S2SV_StartBug> * acl_len = attrlen ; <S2SV_EndBug> ","<S2SV_ModStart> struct nfs_getaclres * res <S2SV_ModEnd> <S2SV_ModStart> , * bm_p <S2SV_ModStart> res -> <S2SV_ModEnd> <S2SV_ModStart> ; bm_p = xdr -> p <S2SV_ModStart> xdr -> p = bm_p ; res -> acl_data_offset = be32_to_cpup ( bm_p ) + 2 ; res -> acl_data_offset <<= 2 ; <S2SV_ModStart> ; attrlen += res -> acl_data_offset <S2SV_ModStart> if ( res -> acl_flags & NFS4_ACL_LEN_REQUEST ) { res -> acl_len = attrlen ; goto out ; } dprintk ( ""NFS:<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\n"" <S2SV_ModEnd> <S2SV_ModStart> res -> <S2SV_ModEnd> ",torvalds@linux/bf118a342f10dafe44b14451a1392c3254629a1f,CVE-2011-4131,https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f,2012-05-17T11:00Z
137,CWE-125,<S2SV_StartBug> nexthdr = * prevhdr ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ; ,torvalds@linux/2423496af35d94a87156b063ea5cedffc10a70a1,CVE-2017-9074,https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1,2017-05-19T07:29Z
138,CWE-125,<S2SV_StartBug> while ( ( tmpName [ i ] != 0 ) && ( i < to_read ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( i < to_read ) && <S2SV_ModStart>  <S2SV_ModEnd> ,gpac@gpac/bceb03fd2be95097a7b409ea59914f332fb6bc86,CVE-2018-13006,https://github.com/gpac/gpac/commit/bceb03fd2be95097a7b409ea59914f332fb6bc86,2018-06-29T14:29Z
139,CWE-189,"<S2SV_StartBug> long rem ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> ",<S2SV_ModStart> u32 <S2SV_ModEnd> <S2SV_ModStart> div_u64_rem <S2SV_ModEnd> ,torvalds@linux/f8bd2258e2d520dff28c855658bd24bdafb5102d,CVE-2011-3209,https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d,2012-10-03T11:02Z
140,CWE-119,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && in -> linesize [ plane ] ,FFmpeg@FFmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,CVE-2013-4263,https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,2013-11-23T17:55Z
141,CWE-119,"<S2SV_StartBug> strncpy ( szFileName , sizeof ( szFileName ) - 5 , pszFileName ) ; <S2SV_EndBug> ","<S2SV_ModStart> pszFileName , <S2SV_ModStart>  <S2SV_ModEnd> ",lurcher@unixODBC/45ef78e037f578b15fc58938a3a3251655e71d6f,CVE-2018-7485,https://github.com/lurcher/unixODBC/commit/45ef78e037f578b15fc58938a3a3251655e71d6f,2018-02-26T14:29Z
142,CWE-000,"<S2SV_StartBug> owner = stok ( auth , "":"" , & tok ) ; <S2SV_EndBug> <S2SV_StartBug> group = stok ( tok , "":"" , & perms ) ; <S2SV_EndBug> ",<S2SV_ModStart> ssplit <S2SV_ModEnd> <S2SV_ModStart> ssplit <S2SV_ModEnd> ,embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z
143,CWE-119,"<S2SV_StartBug> q = ( const uint8_t * ) ( const void * ) <S2SV_EndBug> <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ; <S2SV_EndBug> <S2SV_StartBug> DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , <S2SV_EndBug> <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <S2SV_ModStart> ofs <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> i , <S2SV_ModEnd> <S2SV_ModStart> offs <S2SV_ModEnd> ",glensc@file/1aec04dbf8a24b8a6ba64c4f74efa0628e36db0b,CVE-2012-1571,https://github.com/glensc/file/commit/1aec04dbf8a24b8a6ba64c4f74efa0628e36db0b,2012-07-17T21:55Z
144,CWE-362,<S2SV_StartBug> if ( inet -> opt && inet -> opt -> srr ) <S2SV_EndBug> ,"<S2SV_ModStart> struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . <S2SV_ModEnd> ",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z
145,CWE-119,"<S2SV_StartBug> pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" <S2SV_EndBug> ",<S2SV_ModStart> pr_debug <S2SV_ModEnd> ,torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z
146,CWE-125,"<S2SV_StartBug> tlen = len - sizeof ( struct eigrp_common_header ) ; <S2SV_EndBug> <S2SV_StartBug> tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>holdtime:<S2SV_blank>%us,<S2SV_blank>k1<S2SV_blank>%u,<S2SV_blank>k2<S2SV_blank>%u,<S2SV_blank>k3<S2SV_blank>%u,<S2SV_blank>k4<S2SV_blank>%u,<S2SV_blank>k5<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IOS<S2SV_blank>version:<S2SV_blank>%u.%u,<S2SV_blank>EIGRP<S2SV_blank>version<S2SV_blank>%u.%u"" , <S2SV_EndBug> <S2SV_StartBug> bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ; <S2SV_EndBug> <S2SV_StartBug> bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-range:<S2SV_blank>%u-%u,<S2SV_blank>Router-ID<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" , <S2SV_EndBug> ","<S2SV_ModStart> if ( len < sizeof ( struct eigrp_common_header ) ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , tok2str ( eigrp_opcode_values , ""unknown<S2SV_blank>(%u)"" , eigrp_com_header -> opcode ) , len , ( u_int ) sizeof ( struct eigrp_common_header ) ) ) ; return ; } <S2SV_ModStart> if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) sizeof ( struct eigrp_tlv_header ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) ) ) ; break ; } ",the-tcpdump-group@tcpdump/de981e6070d168b58ec1bb0713ded77ed4ad87f4,CVE-2017-12901,https://github.com/the-tcpdump-group/tcpdump/commit/de981e6070d168b58ec1bb0713ded77ed4ad87f4,2017-09-14T06:29Z
147,CWE-119,<S2SV_StartBug> # if CONFIG_MEM_MANAGER <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart> addr = malloc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
148,CWE-20,"<S2SV_StartBug> int indexes = SQUASHFS_LOOKUP_BLOCKS ( sBlk . s . inodes ) ; <S2SV_EndBug> <S2SV_StartBug> long long export_index_table [ indexes ] ; <S2SV_EndBug> <S2SV_StartBug> res = read_fs_bytes ( fd , sBlk . s . lookup_table_start , <S2SV_EndBug> ","<S2SV_ModStart> ( long long ) sBlk . s . inodes ) ; int length = SQUASHFS_LOOKUP_BLOCK_BYTES ( ( long long ) <S2SV_ModStart> * export_index_table ; if ( length != ( * table_start - sBlk . s . lookup_table_start ) ) { ERROR ( ""parse_exports_table:<S2SV_blank>Bad<S2SV_blank>inode<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; return FALSE ; } export_index_table = alloc_index_table ( indexes ) <S2SV_ModEnd> <S2SV_ModStart> length , <S2SV_ModEnd> ",plougher@squashfs-tools/f95864afe8833fe3ad782d714b41378e860977b1,CVE-2015-4646,https://github.com/plougher/squashfs-tools/commit/f95864afe8833fe3ad782d714b41378e860977b1,2017-04-13T17:59Z
149,CWE-000,"<S2SV_StartBug> ptr = strchr ( ptr + 1 , '/' ) + 1 ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( ptr == NULL ) return ( ENOENT ) ; ptr ++ <S2SV_ModEnd> ,illumos@illumos-gate/d65686849024838243515b5c40ae2c479460b4b5,CVE-2014-9491,https://github.com/illumos/illumos-gate/commit/d65686849024838243515b5c40ae2c479460b4b5,2015-01-20T15:59Z
150,CWE-362,<S2SV_StartBug> flags |= EXT4_GET_BLOCKS_PRE_IO ; <S2SV_EndBug> ,<S2SV_ModStart> if ( flags & EXT4_GET_BLOCKS_CONVERT ) split_flag |= EXT4_EXT_DATA_VALID2 ; ,torvalds@linux/dee1f973ca341c266229faa5a1a5bb268bed3531,CVE-2012-4508,https://github.com/torvalds/linux/commit/dee1f973ca341c266229faa5a1a5bb268bed3531,2012-12-21T11:47Z
151,CWE-285,"<S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & new_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode , & new_mode , & acl ) ; if ( ret ) goto out <S2SV_ModEnd> ",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z
152,CWE-611,"<S2SV_StartBug> else return apr_psprintf ( cmd -> pool , ""ModSecurity:<S2SV_blank>Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>SecRuleEngine:<S2SV_blank>%s"" , p1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""ModSecurity:<S2SV_blank>Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>SexHashEngine:<S2SV_blank>%s"" <S2SV_ModEnd> ",SpiderLabs@ModSecurity/d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe,CVE-2013-1915,https://github.com/SpiderLabs/ModSecurity/commit/d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe,2013-04-25T23:55Z
153,CWE-416,"<S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> ","<S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) , & final ) ; rcu_read_unlock ( <S2SV_ModEnd> ",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
154,CWE-119,"<S2SV_StartBug> uint16 nstrips = 0 , ntiles = 0 , planar = 0 ; <S2SV_EndBug> <S2SV_StartBug> read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ","<S2SV_ModStart> uint32 nstrips = 0 , ntiles = 0 ; uint16 <S2SV_ModEnd> <S2SV_ModStart> { if ( buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } <S2SV_ModStart> } <S2SV_ModStart> if ( buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } ",vadz@libtiff/83a4b92815ea04969d494416eaae3d4c6b338e4a,CVE-2016-9537,https://github.com/vadz/libtiff/commit/83a4b92815ea04969d494416eaae3d4c6b338e4a,2016-11-22T19:59Z
155,CWE-119,"<S2SV_StartBug> if ( 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( 0 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( arg_match ( & arg , & stereo_mode , argi ) ) { <S2SV_EndBug> <S2SV_StartBug> config -> stereo_fmt = arg_parse_enum_or_int ( & arg ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( arg_match ( & arg , & resize_up_thresh , argi ) ) { <S2SV_EndBug> <S2SV_StartBug> config -> cfg . kf_mode = VPX_KF_DISABLED ; <S2SV_EndBug> <S2SV_StartBug> if ( config -> arg_ctrls [ j ] [ 0 ] == ctrl_args_map [ i ] ) <S2SV_EndBug> <S2SV_StartBug> assert ( j < ARG_CTRL_CNT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> if ( j < ARG_CTRL_CNT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> return eos_mark_found ; <S2SV_EndBug> ","<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH int test_16bit_internal = 0 ; # endif <S2SV_ModStart> # if CONFIG_VP10_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp10"" ) == 0 ) { ctrl_args = vp10_args ; ctrl_args_map = vp10_arg_ctrl_map ; # endif <S2SV_ModStart> arg_match ( & arg , & outputfile , argi ) ) { config -> out_fn = arg . val ; } else if ( arg_match ( & arg , & fpf_name , argi ) ) { config -> stats_fn = arg . val ; # if CONFIG_FP_MB_STATS } else if ( arg_match ( & arg , & fpmbf_name , argi ) ) { config -> fpmb_stats_fn = arg . val ; # endif } else if ( arg_match ( & arg , & use_webm , argi ) ) { # if CONFIG_WEBM_IO config -> write_webm = 1 ; # else die ( ""Error:<S2SV_blank>--webm<S2SV_blank>specified<S2SV_blank>but<S2SV_blank>webm<S2SV_blank>is<S2SV_blank>disabled."" ) ; # endif } else if ( arg_match ( & arg , & use_ivf , argi ) ) { config -> write_webm = 0 <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH } else if ( arg_match ( & arg , & bitdeptharg , argi ) ) { config -> cfg . g_bit_depth = arg_parse_enum_or_int ( & arg ) ; } else if ( arg_match ( & arg , & inbitdeptharg , argi ) ) { config -> cfg . g_input_bit_depth = arg_parse_uint ( & arg ) ; # endif # if CONFIG_WEBM_IO <S2SV_ModStart> # endif <S2SV_ModStart> resize_width , argi ) ) { config -> cfg . rc_scaled_width = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & resize_height , argi ) ) { config -> cfg . rc_scaled_height = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH } else if ( arg_match ( & arg , & test16bitinternalarg , argi ) ) { if ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 || strcmp ( global -> codec -> name , ""vp10"" ) == 0 ) { test_16bit_internal = 1 ; } # endif <S2SV_ModStart> ctrl_args_map != NULL && <S2SV_ModStart> ( int ) <S2SV_ModStart> ctrl_args_map != NULL && j < ( int ) <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 || strcmp ( global -> codec -> name , ""vp10"" ) == 0 ) { config -> use_16bit_internal = test_16bit_internal | ( config -> cfg . g_profile > 1 ) ; } # endif ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
156,CWE-264,<S2SV_StartBug> || no_port_forwarding_flag || options . disable_forwarding ) { <S2SV_EndBug> ,<S2SV_ModStart> || ! use_privsep ,openbsd@src/c76fac666ea038753294f2ac94d310f8adece9ce,CVE-2016-10010,https://github.com/openbsd/src/commit/c76fac666ea038753294f2ac94d310f8adece9ce,2017-01-05T02:59Z
157,CWE-264,<S2SV_StartBug> dev -> netdev_ops = & l2tp_eth_netdev_ops ; <S2SV_EndBug> ,<S2SV_ModStart> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> ,torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z
158,CWE-400,<S2SV_StartBug> for ( ; offset < ( MagickOffsetType ) cin . file . image_offset ; offset ++ ) <S2SV_EndBug> ,"<S2SV_ModStart> if ( ( ( MagickSizeType ) image -> columns * image -> rows ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; ",ImageMagick@ImageMagick/e3cdce6fe12193f235b8c0ae5efe6880a25eb957,CVE-2019-11470,https://github.com/ImageMagick/ImageMagick/commit/e3cdce6fe12193f235b8c0ae5efe6880a25eb957,2019-04-23T14:29Z
159,CWE-200,"<S2SV_StartBug> if ( ( gr -> gr_ctx . value = mem_alloc ( sizeof ( gss_union_ctx_id_desc ) ) ) == NULL ) { <S2SV_EndBug> <S2SV_StartBug> memcpy ( gr -> gr_ctx . value , gd -> ctx , sizeof ( gss_union_ctx_id_desc ) ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""xxxx"" ; <S2SV_ModEnd> <S2SV_ModStart> length = 4 <S2SV_ModEnd> ",krb5@krb5/5bb8a6b9c9eb8dd22bc9526751610aaa255ead9c,CVE-2014-9423,https://github.com/krb5/krb5/commit/5bb8a6b9c9eb8dd22bc9526751610aaa255ead9c,2015-02-19T11:59Z
160,CWE-200,"<S2SV_StartBug> if ( ext_depth ( inode ) ) <S2SV_EndBug> <S2SV_StartBug> memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data , <S2SV_EndBug> <S2SV_StartBug> sizeof ( EXT4_I ( inode ) -> i_data ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t ext_size = 0 ; <S2SV_ModStart> ext_size = sizeof ( EXT4_I ( inode ) -> i_data ) ; <S2SV_ModStart> ext_size ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size <S2SV_ModEnd> ",torvalds@linux/592acbf16821288ecdc4192c47e3774a4c48bb64,CVE-2019-11833,https://github.com/torvalds/linux/commit/592acbf16821288ecdc4192c47e3774a4c48bb64,2019-05-15T13:29Z
161,CWE-295,"<S2SV_StartBug> if ( verify_checks ( c , preverify_ok , callback_ctx ) ) { <S2SV_EndBug> <S2SV_StartBug> ( void * ) ( - 1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( c -> opt -> option . client || c -> opt -> protocol ) <S2SV_EndBug> <S2SV_StartBug> if ( c -> opt -> redirect_addr . names ) <S2SV_EndBug> ",<S2SV_ModStart> return 1 ; if ( c -> opt -> option . client || c -> opt -> protocol ) return 0 ; if ( c -> opt -> redirect_addr . names ) <S2SV_ModStart> NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z
162,CWE-264,<S2SV_StartBug> int ret ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( current_chrooted ( ) ) return - EPERM ,torvalds@linux/3151527ee007b73a0ebd296010f1c0454a919c7d,CVE-2013-1956,https://github.com/torvalds/linux/commit/3151527ee007b73a0ebd296010f1c0454a919c7d,2013-04-24T19:55Z
163,CWE-203,"<S2SV_StartBug> if ( memcmp ( cmac , computed_cmac , AT91_AES_BLOCK_SIZE_BYTE ) ) <S2SV_EndBug> ",<S2SV_ModStart> ! consttime_memequal <S2SV_ModEnd> ,linux4sam@at91bootstrap/7753914c9a622c245f3a3cf2af5e24b6a9904213,CVE-2020-11683,https://github.com/linux4sam/at91bootstrap/commit/7753914c9a622c245f3a3cf2af5e24b6a9904213,2020-09-14T14:15Z
164,CWE-20,<S2SV_StartBug> if ( c -> nreslevels < s -> reduction_factor ) <S2SV_EndBug> <S2SV_StartBug> c -> nreslevels2decode = 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> <= <S2SV_ModEnd> <S2SV_ModStart> { av_log ( s -> avctx , AV_LOG_ERROR , ""reduction_factor<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>this<S2SV_blank>bitstream,<S2SV_blank>max<S2SV_blank>is<S2SV_blank>%d\\n"" , c -> nreslevels - 1 ) ; s -> reduction_factor = c -> nreslevels - 1 ; return AVERROR ( EINVAL ) ; } <S2SV_ModEnd> ",FFmpeg@FFmpeg/a1b9004b768bef606ee98d417bceb9392ceb788d,CVE-2013-7019,https://github.com/FFmpeg/FFmpeg/commit/a1b9004b768bef606ee98d417bceb9392ceb788d,2013-12-09T16:36Z
165,CWE-000,"<S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> ","<S2SV_ModStart> | CVAR_PROTECTED <S2SV_ModStart> if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; } ",JACoders@OpenJK/b248763e4878ef12d5835ece6600be8334f67da1,CVE-2017-6903,https://github.com/JACoders/OpenJK/commit/b248763e4878ef12d5835ece6600be8334f67da1,2017-03-14T22:59Z
166,CWE-119,<S2SV_StartBug> bool is_drop_n_account = false ; <S2SV_EndBug> <S2SV_StartBug> if ( po -> has_vnet_hdr ) <S2SV_EndBug> <S2SV_StartBug> macoff = netoff - maclen ; <S2SV_EndBug> <S2SV_StartBug> if ( ( int ) snaplen < 0 ) <S2SV_EndBug> <S2SV_StartBug> snaplen = 0 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( po -> has_vnet_hdr ) { <S2SV_EndBug> ,<S2SV_ModStart> = false ; bool do_vnet <S2SV_ModStart> { <S2SV_ModStart> do_vnet = true ; } <S2SV_ModStart> { <S2SV_ModStart> do_vnet = false ; } <S2SV_ModStart> do_vnet = false ; <S2SV_ModStart> do_vnet <S2SV_ModEnd> ,torvalds@linux/edbd58be15a957f6a760c4a514cd475217eb97fd,CVE-2017-14497,https://github.com/torvalds/linux/commit/edbd58be15a957f6a760c4a514cd475217eb97fd,2017-09-15T18:29Z
167,CWE-000,<S2SV_StartBug> sctp_auth_key_put ( asoc -> asoc_shared_key ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/600ddd6825543962fb807884169e57b580dba208,CVE-2015-1421,https://github.com/torvalds/linux/commit/600ddd6825543962fb807884169e57b580dba208,2015-03-16T10:59Z
168,CWE-284,<S2SV_StartBug> return true ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ndp_msg_type_info ( msg_type ) -> addrto_validate ) return ndp_msg_type_info ( msg_type ) -> addrto_validate ( & msg -> addrto ) ; else ,jpirko@libndp/2af9a55b38b55abbf05fd116ec097d4029115839,CVE-2016-3698,https://github.com/jpirko/libndp/commit/2af9a55b38b55abbf05fd116ec097d4029115839,2016-06-13T19:59Z
169,CWE-264,"<S2SV_StartBug> int lsm_set_label_at ( int procfd , int on_exec , char * lsm_label ) { <S2SV_EndBug> <S2SV_StartBug> int labelfd = - 1 ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> if ( on_exec ) { <S2SV_EndBug> <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( write ( labelfd , command , size + 1 ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label"" ) ; <S2SV_EndBug> <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( labelfd != - 1 ) <S2SV_EndBug> <S2SV_StartBug> close ( labelfd ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> static <S2SV_ModStart> lsm_labelfd <S2SV_ModEnd> <S2SV_ModStart> { int fret <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return 0 <S2SV_ModEnd> <S2SV_ModStart> return 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lsm_labelfd <S2SV_ModEnd> <S2SV_ModStart> ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label:<S2SV_blank>%s."" , command ) ; goto out ; } INFO ( ""Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s."" , command ) ; } else if ( strcmp ( name , ""SELinux"" ) == 0 ) { if ( write ( lsm_labelfd , lsm_label , strlen ( lsm_label ) + 1 ) < 0 ) { SYSERROR ( <S2SV_ModStart> goto out ; } INFO ( ""Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s."" , lsm_label ) ; } else <S2SV_ModEnd> <S2SV_ModStart> goto out ; } fret = 0 ; <S2SV_ModEnd> <S2SV_ModStart> lsm_labelfd <S2SV_ModEnd> <S2SV_ModStart> lsm_labelfd <S2SV_ModEnd> <S2SV_ModStart> fret <S2SV_ModEnd> ",lxc@lxc/81f466d05f2a89cb4f122ef7f593ff3f279b165c,CVE-2016-8649,https://github.com/lxc/lxc/commit/81f466d05f2a89cb4f122ef7f593ff3f279b165c,2017-05-01T06:59Z
170,CWE-369,<S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ,<S2SV_ModStart> rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if ( ,uclouvain@openjpeg/d27ccf01c68a31ad62b33d2dc1ba2bb1eeaafe7b,CVE-2016-10506,https://github.com/uclouvain/openjpeg/commit/d27ccf01c68a31ad62b33d2dc1ba2bb1eeaafe7b,2017-08-30T09:29Z
171,CWE-399,"<S2SV_StartBug> struct pt_regs * regs , int nmi ) <S2SV_EndBug> <S2SV_StartBug> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
172,CWE-119,"<S2SV_StartBug> # ifdef DISABLE_RC_LONG_TERM_MEM <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> common . frame_type == KEY_FRAME ) { <S2SV_EndBug> <S2SV_StartBug> cpi -> twopass . gf_group_bits -= bits_used ; <S2SV_EndBug> <S2SV_StartBug> cpi -> twopass . gf_group_bits = MAX ( cpi -> twopass . gf_group_bits , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> TWO_PASS * const twopass = & cpi -> twopass ; RATE_CONTROL * const rc = & cpi -> rc ; const int bits_used = rc -> base_frame_target ; rc -> vbr_bits_off_target += rc -> base_frame_target - rc -> projected_frame_size ; twopass -> bits_left = MAX ( twopass -> bits_left - bits_used , 0 ) ; if ( rc -> total_actual_bits ) { rc -> rate_error_estimate = ( int ) ( ( rc -> vbr_bits_off_target * 100 ) / rc -> total_actual_bits ) ; rc -> rate_error_estimate = clamp ( rc -> rate_error_estimate , - 100 , 100 ) ; } else { rc -> rate_error_estimate = 0 ; } <S2SV_ModEnd> <S2SV_ModStart> != KEY_FRAME && ! vp9_is_upper_layer_key_frame ( cpi ) ) { twopass -> <S2SV_ModEnd> <S2SV_ModStart> twopass -> last_kfgroup_zeromotion_pct = twopass -> kf_zeromotion_pct ; } twopass -> kf_group_bits <S2SV_ModEnd> <S2SV_ModStart> twopass -> kf_group_bits <S2SV_ModEnd> <S2SV_ModStart> ++ twopass -> gf_group . index ; if ( ( cpi -> oxcf . rc_mode != VPX_Q ) && ( cpi -> twopass . gf_zeromotion_pct < VLOW_MOTION_THRESHOLD ) && ! cpi -> rc . is_src_frame_alt_ref ) { const int maxq_adj_limit = rc -> worst_quality - twopass -> active_worst_quality ; const int minq_adj_limit = ( cpi -> oxcf . rc_mode == VPX_CQ ? MINQ_ADJ_LIMIT_CQ : MINQ_ADJ_LIMIT ) ; if ( rc -> rate_error_estimate > cpi -> oxcf . under_shoot_pct ) { -- twopass -> extend_maxq ; if ( rc -> rolling_target_bits >= rc -> rolling_actual_bits ) ++ twopass -> extend_minq ; } else if ( rc -> rate_error_estimate < - cpi -> oxcf . over_shoot_pct ) { -- twopass -> extend_minq ; if ( rc -> rolling_target_bits < rc -> rolling_actual_bits ) ++ twopass -> extend_maxq ; } else { if ( rc -> projected_frame_size > ( 2 * rc -> base_frame_target ) && rc -> projected_frame_size > ( 2 * rc -> avg_frame_bandwidth ) ) ++ twopass -> extend_maxq ; if ( rc -> rolling_target_bits < rc -> rolling_actual_bits ) -- twopass -> extend_minq ; else if ( rc -> rolling_target_bits > rc -> rolling_actual_bits ) -- twopass -> extend_maxq ; } twopass -> extend_minq = clamp ( twopass -> extend_minq , 0 , minq_adj_limit ) ; twopass -> extend_maxq = clamp ( twopass -> extend_maxq , 0 , maxq_adj_limit ) ; if ( ! frame_is_kf_gf_arf ( cpi ) && ! cpi -> rc . is_src_frame_alt_ref ) { int fast_extra_thresh = rc -> base_frame_target / HIGH_UNDERSHOOT_RATIO ; if ( rc -> projected_frame_size < fast_extra_thresh ) { rc -> vbr_bits_off_target_fast += fast_extra_thresh - rc -> projected_frame_size ; rc -> vbr_bits_off_target_fast = MIN ( rc -> vbr_bits_off_target_fast , ( 4 * rc -> avg_frame_bandwidth ) ) ; if ( rc -> avg_frame_bandwidth ) { twopass -> extend_minq_fast = ( int ) ( rc -> vbr_bits_off_target_fast * 8 / rc -> avg_frame_bandwidth ) ; } twopass -> extend_minq_fast = MIN ( twopass -> extend_minq_fast , minq_adj_limit - twopass -> extend_minq ) ; } else if ( rc -> vbr_bits_off_target_fast ) { twopass -> extend_minq_fast = MIN ( twopass -> extend_minq_fast , minq_adj_limit - twopass -> extend_minq ) ; } else { twopass -> extend_minq_fast = 0 ; } } } <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
173,CWE-189,<S2SV_StartBug> num ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( num > MaxAllocSize / ITEMSIZE ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , num , ( int ) ( MaxAllocSize / ITEMSIZE ) ) ) ) ",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z
174,CWE-19,"<S2SV_StartBug> struct mb_cache_entry * * pce ) <S2SV_EndBug> <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> again : <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev , <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( ce ) ) { <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_find_next ( ce , inode -> i_sb -> s_bdev , hash ) ; <S2SV_EndBug> ","<S2SV_ModStart> mb2_cache_entry <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_entry * ce ; struct mb2_cache <S2SV_ModEnd> <S2SV_ModStart> ce = mb2_cache_entry_find_first <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_entry_find_next ( ext4_mb_cache , ce <S2SV_ModEnd> ",torvalds@linux/82939d7999dfc1f1998c4b1c12e2f19edbdff272,CVE-2015-8952,https://github.com/torvalds/linux/commit/82939d7999dfc1f1998c4b1c12e2f19edbdff272,2016-10-16T21:59Z
175,CWE-119,"<S2SV_StartBug> gint64 offset ; <S2SV_EndBug> <S2SV_StartBug> pkt_len = parse_cosine_rec_hdr ( & wth -> phdr , line , err , err_info ) ; <S2SV_EndBug> <S2SV_StartBug> return parse_cosine_hex_dump ( wth -> fh , & wth -> phdr , pkt_len , <S2SV_EndBug> <S2SV_StartBug> wth -> frame_buffer , err , err_info ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return parse_cosine_packet <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , line ",wireshark@wireshark/f5ec0afb766f19519ea9623152cca3bbe2229500,CVE-2016-5356,https://github.com/wireshark/wireshark/commit/f5ec0afb766f19519ea9623152cca3bbe2229500,2016-08-07T16:59Z
176,CWE-476,<S2SV_StartBug> if ( pkt == NULL ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,libgit2@libgit2/2fdef641fd0dd2828bd948234ae86de75221a11a,CVE-2016-10129,https://github.com/libgit2/libgit2/commit/2fdef641fd0dd2828bd948234ae86de75221a11a,2017-03-24T15:59Z
177,CWE-000,<S2SV_StartBug> if ( left > 0 && n > left ) <S2SV_EndBug> ,<S2SV_ModStart> == 0 && extend ) return 0 ; if ( left ,openssl@openssl/feba02f3919495e1b960c33ba849e10e77d0785d,CVE-2014-3571,https://github.com/openssl/openssl/commit/feba02f3919495e1b960c33ba849e10e77d0785d,2015-01-09T02:59Z
178,CWE-119,"<S2SV_StartBug> # ifndef _MSC_VER <S2SV_EndBug> <S2SV_StartBug> char buf [ EXT2_BLOCK_SIZE ( data ) ] ; <S2SV_EndBug> <S2SV_StartBug> grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> return fileblock + start ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! indir ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> if ( ! indir ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> ",<S2SV_ModStart> char * buf = grub_malloc ( <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( ! buf ) { return - 1 ; } <S2SV_ModEnd> <S2SV_ModStart> ) ; free ( buf <S2SV_ModStart> { free ( buf ) ; <S2SV_ModStart> } <S2SV_ModStart> free ( buf ) ; <S2SV_ModStart> free ( buf ) ; <S2SV_ModStart> free ( buf ) ; <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } ,radare@radare2/65000a7fd9eea62359e6d6714f17b94a99a82edd,CVE-2017-9763,https://github.com/radare/radare2/commit/65000a7fd9eea62359e6d6714f17b94a99a82edd,2017-06-19T16:29Z
179,CWE-119,"<S2SV_StartBug> UnpackRaster : <S2SV_EndBug> <S2SV_StartBug> image -> rows = Bitmap2Header1 . Height ; <S2SV_EndBug> <S2SV_StartBug> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; <S2SV_EndBug> ","<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; <S2SV_ModStart> ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break <S2SV_ModStart>  <S2SV_ModEnd> ",ImageMagick@ImageMagick/fc43974d34318c834fbf78570ca1a3764ed8c7d7,CVE-2016-5688,https://github.com/ImageMagick/ImageMagick/commit/fc43974d34318c834fbf78570ca1a3764ed8c7d7,2016-12-13T15:59Z
180,CWE-362,"<S2SV_StartBug> if ( copy_from_user ( buf , ( void * ) arg , hdr . size_in ) ) { <S2SV_EndBug> ","<S2SV_ModStart> * ( ( struct vbg_ioctl_hdr * ) buf ) = hdr ; <S2SV_ModStart> + sizeof ( hdr ) <S2SV_ModStart> + sizeof ( hdr ) , hdr . size_in - sizeof ( hdr ) <S2SV_ModEnd> ",torvalds@linux/bd23a7269834dc7c1f93e83535d16ebc44b75eba,CVE-2018-12633,https://github.com/torvalds/linux/commit/bd23a7269834dc7c1f93e83535d16ebc44b75eba,2018-06-22T00:29Z
181,CWE-119,"<S2SV_StartBug> int hstartcol ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> hstartcol = ( numrows + 1 - parity ) >> 1 ; <S2SV_EndBug> <S2SV_StartBug> m = numrows - hstartcol ; <S2SV_EndBug> <S2SV_StartBug> dstptr = & a [ hstartcol * stride ] ; <S2SV_EndBug> ","<S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> jas_alloc3 <S2SV_ModEnd> <S2SV_ModStart> JPC_QMFB_COLGRPSIZE , <S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> hstartrow <S2SV_ModEnd> ",mdadams@jasper/4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a,CVE-2016-8654,https://github.com/mdadams/jasper/commit/4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a,2018-08-01T16:29Z
182,CWE-125,"<S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> <S2SV_StartBug> height ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""ImproperImageHeader"" <S2SV_ModEnd> <S2SV_ModStart> ""ImproperImageHeader"" <S2SV_ModEnd> <S2SV_ModStart> ""ImproperImageHeader"" <S2SV_ModEnd> <S2SV_ModStart> else { if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; } ",ImageMagick@ImageMagick/6b4aff0f117b978502ee5bcd6e753c17aec5a961,CVE-2015-8958,https://github.com/ImageMagick/ImageMagick/commit/6b4aff0f117b978502ee5bcd6e753c17aec5a961,2017-04-20T18:59Z
183,CWE-20,"<S2SV_StartBug> char <S2SV_EndBug> <S2SV_StartBug> count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; <S2SV_EndBug> <S2SV_StartBug> image -> page . x = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> image -> page . y = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> one = 1 ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> <S2SV_StartBug> colormap = ( unsigned char * ) NULL ; <S2SV_EndBug> <S2SV_StartBug> colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , <S2SV_EndBug> <S2SV_StartBug> if ( colormap == ( unsigned char * ) NULL ) <S2SV_EndBug> <S2SV_StartBug> ReadBlobLSBShort ( image ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> <S2SV_StartBug> do <S2SV_EndBug> <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> plane = ( unsigned char ) operand ; <S2SV_EndBug> <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> <S2SV_StartBug> } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; <S2SV_EndBug> <S2SV_StartBug> ValidateColormapValue ( image , * p & mask , & index , exception ) ; <S2SV_EndBug> <S2SV_StartBug> ValidateColormapValue ( image , ( size_t ) ( x * map_length + <S2SV_EndBug> <S2SV_StartBug> SetPixelIndex ( image , * p ++ , q ) ; <S2SV_EndBug> ","<S2SV_ModStart> # define ThrowRLEException ( exception , message ) \\\n{ if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; \\\n} <S2SV_ModStart> colormap = ( unsigned char * ) NULL ; pixel_info = ( MemoryInfo * ) NULL ; <S2SV_ModStart> ( ssize_t ) <S2SV_ModStart> ( ssize_t ) <S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> ThrowRLEException ( <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( number_colormaps != 0 ) { <S2SV_ModEnd> <S2SV_ModStart> AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == <S2SV_ModEnd> <S2SV_ModStart> NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) { * p ++ = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> ThrowRLEException ( <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> { <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> { <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> { <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } offset = ( ssize_t ) ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> ( offset + <S2SV_ModEnd> <S2SV_ModStart> ( ssize_t ) <S2SV_ModStart> == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> { <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> ( ssize_t ) ( <S2SV_ModStart> ) <S2SV_ModStart> ( offset + <S2SV_ModEnd> <S2SV_ModStart> ( ssize_t ) <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> ( ssize_t ) ( <S2SV_ModStart> ) <S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ( Quantum ) ",ImageMagick@ImageMagick/f6240ee77847787f6d7618b669d3a2040a2d6d40,CVE-2017-9144,https://github.com/ImageMagick/ImageMagick/commit/f6240ee77847787f6d7618b669d3a2040a2d6d40,2017-05-22T14:29Z
184,CWE-19,<S2SV_StartBug> ext2_xattr_put_super ( sb ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sbi -> s_mb_cache ) { ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } <S2SV_ModEnd> ,torvalds@linux/be0726d33cb8f411945884664924bed3cb8c70ee,CVE-2015-8952,https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee,2016-10-16T21:59Z
185,CWE-000,<S2SV_StartBug> endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( usbinterface -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & usbinterface -> dev , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n"" ) ; error = - EINVAL ; goto err_free_urb ; } ",torvalds@linux/162f98dea487206d9ab79fc12ed64700667a894d,CVE-2016-2187,https://github.com/torvalds/linux/commit/162f98dea487206d9ab79fc12ed64700667a894d,2016-05-02T10:59Z
186,CWE-269,<S2SV_StartBug> if ( ! cfg . shell ) <S2SV_EndBug> <S2SV_StartBug> arg [ 0 ] = cfg . shell ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""/bin/sh"" <S2SV_ModEnd> ",netblue30@firejail/5d43fdcd215203868d440ffc42036f5f5ffc89fc,CVE-2017-5207,https://github.com/netblue30/firejail/commit/5d43fdcd215203868d440ffc42036f5f5ffc89fc,2017-03-23T16:59Z
187,CWE-476,<S2SV_StartBug> return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( node -> nd_item . ci_parent ) <S2SV_ModStart> else return NULL ; ,torvalds@linux/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,CVE-2017-18216,https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,2018-03-05T18:29Z
188,CWE-000,"<S2SV_StartBug> static void nfs_set_open_stateid ( struct nfs4_state * state , nfs4_stateid * stateid , int open_flags ) <S2SV_EndBug> <S2SV_StartBug> nfs_set_open_stateid_locked ( state , stateid , open_flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> ,torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z
189,CWE-834,<S2SV_StartBug> uint32_t vsize = avio_rb32 ( pb ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ,FFmpeg@FFmpeg/4f05e2e2dc1a89f38cd9f0960a6561083d714f1e,CVE-2017-14055,https://github.com/FFmpeg/FFmpeg/commit/4f05e2e2dc1a89f38cd9f0960a6561083d714f1e,2017-08-31T15:29Z
190,CWE-189,<S2SV_StartBug> if ( q > e ) { <S2SV_EndBug> ,<S2SV_ModStart> < p || q ,file@file/7ba1409a1aee5925180de546057ddd84ff267947,CVE-2014-3587,https://github.com/file/file/commit/7ba1409a1aee5925180de546057ddd84ff267947,2014-08-23T01:55Z
191,CWE-20,<S2SV_StartBug> # ifdef AUTOKEY <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,ntp-project@ntp/52e977d79a0c4ace997e5c74af429844da2f27be,CVE-2015-5195,https://github.com/ntp-project/ntp/commit/52e977d79a0c4ace997e5c74af429844da2f27be,2017-07-21T14:29Z
192,CWE-264,"<S2SV_StartBug> char * dir = ""/etc"" ; <S2SV_EndBug> <S2SV_StartBug> if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) { <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""/etc"" , "".vipw"" <S2SV_ModEnd> ",karelzak@util-linux/bde91c85bdc77975155058276f99d2e0f5eab5a9,CVE-2015-5224,https://github.com/karelzak/util-linux/commit/bde91c85bdc77975155058276f99d2e0f5eab5a9,2017-08-23T15:29Z
193,CWE-400,"<S2SV_StartBug> attach_shadowed ( mnt , parent , shadows ) ; <S2SV_EndBug> ",<S2SV_ModStart> n -> mounts += n -> pending_mounts ; n -> pending_mounts = 0 ; ,torvalds@linux/d29216842a85c7970c536108e093963f02714498,CVE-2016-6213,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,2016-12-28T07:59Z
194,CWE-200,"<S2SV_StartBug> savesegment ( es , prev -> es ) ; <S2SV_EndBug> <S2SV_StartBug> loadsegment ( ds , next -> ds ) ; <S2SV_EndBug> ","<S2SV_ModStart> fs , fsindex ) ; savesegment ( gs , gsindex ) ; load_TLS ( next , cpu ) ; arch_end_context_switch ( next_p ) ; savesegment ( <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/f647d7c155f069c1a068030255c300663516420e,CVE-2014-9419,https://github.com/torvalds/linux/commit/f647d7c155f069c1a068030255c300663516420e,2014-12-26T00:59Z
195,CWE-200,<S2SV_StartBug> problem_data_reload_from_dump_dir ( ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,abrt@libreport/257578a23d1537a2d235aaa2b1488ee4f818e360,CVE-2015-5302,https://github.com/abrt/libreport/commit/257578a23d1537a2d235aaa2b1488ee4f818e360,2015-12-07T18:59Z
196,CWE-000,"<S2SV_StartBug> BITS_PARSE ( ""entropy_coding_sync_enabled_flag"" , value , ps_bitstrm , 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ( ps_pps -> i1_tiles_enabled_flag ) && ( ps_sps -> i1_log2_ctb_size == 4 ) && ( ( ps_sps -> i2_pic_width_in_luma_samples >= 4096 ) || ( ps_sps -> i2_pic_height_in_luma_samples >= 4096 ) ) ) { return IHEVCD_INVALID_HEADER ; } ,external@libhevc/25c0ffbe6a181b4a373c3c9b421ea449d457e6ed,CVE-2017-0811,https://android.googlesource.com/platform/external/libhevc/+/25c0ffbe6a181b4a373c3c9b421ea449d457e6ed,2017-10-04T01:29Z
197,CWE-399,<S2SV_StartBug> ( 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) | ( 1u << AC_VECTOR ,torvalds@linux/54a20552e1eae07aa240fa370a0293e006b5faed,CVE-2015-5307,https://github.com/torvalds/linux/commit/54a20552e1eae07aa240fa370a0293e006b5faed,2015-11-16T11:59Z
198,CWE-125,"<S2SV_StartBug> static char temp [ NFSX_V3FHMAX + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( temp , sfsname , NFSX_V3FHMAX ) ; <S2SV_EndBug> <S2SV_StartBug> temp [ sizeof ( temp ) - 1 ] = '\\0' ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> u_int stringlen ; stringlen = len ; if ( stringlen > NFSX_V3FHMAX ) stringlen = NFSX_V3FHMAX ; <S2SV_ModStart> stringlen <S2SV_ModEnd> <S2SV_ModStart> stringlen <S2SV_ModEnd> ,the-tcpdump-group@tcpdump/7a923447fd49a069a0fd3b6c3547438ab5ee2123,CVE-2017-13001,https://github.com/the-tcpdump-group/tcpdump/commit/7a923447fd49a069a0fd3b6c3547438ab5ee2123,2017-09-14T06:29Z
199,CWE-000,"<S2SV_StartBug> int transhdrlen , int mtu , unsigned int flags ) <S2SV_EndBug> <S2SV_StartBug> ipv6_select_ident ( & fhdr ) ; <S2SV_EndBug> ","<S2SV_ModStart> , struct rt6_info * rt <S2SV_ModStart> , rt ",torvalds@linux/87c48fa3b4630905f98268dde838ee43626a060c,CVE-2011-2699,https://github.com/torvalds/linux/commit/87c48fa3b4630905f98268dde838ee43626a060c,2012-05-24T23:55Z
200,CWE-772,<S2SV_StartBug> return res ; <S2SV_EndBug> <S2SV_StartBug> return res ; <S2SV_EndBug> ,<S2SV_ModStart> goto err_add_port <S2SV_ModEnd> <S2SV_ModStart> err_add_port : hsr_del_node ( & hsr -> self_node_db ) ; ,torvalds@linux/6caabe7f197d3466d238f70915d65301f1716626,CVE-2019-16995,https://github.com/torvalds/linux/commit/6caabe7f197d3466d238f70915d65301f1716626,2019-09-30T13:15Z
201,CWE-399,<S2SV_StartBug> ( void ) tls_init_new_session ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> flush_cmd ( ) ; ,jedisct1@pure-ftpd/65c4d4ad331e94661de763e9b5304d28698999c4,CVE-2011-1575,https://github.com/jedisct1/pure-ftpd/commit/65c4d4ad331e94661de763e9b5304d28698999c4,2011-05-23T22:55Z
202,CWE-119,"<S2SV_StartBug> void vp9_setup_dst_planes ( MACROBLOCKD * xd , <S2SV_EndBug> <S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> <S2SV_StartBug> struct macroblockd_plane * const pd = & xd -> plane [ i ] ; <S2SV_EndBug> ",<S2SV_ModStart> struct macroblockd_plane planes [ MAX_MB_PLANE ] <S2SV_ModEnd> <S2SV_ModStart> MAX_MB_PLANE <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> MAX_MB_PLANE <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> planes <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
203,CWE-119,<S2SV_StartBug> len = args -> len = ntohl ( * p ++ ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0 ,torvalds@linux/13bf9fbff0e5e099e2b6f003a0ab8ae145436309,CVE-2017-7895,https://github.com/torvalds/linux/commit/13bf9fbff0e5e099e2b6f003a0ab8ae145436309,2017-04-28T10:59Z
204,CWE-000,"<S2SV_StartBug> static inline void assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst ) <S2SV_EndBug> <S2SV_StartBug> switch ( ctxt -> op_bytes ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return assign_eip_far ( ctxt , dst , ctxt -> mode == X86EMUL_MODE_PROT64 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/234f3ce485d54017f15cf5e0699cff4100121601,CVE-2014-3647,https://github.com/torvalds/linux/commit/234f3ce485d54017f15cf5e0699cff4100121601,2014-11-10T11:55Z
205,CWE-119,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
206,CWE-399,"<S2SV_StartBug> remaining = tvb_captured_length_remaining ( tvb , offset ) ; <S2SV_EndBug> ",<S2SV_ModStart> tvb_reported_length_remaining <S2SV_ModEnd> ,wireshark@wireshark/b4d16b4495b732888e12baf5b8a7e9bf2665e22b,CVE-2016-5350,https://github.com/wireshark/wireshark/commit/b4d16b4495b732888e12baf5b8a7e9bf2665e22b,2016-08-07T16:59Z
207,CWE-362,<S2SV_StartBug> get_block = ocfs2_get_block ; <S2SV_EndBug> <S2SV_StartBug> get_block = ocfs2_dio_get_block ; <S2SV_EndBug> ,<S2SV_ModStart> ocfs2_lock_get_block <S2SV_ModEnd> <S2SV_ModStart> ocfs2_dio_wr_get_block <S2SV_ModEnd> ,torvalds@linux/3e4c56d41eef5595035872a2ec5a483f42e8917f,CVE-2017-18224,https://github.com/torvalds/linux/commit/3e4c56d41eef5595035872a2ec5a483f42e8917f,2018-03-12T03:29Z
208,CWE-20,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
209,CWE-120,"<S2SV_StartBug> if ( fscanf ( f , ""%79s<S2SV_blank>%[^\\n]\\n"" , def , strparm ) == 2 ) <S2SV_EndBug> ","<S2SV_ModStart> ""%79s<S2SV_blank>%99[^\\n]\\n"" <S2SV_ModEnd> ",AXDOOMER@doom-vanille/8a6d9a02fa991a91ff90ccdc73b5ceabaa6cb9ec,CVE-2020-15007,https://github.com/AXDOOMER/doom-vanille/commit/8a6d9a02fa991a91ff90ccdc73b5ceabaa6cb9ec,2020-06-24T11:15Z
210,CWE-189,<S2SV_StartBug> if ( ( int ) val < 0 ) <S2SV_EndBug> ,<S2SV_ModStart> pmc_overflow ( val ) <S2SV_ModEnd> ,torvalds@linux/0837e3242c73566fc1c0196b4ec61779c25ffc93,CVE-2011-4611,https://github.com/torvalds/linux/commit/0837e3242c73566fc1c0196b4ec61779c25ffc93,2012-05-17T11:00Z
211,CWE-125,"<S2SV_StartBug> len = get_line_size ( * b , * avail , nl ) ; <S2SV_EndBug> ","<S2SV_ModStart> + len , * avail - len <S2SV_ModEnd> ",libarchive@libarchive/eec077f52bfa2d3f7103b4b74d52572ba8a15aca,CVE-2016-8688,https://github.com/libarchive/libarchive/commit/eec077f52bfa2d3f7103b4b74d52572ba8a15aca,2017-02-15T19:59Z
212,CWE-125,"<S2SV_StartBug> int all_whitespace = 1 ; <S2SV_EndBug> <S2SV_StartBug> mod_ty mod ; <S2SV_EndBug> <S2SV_StartBug> PyObject * o , * fstring_name ; <S2SV_EndBug> <S2SV_StartBug> o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; <S2SV_EndBug> <S2SV_StartBug> PyMem_RawFree ( str ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> node * mod_n ; <S2SV_ModStart> Py_ssize_t len ; const char * s ; PyObject * fstring_name <S2SV_ModEnd> <S2SV_ModStart> for ( s = expr_start ; s != expr_end ; s ++ ) { char c = * s ; if ( ! ( c == '<S2SV_blank>' || c == '\\t' || c == '\\n' || c == '\\f' ) ) { break ; } } if ( s == expr_end ) { ast_error ( c , n , ""f-string:<S2SV_blank>empty<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>allowed"" ) ; return NULL ; } len = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { PyErr_NoMemory ( ) ; return NULL ; } <S2SV_ModEnd> <S2SV_ModStart> mod_n = PyParser_SimpleParseStringFlagsFilename ( str , ""<fstring>"" , Py_eval_input , 0 ) ; if ( ! mod_n ) { PyMem_RawFree ( str ) ; return NULL ; } str [ 0 ] = '{' ; str [ len + 1 ] = '}' ; fstring_fix_node_location ( n , mod_n , str ) ; <S2SV_ModStart> ) ; Ta3Node_Free ( mod_n ",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
213,CWE-125,"<S2SV_StartBug> void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name ) <S2SV_EndBug> ",<S2SV_ModStart> static ,FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,CVE-2018-8789,https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,2018-11-29T18:29Z
214,CWE-119,<S2SV_StartBug> cJSON * c = object -> child ; <S2SV_EndBug> ,<S2SV_ModStart> ? object -> child : 0 <S2SV_ModEnd> ,esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
215,CWE-20,"<S2SV_StartBug> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> mark_key_instantiated ( key , 0 <S2SV_ModEnd> ",torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z
216,CWE-20,<S2SV_StartBug> assert ( plen <= * len ) ; <S2SV_EndBug> ,<S2SV_ModStart> && plen > 0 ,aircrack-ng@aircrack-ng/88702a3ce4c28a973bf69023cd0312f412f6193e,CVE-2014-8324,https://github.com/aircrack-ng/aircrack-ng/commit/88702a3ce4c28a973bf69023cd0312f412f6193e,2017-10-17T14:29Z
217,CWE-19,"<S2SV_StartBug> args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ; <S2SV_EndBug> ",<S2SV_ModStart> rmtvaluelen = valuelen ; args . ,torvalds@linux/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,CVE-2015-0274,https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,2015-03-16T10:59Z
218,CWE-20,"<S2SV_StartBug> if ( COMPAT_USE_64BIT_TIME ) <S2SV_EndBug> <S2SV_StartBug> if ( get_compat_timespec ( & ktspec , timeout ) ) <S2SV_EndBug> <S2SV_StartBug> if ( datagrams > 0 && put_compat_timespec ( & ktspec , timeout ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> compat_get_timespec <S2SV_ModEnd> <S2SV_ModStart> compat_put_timespec <S2SV_ModEnd> ,torvalds@linux/2def2ef2ae5f3990aabdbe8a755911902707d268,CVE-2014-0038,https://github.com/torvalds/linux/commit/2def2ef2ae5f3990aabdbe8a755911902707d268,2014-02-06T22:55Z
219,CWE-119,<S2SV_StartBug> image -> storage_class = PseudoClass ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> case RMT_NONE : <S2SV_EndBug> <S2SV_StartBug> * sun_colormap ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",ImageMagick@ImageMagick/bd96074b254c6607a0f7731e59f923ad19d5a46d,CVE-2015-8957,https://github.com/ImageMagick/ImageMagick/commit/bd96074b254c6607a0f7731e59f923ad19d5a46d,2017-04-20T18:59Z
220,CWE-416,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = hns_nic_net_xmit_hw ( ndev , skb , <S2SV_EndBug> <S2SV_StartBug> if ( ret == NETDEV_TX_OK ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2,CVE-2017-18218,https://github.com/torvalds/linux/commit/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2,2018-03-05T20:29Z
221,CWE-20,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
222,CWE-400,<S2SV_StartBug> if ( tcp_specified && settings . port != 0 && ! udp_specified ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,memcached@memcached/dbb7a8af90054bf4ef51f5814ef7ceb17d83d974,CVE-2018-1000115,https://github.com/memcached/memcached/commit/dbb7a8af90054bf4ef51f5814ef7ceb17d83d974,2018-03-05T14:29Z
223,CWE-125,<S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> ,<S2SV_ModStart> = { 0 } ,radare@radare2/25a3703ef2e015bbe1d1f16f6b2f63bb10dd34f4,CVE-2018-11377,https://github.com/radare/radare2/commit/25a3703ef2e015bbe1d1f16f6b2f63bb10dd34f4,2018-05-22T19:29Z
224,CWE-476,<S2SV_StartBug> px -> ft -> data = px ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! px -> ft ) { return FALSE ; } ,bitlbee@bitlbee/30d598ce7cd3f136ee9d7097f39fa9818a272441,CVE-2017-5668,https://github.com/bitlbee/bitlbee/commit/30d598ce7cd3f136ee9d7097f39fa9818a272441,2017-03-14T14:59Z
225,CWE-000,"<S2SV_StartBug> int ret = 0 , found = 0 ; <S2SV_EndBug> <S2SV_StartBug> repo_config = perf_pathdup ( ""config"" ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/aba8d056078e47350d85b06a9cabd5afcc4b72ea,CVE-2011-2905,https://github.com/torvalds/linux/commit/aba8d056078e47350d85b06a9cabd5afcc4b72ea,2013-03-01T12:37Z
226,CWE-264,"<S2SV_StartBug> validate_event ( struct pmu_hw_events * hw_events , <S2SV_EndBug> <S2SV_StartBug> struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ; <S2SV_EndBug> <S2SV_StartBug> if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) <S2SV_EndBug> <S2SV_StartBug> return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ; <S2SV_EndBug> ","<S2SV_ModStart> struct pmu * pmu , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pmu ) return 0 ; if ( event -> pmu != <S2SV_ModStart> armpmu = to_arm_pmu ( event -> pmu ) ; ",torvalds@linux/8fff105e13041e49b82f92eef034f363a6b1c071,CVE-2015-8955,https://github.com/torvalds/linux/commit/8fff105e13041e49b82f92eef034f363a6b1c071,2016-10-10T10:59Z
227,CWE-264,"<S2SV_StartBug> static bool new_idmap_permitted ( struct user_namespace * ns , int cap_setid , <S2SV_EndBug> <S2SV_StartBug> if ( ns_capable ( ns -> parent , cap_setid ) ) <S2SV_EndBug> ","<S2SV_ModStart> const struct file * file , <S2SV_ModStart> && file_ns_capable ( file , ns -> parent , cap_setid ) ",torvalds@linux/6708075f104c3c9b04b23336bb0366ca30c3931b,CVE-2013-1959,https://github.com/torvalds/linux/commit/6708075f104c3c9b04b23336bb0366ca30c3931b,2013-05-03T11:57Z
228,CWE-125,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> return body ; <S2SV_EndBug> ,<S2SV_ModStart> { if ( a -> type == szMAPI_BINARY ) <S2SV_ModStart> } ,verdammelt@tnef/8dccf79857ceeb7a6d3e42c1e762e7b865d5344d,CVE-2017-6310,https://github.com/verdammelt/tnef/commit/8dccf79857ceeb7a6d3e42c1e762e7b865d5344d,2017-02-24T04:59Z
229,CWE-119,"<S2SV_StartBug> u8 reset ; <S2SV_EndBug> <S2SV_StartBug> hx = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ret = usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) ) != 1 ) <S2SV_EndBug> <S2SV_StartBug> kfree ( hx ) ; <S2SV_EndBug> <S2SV_StartBug> reset = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ret || usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) != 1 ) { <S2SV_EndBug> <S2SV_StartBug> kfree ( hx ) ; <S2SV_EndBug> ","<S2SV_ModStart> * buf <S2SV_ModEnd> <S2SV_ModStart> u16 cpu_cs_register = <S2SV_ModEnd> <S2SV_ModStart> ; buf = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; hx = ( struct hexline * ) buf ; buf [ 0 ] = 1 ; if ( usb_cypress_writemem ( udev , cpu_cs_register , buf , 1 <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> buf [ 0 ] = 0 ; if ( <S2SV_ModEnd> <S2SV_ModStart> cpu_cs_register , buf <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> ",torvalds@linux/67b0503db9c29b04eadfeede6bebbfe5ddad94ef,CVE-2017-8061,https://github.com/torvalds/linux/commit/67b0503db9c29b04eadfeede6bebbfe5ddad94ef,2017-04-23T05:59Z
230,CWE-125,"<S2SV_StartBug> l2tp_call_errors_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> <S2SV_StartBug> ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> ","<S2SV_ModStart> , u_int length <S2SV_ModStart> if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } ptr ++ ; length -= 2 ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> <S2SV_ModStart> if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> <S2SV_ModStart> if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> <S2SV_ModStart> if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> <S2SV_ModStart> if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> <S2SV_ModStart> if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } ",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z
231,CWE-284,"<S2SV_StartBug> if ( strncmp ( handle -> params . realm , realm -> data , realm -> length ) == 0 <S2SV_EndBug> ","<S2SV_ModStart> success = data_eq_string ( * realm , <S2SV_ModEnd> <S2SV_ModStart> ) && data_eq_string ( * c1 , ""kadmin"" ) && ! data_eq_string ( * c2 , ""history"" ) ; <S2SV_ModEnd> ",krb5@krb5/6609658db0799053fbef0d7d0aa2f1fd68ef32d8,CVE-2014-9422,https://github.com/krb5/krb5/commit/6609658db0799053fbef0d7d0aa2f1fd68ef32d8,2015-02-19T11:59Z
232,CWE-190,<S2SV_StartBug> if ( uniforms_offset < shader_rec_offset || <S2SV_EndBug> ,<S2SV_ModStart> shader_rec_offset < args -> bin_cl_size || ,torvalds@linux/0f2ff82e11c86c05d051cae32b58226392d33bbf,CVE-2017-5576,https://github.com/torvalds/linux/commit/0f2ff82e11c86c05d051cae32b58226392d33bbf,2017-02-06T06:59Z
233,CWE-401,<S2SV_StartBug> # if HAVA_LZMA_H && HAVE_LIBLZMA <S2SV_EndBug> ,<S2SV_ModStart> HAVE_LZMA_H <S2SV_ModEnd> ,libarchive@libarchive/ba641f73f3d758d9032b3f0e5597a9c6e593a505,CVE-2019-11463,https://github.com/libarchive/libarchive/commit/ba641f73f3d758d9032b3f0e5597a9c6e593a505,2019-04-23T03:29Z
234,CWE-362,<S2SV_StartBug> file_update_time ( vma -> vm_file ) ; <S2SV_EndBug> <S2SV_StartBug> sb_end_pagefault ( inode -> i_sb ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; down_read ( & EXT4_I ( inode ) -> i_mmap_sem <S2SV_ModStart> up_read ( & EXT4_I ( inode ) -> i_mmap_sem ) ; ,torvalds@linux/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b,CVE-2015-8839,https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b,2016-05-02T10:59Z
235,CWE-190,<S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> ,<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> ,mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
236,CWE-78,<S2SV_StartBug> switch ( * arg ) { <S2SV_EndBug> <S2SV_StartBug> case '\\n' : <S2SV_EndBug> <S2SV_StartBug> * b ++ = * arg ; <S2SV_EndBug> ,<S2SV_ModStart> char ch = * arg ; switch ( ch <S2SV_ModEnd> <S2SV_ModStart> '=' : case <S2SV_ModStart> ch <S2SV_ModEnd> ,radareorg@radare2/5411543a310a470b1257fb93273cdd6e8dfcb3af,CVE-2019-16718,https://github.com/radareorg/radare2/commit/5411543a310a470b1257fb93273cdd6e8dfcb3af,2019-09-23T14:15Z
237,CWE-125,"<S2SV_StartBug> if ( map && nmap ) { <S2SV_EndBug> <S2SV_StartBug> cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ep2 , map , nmap ) ; else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart>  <S2SV_ModEnd> ",the-tcpdump-group@tcpdump/e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d,CVE-2017-13039,https://github.com/the-tcpdump-group/tcpdump/commit/e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d,2017-09-14T06:29Z
238,CWE-835,<S2SV_StartBug> static gboolean <S2SV_EndBug> <S2SV_StartBug> ice_conn -> context = client ; <S2SV_EndBug> ,"<S2SV_ModStart> typedef struct { guint watch_id ; guint protocol_timeout ; } GsmIceConnectionWatch ; static void disconnect_ice_connection ( IceConn ice_conn ) { IceSetShutdownNegotiation ( ice_conn , FALSE ) ; IceCloseConnection <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",GNOME@gnome-session/b0dc999e0b45355314616321dbb6cb71e729fc9d,CVE-2017-11171,https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d,2017-07-11T20:29Z
239,CWE-399,<S2SV_StartBug> if ( ( skb_headroom ( skb ) < frag_hdr_sz ) && <S2SV_EndBug> ,<S2SV_ModStart> skb_mac_header <S2SV_ModEnd> <S2SV_ModStart> skb -> head + ,torvalds@linux/a9cf73ea7ff78f52662c8658d93c226effbbedde,CVE-2011-4326,https://github.com/torvalds/linux/commit/a9cf73ea7ff78f52662c8658d93c226effbbedde,2012-05-17T11:00Z
240,CWE-20,<S2SV_StartBug> # ifdef GIT_WIN32 <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> test_checkout_fails ( ""refs/heads/git_tilde1"" , ""git~1/foobar"" ) ; <S2SV_ModEnd> ",libgit2@libgit2/64c612cc3e25eff5fb02c59ef5a66ba7a14751e4,CVE-2020-12279,https://github.com/libgit2/libgit2/commit/64c612cc3e25eff5fb02c59ef5a66ba7a14751e4,2020-04-27T17:15Z
241,CWE-119,"<S2SV_StartBug> v . val = test_bit ( SOCK_PASSCRED , & sock -> flags ) ? 1 : 0 ; <S2SV_EndBug> <S2SV_StartBug> v . val = test_bit ( SOCK_PASSSEC , & sock -> flags ) ? 1 : 0 ; <S2SV_EndBug> ",<S2SV_ModStart> ! ! <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ! ! <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/82981930125abfd39d7c8378a9cfdf5e1be2002b,CVE-2012-6704,https://github.com/torvalds/linux/commit/82981930125abfd39d7c8378a9cfdf5e1be2002b,2016-12-28T07:59Z
242,CWE-20,<S2SV_StartBug> if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> ,<S2SV_ModStart> return 0 ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
243,CWE-119,<S2SV_StartBug> return in ; <S2SV_EndBug> ,<S2SV_ModStart> NULL <S2SV_ModEnd> ,lurcher@unixODBC/45ef78e037f578b15fc58938a3a3251655e71d6f,CVE-2018-7485,https://github.com/lurcher/unixODBC/commit/45ef78e037f578b15fc58938a3a3251655e71d6f,2018-02-26T14:29Z
244,CWE-119,"<S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> ",<S2SV_ModStart> MAX_MB_PLANE <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> MAX_MB_PLANE <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
245,CWE-119,"<S2SV_StartBug> char buf [ DN_BUF_LEN ] ; <S2SV_EndBug> <S2SV_StartBug> X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , buf , & bufsize , <S2SV_EndBug> <S2SV_StartBug> md -> subject_dn = strdup ( buf ) ; <S2SV_EndBug> <S2SV_StartBug> X509_NAME_oneline_ex ( X509_get_issuer_name ( cert ) , buf , & bufsize , <S2SV_EndBug> <S2SV_StartBug> md -> issuer_dn = strdup ( buf ) ; <S2SV_EndBug> ","<S2SV_ModStart> * md_out = NULL ; md = calloc ( 1 , sizeof ( <S2SV_ModEnd> <S2SV_ModStart> ret = rfc2253_name <S2SV_ModEnd> <S2SV_ModStart> & <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( ret ) goto cleanup ; ret = rfc2253_name <S2SV_ModEnd> <S2SV_ModStart> & <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( ret ) goto cleanup ; <S2SV_ModEnd> ",krb5@krb5/fbb687db1088ddd894d975996e5f6a4252b9a2b4,CVE-2017-15088,https://github.com/krb5/krb5/commit/fbb687db1088ddd894d975996e5f6a4252b9a2b4,2017-11-23T17:29Z
246,CWE-399,<S2SV_StartBug> if ( ! npages ) { <S2SV_EndBug> ,<S2SV_ModStart> || base_gfn != old . base_gfn ,torvalds@linux/12d6e7538e2d418c08f082b1b44ffa5fb7270ed8,CVE-2013-4592,https://github.com/torvalds/linux/commit/12d6e7538e2d418c08f082b1b44ffa5fb7270ed8,2013-11-20T13:19Z
247,CWE-200,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/6c85501f2fabcfc4fc6ed976543d252c4eaf4be9,CVE-2017-14954,https://github.com/torvalds/linux/commit/6c85501f2fabcfc4fc6ed976543d252c4eaf4be9,2017-10-02T01:29Z
248,CWE-20,<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
249,CWE-125,"<S2SV_StartBug> register u_int amt ; <S2SV_EndBug> <S2SV_StartBug> j = length / sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6 <S2SV_EndBug> <S2SV_StartBug> if ( j * sizeof ( * ni ) != length - 4 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d:"" , j ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> i -= sizeof ( * ni ) , ++ ni ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> j = length / sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> if ( j * sizeof ( * ni ) != length - 4 ) <S2SV_EndBug> <S2SV_StartBug> trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ; <S2SV_EndBug> <S2SV_StartBug> for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> i -= sizeof ( * ni ) , ++ ni ) { <S2SV_EndBug> <S2SV_StartBug> if ( trunc ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> unsigned int length_left ; u_int j ; ND_TCHECK ( rp -> rip6_cmd <S2SV_ModEnd> <S2SV_ModStart> length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> <S2SV_ModStart> ) { ND_TCHECK ( rp -> rip6_nets ) ; if ( <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u[%u]:"" , j , length <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank>ripng-req<S2SV_blank>%u:"" , j ) <S2SV_ModEnd> <S2SV_ModStart> length_left <S2SV_ModEnd> <S2SV_ModStart> length_left <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( * ni ) ; <S2SV_ModStart> if ( length_left != 0 ) goto trunc ; <S2SV_ModStart> length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> <S2SV_ModStart> length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> length_left <S2SV_ModEnd> <S2SV_ModStart> length_left <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( * ni ) ; <S2SV_ModStart> length_left != 0 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( rp -> rip6_vers ) ; <S2SV_ModStart> return ; trunc : ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ; return ; ",the-tcpdump-group@tcpdump/e942fb84fbe3a73a98a00d2a279425872b5fb9d2,CVE-2017-12992,https://github.com/the-tcpdump-group/tcpdump/commit/e942fb84fbe3a73a98a00d2a279425872b5fb9d2,2017-09-14T06:29Z
250,CWE-404,<S2SV_StartBug> if ( ret < 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> goto error ; <S2SV_ModEnd> ,torvalds@linux/c9f838d104fed6f2f61d68164712e3204bf5271b,CVE-2017-7472,https://github.com/torvalds/linux/commit/c9f838d104fed6f2f61d68164712e3204bf5271b,2017-05-11T19:29Z
251,CWE-119,"<S2SV_StartBug> vpx_memcpy ( sortlist , cpi -> mb_activity_map , <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
252,CWE-200,<S2SV_StartBug> bprm -> interp = iname ; <S2SV_EndBug> ,"<S2SV_ModStart> retval = bprm_change_interp ( iname , bprm ) ; if ( retval < 0 ) goto _error <S2SV_ModEnd> ",torvalds@linux/b66c5984017533316fd1951770302649baf1aa33,CVE-2012-4530,https://github.com/torvalds/linux/commit/b66c5984017533316fd1951770302649baf1aa33,2013-02-18T04:41Z
253,CWE-125,<S2SV_StartBug> int iSrc ; <S2SV_EndBug> <S2SV_StartBug> for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { <S2SV_EndBug> <S2SV_StartBug> dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ] . ,libgd@libgd/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a,CVE-2013-7456,https://github.com/libgd/libgd/commit/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a,2016-08-07T10:59Z
254,CWE-416,<S2SV_StartBug> _ipmi_destroy_user ( user ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/77f8269606bf95fcb232ee86f6da80886f1dfae8,CVE-2019-9003,https://github.com/torvalds/linux/commit/77f8269606bf95fcb232ee86f6da80886f1dfae8,2019-02-22T15:29Z
255,CWE-269,"<S2SV_StartBug> Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; return ; } if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) { Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".cfg\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" ",ioquake@ioq3/b173ac05993f634a42be3d3535e1b158de0c3372,CVE-2017-6903,https://github.com/ioquake/ioq3/commit/b173ac05993f634a42be3d3535e1b158de0c3372,2017-03-14T22:59Z
256,CWE-190,<S2SV_StartBug> int sl = strlen ( cursor -> ns ) + 1 ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> ,10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z
257,CWE-189,"<S2SV_StartBug> if ( mobj ) <S2SV_EndBug> <S2SV_StartBug> memset ( mobj_get_va ( mobj , 0 ) , 0 , size ) ; <S2SV_EndBug> ","<S2SV_ModStart> { size_t granularity = BIT ( tee_mm_sec_ddr . shift ) ; <S2SV_ModStart> ROUNDUP ( size , granularity ) ) ; } <S2SV_ModEnd> ",OP-TEE@optee_os/7e768f8a473409215fe3fff8f6e31f8a3a0103c6,CVE-2019-1010294,https://github.com/OP-TEE/optee_os/commit/7e768f8a473409215fe3fff8f6e31f8a3a0103c6,2019-07-15T18:15Z
258,CWE-190,<S2SV_StartBug> timer -> it_overrun += 1 << i ; <S2SV_EndBug> ,<S2SV_ModStart> 1LL <S2SV_ModEnd> ,torvalds@linux/78c9c4dfbf8c04883941445a195276bb4bb92c76,CVE-2018-12896,https://github.com/torvalds/linux/commit/78c9c4dfbf8c04883941445a195276bb4bb92c76,2018-07-02T17:29Z
259,CWE-125,"<S2SV_StartBug> int is_async = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> for_ch = CHILD ( n , 1 + is_async ) ; <S2SV_EndBug> <S2SV_StartBug> expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( NCH ( n ) == ( 5 + is_async ) ) { <S2SV_EndBug> <S2SV_StartBug> n = CHILD ( n , 4 + is_async ) ; <S2SV_EndBug> ","<S2SV_ModStart> node * sync_n ; <S2SV_ModStart> NCH ( n ) == 2 <S2SV_ModEnd> <S2SV_ModStart> REQ ( CHILD ( n , 0 ) , NAME ) ; assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , ""async"" ) == 0 ) ; sync_n = CHILD ( n , 1 ) ; } else { sync_n = CHILD ( n , 0 ) ; } REQ ( sync_n , sync_comp_for ) ; <S2SV_ModEnd> <S2SV_ModStart> sync_n , 1 <S2SV_ModEnd> <S2SV_ModStart> sync_n , 3 <S2SV_ModEnd> <S2SV_ModStart> sync_n ) == 5 <S2SV_ModEnd> <S2SV_ModStart> sync_n , 4 <S2SV_ModEnd> ",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
260,CWE-189,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> dst_state -> speculative = src -> speculative ; ,torvalds@linux/979d63d50c0c0f7bc537bf821e056cc9fe5abd38,CVE-2019-7308,https://github.com/torvalds/linux/commit/979d63d50c0c0f7bc537bf821e056cc9fe5abd38,2019-02-01T22:29Z
261,CWE-119,"<S2SV_StartBug> static void write_mb_modes_kf ( const VP9_COMP * cpi , MODE_INFO * * mi_8x8 , <S2SV_EndBug> <S2SV_StartBug> vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> const MODE_INFO * const above_mi = mi_8x8 [ - xd -> mi_stride ] ; <S2SV_EndBug> <S2SV_StartBug> const MODE_INFO * const left_mi = xd -> left_available ? mi_8x8 [ - 1 ] : NULL ; <S2SV_EndBug> <S2SV_StartBug> write_skip ( cpi , mbmi -> segment_id , mi , w ) ; <S2SV_EndBug> <S2SV_StartBug> write_selected_tx_size ( cpi , mbmi -> tx_size , bsize , w ) ; <S2SV_EndBug> ","<S2SV_ModStart> VP9_COMMON * cm , const MACROBLOCKD * xd , <S2SV_ModEnd> <S2SV_ModStart> vpx_writer * w ) { <S2SV_ModEnd> <S2SV_ModStart> xd -> above_mi <S2SV_ModEnd> <S2SV_ModStart> left_mi <S2SV_ModEnd> <S2SV_ModStart> cm , xd <S2SV_ModEnd> <S2SV_ModStart> cm , xd <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
262,CWE-284,<S2SV_StartBug> saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> ,<S2SV_ModStart> INADDR_LOOPBACK <S2SV_ModEnd> ,libimobiledevice@libimobiledevice/df1f5c4d70d0c19ad40072f5246ca457e7f9849e,CVE-2016-5104,https://github.com/libimobiledevice/libimobiledevice/commit/df1f5c4d70d0c19ad40072f5246ca457e7f9849e,2016-06-13T14:59Z
263,CWE-119,"<S2SV_StartBug> DPRINTF ( ""Data<S2SV_blank>ready<S2SV_blank>tag=0x%x<S2SV_blank>len=%zd\\n"" , r -> req . tag , r -> iov . iov_len ) ; <S2SV_EndBug> <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> <S2SV_StartBug> scsi_req_data ( & r -> req , r -> iov . iov_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> qiov . size <S2SV_ModEnd> <S2SV_ModStart> qiov . size <S2SV_ModEnd> <S2SV_ModStart> qiov . size <S2SV_ModEnd> ,bonzini@qemu/103b40f51e4012b3b0ad20f615562a1806d7f49a,CVE-2011-3346,https://github.com/bonzini/qemu/commit/103b40f51e4012b3b0ad20f615562a1806d7f49a,2014-04-01T06:35Z
264,CWE-119,<S2SV_StartBug> if ( cs > CQSPI_MAX_CHIPSELECT ) { <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> ,torvalds@linux/193e87143c290ec16838f5368adc0e0bc94eb931,CVE-2016-10764,https://github.com/torvalds/linux/commit/193e87143c290ec16838f5368adc0e0bc94eb931,2019-07-27T22:15Z
265,CWE-119,"<S2SV_StartBug> if ( n > maxn ) SWF_error ( ""Action<S2SV_blank>overflow!!"" ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( actions [ n ] . SWF_ACTIONRECORD . ActionCode ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> OpCode ( actions , n , maxn ) <S2SV_ModEnd> ",libming@libming/da9d86eab55cbf608d5c916b8b690f5b76bca462,CVE-2019-12982,https://github.com/libming/libming/commit/da9d86eab55cbf608d5c916b8b690f5b76bca462,2019-06-26T18:15Z
266,CWE-119,"<S2SV_StartBug> memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( l > ll ) l = ll ; ,varnishcache@varnish-cache/176f8a075a963ffbfa56f1c460c15f6a1a6af5a7,CVE-2017-8807,https://github.com/varnishcache/varnish-cache/commit/176f8a075a963ffbfa56f1c460c15f6a1a6af5a7,2017-11-16T02:29Z
267,CWE-119,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> } if ( free < 0 ) { err = - ENOMEM ; goto out ; ,torvalds@linux/0926f91083f34d047abc74f1ca4fa6a9c161f7db,CVE-2010-5332,https://github.com/torvalds/linux/commit/0926f91083f34d047abc74f1ca4fa6a9c161f7db,2019-07-27T22:15Z
268,CWE-125,<S2SV_StartBug> if ( len < sizeof ( * prep ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> || ! ND_TTEST ( * prep ) ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,the-tcpdump-group@tcpdump/cc356512f512e7fa423b3674db4bb31dbe40ffec,CVE-2017-13014,https://github.com/the-tcpdump-group/tcpdump/commit/cc356512f512e7fa423b3674db4bb31dbe40ffec,2017-09-14T06:29Z
269,CWE-835,<S2SV_StartBug> rq -> skip_clock_update = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/f26f9aff6aaf67e9a430d16c266f91b13a5bff64,CVE-2011-4621,https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64,2012-05-17T11:00Z
270,CWE-119,"<S2SV_StartBug> uint8_t value ; <S2SV_EndBug> <S2SV_StartBug> 0 , reg , & value , 1 , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> return ret >= 0 ? value : ret ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> * buffer ; uint8_t value ; buffer = kmalloc ( 1 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> buffer <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> ) { value = buffer [ 0 ] ; kfree ( buffer ) ; return value ; } else { kfree ( buffer ) ; return <S2SV_ModEnd> <S2SV_ModStart> } ",torvalds@linux/05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655,CVE-2017-5548,https://github.com/torvalds/linux/commit/05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655,2017-02-06T06:59Z
271,CWE-190,"<S2SV_StartBug> static void addModuleArgument ( sqlite3 * db , Table * pTable , char * zArg ) { <S2SV_EndBug> <S2SV_StartBug> int nBytes = sizeof ( char * ) * ( 2 + pTable -> nModuleArg ) ; <S2SV_EndBug> <S2SV_StartBug> char * * azModuleArg ; <S2SV_EndBug> ","<S2SV_ModStart> Parse * pParse <S2SV_ModEnd> <S2SV_ModStart> sqlite3_int64 <S2SV_ModEnd> <S2SV_ModStart> sqlite3 * db = pParse -> db ; if ( pTable -> nModuleArg + 3 >= db -> aLimit [ SQLITE_LIMIT_COLUMN ] ) { sqlite3ErrorMsg ( pParse , ""too<S2SV_blank>many<S2SV_blank>columns<S2SV_blank>on<S2SV_blank>%s"" , pTable -> zName ) ; } ",chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4,CVE-2019-5827,https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4,2019-06-27T17:15Z
272,CWE-119,"<S2SV_StartBug> memcpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ; <S2SV_EndBug> ","<S2SV_ModStart> s -> append_char ( s , 0 ) ; strncpy <S2SV_ModEnd> ",atheme@atheme/87580d767868360d2fed503980129504da84b63e,CVE-2016-4478,https://github.com/atheme/atheme/commit/87580d767868360d2fed503980129504da84b63e,2016-06-13T19:59Z
273,CWE-000,<S2SV_StartBug> CurrentColorSpace = ColorSpaceOut ; <S2SV_EndBug> <S2SV_StartBug> cmsPipelineFree ( Lut ) ; <S2SV_EndBug> ,<S2SV_ModStart> Lut = NULL ; <S2SV_ModStart> if ( Lut != NULL ) ,mm2@Little-CMS/fefaaa43c382eee632ea3ad0cfa915335140e1db,CVE-2013-7455,https://github.com/mm2/Little-CMS/commit/fefaaa43c382eee632ea3ad0cfa915335140e1db,2016-05-07T10:59Z
274,CWE-125,<S2SV_StartBug> for ( i = 0 ; i < sec -> size ; i += 4 ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < sec -> size ; i += 8 ) { <S2SV_EndBug> ,<S2SV_ModStart> ( i + 3 ) <S2SV_ModEnd> <S2SV_ModStart> ( i + 7 ) <S2SV_ModEnd> ,radare@radare2/1f37c04f2a762500222dda2459e6a04646feeedf,CVE-2018-11376,https://github.com/radare/radare2/commit/1f37c04f2a762500222dda2459e6a04646feeedf,2018-05-22T19:29Z
275,CWE-125,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""%sBandwidth<S2SV_blank>Constraints<S2SV_blank>Model<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(%u)"" , <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , 4 ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( subl == 0 ) break ; <S2SV_ModStart>  <S2SV_ModEnd> ,the-tcpdump-group@tcpdump/5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e,CVE-2017-13055,https://github.com/the-tcpdump-group/tcpdump/commit/5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e,2017-09-14T06:29Z
276,CWE-787,"<S2SV_StartBug> if ( ixheaacd_cmplx_anal_fft != NULL ) <S2SV_EndBug> <S2SV_StartBug> ( * ixheaacd_cmplx_anal_fft ) ( u_in , u_out , anal_size * 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ( ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft ) ) <S2SV_ModEnd> ,external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z
277,CWE-125,"<S2SV_StartBug> while ( p < q ) p += enclen ( reg -> enc , p ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( q >= end ) return 0 ; ,kkos@oniguruma/9690d3ab1f9bcd2db8cbe1fe3ee4a5da606b8814,CVE-2017-9227,https://github.com/kkos/oniguruma/commit/9690d3ab1f9bcd2db8cbe1fe3ee4a5da606b8814,2017-05-24T15:29Z
278,CWE-416,"<S2SV_StartBug> static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) <S2SV_EndBug> <S2SV_StartBug> struct bfq_data * bfqd = bfqq -> bfqd ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & bfqd -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> struct bfq_data * bfqd , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> bfq_clear_bfqq_wait_request ( bfqq ) ; ",torvalds@linux/2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9,CVE-2020-12657,https://github.com/torvalds/linux/commit/2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9,2020-05-05T07:15Z
279,CWE-20,<S2SV_StartBug> if ( key_is_instantiated ( key ) && <S2SV_EndBug> ,<S2SV_ModStart> key_is_positive <S2SV_ModEnd> ,torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z
280,CWE-20,"<S2SV_StartBug> RING_FINAL_CHECK_FOR_REQUESTS ( & vif -> tx , work_to_do ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( work_to_do < 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( ret < 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , <S2SV_EndBug> <S2SV_StartBug> netbk_tx_err ( vif , & txreq , idx ) ; <S2SV_EndBug> <S2SV_StartBug> netbk_tx_err ( vif , & txreq , idx ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( vif -> tx . sring -> req_prod - vif -> tx . req_cons > XEN_NETIF_TX_RING_SIZE ) { netdev_err ( vif -> dev , ""Impossible<S2SV_blank>number<S2SV_blank>of<S2SV_blank>requests.<S2SV_blank>"" ""req_prod<S2SV_blank>%d,<S2SV_blank>req_cons<S2SV_blank>%d,<S2SV_blank>size<S2SV_blank>%ld\\n"" , vif -> tx . sring -> req_prod , vif -> tx . req_cons , XEN_NETIF_TX_RING_SIZE ) ; netbk_fatal_tx_err ( vif ) ; continue ; } <S2SV_ModStart> continue ; <S2SV_ModEnd> <S2SV_ModStart> continue ; <S2SV_ModEnd> <S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> netbk_fatal_tx_err ( vif <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/48856286b64e4b66ec62b94e504d0b29c1ade664,CVE-2013-0216,https://github.com/torvalds/linux/commit/48856286b64e4b66ec62b94e504d0b29c1ade664,2013-02-18T04:41Z
281,CWE-399,<S2SV_StartBug> ( void ) tls_init_new_session ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> flush_cmd ( ) ; ,jedisct1@pure-ftpd/65c4d4ad331e94661de763e9b5304d28698999c4,CVE-2011-1575,https://github.com/jedisct1/pure-ftpd/commit/65c4d4ad331e94661de763e9b5304d28698999c4,2011-05-23T22:55Z
282,CWE-416,<S2SV_StartBug> struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/1137b5e2529a8f5ca8ee709288ecba3e68044df2,CVE-2017-16939,https://github.com/torvalds/linux/commit/1137b5e2529a8f5ca8ee709288ecba3e68044df2,2017-11-24T10:29Z
283,CWE-000,<S2SV_StartBug> parse_input ( conn ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( <S2SV_ModStart> != 0 ) return ,h2o@h2o/1c0808d580da09fdec5a9a74ff09e103ea058dd4,CVE-2016-4817,https://github.com/h2o/h2o/commit/1c0808d580da09fdec5a9a74ff09e103ea058dd4,2016-06-19T01:59Z
284,CWE-399,"<S2SV_StartBug> struct pending_tx_info * pending_tx_info = netbk -> pending_tx_info ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( err ) ) { <S2SV_EndBug> <S2SV_StartBug> netbk -> pending_ring [ index ] = pending_idx ; <S2SV_EndBug> <S2SV_StartBug> pending_ring_idx_t index ; <S2SV_EndBug> <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> <S2SV_StartBug> txp = & netbk -> pending_tx_info [ pending_idx ] . req ; <S2SV_EndBug> <S2SV_StartBug> index = pending_index ( netbk -> pending_prod ++ ) ; <S2SV_EndBug> <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> xen_netbk_idx_release ( netbk , pending_idx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , XEN_NETIF_RSP_OKAY <S2SV_ModStart> xen_netbk_idx_release ( netbk , pending_idx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , XEN_NETIF_RSP_OKAY <S2SV_ModStart> , XEN_NETIF_RSP_OKAY ",torvalds@linux/7d5145d8eb2b9791533ffe4dc003b129b9696c48,CVE-2013-0217,https://github.com/torvalds/linux/commit/7d5145d8eb2b9791533ffe4dc003b129b9696c48,2013-02-18T04:41Z
285,CWE-119,"
","
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
286,CWE-772,"<S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> ",<S2SV_ModStart> { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> } <S2SV_ModStart> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> } <S2SV_ModStart> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; ,ImageMagick@ImageMagick/ef8f40689ac452398026c07da41656a7c87e4683,CVE-2017-15033,https://github.com/ImageMagick/ImageMagick/commit/ef8f40689ac452398026c07da41656a7c87e4683,2017-10-05T07:29Z
287,CWE-000,<S2SV_StartBug> if ( len < 0 || addr . nl_pid ) { <S2SV_EndBug> <S2SV_StartBug> incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( addr . nl_pid ) { syslog ( LOG_WARNING , ""Received<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>untrusted<S2SV_blank>pid:%u"" , addr . nl_pid ) ; continue ; } ",torvalds@linux/95a69adab9acfc3981c504737a2b6578e4d846ef,CVE-2012-5532,https://github.com/torvalds/linux/commit/95a69adab9acfc3981c504737a2b6578e4d846ef,2012-12-27T11:47Z
288,CWE-400,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
289,CWE-399,<S2SV_StartBug> if ( client -> ipc == NULL ) { <S2SV_EndBug> ,<S2SV_ModStart> && client -> session == NULL ,ClusterLabs@pacemaker/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,CVE-2013-0281,https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,2013-11-23T11:55Z
290,CWE-787,"<S2SV_StartBug> diffPtr + x > diffBlock + diffBlockLength || <S2SV_EndBug> <S2SV_StartBug> memcpy ( newData + newpos , diffPtr , x ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(overflow)"" ) ; return NULL ; } memcpy ( newData + newpos , diffPtr , x ) ; diffPtr += x ; for ( j = 0 ; j < x ; j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ; newpos += x ; oldpos += x ; if ( newpos + y > newDataLength <S2SV_ModStart>  <S2SV_ModEnd> ",ilanschnell@bsdiff4/49a4cee2feef7deaf9d89e5e793a8824930284d7,CVE-2020-15904,https://github.com/ilanschnell/bsdiff4/commit/49a4cee2feef7deaf9d89e5e793a8824930284d7,2020-07-22T23:15Z
291,CWE-17,"<S2SV_StartBug> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; <S2SV_EndBug> ","<S2SV_ModStart> lfi , fname , UDF_NAME_LEN <S2SV_ModEnd> ",torvalds@linux/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,CVE-2014-9731,https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,2015-08-31T10:59Z
292,CWE-200,"<S2SV_StartBug> __ip_vs_get_timeouts ( net , & t ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( & t , 0 , sizeof ( t ) ) ; ",torvalds@linux/2d8a041b7bfe1097af21441cb77d6af95f4f4680,CVE-2012-6540,https://github.com/torvalds/linux/commit/2d8a041b7bfe1097af21441cb77d6af95f4f4680,2013-03-15T20:55Z
293,CWE-264,"<S2SV_StartBug> err = ip6_xmit ( sk , skb , fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> ","<S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) , <S2SV_ModEnd> ",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
294,CWE-264,<S2SV_StartBug> ssize_t result ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ,torvalds@linux/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3,CVE-2016-4565,https://github.com/torvalds/linux/commit/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3,2016-05-23T10:59Z
295,CWE-264,"<S2SV_StartBug> char * fpath = NULL , * path1 , * cgdir = NULL , * controller ; <S2SV_EndBug> <S2SV_StartBug> if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) { <S2SV_EndBug> <S2SV_StartBug> ret = - EACCES ; <S2SV_EndBug> <S2SV_StartBug> if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) { <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> , * next = NULL <S2SV_ModStart> caller_is_in_ancestor ( fc -> pid , controller , path1 , & next <S2SV_ModEnd> <S2SV_ModStart> if ( fpath && strcmp ( next , fpath ) == 0 ) ret = - EEXIST ; else ret = - ENOENT <S2SV_ModEnd> <S2SV_ModStart> fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) { ret = - EACCES ; goto out ; } if ( ! <S2SV_ModStart> free ( next ) ; ",lxc@lxcfs/a8b6c3e0537e90fba3c55910fd1b7229d54a60a7,CVE-2015-1342,https://github.com/lxc/lxcfs/commit/a8b6c3e0537e90fba3c55910fd1b7229d54a60a7,2015-12-07T20:59Z
296,CWE-476,<S2SV_StartBug> disk -> queue = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> put_disk ( disk ) ; ,torvalds@linux/f0d1762554014ce0ae347b9f0d088f2c157c8c72,CVE-2019-15923,https://github.com/torvalds/linux/commit/f0d1762554014ce0ae347b9f0d088f2c157c8c72,2019-09-04T19:15Z
297,CWE-125,"<S2SV_StartBug> void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <S2SV_EndBug> ",<S2SV_ModStart> static ,FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,CVE-2018-8789,https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,2018-11-29T18:29Z
298,CWE-120,"<S2SV_StartBug> if ( CheckMemoryOverflow ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse ) <S2SV_EndBug> <S2SV_StartBug> if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) <S2SV_EndBug> ",<S2SV_ModStart> HeapOverflowSanityCheck <S2SV_ModEnd> <S2SV_ModStart> HeapOverflowSanityCheck <S2SV_ModEnd> ,ImageMagick@ImageMagick/e45e48b881038487d0bc94d92a16c1537616cc0a,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/e45e48b881038487d0bc94d92a16c1537616cc0a,2017-03-03T17:59Z
299,CWE-399,"<S2SV_StartBug> int64_t index_pts = FFMAX ( av_rescale ( itime , i , 10000 ) - asf -> hdr . preroll , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( avio_feof ( s -> pb ) ) { ret = AVERROR_INVALIDDATA ; goto end ; } ,FFmpeg@FFmpeg/afc9c683ed9db01edb357bc8c19edad4282b3a97,CVE-2017-14223,https://github.com/FFmpeg/FFmpeg/commit/afc9c683ed9db01edb357bc8c19edad4282b3a97,2017-09-09T01:29Z
300,CWE-200,"<S2SV_StartBug> rinfo = kmalloc ( SZ_SG_REQ_INFO * SG_MAX_QUEUE , <S2SV_EndBug> ",<S2SV_ModStart> kzalloc <S2SV_ModEnd> ,torvalds@linux/3e0097499839e0fe3af380410eababe5a47c4cf9,CVE-2017-14991,https://github.com/torvalds/linux/commit/3e0097499839e0fe3af380410eababe5a47c4cf9,2017-10-04T01:29Z
301,CWE-200,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> install_keyword ( ""umask"" , & umask_handler ) ; ",acassen@keepalived/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067,CVE-2018-19045,https://github.com/acassen/keepalived/commit/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067,2018-11-08T20:29Z
302,CWE-119,<S2SV_StartBug> return encoder_common_init ( ctx ) ; <S2SV_EndBug> ,"<S2SV_ModStart> vpx_codec_err_t res = VPX_CODEC_OK ; ( void ) data ; if ( ctx -> priv == NULL ) { vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1 , sizeof ( * priv ) ) ; if ( priv == NULL ) return VPX_CODEC_MEM_ERROR ; ctx -> priv = ( vpx_codec_priv_t * ) priv ; ctx -> priv -> init_flags = ctx -> init_flags ; ctx -> priv -> enc . total_encoders = 1 ; priv -> buffer_pool = ( BufferPool * ) vpx_calloc ( 1 , sizeof ( BufferPool ) ) ; if ( priv -> buffer_pool == NULL ) return VPX_CODEC_MEM_ERROR ; # if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & priv -> buffer_pool -> pool_mutex , NULL ) ) { return VPX_CODEC_MEM_ERROR ; } # endif if ( ctx -> config . enc ) { priv -> cfg = * ctx -> config . enc ; ctx -> config . enc = & priv -> cfg ; } priv -> extra_cfg = default_extra_cfg ; once ( vp9_initialize_enc ) ; res = validate_config ( priv , & priv -> cfg , & priv -> extra_cfg ) ; if ( res == VPX_CODEC_OK ) { set_encoder_config ( & priv -> oxcf , & priv -> cfg , & priv -> extra_cfg ) ; # if CONFIG_VP9_HIGHBITDEPTH priv -> oxcf . use_highbitdepth = ( ctx -> init_flags & VPX_CODEC_USE_HIGHBITDEPTH ) ? 1 : 0 ; # endif priv -> cpi = vp9_create_compressor ( & priv -> oxcf , priv -> buffer_pool ) ; if ( priv -> cpi == NULL ) res = VPX_CODEC_MEM_ERROR ; else priv -> cpi -> output_pkt_list = & priv -> pkt_list . head ; } } return res <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
303,CWE-119,<S2SV_StartBug> char * tmpptr = key + strlen ( key ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/cea4dcfdad926a27a18e188720efe0f2c9403456,CVE-2013-2850,https://github.com/torvalds/linux/commit/cea4dcfdad926a27a18e188720efe0f2c9403456,2013-06-07T14:03Z
304,CWE-264,"<S2SV_StartBug> touch_file ( t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> MODE_INVALID <S2SV_ModEnd> ,systemd@systemd/ee735086f8670be1591fa9593e80dd60163a7a2f,CVE-2016-10156,https://github.com/systemd/systemd/commit/ee735086f8670be1591fa9593e80dd60163a7a2f,2017-01-23T07:59Z
305,CWE-476,"<S2SV_StartBug> if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n"" , <S2SV_EndBug> <S2SV_StartBug> if ( box -> len == 1 ) { <S2SV_EndBug> ","<S2SV_ModStart> jp2_box_create0 ( ) ) ) { goto error ; } <S2SV_ModEnd> <S2SV_ModStart> ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>"" ""type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%"" PRIuFAST32 ""\\n"" <S2SV_ModEnd> <S2SV_ModStart> JAS_DBGLOG ( 10 , ( ""big<S2SV_blank>length\\n"" ) ) ; ",mdadams@jasper/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,CVE-2017-6850,https://github.com/mdadams/jasper/commit/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,2017-03-15T14:59Z
306,CWE-190,"<S2SV_StartBug> _Unpickler_ResizeMemoList ( UnpicklerObject * self , Py_ssize_t new_size ) <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> ",<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> ,python@cpython/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,CVE-2018-20406,https://github.com/python/cpython/commit/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,2018-12-23T23:29Z
307,CWE-119,"<S2SV_StartBug> int copylen ; <S2SV_EndBug> <S2SV_StartBug> if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) ) <S2SV_EndBug> <S2SV_StartBug> copylen = vnet_hdr . hdr_len ; <S2SV_EndBug> ","<S2SV_ModStart> = 0 <S2SV_ModStart> err = - EMSGSIZE ; if ( unlikely ( count > UIO_MAXIOV ) ) goto err ; <S2SV_ModStart> if ( count > MAX_SKB_FRAGS ) { copylen = iov_length ( iv , count - MAX_SKB_FRAGS ) ; if ( copylen < vnet_hdr_len ) copylen = 0 ; else copylen -= vnet_hdr_len ; } if ( copylen < vnet_hdr . hdr_len ) ",torvalds@linux/b92946e2919134ebe2a4083e4302236295ea2a73,CVE-2012-2119,https://github.com/torvalds/linux/commit/b92946e2919134ebe2a4083e4302236295ea2a73,2013-01-22T23:55Z
308,CWE-125,<S2SV_StartBug> u16 offset = sizeof ( struct ipv6hdr ) ; <S2SV_EndBug> <S2SV_StartBug> while ( offset + 1 <= packet_len ) { <S2SV_EndBug> <S2SV_StartBug> switch ( * * nexthdr ) { <S2SV_EndBug> <S2SV_StartBug> offset += ipv6_optlen ( exthdr ) ; <S2SV_EndBug> <S2SV_StartBug> exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> struct ipv6_opt_hdr * exthdr ; <S2SV_ModStart> if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <S2SV_ModStart> } return - EINVAL <S2SV_ModEnd> ,torvalds@linux/2423496af35d94a87156b063ea5cedffc10a70a1,CVE-2017-9074,https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1,2017-05-19T07:29Z
309,CWE-119,"<S2SV_StartBug> static void write_delta_q ( struct vp9_write_bit_buffer * wb , int delta_q ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , abs ( delta_q ) , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , delta_q < 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
310,CWE-119,<S2SV_StartBug> find = 1 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
311,CWE-264,"<S2SV_StartBug> put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ; <S2SV_EndBug> ",<S2SV_ModStart> aux . tp_padding = 0 ; ,torvalds@linux/13fcb7bd322164c67926ffe272846d4860196dc6,CVE-2011-2898,https://github.com/torvalds/linux/commit/13fcb7bd322164c67926ffe272846d4860196dc6,2012-05-24T23:55Z
312,CWE-119,<S2SV_StartBug> if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/ad3e14d7c5268c2e24477c6ef54bbdf88add5d36,CVE-2014-3182,https://github.com/torvalds/linux/commit/ad3e14d7c5268c2e24477c6ef54bbdf88add5d36,2014-09-28T10:55Z
313,CWE-119,"<S2SV_StartBug> pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" <S2SV_EndBug> ",<S2SV_ModStart> pr_debug <S2SV_ModEnd> ,torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z
314,CWE-190,<S2SV_StartBug> const int length ) { <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> ,10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z
315,CWE-20,"<S2SV_StartBug> sctp_addiphdr_t * hdr ; <S2SV_EndBug> <S2SV_StartBug> int all_param_pass = 1 ; <S2SV_EndBug> <S2SV_StartBug> while ( chunk_len > 0 ) { <S2SV_EndBug> <S2SV_StartBug> asconf_param ) ; <S2SV_EndBug> <S2SV_StartBug> all_param_pass = 0 ; <S2SV_EndBug> <S2SV_StartBug> asconf_param -> crr_id , err_code , <S2SV_EndBug> <S2SV_StartBug> length = ntohs ( asconf_param -> param_hdr . length ) ; <S2SV_EndBug> ","<S2SV_ModStart> sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) asconf -> chunk_hdr ; bool all_param_pass = true ; union sctp_params param ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sctp_walk_params ( param , addip , addip_hdr . params ) { if ( param . p -> type == SCTP_PARAM_IPV4_ADDRESS || param . p -> type == SCTP_PARAM_IPV6_ADDRESS ) continue ; <S2SV_ModEnd> <S2SV_ModStart> param . addip ) ; if ( err_code != SCTP_ERROR_NO_ERROR <S2SV_ModEnd> <S2SV_ModStart> false <S2SV_ModEnd> <S2SV_ModStart> param . addip <S2SV_ModEnd> <S2SV_ModStart> err_code , param . addip ) ; if ( err_code == SCTP_ERROR_RSRC_LOW <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/9de7922bc709eee2f609cd01d98aaedc4cf5ea74,CVE-2014-3673,https://github.com/torvalds/linux/commit/9de7922bc709eee2f609cd01d98aaedc4cf5ea74,2014-11-10T11:55Z
316,CWE-190,"<S2SV_StartBug> JAS_DBGLOG ( 101 , ( ""jas_realloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%x,%zu\\n"" , ptr , size ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""jas_realloc(%x,<S2SV_blank>%zu)\\n"" <S2SV_ModEnd> ",mdadams@jasper/988f8365f7d8ad8073b6786e433d34c553ecf568,CVE-2016-10249,https://github.com/mdadams/jasper/commit/988f8365f7d8ad8073b6786e433d34c553ecf568,2017-03-15T14:59Z
317,CWE-20,<S2SV_StartBug> m -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
318,CWE-476,<S2SV_StartBug> is_kvmppc_hv_enabled ( kvm ) ; <S2SV_EndBug> ,<S2SV_ModStart> hv_enabled <S2SV_ModEnd> ,torvalds@linux/ac64115a66c18c01745bbd3c47a36b124e5fd8c0,CVE-2017-15306,https://github.com/torvalds/linux/commit/ac64115a66c18c01745bbd3c47a36b124e5fd8c0,2017-11-06T18:29Z
319,CWE-617,"<S2SV_StartBug> pci_populate_msicap ( & msicap , msgnum , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> return <S2SV_ModStart> || <S2SV_ModEnd> ,projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z
320,CWE-119,"<S2SV_StartBug> keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . key ) ; <S2SV_EndBug> <S2SV_StartBug> valuelen = utf8s_to_utf16s ( value , strlen ( value ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . value ) ; <S2SV_EndBug> ","<S2SV_ModStart> UTF16_HOST_ENDIAN , <S2SV_ModStart> , HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2 <S2SV_ModStart> UTF16_HOST_ENDIAN , <S2SV_ModStart> , HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2 ",torvalds@linux/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,CVE-2013-1773,https://github.com/torvalds/linux/commit/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,2013-02-28T19:55Z
321,CWE-399,<S2SV_StartBug> ctx = d -> log_ctx ; <S2SV_EndBug> ,<S2SV_ModStart> d -> log_file = eventfp ; ,torvalds@linux/7932c0bd7740f4cd2aa168d3ce0199e7af7d72d5,CVE-2015-6252,https://github.com/torvalds/linux/commit/7932c0bd7740f4cd2aa168d3ce0199e7af7d72d5,2015-10-19T10:59Z
322,CWE-125,<S2SV_StartBug> img -> color_space = OPJ_CLRSPC_SRGB ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,uclouvain@openjpeg/15f081c89650dccee4aa4ae66f614c3fdb268767,CVE-2016-3183,https://github.com/uclouvain/openjpeg/commit/15f081c89650dccee4aa4ae66f614c3fdb268767,2017-02-03T16:59Z
323,CWE-399,<S2SV_StartBug> void * parg = NULL ; <S2SV_EndBug> <S2SV_StartBug> int is_ext_ctrl ; <S2SV_EndBug> <S2SV_StartBug> case _IOC_NONE : <S2SV_EndBug> <S2SV_StartBug> case _IOC_WRITE : <S2SV_EndBug> <S2SV_StartBug> if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> ( void * ) arg ; long err = - EINVAL ; bool has_array_args ; size_t array_size = 0 ; void __user * user_ptr = NULL ; void * * kernel_ptr = NULL ; if ( _IOC_DIR ( cmd ) != _IOC_NONE ) { if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) { parg = sbuf ; } else { mbuf = kmalloc ( _IOC_SIZE ( cmd ) , GFP_KERNEL ) ; if ( NULL == mbuf ) return - ENOMEM ; parg = mbuf ; } err = - EFAULT ; if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) { unsigned long n = cmd_input_size ( cmd ) ; if ( copy_from_user ( parg , ( void __user * ) arg , n ) ) goto out ; if ( n < _IOC_SIZE ( cmd ) ) memset ( ( u8 * ) parg + n , 0 , _IOC_SIZE ( cmd ) - n ) ; } else { memset ( parg , 0 , _IOC_SIZE ( cmd ) ) ; } } err = check_array_args ( cmd , parg , & array_size , & user_ptr , & kernel_ptr ) ; if ( err < 0 ) goto out ; has_array_args = err ; if ( has_array_args ) { mbuf = kmalloc ( array_size , GFP_KERNEL ) ; err = - ENOMEM ; if ( NULL == mbuf ) goto out_array_args ; err = - EFAULT ; if ( copy_from_user ( mbuf , user_ptr , array_size ) ) goto out_array_args ; * kernel_ptr = mbuf ; } err = func ( file , cmd , parg ) ; if ( err == - ENOIOCTLCMD ) <S2SV_ModEnd> <S2SV_ModStart> if ( has_array_args ) { * kernel_ptr = user_ptr ; if ( copy_to_user ( user_ptr , mbuf , array_size ) ) err = - EFAULT ; goto out_array_args ; } if ( err < 0 ) goto out ; out_array_args : <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/fc0a80798576f80ca10b3f6c9c7097f12fd1d64e,CVE-2010-5329,https://github.com/torvalds/linux/commit/fc0a80798576f80ca10b3f6c9c7097f12fd1d64e,2017-04-24T06:59Z
324,CWE-20,<S2SV_StartBug> if ( server . vm_enabled && server . vm_max_threads > 0 && <S2SV_EndBug> ,<S2SV_ModStart> ds_enabled && <S2SV_ModEnd> ,antirez@redis/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,CVE-2013-0178,https://github.com/antirez/redis/commit/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,2019-11-01T19:15Z
325,CWE-119,"<S2SV_StartBug> static int set_registers ( rtl8150_t * dev , u16 indx , u16 size , void * data ) <S2SV_EndBug> <S2SV_StartBug> return usb_control_msg ( dev -> udev , usb_sndctrlpipe ( dev -> udev , 0 ) , <S2SV_EndBug> <S2SV_StartBug> indx , 0 , data , size , 500 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> const <S2SV_ModStart> void * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> kfree ( buf ) ; return ret ; ",torvalds@linux/7926aff5c57b577ab0f43364ff0c59d968f6a414,CVE-2017-8069,https://github.com/torvalds/linux/commit/7926aff5c57b577ab0f43364ff0c59d968f6a414,2017-04-23T05:59Z
326,CWE-000,<S2SV_StartBug> endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( usbinterface -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & usbinterface -> dev , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n"" ) ; error = - EINVAL ; goto err_free_urb ; } ",torvalds@linux/162f98dea487206d9ab79fc12ed64700667a894d,CVE-2016-2187,https://github.com/torvalds/linux/commit/162f98dea487206d9ab79fc12ed64700667a894d,2016-05-02T10:59Z
327,CWE-20,<S2SV_StartBug> case RESPONSE_RUN : <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> GTK_RESPONSE_OK : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_set_metadata ( parameters -> file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL , ""yes"" ) ; nautilus_file_mark_desktop_file_executable ( file , parameters -> parent_window , TRUE , NULL , NULL ) ; nautilus_file_invalidate_all_attributes ( parameters -> file ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",GNOME@nautilus/1630f53481f445ada0a455e9979236d31a8d3bb0,CVE-2017-14604,https://github.com/GNOME/nautilus/commit/1630f53481f445ada0a455e9979236d31a8d3bb0,2017-09-20T08:29Z
328,CWE-191,<S2SV_StartBug> if ( edge_port -> lsr_event ) { <S2SV_EndBug> ,<S2SV_ModStart> urb -> actual_length > 0 && ,torvalds@linux/654b404f2a222f918af9b0cd18ad469d0c941a8e,CVE-2017-8924,https://github.com/torvalds/linux/commit/654b404f2a222f918af9b0cd18ad469d0c941a8e,2017-05-12T21:29Z
329,CWE-264,"<S2SV_StartBug> cifs_find_smb_ses ( struct TCP_Server_Info * server , char * username ) <S2SV_EndBug> <S2SV_StartBug> list_for_each ( tmp , & server -> smb_ses_list ) { <S2SV_EndBug> <S2SV_StartBug> if ( strncmp ( ses -> userName , username , MAX_USERNAME_SIZE ) ) <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> ","<S2SV_ModStart> struct smb_vol * vol ) { <S2SV_ModEnd> <S2SV_ModStart> list_for_each_entry ( ses <S2SV_ModEnd> <S2SV_ModStart> , smb_ses_list ) { switch ( server -> secType ) { case Kerberos : if ( vol -> linux_uid != ses -> linux_uid ) continue ; break ; default : <S2SV_ModEnd> <S2SV_ModStart> vol -> <S2SV_ModStart> if ( strlen ( vol -> username ) != 0 && strncmp ( ses -> password , vol -> password , MAX_PASSWORD_SIZE ) ) continue ; } ",torvalds@linux/4ff67b720c02c36e54d55b88c2931879b7db1cd2,CVE-2011-1585,https://github.com/torvalds/linux/commit/4ff67b720c02c36e54d55b88c2931879b7db1cd2,2013-06-08T13:05Z
330,CWE-119,"<S2SV_StartBug> if ( ( ( cfg -> g_w != ctx -> cfg . g_w ) || ( cfg -> g_h != ctx -> cfg . g_h ) ) <S2SV_EndBug> <S2SV_StartBug> && ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS ) ) <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> { if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ( ctx -> cpi -> initial_width && ( int ) cfg -> g_w > ctx -> cpi -> initial_width ) || ( ctx -> cpi -> initial_height && ( int ) cfg -> g_h > ctx -> cpi -> initial_height ) ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>their<S2SV_blank>initial<S2SV_blank>values"" ) ; } ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
331,CWE-119,"<S2SV_StartBug> input ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ! r_fs_mount ( core -> fs , ptr , input , off ) ) <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = r_fs_name ( core -> fs , core -> offset ) ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( ! r_fs_mount ( core -> fs , ptr , input , core -> offset ) ) <S2SV_EndBug> <S2SV_StartBug> eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\n"" , input ) ; <S2SV_EndBug> ",<S2SV_ModStart> { input ++ ; } <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } ,radare@radare2/65000a7fd9eea62359e6d6714f17b94a99a82edd,CVE-2017-9763,https://github.com/radare/radare2/commit/65000a7fd9eea62359e6d6714f17b94a99a82edd,2017-06-19T16:29Z
332,CWE-399,"<S2SV_StartBug> if ( vm_flags & VM_NORESERVE ) <S2SV_EndBug> <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> hugepage_subpool_get_pages ( spool <S2SV_ModEnd> <S2SV_ModStart> hugepage_subpool_put_pages ( spool <S2SV_ModEnd> ,torvalds@linux/90481622d75715bfcb68501280a917dbfe516029,CVE-2012-2133,https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029,2012-07-03T16:40Z
333,CWE-404,<S2SV_StartBug> struct key * keyring ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( new -> thread_keyring ) return 0 ,torvalds@linux/c9f838d104fed6f2f61d68164712e3204bf5271b,CVE-2017-7472,https://github.com/torvalds/linux/commit/c9f838d104fed6f2f61d68164712e3204bf5271b,2017-05-11T19:29Z
334,CWE-399,<S2SV_StartBug> static size_t scanned ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,jedisct1@pure-ftpd/65c4d4ad331e94661de763e9b5304d28698999c4,CVE-2011-1575,https://github.com/jedisct1/pure-ftpd/commit/65c4d4ad331e94661de763e9b5304d28698999c4,2011-05-23T22:55Z
335,CWE-416,<S2SV_StartBug> fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ; <S2SV_EndBug> <S2SV_StartBug> fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ; <S2SV_EndBug> ,"<S2SV_ModStart> fptr_orig = io_get_open_fptr ( mrb , orig ) ; <S2SV_ModStart>  <S2SV_ModEnd> ",mruby@mruby/b51b21fc63c9805862322551387d9036f2b63433,CVE-2018-10199,https://github.com/mruby/mruby/commit/b51b21fc63c9805862322551387d9036f2b63433,2018-04-18T15:29Z
336,CWE-476,"<S2SV_StartBug> . match_data . cmp = user_match , <S2SV_EndBug> ",<S2SV_ModStart> key_default_cmp <S2SV_ModEnd> ,torvalds@linux/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,CVE-2017-2647,https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,2017-03-31T04:59Z
337,CWE-119,"<S2SV_StartBug> cpi -> zbin_mode_boost = 0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> td . ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
338,CWE-119,"<S2SV_StartBug> utee_param_to_param ( param , callee_params ) ; <S2SV_EndBug> ","<S2SV_ModStart> res = utee_param_to_param ( utc , <S2SV_ModEnd> <S2SV_ModStart> ; if ( res != TEE_SUCCESS ) return res ",OP-TEE@optee_os/d5c5b0b77b2b589666024d219a8007b3f5b6faeb,CVE-2019-1010295,https://github.com/OP-TEE/optee_os/commit/d5c5b0b77b2b589666024d219a8007b3f5b6faeb,2019-07-15T18:15Z
339,CWE-000,"<S2SV_StartBug> old_cs = get_segment_selector ( ctxt , VCPU_SREG_CS ) ; <S2SV_EndBug> <S2SV_StartBug> if ( load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) ) <S2SV_EndBug> <S2SV_StartBug> ctxt -> _eip = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; int cpl = ctxt -> ops -> cpl ( ctxt ) ; old_eip = ctxt -> _eip ; ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rc = __load_segment_descriptor <S2SV_ModEnd> <S2SV_ModStart> , cpl , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE <S2SV_ModEnd> <S2SV_ModStart> rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_cs ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_eip ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; return rc ; fail : ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; return rc <S2SV_ModEnd> ",torvalds@linux/d1442d85cc30ea75f7d399474ca738e0bc96f715,CVE-2014-3647,https://github.com/torvalds/linux/commit/d1442d85cc30ea75f7d399474ca738e0bc96f715,2014-11-10T11:55Z
340,CWE-000,"<S2SV_StartBug> reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ; <S2SV_EndBug> <S2SV_StartBug> band -> prec = av_malloc_array ( reslevel -> num_precincts_x * <S2SV_EndBug> ",<S2SV_ModStart> av_calloc <S2SV_ModEnd> <S2SV_ModStart> av_calloc <S2SV_ModEnd> ,FFmpeg@FFmpeg/912ce9dd2080c5837285a471d750fa311e09b555,CVE-2013-7017,https://github.com/FFmpeg/FFmpeg/commit/912ce9dd2080c5837285a471d750fa311e09b555,2013-12-09T16:36Z
341,CWE-269,"<S2SV_StartBug> COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! COM_CompareExtension ( filename , "".txt"" ) ) { Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".txt\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" ) ; return ; } ",iortcw@iortcw/11a83410153756ae350a82ed41b08d128ff7f998,CVE-2017-6903,https://github.com/iortcw/iortcw/commit/11a83410153756ae350a82ed41b08d128ff7f998,2017-03-14T22:59Z
342,CWE-119,"<S2SV_StartBug> struct reloc_struct_t * got_table = calloc ( 1 , n_got * sizeof ( ut32 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct reloc_struct_t <S2SV_ModEnd> ,radare@radare2/72794dc3523bbd5bb370de3c5857cb736c387e18,CVE-2017-6194,https://github.com/radare/radare2/commit/72794dc3523bbd5bb370de3c5857cb736c387e18,2017-04-03T05:59Z
343,CWE-000,<S2SV_StartBug> if ( info -> si_code >= 0 ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug> ,<S2SV_ModStart> != SI_QUEUE ) { WARN_ON_ONCE ( info -> si_code < 0 ) ; <S2SV_ModEnd> <S2SV_ModStart> } ,torvalds@linux/da48524eb20662618854bb3df2db01fc65f3070c,CVE-2011-1182,https://github.com/torvalds/linux/commit/da48524eb20662618854bb3df2db01fc65f3070c,2013-03-01T12:37Z
344,CWE-190,"<S2SV_StartBug> * p_tx0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> tx0 + p * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x0 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x1 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y0 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ( OPJ_INT32 ) opj_uint_max <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ( OPJ_INT32 ) opj_uint_min <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ( OPJ_INT32 ) opj_uint_max <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ( OPJ_INT32 ) opj_uint_min <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> ",uclouvain@openjpeg/5d00b719f4b93b1445e6fb4c766b9a9883c57949,CVE-2018-20847,https://github.com/uclouvain/openjpeg/commit/5d00b719f4b93b1445e6fb4c766b9a9883c57949,2019-06-26T18:15Z
345,CWE-22,"<S2SV_StartBug> static char * create_output_name ( unsigned char * fname , unsigned char * dir , <S2SV_EndBug> <S2SV_StartBug> if ( utf8 ) x *= 3 ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""out<S2SV_blank>of<S2SV_blank>memory!\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> while ( * fname == sep ) fname ++ ; <S2SV_EndBug> <S2SV_StartBug> p = & name [ strlen ( ( char * ) name ) ] ; <S2SV_EndBug> <S2SV_StartBug> if ( fname >= fe ) { <S2SV_EndBug> <S2SV_StartBug> x = ( c & 0x1F ) << 6 ; <S2SV_EndBug> <S2SV_StartBug> } while ( x ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) { char * out , * p <S2SV_ModEnd> <S2SV_ModStart> ( out = malloc ( strlen ( fname ) + 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> '/' || * fname == '\\\\' <S2SV_ModEnd> <S2SV_ModStart> strcpy ( out , ( * fname ) ? fname : ""x"" ) ; for ( p = out ; * p ; p ++ ) <S2SV_ModEnd> <S2SV_ModStart> p [ 0 ] == '.' && p [ 1 ] == '.' && ( p [ 2 ] == '/' || p [ 2 ] == '\\\\' <S2SV_ModEnd> <S2SV_ModStart> p [ 0 ] = p [ 1 ] = 'x' <S2SV_ModEnd> <S2SV_ModStart> } return out <S2SV_ModEnd> ",kyz@libmspack/7cadd489698be117c47efcadd742651594429e6d,CVE-2018-18586,https://github.com/kyz/libmspack/commit/7cadd489698be117c47efcadd742651594429e6d,2018-10-23T02:29Z
346,CWE-416,"<S2SV_StartBug> zval * options = NULL , * classes = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { <S2SV_EndBug> <S2SV_StartBug> zval_ptr_dtor ( return_value ) ; <S2SV_EndBug> <S2SV_StartBug> var_push_dtor ( & var_hash , return_value ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; zval * retval <S2SV_ModStart> retval = var_tmp_var ( & var_hash ) ; <S2SV_ModStart> retval <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ZVAL_COPY ( return_value , retval <S2SV_ModEnd> ",php@php-src/b2af4e8868726a040234de113436c6e4f6372d17,CVE-2016-9936,https://github.com/php/php-src/commit/b2af4e8868726a040234de113436c6e4f6372d17,2017-01-04T20:59Z
347,CWE-200,<S2SV_StartBug> kfree ( tu -> queue ) ; <S2SV_EndBug> ,<S2SV_ModStart> tu -> qhead = tu -> qtail = tu -> qused = 0 ; ,torvalds@linux/ba3021b2c79b2fa9114f92790a99deb27a65b728,CVE-2017-1000380,https://github.com/torvalds/linux/commit/ba3021b2c79b2fa9114f92790a99deb27a65b728,2017-06-17T18:29Z
348,CWE-125,<S2SV_StartBug> tmp_strsize = ( u32 ) ptr -> size - 8 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,gpac@gpac/8e05648d6b4459facbc783025c5c42d301fef5c3,CVE-2020-23928,https://github.com/gpac/gpac/commit/8e05648d6b4459facbc783025c5c42d301fef5c3,2021-04-21T18:15Z
349,CWE-119,<S2SV_StartBug> buf = ctx -> iface -> enc . get_glob_hdrs ( ctx -> priv -> alg_priv ) ; <S2SV_EndBug> ,<S2SV_ModStart> get_alg_priv ( ctx ) <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
350,CWE-404,"<S2SV_StartBug> else if ( Ustrcmp ( argrest , ""Mr"" ) == 0 ) received_protocol = argv [ ++ i ] ; <S2SV_EndBug> <S2SV_StartBug> uschar * hn = Ustrchr ( argrest , ':' ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( received_protocol ) { fprintf ( stderr , ""received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\n"" ) ; exit ( EXIT_FAILURE ) ; } else <S2SV_ModStart> hn ; if ( received_protocol ) { fprintf ( stderr , ""received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\n"" ) ; exit ( EXIT_FAILURE ) ; } ",Exim@exim/65e061b76867a9ea7aeeb535341b790b90ae6c21,CVE-2017-1000369,https://github.com/Exim/exim/commit/65e061b76867a9ea7aeeb535341b790b90ae6c21,2017-06-19T16:29Z
351,CWE-000,<S2SV_StartBug> if ( info -> si_code >= 0 ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug> ,<S2SV_ModStart> != SI_QUEUE ) { WARN_ON_ONCE ( info -> si_code < 0 ) ; <S2SV_ModEnd> <S2SV_ModStart> } ,torvalds@linux/da48524eb20662618854bb3df2db01fc65f3070c,CVE-2011-1182,https://github.com/torvalds/linux/commit/da48524eb20662618854bb3df2db01fc65f3070c,2013-03-01T12:37Z
352,CWE-119,"<S2SV_StartBug> s -> off = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> <S2SV_StartBug> s -> filesize = strtoll ( slash + 1 , NULL , 10 ) ; <S2SV_EndBug> ",<S2SV_ModStart> strtoull <S2SV_ModEnd> <S2SV_ModStart> strtoull <S2SV_ModEnd> ,FFmpeg@FFmpeg/2a05c8f813de6f2278827734bf8102291e7484aa,CVE-2016-10190,https://github.com/FFmpeg/FFmpeg/commit/2a05c8f813de6f2278827734bf8102291e7484aa,2017-02-09T15:59Z
353,CWE-125,"<S2SV_StartBug> unsigned int maxw , maxh , max ; <S2SV_EndBug> <S2SV_StartBug> unsigned int i , j ; <S2SV_EndBug> <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0U ; i < maxh ; ++ i ) <S2SV_EndBug> <S2SV_StartBug> for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> <S2SV_StartBug> if ( j < maxw ) { <S2SV_EndBug> <S2SV_StartBug> # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_EndBug> <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> <S2SV_StartBug> if ( g ) free ( g ) ; <S2SV_EndBug> <S2SV_StartBug> if ( b ) free ( b ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> , offx , loopmaxw <S2SV_ModStart> size_t i <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; <S2SV_ModStart> size_t j ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } <S2SV_ModStart> loopmaxw <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> loopmaxw <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> <S2SV_ModStart> dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",uclouvain@openjpeg/15f081c89650dccee4aa4ae66f614c3fdb268767,CVE-2016-3183,https://github.com/uclouvain/openjpeg/commit/15f081c89650dccee4aa4ae66f614c3fdb268767,2017-02-03T16:59Z
354,CWE-000,"<S2SV_StartBug> nfs4_state_set_mode_locked ( struct nfs4_state * state , mode_t mode ) <S2SV_EndBug> <S2SV_StartBug> if ( state -> state == mode ) <S2SV_EndBug> <S2SV_StartBug> if ( ( mode & FMODE_WRITE ) != ( state -> state & FMODE_WRITE ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( mode & FMODE_WRITE ) <S2SV_EndBug> <S2SV_StartBug> state -> state = mode ; <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> ,torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z
355,CWE-399,"<S2SV_StartBug> ptr = sshpkt_ptr ( ssh , & dlen ) ; <S2SV_EndBug> ","<S2SV_ModStart> ssh_dispatch_set ( ssh , SSH2_MSG_KEXINIT , NULL ) ; ",openssh@openssh-portable/ec165c392ca54317dbe3064a8c200de6531e89ad,CVE-2016-8858,https://github.com/openssh/openssh-portable/commit/ec165c392ca54317dbe3064a8c200de6531e89ad,2016-12-09T11:59Z
356,CWE-119,"<S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> ","<S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[256]<S2SV_blank>==<S2SV_blank>256<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\""baz\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""foo\\""]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""bar\\""]<S2SV_blank>==<S2SV_blank>\\""bar\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\""dummy\\"")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""foo\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""bar\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> ",VirusTotal@yara/4a342f01e5439b9bb901aff1c6c23c536baeeb3f,CVE-2017-11328,https://github.com/VirusTotal/yara/commit/4a342f01e5439b9bb901aff1c6c23c536baeeb3f,2017-07-17T13:18Z
357,CWE-416,<S2SV_StartBug> ( void ) CloseBlob ( pwp_image ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,ImageMagick@ImageMagick/ecc03a2518c2b7dd375fde3a040fdae0bdf6a521,CVE-2016-10051,https://github.com/ImageMagick/ImageMagick/commit/ecc03a2518c2b7dd375fde3a040fdae0bdf6a521,2017-03-23T17:59Z
358,CWE-119,"<S2SV_StartBug> char lbase [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char strbase [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char ltest [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char strtest [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> int nbase = sscanf ( lbase , ""%255[^\\r\\n]"" , strbase ) ; <S2SV_EndBug> <S2SV_StartBug> int ntest = sscanf ( ltest , ""%255[^\\r\\n]"" , strtest ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( nbase != 255 && ntest != 255 ) ; <S2SV_EndBug> ","<S2SV_ModStart> 512 <S2SV_ModEnd> <S2SV_ModStart> 512 <S2SV_ModEnd> <S2SV_ModStart> 512 <S2SV_ModEnd> <S2SV_ModStart> 512 <S2SV_ModEnd> <S2SV_ModStart> ""%511[^\\r\\n]"" <S2SV_ModEnd> <S2SV_ModStart> ""%511[^\\r\\n]"" <S2SV_ModEnd> <S2SV_ModStart> 511 <S2SV_ModEnd> <S2SV_ModStart> 511 <S2SV_ModEnd> ",uclouvain@openjpeg/e078172b1c3f98d2219c37076b238fb759c751ea,CVE-2016-5157,https://github.com/uclouvain/openjpeg/commit/e078172b1c3f98d2219c37076b238fb759c751ea,2016-09-11T10:59Z
359,CWE-000,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = cdc_ncm_bind_common ( dev , intf , CDC_NCM_DATA_ALTSETTING_NCM , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> usbnet_link_change ( dev , 0 , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/4d06dd537f95683aba3651098ae288b7cbff8274,CVE-2016-3951,https://github.com/torvalds/linux/commit/4d06dd537f95683aba3651098ae288b7cbff8274,2016-05-02T10:59Z
360,CWE-120,"<S2SV_StartBug> memcpy ( elem . in_sg [ 0 ] . iov_base , buf , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> iov_from_buf <S2SV_ModEnd> <S2SV_ModStart> , elem . in_num , 0 <S2SV_ModEnd> ",qemu@qemu/7882080388be5088e72c425b02223c02e6cb4295,CVE-2015-5745,https://github.com/qemu/qemu/commit/7882080388be5088e72c425b02223c02e6cb4295,2020-01-23T20:15Z
361,CWE-000,"<S2SV_StartBug> i , ( unsigned ) JPC_QCX_GETEXPN ( qcd -> compparms . stepsizes [ i ] ) , <S2SV_EndBug> <S2SV_StartBug> i , ( unsigned ) JPC_QCX_GETMANT ( qcd -> compparms . stepsizes [ i ] ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> JAS_CAST ( unsigned , <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> JAS_CAST ( unsigned , <S2SV_ModEnd> <S2SV_ModStart> ) ",mdadams@jasper/1e84674d95353c64e5c4c0e7232ae86fd6ea813b,CVE-2016-9391,https://github.com/mdadams/jasper/commit/1e84674d95353c64e5c4c0e7232ae86fd6ea813b,2017-03-23T18:59Z
362,CWE-264,"<S2SV_StartBug> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <S2SV_EndBug> ","<S2SV_ModStart> elems , e -> ",torvalds@linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,CVE-2016-4997,https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,2016-07-03T21:59Z
363,CWE-119,<S2SV_StartBug> } else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) { <S2SV_EndBug> ,<S2SV_ModStart> && c -> format != CHUNKY ,FFmpeg@FFmpeg/1e42736b95065c69a7481d0cf55247024f54b660,CVE-2017-9996,https://github.com/FFmpeg/FFmpeg/commit/1e42736b95065c69a7481d0cf55247024f54b660,2017-06-28T06:29Z
364,CWE-125,"<S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z
365,CWE-362,<S2SV_StartBug> snd_seq_timer_stop ( q -> timer ) ; <S2SV_EndBug> <S2SV_StartBug> snd_seq_timer_close ( q ) ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & q -> timer_mutex ) ; <S2SV_ModStart> ) ; mutex_unlock ( & q -> timer_mutex ,torvalds@linux/3567eb6af614dac436c4b16a8d426f9faed639b3,CVE-2016-2544,https://github.com/torvalds/linux/commit/3567eb6af614dac436c4b16a8d426f9faed639b3,2016-04-27T17:59Z
366,CWE-119,"<S2SV_StartBug> u64 start = offset >> PAGE_CACHE_SHIFT ; <S2SV_EndBug> <S2SV_StartBug> u64 end = ( offset + len - 1 ) >> PAGE_CACHE_SHIFT ; <S2SV_EndBug> <S2SV_StartBug> ! ( mode & FALLOC_FL_KEEP_SIZE ) ) { <S2SV_EndBug> <S2SV_StartBug> i_size_write ( inode , offset + to ) ; <S2SV_EndBug> <S2SV_StartBug> mark_inode_dirty ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> return error ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned int nr_blks ; sector_t lblock <S2SV_ModEnd> <S2SV_ModStart> inode -> i_blkbits ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) return error ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } while ( len ) { struct buffer_head bh_map = { . b_state = 0 , . b_blocknr = 0 } ; bh_map . b_size = len ; set_buffer_zeronew ( & bh_map ) ; error = gfs2_block_map ( inode , lblock , & bh_map , 1 ) ; if ( unlikely ( error ) ) goto out ; len -= bh_map . b_size ; nr_blks = bh_map . b_size >> inode -> i_blkbits ; lblock += nr_blks ; if ( ! buffer_new ( & bh_map ) ) continue ; if ( unlikely ( ! buffer_zeronew ( & bh_map ) ) ) { error = - EIO ; goto out ; } } if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> len ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> brelse ( dibh ) ; ",torvalds@linux/64dd153c83743af81f20924c6343652d731eeecb,CVE-2011-4098,https://github.com/torvalds/linux/commit/64dd153c83743af81f20924c6343652d731eeecb,2013-06-08T13:05Z
367,CWE-362,<S2SV_StartBug> VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ; <S2SV_EndBug> <S2SV_StartBug> vips_image_pio_input ( load -> real ) ) <S2SV_EndBug> <S2SV_StartBug> return ( NULL ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; if ( load -> error ) return ( NULL <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> { vips_operation_invalidate ( VIPS_OPERATION ( load ) ) ; load -> error = TRUE ; return ( NULL ) ; } <S2SV_ModEnd> ,jcupitt@libvips/20d840e6da15c1574b3ed998bc92f91d1e36c2a5,CVE-2018-7998,https://github.com/jcupitt/libvips/commit/20d840e6da15c1574b3ed998bc92f91d1e36c2a5,2018-03-09T19:29Z
368,CWE-000,"<S2SV_StartBug> const char * name = fit_get_name ( fit , noffset , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( strchr ( name , '@' ) ) { err_msg = ""Node<S2SV_blank>name<S2SV_blank>contains<S2SV_blank>@"" ; goto error ; } ",u-boot@u-boot/79af75f7776fc20b0d7eb6afe1e27c00fdb4b9b4,CVE-2021-27138,https://github.com/u-boot/u-boot/commit/79af75f7776fc20b0d7eb6afe1e27c00fdb4b9b4,2021-02-17T23:15Z
369,CWE-400,<S2SV_StartBug> if ( retval ) <S2SV_EndBug> ,<S2SV_ModStart> ! retval ) <S2SV_ModEnd> ,torvalds@linux/2e83b79b2d6c78bf1b4aa227938a214dcbddc83f,CVE-2016-9685,https://github.com/torvalds/linux/commit/2e83b79b2d6c78bf1b4aa227938a214dcbddc83f,2016-12-28T07:59Z
370,CWE-401,"<S2SV_StartBug> if ( kfifo_alloc ( & state -> rx_kfifo , CX23888_IR_RX_KFIFO_SIZE , GFP_KERNEL ) ) <S2SV_EndBug> <S2SV_StartBug> state -> dev = dev ; <S2SV_EndBug> ",<S2SV_ModStart> { kfree ( state ) ; <S2SV_ModStart> } ,torvalds@linux/a7b2df76b42bdd026e3106cf2ba97db41345a177,CVE-2019-19054,https://github.com/torvalds/linux/commit/a7b2df76b42bdd026e3106cf2ba97db41345a177,2019-11-18T06:15Z
371,CWE-476,<S2SV_StartBug> size += service_name_tlv_length ; <S2SV_EndBug> <S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! service_name_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; } ,torvalds@linux/58bdd544e2933a21a51eecf17c3f5f94038261b5,CVE-2019-12818,https://github.com/torvalds/linux/commit/58bdd544e2933a21a51eecf17c3f5f94038261b5,2019-06-14T02:29Z
372,CWE-119,<S2SV_StartBug> struct ssh * ssh = active_state ; <S2SV_EndBug> <S2SV_StartBug> if ( options . compression ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,openbsd@src/3095060f479b86288e31c79ecbc5131a66bcd2f9,CVE-2016-10012,https://github.com/openbsd/src/commit/3095060f479b86288e31c79ecbc5131a66bcd2f9,2017-01-05T02:59Z
373,CWE-119,"<S2SV_StartBug> vpx_codec_dec_cfg_t * cfg , <S2SV_EndBug> <S2SV_StartBug> else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) <S2SV_EndBug> <S2SV_StartBug> res = VPX_CODEC_OK ; <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> priv ) <S2SV_EndBug> ",<S2SV_ModStart> const <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
374,CWE-476,<S2SV_StartBug> unsigned int channo ; <S2SV_EndBug> ,<S2SV_ModStart> ; cdef -> ents = 0 ,mdadams@jasper/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,CVE-2017-6850,https://github.com/mdadams/jasper/commit/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,2017-03-15T14:59Z
375,CWE-20,<S2SV_StartBug> value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ ; <S2SV_EndBug> ,<S2SV_ModStart> TJA1100_CONFIG1_MII_MODE_RMII_25MHZ_XTAL <S2SV_ModEnd> ,Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
376,CWE-362,"<S2SV_StartBug> if ( ip_options_echo ( & icmp_param . replyopts , skb_in ) ) <S2SV_EndBug> <S2SV_StartBug> ipc . opt = & icmp_param . replyopts ; <S2SV_EndBug> <S2SV_StartBug> room -= sizeof ( struct iphdr ) + icmp_param . replyopts . optlen ; <S2SV_EndBug> ",<S2SV_ModStart> . opt . opt <S2SV_ModStart> . opt <S2SV_ModStart> opt . opt . ,torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z
377,CWE-125,"<S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_32BITS <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,the-tcpdump-group@tcpdump/7029d15f148ef24bb7c6668bc640f5470d085e5a,CVE-2017-13029,https://github.com/the-tcpdump-group/tcpdump/commit/7029d15f148ef24bb7c6668bc640f5470d085e5a,2017-09-14T06:29Z
378,CWE-476,<S2SV_StartBug> skb_dst_drop ( skb ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( IPCB ( skb ) -> opt . optlen ) ) skb_dst_force ( skb ) ; else ,torvalds@linux/34b2cef20f19c87999fff3da4071e66937db9644,CVE-2017-5970,https://github.com/torvalds/linux/commit/34b2cef20f19c87999fff3da4071e66937db9644,2017-02-14T06:59Z
379,CWE-476,<S2SV_StartBug> crypto_free_skcipher ( private ) ; <S2SV_EndBug> ,<S2SV_ModStart> struct skcipher_tfm * tfm = private ; crypto_free_skcipher ( tfm -> skcipher ) ; kfree ( tfm <S2SV_ModEnd> ,torvalds@linux/dd504589577d8e8e70f51f997ad487a4cb6c026f,CVE-2015-8970,https://github.com/torvalds/linux/commit/dd504589577d8e8e70f51f997ad487a4cb6c026f,2016-11-28T03:59Z
380,CWE-362,<S2SV_StartBug> struct inode * inode = file_inode ( bprm -> file ) ; <S2SV_EndBug> <S2SV_StartBug> bprm -> cred -> euid = current_euid ( ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> bprm_fill_uid ( bprm ) ; <S2SV_ModEnd> ,torvalds@linux/8b01fc86b9f425899f8a3a8fc1c47d73c2c20543,CVE-2015-3339,https://github.com/torvalds/linux/commit/8b01fc86b9f425899f8a3a8fc1c47d73c2c20543,2015-05-27T10:59Z
381,CWE-20,<S2SV_StartBug> return headcount ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( datalen > 0 ) ) { r = UIO_MAXIOV + 1 ; goto err ; } ,torvalds@linux/d8316f3991d207fe32881a9ac20241be8fa2bad0,CVE-2014-0077,https://github.com/torvalds/linux/commit/d8316f3991d207fe32881a9ac20241be8fa2bad0,2014-04-14T23:55Z
382,CWE-191,<S2SV_StartBug> dlen -= 2 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( dlen < 2 ) break ; <S2SV_ModStart>  <S2SV_ModEnd> ,neomutt@neomutt/65d64a5b60a4a3883f2cd799d92c6091d8854f23,CVE-2018-14353,https://github.com/neomutt/neomutt/commit/65d64a5b60a4a3883f2cd799d92c6091d8854f23,2018-07-17T17:29Z
383,CWE-362,"<S2SV_StartBug> rq = blk_mq_tag_to_rq ( tags , off + bit ) ; <S2SV_EndBug> ",<S2SV_ModStart> tags -> rqs [ <S2SV_ModEnd> <S2SV_ModStart> ] <S2SV_ModEnd> ,torvalds@linux/0048b4837affd153897ed1222283492070027aa9,CVE-2015-9016,https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9,2018-04-05T18:29Z
384,CWE-119,<S2SV_StartBug> else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> priv ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
385,CWE-20,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
386,CWE-189,<S2SV_StartBug> if ( skb_is_nonlinear ( skb ) ) <S2SV_EndBug> ,<S2SV_ModStart> ) ) return 0 ; if ( skb -> len < sizeof ( struct nlattr ,torvalds@linux/05ab8f2647e4221cbdb3856dd7d32bd5407316b3,CVE-2014-3145,https://github.com/torvalds/linux/commit/05ab8f2647e4221cbdb3856dd7d32bd5407316b3,2014-05-11T21:55Z
387,CWE-000,"<S2SV_StartBug> encode_share_access ( xdr , arg -> open_flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode <S2SV_ModEnd> ,torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z
388,CWE-125,"<S2SV_StartBug> isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len <S2SV_ModStart>  <S2SV_ModEnd> ",the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z
389,CWE-119,<S2SV_StartBug> tilebuf = _TIFFmalloc ( tile_buffsize ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( tile_buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size."" ) ; exit ( - 1 ) ; } <S2SV_ModStart> + 3 <S2SV_ModStart> 0 ; tilebuf [ tile_buffsize ] = 0 ; tilebuf [ tile_buffsize + 1 ] = 0 ; tilebuf [ tile_buffsize + 2 ] = ",vadz@libtiff/ae9365db1b271b62b35ce018eac8799b1d5e8a53,CVE-2016-9539,https://github.com/vadz/libtiff/commit/ae9365db1b271b62b35ce018eac8799b1d5e8a53,2016-11-22T19:59Z
390,CWE-59,"<S2SV_StartBug> int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <S2SV_EndBug> ",<S2SV_ModStart> | O_NOFOLLOW ,acassen@keepalived/04f2d32871bb3b11d7dc024039952f2fe2750306,CVE-2018-19044,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,2018-11-08T20:29Z
391,CWE-617,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> assert ( error == 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModStart> return error <S2SV_ModEnd> ,projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z
392,CWE-476,<S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp && tmp == cluster -> cl_has_local && <S2SV_EndBug> <S2SV_StartBug> return - EBUSY ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp && ! cluster -> cl_has_local ) { <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> <S2SV_StartBug> return count ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { ret = - EINVAL ; goto out ; } <S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto out ; } <S2SV_ModStart> goto out <S2SV_ModEnd> <S2SV_ModStart> ret = count ; out : o2nm_unlock_subsystem ( ) ; return ret <S2SV_ModEnd> ,torvalds@linux/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,CVE-2017-18216,https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,2018-03-05T18:29Z
393,CWE-119,"<S2SV_StartBug> if ( fscanf ( fp , ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%s\\n"" , & n , typestr ) != 2 ) <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%127s\\n"" <S2SV_ModEnd> ",DanBloomberg@leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a,CVE-2018-7186,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,2018-02-16T16:29Z
394,CWE-125,<S2SV_StartBug> if ( data [ 1 ] <= 127 ) <S2SV_EndBug> <S2SV_StartBug> else op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ; <S2SV_EndBug> <S2SV_StartBug> op -> fail = addr + op -> size ; <S2SV_EndBug> ,<S2SV_ModStart> len > 1 ) { if ( <S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> } } else { op -> jump = addr ; } ,radare@radare2/bbb4af56003c1afdad67af0c4339267ca38b1017,CVE-2018-12322,https://github.com/radare/radare2/commit/bbb4af56003c1afdad67af0c4339267ca38b1017,2018-06-13T16:29Z
395,CWE-362,<S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> sock * sk = asoc -> base . sk ; struct <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/635682a14427d241bab7bbdeebb48a7d7b91638e,CVE-2015-8767,https://github.com/torvalds/linux/commit/635682a14427d241bab7bbdeebb48a7d7b91638e,2016-02-08T03:59Z
396,CWE-20,"<S2SV_StartBug> s = strchr ( token , '?' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> ,Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
397,CWE-125,<S2SV_StartBug> return - E_NOTHANDLED ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ninst == 0 ) return - E_INVALID ,LocutusOfBorg@ettercap/626dc56686f15f2dda13c48f78c2a666cb6d8506,CVE-2017-6430,https://github.com/LocutusOfBorg/ettercap/commit/626dc56686f15f2dda13c48f78c2a666cb6d8506,2017-03-15T15:59Z
398,CWE-125,<S2SV_StartBug> ND_TCHECK ( lshp -> ls_type ) ; <S2SV_EndBug> ,<S2SV_ModStart> ls_length <S2SV_ModEnd> ,the-tcpdump-group@tcpdump/e01c9bf76740802025c9328901b55ee4a0c49ed6,CVE-2018-14880,https://github.com/the-tcpdump-group/tcpdump/commit/e01c9bf76740802025c9328901b55ee4a0c49ed6,2019-10-03T16:15Z
399,CWE-190,"<S2SV_StartBug> static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val ) <S2SV_EndBug> ",<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> ,mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
400,CWE-125,"<S2SV_StartBug> memcpy ( tim . bitmap , p + ( tim . length - 3 ) , <S2SV_EndBug> <S2SV_StartBug> ( tim . length - 3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> length -= tim . length - 3 ; <S2SV_EndBug> ","<S2SV_ModStart> offset + 3 , <S2SV_ModEnd> <S2SV_ModStart> ; offset += <S2SV_ModEnd> <S2SV_ModStart> ; length -= <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",the-tcpdump-group@tcpdump/99798bd9a41bd3d03fdc1e949810a38967f20ed3,CVE-2017-12987,https://github.com/the-tcpdump-group/tcpdump/commit/99798bd9a41bd3d03fdc1e949810a38967f20ed3,2017-09-14T06:29Z
401,CWE-416,"<S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> ,torvalds@linux/6b3a707736301c2128ca85ce85fb13f60b5e350a,CVE-2019-11487,https://github.com/torvalds/linux/commit/6b3a707736301c2128ca85ce85fb13f60b5e350a,2019-04-23T22:29Z
402,CWE-119,"<S2SV_StartBug> r_buf_set_bytes ( tbuf , buf , sz ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! tbuf ) { return NULL ; } ,radare@radare2/72794dc3523bbd5bb370de3c5857cb736c387e18,CVE-2017-6194,https://github.com/radare/radare2/commit/72794dc3523bbd5bb370de3c5857cb736c387e18,2017-04-03T05:59Z
403,CWE-264,"<S2SV_StartBug> mm_segment_t old_fs ; <S2SV_EndBug> <S2SV_StartBug> ret = sys_wait4 ( pid , ustatus , options , ( struct rusage __user * ) & r ) ; <S2SV_EndBug> <S2SV_StartBug> err |= __put_user ( r . ru_utime . tv_sec , & ur -> ru_utime . tv_sec ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned int status = 0 ; <S2SV_ModStart> ( unsigned int __user * ) & status <S2SV_ModEnd> <S2SV_ModStart> put_user ( status , ustatus ) ; err |= ",torvalds@linux/21c5977a836e399fc710ff2c5367845ed5c2527f,CVE-2011-2211,https://github.com/torvalds/linux/commit/21c5977a836e399fc710ff2c5367845ed5c2527f,2012-06-13T10:24Z
404,CWE-59,"<S2SV_StartBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys/net"" , ""%r/proc/net"" , NULL , MS_BIND , NULL } , <S2SV_EndBug> <S2SV_StartBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/net"" , ""%r/proc/sys/net"" , NULL , MS_MOVE , NULL } , <S2SV_EndBug> <S2SV_StartBug> r = mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%r/proc/tty"" <S2SV_ModEnd> <S2SV_ModStart> ""%r/proc/tty"" <S2SV_ModEnd> <S2SV_ModStart> safe_mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options , conf -> rootfs . path ? conf -> rootfs . mount : NULL <S2SV_ModEnd> ",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z
405,CWE-20,<S2SV_StartBug> ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; <S2SV_EndBug> <S2SV_StartBug> libreswan_log ( <S2SV_EndBug> <S2SV_StartBug> return v2N_INVALID_KE_PAYLOAD ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! md -> chain [ ISAKMP_NEXT_v2KE ] ) { if ( md -> chain [ ISAKMP_NEXT_v2N ] ) { libreswan_log ( ""Received<S2SV_blank>Notify(%d):<S2SV_blank>%s"" , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type , enum_name ( & ikev2_notify_names , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type ) ) ; } libreswan_log ( ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>no<S2SV_blank>KE<S2SV_blank>payload<S2SV_blank>present"" , fromname , md -> sender_port ) ; return STF_FAIL + v2N_INVALID_KE_PAYLOAD ; } ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { libreswan_log ( <S2SV_ModEnd> <S2SV_ModStart> STF_FAIL + ",libreswan@libreswan/2899351224fe2940aec37d7656e1e392c0fe07f0,CVE-2013-7294,https://github.com/libreswan/libreswan/commit/2899351224fe2940aec37d7656e1e392c0fe07f0,2014-01-16T05:05Z
406,CWE-787,"<S2SV_StartBug> void nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride ) <S2SV_EndBug> <S2SV_StartBug> nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ; <S2SV_EndBug> <S2SV_StartBug> nsc_encode_subsampling ( context ) ; <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> if ( ! context || ! bmpdata || ( rowstride == 0 ) ) return FALSE ; if ( ! <S2SV_ModStart> ) return FALSE <S2SV_ModStart> if ( ! <S2SV_ModStart> ) return FALSE ; } return TRUE ; <S2SV_ModEnd> ,FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z
407,CWE-119,"<S2SV_StartBug> void vp9_tree_probs_from_distribution ( vp9_tree tree , <S2SV_EndBug> ",<S2SV_ModStart> vpx_tree <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
408,CWE-119,<S2SV_StartBug> if ( stringset == ETH_SS_STATS ) <S2SV_EndBug> ,<S2SV_ModStart> || stringset == ETH_SS_PRIV_FLAGS ,torvalds@linux/412b65d15a7f8a93794653968308fc100f2aa87c,CVE-2017-18222,https://github.com/torvalds/linux/commit/412b65d15a7f8a93794653968308fc100f2aa87c,2018-03-08T14:29Z
409,CWE-125,<S2SV_StartBug> return ( ( image -> columns + 7 ) / 8 ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) * GetPSDPacketSize ( image ) ,ImageMagick@ImageMagick/5f16640725b1225e6337c62526e6577f0f88edb8,CVE-2016-7525,https://github.com/ImageMagick/ImageMagick/commit/5f16640725b1225e6337c62526e6577f0f88edb8,2017-04-20T18:59Z
410,CWE-284,"<S2SV_StartBug> p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> <S2SV_StartBug> p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ,system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
411,CWE-000,<S2SV_StartBug> alt = pcu -> ctrl_intf -> cur_altsetting ; <S2SV_EndBug> <S2SV_StartBug> alt = pcu -> data_intf -> cur_altsetting ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! pcu -> ctrl_intf ) return - EINVAL ; <S2SV_ModStart> if ( ! pcu -> data_intf ) return - EINVAL ; ,torvalds@linux/a0ad220c96692eda76b2e3fd7279f3dcd1d8a8ff,CVE-2016-3689,https://github.com/torvalds/linux/commit/a0ad220c96692eda76b2e3fd7279f3dcd1d8a8ff,2016-05-02T10:59Z
412,CWE-119,"<S2SV_StartBug> const char * name = d -> name ; <S2SV_EndBug> <S2SV_StartBug> struct device dev = d -> udev -> dev ; <S2SV_EndBug> <S2SV_StartBug> dev_info ( & dev , ""%s:<S2SV_blank>\'%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n"" , <S2SV_EndBug> <S2SV_StartBug> KBUILD_MODNAME , name ) ; <S2SV_EndBug> ","<S2SV_ModStart> devname = kstrdup ( dev_name ( & <S2SV_ModEnd> <S2SV_ModStart> ) , GFP_KERNEL ) ; const char * drvname = d -> name <S2SV_ModStart> pr_info ( ""%s:<S2SV_blank>\'%s:%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n"" <S2SV_ModEnd> <S2SV_ModStart> drvname , devname ) ; kfree ( devname <S2SV_ModEnd> ",torvalds@linux/005145378c9ad7575a01b6ce1ba118fb427f583a,CVE-2017-8064,https://github.com/torvalds/linux/commit/005145378c9ad7575a01b6ce1ba118fb427f583a,2017-04-23T05:59Z
413,CWE-125,<S2SV_StartBug> xstep = picomp -> hsamp * ( 1 << <S2SV_EndBug> <S2SV_StartBug> ystep = picomp -> vsamp * ( 1 << <S2SV_EndBug> <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || <S2SV_EndBug> <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || <S2SV_EndBug> ,"<S2SV_ModStart> if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> ",mdadams@jasper/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d,CVE-2016-9583,https://github.com/mdadams/jasper/commit/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d,2018-08-01T17:29Z
414,CWE-416,"<S2SV_StartBug> r = conv_encoding ( ci -> pattern_enc , ci -> target_enc , pattern , pattern_end , <S2SV_EndBug> ",<S2SV_ModStart> return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION <S2SV_ModEnd> ,kkos@oniguruma/0f7f61ed1b7b697e283e37bd2d731d0bd57adb55,CVE-2019-13224,https://github.com/kkos/oniguruma/commit/0f7f61ed1b7b697e283e37bd2d731d0bd57adb55,2019-07-10T14:15Z
415,CWE-787,"<S2SV_StartBug> static void InsertRow ( Image * image , ssize_t depth , unsigned char * p , ssize_t y , <S2SV_EndBug> <S2SV_StartBug> size_t bit ; ssize_t x ; <S2SV_EndBug> <S2SV_StartBug> register Quantum * q ; <S2SV_EndBug> <S2SV_StartBug> switch ( depth ) <S2SV_EndBug> <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ; <S2SV_EndBug> <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) <S2SV_EndBug> <S2SV_StartBug> index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ; <S2SV_EndBug> <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) SyncAuthenticPixels ( image , exception ) ; <S2SV_EndBug> <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> if ( q == ( Quantum * ) NULL ) <S2SV_EndBug> <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ; <S2SV_EndBug> <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> p ++ ; <S2SV_EndBug> <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> if ( q == ( Quantum * ) NULL ) <S2SV_EndBug> <S2SV_StartBug> index = ConstrainColormapIndex ( image , * p , exception ) ; <S2SV_EndBug> ","<S2SV_ModStart> MagickBooleanType <S2SV_ModEnd> <S2SV_ModStart> bpp <S2SV_ModEnd> <S2SV_ModStart> int bit ; Quantum index <S2SV_ModEnd> <S2SV_ModStart> * q ; ssize_t x ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) return ( MagickFalse ) <S2SV_ModEnd> <S2SV_ModStart> bpp <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> ssize_t ) ( <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> for ( x = 0 ; x < ( ( ssize_t ) <S2SV_ModEnd> <S2SV_ModStart> - 3 ) ; x += 4 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 <S2SV_ModEnd> <S2SV_ModStart> SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } break ; } case 4 : { <S2SV_ModEnd> <S2SV_ModStart> 4 ) & 0x0f <S2SV_ModEnd> <S2SV_ModStart> if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> ) & 0x0f <S2SV_ModEnd> <S2SV_ModStart> if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 0x0f <S2SV_ModEnd> <S2SV_ModStart> if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; <S2SV_ModStart> } <S2SV_ModEnd> <S2SV_ModStart> for ( x = 0 ; x < ( ssize_t ) <S2SV_ModEnd> <S2SV_ModStart> ; x ++ ) { index = ConstrainColormapIndex ( image , * p <S2SV_ModEnd> <S2SV_ModStart> SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } } break ; case 24 : <S2SV_ModEnd> <S2SV_ModStart> SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } if ( ! SyncAuthenticPixels ( image <S2SV_ModEnd> <S2SV_ModStart> ) return ( MagickFalse ) ; return ( MagickTrue ) ; <S2SV_ModEnd> ",ImageMagick@ImageMagick/cc4ac341f29fa368da6ef01c207deaf8c61f6a2e,CVE-2018-16642,https://github.com/ImageMagick/ImageMagick/commit/cc4ac341f29fa368da6ef01c207deaf8c61f6a2e,2018-09-06T22:29Z
416,CWE-125,"<S2SV_StartBug> register const u_char * tptr ) <S2SV_EndBug> <S2SV_StartBug> u_int hexdump = FALSE ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> , const u_int length ) { u_int network_addr_type ; u_int <S2SV_ModEnd> <S2SV_ModStart> if ( length < 1 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Network<S2SV_blank>Address<S2SV_blank>Type<S2SV_blank>(invalid,<S2SV_blank>no<S2SV_blank>data"" ) ) ; return hexdump ; } <S2SV_ModStart> if ( length != 1 + 4 ) { ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> if ( length != 1 + 16 ) { ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ; hexdump = TRUE ; break ; } ",the-tcpdump-group@tcpdump/5d340a5ca6e420a70297cdbdf777333f18bfdab7,CVE-2017-13052,https://github.com/the-tcpdump-group/tcpdump/commit/5d340a5ca6e420a70297cdbdf777333f18bfdab7,2017-09-14T06:29Z
417,CWE-264,"<S2SV_StartBug> u64 msr_data ; <S2SV_EndBug> <S2SV_StartBug> cs . dpl = 3 ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> ctxt -> _eip = reg_read ( ctxt , VCPU_REGS_RDX ) ; <S2SV_EndBug> <S2SV_StartBug> * reg_write ( ctxt , VCPU_REGS_RSP ) = reg_read ( ctxt , VCPU_REGS_RCX ) ; <S2SV_EndBug> ","<S2SV_ModStart> , rcx , rdx <S2SV_ModStart> rcx = reg_read ( ctxt , VCPU_REGS_RCX ) ; rdx = reg_read ( ctxt , VCPU_REGS_RDX ) ; <S2SV_ModStart> if ( is_noncanonical_address ( rcx ) || is_noncanonical_address ( rdx ) ) return emulate_gp ( ctxt , 0 ) ; <S2SV_ModStart> rdx <S2SV_ModEnd> <S2SV_ModStart> rcx <S2SV_ModEnd> ",torvalds@linux/234f3ce485d54017f15cf5e0699cff4100121601,CVE-2014-3647,https://github.com/torvalds/linux/commit/234f3ce485d54017f15cf5e0699cff4100121601,2014-11-10T11:55Z
418,CWE-362,"<S2SV_StartBug> return sprintf ( buf , ""%s\\n"" , pdev -> driver_override ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> ssize_t len ; device_lock ( dev ) ; len = <S2SV_ModEnd> <S2SV_ModStart> device_unlock ( dev ) ; return len ; ,torvalds@linux/6265539776a0810b7ce6398c27866ddb9c6bd154,CVE-2017-12146,https://github.com/torvalds/linux/commit/6265539776a0810b7ce6398c27866ddb9c6bd154,2017-09-08T19:29Z
419,CWE-399,<S2SV_StartBug> BIO * tmpout = NULL ; <S2SV_EndBug> <S2SV_StartBug> tmpout = BIO_new ( BIO_s_mem ( ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ; tmpout = cms_get_text_bio ( out , flags ) ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ; goto err ; } for ( ; ; ) { i = BIO_read ( in , buf , sizeof ( buf ) ) ; if ( i <= 0 ) { if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) { if ( ! BIO_get_cipher_status ( in ) ) goto err ; } if ( i < 0 ) goto err ; break ; } if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",openssl@openssl/cd30f03ac5bf2962f44bd02ae8d88245dff2f12c,CVE-2015-1792,https://github.com/openssl/openssl/commit/cd30f03ac5bf2962f44bd02ae8d88245dff2f12c,2015-06-12T19:59Z
420,CWE-264,"<S2SV_StartBug> rs . respond ( rs . arg , retval , NULL , NULL , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( retval == 0 ) rs . enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ; ,krb5@krb5/e3b5a5e5267818c97750b266df50b6a3d4649604,CVE-2015-2694,https://github.com/krb5/krb5/commit/e3b5a5e5267818c97750b266df50b6a3d4649604,2015-05-25T19:59Z
421,CWE-119,"<S2SV_StartBug> static void cost ( int * costs , vp9_tree tree , const vp9_prob * probs , <S2SV_EndBug> <S2SV_StartBug> const vp9_prob prob = probs [ i / 2 ] ; <S2SV_EndBug> <S2SV_StartBug> const vp9_tree_index ii = tree [ i + b ] ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_tree <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_index <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
422,CWE-59,<S2SV_StartBug> create_option_search_table ( ) ; <S2SV_EndBug> ,"<S2SV_ModStart> # ifdef HAVE_MKDTEMP tmp_dir = mkdtemp ( Strnew_m_charp ( tmp_dir , ""/w3m-XXXXXX"" , NULL ) -> ptr ) ; if ( tmp_dir == NULL ) tmp_dir = rc_dir ; # endif ",tats@w3m/18dcbadf2771cdb0c18509b14e4e73505b242753,CVE-2018-6198,https://github.com/tats/w3m/commit/18dcbadf2771cdb0c18509b14e4e73505b242753,2018-01-25T03:29Z
423,CWE-125,"<S2SV_StartBug> switch ( af ) { <S2SV_EndBug> <S2SV_StartBug> strncpy ( addr_text , <S2SV_EndBug> <S2SV_StartBug> ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , <S2SV_EndBug> ","<S2SV_ModStart> size_t pathlen = 0 ; <S2SV_ModStart> pathlen = sizeof ( <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( MAXPATHLEN <= pathlen ) { pathlen = MAXPATHLEN - 1 ; } strncpy ( addr_text , ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , pathlen ) ; addr_text [ pathlen <S2SV_ModEnd> ",memcached@memcached/554b56687a19300a75ec24184746b5512580c819,CVE-2019-15026,https://github.com/memcached/memcached/commit/554b56687a19300a75ec24184746b5512580c819,2019-08-30T15:15Z
424,CWE-119,"<S2SV_StartBug> static INLINE void write_buffer_16x16 ( int16_t * output , __m128i * in0 , <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
425,CWE-189,"<S2SV_StartBug> err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf , p + 4 , c , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> + p <S2SV_ModEnd> ,torvalds@linux/b769f49463711205d57286e64cf535ed4daf59e9,CVE-2011-1476,https://github.com/torvalds/linux/commit/b769f49463711205d57286e64cf535ed4daf59e9,2012-06-21T23:55Z
426,CWE-399,"<S2SV_StartBug> struct hstate * h = hstate_vma ( vma ) ; <S2SV_EndBug> <S2SV_StartBug> struct page * page ; <S2SV_EndBug> <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug> <S2SV_StartBug> set_page_private ( page , ( unsigned long ) mapping ) ; <S2SV_EndBug> ",<S2SV_ModStart> hugepage_subpool * spool = subpool_vma ( vma ) ; struct <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> hugepage_subpool_get_pages ( spool <S2SV_ModEnd> <S2SV_ModStart> hugepage_subpool_put_pages ( spool <S2SV_ModEnd> <S2SV_ModStart> spool <S2SV_ModEnd> ,torvalds@linux/90481622d75715bfcb68501280a917dbfe516029,CVE-2012-2133,https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029,2012-07-03T16:40Z
427,CWE-20,"<S2SV_StartBug> DPRINTF ( 4 , ( ""enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\'%s%s\'\\n"" , <S2SV_EndBug> <S2SV_StartBug> filegen_flag = filegen -> flag ; <S2SV_EndBug> ","<S2SV_ModStart> if ( NULL == filegen ) { msyslog ( LOG_ERR , ""stats<S2SV_blank>%s<S2SV_blank>unrecognized"" , filegen_string ) ; continue ; } <S2SV_ModStart> if ( NULL == filegen ) { msyslog ( LOG_ERR , ""filegen<S2SV_blank>category<S2SV_blank>\'%s\'<S2SV_blank>unrecognized"" , filegen_file ) ; continue ; } ",ntp-project@ntp/52e977d79a0c4ace997e5c74af429844da2f27be,CVE-2015-5195,https://github.com/ntp-project/ntp/commit/52e977d79a0c4ace997e5c74af429844da2f27be,2017-07-21T14:29Z
428,CWE-264,"<S2SV_StartBug> touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> MODE_INVALID <S2SV_ModEnd> ,systemd@systemd/ee735086f8670be1591fa9593e80dd60163a7a2f,CVE-2016-10156,https://github.com/systemd/systemd/commit/ee735086f8670be1591fa9593e80dd60163a7a2f,2017-01-23T07:59Z
429,CWE-119,"<S2SV_StartBug> static void fadst16 ( const int16_t * input , int16_t * output ) { <S2SV_EndBug> <S2SV_StartBug> int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8 , s9 , s10 , s11 , s12 , s13 , s14 , s15 ; <S2SV_EndBug> <S2SV_StartBug> int x0 = input [ 15 ] ; <S2SV_EndBug> <S2SV_StartBug> int x1 = input [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> int x2 = input [ 13 ] ; <S2SV_EndBug> <S2SV_StartBug> int x3 = input [ 2 ] ; <S2SV_EndBug> <S2SV_StartBug> int x4 = input [ 11 ] ; <S2SV_EndBug> <S2SV_StartBug> int x5 = input [ 4 ] ; <S2SV_EndBug> <S2SV_StartBug> int x6 = input [ 9 ] ; <S2SV_EndBug> <S2SV_StartBug> int x7 = input [ 6 ] ; <S2SV_EndBug> <S2SV_StartBug> int x8 = input [ 7 ] ; <S2SV_EndBug> <S2SV_StartBug> int x9 = input [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int x10 = input [ 5 ] ; <S2SV_EndBug> <S2SV_StartBug> int x11 = input [ 10 ] ; <S2SV_EndBug> <S2SV_StartBug> int x12 = input [ 3 ] ; <S2SV_EndBug> <S2SV_StartBug> int x13 = input [ 12 ] ; <S2SV_EndBug> <S2SV_StartBug> int x14 = input [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> int x15 = input [ 14 ] ; <S2SV_EndBug> <S2SV_StartBug> output [ 0 ] = x0 ; <S2SV_EndBug> <S2SV_StartBug> output [ 1 ] = - x8 ; <S2SV_EndBug> <S2SV_StartBug> output [ 2 ] = x12 ; <S2SV_EndBug> <S2SV_StartBug> output [ 3 ] = - x4 ; <S2SV_EndBug> <S2SV_StartBug> output [ 4 ] = x6 ; <S2SV_EndBug> <S2SV_StartBug> output [ 5 ] = x14 ; <S2SV_EndBug> <S2SV_StartBug> output [ 6 ] = x10 ; <S2SV_EndBug> <S2SV_StartBug> output [ 7 ] = x2 ; <S2SV_EndBug> <S2SV_StartBug> output [ 8 ] = x3 ; <S2SV_EndBug> <S2SV_StartBug> output [ 9 ] = x11 ; <S2SV_EndBug> <S2SV_StartBug> output [ 10 ] = x15 ; <S2SV_EndBug> <S2SV_StartBug> output [ 11 ] = x7 ; <S2SV_EndBug> <S2SV_StartBug> output [ 12 ] = x5 ; <S2SV_EndBug> <S2SV_StartBug> output [ 13 ] = - x13 ; <S2SV_EndBug> <S2SV_StartBug> output [ 14 ] = x9 ; <S2SV_EndBug> <S2SV_StartBug> output [ 15 ] = - x1 ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> ; tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
430,CWE-119,<S2SV_StartBug> # if HAVE_EDSP <S2SV_EndBug> <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> || HAVE_NEON_ASM ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
431,CWE-119,"<S2SV_StartBug> MB_PREDICTION_MODE vp9_left_block_mode ( const MODE_INFO * cur_mi , <S2SV_EndBug> ",<S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
432,CWE-119,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> horAcc16 ( tif , cp0 , cc ) ; <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return ,vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1,CVE-2016-9535,https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1,2016-11-22T19:59Z
433,CWE-416,<S2SV_StartBug> opt2 -> tot_len = tot_len ; <S2SV_EndBug> ,"<S2SV_ModStart> atomic_set ( & opt2 -> refcnt , 1 ) ; ",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
434,CWE-834,<S2SV_StartBug> for ( i = 0 ; i < st -> duration ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } ,FFmpeg@FFmpeg/7e80b63ecd259d69d383623e75b318bf2bd491f6,CVE-2017-14059,https://github.com/FFmpeg/FFmpeg/commit/7e80b63ecd259d69d383623e75b318bf2bd491f6,2017-08-31T15:29Z
435,CWE-310,<S2SV_StartBug> dp == datalen ) { <S2SV_EndBug> ,<S2SV_ModStart> ( op & ASN1_OP_MATCH__SKIP && <S2SV_ModStart> ) ,torvalds@linux/0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f,CVE-2016-2053,https://github.com/torvalds/linux/commit/0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f,2016-05-02T10:59Z
436,CWE-264,"<S2SV_StartBug> char * fpath = NULL , * cgdir = NULL , * controller ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""rmdir:<S2SV_blank>verifying<S2SV_blank>access<S2SV_blank>to<S2SV_blank>%s:%s<S2SV_blank>(req<S2SV_blank>path<S2SV_blank>%s)\\n"" , <S2SV_EndBug> <S2SV_StartBug> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! cgfs_remove ( controller , cgroup ) ) { <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> , * next = NULL <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> & next ) ) { if ( ! fpath || strcmp ( next , fpath ) == 0 ) ret = - EBUSY ; else ret = - ENOENT ; goto out ; } if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY <S2SV_ModEnd> <S2SV_ModStart> caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { ret = - EACCES ; goto out ; } if ( ! <S2SV_ModStart> free ( next ) ; ",lxc@lxcfs/a8b6c3e0537e90fba3c55910fd1b7229d54a60a7,CVE-2015-1342,https://github.com/lxc/lxcfs/commit/a8b6c3e0537e90fba3c55910fd1b7229d54a60a7,2015-12-07T20:59Z
437,CWE-269,<S2SV_StartBug> if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { mnt -> mnt . mnt_flags |= MNT_LOCK_ATIME ; if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mnt -> mnt . mnt_flags & MNT_NODEV ) mnt -> mnt . mnt_flags |= MNT_LOCK_NODEV ; if ( mnt -> mnt . mnt_flags & MNT_NOSUID ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOSUID ; if ( mnt -> mnt . mnt_flags & MNT_NOEXEC ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOEXEC ; } if ( ,torvalds@linux/9566d6742852c527bf5af38af5cbb878dad75705,CVE-2014-5207,https://github.com/torvalds/linux/commit/9566d6742852c527bf5af38af5cbb878dad75705,2014-08-18T11:15Z
438,CWE-362,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/8c7188b23474cca017b3ef354c4a58456f68303a,CVE-2015-7990,https://github.com/torvalds/linux/commit/8c7188b23474cca017b3ef354c4a58456f68303a,2015-12-28T11:59Z
439,CWE-119,<S2SV_StartBug> if ( * rsize >= 107 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 && <S2SV_EndBug> ,<S2SV_ModStart> 112 <S2SV_ModEnd> ,torvalds@linux/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,CVE-2014-3184,https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,2014-09-28T10:55Z
440,CWE-20,<S2SV_StartBug> if ( ( tot_len - offset - 4 ) < bodyLength ) { <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) ) ,wireshark@wireshark/9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4,CVE-2016-5351,https://github.com/wireshark/wireshark/commit/9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4,2016-08-07T16:59Z
441,CWE-476,<S2SV_StartBug> if ( likely ( port -> exists && ! filtered ) ) <S2SV_EndBug> ,<S2SV_ModStart> serio <S2SV_ModEnd> ,torvalds@linux/340d394a789518018f834ff70f7534fc463d3226,CVE-2017-18079,https://github.com/torvalds/linux/commit/340d394a789518018f834ff70f7534fc463d3226,2018-01-29T05:29Z
442,CWE-125,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> { ND_TCHECK ( <S2SV_ModEnd> <S2SV_ModStart> ; ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } <S2SV_ModEnd> ",the-tcpdump-group@tcpdump/19d25dd8781620cd41bf178a5e2e27fc1cf242d0,CVE-2017-12898,https://github.com/the-tcpdump-group/tcpdump/commit/19d25dd8781620cd41bf178a5e2e27fc1cf242d0,2017-09-14T06:29Z
443,CWE-17,"<S2SV_StartBug> static int udf_translate_to_linux ( uint8_t * newName , uint8_t * udfName , <S2SV_EndBug> <S2SV_StartBug> int udfLen , uint8_t * fidName , <S2SV_EndBug> <S2SV_StartBug> if ( newIndex < 256 ) <S2SV_EndBug> <S2SV_StartBug> maxFilenameLen = 250 - localExtIndex ; <S2SV_EndBug> <S2SV_StartBug> } else if ( newIndex > 250 ) <S2SV_EndBug> ","<S2SV_ModStart> int newLen , <S2SV_ModStart> int udfLen , <S2SV_ModEnd> <S2SV_ModStart> newLen <S2SV_ModEnd> <S2SV_ModStart> newLen - CRC_LEN <S2SV_ModEnd> <S2SV_ModStart> newLen - CRC_LEN ) newIndex = newLen - CRC_LEN <S2SV_ModEnd> ",torvalds@linux/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,CVE-2014-9731,https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,2015-08-31T10:59Z
444,CWE-119,"<S2SV_StartBug> static void count_segs_sb ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 , <S2SV_EndBug> <S2SV_StartBug> const VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> bw = num_8x8_blocks_wide_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ; <S2SV_EndBug> <S2SV_StartBug> bh = num_8x8_blocks_high_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ; <S2SV_EndBug> <S2SV_StartBug> count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count , <S2SV_EndBug> <S2SV_StartBug> count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count , <S2SV_EndBug> <S2SV_StartBug> count_segs ( cpi , tile , mi_8x8 + hbs * mis , no_pred_segcounts , <S2SV_EndBug> <S2SV_StartBug> count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count , <S2SV_EndBug> <S2SV_StartBug> count_segs ( cpi , tile , mi_8x8 + hbs , <S2SV_EndBug> <S2SV_StartBug> count_segs_sb ( cpi , tile , & mi_8x8 [ mi_dr * mis + mi_dc ] , <S2SV_EndBug> ","<S2SV_ModStart> const VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_ModEnd> <S2SV_ModStart> tile , <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> cm , xd , tile , mi <S2SV_ModEnd> <S2SV_ModStart> cm , xd , tile , mi <S2SV_ModEnd> <S2SV_ModStart> cm , xd , tile , mi <S2SV_ModEnd> <S2SV_ModStart> cm , xd , tile , mi <S2SV_ModEnd> <S2SV_ModStart> cm , xd , tile , mi <S2SV_ModEnd> <S2SV_ModStart> cm , xd <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
445,CWE-254,<S2SV_StartBug> if ( c -> flags & CLIENT_CLOSE_AFTER_REPLY ) break ; <S2SV_EndBug> ,<S2SV_ModStart> ( CLIENT_CLOSE_AFTER_REPLY | CLIENT_CLOSE_ASAP ) <S2SV_ModEnd> ,antirez@redis/874804da0c014a7d704b3d285aa500098a931f50,CVE-2016-10517,https://github.com/antirez/redis/commit/874804da0c014a7d704b3d285aa500098a931f50,2017-10-24T18:29Z
446,CWE-000,<S2SV_StartBug> get_blocks_flags = EXT4_GET_BLOCKS_CREATE ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ext4_should_dioread_nolock ( mpd -> inode ) ) get_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT ,torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z
447,CWE-310,"<S2SV_StartBug> int ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( d2i_DSA_SIG ( & s , & sigbuf , siglen ) == NULL ) goto err ; <S2SV_EndBug> <S2SV_StartBug> DSA_SIG_free ( s ) ; <S2SV_EndBug> ","<S2SV_ModStart> const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> p <S2SV_ModEnd> <S2SV_ModStart> goto err ; derlen = i2d_DSA_SIG ( s , & der ) ; if ( derlen != siglen || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; } ",openssl@openssl/684400ce192dac51df3d3e92b61830a6ef90be3e,CVE-2014-8275,https://github.com/openssl/openssl/commit/684400ce192dac51df3d3e92b61830a6ef90be3e,2015-01-09T02:59Z
448,CWE-415,"<S2SV_StartBug> gdImageGifCtx ( im , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! _gdImageGifCtx <S2SV_ModEnd> <S2SV_ModStart> ) { <S2SV_ModEnd> <S2SV_ModStart> } else { rv = NULL ; } ,php@php-src/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,CVE-2019-6978,https://github.com/php/php-src/commit/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,2019-01-28T08:29Z
449,CWE-200,<S2SV_StartBug> kfree ( bprm ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( bprm -> interp != bprm -> filename ) kfree ( bprm -> interp ) ; ,torvalds@linux/b66c5984017533316fd1951770302649baf1aa33,CVE-2012-4530,https://github.com/torvalds/linux/commit/b66c5984017533316fd1951770302649baf1aa33,2013-02-18T04:41Z
450,CWE-552,"<S2SV_StartBug> size_t canonnamelen = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( p = oe_calloc ( 1 , sizeof ( struct oe_addrinfo ) ) ) ) <S2SV_EndBug> <S2SV_StartBug> & p -> ai_flags , <S2SV_EndBug> <S2SV_StartBug> & p -> ai_family , <S2SV_EndBug> <S2SV_StartBug> & p -> ai_socktype , <S2SV_EndBug> <S2SV_StartBug> & p -> ai_protocol , <S2SV_EndBug> <S2SV_StartBug> & p -> ai_addrlen , <S2SV_EndBug> <S2SV_StartBug> canonnamelen , <S2SV_EndBug> <S2SV_StartBug> if ( p -> ai_addrlen && ! ( p -> ai_addr = oe_calloc ( 1 , p -> ai_addrlen ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( canonnamelen && ! ( p -> ai_canonname = oe_calloc ( 1 , canonnamelen ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( oe_syscall_getaddrinfo_read_ocall ( <S2SV_EndBug> <S2SV_StartBug> p -> ai_addrlen , <S2SV_EndBug> <S2SV_StartBug> canonnamelen , <S2SV_EndBug> <S2SV_StartBug> if ( tail ) <S2SV_EndBug> ","<S2SV_ModStart> canonnamelen_in <S2SV_ModEnd> <S2SV_ModStart> size_t canonnamelen_out = 0 ; struct oe_addrinfo p_out ; memset ( & p_out , 0 , sizeof ( struct oe_addrinfo ) ) ; <S2SV_ModEnd> <S2SV_ModStart> p_out . <S2SV_ModEnd> <S2SV_ModStart> p_out . <S2SV_ModEnd> <S2SV_ModStart> p_out . <S2SV_ModEnd> <S2SV_ModStart> p_out . ai_protocol , p_out . <S2SV_ModEnd> <S2SV_ModStart> p_out . <S2SV_ModEnd> <S2SV_ModStart> canonnamelen_in , & canonnamelen_out <S2SV_ModEnd> <S2SV_ModStart> switch ( p_out . ai_family ) { case OE_AF_INET : if ( p_out . ai_addrlen != sizeof ( struct oe_sockaddr ) ) { ret = OE_EAI_FAIL ; goto done ; } break ; case OE_AF_INET6 : case OE_AF_INET6_WIN : case OE_AF_UNSPEC : if ( p_out . ai_addrlen != sizeof ( struct oe_sockaddr_in6 ) ) { ret = OE_EAI_FAIL ; goto done ; } break ; default : ret = OE_EAI_FAIL ; goto done ; } if ( ! ( p = oe_calloc ( 1 , sizeof ( struct oe_addrinfo ) ) ) ) { ret = OE_EAI_MEMORY ; goto done ; } if ( p_out . <S2SV_ModEnd> <S2SV_ModStart> p_out . <S2SV_ModEnd> <S2SV_ModStart> canonnamelen_out <S2SV_ModEnd> <S2SV_ModStart> canonnamelen_out <S2SV_ModEnd> <S2SV_ModStart> canonnamelen_in = canonnamelen_out ; <S2SV_ModStart> p_out . <S2SV_ModEnd> <S2SV_ModStart> canonnamelen_in , & canonnamelen_out <S2SV_ModEnd> <S2SV_ModStart> ( p -> ai_flags != p_out . ai_flags ) || ( p -> ai_family != p_out . ai_family ) || ( p -> ai_socktype != p_out . ai_socktype ) || ( p -> ai_protocol != p_out . ai_protocol ) || ( p -> ai_addrlen != p_out . ai_addrlen ) || ( canonnamelen_out != canonnamelen_in ) || ( canonnamelen_out && p -> ai_canonname [ canonnamelen_out - 1 ] != '\\0' ) ) { ret = OE_EAI_FAIL ; goto done ; } if ( tail ) { tail -> ai_next = p ; tail = p ; } else { head = p ; tail = p ; } p = NULL ; } if ( handle ) { int retval = - 1 <S2SV_ModEnd> ",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z
451,CWE-20,"<S2SV_StartBug> separator = strchr ( token , ':' ) ; <S2SV_EndBug> <S2SV_StartBug> separator = strchr ( token , '=' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> ,Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
452,CWE-369,<S2SV_StartBug> rctx -> image_height = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 6 ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( rctx -> image_width < 1 || rctx -> image_height < 1 ) { iw_set_error ( rctx -> ctx , ""Invalid<S2SV_blank>image<S2SV_blank>dimensions"" ) ; goto done ; } ",jsummers@imageworsener/ca3356eb49fee03e2eaf6b6aff826988c1122d93,CVE-2017-7962,https://github.com/jsummers/imageworsener/commit/ca3356eb49fee03e2eaf6b6aff826988c1122d93,2017-04-19T15:59Z
453,CWE-119,"<S2SV_StartBug> vpx_memcpy ( pc -> fc . coef_probs , default_coef_probs , <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
454,CWE-119,"<S2SV_StartBug> static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data ) <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> indx , data , size , 100 ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> const <S2SV_ModStart> u8 * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> kfree ( buf ) ; ",torvalds@linux/5593523f968bc86d42a035c6df47d5e0979b5ace,CVE-2017-8068,https://github.com/torvalds/linux/commit/5593523f968bc86d42a035c6df47d5e0979b5ace,2017-04-23T05:59Z
455,CWE-125,"<S2SV_StartBug> Module ( asdl_seq * body , PyArena * arena ) <S2SV_EndBug> <S2SV_StartBug> return p ; <S2SV_EndBug> ","<S2SV_ModStart> , asdl_seq * type_ignores <S2SV_ModStart> p -> v . Module . type_ignores = type_ignores ; ",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z
456,CWE-000,"<S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_DESTRUCT ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/0558f33c06bb910e2879e355192227a8e8f0219d,CVE-2017-18232,https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d,2018-03-15T04:29Z
457,CWE-119,"<S2SV_StartBug> int64_t ts_start , int64_t ts_end , unsigned int flags ) { <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> # if USE_PARTIAL_COPY <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> max_sz == 1 && active_map && ! flags ) { <S2SV_EndBug> <S2SV_StartBug> vp9_copy_and_extend_frame ( src , & buf -> img ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif <S2SV_ModStart> int width = src -> y_crop_width ; int height = src -> y_crop_height ; int uv_width = src -> uv_crop_width ; int uv_height = src -> uv_crop_height ; int subsampling_x = src -> subsampling_x ; int subsampling_y = src -> subsampling_y ; int larger_dimensions , new_dimensions ; <S2SV_ModStart> new_dimensions = width != buf -> img . y_crop_width || height != buf -> img . y_crop_height || uv_width != buf -> img . uv_crop_width || uv_height != buf -> img . uv_crop_height ; larger_dimensions = width > buf -> img . y_width || height > buf -> img . y_height || uv_width > buf -> img . uv_width || uv_height > buf -> img . uv_height ; assert ( ! larger_dimensions || new_dimensions ) ; <S2SV_ModStart> ! new_dimensions && <S2SV_ModStart> # endif if ( larger_dimensions ) { YV12_BUFFER_CONFIG new_img ; memset ( & new_img , 0 , sizeof ( new_img ) ) ; if ( vpx_alloc_frame_buffer ( & new_img , width , height , subsampling_x , subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , 0 ) ) return 1 ; vpx_free_frame_buffer ( & buf -> img ) ; buf -> img = new_img ; } else if ( new_dimensions ) { buf -> img . y_crop_width = src -> y_crop_width ; buf -> img . y_crop_height = src -> y_crop_height ; buf -> img . uv_crop_width = src -> uv_crop_width ; buf -> img . uv_crop_height = src -> uv_crop_height ; buf -> img . subsampling_x = src -> subsampling_x ; buf -> img . subsampling_y = src -> subsampling_y ; } <S2SV_ModStart> # if USE_PARTIAL_COPY } <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
458,CWE-399,"<S2SV_StartBug> rc = fuse_dev_release ( inode , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> fuse_conn_put ( & cc -> fc ) ; ,torvalds@linux/2c5816b4beccc8ba709144539f6fdd764f8fa49c,CVE-2015-1339,https://github.com/torvalds/linux/commit/2c5816b4beccc8ba709144539f6fdd764f8fa49c,2016-04-27T17:59Z
459,CWE-617,<S2SV_StartBug> return code ; <S2SV_EndBug> ,"<S2SV_ModStart> { * status = ""DECODE_PA_S4U_X509_USER"" ; return code ; } <S2SV_ModEnd> ",krb5@krb5/ffb35baac6981f9e8914f8f3bffd37f284b85970,CVE-2017-11368,https://github.com/krb5/krb5/commit/ffb35baac6981f9e8914f8f3bffd37f284b85970,2017-08-09T18:29Z
460,CWE-119,"<S2SV_StartBug> static int scsi_disk_emulate_command ( SCSIDiskReq * r , uint8_t * outbuf ) <S2SV_EndBug> ","<S2SV_ModStart> ) { SCSIRequest * req = & r -> req ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; uint64_t nb_sectors ; <S2SV_ModEnd> <S2SV_ModStart> ; int buflen = 0 ; if ( ! r -> iov . iov_base ) { if ( req -> cmd . xfer > 65536 ) { goto illegal_request ; } r -> buflen = MAX ( 4096 , req -> cmd . xfer ) ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } outbuf = r -> iov . iov_base <S2SV_ModEnd> ",bonzini@qemu/7285477ab11831b1cf56e45878a89170dd06d9b9,CVE-2011-3346,https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9,2014-04-01T06:35Z
461,CWE-617,<S2SV_StartBug> s -> cur_pic . field_picture || <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,FFmpeg@FFmpeg/bd27a9364ca274ca97f1df6d984e88a0700fb235,CVE-2018-13304,https://github.com/FFmpeg/FFmpeg/commit/bd27a9364ca274ca97f1df6d984e88a0700fb235,2018-07-05T17:29Z
462,CWE-000,<S2SV_StartBug> if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) { <S2SV_EndBug> <S2SV_StartBug> return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ; <S2SV_EndBug> <S2SV_StartBug> return sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; <S2SV_EndBug> ,"<S2SV_ModStart> struct scatterlist * sgp = & rm -> data . op_sg [ sg ] ; int ret = sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; <S2SV_ModStart> ret = min_t ( int , ret , sgp -> length - conn -> c_xmit_data_off ) ; goto out <S2SV_ModEnd> <S2SV_ModStart> out : return ret <S2SV_ModEnd> ",torvalds@linux/6094628bfd94323fc1cea05ec2c6affd98c18f7f,CVE-2011-1023,https://github.com/torvalds/linux/commit/6094628bfd94323fc1cea05ec2c6affd98c18f7f,2012-06-21T23:55Z
463,CWE-119,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> { return 0 ; } <S2SV_ModEnd> ,radare@radare2/65000a7fd9eea62359e6d6714f17b94a99a82edd,CVE-2017-9763,https://github.com/radare/radare2/commit/65000a7fd9eea62359e6d6714f17b94a99a82edd,2017-06-19T16:29Z
464,CWE-20,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ret = key_read_state ( key ) ; if ( ret < 0 ) goto error2 ; <S2SV_ModEnd> ,torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z
465,CWE-125,"<S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bp [ hlen ] & 0xf0 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""K"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mh -> ip6m_data8 [ 1 ] & 0x80 ) <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 16 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( mh -> ip6m_data8 [ 1 ] <S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> <S2SV_ModStart> bp [ hlen ] , <S2SV_ModEnd> ",the-tcpdump-group@tcpdump/db8c799f6dfc68765c9451fcbfca06e662f5bd5f,CVE-2017-13009,https://github.com/the-tcpdump-group/tcpdump/commit/db8c799f6dfc68765c9451fcbfca06e662f5bd5f,2017-09-14T06:29Z
466,CWE-000,<S2SV_StartBug> dev -> netdev_ops = & ieee80211_dataif_ops ; <S2SV_EndBug> ,<S2SV_ModStart> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> ,torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z
467,CWE-125,"<S2SV_StartBug> uint16_t hmi_bpm = 0 ; <S2SV_EndBug> <S2SV_StartBug> } * note ; <S2SV_EndBug> <S2SV_StartBug> if ( hmi_data [ 0 ] == 0xfe ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( hmi_data [ 1 ] == 0x15 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , hmi_running_event [ i ] ) ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> note [ hmi_tmp ] . length = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( * hmi_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> } while ( * hmi_data > 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> hmi_data ++ ; <S2SV_EndBug> ","<S2SV_ModStart> uint32_t data_siz ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> hmi_track_offset [ i ] >= hmi_size ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } data_siz = hmi_size - hmi_track_offset [ i ] ; if ( <S2SV_ModStart> hmi_tmp += 4 ; <S2SV_ModStart> hmi_tmp = 8 ; } else { hmi_tmp = 4 ; } hmi_data <S2SV_ModEnd> <S2SV_ModStart> hmi_track_offset [ i ] += 4 ; if ( hmi_tmp > data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } data_siz -= hmi_tmp ; <S2SV_ModStart> , data_siz <S2SV_ModStart> data_siz -= setup_ret ; <S2SV_ModStart> data_siz && <S2SV_ModStart> if ( ! data_siz ) break ; <S2SV_ModStart> data_siz -- ; <S2SV_ModStart> ; } if ( ! data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end <S2SV_ModStart> data_siz -- ; <S2SV_ModStart> data_siz -= setup_ret ; } } if ( data_siz && <S2SV_ModEnd> <S2SV_ModStart> if ( ! data_siz ) break ; <S2SV_ModStart> data_siz -- ; <S2SV_ModStart> if ( ! data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } <S2SV_ModStart> ; data_siz -- ",Mindwerks@wildmidi/ad6d7cf88d6673167ca1f517248af9409a9f1be1,CVE-2017-11664,https://github.com/Mindwerks/wildmidi/commit/ad6d7cf88d6673167ca1f517248af9409a9f1be1,2017-08-17T16:29Z
468,CWE-200,<S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> haddr -> hci_channel = 0 ; ,torvalds@linux/3f68ba07b1da811bf383b4b701b129bfcb2e4988,CVE-2012-6544,https://github.com/torvalds/linux/commit/3f68ba07b1da811bf383b4b701b129bfcb2e4988,2013-03-15T20:55Z
469,CWE-200,<S2SV_StartBug> fh32 [ 2 ] = inode -> i_generation ; <S2SV_EndBug> ,<S2SV_ModStart> fh16 [ 3 ] = 0 ; ,torvalds@linux/fe685aabf7c8c9f138e5ea900954d295bf229175,CVE-2012-6549,https://github.com/torvalds/linux/commit/fe685aabf7c8c9f138e5ea900954d295bf229175,2013-03-15T20:55Z
470,CWE-476,"<S2SV_StartBug> if ( check_anon ( kdc_active_realm , request -> client , request -> server ) != 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> client . princ <S2SV_ModEnd> ,krb5@krb5/93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7,CVE-2016-3120,https://github.com/krb5/krb5/commit/93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7,2016-08-01T02:59Z
471,CWE-119,<S2SV_StartBug> if ( dst_reg -> smin_value < 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/4374f256ce8182019353c0c639bb8d0695b4c941,CVE-2017-17853,https://github.com/torvalds/linux/commit/4374f256ce8182019353c0c639bb8d0695b4c941,2017-12-27T17:08Z
472,CWE-119,"<S2SV_StartBug> if ( method == LPF_PICK_FROM_Q ) { <S2SV_EndBug> <S2SV_StartBug> const int q = vp9_ac_quant ( cm -> base_qindex , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> int filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ; <S2SV_EndBug> <S2SV_StartBug> search_filter_level ( sd , cpi , method == LPF_PICK_FROM_SUBIMAGE ) ; <S2SV_EndBug> ","<S2SV_ModStart> LPF_PICK_MINIMAL_LPF && lf -> filter_level ) { lf -> filter_level = 0 ; } else if ( method >= <S2SV_ModStart> , cm -> bit_depth ) ; # if CONFIG_VP9_HIGHBITDEPTH int filt_guess ; switch ( cm -> bit_depth ) { case VPX_BITS_8 : <S2SV_ModEnd> <S2SV_ModStart> break ; case VPX_BITS_10 : filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 4060632 , 20 ) ; break ; case VPX_BITS_12 : filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 16242526 , 22 ) ; break ; default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>"" ""or<S2SV_blank>VPX_BITS_12"" ) ; return ; } # else int filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ; # endif <S2SV_ModStart> lf -> filter_level = ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
473,CWE-284,<S2SV_StartBug> usleep ( 100000 ) ; <S2SV_EndBug> ,<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ,system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
474,CWE-772,<S2SV_StartBug> quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; canvas_image = DestroyImage ( canvas_image ,ImageMagick@ImageMagick/241988ca28139ad970c1d9717c419f41e360ddb0,CVE-2017-15032,https://github.com/ImageMagick/ImageMagick/commit/241988ca28139ad970c1d9717c419f41e360ddb0,2017-10-05T07:29Z
475,CWE-190,"<S2SV_StartBug> int a = getnum ( fmt , MAXALIGN ) ; <S2SV_EndBug> ","<S2SV_ModStart> L , ",antirez@redis/ef764dde1cca2f25d00686673d1bc89448819571,CVE-2020-14147,https://github.com/antirez/redis/commit/ef764dde1cca2f25d00686673d1bc89448819571,2020-06-15T18:15Z
476,CWE-119,<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> ,<S2SV_ModStart> void ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
477,CWE-119,"<S2SV_StartBug> if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> ",<S2SV_ModStart> 3 == <S2SV_ModStart> && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> ,hfp@libxsmm/151481489192e6d1997f8bde52c5c425ea41741d,CVE-2018-20542,https://github.com/hfp/libxsmm/commit/151481489192e6d1997f8bde52c5c425ea41741d,2018-12-28T16:29Z
478,CWE-119,<S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } ",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z
479,CWE-189,"<S2SV_StartBug> long rem ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> ",<S2SV_ModStart> u32 <S2SV_ModEnd> <S2SV_ModStart> div_u64_rem <S2SV_ModEnd> ,torvalds@linux/f8bd2258e2d520dff28c855658bd24bdafb5102d,CVE-2011-3209,https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d,2012-10-03T11:02Z
480,CWE-119,"<S2SV_StartBug> if ( ! ctx || ( ! data && data_sz ) ) <S2SV_EndBug> <S2SV_StartBug> res = ctx -> iface -> dec . decode ( ctx -> priv -> alg_priv , data , data_sz , <S2SV_EndBug> ",<S2SV_ModStart> || ( data && ! data_sz ) <S2SV_ModStart> get_alg_priv ( ctx ) <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
481,CWE-119,"<S2SV_StartBug> if ( value [ strlen ( value ) - 1 ] == ',' ) { <S2SV_EndBug> ",<S2SV_ModStart> * value == 0 || ,FFmpeg@FFmpeg/c42a1388a6d1bfd8001bf6a4241d8ca27e49326d,CVE-2017-14767,https://github.com/FFmpeg/FFmpeg/commit/c42a1388a6d1bfd8001bf6a4241d8ca27e49326d,2017-09-27T08:29Z
482,CWE-20,"<S2SV_StartBug> static int isofs_read_inode ( struct inode * inode ) <S2SV_EndBug> <S2SV_StartBug> parse_rock_ridge_inode ( de , inode ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int relocated <S2SV_ModStart> , relocated ",torvalds@linux/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4,CVE-2014-5472,https://github.com/torvalds/linux/commit/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4,2014-09-01T01:55Z
483,CWE-000,"<S2SV_StartBug> COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! COM_CompareExtension ( filename , "".txt"" ) ) { Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".txt\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" ) ; return ; } ",JACoders@OpenJK/11a83410153756ae350a82ed41b08d128ff7f998,CVE-2017-6903,https://github.com/JACoders/OpenJK/commit/11a83410153756ae350a82ed41b08d128ff7f998,2017-03-14T22:59Z
484,CWE-125,"<S2SV_StartBug> if ( netal == 0 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s"" , etheraddr_string ( ndo , snpa ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> snpal == 6 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , snpal , etheraddr_string ( ndo , snpa ) ) ) ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , snpal , linkaddr_string ( ndo , snpa , LINKADDR_OTHER , snpal ) ) ) ; if ( netal != <S2SV_ModEnd> <S2SV_ModStart> ""\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u)<S2SV_blank>%s"" , netal , <S2SV_ModEnd> ",the-tcpdump-group@tcpdump/c177cb3800a9a68d79b2812f0ffcb9479abd6eb8,CVE-2017-13016,https://github.com/the-tcpdump-group/tcpdump/commit/c177cb3800a9a68d79b2812f0ffcb9479abd6eb8,2017-09-14T06:29Z
485,CWE-20,"<S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>K"" , c , m , y , k ) ; <S2SV_EndBug> <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>k"" , c , m , y , k ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sendClean ( outputbuffer ) ; ,TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z
486,CWE-617,<S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> return false ; } } else if ( r -> CRn == 0 && r -> CRm == 9 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; <S2SV_ModEnd> <S2SV_ModStart> return false <S2SV_ModEnd> ,torvalds@linux/9e3f7a29694049edd728e2400ab57ad7553e5aa9,CVE-2017-12168,https://github.com/torvalds/linux/commit/9e3f7a29694049edd728e2400ab57ad7553e5aa9,2017-09-20T08:29Z
487,CWE-189,<S2SV_StartBug> convert_to_double_ex ( zval_affine_elem ) ; <S2SV_EndBug> <S2SV_StartBug> affine [ i ] = Z_DVAL_PP ( zval_affine_elem ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . x = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . y = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . width = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . height = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> ,<S2SV_ModStart> { zval dval ; dval = * * zval_affine_elem ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> <S2SV_ModStart> Z_DVAL ( dval ) ; } <S2SV_ModEnd> <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . x = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . y = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . width = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . height = <S2SV_ModStart> } ,php@php-src/2938329ce19cb8c4197dec146c3ec887c6f61d01,CVE-2014-2020,https://github.com/php/php-src/commit/2938329ce19cb8c4197dec146c3ec887c6f61d01,2014-02-18T11:55Z
488,CWE-125,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> PyObject_GC_UnTrack ( self ) ; ,python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
489,CWE-119,<S2SV_StartBug> free ( szSepLine ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,lurcher@unixODBC/45ef78e037f578b15fc58938a3a3251655e71d6f,CVE-2018-7485,https://github.com/lurcher/unixODBC/commit/45ef78e037f578b15fc58938a3a3251655e71d6f#diff-d52750c7ba4e594410438569d8e2963aL24,2018-02-26T14:29Z
490,CWE-20,"<S2SV_StartBug> r = copy_from_user ( data , ( void __user * ) addr + offset , len ) ; <S2SV_EndBug> ",<S2SV_ModStart> __copy_from_user <S2SV_ModEnd> ,torvalds@linux/fa3d315a4ce2c0891cdde262562e710d95fba19e,CVE-2013-1943,https://github.com/torvalds/linux/commit/fa3d315a4ce2c0891cdde262562e710d95fba19e,2013-07-16T14:08Z
491,CWE-119,"<S2SV_StartBug> char * p , * q , * r ; <S2SV_EndBug> <S2SV_StartBug> printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\n<S2SV_blank>This<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\n<S2SV_blank>There<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\n<S2SV_blank>particular<S2SV_blank>purpose.\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( p = line + 18 ; isspace ( * p ) ; p ++ ) <S2SV_EndBug> <S2SV_StartBug> lenIV = atoi ( line + 6 ) ; <S2SV_EndBug> <S2SV_StartBug> && strstr ( line , ""readstring"" ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( p = strstr ( line , ""/Subrs"" ) ) && isdigit ( p [ 7 ] ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( ( p = strstr ( line , ""/CharStrings"" ) ) && isdigit ( p [ 13 ] ) ) <S2SV_EndBug> <S2SV_StartBug> for ( q = p ; isspace ( * q ) && * q != '\\n' ; q ++ ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\nThis<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\nThere<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\nparticular<S2SV_blank>purpose.\\n"" <S2SV_ModEnd> <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> set_lenIV ( line <S2SV_ModEnd> <S2SV_ModStart> ) { set_cs_start ( line ) <S2SV_ModEnd> <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) ",kohler@t1utils/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33,CVE-2015-3905,https://github.com/kohler/t1utils/commit/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33,2015-06-08T14:59Z
492,CWE-416,<S2SV_StartBug> usb_autopm_put_interface ( serial -> interface ) ; <S2SV_EndBug> ,<S2SV_ModStart> info -> port = NULL ; ,torvalds@linux/299d7572e46f98534033a9e65973f13ad1ce9047,CVE-2017-16525,https://github.com/torvalds/linux/commit/299d7572e46f98534033a9e65973f13ad1ce9047,2017-11-04T01:29Z
493,CWE-264,<S2SV_StartBug> cpuctx -> ctx . type = cpu_context ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/c3c87e770458aa004bd7ed3f29945ff436fd6511,CVE-2015-9004,https://github.com/torvalds/linux/commit/c3c87e770458aa004bd7ed3f29945ff436fd6511,2017-05-02T21:59Z
494,CWE-000,<S2SV_StartBug> struct iovec * iovec ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> , struct iov_iter * iter ) { if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ; <S2SV_ModEnd> <S2SV_ModStart> iov_iter_init ( iter , rw , iovec , * nr_segs , len ) ; ",torvalds@linux/4c185ce06dca14f5cea192f5a2c981ef50663f2b,CVE-2015-8830,https://github.com/torvalds/linux/commit/4c185ce06dca14f5cea192f5a2c981ef50663f2b,2016-05-02T10:59Z
495,CWE-189,<S2SV_StartBug> int groups_per_flex = 0 ; <S2SV_EndBug> <S2SV_StartBug> groups_per_flex = 1 << sbi -> s_log_groups_per_flex ; <S2SV_EndBug> <S2SV_StartBug> if ( groups_per_flex < 2 ) { <S2SV_EndBug> ,<S2SV_ModStart> unsigned <S2SV_ModStart> if ( sbi -> s_log_groups_per_flex < 1 || sbi -> s_log_groups_per_flex > 31 ) { sbi -> s_log_groups_per_flex = 0 ; return 1 ; } <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/d50f2ab6f050311dbf7b8f5501b25f0bf64a439b,CVE-2012-2100,https://github.com/torvalds/linux/commit/d50f2ab6f050311dbf7b8f5501b25f0bf64a439b,2012-07-03T16:40Z
496,CWE-399,<S2SV_StartBug> if ( unlikely ( chunk_length < required_length ) ) <S2SV_EndBug> ,<S2SV_ModStart> chunk -> pdiscard ) ) return 0 ; if ( unlikely ( ,torvalds@linux/26b87c7881006311828bb0ab271a551a62dcceb4,CVE-2014-3688,https://github.com/torvalds/linux/commit/26b87c7881006311828bb0ab271a551a62dcceb4,2014-11-30T01:59Z
497,CWE-119,<S2SV_StartBug> for ( i = 0 ; a && i < count ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! i ) <S2SV_EndBug> ,<S2SV_ModStart> i ++ <S2SV_ModEnd> <S2SV_ModStart> if ( ! n ) { cJSON_Delete ( a ) ; return 0 ; } ,esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
498,CWE-287,<S2SV_StartBug> if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) <S2SV_EndBug> ,"<S2SV_ModStart> * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ; if ( <S2SV_ModStart> * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ; if ( ",evilnet@nefarious2/f50a84bad996d438e7b31b9e74c32a41e43f8be5,CVE-2016-7145,https://github.com/evilnet/nefarious2/commit/f50a84bad996d438e7b31b9e74c32a41e43f8be5,2017-03-07T15:59Z
499,CWE-189,<S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( int ) ,FFmpeg@FFmpeg/454a11a1c9c686c78aa97954306fb63453299760,CVE-2013-7010,https://github.com/FFmpeg/FFmpeg/commit/454a11a1c9c686c78aa97954306fb63453299760,2013-12-09T16:36Z
500,CWE-125,<S2SV_StartBug> match_length += callback_args -> forward_matches ; <S2SV_EndBug> ,<S2SV_ModStart> ; assert ( match_offset + match_length <= callback_args -> data_size ) ,VirusTotal@yara/992480c30f75943e9cd6245bb2015c7737f9b661,CVE-2017-9465,https://github.com/VirusTotal/yara/commit/992480c30f75943e9cd6245bb2015c7737f9b661,2017-06-06T21:29Z
501,CWE-264,<S2SV_StartBug> ! no_port_forwarding_flag && ! options . disable_forwarding ) { <S2SV_EndBug> ,<S2SV_ModStart> && use_privsep ,openbsd@src/c76fac666ea038753294f2ac94d310f8adece9ce,CVE-2016-10010,https://github.com/openbsd/src/commit/c76fac666ea038753294f2ac94d310f8adece9ce,2017-01-05T02:59Z
502,CWE-119,<S2SV_StartBug> if ( ! bitstream_read_bit ( bc ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> length > SMKTREE_DECODE_MAX_RECURSION ) { av_log ( NULL , AV_LOG_ERROR , ""Maximum<S2SV_blank>tree<S2SV_blank>recursion<S2SV_blank>level<S2SV_blank>exceeded.\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ",libav@libav/cd4663dc80323ba64989d0c103d51ad3ee0e9c2f,CVE-2017-16803,https://github.com/libav/libav/commit/cd4663dc80323ba64989d0c103d51ad3ee0e9c2f,2017-11-13T17:29Z
503,CWE-20,<S2SV_StartBug> m -> msg_name = address ; <S2SV_EndBug> ,<S2SV_ModStart> if ( m -> msg_name ) ,torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
504,CWE-125,"<S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> type_ignore_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( type_ignores , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_argtypes ) ) { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( argtypes , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_type_ignores , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> * out = Module ( body , type_ignores , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""returns\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { <S2SV_ModEnd> <S2SV_ModStart> ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
505,CWE-119,<S2SV_StartBug> int hstartcol ; <S2SV_EndBug> <S2SV_StartBug> hstartcol = ( numrows + 1 - parity ) >> 1 ; <S2SV_EndBug> <S2SV_StartBug> m = numrows - hstartcol ; <S2SV_EndBug> <S2SV_StartBug> dstptr = & a [ hstartcol * stride ] ; <S2SV_EndBug> ,<S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> hstartrow <S2SV_ModEnd> ,mdadams@jasper/4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a,CVE-2016-8654,https://github.com/mdadams/jasper/commit/4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a,2018-08-01T16:29Z
506,CWE-119,"<S2SV_StartBug> iwl_sta_ucode_activate ( priv , sta_id ) ; <S2SV_EndBug> ","<S2SV_ModStart> ret = iwl_sta_ucode_activate ( priv , sta_id ) <S2SV_ModEnd> ",torvalds@linux/2da424b0773cea3db47e1e81db71eeebde8269d4,CVE-2012-6712,https://github.com/torvalds/linux/commit/2da424b0773cea3db47e1e81db71eeebde8269d4,2019-07-27T22:15Z
507,CWE-59,"<S2SV_StartBug> log_file = fopen ( file_name , ""a"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> fopen_safe <S2SV_ModEnd> ,acassen@keepalived/04f2d32871bb3b11d7dc024039952f2fe2750306,CVE-2018-19044,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,2018-11-08T20:29Z
508,CWE-476,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> assert_regexp_syntax_error ( ""\\\\x0"" ) ; assert_regexp_syntax_error ( ""\\\\x"" ) ; assert_regexp_syntax_error ( ""\\\\xxy"" ) ; ",VirusTotal@yara/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,CVE-2016-10210,https://github.com/VirusTotal/yara/commit/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,2017-04-03T05:59Z
509,CWE-000,<S2SV_StartBug> if ( hashbin -> hb_type & HB_LOCK ) { <S2SV_EndBug> <S2SV_StartBug> queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> while ( queue ) { <S2SV_EndBug> <S2SV_StartBug> ( * free_func ) ( queue ) ; <S2SV_EndBug> <S2SV_StartBug> if ( hashbin -> hb_type & HB_LOCK ) { <S2SV_EndBug> <S2SV_StartBug> # ifdef CONFIG_LOCKDEP <S2SV_EndBug> ,"<S2SV_ModStart> spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; <S2SV_ModEnd> <S2SV_ModStart> while ( 1 ) { <S2SV_ModStart> if ( ! queue ) break ; <S2SV_ModEnd> <S2SV_ModStart> { if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ; free_func ( queue ) ; if ( hashbin -> hb_type & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/4c03b862b12f980456f9de92db6d508a4999b788,CVE-2017-6348,https://github.com/torvalds/linux/commit/4c03b862b12f980456f9de92db6d508a4999b788,2017-03-01T20:59Z
510,CWE-269,"<S2SV_StartBug> err = security_sb_remount ( sb , data ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NODEV ) && ! ( mnt_flags & MNT_NODEV ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOSUID ) && ! ( mnt_flags & MNT_NOSUID ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOEXEC ) && ! ( mnt_flags & MNT_NOEXEC ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_ATIME ) && ( ( mnt -> mnt . mnt_flags & MNT_ATIME_MASK ) != ( mnt_flags & MNT_ATIME_MASK ) ) ) { return - EPERM ; } ,torvalds@linux/9566d6742852c527bf5af38af5cbb878dad75705,CVE-2014-5207,https://github.com/torvalds/linux/commit/9566d6742852c527bf5af38af5cbb878dad75705,2014-08-18T11:15Z
511,CWE-20,"<S2SV_StartBug> int copied , err ; <S2SV_EndBug> <S2SV_StartBug> sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_EndBug> <S2SV_StartBug> if ( sock -> type == SOCK_PACKET ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> copied = skb -> len ; <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_name ) <S2SV_EndBug> <S2SV_StartBug> msg -> msg_namelen ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } else { struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_ModEnd> <S2SV_ModStart> } memcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } ",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
512,CWE-190,<S2SV_StartBug> uchar buf [ RAS_MAGICLEN ] ; <S2SV_EndBug> ,<S2SV_ModStart> jas_uchar <S2SV_ModEnd> ,mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
513,CWE-000,<S2SV_StartBug> if ( serial -> num_ports < 2 ) <S2SV_EndBug> ,"<S2SV_ModStart> num_bulk_out <S2SV_ModEnd> <S2SV_ModStart> { dev_err ( & serial -> interface -> dev , ""missing<S2SV_blank>bulk<S2SV_blank>out<S2SV_blank>endpoints\\n"" ) ; return - ENODEV ; } <S2SV_ModEnd> ",torvalds@linux/cb3232138e37129e88240a98a1d2aba2187ff57c,CVE-2015-7566,https://github.com/torvalds/linux/commit/cb3232138e37129e88240a98a1d2aba2187ff57c,2016-02-08T03:59Z
514,CWE-119,"<S2SV_StartBug> int do_rf64 = 0 , write_junk = 1 ; <S2SV_EndBug> <S2SV_StartBug> DS64Chunk ds64_chunk ; <S2SV_EndBug> <S2SV_StartBug> if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ; <S2SV_EndBug> <S2SV_StartBug> ds64hdr . ckSize = sizeof ( ds64_chunk ) ; <S2SV_EndBug> <S2SV_StartBug> ds64_chunk . sampleCount64 = total_samples ; <S2SV_EndBug> <S2SV_StartBug> WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ; <S2SV_EndBug> <S2SV_StartBug> ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) || <S2SV_EndBug> ","<S2SV_ModStart> , table_length = 0 <S2SV_ModStart> ; CS64Chunk cs64_chunk <S2SV_ModStart> total_riff_bytes += table_length * sizeof ( CS64Chunk ) ; if ( write_junk ) total_riff_bytes += <S2SV_ModEnd> <S2SV_ModStart> + ( table_length * sizeof ( CS64Chunk ) ) <S2SV_ModStart> ; ds64_chunk . tableLength = table_length <S2SV_ModStart> if ( table_length ) { strncpy ( cs64_chunk . ckID , ""dmmy"" , sizeof ( cs64_chunk . ckID ) ) ; cs64_chunk . chunkSize64 = 12345678 ; WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ; } <S2SV_ModStart> ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } if ( <S2SV_ModEnd> ",dbry@WavPack/d5bf76b5a88d044a1be1d5656698e3ba737167e5,CVE-2018-6767,https://github.com/dbry/WavPack/commit/d5bf76b5a88d044a1be1d5656698e3ba737167e5,2018-02-06T22:29Z
515,CWE-20,<S2SV_StartBug> if ( MSG_CMSG_COMPAT & flags ) { <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> msg_sys -> msg_flags = flags & ( MSG_CMSG_CLOEXEC | MSG_CMSG_COMPAT ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; msg_sys -> msg_namelen = 0 ,torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
516,CWE-119,<S2SV_StartBug> struct buffer_head * dibh = mp -> mp_bh [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> const unsigned end_of_metadata = height - 1 ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> super_block * sb = sdp -> sd_vfs ; struct <S2SV_ModStart> ; int ret <S2SV_ModStart> if ( buffer_zeronew ( bh_map ) ) { ret = sb_issue_zeroout ( sb , dblock , dblks , GFP_NOFS ) ; if ( ret ) { fs_err ( sdp , ""Failed<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>data<S2SV_blank>buffers\\n"" ) ; clear_buffer_zeronew ( bh_map ) ; } } ",torvalds@linux/64dd153c83743af81f20924c6343652d731eeecb,CVE-2011-4098,https://github.com/torvalds/linux/commit/64dd153c83743af81f20924c6343652d731eeecb,2013-06-08T13:05Z
517,CWE-119,"<S2SV_StartBug> vpx_codec_iface_name ( global -> codec -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> input -> use_i420 ? ""I420"" : ""YV12"" ) ; <S2SV_EndBug> <S2SV_StartBug> SHOW ( g_timebase . num ) ; <S2SV_EndBug> <S2SV_StartBug> SHOW ( rc_resize_allowed ) ; <S2SV_EndBug> ","<S2SV_ModStart> codec_interface ( ) ) ) ; fprintf ( stderr , ""Source<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>File<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>Format:<S2SV_blank>%s\\n"" , <S2SV_ModEnd> <S2SV_ModStart> file_type_to_string ( input -> file_type ) , image_format_to_string ( input -> fmt ) <S2SV_ModEnd> <S2SV_ModStart> g_bit_depth ) ; SHOW ( g_input_bit_depth ) ; SHOW ( <S2SV_ModStart> ) ; SHOW ( rc_scaled_width ) ; SHOW ( rc_scaled_height ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
518,CWE-787,<S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decompress_data ( context ) ; <S2SV_EndBug> <S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> <S2SV_StartBug> context -> decode ( context ) ; <S2SV_EndBug> <S2SV_StartBug> PROFILER_EXIT ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> ,<S2SV_ModStart> { BOOL rc ; <S2SV_ModStart> rc = <S2SV_ModStart> if ( ! rc ) return FALSE ; } { BOOL rc ; <S2SV_ModStart> rc = <S2SV_ModStart> if ( ! rc ) return FALSE ; } ,FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z
519,CWE-399,<S2SV_StartBug> ( target -> doc -> dict == ctxt -> dict ) ) <S2SV_EndBug> ,"<S2SV_ModStart> && xmlDictOwns ( ctxt -> dict , value ) ",chromium@chromium/2de493f4a1d48952e09230a0c32ccbd45db973b2,CVE-2012-2893,https://github.com/chromium/chromium/commit/2de493f4a1d48952e09230a0c32ccbd45db973b2,2012-09-26T10:56Z
520,CWE-269,"<S2SV_StartBug> if ( copy_file ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> <S2SV_ModStart> else { touch_file_as_user ( fname , u , g , 0644 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> <S2SV_ModStart> else { touch_file_as_user ( fname , u , g , 0644 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",netblue30@firejail/b8a4ff9775318ca5e679183884a6a63f3da8f863,CVE-2017-5940,https://github.com/netblue30/firejail/commit/b8a4ff9775318ca5e679183884a6a63f3da8f863,2017-02-09T18:59Z
521,CWE-189,"<S2SV_StartBug> size_t * acl_len ) <S2SV_EndBug> <S2SV_StartBug> __be32 * savep ; <S2SV_EndBug> <S2SV_StartBug> * acl_len = 0 ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ; <S2SV_EndBug> <S2SV_StartBug> dprintk ( ""NFS:<S2SV_blank>server<S2SV_blank>cheating<S2SV_blank>in<S2SV_blank>getattr"" <S2SV_EndBug> <S2SV_StartBug> * acl_len = attrlen ; <S2SV_EndBug> ","<S2SV_ModStart> struct nfs_getaclres * res <S2SV_ModEnd> <S2SV_ModStart> , * bm_p <S2SV_ModStart> res -> <S2SV_ModEnd> <S2SV_ModStart> ; bm_p = xdr -> p <S2SV_ModStart> xdr -> p = bm_p ; res -> acl_data_offset = be32_to_cpup ( bm_p ) + 2 ; res -> acl_data_offset <<= 2 ; <S2SV_ModStart> ; attrlen += res -> acl_data_offset <S2SV_ModStart> if ( res -> acl_flags & NFS4_ACL_LEN_REQUEST ) { res -> acl_len = attrlen ; goto out ; } dprintk ( ""NFS:<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\n"" <S2SV_ModEnd> <S2SV_ModStart> res -> <S2SV_ModEnd> ",torvalds@linux/bf118a342f10dafe44b14451a1392c3254629a1f,CVE-2011-4131,https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f,2012-05-17T11:00Z
522,CWE-119,<S2SV_StartBug> if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) { <S2SV_EndBug> ,<S2SV_ModStart> } else if ( warn_script_unsaved && fv -> script_unsaved && AskScriptChanged ( ) == 2 ) { return false ; ,fontforge@fontforge/626f751752875a0ddd74b9e217b6f4828713573c,CVE-2019-15785,https://github.com/fontforge/fontforge/commit/626f751752875a0ddd74b9e217b6f4828713573c,2019-08-29T13:15Z
523,CWE-617,<S2SV_StartBug> assert ( msix_tab_size % 4096 == 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z
524,CWE-189,<S2SV_StartBug> when = timespec_to_ns ( new_setting -> it_value ) ; <S2SV_EndBug> <S2SV_StartBug> period = timespec_to_ns ( new_setting -> it_interval ) ; <S2SV_EndBug> <S2SV_StartBug> now = timespec_to_ns ( n ) ; <S2SV_EndBug> ,<S2SV_ModStart> & <S2SV_ModStart> & <S2SV_ModStart> & ,torvalds@linux/f8bd2258e2d520dff28c855658bd24bdafb5102d,CVE-2011-3209,https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d,2012-10-03T11:02Z
525,CWE-674,"<S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , 0 ) ) <S2SV_EndBug> ","<S2SV_ModStart> js_doregexec ( J , <S2SV_ModEnd> ",ccxvii@mujs/00d4606c3baf813b7b1c176823b2729bf51002a2,CVE-2019-11413,https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2,2019-04-22T11:29Z
526,CWE-119,"<S2SV_StartBug> if ( Int_val ( Field ( ( value ) dest , 1 ) ) >= 0 ) <S2SV_EndBug> ",<S2SV_ModStart> Long_val <S2SV_ModEnd> ,ocaml@ocaml/659615c7b100a89eafe6253e7a5b9d84d0e8df74,CVE-2015-8869,https://github.com/ocaml/ocaml/commit/659615c7b100a89eafe6253e7a5b9d84d0e8df74,2016-06-13T19:59Z
527,CWE-770,"<S2SV_StartBug> struct range * range ; <S2SV_EndBug> <S2SV_StartBug> size_t content_length ; <S2SV_EndBug> <S2SV_StartBug> int code = 500 , fd = - 1 , i , nranges , ret ; <S2SV_EndBug> <S2SV_StartBug> if ( ( range = parse_range ( range_str , st -> st_size , & nranges ) ) == NULL ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( evb = evbuffer_new ( ) ) == NULL ) { <S2SV_EndBug> <S2SV_StartBug> ( void ) snprintf ( content_range , sizeof ( content_range ) , <S2SV_EndBug> <S2SV_StartBug> content_length = range -> end - range -> start + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( buffer_add_range ( fd , evb , range ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> content_length = 0 ; <S2SV_EndBug> <S2SV_StartBug> content_length += i ; <S2SV_EndBug> <S2SV_StartBug> range ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ( i = evbuffer_add_printf ( evb , ""\\r\\n--%ud--\\r\\n"" , <S2SV_EndBug> <S2SV_StartBug> content_length += i ; <S2SV_EndBug> <S2SV_StartBug> ""byteranges;<S2SV_blank>boundary=%ud"" , boundary ) ; <S2SV_EndBug> <S2SV_StartBug> close ( fd ) ; <S2SV_EndBug> <S2SV_StartBug> goto done ; <S2SV_EndBug> <S2SV_StartBug> if ( server_bufferevent_write_buffer ( clt , evb ) == - 1 ) <S2SV_EndBug> <S2SV_StartBug> bufferevent_enable ( clt -> clt_bev , EV_READ | EV_WRITE ) ; <S2SV_EndBug> <S2SV_StartBug> if ( clt -> clt_persist ) <S2SV_EndBug> <S2SV_StartBug> if ( evb != NULL ) <S2SV_EndBug> ","<S2SV_ModStart> range_data * r = & clt -> clt_ranges ; struct range * range <S2SV_ModEnd> <S2SV_ModStart> = 0 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> nranges = parse_ranges ( clt , <S2SV_ModEnd> <S2SV_ModStart> ) ) < 1 <S2SV_ModEnd> <S2SV_ModStart> r -> range_media = media ; <S2SV_ModEnd> <S2SV_ModStart> range = & r -> range [ 0 ] ; <S2SV_ModStart> range = & r -> range [ 0 ] ; content_length += <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> arc4random_buf ( & clt -> clt_boundary , sizeof ( clt -> clt_boundary ) ) ; for ( i = 0 ; i < nranges ; i ++ ) { range = & r -> range [ i ] ; if ( ( ret = snprintf ( NULL , 0 , ""\\r\\n--%llu\\r\\n"" ""Content-Type:<S2SV_blank>%s/%s\\r\\n"" ""Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\r\\n\\r\\n"" , clt -> clt_boundary , media -> media_type , media -> media_subtype , range -> start , range -> end , st -> st_size ) ) < 0 <S2SV_ModEnd> <S2SV_ModStart> ret + <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ret = snprintf ( NULL , 0 , ""\\r\\n--%llu--\\r\\n"" , clt -> clt_boundary ) ) < 0 <S2SV_ModEnd> <S2SV_ModStart> ret <S2SV_ModEnd> <S2SV_ModStart> ""byteranges;<S2SV_blank>boundary=%llu"" , clt -> clt_boundary <S2SV_ModEnd> <S2SV_ModStart> r -> range_toread = TOREAD_HTTP_RANGE <S2SV_ModEnd> <S2SV_ModStart> close ( fd ) ; <S2SV_ModStart> clt -> clt_fd = fd ; if ( clt -> clt_srvbev != NULL ) bufferevent_free ( clt -> clt_srvbev ) ; clt -> clt_srvbev_throttled = 0 ; clt -> clt_srvbev = bufferevent_new ( clt -> clt_fd , server_read_httprange , server_write , server_file_error , clt ) ; if ( clt -> clt_srvbev == NULL ) { errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer<S2SV_blank>event"" ; <S2SV_ModEnd> <S2SV_ModStart> } bufferevent_setwatermark ( clt -> clt_srvbev , EV_READ , 0 , clt -> clt_sndbufsiz ) ; bufferevent_settimeout ( clt -> clt_srvbev , srv_conf -> timeout . tv_sec , srv_conf -> timeout . tv_sec ) ; bufferevent_enable ( clt -> clt_srvbev , EV_READ ) ; bufferevent_disable ( clt -> clt_bev , EV_READ ) ; done : server_reset_http ( clt ) ; return ( 0 ) ; fail : bufferevent_disable <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",openbsd@src/142cfc82b932bc211218fbd7bdda8c7ce83f19df,CVE-2017-5850,https://github.com/openbsd/src/commit/142cfc82b932bc211218fbd7bdda8c7ce83f19df,2017-03-27T15:59Z
528,CWE-20,"<S2SV_StartBug> ier = ksz8851ReadReg ( interface , KSZ8851_REG_IER ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_IER , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> isr = ksz8851ReadReg ( interface , KSZ8851_REG_ISR ) ; <S2SV_EndBug> <S2SV_StartBug> ier &= ~ IER_LCIE ; <S2SV_EndBug> <S2SV_StartBug> if ( ( isr & ISR_TXIS ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_TXIS ) ; <S2SV_EndBug> <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ; <S2SV_EndBug> <S2SV_StartBug> if ( ( isr & ISR_RXIS ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> ier &= ~ IER_RXIE ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_IER , ier ) ; <S2SV_EndBug> ","<S2SV_ModStart> KSZ8851_IER <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_IER <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_ISR ) ; if ( ( isr & KSZ8851_ISR_LCIS <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_IER_LCIE <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_ISR_TXIS <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_ISR , KSZ8851_ISR_TXIS <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_ISR_RXIS <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_IER_RXIE <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_IER <S2SV_ModEnd> ",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
529,CWE-119,"<S2SV_StartBug> static void encode_quantization ( VP9_COMMON * cm , <S2SV_EndBug> <S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> base_qindex , QINDEX_BITS ) ; <S2SV_EndBug> ",<S2SV_ModStart> const VP9_COMMON * const <S2SV_ModEnd> <S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
530,CWE-119,<S2SV_StartBug> } else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) { <S2SV_EndBug> ,<S2SV_ModStart> && c -> format != CHUNKY ,FFmpeg@FFmpeg/1e42736b95065c69a7481d0cf55247024f54b660,CVE-2017-9996,https://github.com/FFmpeg/FFmpeg/commit/1e42736b95065c69a7481d0cf55247024f54b660,2017-06-28T06:29Z
531,CWE-284,"<S2SV_StartBug> if ( write ( uipc_main . ch [ ch_id ] . fd , p_buf , msglen ) < 0 ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ,system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
532,CWE-119,<S2SV_StartBug> return tmp ; <S2SV_EndBug> <S2SV_StartBug> return tmp ; <S2SV_EndBug> <S2SV_StartBug> return state -> ptr = tmp ; <S2SV_EndBug> ,<S2SV_ModStart> goto softfail <S2SV_ModEnd> <S2SV_ModStart> goto softfail <S2SV_ModEnd> <S2SV_ModStart> softfail : state -> offset = 0 ; ,m6w6@ext-http/3724cd76a28be1d6049b5537232e97ac567ae1f5,CVE-2016-5873,https://github.com/m6w6/ext-http/commit/3724cd76a28be1d6049b5537232e97ac567ae1f5,2017-01-23T21:59Z
533,CWE-200,<S2SV_StartBug> struct fb_vblank vblank ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & vblank , 0 , sizeof ( vblank ) ) ",torvalds@linux/eda98796aff0d9bf41094b06811f5def3b4c333c,CVE-2015-7884,https://github.com/torvalds/linux/commit/eda98796aff0d9bf41094b06811f5def3b4c333c,2015-12-28T11:59Z
534,CWE-416,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } else if ( ctx -> might_cancel ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> spin_lock ( & ctx -> cancel_lock ) ; <S2SV_ModStart> { __timerfd_remove_cancel <S2SV_ModEnd> <S2SV_ModStart> spin_unlock ( & ctx -> cancel_lock ) ; ,torvalds@linux/1e38da300e1e395a15048b0af1e5305bd91402f6,CVE-2017-10661,https://github.com/torvalds/linux/commit/1e38da300e1e395a15048b0af1e5305bd91402f6,2017-08-19T18:29Z
535,CWE-000,"<S2SV_StartBug> c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( c16 -> Curves [ i ] == NULL ) { for ( j = 0 ; j < i ; j ++ ) { _cmsFree ( ContextID , c16 -> Curves [ j ] ) ; } _cmsFree ( ContextID , c16 -> Curves ) ; _cmsFree ( ContextID , c16 ) ; return NULL ; } ",mm2@Little-CMS/91c2db7f2559be504211b283bc3a2c631d6f06d9,CVE-2013-4160,https://github.com/mm2/Little-CMS/commit/91c2db7f2559be504211b283bc3a2c631d6f06d9,2014-01-21T18:55Z
536,CWE-20,"<S2SV_StartBug> if ( kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ! dev_name || ,torvalds@linux/4e78c724d47e2342aa8fde61f6b8536f662f795f,CVE-2011-2518,https://github.com/torvalds/linux/commit/4e78c724d47e2342aa8fde61f6b8536f662f795f,2012-05-24T23:55Z
537,CWE-125,"<S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z
538,CWE-125,"<S2SV_StartBug> if ( peekonly ) { <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , space_rem ) ; <S2SV_EndBug> <S2SV_StartBug> sizeof ( * msg ) - space_rem ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) - <S2SV_EndBug> <S2SV_StartBug> } else if ( space_rem == sizeof ( * msg ) ) { <S2SV_EndBug> ","<S2SV_ModStart> memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd> <S2SV_ModStart> sizeof ( * msg ) - space_rem , buf_size ) ; } else if ( space_rem == sizeof ( * msg ) ) { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd> <S2SV_ModStart> buf_size ) ; } else { if ( buf ) { <S2SV_ModEnd> <S2SV_ModStart> curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",stoth68000@media-tree/354dd3924a2e43806774953de536257548b5002c,CVE-2017-8831,https://github.com/stoth68000/media-tree/commit/354dd3924a2e43806774953de536257548b5002c,2017-05-08T06:29Z
539,CWE-190,"<S2SV_StartBug> RETVAL_STRINGL ( replaced , ( int ) new_len , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( new_len > INT_MAX ) { efree ( replaced ) ; RETURN_FALSE ; } ,php@php-src/0da8b8b801f9276359262f1ef8274c7812d3dfda,CVE-2016-5094,https://github.com/php/php-src/commit/0da8b8b801f9276359262f1ef8274c7812d3dfda?w=1,2016-08-07T10:59Z
540,CWE-639,"<S2SV_StartBug> if ( peerkey && ! EVP_PKEY_cmp ( peerkey , localkey ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> != 1 ,openbsd@src/7afb2d41c6d373cf965285840b85c45011357115,CVE-2020-16088,https://github.com/openbsd/src/commit/7afb2d41c6d373cf965285840b85c45011357115,2020-07-28T12:15Z
541,CWE-119,"<S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> ","<S2SV_ModStart> alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ",TeX-Live@texlive-source/6ed0077520e2b0da1fd060c7f88db7b2e6068e4c,CVE-2018-17407,https://github.com/TeX-Live/texlive-source/commit/6ed0077520e2b0da1fd060c7f88db7b2e6068e4c,2018-09-23T21:29Z
542,CWE-119,"<S2SV_StartBug> BLOCK_SIZE bsize , BLOCK_SIZE subsize ) { <S2SV_EndBug> <S2SV_StartBug> int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; <S2SV_EndBug> <S2SV_StartBug> PARTITION_TYPE partition = partition_lookup [ bsl ] [ subsize ] ; <S2SV_EndBug> <S2SV_StartBug> set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; <S2SV_EndBug> <S2SV_StartBug> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_EndBug> <S2SV_StartBug> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col + hbs , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; <S2SV_EndBug> <S2SV_StartBug> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_EndBug> <S2SV_StartBug> duplicate_mode_info_in_sb ( cm , xd , mi_row + hbs , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> * ( get_sb_partitioning ( x , subsize ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize , <S2SV_EndBug> <S2SV_StartBug> fill_mode_info_sb ( cm , x , mi_row + hbs , mi_col , subsize , <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ","<S2SV_ModStart> PC_TREE * pc_tree <S2SV_ModEnd> <S2SV_ModStart> b_width_log2_lookup [ bsize ] <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> partitioning ; BLOCK_SIZE subsize = get_subsize ( bsize , partition ) <S2SV_ModEnd> <S2SV_ModStart> set_mode_info_offsets ( cm , x <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> none . mic ; * ( x -> mbmi_ext ) = pc_tree -> none . mbmi_ext <S2SV_ModEnd> <S2SV_ModStart> set_mode_info_offsets ( cm , x <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> vertical [ 0 ] . mic ; * ( x -> mbmi_ext ) = pc_tree -> vertical [ 0 ] . mbmi_ext ; <S2SV_ModEnd> <S2SV_ModStart> subsize <S2SV_ModEnd> <S2SV_ModStart> set_mode_info_offsets ( cm , x , xd , mi_row , mi_col + hbs ) ; * ( xd -> mi [ 0 ] ) = pc_tree -> vertical [ 1 ] . mic ; * ( x -> mbmi_ext ) = pc_tree -> vertical [ 1 ] . mbmi_ext ; <S2SV_ModEnd> <S2SV_ModStart> subsize <S2SV_ModEnd> <S2SV_ModStart> set_mode_info_offsets ( cm , x <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> horizontal [ 0 ] . mic ; * ( x -> mbmi_ext ) = pc_tree -> horizontal [ 0 ] . mbmi_ext ; <S2SV_ModEnd> <S2SV_ModStart> subsize <S2SV_ModEnd> <S2SV_ModStart> set_mode_info_offsets ( cm , x , xd , mi_row + hbs , mi_col ) ; * ( xd -> mi [ 0 ] ) = pc_tree -> horizontal [ 1 ] . mic ; * ( x -> mbmi_ext ) = pc_tree -> horizontal [ 1 ] . mbmi_ext ; <S2SV_ModEnd> <S2SV_ModStart> subsize <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> split [ 0 ] ) ; fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize , pc_tree -> split [ 1 ] ) <S2SV_ModEnd> <S2SV_ModStart> + hbs , mi_col , subsize , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> <S2SV_ModStart> + hbs , subsize , pc_tree -> split [ 3 ] <S2SV_ModEnd> <S2SV_ModStart> } ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
543,CWE-20,<S2SV_StartBug> free ( name ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! strcmp ( key , ""url"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , ""disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s"" , value ) ; ",git@git/a124133e1e6ab5c7a9fef6d0e6bcb084e3455b46,CVE-2018-17456,https://github.com/git/git/commit/a124133e1e6ab5c7a9fef6d0e6bcb084e3455b46,2018-10-06T14:29Z
544,CWE-119,<S2SV_StartBug> int pixel_ptr = 0 ; <S2SV_EndBug> <S2SV_StartBug> block_ptr = row_ptr + pixel_ptr ; <S2SV_EndBug> <S2SV_StartBug> ADVANCE_BLOCK ( ) ; <S2SV_EndBug> <S2SV_StartBug> block_ptr = row_ptr + pixel_ptr ; <S2SV_EndBug> <S2SV_StartBug> ADVANCE_BLOCK ( ) ; <S2SV_EndBug> <S2SV_StartBug> block_ptr = row_ptr + pixel_ptr ; <S2SV_EndBug> <S2SV_StartBug> ADVANCE_BLOCK ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> - 4 <S2SV_ModEnd> <S2SV_ModStart> ADVANCE_BLOCK ( ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ADVANCE_BLOCK ( ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ADVANCE_BLOCK ( ) ; <S2SV_ModStart>  <S2SV_ModEnd> ,FFmpeg@FFmpeg/3819db745da2ac7fb3faacb116788c32f4753f34,CVE-2013-7009,https://github.com/FFmpeg/FFmpeg/commit/3819db745da2ac7fb3faacb116788c32f4753f34,2013-12-09T16:36Z
545,CWE-190,<S2SV_StartBug> int n ; <S2SV_EndBug> ,<S2SV_ModStart> ssize_t <S2SV_ModEnd> ,mdadams@jasper/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,CVE-2016-9262,https://github.com/mdadams/jasper/commit/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,2017-03-23T18:59Z
546,CWE-400,<S2SV_StartBug> __be16 type ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( NAPI_GRO_CB ( skb ) -> encap_mark ) goto out ; NAPI_GRO_CB ( skb ) -> encap_mark = 1 ,torvalds@linux/fac8e0f579695a3ecbc4d3cac369139d7f819971,CVE-2016-8666,https://github.com/torvalds/linux/commit/fac8e0f579695a3ecbc4d3cac369139d7f819971,2016-10-16T21:59Z
547,CWE-476,<S2SV_StartBug> if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) { <S2SV_EndBug> ,<S2SV_ModStart> numrows < 0 || numcols < 0 ) { return 0 ; } if ( ,mdadams@jasper/5d66894d2313e3f3469f19066e149e08ff076698,CVE-2016-8884,https://github.com/mdadams/jasper/commit/5d66894d2313e3f3469f19066e149e08ff076698,2017-03-28T14:59Z
548,CWE-522,"<S2SV_StartBug> rval = tpm_kdfa ( sapi_context , session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,01org@tpm2.0-tools/c5d72beaab1cbbbe68271f4bc4b6670d69985157,CVE-2017-7524,https://github.com/01org/tpm2.0-tools/commit/c5d72beaab1cbbbe68271f4bc4b6670d69985157,2017-06-27T14:29Z
549,CWE-476,"<S2SV_StartBug> ret = key_permission ( key_ref , KEY_NEED_READ ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { ret = - ENOKEY ; goto error2 ; } ",torvalds@linux/37863c43b2c6464f252862bf2e9768264e961678,CVE-2017-12192,https://github.com/torvalds/linux/commit/37863c43b2c6464f252862bf2e9768264e961678,2017-10-12T00:29Z
550,CWE-172,<S2SV_StartBug> || ( ret == ERROR_UNAVAIL_MVBUF_T ) ) <S2SV_EndBug> <S2SV_StartBug> || ( ret == ERROR_UNAVAIL_MVBUF_T ) ) <S2SV_EndBug> ,<S2SV_ModStart> || ( ret == ERROR_INV_SPS_PPS_T ) ) { ps_dec -> u4_slice_start_code_found = 0 ; <S2SV_ModEnd> <S2SV_ModStart> || ( ret == ERROR_INV_SPS_PPS_T ) ,external@libavc/7554755536019e439433c515eeb44e701fb3bfb2,CVE-2016-3828,https://android.googlesource.com/platform/external/libavc/+/7554755536019e439433c515eeb44e701fb3bfb2,2016-08-05T20:59Z
551,CWE-190,<S2SV_StartBug> dst_known = tnum_is_const ( dst_reg -> var_off ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } ,torvalds@linux/bb7f0f989ca7de1153bd128a40a71709e339fa03,CVE-2017-17854,https://github.com/torvalds/linux/commit/bb7f0f989ca7de1153bd128a40a71709e339fa03,2017-12-27T17:08Z
552,CWE-264,<S2SV_StartBug> if ( ( rc == 0 ) || ( rc == - ENOENT ) ) <S2SV_EndBug> ,"<S2SV_ModStart> switch ( rc ) { case 0 : if ( newInode && ! S_ISREG ( newInode -> i_mode ) ) { CIFSSMBClose ( xid , pTcon , fileHandle ) ; break ; } case - ENOENT : posix_open = true ; case - EOPNOTSUPP : break ; default : pTcon -> broken_posix_open = true ; } } if ( ! posix_open ) rc = cifs_get_inode_info_unix ( & newInode , full_path , parent_dir_inode -> i_sb , xid ) ; } else rc = cifs_get_inode_info ( & newInode , full_path , NULL , parent_dir_inode -> i_sb , xid , NULL ) ; <S2SV_ModStart> && ( newInode != NULL ) ) { d_add ( direntry , newInode ) ; if ( posix_open ) { filp = lookup_instantiate_filp ( nd , direntry , generic_file_open ) ; if ( IS_ERR ( filp ) ) { rc = PTR_ERR ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; goto lookup_out ; } cfile = cifs_new_fileinfo ( fileHandle , filp , tlink , oplock ) ; if ( cfile == NULL ) { fput ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; rc = - ENOMEM ; goto lookup_out ; } } renew_parental_timestamps ( direntry ) ; } else if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/88d7d4e4a439f32acc56a6d860e415ee71d3df08,CVE-2012-1090,https://github.com/torvalds/linux/commit/88d7d4e4a439f32acc56a6d860e415ee71d3df08,2012-05-17T11:00Z
553,CWE-190,<S2SV_StartBug> u8 * data = NULL ; <S2SV_EndBug> <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> hdr . flags & ~ ( VFIO_IRQ_SET_DATA_TYPE_MASK | <S2SV_EndBug> <S2SV_StartBug> if ( ! ( hdr . flags & VFIO_IRQ_SET_DATA_NONE ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( hdr . flags & VFIO_IRQ_SET_DATA_BOOL ) <S2SV_EndBug> <S2SV_StartBug> hdr . start >= max || hdr . start + hdr . count > max ) <S2SV_EndBug> ,"<S2SV_ModStart> size_t size ; <S2SV_ModStart> max , <S2SV_ModStart> count >= ( U32_MAX - hdr . start ) || hdr . <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) return - EINVAL ; switch ( hdr . flags & VFIO_IRQ_SET_DATA_TYPE_MASK ) { case VFIO_IRQ_SET_DATA_NONE : size = 0 ; break ; case VFIO_IRQ_SET_DATA_BOOL : size = sizeof ( uint8_t ) ; break ; case VFIO_IRQ_SET_DATA_EVENTFD : size = sizeof ( int32_t ) ; break ; default : return - EINVAL ; } if ( size ) { if ( hdr . argsz - minsz < hdr . count * size ",torvalds@linux/05692d7005a364add85c6e25a6c4447ce08f913a,CVE-2016-9084,https://github.com/torvalds/linux/commit/05692d7005a364add85c6e25a6c4447ce08f913a,2016-11-28T03:59Z
554,CWE-200,"<S2SV_StartBug> if ( ext4_test_inode_state ( inode , EXT4_STATE_ORDERED_MODE ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/06bd3c36a733ac27962fea7d6f47168841376824,CVE-2017-7495,https://github.com/torvalds/linux/commit/06bd3c36a733ac27962fea7d6f47168841376824,2017-05-15T18:29Z
555,CWE-119,<S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> ,<S2SV_ModStart> UINT64_MAX <S2SV_ModEnd> ,FFmpeg@FFmpeg/2a05c8f813de6f2278827734bf8102291e7484aa,CVE-2016-10190,https://github.com/FFmpeg/FFmpeg/commit/2a05c8f813de6f2278827734bf8102291e7484aa,2017-02-09T15:59Z
556,CWE-362,"<S2SV_StartBug> int opt_size = sizeof ( struct ip_options ) + opt -> optlen ; <S2SV_EndBug> <S2SV_StartBug> if ( ireq -> opt != NULL && ip_options_echo ( ireq -> opt , skb ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> & ireq -> opt <S2SV_ModEnd> ,torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z
557,CWE-119,"<S2SV_StartBug> int mutt_b64_decode ( char * out , const char * in ) <S2SV_EndBug> <S2SV_StartBug> * out ++ = ( base64val ( digit1 ) << 2 ) | ( base64val ( digit2 ) >> 4 ) ; <S2SV_EndBug> <S2SV_StartBug> * out ++ = ( ( base64val ( digit2 ) << 4 ) & 0xf0 ) | ( base64val ( digit3 ) >> 2 ) ; <S2SV_EndBug> <S2SV_StartBug> * out ++ = ( ( base64val ( digit3 ) << 6 ) & 0xc0 ) | base64val ( digit4 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , size_t olen <S2SV_ModStart> if ( len == olen ) return len ; <S2SV_ModStart> if ( len == olen ) return len ; <S2SV_ModStart> if ( len == olen ) return len ; ",neomutt@neomutt/6f163e07ae68654d7ac5268cbb7565f6df79ad85,CVE-2018-14359,https://github.com/neomutt/neomutt/commit/6f163e07ae68654d7ac5268cbb7565f6df79ad85,2018-07-17T17:29Z
558,CWE-415,<S2SV_StartBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/8dca4a41f1ad65043a78c2338d9725f859c8d2c3,CVE-2017-18174,https://github.com/torvalds/linux/commit/8dca4a41f1ad65043a78c2338d9725f859c8d2c3,2018-02-11T18:29Z
559,CWE-119,"<S2SV_StartBug> size_t copied , len , cur_len ; <S2SV_EndBug> <S2SV_StartBug> copied = min_t ( const size_t , cur_len , PAGE_SIZE ) ; <S2SV_EndBug> <S2SV_StartBug> 0 , copied ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> cur_len = save_len - cur_len ; <S2SV_EndBug> ","<S2SV_ModStart> bytes , <S2SV_ModStart> bytes <S2SV_ModEnd> <S2SV_ModStart> bytes <S2SV_ModEnd> <S2SV_ModStart> if ( copied < bytes ) break ; <S2SV_ModStart> ; if ( ! cur_len ) { for ( i = 0 ; i < nr_pages ; i ++ ) put_page ( wdata -> pages [ i ] ) ; kfree ( wdata ) ; rc = - EFAULT ; break ; } for ( ; nr_pages > i + 1 ; nr_pages -- ) put_page ( wdata -> pages [ nr_pages - 1 ] ) ",torvalds@linux/5d81de8e8667da7135d3a32a964087c0faf5483f,CVE-2014-0069,https://github.com/torvalds/linux/commit/5d81de8e8667da7135d3a32a964087c0faf5483f,2014-02-28T06:18Z
560,CWE-000,<S2SV_StartBug> if ( ! ( quirks & CP_RDESC_SWAPPED_MIN_MAX ) ) <S2SV_EndBug> ,<S2SV_ModStart> ) return rdesc ; if ( * rsize < 4 ,torvalds@linux/1ebb71143758f45dc0fa76e2f48429e13b16d110,CVE-2017-7273,https://github.com/torvalds/linux/commit/1ebb71143758f45dc0fa76e2f48429e13b16d110,2017-03-27T17:59Z
561,CWE-119,"<S2SV_StartBug> int number_of_frames , number_of_keyframes , encode_frame_count ; <S2SV_EndBug> <S2SV_StartBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <S2SV_EndBug> <S2SV_StartBug> encode_frame_count = si -> encode_frame_count ; <S2SV_EndBug> <S2SV_StartBug> if ( si -> encode_frame_count <= 0 ) return vpx_svc_get_message ( svc_ctx ) ; <S2SV_EndBug> <S2SV_StartBug> number_of_keyframes = encode_frame_count / si -> kf_dist + 1 ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < si -> layers ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> number_of_frames = encode_frame_count ; <S2SV_EndBug> <S2SV_StartBug> si -> encode_frame_count = 0 ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> <S2SV_ModStart> number_of_frames = si -> psnr_pkt_received <S2SV_ModEnd> <S2SV_ModStart> number_of_frames <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> svc_ctx -> spatial_layers <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> psnr_pkt_received <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
562,CWE-787,"<S2SV_StartBug> static void nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 originalSize ) <S2SV_EndBug> <S2SV_StartBug> * out ++ = value ; <S2SV_EndBug> <S2SV_StartBug> FillMemory ( out , len , value ) ; <S2SV_EndBug> <S2SV_StartBug> * out ++ = value ; <S2SV_EndBug> ","<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> , UINT32 outSize <S2SV_ModStart> if ( outSize < 1 ) return FALSE ; outSize -- ; <S2SV_ModStart> if ( outSize < len ) return FALSE ; outSize -= len ; <S2SV_ModStart> if ( outSize < 1 ) return FALSE ; outSize -- ; * out ++ = value ; left -- ; } } if ( ( outSize < 4 ) || ( left < 4 ) ) return FALSE ; memcpy ( out , in , 4 ) ; return TRUE <S2SV_ModEnd> ",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z
563,CWE-476,<S2SV_StartBug> if ( screen -> sb_buffer ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,vim@vim/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,CVE-2018-20786,https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,2019-02-24T14:29Z
564,CWE-125,"<S2SV_StartBug> const char * literal_start = * str ; <S2SV_EndBug> <S2SV_StartBug> for ( ; * str < end ; ( * str ) ++ ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && <S2SV_EndBug> <S2SV_StartBug> in_named_escape = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( * str + 1 < end && * ( * str + 1 ) == ch ) { <S2SV_EndBug> <S2SV_StartBug> ast_error ( c , n , ""f-string:<S2SV_blank>single<S2SV_blank>\'}\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed"" ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> literal_end = * str ; <S2SV_EndBug> <S2SV_StartBug> assert ( * str <= end ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( * str == end || * * str == '{' || * * str == '}' ) ; <S2SV_EndBug> <S2SV_StartBug> if ( literal_start != literal_end ) { <S2SV_EndBug> <S2SV_StartBug> literal_end - literal_start , <S2SV_EndBug> <S2SV_StartBug> literal_end - literal_start ) ; <S2SV_EndBug> ","<S2SV_ModStart> s = * str ; const char * literal_start = s <S2SV_ModEnd> <S2SV_ModStart> while ( s < end ) { char ch = * s ++ <S2SV_ModEnd> <S2SV_ModStart> raw && ch == '\\\\' && s < end ) { ch = * s ++ ; if ( ch == 'N' ) { if ( s < end && * s ++ == '{' ) { while ( s < end && * s ++ != <S2SV_ModEnd> <S2SV_ModStart> } continue ; } break ; } if ( ch == '{' && warn_invalid_escape_sequence ( c , n , ch ) < 0 ) { return - 1 ; } } <S2SV_ModEnd> <S2SV_ModStart> s < end && * s == ch ) { * str = s + 1 <S2SV_ModEnd> <S2SV_ModStart> * str = s - 1 ; <S2SV_ModStart> s -- ; <S2SV_ModStart> * str = s <S2SV_ModEnd> <S2SV_ModStart> s <S2SV_ModEnd> <S2SV_ModStart> s <S2SV_ModEnd> <S2SV_ModStart> s <S2SV_ModEnd> <S2SV_ModStart> s <S2SV_ModEnd> <S2SV_ModStart> s <S2SV_ModEnd> <S2SV_ModStart> s <S2SV_ModEnd> <S2SV_ModStart> s <S2SV_ModEnd> ",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
565,CWE-190,"<S2SV_StartBug> static int mem_resize ( jas_stream_memobj_t * m , int bufsize ) <S2SV_EndBug> <S2SV_StartBug> assert ( bufsize >= 0 ) ; <S2SV_EndBug> <S2SV_StartBug> JAS_DBGLOG ( 100 , ( ""mem_resize(%p,<S2SV_blank>%d)\\n"" , m , bufsize ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""mem_resize(%p,<S2SV_blank>%zu)\\n"" <S2SV_ModEnd> <S2SV_ModStart> if ( ! bufsize ) { jas_eprintf ( ""mem_resize<S2SV_blank>was<S2SV_blank>not<S2SV_blank>really<S2SV_blank>designed<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>a<S2SV_blank>buffer<S2SV_blank>of<S2SV_blank>size<S2SV_blank>0\\n"" ""This<S2SV_blank>may<S2SV_blank>not<S2SV_blank>work.\\n"" ) ; } ",mdadams@jasper/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,CVE-2016-9262,https://github.com/mdadams/jasper/commit/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,2017-03-23T18:59Z
566,CWE-200,"<S2SV_StartBug> struct dump_dir * dd = create_dump_dir_from_problem_data ( pd , g_settings_dump_location ) ; <S2SV_EndBug> ","<S2SV_ModStart> dd = NULL ; if ( g_settings_privatereports ) dd = create_dump_dir_from_problem_data_ext ( pd , g_settings_dump_location , 0 ) ; else ",abrt@abrt/8939398b82006ba1fec4ed491339fc075f43fc7c,CVE-2015-1870,https://github.com/abrt/abrt/commit/8939398b82006ba1fec4ed491339fc075f43fc7c,2017-06-26T15:29Z
567,CWE-476,"<S2SV_StartBug> if ( ! LookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) ) { <S2SV_EndBug> ",<S2SV_ModStart> || ! expr -> action . args ,xkbcommon@libxkbcommon/96df3106d49438e442510c59acad306e94f3db4d,CVE-2018-15863,https://github.com/xkbcommon/libxkbcommon/commit/96df3106d49438e442510c59acad306e94f3db4d,2018-08-25T21:29Z
568,CWE-763,<S2SV_StartBug> static void pcrypt_free ( struct crypto_instance * inst ) <S2SV_EndBug> <S2SV_StartBug> struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ; <S2SV_EndBug> ,<S2SV_ModStart> aead_instance <S2SV_ModEnd> <S2SV_ModStart> aead_instance_ctx <S2SV_ModEnd> ,torvalds@linux/d76c68109f37cb85b243a1cf0f40313afd2bae68,CVE-2017-18075,https://github.com/torvalds/linux/commit/d76c68109f37cb85b243a1cf0f40313afd2bae68,2018-01-24T10:29Z
569,CWE-190,<S2SV_StartBug> pixel_value += ( srcptr2 [ z ] << ( 8 * z ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( unsigned long ) ,LibVNC@libvncserver/a6788d1da719ae006605b78d22f5a9f170b423af,CVE-2020-14401,https://github.com/LibVNC/libvncserver/commit/a6788d1da719ae006605b78d22f5a9f170b423af,2020-06-17T16:15Z
570,CWE-125,<S2SV_StartBug> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) <S2SV_EndBug> ,"<S2SV_ModStart> EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ",ImageMagick@ImageMagick/7afcf9f71043df15508e46f079387bd4689a738d,CVE-2016-7101,https://github.com/ImageMagick/ImageMagick/commit/7afcf9f71043df15508e46f079387bd4689a738d,2017-01-18T17:59Z
571,CWE-17,<S2SV_StartBug> in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( <S2SV_ModStart> < <S2SV_ModEnd> <S2SV_ModStart> ) { in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ; } else { ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>Got<S2SV_blank>route<S2SV_blank>advertisement<S2SV_blank>with<S2SV_blank>lower<S2SV_blank>hop_limit<S2SV_blank>than<S2SV_blank>current\\n"" ) ; } <S2SV_ModEnd> ",torvalds@linux/6fd99094de2b83d1d4c8457f2c83483b2828e75a,CVE-2015-2922,https://github.com/torvalds/linux/commit/6fd99094de2b83d1d4c8457f2c83483b2828e75a,2015-05-27T10:59Z
572,CWE-125,"<S2SV_StartBug> l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> <S2SV_StartBug> const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_EndBug> ","<S2SV_ModStart> , u_int length <S2SV_ModStart> if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } ",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z
573,CWE-200,<S2SV_StartBug> if ( ! replay_esn || ! rp ) <S2SV_EndBug> <S2SV_StartBug> if ( xfrm_replay_state_esn_len ( replay_esn ) != <S2SV_EndBug> <S2SV_StartBug> xfrm_replay_state_esn_len ( up ) ) <S2SV_EndBug> ,<S2SV_ModStart> int ulen ; <S2SV_ModStart> ulen = xfrm_replay_state_esn_len ( up ) ; if ( nla_len ( rp ) < ulen || <S2SV_ModEnd> <S2SV_ModStart> ulen <S2SV_ModEnd> ,torvalds@linux/ecd7918745234e423dd87fcc0c077da557909720,CVE-2012-6536,https://github.com/torvalds/linux/commit/ecd7918745234e423dd87fcc0c077da557909720,2013-03-15T20:55Z
574,CWE-190,"<S2SV_StartBug> int ret = proc_dointvec ( table , write , buffer , lenp , ppos ) ; <S2SV_EndBug> ",<S2SV_ModStart> proc_dointvec_minmax <S2SV_ModEnd> ,torvalds@linux/1572e45a924f254d9570093abde46430c3172e3d,CVE-2017-18255,https://github.com/torvalds/linux/commit/1572e45a924f254d9570093abde46430c3172e3d,2018-03-31T17:29Z
575,CWE-119,"<S2SV_StartBug> in_what_stride , UINT_MAX ) <S2SV_EndBug> <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
576,CWE-125,"<S2SV_StartBug> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if <S2SV_EndBug> ",<S2SV_ModStart> 00 ; if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) { l_current_pi -> include = <S2SV_ModStart> } ,uclouvain@openjpeg/c16bc057ba3f125051c9966cf1f5b68a05681de4,CVE-2016-7163,https://github.com/uclouvain/openjpeg/commit/c16bc057ba3f125051c9966cf1f5b68a05681de4,2016-09-21T14:25Z
577,CWE-269,"<S2SV_StartBug> return try_then_request_module ( __crypto_lookup_template ( name ) , ""%s"" , <S2SV_EndBug> ","<S2SV_ModStart> ""crypto-%s"" <S2SV_ModEnd> ",torvalds@linux/4943ba16bbc2db05115707b3ff7b4874e9e3c560,CVE-2014-9644,https://github.com/torvalds/linux/commit/4943ba16bbc2db05115707b3ff7b4874e9e3c560,2015-03-02T11:59Z
578,CWE-000,"<S2SV_StartBug> int start = 0 ; <S2SV_EndBug> <S2SV_StartBug> kvm_pit_load_count ( kvm , 0 , kvm -> arch . vpit -> pit_state . channels [ 0 ] . count , start ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; int i <S2SV_ModStart> for ( i = 0 ; i < 3 ; i ++ ) <S2SV_ModStart> i <S2SV_ModEnd> <S2SV_ModStart> i <S2SV_ModEnd> ,torvalds@linux/0185604c2d82c560dab2f2933a18f797e74ab5a8,CVE-2015-7513,https://github.com/torvalds/linux/commit/0185604c2d82c560dab2f2933a18f797e74ab5a8,2016-02-08T03:59Z
579,CWE-119,"<S2SV_StartBug> static void encode_nonrd_sb_row ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( mi_col = tile -> mi_col_start ; mi_col < tile -> mi_col_end ; <S2SV_EndBug> <S2SV_StartBug> int dummy_rate = 0 ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + idx_str ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * prev_mi_8x8 = cm -> prev_mi_grid_visible + idx_str ; <S2SV_EndBug> <S2SV_StartBug> BLOCK_SIZE bsize ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( cpi -> mb . pred_mv ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( cpi -> sf . partition_search_type ) { <S2SV_EndBug> <S2SV_StartBug> choose_partitioning ( cpi , tile , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_EndBug> <S2SV_StartBug> 1 , & dummy_rate , & dummy_dist ) ; <S2SV_EndBug> <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; <S2SV_EndBug> <S2SV_StartBug> set_source_var_based_partition ( cpi , tile , mi_8x8 , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_EndBug> <S2SV_StartBug> 1 , & dummy_rate , & dummy_dist ) ; <S2SV_EndBug> <S2SV_StartBug> case VAR_BASED_FIXED_PARTITION : <S2SV_EndBug> <S2SV_StartBug> bsize = cpi -> sf . partition_search_type == FIXED_PARTITION ? <S2SV_EndBug> <S2SV_StartBug> set_fixed_partitioning ( cpi , tile , mi_8x8 , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_EndBug> <S2SV_StartBug> 1 , & dummy_rate , & dummy_dist ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . partition_check || sb_has_motion ( cm , prev_mi_8x8 ) ) { <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_partition ( cpi , tile , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_EndBug> <S2SV_StartBug> & dummy_rate , & dummy_dist , 1 , INT64_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> copy_partitioning ( cm , mi_8x8 , prev_mi_8x8 ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> BLOCK_64X64 , 1 , & dummy_rate , & dummy_dist ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , TileDataEnc * tile_data , int mi_row , TOKENEXTRA * * tp ) { SPEED_FEATURES * const sf = & cpi -> sf ; VP9_COMMON * const cm = & cpi -> common ; <S2SV_ModEnd> <S2SV_ModStart> tile_info = & tile_data -> tile_info ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; int mi_col ; memset ( & xd -> left_context , 0 , sizeof ( <S2SV_ModEnd> <S2SV_ModStart> ) ) ; memset ( xd -> left_seg_context <S2SV_ModStart> left_seg_context <S2SV_ModEnd> <S2SV_ModStart> tile_info <S2SV_ModEnd> <S2SV_ModStart> tile_info <S2SV_ModEnd> <S2SV_ModStart> const struct segmentation * const seg = & cm -> seg ; RD_COST dummy_rdc <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> PARTITION_SEARCH_TYPE partition_search_type = sf -> partition_search_type <S2SV_ModEnd> <S2SV_ModStart> = BLOCK_64X64 ; int seg_skip = 0 ; x -> <S2SV_ModEnd> <S2SV_ModStart> x -> <S2SV_ModEnd> <S2SV_ModStart> vp9_rd_cost_init ( & dummy_rdc ) ; x -> color_sensitivity [ 0 ] = 0 ; x -> color_sensitivity [ 1 ] = 0 ; if ( seg -> enabled ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; int segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ; seg_skip = segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ; if ( seg_skip ) { partition_search_type = FIXED_PARTITION ; } } switch ( <S2SV_ModEnd> <S2SV_ModStart> tile_info , x <S2SV_ModEnd> <S2SV_ModStart> td , tile_data , mi <S2SV_ModEnd> <S2SV_ModStart> BLOCK_64X64 , <S2SV_ModEnd> <S2SV_ModStart> dummy_rdc , td -> pc_root <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tile_info , x , mi <S2SV_ModEnd> <S2SV_ModStart> td , tile_data , mi <S2SV_ModEnd> <S2SV_ModStart> BLOCK_64X64 , <S2SV_ModEnd> <S2SV_ModStart> dummy_rdc , td -> pc_root <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! seg_skip ) bsize = sf -> always_this_block_size <S2SV_ModEnd> <S2SV_ModStart> tile_info , mi <S2SV_ModEnd> <S2SV_ModStart> td , tile_data , mi <S2SV_ModEnd> <S2SV_ModStart> BLOCK_64X64 , <S2SV_ModEnd> <S2SV_ModStart> dummy_rdc , td -> pc_root <S2SV_ModEnd> <S2SV_ModStart> set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; <S2SV_ModStart> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled && xd -> mi [ 0 ] -> mbmi . segment_id ) { if ( cm -> width <= 352 && cm -> height <= 288 ) x -> max_partition_size = BLOCK_32X32 ; else x -> max_partition_size = BLOCK_64X64 ; x -> min_partition_size = BLOCK_8X8 ; <S2SV_ModEnd> <S2SV_ModStart> td , tile_data <S2SV_ModEnd> <S2SV_ModStart> BLOCK_64X64 , & dummy_rdc <S2SV_ModEnd> <S2SV_ModStart> , td -> pc_root <S2SV_ModStart> choose_partitioning ( cpi , tile_info , x , mi_row , mi_col ) ; if ( cm -> frame_type == KEY_FRAME ) <S2SV_ModEnd> <S2SV_ModStart> td , tile_data , mi <S2SV_ModEnd> <S2SV_ModStart> dummy_rdc , td -> pc_root ) ; else nonrd_select_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rdc , td -> pc_root <S2SV_ModEnd> <S2SV_ModStart> break ; ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
580,CWE-416,"<S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> ,torvalds@linux/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,CVE-2019-11487,https://github.com/torvalds/linux/commit/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,2019-04-23T22:29Z
581,CWE-20,"<S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> ",<S2SV_ModStart> _dh <S2SV_ModEnd> ,torvalds@linux/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,CVE-2014-2523,https://github.com/torvalds/linux/commit/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,2014-03-24T16:40Z
582,CWE-284,"<S2SV_StartBug> Fp = fopen ( filename , ""wb"" ) ; <S2SV_EndBug> <S2SV_StartBug> return HTTP_UNAUTHORIZED ; <S2SV_EndBug> ",<S2SV_ModStart> # ifdef UPNP_ENABLE_POST_WRITE <S2SV_ModStart> # else return HTTP_NOT_FOUND ; # endif ,mjg59@pupnp-code/be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd,CVE-2016-6255,https://github.com/mjg59/pupnp-code/commit/be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd,2017-03-07T16:59Z
583,CWE-000,"<S2SV_StartBug> char * dir = ""/etc"" ; <S2SV_EndBug> <S2SV_StartBug> if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) { <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""/etc"" , "".vipw"" <S2SV_ModEnd> ",karelzak@util-linux/bde91c85bdc77975155058276f99d2e0f5eab5a9,CVE-2015-5224,https://github.com/karelzak/util-linux/commit/bde91c85bdc77975155058276f99d2e0f5eab5a9,2017-08-23T15:29Z
584,CWE-415,<S2SV_StartBug> if ( IS_ERR ( blkg ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/9b54d816e00425c3a517514e0d677bb3cec49258,CVE-2018-7480,https://github.com/torvalds/linux/commit/9b54d816e00425c3a517514e0d677bb3cec49258,2018-02-25T20:29Z
585,CWE-119,<S2SV_StartBug> if ( pixdepth == 1 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( pixdepth == 8 ) { <S2SV_EndBug> ,<S2SV_ModStart> bpp == 1 && <S2SV_ModStart> bpp == 8 && ,FFmpeg@FFmpeg/441026fcb13ac23aa10edc312bdacb6445a0ad06,CVE-2017-9991,https://github.com/FFmpeg/FFmpeg/commit/441026fcb13ac23aa10edc312bdacb6445a0ad06,2017-06-28T06:29Z
586,CWE-295,"<S2SV_StartBug> krb5_data rspac ; <S2SV_EndBug> <S2SV_StartBug> krbtgt_out , <S2SV_EndBug> ","<S2SV_ModStart> ; const char * tgt_realm = krb5_principal_get_realm ( context , krbtgt -> entry . principal ) <S2SV_ModStart> tgt_realm , ",heimdal@heimdal/b1e699103f08d6a0ca46a122193c9da65f6cf837,CVE-2017-6594,https://github.com/heimdal/heimdal/commit/b1e699103f08d6a0ca46a122193c9da65f6cf837,2017-08-28T19:29Z
587,CWE-20,"<S2SV_StartBug> cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ; <S2SV_EndBug> ",<S2SV_ModStart> nd -> last_type = LAST_BIND ; ,torvalds@linux/86acdca1b63e6890540fa19495cfc708beff3d8b,CVE-2014-0203,https://github.com/torvalds/linux/commit/86acdca1b63e6890540fa19495cfc708beff3d8b,2014-06-23T11:21Z
588,CWE-200,"<S2SV_StartBug> struct usbdevfs_connectinfo ci = { <S2SV_EndBug> <S2SV_StartBug> . devnum = ps -> dev -> devnum , <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> ","<S2SV_ModStart> ; memset ( & ci , 0 , sizeof ( ci ) ) ; ci <S2SV_ModEnd> <S2SV_ModStart> ; ci <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/681fef8380eb818c0b845fca5d2ab1dcbab114ee,CVE-2016-4482,https://github.com/torvalds/linux/commit/681fef8380eb818c0b845fca5d2ab1dcbab114ee,2016-05-23T10:59Z
589,CWE-362,"<S2SV_StartBug> static int ip_options_get_finish ( struct net * net , struct ip_options * * optp , <S2SV_EndBug> <S2SV_StartBug> struct ip_options * opt , int optlen ) <S2SV_EndBug> <S2SV_StartBug> opt -> __data [ optlen ++ ] = IPOPT_END ; <S2SV_EndBug> <S2SV_StartBug> opt -> optlen = optlen ; <S2SV_EndBug> <S2SV_StartBug> if ( optlen && ip_options_compile ( net , opt , NULL ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> & opt -> ,torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z
590,CWE-19,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( args -> rmtblkno ) { <S2SV_EndBug> ,<S2SV_ModStart> args -> rmtvaluelen2 = args -> rmtvaluelen ; args -> rmtblkno = 0 ; args -> rmtblkcnt = 0 ; args -> rmtvaluelen = 0 ; <S2SV_ModStart> args -> rmtvaluelen = args -> rmtvaluelen2 ; ,torvalds@linux/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,CVE-2015-0274,https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,2015-03-16T10:59Z
591,CWE-119,"<S2SV_StartBug> byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> offset . QuadPart = 0 ; <S2SV_EndBug> <S2SV_StartBug> sizeof ( readBuffer ) , <S2SV_EndBug> <S2SV_StartBug> if ( NT_SUCCESS ( ntStatus ) ) <S2SV_EndBug> <S2SV_StartBug> Irp -> IoStatus . Status = ntStatus ; <S2SV_EndBug> <S2SV_StartBug> Irp -> IoStatus . Information = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> size_t devicePathLen = 0 <S2SV_ModEnd> <S2SV_ModStart> if ( ! NT_SUCCESS ( RtlUnalignedStringCchLengthW ( request -> DevicePath , TC_MAX_PATH , & devicePathLen ) ) || ( devicePathLen < 28 ) || ( devicePathLen > 30 ) || ( memcmp ( request -> DevicePath , L""\\\\Device\\\\Harddisk"" , 16 * sizeof ( WCHAR ) ) ) || ( memcmp ( & request -> DevicePath [ devicePathLen - 11 ] , L""\\\\Partition0"" , 11 * sizeof ( WCHAR ) ) ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } <S2SV_ModStart> byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } else { <S2SV_ModStart> TC_MAX_VOLUME_SECTOR_SIZE <S2SV_ModEnd> <S2SV_ModStart> ) { if ( IoStatus . Information >= TC_SECTOR_SIZE_BIOS <S2SV_ModStart> STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } else { Irp -> IoStatus . Status = <S2SV_ModStart> ; } TCfree ( readBuffer ) ",veracrypt@VeraCrypt/f30f9339c9a0b9bbcc6f5ad38804af39db1f479e,CVE-2019-1010208,https://github.com/veracrypt/VeraCrypt/commit/f30f9339c9a0b9bbcc6f5ad38804af39db1f479e,2019-07-23T14:15Z
592,CWE-190,<S2SV_StartBug> if ( connection == NULL ) <S2SV_EndBug> ,<S2SV_ModStart> || strlen ( connection ) > UT_WS_SVR_MAX_HEADER_SIZE ,viabtc@viabtc_exchange_server/4a7c27bfe98f409623d4d857894d017ff0672cc9,CVE-2018-17568,https://github.com/viabtc/viabtc_exchange_server/commit/4a7c27bfe98f409623d4d857894d017ff0672cc9#diff-0c23effa84a7b85053bac7981a8580c8,2018-09-26T22:29Z
593,CWE-20,"<S2SV_StartBug> uint16 nif = 0 ; <S2SV_EndBug> <S2SV_StartBug> for ( d = alldevs ; d != NULL ; d = d -> next ) <S2SV_EndBug> <S2SV_StartBug> plen += strlen ( d -> description ) ; <S2SV_EndBug> <S2SV_StartBug> plen += strlen ( d -> name ) ; <S2SV_EndBug> <S2SV_StartBug> plen += sizeof ( struct rpcap_findalldevs_if ) ; <S2SV_EndBug> <S2SV_StartBug> plen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ; <S2SV_EndBug> <S2SV_StartBug> RPCAP_MSG_FINDALLIF_REPLY , nif , plen ) ; <S2SV_EndBug> ",<S2SV_ModStart> uint32 replylen ; <S2SV_ModStart> replylen = 0 ; <S2SV_ModStart> replylen <S2SV_ModEnd> <S2SV_ModStart> replylen <S2SV_ModEnd> <S2SV_ModStart> replylen <S2SV_ModEnd> <S2SV_ModStart> replylen <S2SV_ModEnd> <S2SV_ModStart> replylen <S2SV_ModEnd> ,the-tcpdump-group@libpcap/617b12c0339db4891d117b661982126c495439ea,CVE-2019-15161,https://github.com/the-tcpdump-group/libpcap/commit/617b12c0339db4891d117b661982126c495439ea,2019-10-03T19:15Z
594,CWE-200,"<S2SV_StartBug> struct dump_dir * dd = dd_create ( path , client_uid , DEFAULT_DUMP_DIR_MODE ) ; <S2SV_EndBug> ",<S2SV_ModStart> g_settings_privatereports ? 0 : ,abrt@abrt/8939398b82006ba1fec4ed491339fc075f43fc7c,CVE-2015-1870,https://github.com/abrt/abrt/commit/8939398b82006ba1fec4ed491339fc075f43fc7c,2017-06-26T15:29Z
595,CWE-787,<S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) <S2SV_EndBug> ,<S2SV_ModStart> 4 <S2SV_ModEnd> ,ImageMagick@ImageMagick/b6ae2f9e0ab13343c0281732d479757a8e8979c7,CVE-2016-7526,https://github.com/ImageMagick/ImageMagick/commit/b6ae2f9e0ab13343c0281732d479757a8e8979c7,2017-04-20T18:59Z
596,CWE-310,"<S2SV_StartBug> BN_ULONG t1 , t2 ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,openssl@openssl/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,CVE-2014-3570,https://github.com/openssl/openssl/commit/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,2015-01-09T02:59Z
597,CWE-125,<S2SV_StartBug> int tstype ) <S2SV_EndBug> <S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> serr -> ee . ee_info = tstype ; <S2SV_EndBug> ,"<S2SV_ModStart> , bool opt_stats <S2SV_ModStart> ; BUILD_BUG_ON ( sizeof ( struct sock_exterr_skb ) > sizeof ( skb -> cb ) ) <S2SV_ModStart> ; serr -> opt_stats = opt_stats ",torvalds@linux/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,CVE-2017-7277,https://github.com/torvalds/linux/commit/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,2017-03-28T06:59Z
598,CWE-119,"<S2SV_StartBug> if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue ) <S2SV_EndBug> ","<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } ",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z
599,CWE-125,"<S2SV_StartBug> if ( in_cksum ( vec , 1 ) ) <S2SV_EndBug> <S2SV_StartBug> EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> { ND_TCHECK_16BITS ( & bp [ 6 ] ) ; <S2SV_ModStart> } ,the-tcpdump-group@tcpdump/3de07c772166b7e8e8bb4b9d1d078f1d901b570b,CVE-2018-14463,https://github.com/the-tcpdump-group/tcpdump/commit/3de07c772166b7e8e8bb4b9d1d078f1d901b570b,2019-10-03T16:15Z
600,CWE-190,"<S2SV_StartBug> run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%2f?"" ) , CONST_STR_LEN ( ""/?"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2f?"" ) , CONST_STR_LEN ( ""//?"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ",lighttpd@lighttpd1.4/32120d5b8b3203fc21ccb9eafb0eaf824bb59354,CVE-2019-11072,https://github.com/lighttpd/lighttpd1.4/commit/32120d5b8b3203fc21ccb9eafb0eaf824bb59354,2019-04-10T22:29Z
601,CWE-264,"<S2SV_StartBug> if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) { <S2SV_EndBug> ",<S2SV_ModStart> dumpable != SUID_DUMP_USER && <S2SV_ModEnd> ,torvalds@linux/d049f74f2dbe71354d43d393ac3a188947811348,CVE-2013-2929,https://github.com/torvalds/linux/commit/d049f74f2dbe71354d43d393ac3a188947811348,2013-12-09T18:55Z
602,CWE-189,<S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( int ) ,FFmpeg@FFmpeg/86736f59d6a527d8bc807d09b93f971c0fe0bb07,CVE-2013-7014,https://github.com/FFmpeg/FFmpeg/commit/86736f59d6a527d8bc807d09b93f971c0fe0bb07,2013-12-09T16:36Z
603,CWE-200,<S2SV_StartBug> if ( flags & __GFP_ZERO ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/6829e274a623187c24f7cfc0e3d35f25d087fcc5,CVE-2015-8950,https://github.com/torvalds/linux/commit/6829e274a623187c24f7cfc0e3d35f25d087fcc5,2016-10-10T10:59Z
604,CWE-190,<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> int rowstep ; <S2SV_EndBug> ,<S2SV_ModStart> jas_matind_t i ; jas_matind_t <S2SV_ModEnd> <S2SV_ModStart> jas_matind_t <S2SV_ModEnd> ,mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
605,CWE-190,"<S2SV_StartBug> ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , <S2SV_EndBug> <S2SV_StartBug> u4_payload_size ) ; <S2SV_EndBug> <S2SV_StartBug> ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , <S2SV_EndBug> <S2SV_StartBug> u4_payload_size ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) { for ( i = 0 ; i < u4_payload_size / 4 ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ; } ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ; } else { <S2SV_ModStart> } <S2SV_ModStart> if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) { for ( i = 0 ; i < u4_payload_size / 4 ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ; } ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ; } else { <S2SV_ModStart> } ",external@libhevc/9f0fb67540d2259e4930d9bd5f1a1a6fb95af862,CVE-2018-9473,https://android.googlesource.com/platform/external/libhevc/+/9f0fb67540d2259e4930d9bd5f1a1a6fb95af862,2018-10-02T19:29Z
606,CWE-000,"<S2SV_StartBug> priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! port -> interrupt_out_urb || ! port -> interrupt_in_urb ) { dev_err ( & port -> dev , ""required<S2SV_blank>endpoint<S2SV_blank>is<S2SV_blank>missing\\n"" ) ; return - ENODEV ; } ",torvalds@linux/c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754,CVE-2016-3137,https://github.com/torvalds/linux/commit/c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754,2016-05-02T10:59Z
607,CWE-401,<S2SV_StartBug> if ( ret < 0 ) <S2SV_EndBug> <S2SV_StartBug> dd -> sdma_rht = tmp_sdma_rht ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree ( tmp_sdma_rht ) ; <S2SV_ModStart> } ,torvalds@linux/34b3be18a04ecdc610aae4c48e5d1b799d8689f6,CVE-2019-19065,https://github.com/torvalds/linux/commit/34b3be18a04ecdc610aae4c48e5d1b799d8689f6,2019-11-18T06:15Z
608,CWE-416,<S2SV_StartBug> put_device ( & dev -> dev ) ; <S2SV_EndBug> ,<S2SV_ModStart> cancel_autoload_drivers ( ) ; ,torvalds@linux/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57,CVE-2017-16528,https://github.com/torvalds/linux/commit/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57,2017-11-04T01:29Z
609,CWE-362,"<S2SV_StartBug> const char * name , int rep_quick ) <S2SV_EndBug> <S2SV_StartBug> mysql_file_close ( new_file , MYF ( 0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( param -> testflag & T_BACKUP_DATA ? <S2SV_EndBug> ","<S2SV_ModStart> , my_bool no_copy_stat <S2SV_ModStart> myf flags = 0 ; if ( param -> testflag & T_BACKUP_DATA ) flags |= MY_REDEL_MAKE_BACKUP ; if ( no_copy_stat ) flags |= MY_REDEL_NO_COPY_STAT ; <S2SV_ModStart> flags <S2SV_ModEnd> ",MariaDB@server/4e5473862e6852b0f3802b0cd0c6fa10b5253291,CVE-2016-6663,https://github.com/MariaDB/server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291,2016-12-13T21:59Z
610,CWE-000,<S2SV_StartBug> if ( p == q || size < 16 || size > 256 ) <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) || ( <S2SV_ModEnd> <S2SV_ModStart> ) || ( <S2SV_ModEnd> <S2SV_ModStart> ) ,ImageMagick@ImageMagick/0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734,CVE-2015-8896,https://github.com/ImageMagick/ImageMagick/commit/0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734,2017-03-15T19:59Z
611,CWE-19,"<S2SV_StartBug> uint dblocks = XFS_B_TO_FSB ( mp , valuelen ) ; <S2SV_EndBug> ",<S2SV_ModStart> xfs_attr3_rmt_blocks <S2SV_ModEnd> ,torvalds@linux/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,CVE-2015-0274,https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,2015-03-16T10:59Z
612,CWE-189,<S2SV_StartBug> pairs = palloc ( pcount * sizeof ( Pairs ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( pcount < 0 || pcount > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , pcount , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ; ",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z
613,CWE-476,"<S2SV_StartBug> ruleaddvar ( r , var , val ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( ! val ) continue ,michaelforney@samurai/d2af3bc375e2a77139c3a28d6128c60cd8d08655,CVE-2021-30219,https://github.com/michaelforney/samurai/commit/d2af3bc375e2a77139c3a28d6128c60cd8d08655,2021-04-29T15:15Z
614,CWE-476,<S2SV_StartBug> if ( text [ 1 ] == EOF ) <S2SV_EndBug> <S2SV_StartBug> if ( text [ 2 ] == EOF ) <S2SV_EndBug> <S2SV_StartBug> if ( text [ 3 ] == EOF ) <S2SV_EndBug> ,<S2SV_ModStart> || text [ 1 ] == 0 <S2SV_ModStart> ! isxdigit ( <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> ! isxdigit ( <S2SV_ModStart> ) <S2SV_ModEnd> ,VirusTotal@yara/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,CVE-2016-10210,https://github.com/VirusTotal/yara/commit/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,2017-04-03T05:59Z
615,CWE-444,<S2SV_StartBug> c -> req -> path . start = c -> req -> msg + ( path . start - c -> buf ) ; <S2SV_EndBug> ,"<S2SV_ModStart> memcpy ( c -> req -> remote , c -> remote , sizeof ( c -> remote ) ) ; ",ohler55@agoo/23d03535cf7b50d679a60a953a0cae9519a4a130,CVE-2020-7670,https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130,2020-06-10T16:15Z
616,CWE-119,"<S2SV_StartBug> void vp9_fht16x16_c ( const int16_t * input , int16_t * output , <S2SV_EndBug> <S2SV_StartBug> vp9_fdct16x16_c ( input , output , stride ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t out [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = & out [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t temp_in [ 16 ] , temp_out [ 16 ] ; <S2SV_EndBug> <S2SV_StartBug> outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_fdct16x16_c <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
617,CWE-74,"<S2SV_StartBug> g_print ( _ ( ""Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\n"" ) , arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> { flatpak_fail_error ( error , FLATPAK_ERROR_EXPORT_FAILED , _ ( ""Invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s"" <S2SV_ModEnd> <S2SV_ModStart> goto out ; } ",flatpak@flatpak/a7401e638bf0c03102039e216ab1081922f140ae,CVE-2021-21381,https://github.com/flatpak/flatpak/commit/a7401e638bf0c03102039e216ab1081922f140ae,2021-03-11T17:15Z
618,CWE-284,"<S2SV_StartBug> if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> goto out_errno ; <S2SV_EndBug> <S2SV_StartBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_default , <S2SV_EndBug> ","<S2SV_ModStart> error = fh_want_write ( fh ) ; if ( error ) <S2SV_ModEnd> <S2SV_ModStart> fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access <S2SV_ModEnd> <S2SV_ModStart> out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT <S2SV_ModEnd> <S2SV_ModStart> ) ; out_drop_lock : fh_unlock ( fh ) ; <S2SV_ModEnd> ",torvalds@linux/999653786df6954a31044528ac3f7a5dadca08f4,CVE-2016-1237,https://github.com/torvalds/linux/commit/999653786df6954a31044528ac3f7a5dadca08f4,2016-06-29T14:10Z
619,CWE-125,<S2SV_StartBug> BUG_IF ( tree_root == NULL ) ; <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> return 0 ,LocutusOfBorg@ettercap/626dc56686f15f2dda13c48f78c2a666cb6d8506,CVE-2017-6430,https://github.com/LocutusOfBorg/ettercap/commit/626dc56686f15f2dda13c48f78c2a666cb6d8506,2017-03-15T15:59Z
620,CWE-284,"<S2SV_StartBug> char * temp_filename = osi_calloc ( strlen ( filename ) + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! temp_filename ) { <S2SV_EndBug> <S2SV_StartBug> fprintf ( fp , ""[%s]\\n"" , section -> name ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( fp , ""%s<S2SV_blank>=<S2SV_blank>%s\\n"" , entry -> key , entry -> value ) ; <S2SV_EndBug> <S2SV_StartBug> fputc ( '\\n' , fp ) ; <S2SV_EndBug> <S2SV_StartBug> fclose ( fp ) ; <S2SV_EndBug> <S2SV_StartBug> osi_free ( temp_filename ) ; <S2SV_EndBug> <S2SV_StartBug> error : ; <S2SV_EndBug> <S2SV_StartBug> osi_free ( temp_filename ) ; <S2SV_EndBug> ","<S2SV_ModStart> int dir_fd = - 1 ; FILE * fp = NULL ; static const char * temp_file_ext = "".new"" ; const int filename_len = strlen ( filename ) ; const int temp_filename_len = filename_len + strlen ( temp_file_ext ) + 1 ; char * <S2SV_ModEnd> <S2SV_ModStart> temp_filename_len ) ; snprintf ( temp_filename , temp_filename_len , ""%s%s"" , filename , temp_file_ext ) ; char * temp_dirname = osi_strdup ( filename ) ; const char * directoryname = dirname ( temp_dirname <S2SV_ModEnd> <S2SV_ModStart> directoryname ) { LOG_ERROR ( ""%s<S2SV_blank>error<S2SV_blank>extracting<S2SV_blank>directory<S2SV_blank>from<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , filename , strerror ( errno ) ) ; goto error ; } dir_fd = TEMP_FAILURE_RETRY ( open ( directoryname , O_RDONLY ) ) ; if ( dir_fd < 0 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModStart> < 0 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModStart> < 0 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> <S2SV_ModStart> { if ( <S2SV_ModStart> == EOF ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } } } if ( fsync ( fileno ( fp ) ) < 0 ) { LOG_WARN ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>fsync<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; } if ( <S2SV_ModEnd> <S2SV_ModStart> == EOF ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>close<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } fp = NULL <S2SV_ModStart> if ( fsync ( dir_fd ) < 0 ) { LOG_WARN ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>fsync<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ; } if ( close ( dir_fd ) < 0 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>close<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ; goto error ; } <S2SV_ModStart> ) ; osi_free ( temp_dirname <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( fp ) fclose ( fp ) ; if ( dir_fd != - 1 ) close ( dir_fd ) ; <S2SV_ModStart> ) ; osi_free ( temp_dirname ",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
621,CWE-000,<S2SV_StartBug> switch ( pc -> componentType ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case 5 : <S2SV_EndBug> <S2SV_StartBug> elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ; <S2SV_EndBug> ,<S2SV_ModStart> elen += sizeof ( struct pathComponent ) ; <S2SV_ModStart> { elen += pc -> lengthComponentIdent ; break ; } <S2SV_ModEnd> <S2SV_ModStart> elen += pc -> lengthComponentIdent ; if ( elen > fromlen ) return - EIO ; <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/e237ec37ec154564f8690c5bd1795339955eeef9,CVE-2014-9730,https://github.com/torvalds/linux/commit/e237ec37ec154564f8690c5bd1795339955eeef9,2015-08-31T10:59Z
622,CWE-125,<S2SV_StartBug> ND_TCHECK ( dp [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> dp += 3 ; <S2SV_EndBug> ,"<S2SV_ModStart> 4 <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 3 ] <S2SV_ModEnd> ",the-tcpdump-group@tcpdump/19d25dd8781620cd41bf178a5e2e27fc1cf242d0,CVE-2017-12898,https://github.com/the-tcpdump-group/tcpdump/commit/19d25dd8781620cd41bf178a5e2e27fc1cf242d0,2017-09-14T06:29Z
623,CWE-125,"<S2SV_StartBug> ND_TCHECK ( * vtp_vlan ) ; <S2SV_EndBug> <S2SV_StartBug> fn_printzp ( ndo , tptr + VTP_VLAN_INFO_OFFSET , vtp_vlan -> name_len , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; <S2SV_EndBug> <S2SV_StartBug> tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; <S2SV_EndBug> <S2SV_StartBug> type = * tptr ; <S2SV_EndBug> <S2SV_StartBug> if ( type == 0 || tlv_len == 0 ) { <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> len -= 2 + tlv_len * 2 ; <S2SV_EndBug> ","<S2SV_ModStart> if ( len < VTP_VLAN_INFO_FIXED_PART_LEN ) goto trunc ; <S2SV_ModStart> len -= VTP_VLAN_INFO_FIXED_PART_LEN ; tptr += VTP_VLAN_INFO_FIXED_PART_LEN ; if ( len < 4 * ( ( <S2SV_ModEnd> <S2SV_ModStart> + 3 ) / 4 ) ) goto trunc ; ND_TCHECK2 ( * tptr , <S2SV_ModEnd> <S2SV_ModStart> ) ; fn_printzp ( ndo , tptr , <S2SV_ModEnd> <S2SV_ModStart> , NULL ) ; len -= 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; tptr += 4 * ( ( vtp_vlan -> name_len <S2SV_ModStart> if ( len < 2 ) goto trunc ; ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> len < tlv_len * 2 + 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(TLV<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>packet)"" ) ) ; <S2SV_ModEnd> <S2SV_ModStart> if ( tlv_len != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>TLV<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>1)"" , tlv_len ) ) ; return ; } else { <S2SV_ModStart> } ",the-tcpdump-group@tcpdump/ae83295915d08a854de27a88efac5dd7353e6d3f,CVE-2017-13033,https://github.com/the-tcpdump-group/tcpdump/commit/ae83295915d08a854de27a88efac5dd7353e6d3f,2017-09-14T06:29Z
624,CWE-000,"<S2SV_StartBug> target , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> ctxt -> instate = state ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ctxt -> instate != XML_PARSER_EOF ) <S2SV_ModStart> if ( <S2SV_ModStart> != XML_PARSER_EOF ) ctxt -> instate ,chromium@chromium/44a637b47793512bfb1d2589d43b8dc492a97629,,https://github.com/chromium/chromium/commit/44a637b47793512bfb1d2589d43b8dc492a97629,
625,CWE-200,<S2SV_StartBug> bool slow ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * addr_len = sizeof ( * sin ) ; ,torvalds@linux/bceaa90240b6019ed73b49965eac7d167610be69,CVE-2013-7281,https://github.com/torvalds/linux/commit/bceaa90240b6019ed73b49965eac7d167610be69,2014-01-08T16:55Z
626,CWE-125,"<S2SV_StartBug> u_int tlen , pdu_type , pdu_len ; <S2SV_EndBug> <S2SV_StartBug> while ( tlen >= sizeof ( rpki_rtr_pdu ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( rpki_rtr_pdu_print ( ndo , tptr , 8 ) ) <S2SV_EndBug> <S2SV_StartBug> tptr += pdu_len ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> len ) { u_int pdu_len = <S2SV_ModEnd> <S2SV_ModStart> pptr , len , 1 <S2SV_ModEnd> <S2SV_ModStart> ; len <S2SV_ModEnd> <S2SV_ModStart> pptr <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",the-tcpdump-group@tcpdump/83c64fce3a5226b080e535f5131a8a318f30e79b,CVE-2017-13050,https://github.com/the-tcpdump-group/tcpdump/commit/83c64fce3a5226b080e535f5131a8a318f30e79b,2017-09-14T06:29Z
627,CWE-119,"<S2SV_StartBug> s = tcp_recv ( NULL , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ber_in_header ( s , & tagval , & length ) || <S2SV_EndBug> <S2SV_StartBug> in_uint8s ( s , length ) ; <S2SV_EndBug> <S2SV_StartBug> token -> end = token -> p = token -> data ; <S2SV_EndBug> ","<S2SV_ModStart> struct stream packet ; <S2SV_ModStart> packet = * s ; <S2SV_ModStart> if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>version<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } <S2SV_ModStart> if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>token<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } s_realloc ( token , length ) ; s_reset ( token ) <S2SV_ModEnd> ",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-20182,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-03-15T18:29Z
628,CWE-835,<S2SV_StartBug> int chars_processed ; <S2SV_EndBug> <S2SV_StartBug> int data_size = ndo -> ndo_snapend - bp ; <S2SV_EndBug> <S2SV_StartBug> chars_processed = 1 ; <S2SV_EndBug> <S2SV_StartBug> cp = bp + ( ( ( i << 8 ) | * cp ) & 0x3fff ) ; <S2SV_EndBug> <S2SV_StartBug> chars_processed ++ ; <S2SV_EndBug> <S2SV_StartBug> chars_processed += l ; <S2SV_EndBug> <S2SV_StartBug> chars_processed ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> elt ; u_int offset , max_offset ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; max_offset = ( u_int ) ( cp - bp ) ; if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) { compress = 0 ; rp = cp + l ; } if ( i != 0 ) while ( i && cp < <S2SV_ModEnd> <S2SV_ModStart> ) { if ( ( i & INDIR_MASK ) == INDIR_MASK ) { if ( ! compress ) { rp = cp + 1 ; compress = 1 ; } <S2SV_ModEnd> <S2SV_ModStart> offset = ( ( ( i << 8 ) | * cp ) & 0x3fff ) ; if ( offset >= max_offset ) { ND_PRINT ( ( ndo , ""<BAD<S2SV_blank>PTR>"" ) ) ; return ( NULL ) ; } max_offset = offset ; cp = bp + offset ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",the-tcpdump-group@tcpdump/3a76fd7c95fced2c2f8c8148a9055c3a542eff29,CVE-2017-12995,https://github.com/the-tcpdump-group/tcpdump/commit/3a76fd7c95fced2c2f8c8148a9055c3a542eff29,2017-09-14T06:29Z
629,CWE-19,"<S2SV_StartBug> blkcnt = xfs_attr3_rmt_blocks ( mp , args -> valuelen ) ; <S2SV_EndBug> <S2SV_StartBug> valuelen = args -> valuelen ; <S2SV_EndBug> ",<S2SV_ModStart> rmtvaluelen <S2SV_ModEnd> <S2SV_ModStart> rmtvaluelen <S2SV_ModEnd> ,torvalds@linux/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,CVE-2015-0274,https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,2015-03-16T10:59Z
630,CWE-352,"<S2SV_StartBug> int rv = Socket_print ( S , <S2SV_EndBug> <S2SV_StartBug> ""Content-Length:<S2SV_blank>%d\\r\\n"" <S2SV_EndBug> <S2SV_StartBug> request , <S2SV_EndBug> ","<S2SV_ModStart> MD_T token ; StringBuffer_append ( data , ""%ssecuritytoken=%s"" , StringBuffer_length ( data ) > 0 ? ""&"" : """" , Util_getToken ( token ) ) ; <S2SV_ModStart> ""Cookie:<S2SV_blank>securitytoken=%s\\r\\n"" <S2SV_ModStart> , token ",tildeslash@monit/c6ec3820e627f85417053e6336de2987f2d863e3,CVE-2016-7067,https://bitbucket.org/tildeslash/monit/commit/c6ec3820e627f85417053e6336de2987f2d863e3,2018-09-10T14:29Z
631,CWE-269,"<S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> <S2SV_StartBug> int rv = copy_file ( src , dest ) ; <S2SV_EndBug> <S2SV_StartBug> if ( chown ( dest , getuid ( ) , getgid ( ) ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( chmod ( dest , S_IRUSR | S_IWUSR ) < 0 ) <S2SV_EndBug> ","<S2SV_ModStart> copy_file_as_user <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; fs_logger2 ( ""clone"" , dest <S2SV_ModEnd> ",netblue30@firejail/903fd8a0789ca3cc3c21d84cd0282481515592ef,CVE-2017-5940,https://github.com/netblue30/firejail/commit/903fd8a0789ca3cc3c21d84cd0282481515592ef,2017-02-09T18:59Z
632,CWE-401,<S2SV_StartBug> if ( rc != BFA_STATUS_OK ) <S2SV_EndBug> <S2SV_StartBug> wait_for_completion ( & fcomp . comp ) ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree ( fcstats ) ; <S2SV_ModStart> } ,torvalds@linux/0e62395da2bd5166d7c9e14cbc7503b256a34cb0,CVE-2019-19066,https://github.com/torvalds/linux/commit/0e62395da2bd5166d7c9e14cbc7503b256a34cb0,2019-11-18T06:15Z
633,CWE-20,"<S2SV_StartBug> value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> MagickMax <S2SV_ModEnd> <S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> MagickMax <S2SV_ModEnd> <S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> MagickMax <S2SV_ModEnd> ,ImageMagick@ImageMagick/d7325bac173492b358417a0ad49fabad44447d52,CVE-2014-9907,https://github.com/ImageMagick/ImageMagick/commit/d7325bac173492b358417a0ad49fabad44447d52,2017-04-19T14:59Z
634,CWE-476,<S2SV_StartBug> * head = NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> giterr_set_str ( GITERR_NET , ""Invalid<S2SV_blank>empty<S2SV_blank>packet"" ) ; return GIT_ERROR <S2SV_ModEnd> ",libgit2@libgit2/84d30d569ada986f3eef527cbdb932643c2dd037,CVE-2016-10129,https://github.com/libgit2/libgit2/commit/84d30d569ada986f3eef527cbdb932643c2dd037,2017-03-24T15:59Z
635,CWE-20,"<S2SV_StartBug> if ( check_stack_guard_page ( vma , address ) < 0 ) <S2SV_EndBug> ",<S2SV_ModStart> vma -> vm_flags & VM_SHARED ) return VM_FAULT_SIGBUS ; if ( ,torvalds@linux/6b7339f4c31ad69c8e9c0b2859276e22cf72176d,CVE-2015-3288,https://github.com/torvalds/linux/commit/6b7339f4c31ad69c8e9c0b2859276e22cf72176d,2016-10-16T21:59Z
636,CWE-416,<S2SV_StartBug> rec -> sasl_username = src -> sasl_username ; <S2SV_EndBug> <S2SV_StartBug> rec -> sasl_password = src -> sasl_password ; <S2SV_EndBug> ,<S2SV_ModStart> g_strdup ( <S2SV_ModStart> ) <S2SV_ModStart> g_strdup ( <S2SV_ModStart> ) ,irssi@irssi/d23b0d22cc611e43c88d99192a59f413f951a955,CVE-2019-13045,https://github.com/irssi/irssi/commit/d23b0d22cc611e43c88d99192a59f413f951a955,2019-06-29T14:15Z
637,CWE-20,"<S2SV_StartBug> struct bpf_insn_aux_data * new_data , * old_data = env -> insn_aux_data ; <S2SV_EndBug> <S2SV_StartBug> env -> insn_aux_data = new_data ; <S2SV_EndBug> ",<S2SV_ModStart> ; int i <S2SV_ModStart> for ( i = off ; i < off + cnt - 1 ; i ++ ) new_data [ i ] . seen = true ; ,torvalds@linux/c131187db2d3fa2f8bf32fdf4e9a4ef805168467,CVE-2017-17862,https://github.com/torvalds/linux/commit/c131187db2d3fa2f8bf32fdf4e9a4ef805168467,2017-12-27T17:08Z
638,CWE-125,<S2SV_StartBug> ND_TCHECK ( dp -> ip6f_offlg ) ; <S2SV_EndBug> ,<S2SV_ModStart> * dp <S2SV_ModEnd> ,the-tcpdump-group@tcpdump/2d669862df7cd17f539129049f6fb70d17174125,CVE-2017-13031,https://github.com/the-tcpdump-group/tcpdump/commit/2d669862df7cd17f539129049f6fb70d17174125,2017-09-14T06:29Z
639,CWE-125,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>%u)"" , <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ,the-tcpdump-group@tcpdump/b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00,CVE-2017-13023,https://github.com/the-tcpdump-group/tcpdump/commit/b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00,2017-09-14T06:29Z
640,CWE-119,"<S2SV_StartBug> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
641,CWE-119,"<S2SV_StartBug> assert ( ( occ0 % rowsize ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> ( * sp -> decodepfunc ) ( tif , op0 , rowsize ) ; <S2SV_EndBug> ","<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""PredictorDecodeTile"" , ""%s"" , ""occ0%rowsize<S2SV_blank>!=<S2SV_blank>0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> if ( ! <S2SV_ModStart> ) return 0 ",vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1,CVE-2016-9535,https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1,2016-11-22T19:59Z
642,CWE-400,"<S2SV_StartBug> size_t i , tcount , o , datao ; <S2SV_EndBug> <S2SV_StartBug> ++ tcount ; <S2SV_EndBug> ","<S2SV_ModStart> ; long failsafe_size = 0 <S2SV_ModStart> failsafe_size += mnote_canon_entry_count_values ( & n -> entries [ tcount ] ) ; if ( failsafe_size > FAILSAFE_SIZE_MAX ) { exif_mem_free ( ne -> mem , n -> entries [ tcount ] . data ) ; exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Failsafe<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>(%lu<S2SV_blank>><S2SV_blank>%ld)"" , failsafe_size , FAILSAFE_SIZE_MAX ) ; break ; } ",libexif@libexif/e6a38a1a23ba94d139b1fa2cd4519fdcfe3c9bab,CVE-2020-13114,https://github.com/libexif/libexif/commit/e6a38a1a23ba94d139b1fa2cd4519fdcfe3c9bab,2020-05-21T16:15Z
643,CWE-000,<S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug> ,<S2SV_ModStart> ctx -> terminated || ,krb5@krb5/82dc33da50338ac84c7b4102dc6513d897d0506a,CVE-2014-5352,https://github.com/krb5/krb5/commit/82dc33da50338ac84c7b4102dc6513d897d0506a,2015-02-19T11:59Z
644,CWE-399,<S2SV_StartBug> kfree ( sbi ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sbi -> spool ) hugepage_put_subpool ( sbi -> spool ) ; ,torvalds@linux/90481622d75715bfcb68501280a917dbfe516029,CVE-2012-2133,https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029,2012-07-03T16:40Z
645,CWE-362,"<S2SV_StartBug> error = mi_repair_by_sort ( param , info , filename , rep_quick ) ; <S2SV_EndBug> <S2SV_StartBug> error = mi_repair_parallel ( param , info , filename , rep_quick ) ; <S2SV_EndBug> <S2SV_StartBug> error = mi_repair ( param , info , filename , rep_quick ) ; <S2SV_EndBug> <S2SV_StartBug> error = mi_repair_by_sort ( param , info , filename , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> error = mi_sort_index ( param , info , filename ) ; <S2SV_EndBug> ","<S2SV_ModStart> , FALSE <S2SV_ModStart> , FALSE <S2SV_ModStart> , FALSE <S2SV_ModStart> , FALSE <S2SV_ModStart> , FALSE ",MariaDB@server/4e5473862e6852b0f3802b0cd0c6fa10b5253291,CVE-2016-6663,https://github.com/MariaDB/server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291,2016-12-13T21:59Z
646,CWE-89,"<S2SV_StartBug> int alloc = ( length ? length : ( int ) strlen ( string ) ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> CURLcode res ; <S2SV_EndBug> <S2SV_StartBug> res = Curl_convert_from_network ( handle , & in , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( res ) { <S2SV_EndBug> <S2SV_StartBug> * olen = strindex ; <S2SV_EndBug> ","<S2SV_ModStart> char * str = NULL ; size_t inputlen = length ; size_t outputlen <S2SV_ModEnd> <S2SV_ModStart> = Curl_urldecode <S2SV_ModEnd> <S2SV_ModStart> string , inputlen , & str , & outputlen , FALSE <S2SV_ModEnd> <S2SV_ModStart> return NULL <S2SV_ModEnd> <S2SV_ModStart> curlx_uztosi ( outputlen ) ; return str <S2SV_ModEnd> ",bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238,CVE-2012-0036,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,2012-04-13T20:55Z
647,CWE-416,<S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> ,<S2SV_ModStart> = { 0 } ,radare@radare2/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,CVE-2018-11383,https://github.com/radare/radare2/commit/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,2018-05-22T19:29Z
648,CWE-20,"<S2SV_StartBug> if ( unlikely ( copied == 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> iov_iter_advance ( i , copied ) ; <S2SV_EndBug> ","<S2SV_ModStart> iov_iter_advance ( i , copied ) ; <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/124d3b7041f9a0ca7c43a6293e1cae4576c32fd5,CVE-2008-7316,https://github.com/torvalds/linux/commit/124d3b7041f9a0ca7c43a6293e1cae4576c32fd5,2016-05-02T10:59Z
649,CWE-119,<S2SV_StartBug> if ( unlikely ( len > ring -> rx_buffersize ) ) { <S2SV_EndBug> ,<S2SV_ModStart> + ring -> frameoffset ,torvalds@linux/c85ce65ecac078ab1a1835c87c4a6319cf74660a,CVE-2011-3359,https://github.com/torvalds/linux/commit/c85ce65ecac078ab1a1835c87c4a6319cf74660a,2012-05-24T23:55Z
650,CWE-415,<S2SV_StartBug> def -> pdu_free_state_ref = usm_free_usmStateReference ; <S2SV_EndBug> ,<S2SV_ModStart> pdu_clone = usm_clone ; def -> ,net-snmp@net-snmp/5f881d3bf24599b90d67a45cae7a3eb099cd71c9,CVE-2019-20892,https://github.com/net-snmp/net-snmp/commit/5f881d3bf24599b90d67a45cae7a3eb099cd71c9,2020-06-25T10:15Z
651,CWE-119,"<S2SV_StartBug> show_object ( obj , NULL , name , data ) ; <S2SV_EndBug> <S2SV_StartBug> NULL , path , data ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> & base <S2SV_ModEnd> ,git@git/de1e67d0703894cb6ea782e36abb63976ab07e60,CVE-2016-2324,https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60,2016-04-08T14:59Z
652,CWE-674,"<S2SV_StartBug> return ! match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , 0 ",ccxvii@mujs/00d4606c3baf813b7b1c176823b2729bf51002a2,CVE-2019-11413,https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2,2019-04-22T11:29Z
653,CWE-119,<S2SV_StartBug> if ( src_end - src < zsize ) <S2SV_EndBug> <S2SV_StartBug> bitbuf = * src ++ ; <S2SV_EndBug> ,<S2SV_ModStart> + ( sub_type != 2 ) <S2SV_ModStart> if ( src >= src_end ) return AVERROR_INVALIDDATA ; ,FFmpeg@FFmpeg/2960576378d17d71cc8dccc926352ce568b5eec1,CVE-2013-4264,https://github.com/FFmpeg/FFmpeg/commit/2960576378d17d71cc8dccc926352ce568b5eec1,2013-11-23T17:55Z
654,CWE-119,<S2SV_StartBug> drop_futex_key_refs ( & q -> key ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/7ada876a8703f23befbb20a7465a702ee39b1704,CVE-2014-0205,https://github.com/torvalds/linux/commit/7ada876a8703f23befbb20a7465a702ee39b1704,2014-09-28T19:55Z
655,CWE-269,<S2SV_StartBug> # ifndef NETSNMP_NO_WRITE_SUPPORT <S2SV_EndBug> ,<S2SV_ModStart> if ! defined ( NETSNMP_NO_WRITE_SUPPORT ) && ENABLE_EXTEND_WRITE_ACCESS <S2SV_ModEnd> ,net-snmp@net-snmp/77f6c60f57dba0aaea5d8ef1dd94bcd0c8e6d205,CVE-2020-15862,https://github.com/net-snmp/net-snmp/commit/77f6c60f57dba0aaea5d8ef1dd94bcd0c8e6d205,2020-08-20T01:17Z
656,CWE-125,<S2SV_StartBug> switch ( depth ) <S2SV_EndBug> <S2SV_StartBug> CheckNumberCompactPixels ; <S2SV_EndBug> ,<S2SV_ModStart> CheckNumberCompactPixels ; <S2SV_ModStart>  <S2SV_ModEnd> ,ImageMagick@ImageMagick/30eec879c8b446b0ea9a3bb0da1a441cc8482bc4,CVE-2016-7521,https://github.com/ImageMagick/ImageMagick/commit/30eec879c8b446b0ea9a3bb0da1a441cc8482bc4,2017-04-20T18:59Z
657,CWE-20,"<S2SV_StartBug> list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , <S2SV_EndBug> <S2SV_StartBug> spin_lock_irq ( & slave_active_lock ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irq ( & slave_active_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> spin_lock_irq ( & slave_active_lock ) ; spin_lock ( & timer -> lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> list_del_init ( & slave -> ack_list ) ; list_del_init ( & slave -> active_list ) ; } spin_unlock ( & timer -> lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/b5a663aa426f4884c71cd8580adae73f33570f0d,CVE-2016-2548,https://github.com/torvalds/linux/commit/b5a663aa426f4884c71cd8580adae73f33570f0d,2016-04-27T17:59Z
658,CWE-125,"<S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK ( p [ 2 ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ,the-tcpdump-group@tcpdump/7029d15f148ef24bb7c6668bc640f5470d085e5a,CVE-2017-13029,https://github.com/the-tcpdump-group/tcpdump/commit/7029d15f148ef24bb7c6668bc640f5470d085e5a,2017-09-14T06:29Z
659,CWE-416,"<S2SV_StartBug> const char * arch = info -> arch ; <S2SV_EndBug> <S2SV_StartBug> if ( info -> cpu && * info -> cpu ) { <S2SV_EndBug> <S2SV_StartBug> r_config_set ( r -> config , ""anal.cpu"" , info -> cpu ) ; <S2SV_EndBug> <S2SV_StartBug> r_core_bin_set_cur ( r , binfile ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strdup ( info -> arch ) ; char * cpu = info -> cpu ? strdup ( info -> cpu ) : NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; free ( cpu ) ; free ( arch ,radare@radare2/f85bc674b2a2256a364fe796351bc1971e106005,CVE-2017-9520,https://github.com/radare/radare2/commit/f85bc674b2a2256a364fe796351bc1971e106005,2017-06-08T14:29Z
660,CWE-000,"<S2SV_StartBug> static void sas_probe_devices ( struct work_struct * work ) <S2SV_EndBug> <S2SV_StartBug> struct domain_device * dev , * n ; <S2SV_EndBug> ",<S2SV_ModStart> asd_sas_port * port <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/0558f33c06bb910e2879e355192227a8e8f0219d,CVE-2017-18232,https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d,2018-03-15T04:29Z
661,CWE-119,<S2SV_StartBug> ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( <S2SV_EndBug> ,<S2SV_ModStart> { i_temp = ih264d_read_mmco_commands ( ps_dec ) ; if ( i_temp < 0 ) { return ERROR_DBP_MANAGER_T ; } <S2SV_ModStart> i_temp ; } <S2SV_ModEnd> ,external@libavc/943323f1d9d3dd5c2634deb26cbe72343ca6b3db,CVE-2016-0842,https://android.googlesource.com/platform/external/libavc/+/943323f1d9d3dd5c2634deb26cbe72343ca6b3db,2016-04-18T00:59Z
662,CWE-20,"<S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> char line [ NETSCREEN_LINE_LENGTH ] ; <S2SV_EndBug> <S2SV_StartBug> pkt_len = parse_netscreen_rec_hdr ( & wth -> phdr , line , cap_int , & cap_dir , <S2SV_EndBug> <S2SV_StartBug> if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int , <S2SV_EndBug> <S2SV_StartBug> cap_dst , & wth -> phdr , wth -> frame_buffer , err , err_info ) ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> parse_netscreen_packet <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , line ",wireshark@wireshark/6a140eca7b78b230f1f90a739a32257476513c78,CVE-2016-5357,https://github.com/wireshark/wireshark/commit/6a140eca7b78b230f1f90a739a32257476513c78,2016-08-07T16:59Z
663,CWE-119,"<S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> processed_rcds ) , <S2SV_EndBug> <S2SV_StartBug> s -> s3 -> rrec . seq_num ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( <S2SV_ModStart> < 0 ) return - 1 ,openssl@openssl/103b171d8fc282ef435f8de9afbf7782e312961f,CVE-2015-0206,https://github.com/openssl/openssl/commit/103b171d8fc282ef435f8de9afbf7782e312961f,2015-01-09T02:59Z
664,CWE-415,<S2SV_StartBug> int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ; <S2SV_EndBug> <S2SV_StartBug> const uint_fast32_t newRasterSize = gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( newRasterSize == 0 ) { free ( info -> rasterBits ) ; info -> rasterBits = NULL ; info -> rasterSize = newRasterSize ; return ; } const int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ; const int_fast32_t heightOverflow = gifFilePtr -> Image . Height - info -> originalHeight ,koral--@android-gif-drawable/cc5b4f8e43463995a84efd594f89a21f906c2d20,CVE-2019-11932,https://github.com/koral--/android-gif-drawable/commit/cc5b4f8e43463995a84efd594f89a21f906c2d20,2019-10-03T22:15Z
665,CWE-362,"<S2SV_StartBug> ret = key_validate ( key ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( key -> type -> read ) { <S2SV_EndBug> <S2SV_StartBug> ret = key -> type -> read ( key , buffer , buflen ) ; <S2SV_EndBug> ","<S2SV_ModStart> - EOPNOTSUPP ; if ( key -> type -> read ) { down_read ( & key -> sem ) ; ret = <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> ( key , buffer , buflen ) ; up_read <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/b4a1b4f5047e4f54e194681125c74c0aa64d637d,CVE-2015-7550,https://github.com/torvalds/linux/commit/b4a1b4f5047e4f54e194681125c74c0aa64d637d,2016-02-08T03:59Z
666,CWE-287,<S2SV_StartBug> cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <S2SV_EndBug> ,<S2SV_ModStart> || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ,cherokee@webserver/fbda667221c51f0aa476a02366e0cf66cb012f88,CVE-2014-4668,https://github.com/cherokee/webserver/commit/fbda667221c51f0aa476a02366e0cf66cb012f88,2014-07-02T04:14Z
667,CWE-252,"<S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> != c ) break ,ImageMagick@ImageMagick/6b6bff054d569a77973f2140c0e86366e6168a6c,CVE-2018-16643,https://github.com/ImageMagick/ImageMagick/commit/6b6bff054d569a77973f2140c0e86366e6168a6c,2018-09-06T22:29Z
668,CWE-190,"<S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> <S2SV_StartBug> * val = ( tmp & 0x80000000 ) ? ( - JAS_CAST ( longlong , ( ( ( ~ tmp ) & <S2SV_EndBug> <S2SV_StartBug> 0x7fffffff ) + 1 ) ) ) : JAS_CAST ( longlong , tmp ) ; <S2SV_EndBug> ",<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> <S2SV_ModStart> jas_longlong <S2SV_ModEnd> <S2SV_ModStart> jas_longlong <S2SV_ModEnd> ,mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
669,CWE-476,<S2SV_StartBug> kfree ( rm -> atomic . op_notifier ) ; <S2SV_EndBug> ,<S2SV_ModStart> rm -> atomic . op_active = 0 ; ,torvalds@linux/7d11f77f84b27cef452cee332f4e469503084737,CVE-2018-5333,https://github.com/torvalds/linux/commit/7d11f77f84b27cef452cee332f4e469503084737,2018-01-11T07:29Z
670,CWE-617,<S2SV_StartBug> assert ( bi != NULL ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( bi == NULL ) { pr_err ( ""%s:<S2SV_blank>pci<S2SV_blank>[%s]<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>bus<S2SV_blank>%d<S2SV_blank>info!\\n"" , __func__ , dev -> name , dev -> bus ) ; return ; } <S2SV_ModEnd> ",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z
671,CWE-20,"<S2SV_StartBug> rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , size , msg_flags , timeo ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
672,CWE-22,"<S2SV_StartBug> if ( snprintf ( spath , sizeof ( spath ) , var , iface ) >= sizeof ( spath ) ) <S2SV_EndBug> ","<S2SV_ModStart> ) ) return - 1 ; if ( strstr ( name , "".."" ) || strchr ( name , '/' ",reubenhwk@radvd/92e22ca23e52066da2258df8c76a2dca8a428bcc,CVE-2011-3602,https://github.com/reubenhwk/radvd/commit/92e22ca23e52066da2258df8c76a2dca8a428bcc,2014-04-27T21:55Z
673,CWE-119,<S2SV_StartBug> for ( s += 9 ; isspace ( * s ) ; s ++ ) ; <S2SV_EndBug> <S2SV_StartBug> while ( * t && ! isspace ( * t ) ) t ++ ; <S2SV_EndBug> ,<S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) ,kohler@t1utils/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33,CVE-2015-3905,https://github.com/kohler/t1utils/commit/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33,2015-06-08T14:59Z
674,CWE-22,"<S2SV_StartBug> mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <S2SV_EndBug> ",<S2SV_ModStart> cache_id ( <S2SV_ModStart> ) ,neomutt@neomutt/9bfab35522301794483f8f9ed60820bdec9be59e,CVE-2018-14363,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,2018-07-17T17:29Z
675,CWE-000,<S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> * objp = NULL ; ,krb5@krb5/a197e92349a4aa2141b5dff12e9dd44c2a2166e3,CVE-2014-9421,https://github.com/krb5/krb5/commit/a197e92349a4aa2141b5dff12e9dd44c2a2166e3,2015-02-19T11:59Z
676,CWE-284,"<S2SV_StartBug> result = select ( uipc_main . max_fd + 1 , & uipc_main . read_set , NULL , NULL , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ,system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
677,CWE-415,<S2SV_StartBug> goto discard ; <S2SV_EndBug> ,<S2SV_ModStart> consume_skb ( skb ) ; return 0 <S2SV_ModEnd> ,torvalds@linux/5edabca9d4cff7f1f2b68f0bac55ef99d9798ba4,CVE-2017-6074,https://github.com/torvalds/linux/commit/5edabca9d4cff7f1f2b68f0bac55ef99d9798ba4,2017-02-18T21:59Z
678,CWE-617,"<S2SV_StartBug> assert ( msgnum >= 1 && msgnum <= MAX_MSIX_TABLE_ENTRIES ) ; <S2SV_EndBug> <S2SV_StartBug> pci_msix_table_init ( dev , msgnum ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( msgnum > MAX_MSIX_TABLE_ENTRIES ) { pr_err ( ""%s:<S2SV_blank>Too<S2SV_blank>many<S2SV_blank>entries!\\n"" , __func__ ) ; return - 1 ; } <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModStart> != 0 ) return - 1 ",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z
679,CWE-264,<S2SV_StartBug> upperdentry = ovl_dentry_upper ( dentry ) ; <S2SV_EndBug> <S2SV_StartBug> if ( upperdentry ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ,<S2SV_ModStart> err = ovl_copy_up ( dentry ) ; if ( ! err ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/acff81ec2c79492b180fade3c2894425cd35a545,CVE-2015-8660,https://github.com/torvalds/linux/commit/acff81ec2c79492b180fade3c2894425cd35a545,2015-12-28T11:59Z
680,CWE-119,<S2SV_StartBug> while ( isspace ( * p ) ) <S2SV_EndBug> ,<S2SV_ModStart> ( unsigned char ) ,kohler@t1utils/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33,CVE-2015-3905,https://github.com/kohler/t1utils/commit/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33,2015-06-08T14:59Z
681,CWE-200,<S2SV_StartBug> if ( ! authctxt -> valid ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( b = sshbuf_new ( ) ) == NULL ) <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; goto done ; } if ( ",openbsd@src/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0,CVE-2018-15473,https://github.com/openbsd/src/commit/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0,2018-08-17T19:29Z
682,CWE-119,"<S2SV_StartBug> static int decode_unsigned_max ( struct vp9_read_bit_buffer * rb , int max ) { <S2SV_EndBug> <S2SV_StartBug> const int data = vp9_rb_read_literal ( rb , get_unsigned_bits ( max ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_read_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_rb_read_literal <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
683,CWE-824,<S2SV_StartBug> for ( i = 0 ; i < ctx -> msgcount ; i ++ ) <S2SV_EndBug> ,<S2SV_ModStart> if ( strlen ( line ) == 0 ) return - 1 ; ,neomutt@neomutt/93b8ac558752d09e1c56d4f1bc82631316fa9c82,CVE-2018-14356,https://github.com/neomutt/neomutt/commit/93b8ac558752d09e1c56d4f1bc82631316fa9c82,2018-07-17T17:29Z
684,CWE-000,<S2SV_StartBug> goto cleanup ; <S2SV_EndBug> <S2SV_StartBug> cleanup : <S2SV_EndBug> ,<S2SV_ModStart> return retval <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,krb5@krb5/f249555301940c6df3a2cdda13b56b5674eebc2e,CVE-2013-1415,https://github.com/krb5/krb5/commit/f249555301940c6df3a2cdda13b56b5674eebc2e,2013-03-05T05:05Z
685,CWE-000,<S2SV_StartBug> Jpeg2000Prec * prec = band -> prec + precno ; <S2SV_EndBug> <S2SV_StartBug> av_freep ( & band -> prec ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( band -> prec ) { <S2SV_ModStart> } ,FFmpeg@FFmpeg/912ce9dd2080c5837285a471d750fa311e09b555,CVE-2013-7017,https://github.com/FFmpeg/FFmpeg/commit/912ce9dd2080c5837285a471d750fa311e09b555,2013-12-09T16:36Z
686,CWE-835,"<S2SV_StartBug> if ( xmlPushInput ( ctxt , input ) < 0 ) <S2SV_EndBug> ",<S2SV_ModStart> { xmlFreeInputStream ( input ) ; return ; } <S2SV_ModEnd> ,GNOME@libxml2/899a5d9f0ed13b8e32449a08a361e0de127dd961,CVE-2017-16932,https://github.com/GNOME/libxml2/commit/899a5d9f0ed13b8e32449a08a361e0de127dd961,2017-11-23T21:29Z
687,CWE-264,"<S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> err = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> ","<S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) <S2SV_ModStart> ) ; rcu_read_unlock ( <S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) , <S2SV_ModEnd> <S2SV_ModStart> ) ; rcu_read_unlock ( ",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
688,CWE-119,<S2SV_StartBug> static TX_MODE select_tx_mode ( const VP9_COMP * cpi ) { <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . lossless ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> common . current_video_frame == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . tx_size_search_method == USE_LARGESTALL ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> sf . tx_size_search_method == USE_FULL_RD ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> , MACROBLOCKD * const xd <S2SV_ModStart> xd -> lossless ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> frame_type == KEY_FRAME && cpi -> sf . use_nonrd_pick_mode ) return ALLOW_16X16 ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> || cpi -> sf . tx_size_search_method == USE_TX_8X8 ) return TX_MODE_SELECT ; else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
689,CWE-119,<S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) <S2SV_EndBug> <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; } <S2SV_ModEnd> <S2SV_ModStart> * num ",frameworks@av/2b6f22dc64d456471a1dc6df09d515771d1427c8,CVE-2016-2463,https://android.googlesource.com/platform/frameworks/av/+/2b6f22dc64d456471a1dc6df09d515771d1427c8,2016-06-13T01:59Z
690,CWE-134,<S2SV_StartBug> } else if ( bad_format ( im -> gdes [ i ] . format ) ) { <S2SV_EndBug> <S2SV_StartBug> rrd_set_error <S2SV_EndBug> <S2SV_StartBug> if ( bad_format ( im -> gdes [ i ] . format ) ) { <S2SV_EndBug> <S2SV_StartBug> rrd_set_error <S2SV_EndBug> ,<S2SV_ModStart> bad_format_print <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> bad_format_print <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,oetiker@rrdtool-1.x/64ed5314af1255ab6dded45f70b39cdeab5ae2ec,CVE-2014-6262,https://github.com/oetiker/rrdtool-1.x/commit/64ed5314af1255ab6dded45f70b39cdeab5ae2ec,2020-02-12T02:15Z
691,CWE-119,<S2SV_StartBug> if ( shdr -> sh_size < 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> || shdr -> sh_size > SIZE_MAX ,radare@radare2/0b973e28166636e0ff1fad80baa0385c9c09c53a,CVE-2017-16357,https://github.com/radare/radare2/commit/0b973e28166636e0ff1fad80baa0385c9c09c53a,2017-11-01T17:29Z
692,CWE-119,<S2SV_StartBug> if ( buf1 -> size < buf2 -> size ) { <S2SV_EndBug> ,<S2SV_ModStart> return ( int ) ( buf2 -> size - <S2SV_ModEnd> <S2SV_ModStart> ) ; } <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
693,CWE-119,<S2SV_StartBug> root_storage -> d_storage_uuid ) ) < 0 ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,file@file/6d209c1c489457397a5763bca4b28e43aac90391,CVE-2014-0207,https://github.com/file/file/commit/6d209c1c489457397a5763bca4b28e43aac90391,2014-07-09T11:07Z
694,CWE-189,<S2SV_StartBug> size_t sz = sizeof ( * info ) + size ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( sz < sizeof ( * info ) ) return NULL ,torvalds@linux/d157bd761585605b7882935ffb86286919f62ea1,CVE-2016-3135,https://github.com/torvalds/linux/commit/d157bd761585605b7882935ffb86286919f62ea1,2016-04-27T17:59Z
695,CWE-400,<S2SV_StartBug> if ( ! eof ) { <S2SV_EndBug> ,<S2SV_ModStart> && vars -> str . c != vars -> ptr ,php@php-src/0f8cf3b8497dc45c010c44ed9e96518e11e19fc3,CVE-2017-11142,https://github.com/php/php-src/commit/0f8cf3b8497dc45c010c44ed9e96518e11e19fc3,2017-07-10T14:29Z
696,CWE-000,"<S2SV_StartBug> if ( ! net_eq ( net , & init_net ) ) <S2SV_EndBug> ",<S2SV_ModStart> protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if ( ,torvalds@linux/79462ad02e861803b3840cc782248c7359451cd9,CVE-2015-8543,https://github.com/torvalds/linux/commit/79462ad02e861803b3840cc782248c7359451cd9,2015-12-28T11:59Z
697,CWE-400,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
698,CWE-000,<S2SV_StartBug> ctxt -> _eip = ctxt -> src . val ; <S2SV_EndBug> <S2SV_StartBug> ctxt -> _eip = ctxt -> src . val ; <S2SV_EndBug> ,"<S2SV_ModStart> rc = assign_eip_near ( ctxt , <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( rc != X86EMUL_CONTINUE ) break <S2SV_ModStart> rc = assign_eip_near ( ctxt , <S2SV_ModEnd> <S2SV_ModStart> ) ",torvalds@linux/234f3ce485d54017f15cf5e0699cff4100121601,CVE-2014-3647,https://github.com/torvalds/linux/commit/234f3ce485d54017f15cf5e0699cff4100121601,2014-11-10T11:55Z
699,CWE-77,"<S2SV_StartBug> imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ; <S2SV_EndBug> ","<S2SV_ModStart> , true ",neomutt@neomutt/e52393740334443ae0206cab2d7caef381646725,CVE-2018-14357,https://github.com/neomutt/neomutt/commit/e52393740334443ae0206cab2d7caef381646725,2018-07-17T17:29Z
700,CWE-399,"<S2SV_StartBug> void * * p , void * end , <S2SV_EndBug> <S2SV_StartBug> void * dp , * dend ; <S2SV_EndBug> <S2SV_StartBug> struct ceph_crypto_key old_key ; <S2SV_EndBug> <S2SV_StartBug> dlen = ceph_x_decrypt ( secret , p , end , dbuf , <S2SV_EndBug> <S2SV_StartBug> tp = ticket_buf ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ceph_decode_need ( p , end , dlen , bad ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dbuf = NULL ; void * <S2SV_ModStart> ; void * ticket_buf = NULL <S2SV_ModStart> & dbuf , 0 <S2SV_ModEnd> <S2SV_ModStart> if ( is_enc ) { dout ( ""<S2SV_blank>encrypted<S2SV_blank>ticket\\n"" ) ; dlen = ceph_x_decrypt ( & old_key , p , end , & ticket_buf , 0 <S2SV_ModEnd> <S2SV_ModStart> tp = ticket_buf ; <S2SV_ModStart> ticket_buf = kmalloc ( dlen , GFP_NOFS ) ; if ( ! ticket_buf ) { ret = - ENOMEM ; goto out ; } tp = ticket_buf ; <S2SV_ModStart> kfree ( ticket_buf ) ; kfree ( dbuf ) ; ",torvalds@linux/c27a3e4d667fdcad3db7b104f75659478e0c68d8,CVE-2014-6418,https://github.com/torvalds/linux/commit/c27a3e4d667fdcad3db7b104f75659478e0c68d8,2014-09-28T10:55Z
701,CWE-189,<S2SV_StartBug> pairs = palloc ( count * sizeof ( Pairs ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ; ",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z
702,CWE-000,<S2SV_StartBug> rq -> skip_clock_update = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/f26f9aff6aaf67e9a430d16c266f91b13a5bff64,CVE-2011-4621,https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64,2012-05-17T11:00Z
703,CWE-362,"<S2SV_StartBug> n2l ( p , s -> session -> tlsext_tick_lifetime_hint ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( s -> session -> session_id_length > 0 ) { int i = s -> session_ctx -> session_cache_mode ; SSL_SESSION * new_sess ; if ( i & SSL_SESS_CACHE_CLIENT ) { if ( i & SSL_SESS_CACHE_NO_INTERNAL_STORE ) { if ( s -> session_ctx -> remove_session_cb != NULL ) s -> session_ctx -> remove_session_cb ( s -> session_ctx , s -> session ) ; } else { SSL_CTX_remove_session ( s -> session_ctx , s -> session ) ; } } if ( ( new_sess = ssl_session_dup ( s -> session , 0 ) ) == 0 ) { al = SSL_AD_INTERNAL_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , ERR_R_MALLOC_FAILURE ) ; goto f_err ; } SSL_SESSION_free ( s -> session ) ; s -> session = new_sess ; } ",openssl@openssl/98ece4eebfb6cd45cc8d550c6ac0022965071afc,CVE-2015-1791,https://github.com/openssl/openssl/commit/98ece4eebfb6cd45cc8d550c6ac0022965071afc,2015-06-12T19:59Z
704,CWE-772,"<S2SV_StartBug> r = sd_event_add_io ( b -> manager -> event , & b -> io_event_source , b -> fd , EPOLLIN , button_dispatch , b ) ; <S2SV_EndBug> ",<S2SV_ModStart> b -> io_event_source = sd_event_source_unref ( b -> io_event_source ) ; ,systemd@systemd/b2774a3ae692113e1f47a336a6c09bac9cfb49ad,CVE-2019-20386,https://github.com/systemd/systemd/commit/b2774a3ae692113e1f47a336a6c09bac9cfb49ad,2020-01-21T06:15Z
705,CWE-119,<S2SV_StartBug> if ( errors ) <S2SV_EndBug> ,<S2SV_ModStart> errors += test_float_formatting ( ) ; ,curl@curl/3ab3c16db6a5674f53cf23d56512a405fde0b2c9,CVE-2016-9586,https://github.com/curl/curl/commit/curl-7_51_0-162-g3ab3c16,2018-04-23T18:29Z
706,CWE-476,<S2SV_StartBug> return true ; <S2SV_EndBug> <S2SV_StartBug> return true ; <S2SV_EndBug> ,<S2SV_ModStart> ( * elem_rtrn != NULL && * field_rtrn != NULL ) <S2SV_ModEnd> <S2SV_ModStart> if ( expr -> array_ref . element != XKB_ATOM_NONE && * elem_rtrn == NULL ) return false ; if ( * field_rtrn == NULL ) return false ; ,xkbcommon@libxkbcommon/bb4909d2d8fa6b08155e449986a478101e2b2634,CVE-2018-15859,https://github.com/xkbcommon/libxkbcommon/commit/bb4909d2d8fa6b08155e449986a478101e2b2634,2018-08-25T21:29Z
707,CWE-000,<S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> ,<S2SV_ModStart> sas_eh_finish_cmd <S2SV_ModEnd> ,torvalds@linux/318aaf34f1179b39fa9c30fa0f3288b645beee39,CVE-2018-10021,https://github.com/torvalds/linux/commit/318aaf34f1179b39fa9c30fa0f3288b645beee39,2018-04-11T17:29Z
708,CWE-125,"<S2SV_StartBug> REQ ( n , funcdef ) ; <S2SV_EndBug> <S2SV_StartBug> body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( is_async ) <S2SV_EndBug> <S2SV_StartBug> return AsyncFunctionDef ( name , args , body , decorator_seq , returns , <S2SV_EndBug> <S2SV_StartBug> return FunctionDef ( name , args , body , decorator_seq , returns , <S2SV_EndBug> ","<S2SV_ModStart> node * tc ; string type_comment = NULL ; <S2SV_ModStart> if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; if ( ! type_comment ) return NULL ; name_i += 1 ; } <S2SV_ModStart> NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) { if ( type_comment != NULL ) { ast_error ( c , n , ""Cannot<S2SV_blank>have<S2SV_blank>two<S2SV_blank>type<S2SV_blank>comments<S2SV_blank>on<S2SV_blank>def"" ) ; return NULL ; } type_comment = NEW_TYPE_COMMENT ( tc ) ; if ( ! type_comment ) return NULL ; } } if ( <S2SV_ModStart> , type_comment <S2SV_ModStart> type_comment , ",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z
709,CWE-416,<S2SV_StartBug> int err = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( ! net_eq ( current -> nsproxy -> net_ns , sock_net ( sk ) ) ) return - EINVAL ",torvalds@linux/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74,CVE-2017-15115,https://github.com/torvalds/linux/commit/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74,2017-11-15T21:29Z
710,CWE-20,<S2SV_StartBug> if ( likely ( walk . nbytes == nbytes ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/ecaaab5649781c5a0effdaf298a925063020500e,CVE-2017-17805,https://github.com/torvalds/linux/commit/ecaaab5649781c5a0effdaf298a925063020500e,2017-12-20T23:29Z
711,CWE-200,<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> msg -> msg_namelen = 0 ; ,torvalds@linux/d5e0d0f607a7a029c6563a0470d88255c89a8d11,CVE-2013-3237,https://github.com/torvalds/linux/commit/d5e0d0f607a7a029c6563a0470d88255c89a8d11,2013-04-22T11:41Z
712,CWE-119,"<S2SV_StartBug> if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> ",<S2SV_ModStart> 3 == <S2SV_ModStart> && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> ,hfp@libxsmm/151481489192e6d1997f8bde52c5c425ea41741d,CVE-2018-20542,https://github.com/hfp/libxsmm/commit/151481489192e6d1997f8bde52c5c425ea41741d,2018-12-28T16:29Z
713,CWE-787,<S2SV_StartBug> image -> columns = image -> rows = 0 ; <S2SV_EndBug> <S2SV_StartBug> BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ; <S2SV_EndBug> ,<S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,ImageMagick@ImageMagick/998c687fb83993c13fa711d75f59a95b38ceab77,CVE-2016-7526,https://github.com/ImageMagick/ImageMagick/commit/998c687fb83993c13fa711d75f59a95b38ceab77,2017-04-20T18:59Z
714,CWE-264,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> ",<S2SV_ModStart> int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> rc = <S2SV_ModStart> rc <S2SV_ModEnd> ,torvalds@linux/234f3ce485d54017f15cf5e0699cff4100121601,CVE-2014-3647,https://github.com/torvalds/linux/commit/234f3ce485d54017f15cf5e0699cff4100121601,2014-11-10T11:55Z
715,CWE-119,"
","
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
716,CWE-476,"<S2SV_StartBug> freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! res ) return - EINVAL ; ,torvalds@linux/9903e41ae1f5d50c93f268ca3304d4d7c64b9311,CVE-2018-10074,https://github.com/torvalds/linux/commit/9903e41ae1f5d50c93f268ca3304d4d7c64b9311,2018-04-12T18:29Z
717,CWE-119,"<S2SV_StartBug> if ( position > SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> <S2SV_StartBug> if ( position > psf -> headend ) <S2SV_EndBug> <S2SV_StartBug> psf -> headend += psf_fread ( psf -> header + psf -> headend , 1 , position - psf -> headend , psf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( psf -> headindex + position < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( psf -> headindex >= SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> <S2SV_StartBug> if ( psf -> headindex + position <= psf -> headend ) <S2SV_EndBug> <S2SV_StartBug> if ( psf -> headindex + position > SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> <S2SV_StartBug> psf -> headindex = psf -> headend ; <S2SV_EndBug> <S2SV_StartBug> psf -> headend += psf_fread ( psf -> header + psf -> headend , 1 , position - ( psf -> headend - psf -> headindex ) , psf ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex = psf -> headend ; <S2SV_EndBug> ","<S2SV_ModStart> psf -> header . indx + position >= psf -> header . len ) psf_bump_header_allocation ( psf , position ) ; if ( position > psf -> header . len <S2SV_ModEnd> <S2SV_ModStart> header . end ) psf -> header . end <S2SV_ModEnd> <S2SV_ModStart> . ptr + psf -> header . end <S2SV_ModEnd> <S2SV_ModStart> header . end , psf ) ; psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . indx + position >= psf -> header . len ) psf_bump_header_allocation ( psf , position ) ; if ( psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . indx >= psf -> header . len <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . end ) { psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> psf -> header . len ) { psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . end <S2SV_ModEnd> <S2SV_ModStart> header . end <S2SV_ModEnd> <S2SV_ModStart> . ptr + psf -> header . end <S2SV_ModEnd> <S2SV_ModStart> header . end <S2SV_ModEnd> <S2SV_ModStart> header . indx ) , psf ) ; psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . end <S2SV_ModEnd> ",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z
718,CWE-362,"<S2SV_StartBug> truncate_pagecache ( inode , ioffset ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> goto out_dio ; <S2SV_EndBug> <S2SV_StartBug> out_dio : <S2SV_EndBug> ",<S2SV_ModStart> ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> out_mmap <S2SV_ModEnd> <S2SV_ModStart> out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModEnd> ,torvalds@linux/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b,CVE-2015-8839,https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b,2016-05-02T10:59Z
719,CWE-125,"<S2SV_StartBug> uint32_t track_size ; <S2SV_EndBug> <S2SV_StartBug> track_delta = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_EndBug> <S2SV_StartBug> track_size = * midi_data ++ << 24 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ << 16 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ << 8 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( midi_size < track_size ) { <S2SV_EndBug> <S2SV_StartBug> if ( track_size < 3 ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( midi_data [ track_size - 3 ] != 0xFF ) <S2SV_EndBug> <S2SV_StartBug> || ( midi_data [ track_size - 2 ] != 0x2F ) <S2SV_EndBug> <S2SV_StartBug> || ( midi_data [ track_size - 1 ] != 0x00 ) ) { <S2SV_EndBug> <S2SV_StartBug> midi_data += track_size ; <S2SV_EndBug> <S2SV_StartBug> midi_size -= track_size ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> goto NEXT_TRACK ; <S2SV_EndBug> <S2SV_StartBug> if ( * tracks [ i ] > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( * tracks [ i ] > 0x7f ) ; <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( * tracks [ i ] > 0x7f ) ; <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( mdi -> reverb ) return ( mdi ) ; <S2SV_EndBug> ","<S2SV_ModStart> uint8_t * * tracks ; uint32_t * track_size <S2SV_ModEnd> <S2SV_ModStart> track_size = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> track_size [ i ] = tmp_val ; midi_data += tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> track_size [ i ] -- ; <S2SV_ModStart> ; track_size [ i ] -- <S2SV_ModStart> track_size [ i ] , <S2SV_ModStart> track_size [ i ] -= 3 ; <S2SV_ModStart> track_size [ i ] -= setup_ret ; <S2SV_ModStart> if ( ! track_size [ i ] ) break ; <S2SV_ModStart> track_size [ i ] -- ; <S2SV_ModStart> if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_ModStart> ; track_size [ i ] -- <S2SV_ModStart> track_size [ i ] , <S2SV_ModStart> track_size [ i ] -= setup_ret ; <S2SV_ModStart> if ( ! track_size [ i ] ) break ; <S2SV_ModStart> track_size [ i ] -- ; <S2SV_ModStart> if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_ModStart> ; track_size [ i ] -- <S2SV_ModStart> free ( track_size ) ; ",Mindwerks@wildmidi/ad6d7cf88d6673167ca1f517248af9409a9f1be1,CVE-2017-11664,https://github.com/Mindwerks/wildmidi/commit/ad6d7cf88d6673167ca1f517248af9409a9f1be1,2017-08-17T16:29Z
720,CWE-119,"<S2SV_StartBug> sk -> sk_sndbuf = max_t ( u32 , val * 2 , SOCK_MIN_SNDBUF ) ; <S2SV_EndBug> <S2SV_StartBug> sk -> sk_rcvbuf = max_t ( u32 , val * 2 , SOCK_MIN_RCVBUF ) ; <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int <S2SV_ModEnd> ,torvalds@linux/b98b0bc8c431e3ceb4b26b0dfc8db509518fb290,CVE-2016-9793,https://github.com/torvalds/linux/commit/b98b0bc8c431e3ceb4b26b0dfc8db509518fb290,2016-12-28T07:59Z
721,CWE-119,<S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> lvd = ( struct logicalVolDesc * ) bh -> b_data ; <S2SV_EndBug> <S2SV_StartBug> i < sbi -> s_partitions && offset < le32_to_cpu ( lvd -> mapTableLength ) ; <S2SV_EndBug> ,"<S2SV_ModStart> unsigned int table_len ; <S2SV_ModStart> table_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) { udf_err ( sb , ""error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>"" ""Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\n"" , table_len , sb -> s_blocksize - sizeof ( * lvd ) ) ; goto out_bh ; } <S2SV_ModStart> table_len <S2SV_ModEnd> ",torvalds@linux/adee11b2085bee90bd8f4f52123ffb07882d6256,CVE-2012-3400,https://github.com/torvalds/linux/commit/adee11b2085bee90bd8f4f52123ffb07882d6256,2012-10-03T11:02Z
722,CWE-476,"<S2SV_StartBug> if ( optstr ) { <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" <S2SV_EndBug> <S2SV_StartBug> ""mincolors<S2SV_blank>%d\\n"" , info -> len , info -> width , info -> height , info -> numplanes , <S2SV_EndBug> <S2SV_StartBug> info -> depth , info -> enctype , info -> siz , info -> hres , info -> vres , <S2SV_EndBug> <S2SV_StartBug> info -> numcolors , info -> mincolors ) ) ; <S2SV_EndBug> <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> <S2SV_StartBug> jas_image_destroy ( image ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> ","<S2SV_ModStart> image = 0 ; info = 0 ; <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%ld;<S2SV_blank>width<S2SV_blank>%ld;<S2SV_blank>height<S2SV_blank>%ld;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%ld;<S2SV_blank>siz<S2SV_blank>%ld;<S2SV_blank>hres<S2SV_blank>%ld;<S2SV_blank>vres<S2SV_blank>%ld;<S2SV_blank>numcolors<S2SV_blank>%ld;<S2SV_blank>"" ""mincolors<S2SV_blank>%ld\\n"" , JAS_CAST ( long <S2SV_ModEnd> <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long , <S2SV_ModEnd> <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long , <S2SV_ModEnd> <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) ; if ( info -> width < 0 || info -> height < 0 || info -> numplanes < 0 || info -> depth < 0 || info -> siz < 0 || info -> hres < 0 || info -> vres < 0 ) { jas_eprintf ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\n"" ) ; goto error ; } <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error ; } <S2SV_ModStart> return image ; error : if ( info ) { bmp_info_destroy ( info ) ; } if ( image ) { <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> ",mdadams@jasper/5d66894d2313e3f3469f19066e149e08ff076698,CVE-2016-8884,https://github.com/mdadams/jasper/commit/5d66894d2313e3f3469f19066e149e08ff076698,2017-03-28T14:59Z
723,CWE-125,"<S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> <S2SV_StartBug> dev_name ( & qedi -> pdev -> dev ) , nfunc , line , <S2SV_EndBug> <S2SV_StartBug> pr_notice ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> ,torvalds@linux/c09581a52765a85f19fc35340127396d5e3379cc,CVE-2019-15090,https://github.com/torvalds/linux/commit/c09581a52765a85f19fc35340127396d5e3379cc,2019-08-16T00:15Z
724,CWE-119,<S2SV_StartBug> return ( ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ps_cabac -> u4_ofst >= ps_cabac -> u4_range ) { return ( ( IHEVCD_ERROR_T ) IHEVCD_FAIL ) ; } ,external@libhevc/bcfc7124f6ef9f1ec128fb2e90de774a5b33d199,CVE-2017-0589,https://android.googlesource.com/platform/external/libhevc/+/bcfc7124f6ef9f1ec128fb2e90de774a5b33d199,2017-05-12T15:29Z
725,CWE-200,"<S2SV_StartBug> save_text_from_text_view ( g_tv_comment , FILENAME_COMMENT ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; problem_data_reload_from_dump_dir ( ) ; update_gui_state_from_problem_data ( 0 ,abrt@libreport/257578a23d1537a2d235aaa2b1488ee4f818e360,CVE-2015-5302,https://github.com/abrt/libreport/commit/257578a23d1537a2d235aaa2b1488ee4f818e360,2015-12-07T18:59Z
726,CWE-200,"<S2SV_StartBug> media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ; <S2SV_EndBug> <S2SV_StartBug> media_device_kpad_to_upad ( entity -> links [ l ] . source , <S2SV_EndBug> ","<S2SV_ModStart> memset ( & pad , 0 , sizeof ( pad ) ) ; <S2SV_ModStart> memset ( & link , 0 , sizeof ( link ) ) ; ",torvalds@linux/c88e739b1fad662240e99ecbd0bdaac871717987,CVE-2014-9895,https://github.com/torvalds/linux/commit/c88e739b1fad662240e99ecbd0bdaac871717987,2016-08-06T10:59Z
727,CWE-908,"<S2SV_StartBug> && ( CH ( off ) == _T ( '=' ) || CH ( off ) == _T ( '-' ) ) <S2SV_EndBug> <S2SV_StartBug> if ( line -> indent < ctx -> code_indent_offset && ISANYOF ( off , _T ( ""-_*"" ) ) && off >= hr_killer ) { <S2SV_EndBug> <S2SV_StartBug> ( container . ch == _T ( '.' ) || container . ch == _T ( ')' ) ) && container . start != 1 ) <S2SV_EndBug> <S2SV_StartBug> if ( line -> indent < ctx -> code_indent_offset && CH ( off ) == _T ( '#' ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( CH ( off ) == _T ( '`' ) || CH ( off ) == _T ( '~' ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( ctx -> parser . flags & MD_FLAG_TABLES ) && pivot_line -> type == MD_LINE_TEXT && <S2SV_EndBug> <S2SV_StartBug> ( CH ( off ) == _T ( '|' ) || CH ( off ) == _T ( '-' ) || CH ( off ) == _T ( ':' ) ) && <S2SV_EndBug> ","<S2SV_ModStart> off < ctx -> size && ISANYOF2 ( off , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> && off < ctx -> size <S2SV_ModEnd> <S2SV_ModStart> && ISANYOF ( off , _T ( ""-_*"" ) ) ) <S2SV_ModEnd> <S2SV_ModStart> ISANYOF2_ <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> off < ctx -> size && <S2SV_ModStart> off < ctx -> size && ISANYOF2 ( off , _T ( '`' ) , _T ( '~' ) ) ) { if ( md_is_opening_code_fence ( ctx , off , & off ) ) { line -> type = MD_LINE_FENCEDCODE ; line -> data = 1 ; break ; } } if ( off < ctx -> size && <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && off < ctx -> size && ISANYOF3 ( off , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> ",mity@md4c/4fc808d8fe8d8904f8525bb4231d854f45e23a19,CVE-2021-30027,https://github.com/mity/md4c/commit/4fc808d8fe8d8904f8525bb4231d854f45e23a19,2021-04-29T15:15Z
728,CWE-125,"<S2SV_StartBug> height , <S2SV_EndBug> <S2SV_StartBug> if ( bytes_per_line == 0 ) <S2SV_EndBug> <S2SV_StartBug> bytes_per_line = image -> columns ; <S2SV_EndBug> <S2SV_StartBug> length = image -> rows * ( image -> columns + image -> columns % 2 ) ; <S2SV_EndBug> <S2SV_StartBug> SetPixelIndex ( image , * p ++ , q ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( image -> columns % 2 ) != 0 ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , <S2SV_ModEnd> <S2SV_ModStart> , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) <S2SV_ModEnd> <S2SV_ModStart> ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( <S2SV_ModEnd> <S2SV_ModStart> != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns <S2SV_ModEnd> <S2SV_ModStart> if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } <S2SV_ModStart>  <S2SV_ModEnd> ",ImageMagick@ImageMagick/8ea44b48a182dd46d018f4b4f09a5e2ee9638105,CVE-2015-8958,https://github.com/ImageMagick/ImageMagick/commit/8ea44b48a182dd46d018f4b4f09a5e2ee9638105,2017-04-20T18:59Z
729,CWE-295,"<S2SV_StartBug> krb5_principal client_principal , <S2SV_EndBug> <S2SV_StartBug> krb5_principal_get_realm ( context , krbtgt -> entry . principal ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> , const char * tgt_realm <S2SV_ModStart> tgt_realm <S2SV_ModEnd> ",heimdal@heimdal/b1e699103f08d6a0ca46a122193c9da65f6cf837,CVE-2017-6594,https://github.com/heimdal/heimdal/commit/b1e699103f08d6a0ca46a122193c9da65f6cf837,2017-08-28T19:29Z
730,CWE-835,<S2SV_StartBug> if ( bmp_info . number_colors > GetBlobSize ( image ) ) <S2SV_EndBug> <S2SV_StartBug> * magick = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> if ( bmp_info . ba_offset != 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( offset < 0 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> ( MagickSizeType ) <S2SV_ModStart> offset = ( MagickOffsetType ) <S2SV_ModEnd> <S2SV_ModStart> ; if ( offset <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) <S2SV_ModEnd> <S2SV_ModStart> * magick = '\\0' ; <S2SV_ModEnd> ",ImageMagick@ImageMagick/db0add932fb850d762b02604ca3053b7d7ab6deb,CVE-2018-20467,https://github.com/ImageMagick/ImageMagick/commit/db0add932fb850d762b02604ca3053b7d7ab6deb,2018-12-26T03:29Z
731,CWE-362,<S2SV_StartBug> newinet -> opt = ireq -> opt ; <S2SV_EndBug> ,<S2SV_ModStart> inet_opt <S2SV_ModEnd> ,torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z
732,CWE-119,<S2SV_StartBug> data -> l_head = NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> ",miniupnp@miniupnp/7aeb624b44f86d335841242ff427433190e7168a,CVE-2017-1000494,https://github.com/miniupnp/miniupnp/commit/7aeb624b44f86d335841242ff427433190e7168a,2018-01-03T14:29Z
733,CWE-125,"<S2SV_StartBug> if ( offset != 0 ) <S2SV_EndBug> <S2SV_StartBug> csum_partial ( skb_transport_header ( skb ) + tlen , <S2SV_EndBug> <S2SV_StartBug> offset , 0 ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> { int tend_off = skb_transport_offset ( skb ) + tlen ; <S2SV_ModStart> skb_checksum ( skb , tend_off , <S2SV_ModEnd> <S2SV_ModStart> } ",torvalds@linux/ca4ef4574f1ee5252e2cd365f8f5d5bafd048f32,CVE-2017-6347,https://github.com/torvalds/linux/commit/ca4ef4574f1ee5252e2cd365f8f5d5bafd048f32,2017-03-01T20:59Z
734,CWE-189,"<S2SV_StartBug> goto unmap_pages ; <S2SV_EndBug> <S2SV_StartBug> kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn ) ; <S2SV_EndBug> ","<S2SV_ModStart> kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_ModStart> - slot -> base_gfn ",torvalds@linux/350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7,CVE-2014-3601,https://github.com/torvalds/linux/commit/350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7,2014-09-01T01:55Z
735,CWE-119,"<S2SV_StartBug> memcpy ( & b [ 4 ] , cmd -> msg , cmd -> msg_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( cmd -> msg_len > sizeof ( b ) - 4 ) return - EINVAL ; ,torvalds@linux/f2e323ec96077642d397bb1c355def536d489d16,CVE-2014-8884,https://github.com/torvalds/linux/commit/f2e323ec96077642d397bb1c355def536d489d16,2014-11-30T01:59Z
736,CWE-264,<S2SV_StartBug> struct perf_event_context * ctx = event -> ctx ; <S2SV_EndBug> <S2SV_StartBug> event -> state = PERF_EVENT_STATE_OFF ; <S2SV_EndBug> ,"<S2SV_ModStart> ; ctx = perf_event_ctx_lock <S2SV_ModEnd> <S2SV_ModStart> _perf_event_disable ( event ) ; perf_event_ctx_unlock ( event , ctx <S2SV_ModEnd> ",torvalds@linux/f63a8daa5812afef4f06c962351687e1ff9ccb2b,CVE-2016-6787,https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b,2016-12-28T07:59Z
737,CWE-125,<S2SV_StartBug> value = ( unsigned int ) ( ( buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) | <S2SV_EndBug> <S2SV_StartBug> ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned int ) ( value & 0xffffffff ) ) ; <S2SV_EndBug> <S2SV_StartBug> value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ) | ( buffer [ 1 ] << 16 ) | <S2SV_EndBug> <S2SV_StartBug> ( buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned int ) ( value & 0xffffffff ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,ImageMagick@ImageMagick/d8ab7f046587f2e9f734b687ba7e6e10147c294b,CVE-2016-5842,https://github.com/ImageMagick/ImageMagick/commit/d8ab7f046587f2e9f734b687ba7e6e10147c294b,2016-12-13T15:59Z
738,CWE-362,<S2SV_StartBug> struct free_nid * i ; <S2SV_EndBug> <S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> if ( build ) { <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> ,"<S2SV_ModStart> , * e <S2SV_ModStart> = - EINVAL ; bool ret = false <S2SV_ModStart> i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) goto err ; spin_lock ( & nm_i -> nid_list_lock ) ; <S2SV_ModStart> goto err_out ; e = __lookup_free_nid_list ( nm_i , nid ) ; if ( e ) { if ( e -> state == NID_NEW ) ret = true ; goto err_out ; } } ret = true ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; err_out : spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; err : if ( err ) kmem_cache_free ( free_nid_slab , i ) ; return ret <S2SV_ModEnd> ",torvalds@linux/30a61ddf8117c26ac5b295e1233eaa9629a94ca3,CVE-2017-18249,https://github.com/torvalds/linux/commit/30a61ddf8117c26ac5b295e1233eaa9629a94ca3,2018-03-26T20:29Z
739,CWE-119,<S2SV_StartBug> # if CONFIG_POSTPROC_VISUALIZER <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_POSTPROC_VISUALIZER <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
740,CWE-20,"<S2SV_StartBug> netdev_dbg ( vif -> dev , ""Missing<S2SV_blank>extra<S2SV_blank>info\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , <S2SV_EndBug> <S2SV_StartBug> ""Invalid<S2SV_blank>extra<S2SV_blank>type:<S2SV_blank>%d\\n"" , extra . type ) ; <S2SV_EndBug> ",<S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif ,torvalds@linux/48856286b64e4b66ec62b94e504d0b29c1ade664,CVE-2013-0216,https://github.com/torvalds/linux/commit/48856286b64e4b66ec62b94e504d0b29c1ade664,2013-02-18T04:41Z
741,CWE-119,"<S2SV_StartBug> pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; <S2SV_EndBug> ",<S2SV_ModStart> hdr -> sadb_msg_reserved = 0 ; ,torvalds@linux/a5cc68f3d63306d0d288f31edfc2ae6ef8ecd887,CVE-2013-2234,https://github.com/torvalds/linux/commit/a5cc68f3d63306d0d288f31edfc2ae6ef8ecd887,2013-07-04T21:55Z
742,CWE-200,<S2SV_StartBug> r1 . event = event ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & r1 , 0 , sizeof ( r1 ) ) ; ",torvalds@linux/9a47e9cff994f37f7f0dbd9ae23740d0f64f9fe6,CVE-2016-4578,https://github.com/torvalds/linux/commit/9a47e9cff994f37f7f0dbd9ae23740d0f64f9fe6,2016-05-23T10:59Z
743,CWE-190,"<S2SV_StartBug> defaultoptions ( & h ) ; <S2SV_EndBug> <S2SV_StartBug> luaL_checkstack ( L , 1 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pushnumber ( L , res ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pushnumber ( L , f ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pushnumber ( L , d ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! lua_isnumber ( L , - 1 ) ) <S2SV_EndBug> <S2SV_StartBug> luaL_error ( L , ""format<S2SV_blank>`c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pop ( L , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pushlstring ( L , data + pos , size ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pushlstring ( L , data + pos , size - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> return lua_gettop ( L ) - 2 ; <S2SV_EndBug> ","<S2SV_ModStart> int n = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 2 <S2SV_ModEnd> <S2SV_ModStart> n ++ ; <S2SV_ModStart> n ++ ; <S2SV_ModStart> n ++ ; <S2SV_ModStart> n == 0 || <S2SV_ModStart> ""format<S2SV_blank>\'c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" <S2SV_ModEnd> <S2SV_ModStart> n -- ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && pos <= ld - size , <S2SV_ModEnd> <S2SV_ModStart> ; n ++ <S2SV_ModStart> n ++ ; <S2SV_ModStart> n + 1 <S2SV_ModEnd> ",antirez@redis/1eb08bcd4634ae42ec45e8284923ac048beaa4c3,CVE-2018-11219,https://github.com/antirez/redis/commit/1eb08bcd4634ae42ec45e8284923ac048beaa4c3,2018-06-17T17:29Z
744,CWE-125,"<S2SV_StartBug> ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> u_int name_entries = EXTRACT_16BITS ( msg_data + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> u_int addr_size = 4 ; <S2SV_EndBug> <S2SV_StartBug> int name_entries_valid = 0 ; <S2SV_EndBug> <S2SV_StartBug> name_entries_valid = 1 ; <S2SV_EndBug> ","<S2SV_ModStart> if ( is_ipv6 ) { <S2SV_ModStart> olsr_msg6 ) ) ; <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_ModStart> ; u_int addr_size ; int name_entries_valid ; u_int i ; if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entries <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( is_ipv6 ) addr_size = 16 ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",the-tcpdump-group@tcpdump/0cb1b8a434b599b8d636db029aadb757c24e39d6,CVE-2017-13688,https://github.com/the-tcpdump-group/tcpdump/commit/0cb1b8a434b599b8d636db029aadb757c24e39d6,2017-09-14T06:29Z
745,CWE-119,<S2SV_StartBug> int n ; <S2SV_EndBug> <S2SV_StartBug> if ( ! body -> unit_size ) <S2SV_EndBug> <S2SV_StartBug> n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) <S2SV_EndBug> ,<S2SV_ModStart> unsigned <S2SV_ModStart> || len < sizeof ( struct oz_multiple_fixed ) - 1 <S2SV_ModStart> ( <S2SV_ModStart> - 1 ) <S2SV_ModEnd> ,torvalds@linux/9a59029bc218b48eff8b5d4dde5662fd79d3e1a8,CVE-2015-4002,https://github.com/torvalds/linux/commit/9a59029bc218b48eff8b5d4dde5662fd79d3e1a8,2015-06-07T23:59Z
746,CWE-119,<S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
747,CWE-269,"<S2SV_StartBug> fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> int rv = copy_file ( src , dest ) ; <S2SV_EndBug> <S2SV_StartBug> if ( chown ( dest , getuid ( ) , getgid ( ) ) == - 1 ) <S2SV_EndBug> ","<S2SV_ModStart> ""Warning:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\n"" ) ; return 0 ; } copy_file_as_user <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , 0600 ) ; fs_logger2 ( ""clone"" , dest <S2SV_ModEnd> ",netblue30@firejail/903fd8a0789ca3cc3c21d84cd0282481515592ef,CVE-2017-5940,https://github.com/netblue30/firejail/commit/903fd8a0789ca3cc3c21d84cd0282481515592ef,2017-02-09T18:59Z
748,CWE-20,<S2SV_StartBug> idata -> status = IMAP_FATAL ; <S2SV_EndBug> ,"<S2SV_ModStart> ; return ; } if ( strlen ( idata -> buf ) < litlen ) { mutt_debug ( 1 , ""Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>mailbox\\n"" ) ",neomutt@neomutt/3c49c44be9b459d9c616bcaef6eb5d51298c1741,CVE-2018-14351,https://github.com/neomutt/neomutt/commit/3c49c44be9b459d9c616bcaef6eb5d51298c1741,2018-07-17T17:29Z
749,CWE-000,"<S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_PROBE ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/0558f33c06bb910e2879e355192227a8e8f0219d,CVE-2017-18232,https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d,2018-03-15T04:29Z
750,CWE-908,"<S2SV_StartBug> if ( unlikely ( path [ depth ] . p_ext > EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) ) { <S2SV_EndBug> <S2SV_StartBug> ext4_extent_block_csum_set ( inode , neh ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_extent_block_csum_set ( inode , neh ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t ext_size = 0 ; <S2SV_ModStart> ext_size = sizeof ( struct ext4_extent_header ) + sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ; <S2SV_ModStart> ext_size = sizeof ( struct ext4_extent_header ) + ( sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ; ",torvalds@linux/592acbf16821288ecdc4192c47e3774a4c48bb64,CVE-2019-11833,https://github.com/torvalds/linux/commit/592acbf16821288ecdc4192c47e3774a4c48bb64,2019-05-15T13:29Z
751,CWE-787,<S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p3 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p3 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } ,external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z
752,CWE-787,<S2SV_StartBug> cmap_len = get_ushort ( & tga [ 5 ] ) ; <S2SV_EndBug> <S2SV_StartBug> x_origin = get_ushort ( & tga [ 8 ] ) ; <S2SV_EndBug> <S2SV_StartBug> y_origin = get_ushort ( & tga [ 10 ] ) ; <S2SV_EndBug> <S2SV_StartBug> image_w = get_ushort ( & tga [ 12 ] ) ; <S2SV_EndBug> <S2SV_StartBug> image_h = get_ushort ( & tga [ 14 ] ) ; <S2SV_EndBug> ,<S2SV_ModStart> get_tga_ushort <S2SV_ModEnd> <S2SV_ModStart> get_tga_ushort <S2SV_ModEnd> <S2SV_ModStart> get_tga_ushort <S2SV_ModEnd> <S2SV_ModStart> get_tga_ushort <S2SV_ModEnd> <S2SV_ModStart> get_tga_ushort <S2SV_ModEnd> ,uclouvain@openjpeg/2cd30c2b06ce332dede81cccad8b334cde997281,CVE-2017-14040,https://github.com/uclouvain/openjpeg/commit/2cd30c2b06ce332dede81cccad8b334cde997281,2017-08-30T22:29Z
753,CWE-264,<S2SV_StartBug> ssize_t ret ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ,torvalds@linux/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3,CVE-2016-4565,https://github.com/torvalds/linux/commit/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3,2016-05-23T10:59Z
754,CWE-189,"<S2SV_StartBug> if ( CPUCLOCK_WHICH ( which_clock ) == CPUCLOCK_SCHED ) { <S2SV_EndBug> <S2SV_StartBug> tp -> tv_sec = div_long_long_rem ( cpu . sched , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> * tp = ns_to_timespec <S2SV_ModEnd> <S2SV_ModStart> ) ; else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/f8bd2258e2d520dff28c855658bd24bdafb5102d,CVE-2011-3209,https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d,2012-10-03T11:02Z
755,CWE-125,<S2SV_StartBug> uint32 nstrips ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,vadz@libtiff/9a72a69e035ee70ff5c41541c8c61cd97990d018,CVE-2016-10270,https://github.com/vadz/libtiff/commit/9a72a69e035ee70ff5c41541c8c61cd97990d018,2017-03-24T19:59Z
756,CWE-20,"<S2SV_StartBug> rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , size , msg_flags , timeo ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
757,CWE-264,"<S2SV_StartBug> const lua_authz_provider_spec * prov_spec = parsed_require_line ; <S2SV_EndBug> <S2SV_StartBug> if ( prov_spec -> args ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! lua_checkstack ( L , prov_spec -> args -> nelts ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < prov_spec -> args -> nelts ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> const char * arg = APR_ARRAY_IDX ( prov_spec -> args , i , const char * ) ; <S2SV_EndBug> <S2SV_StartBug> nargs = prov_spec -> args -> nelts ; <S2SV_EndBug> ",<S2SV_ModStart> lua_authz_provider_func * prov_func = parsed_require_line ; const <S2SV_ModStart> prov_func -> spec <S2SV_ModEnd> <S2SV_ModStart> prov_func <S2SV_ModEnd> <S2SV_ModStart> prov_func <S2SV_ModEnd> <S2SV_ModStart> prov_func <S2SV_ModEnd> <S2SV_ModStart> prov_func <S2SV_ModEnd> <S2SV_ModStart> prov_func <S2SV_ModEnd> ,apache@httpd/3f1693d558d0758f829c8b53993f1749ddf6ffcb,CVE-2014-8109,https://github.com/apache/httpd/commit/3f1693d558d0758f829c8b53993f1749ddf6ffcb,2014-12-29T23:59Z
758,CWE-476,<S2SV_StartBug> int error ; <S2SV_EndBug> <S2SV_StartBug> error = security_mmap_addr ( address ) ; <S2SV_EndBug> ,<S2SV_ModStart> = 0 <S2SV_ModStart> if ( address < mmap_min_addr ) return - EPERM <S2SV_ModEnd> ,torvalds@linux/0a1d52994d440e21def1c2174932410b4f2a98a1,CVE-2019-9213,https://github.com/torvalds/linux/commit/0a1d52994d440e21def1c2174932410b4f2a98a1,2019-03-05T22:29Z
759,CWE-285,"<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z
760,CWE-59,"<S2SV_StartBug> const char * data , int optional ) <S2SV_EndBug> <S2SV_StartBug> if ( mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data ) ) { <S2SV_EndBug> <S2SV_StartBug> mountflags | MS_REMOUNT , data ) ) { <S2SV_EndBug> ","<S2SV_ModStart> , const char * rootfs <S2SV_ModStart> safe_mount <S2SV_ModEnd> <S2SV_ModStart> , rootfs <S2SV_ModStart> < 0 ",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z
761,CWE-119,<S2SV_StartBug> return ( GetFirstImageInList ( image ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z
762,CWE-190,<S2SV_StartBug> timr -> it_overrun = - 1 ; <S2SV_EndBug> <S2SV_StartBug> info -> si_overrun += timr -> it_overrun_last ; <S2SV_EndBug> ,"<S2SV_ModStart> 1LL <S2SV_ModEnd> <S2SV_ModStart> = timer_overrun_to_int ( timr , info -> si_overrun ) <S2SV_ModEnd> ",torvalds@linux/78c9c4dfbf8c04883941445a195276bb4bb92c76,CVE-2018-12896,https://github.com/torvalds/linux/commit/78c9c4dfbf8c04883941445a195276bb4bb92c76,2018-07-02T17:29Z
763,CWE-522,<S2SV_StartBug> if ( ! proto_end ) <S2SV_EndBug> ,"<S2SV_ModStart> { if ( ! quiet ) warning ( _ ( ""url<S2SV_blank>has<S2SV_blank>no<S2SV_blank>scheme:<S2SV_blank>%s"" ) , url ) ; return - 1 ; } <S2SV_ModEnd> ",git@git/c44088ecc4b0722636e0a305f9608d3047197282,CVE-2020-11008,https://github.com/git/git/commit/c44088ecc4b0722636e0a305f9608d3047197282,2020-04-21T19:15Z
764,CWE-200,<S2SV_StartBug> struct static_key * done_key ) <S2SV_EndBug> <S2SV_StartBug> __net_random_once_disable_jump ( done_key ) ; <S2SV_EndBug> ,<S2SV_ModStart> once_key <S2SV_ModEnd> <S2SV_ModStart> once_key <S2SV_ModEnd> ,torvalds@linux/3d4405226d27b3a215e4d03cfa51f536244e5de7,CVE-2014-7284,https://github.com/torvalds/linux/commit/3d4405226d27b3a215e4d03cfa51f536244e5de7,2014-10-13T10:55Z
765,CWE-416,"<S2SV_StartBug> if ( io_data -> read && ret > 0 ) { <S2SV_EndBug> <S2SV_StartBug> ! ( io_data -> kiocb -> ki_flags & IOCB_EVENTFD ) ) <S2SV_EndBug> <S2SV_StartBug> usb_ep_free_request ( io_data -> ep , io_data -> req ) ; <S2SV_EndBug> ","<S2SV_ModStart> bool kiocb_has_eventfd = <S2SV_ModEnd> <S2SV_ModStart> ; if ( io_data -> read && ret > 0 ) { use_mm ( io_data -> mm ) ; ret = copy_to_iter ( io_data -> buf , ret , & io_data -> data ) ; if ( iov_iter_count ( & io_data -> data ) ) ret = - EFAULT ; unuse_mm ( io_data -> mm ) ; } io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ; if ( io_data -> ffs -> ffs_eventfd && ! kiocb_has_eventfd <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/38740a5b87d53ceb89eb2c970150f6e94e00373a,CVE-2016-7912,https://github.com/torvalds/linux/commit/38740a5b87d53ceb89eb2c970150f6e94e00373a,2016-11-16T05:59Z
766,CWE-17,<S2SV_StartBug> if ( rt -> rt_flags & RTCF_DOREDIRECT && ! opt -> srr && ! skb_sec_path ( skb ) ) <S2SV_EndBug> ,<S2SV_ModStart> IPCB ( skb ) -> flags & IPSKB_DOREDIRECT <S2SV_ModEnd> ,torvalds@linux/df4d92549f23e1c037e83323aff58a21b3de7fe0,CVE-2015-1465,https://github.com/torvalds/linux/commit/df4d92549f23e1c037e83323aff58a21b3de7fe0,2015-04-05T21:59Z
767,CWE-20,<S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,libreswan@libreswan/2899351224fe2940aec37d7656e1e392c0fe07f0,CVE-2013-7294,https://github.com/libreswan/libreswan/commit/2899351224fe2940aec37d7656e1e392c0fe07f0,2014-01-16T05:05Z
768,CWE-264,<S2SV_StartBug> struct trusted_key_payload * p = key -> payload . data [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> struct trusted_key_payload * new_p ; <S2SV_EndBug> ,"<S2SV_ModStart> p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY ; <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/096fe9eaea40a17e125569f9e657e34cdb6d73bd,CVE-2015-8539,https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd,2016-02-08T03:59Z
769,CWE-476,<S2SV_StartBug> v |= ( c << 24 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> JAS_CAST ( uint_fast32_t , c ) <S2SV_ModEnd> ",mdadams@jasper/8f62b4761711d036fd8964df256b938c809b7fca,CVE-2016-8690,https://github.com/mdadams/jasper/commit/8f62b4761711d036fd8964df256b938c809b7fca,2017-02-15T19:59Z
770,CWE-20,<S2SV_StartBug> while ( ( skb = skb_dequeue ( & loopback_queue ) ) != NULL ) { <S2SV_EndBug> <S2SV_StartBug> dest = ( rose_address * ) ( skb -> data + 4 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( skb -> len < ROSE_MIN_LEN ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> if ( frametype == ROSE_CALL_REQUEST && ( skb -> len <= ROSE_CALL_REQ_FACILITIES_OFF || skb -> data [ ROSE_CALL_REQ_ADDR_LEN_OFF ] != ROSE_CALL_REQ_ADDR_LEN_VAL ) ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> ROSE_CALL_REQ_DEST_ADDR_OFF <S2SV_ModEnd> ,torvalds@linux/e0bccd315db0c2f919e7fcf9cb60db21d9986f52,CVE-2011-4914,https://github.com/torvalds/linux/commit/e0bccd315db0c2f919e7fcf9cb60db21d9986f52,2012-06-21T23:55Z
771,CWE-399,"<S2SV_StartBug> kvm_arch_flush_shadow_memslot ( kvm , slot ) ; <S2SV_EndBug> <S2SV_StartBug> goto out_free ; <S2SV_EndBug> <S2SV_StartBug> if ( ! npages ) { <S2SV_EndBug> <S2SV_StartBug> out_free : <S2SV_EndBug> ","<S2SV_ModStart> kvm_iommu_unmap_pages ( kvm , & old ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_slots ; } if ( <S2SV_ModStart> out_slots : kfree ( slots ) ; ",torvalds@linux/e40f193f5bb022e927a57a4f5d5194e4f12ddb74,CVE-2013-4592,https://github.com/torvalds/linux/commit/e40f193f5bb022e927a57a4f5d5194e4f12ddb74,2013-11-20T13:19Z
772,CWE-000,<S2SV_StartBug> if ( indev != NULL ) { <S2SV_EndBug> ,<S2SV_ModStart> && indev -> ifa_list <S2SV_ModEnd> ,torvalds@linux/94f9cd81436c85d8c3a318ba92e236ede73752fc,CVE-2015-8787,https://github.com/torvalds/linux/commit/94f9cd81436c85d8c3a318ba92e236ede73752fc,2016-02-08T03:59Z
773,CWE-000,"<S2SV_StartBug> end = path ; <S2SV_EndBug> <S2SV_StartBug> switch ( tag ) { <S2SV_EndBug> <S2SV_StartBug> name = fdt_get_name ( fdt , offset , & len ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ",<S2SV_ModStart> bool expect_end = false ; <S2SV_ModStart> if ( expect_end && tag != FDT_END ) return - FDT_ERR_BADLAYOUT ; <S2SV_ModStart> ; if ( ! depth && * name ) return - FDT_ERR_BADLAYOUT <S2SV_ModStart> if ( depth == - 1 ) expect_end = true ; ,u-boot@u-boot/8a7d4cf9820ea16fabd25a6379351b4dc291204b,CVE-2021-27097,https://github.com/u-boot/u-boot/commit/8a7d4cf9820ea16fabd25a6379351b4dc291204b,2021-02-17T23:15Z
774,CWE-787,<S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff ",dbry@WavPack/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,CVE-2018-10540,https://github.com/dbry/WavPack/commit/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,2018-04-29T15:29Z
775,CWE-000,<S2SV_StartBug> if ( md_sk != NULL ) { <S2SV_EndBug> <S2SV_StartBug> if ( PKCS7_is_detached ( p7 ) || ( in_bio != NULL ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> data_body == NULL && in_bio == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; goto err ; } if ( <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",openssl@openssl/59302b600e8d5b77ef144e447bb046fd7ab72686,CVE-2015-1790,https://github.com/openssl/openssl/commit/59302b600e8d5b77ef144e447bb046fd7ab72686,2015-06-12T19:59Z
776,CWE-20,<S2SV_StartBug> if ( vmCanSwapOut ( ) ) { <S2SV_EndBug> <S2SV_StartBug> while ( server . vm_enabled && zmalloc_used_memory ( ) > <S2SV_EndBug> <S2SV_StartBug> server . vm_max_memory ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ds_enabled <S2SV_ModEnd> <S2SV_ModStart> cache_max_memory ) { cacheFreeOneEntry ( ) ; <S2SV_ModEnd> ,antirez@redis/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,CVE-2013-0178,https://github.com/antirez/redis/commit/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,2019-11-01T19:15Z
777,CWE-264,<S2SV_StartBug> if ( ( options -> flags & UV_PROCESS_SETGID ) && setgid ( options -> gid ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> options -> flags & ( UV_PROCESS_SETUID | UV_PROCESS_SETGID ) ) { SAVE_ERRNO ( setgroups ( 0 , NULL ) ) ; } if ( ",libuv@libuv/66ab38918c911bcff025562cf06237d7fedaba0c,CVE-2015-0278,https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c,2015-05-18T15:59Z
778,CWE-119,"<S2SV_StartBug> int ret , wo ; <S2SV_EndBug> <S2SV_StartBug> wo = ( rbuf == NULL || rlen == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( wo ) <S2SV_EndBug> <S2SV_StartBug> rbuf , rlen , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( rlen > MAX_XFER_SIZE ) { warn ( ""i2c<S2SV_blank>rd:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\n"" , rlen ) ; return - EOPNOTSUPP ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> st -> data <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( ! ret && rbuf && rlen ) memcpy ( rbuf , st -> data , rlen ",torvalds@linux/3f190e3aec212fc8c61e202c51400afa7384d4bc,CVE-2017-8063,https://github.com/torvalds/linux/commit/3f190e3aec212fc8c61e202c51400afa7384d4bc,2017-04-23T05:59Z
779,CWE-835,"<S2SV_StartBug> client -> priv -> protocol_timeout = g_timeout_add_seconds ( 5 , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,GNOME@gnome-session/b0dc999e0b45355314616321dbb6cb71e729fc9d,CVE-2017-11171,https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d,2017-07-11T20:29Z
780,CWE-200,<S2SV_StartBug> for ( j = 0 ; j < book -> dim ; j ++ ) <S2SV_EndBug> ,<S2SV_ModStart> && i < n ,external@tremolo/eeb4e45d5683f88488c083ecf142dc89bc3f0b47,CVE-2017-0814,https://android.googlesource.com/platform/external/tremolo/+/eeb4e45d5683f88488c083ecf142dc89bc3f0b47,2017-10-04T01:29Z
781,CWE-20,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> char * outpos = outputbuffer ; <S2SV_ModStart> sendClean ( outputbuffer ) ; ,TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z
782,CWE-310,<S2SV_StartBug> BUG_ON ( ret == - EEXIST ) ; <S2SV_EndBug> ,<S2SV_ModStart> || ret == - EOVERFLOW ,torvalds@linux/9c52057c698fb96f8f07e7a4bcf4801a092bda89,CVE-2012-5375,https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89,2013-02-18T11:56Z
783,CWE-119,<S2SV_StartBug> if ( s ) { <S2SV_EndBug> <S2SV_StartBug> struct unix_sock * u = unix_sk ( s ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock ( & unix_gc_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> spin_lock ( & unix_gc_lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } fp -> f_cred -> user -> unix_inflight -- ; <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/712f4aad406bb1ed67f3f98d04c044191f0ff593,CVE-2013-4312,https://github.com/torvalds/linux/commit/712f4aad406bb1ed67f3f98d04c044191f0ff593,2016-02-08T03:59Z
784,CWE-119,<S2SV_StartBug> { size_t chanmap_size = psf -> sf . channels * sizeof ( psf -> channel_map [ 0 ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> SF_MIN ( <S2SV_ModStart> , layout_tag & 0xffff ) ",erikd@libsndfile/f833c53cb596e9e1792949f762e0b33661822748,CVE-2017-6892,https://github.com/erikd/libsndfile/commit/f833c53cb596e9e1792949f762e0b33661822748,2017-06-12T16:29Z
785,CWE-119,"<S2SV_StartBug> if ( ! check_scale_factors ( other_w , other_h , this_w , this_h ) ) { <S2SV_EndBug> <S2SV_StartBug> sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve_copy ; <S2SV_EndBug> <S2SV_StartBug> sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve8_vert ; <S2SV_EndBug> <S2SV_StartBug> sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve8_horiz ; <S2SV_EndBug> <S2SV_StartBug> sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve8 ; <S2SV_EndBug> ",<S2SV_ModStart> # endif <S2SV_ModStart> valid_ref_frame_size <S2SV_ModEnd> <S2SV_ModStart> vpx_convolve_copy ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_convolve_avg ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_convolve8_vert ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_convolve8_avg_vert ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_convolve8_horiz ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_convolve8_avg_horiz <S2SV_ModEnd> <S2SV_ModStart> vpx_scaled_vert ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_vert ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_vert ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_vert ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d <S2SV_ModEnd> <S2SV_ModStart> vpx_scaled_horiz ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_horiz ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_horiz ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_horiz <S2SV_ModEnd> <S2SV_ModStart> vpx_scaled_2d ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d ; } } if ( ( sf -> x_step_q4 != 16 ) || ( sf -> y_step_q4 != 16 ) ) { sf -> predict [ 1 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; } else { sf -> predict [ 1 ] [ 1 ] [ 0 ] = vpx_convolve8 ; sf -> predict [ 1 ] [ 1 ] [ 1 ] = vpx_convolve8_avg ; } # if CONFIG_VP9_HIGHBITDEPTH if ( use_highbd ) { if ( sf -> x_step_q4 == 16 ) { if ( sf -> y_step_q4 == 16 ) { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve_copy ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve_avg ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; } else { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; } } else { if ( sf -> y_step_q4 == 16 ) { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; } else { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; } } sf -> highbd_predict [ 1 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; } # endif <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
786,CWE-787,<S2SV_StartBug> int32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ; <S2SV_EndBug> ,<S2SV_ModStart> uint32_t <S2SV_ModEnd> <S2SV_ModStart> uint32_t <S2SV_ModEnd> ,gopro@gpmf-parser/341f12cd5b97ab419e53853ca00176457c9f1681,CVE-2019-15148,https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681,2019-08-18T19:15Z
787,CWE-399,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
788,CWE-119,<S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ip6t_entry ) && <S2SV_EndBug> <S2SV_StartBug> t -> verdict < 0 && <S2SV_EndBug> ,<S2SV_ModStart> unconditional ( e <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z
789,CWE-787,"<S2SV_StartBug> pdf -> xrefs = calloc ( 1 , sizeof ( xref_t ) * pdf -> n_xrefs ) ; <S2SV_EndBug> ",<S2SV_ModStart> safe_calloc ( <S2SV_ModEnd> ,enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6,CVE-2019-14934,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,2019-08-11T22:15Z
790,CWE-552,<S2SV_StartBug> if ( ! sock || ( count && ! buf ) ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ,<S2SV_ModStart> || count > OE_SSIZE_MAX <S2SV_ModStart> if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } ,openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z
791,CWE-416,"<S2SV_StartBug> opt = xchg ( & np -> opt , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt ) <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ( __force struct ipv6_txoptions * * ) <S2SV_ModStart> { atomic_sub ( <S2SV_ModEnd> <S2SV_ModStart> , & sk -> sk_omem_alloc ) ; txopt_put ( opt <S2SV_ModStart> } ",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
792,CWE-399,"<S2SV_StartBug> BIO * cmsbio = NULL , * tmpin = NULL ; <S2SV_EndBug> <S2SV_StartBug> cmsbio = CMS_dataInit ( cms , tmpin ) ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( dcont && ( tmpin == dcont ) ) <S2SV_EndBug> <S2SV_StartBug> if ( cms_certs ) <S2SV_EndBug> ","<S2SV_ModStart> = NULL , * tmpout <S2SV_ModStart> if ( ! ( flags & SMIME_BINARY ) && dcont ) { tmpout = cms_get_text_bio ( out , flags ) ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } <S2SV_ModStart> tmpout ) ; if ( ! cmsbio ) goto err ; SMIME_crlf_copy ( dcont , cmsbio , flags & ~ SMIME_TEXT ) ; if ( flags & CMS_TEXT ) { if ( ! SMIME_text ( tmpout , out ) ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SMIME_TEXT_ERROR ) ; goto err ; } } } else { cmsbio = CMS_dataInit ( cms , <S2SV_ModStart> } <S2SV_ModStart> ! ( flags & SMIME_BINARY ) && dcont ) { do_free_upto ( cmsbio , tmpout ) ; if ( tmpin != dcont ) BIO_free ( tmpin ) ; } else { if ( <S2SV_ModStart> } if ( tmpout && out != tmpout ) BIO_free_all ( tmpout ) ; ",openssl@openssl/cd30f03ac5bf2962f44bd02ae8d88245dff2f12c,CVE-2015-1792,https://github.com/openssl/openssl/commit/cd30f03ac5bf2962f44bd02ae8d88245dff2f12c,2015-06-12T19:59Z
793,CWE-416,"<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> len = ipv6_getsockopt_sticky ( sk , np -> opt , <S2SV_EndBug> ","<S2SV_ModStart> struct ipv6_txoptions * opt ; <S2SV_ModStart> opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
794,CWE-119,<S2SV_StartBug> unregister_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> <S2SV_StartBug> sctp_v4_protosw_exit ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> sctp_ctrlsock_ops <S2SV_ModEnd> <S2SV_ModStart> ) ; unregister_pernet_subsys ( & sctp_defaults_ops ,torvalds@linux/8e2d61e0aed2b7c4ecb35844fe07e0b2b762dee4,CVE-2015-5283,https://github.com/torvalds/linux/commit/8e2d61e0aed2b7c4ecb35844fe07e0b2b762dee4,2015-10-19T10:59Z
795,CWE-284,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> add_bool_conf_item ( ""ANOPE_FLAGS_COMPAT"" , & chansvs . me -> conf_table , 0 , & anope_flags_compat , true ) ; hook_add_event ( ""nick_can_register"" ) ; hook_add_nick_can_register ( check_registration_keywords ) ; hook_add_event ( ""user_can_register"" ) ; hook_add_user_can_register ( check_registration_keywords ) ; ",atheme@atheme/c597156adc60a45b5f827793cd420945f47bc03b,CVE-2014-9773,https://github.com/atheme/atheme/commit/c597156adc60a45b5f827793cd420945f47bc03b,2016-06-13T19:59Z
796,CWE-399,"<S2SV_StartBug> struct net_device * dev = ( ( struct in_ifaddr * ) ptr ) -> ifa_dev -> dev ; <S2SV_EndBug> <S2SV_StartBug> netdev_notifier_info_init ( & info , dev ) ; <S2SV_EndBug> ",<S2SV_ModStart> in_device * idev <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( idev -> dead ) return NOTIFY_DONE ; <S2SV_ModStart> idev -> ,torvalds@linux/fbd40ea0180a2d328c5adc61414dc8bab9335ce2,CVE-2016-3156,https://github.com/torvalds/linux/commit/fbd40ea0180a2d328c5adc61414dc8bab9335ce2,2016-04-27T17:59Z
797,CWE-362,<S2SV_StartBug> if ( current -> active_mm != mm ) <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> ,<S2SV_ModStart> { smp_mb ( ) ; <S2SV_ModStart> } <S2SV_ModStart> smp_mb ( ) ; ,torvalds@linux/71b3c126e61177eb693423f2e18a1914205b165e,CVE-2016-2069,https://github.com/torvalds/linux/commit/71b3c126e61177eb693423f2e18a1914205b165e,2016-04-27T17:59Z
798,CWE-119,"<S2SV_StartBug> static void show_psnr ( struct stream_state * stream ) { <S2SV_EndBug> <S2SV_StartBug> ovpsnr = sse_to_psnr ( ( double ) stream -> psnr_samples_total , 255.0 , <S2SV_EndBug> ","<S2SV_ModStart> , double peak <S2SV_ModStart> peak <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
799,CWE-119,<S2SV_StartBug> char temp [ 500 ] ; <S2SV_EndBug> <S2SV_StartBug> temp [ i ] = fgetc ( fp ) ; <S2SV_EndBug> ,"<S2SV_ModStart> int temp_size = 500 ; char * temp = malloc ( temp_size ) <S2SV_ModEnd> <S2SV_ModStart> if ( i >= temp_size ) { temp_size *= 2 ; temp = realloc ( temp , temp_size ) ; } ",kmatheussen@das_watchdog/bd20bb02e75e2c0483832b52f2577253febfb690,CVE-2015-2831,https://github.com/kmatheussen/das_watchdog/commit/bd20bb02e75e2c0483832b52f2577253febfb690,2015-04-14T18:59Z
800,CWE-362,<S2SV_StartBug> if ( ! del_timer ( & task -> slow_task -> timer ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/b90cd6f2b905905fb42671009dc0e27c310a16ae,CVE-2018-20836,https://github.com/torvalds/linux/commit/b90cd6f2b905905fb42671009dc0e27c310a16ae,2019-05-07T14:29Z
801,CWE-787,<S2SV_StartBug> dst_name = malloc ( strlen ( name ) * 2 + 16 ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> ,enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6,CVE-2019-14934,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,2019-08-11T22:15Z
802,CWE-617,"<S2SV_StartBug> assert ( errno == ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> ""for<S2SV_blank>management<S2SV_blank>address"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; else log_warn ( ""lldp"" , ""too<S2SV_blank>large<S2SV_blank>management<S2SV_blank>address<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ",vincentbernat@lldpd/793526f8884455f43daecd0a2c46772388417a00,CVE-2015-8012,https://github.com/vincentbernat/lldpd/commit/793526f8884455f43daecd0a2c46772388417a00,2020-01-28T19:15Z
803,CWE-787,<S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> <S2SV_StartBug> if ( * object + size * 2 > bplist -> offset_table ) { <S2SV_EndBug> <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> ,"<S2SV_ModStart> < * object || * object + size <S2SV_ModStart> * object + size < * object || <S2SV_ModStart> < * object || * object + size * 2 <S2SV_ModStart> < * object || * object + size <S2SV_ModStart> < * object || * object + size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DICT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" <S2SV_ModEnd> ",libimobiledevice@libplist/32ee5213fe64f1e10ec76c1ee861ee6f233120dd,CVE-2017-6439,https://github.com/libimobiledevice/libplist/commit/32ee5213fe64f1e10ec76c1ee861ee6f233120dd,2017-03-15T14:59Z
804,CWE-20,"<S2SV_StartBug> TRACE_DEBUG ( ""CIDER=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_CIDER ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""PHY1ILR=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_PHY1ILR ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""PHY1IHR=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_PHY1IHR ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ksz8851ReadReg ( interface , KSZ8851_REG_CIDER ) != KSZ8851_REV_A3_ID ) <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MARH , htons ( interface -> macAddr . w [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MARM , htons ( interface -> macAddr . w [ 1 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MARL , htons ( interface -> macAddr . w [ 2 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_TXCR , TXCR_TXFCE | TXCR_TXPE | TXCR_TXCE ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851ClearBit ( interface , KSZ8851_REG_P1CR , P1CR_FORCE_DUPLEX ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_P1CR , P1CR_RESTART_AN ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_ISR , ISR_LCIS | ISR_TXIS | <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_IER , IER_LCIE | IER_TXIE | IER_RXIE ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_TXCR , TXCR_TXE ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXCR1 , RXCR1_RXE ) ; <S2SV_EndBug> ","<S2SV_ModStart> KSZ8851_CIDER <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_PHY1ILR <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_PHY1IHR <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_CIDER ) != ( KSZ8851_CIDER_FAMILY_ID_DEFAULT | KSZ8851_CIDER_CHIP_ID_DEFAULT | KSZ8851_CIDER_REV_ID_A3 ) <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_MARH <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_MARM <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_MARL <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_TXCR , KSZ8851_TXCR_TXFCE | KSZ8851_TXCR_TXPE | KSZ8851_TXCR_TXCE ) ; ksz8851WriteReg ( interface , KSZ8851_TXFDPR , KSZ8851_TXFDPR_TXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_RXCR1 , KSZ8851_RXCR1_RXPAFMA | KSZ8851_RXCR1_RXFCE | KSZ8851_RXCR1_RXBE | KSZ8851_RXCR1_RXME | KSZ8851_RXCR1_RXUE ) ; ksz8851WriteReg ( interface , KSZ8851_RXCR2 , KSZ8851_RXCR2_SRDBL_SINGLE_FRAME | KSZ8851_RXCR2_IUFFP | KSZ8851_RXCR2_RXIUFCEZ ) ; ksz8851WriteReg ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_RXFCTE | KSZ8851_RXQCR_ADRFE ) ; ksz8851WriteReg ( interface , KSZ8851_RXFDPR , KSZ8851_RXFDPR_RXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_RXFCTR <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_P1CR , KSZ8851_P1CR_FORCE_DUPLEX <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_P1CR , KSZ8851_P1CR_RESTART_AN <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_ISR , KSZ8851_ISR_LCIS | KSZ8851_ISR_TXIS | KSZ8851_ISR_RXIS | KSZ8851_ISR_RXOIS | KSZ8851_ISR_TXPSIS | KSZ8851_ISR_RXPSIS | KSZ8851_ISR_TXSAIS | KSZ8851_ISR_RXWFDIS | KSZ8851_ISR_RXMPDIS | KSZ8851_ISR_LDIS | KSZ8851_ISR_EDIS | KSZ8851_ISR_SPIBEIS <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_IER , KSZ8851_IER_LCIE | KSZ8851_IER_TXIE | KSZ8851_IER_RXIE <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_TXCR , KSZ8851_TXCR_TXE <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXCR1 , KSZ8851_RXCR1_RXE <S2SV_ModEnd> ",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
805,CWE-416,<S2SV_StartBug> pch -> file . dead = 1 ; <S2SV_EndBug> ,<S2SV_ModStart> put_net ( pch -> chan_net ) ; pch -> chan_net = NULL ; ,torvalds@linux/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,CVE-2016-4805,https://github.com/torvalds/linux/commit/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,2016-05-23T10:59Z
806,CWE-362,"<S2SV_StartBug> struct btrfs_dir_item * di ; <S2SV_EndBug> <S2SV_StartBug> if ( flags & XATTR_REPLACE ) { <S2SV_EndBug> <S2SV_StartBug> di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , <S2SV_EndBug> <S2SV_StartBug> } else if ( ! di ) { <S2SV_EndBug> <S2SV_StartBug> ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ; <S2SV_EndBug> <S2SV_StartBug> btrfs_release_path ( path ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( flags & XATTR_CREATE ) <S2SV_EndBug> <S2SV_StartBug> btrfs_release_path ( path ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( ! di ) { <S2SV_EndBug> <S2SV_StartBug> if ( value ) { <S2SV_EndBug> ","<S2SV_ModStart> = NULL <S2SV_ModStart> path -> skip_release_on_error = 1 ; if ( ! value ) { di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ; if ( ! di && <S2SV_ModEnd> <S2SV_ModStart> ) ret = - ENODATA ; else if ( di ) ret = btrfs_delete_one_dir_name <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( flags & XATTR_REPLACE ) { ASSERT ( mutex_is_locked ( & inode -> i_mutex ) ) ; di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ; <S2SV_ModEnd> <S2SV_ModStart> btrfs_release_path ( path ) ; di = NULL ; } ret = btrfs_insert_xattr_item <S2SV_ModEnd> <S2SV_ModStart> btrfs_ino ( inode ) , name , name_len , value , size ) ; if ( ret == - EOVERFLOW ) { ret = 0 ; btrfs_assert_tree_locked ( path -> nodes [ 0 ] ) ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; if ( ! di && ! ( flags & XATTR_REPLACE ) ) { ret = - ENOSPC ; <S2SV_ModEnd> <S2SV_ModStart> } } else if ( ret == - EEXIST ) { ret = 0 ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; ASSERT ( di ) ; } else if ( ret ) { <S2SV_ModEnd> <S2SV_ModStart> if ( di && <S2SV_ModEnd> <S2SV_ModStart> ) { ret = - EEXIST ; <S2SV_ModStart> } if ( di ) { const int slot = path -> slots [ 0 ] ; struct extent_buffer * leaf = path -> nodes [ 0 ] ; const u16 old_data_len = btrfs_dir_data_len ( leaf , di ) ; const u32 item_size = btrfs_item_size_nr ( leaf , slot ) ; const u32 data_size = sizeof ( * di ) + name_len + size ; struct btrfs_item * item ; unsigned long data_ptr ; char * ptr ; if ( size > old_data_len ) { if ( btrfs_leaf_free_space ( root , leaf ) < ( size - old_data_len ) ) { ret = - ENOSPC <S2SV_ModEnd> <S2SV_ModStart> } if ( old_data_len + name_len + sizeof ( * di ) == item_size ) { if ( size > old_data_len ) btrfs_extend_item ( root , path , size - old_data_len ) ; <S2SV_ModStart> size < old_data_len ) btrfs_truncate_item ( root , path , data_size , 1 ) ; } else { <S2SV_ModEnd> <S2SV_ModStart> btrfs_extend_item ( root , path , data_size ) ; } item = btrfs_item_nr ( slot ) ; ptr = btrfs_item_ptr ( leaf , slot , char ) ; ptr += btrfs_item_size ( leaf , item ) - data_size ; di = ( struct btrfs_dir_item * ) ptr ; btrfs_set_dir_data_len ( leaf , di , size ) ; data_ptr = ( ( unsigned long ) ( di + 1 ) ) + name_len ; write_extent_buffer ( leaf , value , data_ptr , size ) ; btrfs_mark_buffer_dirty ( leaf ) ; } else { <S2SV_ModEnd> ",torvalds@linux/5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339,CVE-2014-9710,https://github.com/torvalds/linux/commit/5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339,2015-05-27T10:59Z
807,CWE-125,"<S2SV_StartBug> if ( op -> op > 0xbf ) return 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( n > 0 && n < buf_len ) ) goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) ) goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( op -> len + n <= buf_len ) ) goto beach ; <S2SV_EndBug> <S2SV_StartBug> op -> len += n ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( n > 0 && n + op -> len < buf_len ) ) goto beach ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < count && strlen ( op -> txt ) < R_ASM_BUFSIZE ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d<S2SV_blank>"" , table [ i ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> + 10 <S2SV_ModStart> int optxtlen = strlen ( op -> txt ) ; <S2SV_ModStart> optxtlen , R_ASM_BUFSIZE - optxtlen <S2SV_ModEnd> ",radare@radare2/52b1526443c1f433087928291d1c3d37a5600515,CVE-2017-15368,https://github.com/radare/radare2/commit/52b1526443c1f433087928291d1c3d37a5600515,2017-10-16T01:29Z
808,CWE-436,<S2SV_StartBug> g_clear_object ( & client -> proxy ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; g_byte_array_free ( client -> auth_buffer , TRUE ",flatpak@flatpak/52346bf187b5a7f1c0fe9075b328b7ad6abe78f6,CVE-2018-6560,https://github.com/flatpak/flatpak/commit/52346bf187b5a7f1c0fe9075b328b7ad6abe78f6,2018-02-02T14:29Z
809,CWE-119,"<S2SV_StartBug> vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , encode_block_intra , <S2SV_EndBug> ",<S2SV_ModStart> vp9_encode_block_intra <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
810,CWE-20,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> ",<S2SV_ModStart> key_is_negative ( key <S2SV_ModEnd> ,torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z
811,CWE-190,<S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( t + 3 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( 2 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( 2 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( 2 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( likely ( HAVE_OP ( t + 15 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( HAVE_IP ( 6 ) ) { <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> <S2SV_StartBug> if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( t + 3 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , 0 <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , 0 <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , 0 ",torvalds@linux/206a81c18401c0cde6e579164f752c4b147324ce,CVE-2014-4608,https://github.com/torvalds/linux/commit/206a81c18401c0cde6e579164f752c4b147324ce,2014-07-03T04:22Z
812,CWE-000,"<S2SV_StartBug> if ( fit_check_format ( fit , IMAGE_SIZE_INVAL ) ) { <S2SV_EndBug> <S2SV_StartBug> printf ( ""Bad<S2SV_blank>FIT<S2SV_blank>%s<S2SV_blank>image<S2SV_blank>format!\\n"" , prop_name ) ; <S2SV_EndBug> <S2SV_StartBug> return - ENOEXEC ; <S2SV_EndBug> ","<S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> ; if ( ret <S2SV_ModStart> ""Bad<S2SV_blank>FIT<S2SV_blank>%s<S2SV_blank>image<S2SV_blank>format!<S2SV_blank>(err=%d)\\n"" , prop_name , ret ) ; if ( CONFIG_IS_ENABLED ( FIT_SIGNATURE ) && ret == - EADDRNOTAVAIL ) printf ( ""Signature<S2SV_blank>checking<S2SV_blank>prevents<S2SV_blank>use<S2SV_blank>of<S2SV_blank>unit<S2SV_blank>addresses<S2SV_blank>(@)<S2SV_blank>in<S2SV_blank>nodes\\n"" <S2SV_ModEnd> <S2SV_ModStart> ret <S2SV_ModEnd> ",u-boot@u-boot/3f04db891a353f4b127ed57279279f851c6b4917,CVE-2021-27138,https://github.com/u-boot/u-boot/commit/3f04db891a353f4b127ed57279279f851c6b4917,2021-02-17T23:15Z
813,CWE-119,<S2SV_StartBug> vpn_packet_t outpkt ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( len > sizeof outpkt . data ) return ,gsliepen@tinc/17a33dfd95b1a29e90db76414eb9622df9632320,CVE-2013-1428,https://github.com/gsliepen/tinc/commit/17a33dfd95b1a29e90db76414eb9622df9632320,2013-04-26T16:55Z
814,CWE-264,<S2SV_StartBug> if ( enable_apicv ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/3ce424e45411cf5a13105e0386b6ecf6eeb4f66f,CVE-2016-4440,https://github.com/torvalds/linux/commit/3ce424e45411cf5a13105e0386b6ecf6eeb4f66f,2016-06-27T10:59Z
815,CWE-476,"<S2SV_StartBug> for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> <S2SV_StartBug> if ( vdaux < 1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> ",<S2SV_ModStart> end - <S2SV_ModStart> > i <S2SV_ModEnd> <S2SV_ModStart> || ( char * ) UINTPTR_MAX - vstart < vdaux <S2SV_ModStart> end - vstart < <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> end - vstart < <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,radare@radare2/62e39f34b2705131a2d08aff0c2e542c6a52cf0e,CVE-2017-16359,https://github.com/radare/radare2/commit/62e39f34b2705131a2d08aff0c2e542c6a52cf0e,2017-11-01T17:29Z
816,CWE-284,"<S2SV_StartBug> ioctl ( uinput_fd , UI_DEV_DESTROY ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ,system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
817,CWE-119,<S2SV_StartBug> ( rc -> av_per_frame_bandwidth * rc -> baseline_gf_interval * af_ratio ) / <S2SV_EndBug> <S2SV_StartBug> ( rc -> av_per_frame_bandwidth * rc -> baseline_gf_interval ) / <S2SV_EndBug> <S2SV_StartBug> target = rc -> av_per_frame_bandwidth ; <S2SV_EndBug> ,<S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
818,CWE-668,"<S2SV_StartBug> if ( strcmp ( argv [ i ] , ""--allow-untrusted"" ) == 0 ) <S2SV_EndBug> ",<S2SV_ModStart> check_option ( argv [ i ] <S2SV_ModEnd> ,sroracle@abuild/4f90ce92778d0ee302e288def75591b96a397c8b,CVE-2019-12875,https://github.com/sroracle/abuild/commit/4f90ce92778d0ee302e288def75591b96a397c8b,2019-06-18T19:15Z
819,CWE-125,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> ,python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
820,CWE-835,<S2SV_StartBug> offset = tbl -> indent ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( tbl -> indent < 0 ) tbl -> indent = 0 ; <S2SV_ModStart> if ( offset < 0 ) offset = 0 ; ,tats@w3m/8354763b90490d4105695df52674d0fcef823e92,CVE-2018-6196,https://github.com/tats/w3m/commit/8354763b90490d4105695df52674d0fcef823e92,2018-01-25T03:29Z
821,CWE-189,"<S2SV_StartBug> ( void ) & line ; <S2SV_EndBug> <S2SV_StartBug> if ( e >= b && ( size_t ) ( e - b ) <= CDF_SEC_SIZE ( h ) * sst -> sst_len ) <S2SV_EndBug> <S2SV_StartBug> CDF_SEC_SIZE ( h ) * sst -> sst_len , CDF_SEC_SIZE ( h ) , sst -> sst_len ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> size_t ss = sst -> sst_dirlen < h -> h_min_size_standard_stream ? CDF_SHORT_SEC_SIZE ( h ) : CDF_SEC_SIZE ( h ) ; <S2SV_ModStart> ss <S2SV_ModEnd> <S2SV_ModStart> ss <S2SV_ModEnd> <S2SV_ModStart> ss <S2SV_ModEnd> ,file@file/36fadd29849b8087af9f4586f89dbf74ea45be67,CVE-2014-3479,https://github.com/file/file/commit/36fadd29849b8087af9f4586f89dbf74ea45be67,2014-07-09T11:07Z
822,CWE-674,"<S2SV_StartBug> # line 106 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1330 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 115 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1338 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 119 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1351 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 128 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ; <S2SV_EndBug> <S2SV_StartBug> # line 1413 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 190 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1421 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 194 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1434 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 207 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1442 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 211 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1451 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 220 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1468 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 233 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1476 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 237 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1485 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 246 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1512 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 269 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1548 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 301 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1574 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 323 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1594 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 343 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1602 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 347 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; <S2SV_EndBug> <S2SV_StartBug> # line 1617 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 361 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1629 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 369 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1653 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1657 ""hex_grammar.c"" <S2SV_EndBug> ","<S2SV_ModStart> 113 <S2SV_ModEnd> <S2SV_ModStart> 1337 <S2SV_ModEnd> <S2SV_ModStart> 122 <S2SV_ModEnd> <S2SV_ModStart> 1345 <S2SV_ModEnd> <S2SV_ModStart> 126 ""hex_grammar.y"" { incr_ast_levels ( ) ; <S2SV_ModEnd> <S2SV_ModStart> 1360 <S2SV_ModEnd> <S2SV_ModStart> 137 <S2SV_ModEnd> <S2SV_ModStart> ) ; incr_ast_levels ( <S2SV_ModStart> 1424 <S2SV_ModEnd> <S2SV_ModStart> 201 <S2SV_ModEnd> <S2SV_ModStart> 1432 <S2SV_ModEnd> <S2SV_ModStart> 205 ""hex_grammar.y"" { incr_ast_levels ( ) ; <S2SV_ModEnd> <S2SV_ModStart> 1447 <S2SV_ModEnd> <S2SV_ModStart> 220 <S2SV_ModEnd> <S2SV_ModStart> 1455 <S2SV_ModEnd> <S2SV_ModStart> 224 <S2SV_ModEnd> <S2SV_ModStart> 1464 <S2SV_ModEnd> <S2SV_ModStart> 233 <S2SV_ModEnd> <S2SV_ModStart> 1481 <S2SV_ModEnd> <S2SV_ModStart> 246 <S2SV_ModEnd> <S2SV_ModStart> 1489 <S2SV_ModEnd> <S2SV_ModStart> 250 <S2SV_ModEnd> <S2SV_ModStart> 1498 <S2SV_ModEnd> <S2SV_ModStart> 259 <S2SV_ModEnd> <S2SV_ModStart> 1525 <S2SV_ModEnd> <S2SV_ModStart> 282 <S2SV_ModEnd> <S2SV_ModStart> 1561 <S2SV_ModEnd> <S2SV_ModStart> 314 <S2SV_ModEnd> <S2SV_ModStart> 1587 <S2SV_ModEnd> <S2SV_ModStart> 336 <S2SV_ModEnd> <S2SV_ModStart> 1607 <S2SV_ModEnd> <S2SV_ModStart> 356 <S2SV_ModEnd> <S2SV_ModStart> 1615 <S2SV_ModEnd> <S2SV_ModStart> 360 <S2SV_ModEnd> <S2SV_ModStart> incr_ast_levels ( ) ; <S2SV_ModStart> 1631 <S2SV_ModEnd> <S2SV_ModStart> 375 <S2SV_ModEnd> <S2SV_ModStart> 1643 <S2SV_ModEnd> <S2SV_ModStart> 383 <S2SV_ModEnd> <S2SV_ModStart> 1667 <S2SV_ModEnd> <S2SV_ModStart> 1671 <S2SV_ModEnd> ",VirusTotal@yara/10e8bd3071677dd1fa76beeef4bc2fc427cea5e7,CVE-2017-9438,https://github.com/VirusTotal/yara/commit/10e8bd3071677dd1fa76beeef4bc2fc427cea5e7,2017-06-05T17:29Z
823,CWE-119,<S2SV_StartBug> # if 0 <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
824,CWE-000,"<S2SV_StartBug> strncpy ( buff , opt_basedir , sizeof ( buff ) - 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( buff , 0 , sizeof ( buff ) ) ; ",mysql@mysql-server/0dbd5a8797ed4bd18e8b883988fb62177eb0f73f,CVE-2016-0546,https://github.com/mysql/mysql-server/commit/0dbd5a8797ed4bd18e8b883988fb62177eb0f73f,2016-01-21T03:01Z
825,CWE-20,"<S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> ",<S2SV_ModStart> key_is_positive ( key <S2SV_ModEnd> ,torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z
826,CWE-200,<S2SV_StartBug> struct hci_filter * f = & hci_pi ( sk ) -> filter ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & uf , 0 , sizeof ( uf ) ) ",torvalds@linux/e15ca9a0ef9a86f0477530b0f44a725d67f889ee,CVE-2012-6544,https://github.com/torvalds/linux/commit/e15ca9a0ef9a86f0477530b0f44a725d67f889ee,2013-03-15T20:55Z
827,CWE-119,"<S2SV_StartBug> int n = ( int ) ( data_end - data ) ; <S2SV_EndBug> <S2SV_StartBug> clear += 7 ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & xd -> pre , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & xd -> dst , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & pc -> lfc , & pc -> fc , sizeof ( pc -> fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pc -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) * pc -> mb_cols ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & pc -> fc , & pc -> lfc , sizeof ( pc -> fc ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> MIN ( sizeof ( clear_buffer ) , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
828,CWE-772,"<S2SV_StartBug> gss_buffer_desc client_name , service_name ; <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> <S2SV_StartBug> exit_func : <S2SV_EndBug> ",<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : <S2SV_ModStart>  <S2SV_ModEnd> ,krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z
829,CWE-000,<S2SV_StartBug> asoc -> peer . i = new -> peer . i ; <S2SV_EndBug> ,<S2SV_ModStart> auth_capable = new -> peer . auth_capable ; asoc -> peer . ,torvalds@linux/1be9a950c646c9092fb3618197f7b6bfb50e82aa,CVE-2014-5077,https://github.com/torvalds/linux/commit/1be9a950c646c9092fb3618197f7b6bfb50e82aa,2014-08-01T11:13Z
830,CWE-20,<S2SV_StartBug> if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( <S2SV_ModStart> ) ,torvalds@linux/b4789b8e6be3151a955ade74872822f30e8cd914,CVE-2013-6380,https://github.com/torvalds/linux/commit/b4789b8e6be3151a955ade74872822f30e8cd914,2013-11-27T04:43Z
831,CWE-119,<S2SV_StartBug> assert ( ( cc0 % rowsize ) == 0 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""PredictorEncodeTile"" , ""%s"" , ""(cc0%rowsize)!=0"" ) ; return 0 ; } <S2SV_ModEnd> ",vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1,CVE-2016-9535,https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1,2016-11-22T19:59Z
832,CWE-362,<S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> sock * sk = asoc -> base . sk ; struct <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/635682a14427d241bab7bbdeebb48a7d7b91638e,CVE-2015-8767,https://github.com/torvalds/linux/commit/635682a14427d241bab7bbdeebb48a7d7b91638e,2016-02-08T03:59Z
833,CWE-125,"<S2SV_StartBug> size_t input_size , <S2SV_EndBug> <S2SV_StartBug> # define prolog if ( bytes_matched >= max_bytes_matched ) { action = ACTION_KILL ; break ; } <S2SV_EndBug> <S2SV_StartBug> # define fail_if_error ( e ) switch ( e ) { case ERROR_INSUFFICIENT_MEMORY : return - 2 ; case ERROR_TOO_MANY_RE_FIBERS : return - 4 ; } <S2SV_EndBug> <S2SV_StartBug> input -= character_size ; <S2SV_EndBug> <S2SV_StartBug> max_bytes_matched = ( int ) yr_min ( input_size , RE_SCAN_LIMIT ) ; <S2SV_EndBug> <S2SV_StartBug> match = IS_WORD_CHAR ( * input ) ; <S2SV_EndBug> <S2SV_StartBug> match = ! IS_WORD_CHAR ( * input ) ; <S2SV_EndBug> <S2SV_StartBug> ! ( flags & RE_FLAGS_NOT_AT_START ) && <S2SV_EndBug> <S2SV_StartBug> match = TRUE ; <S2SV_EndBug> <S2SV_StartBug> match = TRUE ; <S2SV_EndBug> <S2SV_StartBug> else if ( IS_WORD_CHAR ( * ( input - input_incr ) ) != IS_WORD_CHAR ( * input ) ) <S2SV_EndBug> <S2SV_StartBug> kill = input_size > ( size_t ) bytes_matched ; <S2SV_EndBug> <S2SV_StartBug> kill = ( flags & RE_FLAGS_NOT_AT_START ) || ( bytes_matched != 0 ) ; <S2SV_EndBug> <S2SV_StartBug> input_size > ( size_t ) bytes_matched ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> <S2SV_ModStart> { if ( <S2SV_ModEnd> <S2SV_ModStart> || ( character_size == 2 && * ( input + 1 ) != 0 ) ) { action = ACTION_KILL ; break ; } <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> max_bytes_matched = ( int ) yr_min ( input_backwards_size , RE_SCAN_LIMIT ) ; <S2SV_ModStart> else { <S2SV_ModStart> input_forwards_size <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> <S2SV_ModStart> _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> <S2SV_ModStart> input_backwards_size < character_size ) { <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } else { assert ( input < input_data + input_forwards_size ) ; assert ( input >= input_data - input_backwards_size ) ; assert <S2SV_ModEnd> <S2SV_ModStart> < input_data + input_forwards_size ) ; assert ( input - input_incr >= input_data - input_backwards_size ) ; match = _yr_re_is_word_char ( input , character_size ) != _yr_re_is_word_char ( input - input_incr , character_size ) ; } <S2SV_ModEnd> <S2SV_ModStart> input_backwards_size <S2SV_ModEnd> <S2SV_ModStart> input_backwards_size > 0 <S2SV_ModEnd> <S2SV_ModStart> input_forwards_size <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",VirusTotal@yara/83d799804648c2a0895d40a19835d9b757c6fa4e,CVE-2017-8294,https://github.com/VirusTotal/yara/commit/83d799804648c2a0895d40a19835d9b757c6fa4e,2017-04-27T14:59Z
834,CWE-119,"<S2SV_StartBug> int * returndistortion , int * returnintra ) <S2SV_EndBug> <S2SV_StartBug> unsigned int zero_mv_sse = INT_MAX , best_sse = INT_MAX , <S2SV_EndBug> <S2SV_StartBug> best_rd_sse = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( & best_mode . mbmode , 0 , sizeof ( best_mode . mbmode ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( & best_mode . bmodes , 0 , sizeof ( best_mode . bmodes ) ) ; <S2SV_EndBug> <S2SV_StartBug> mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; <S2SV_EndBug> <S2SV_StartBug> if ( x -> best_sse_inter_mode == DC_PRED ) <S2SV_EndBug> <S2SV_StartBug> recon_yoffset , recon_uvoffset ) ; <S2SV_EndBug> <S2SV_StartBug> best_mode_index = mode_index ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mode . mbmode , sizeof ( MB_MODE_INFO ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( x -> partition_info , & best_mode . partition , sizeof ( PARTITION_INFO ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int mb_row , int mb_col <S2SV_ModStart> UINT_MAX <S2SV_ModEnd> <S2SV_ModStart> UINT_MAX <S2SV_ModEnd> <S2SV_ModStart> UINT_MAX <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int block_index = mb_row * cpi -> common . mb_cols + mb_col ; <S2SV_ModStart> , & cpi -> common . lf_info , mb_row , mb_col , block_index <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
835,CWE-399,"<S2SV_StartBug> set_exception_intercept ( svm , MC_VECTOR ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; set_exception_intercept ( svm , AC_VECTOR ",torvalds@linux/54a20552e1eae07aa240fa370a0293e006b5faed,CVE-2015-5307,https://github.com/torvalds/linux/commit/54a20552e1eae07aa240fa370a0293e006b5faed,2015-11-16T11:59Z
836,CWE-119,<S2SV_StartBug> h -> size = statbuf . st_size ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( h -> size < 0x2000 ) { SET_ERRNO ( EINVAL , ""%s:<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file"" , filename ) ; goto error ; } ",libguestfs@hivex/357f26fa64fd1d9ccac2331fe174a8ee9c607adb,CVE-2014-9273,https://github.com/libguestfs/hivex/commit/357f26fa64fd1d9ccac2331fe174a8ee9c607adb,2014-12-08T16:59Z
837,CWE-119,"<S2SV_StartBug> const cdf_stream_t * sst , const uint64_t clsid [ 2 ] ) <S2SV_EndBug> <S2SV_StartBug> str = cdf_clsid_to_mime ( clsid , clsid2desc ) ; <S2SV_EndBug> <S2SV_StartBug> return - 2 ; <S2SV_EndBug> <S2SV_StartBug> m = cdf_file_property_info ( ms , info , count , clsid ) ; <S2SV_EndBug> ",<S2SV_ModStart> cdf_directory_t * root_storage <S2SV_ModEnd> <S2SV_ModStart> if ( root_storage ) { <S2SV_ModStart> root_storage -> d_storage_uuid <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> root_storage <S2SV_ModEnd> ,file@file/6d209c1c489457397a5763bca4b28e43aac90391,CVE-2014-0207,https://github.com/file/file/commit/6d209c1c489457397a5763bca4b28e43aac90391,2014-07-09T11:07Z
838,CWE-200,"<S2SV_StartBug> UWORD8 u1_profile_idc , u1_level_idc , u1_seq_parameter_set_id ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ps_seq -> u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; <S2SV_EndBug> ","<S2SV_ModStart> , u1_mb_aff_flag = 0 <S2SV_ModStart> u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_mb_aff_flag != u1_mb_aff_flag ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ! u1_frm ) <S2SV_ModStart> u1_mb_aff_flag <S2SV_ModEnd> ",external@libavc/42cf02965b11c397dd37a0063e683cef005bc0ae,CVE-2017-13204,https://android.googlesource.com/platform/external/libavc/+/42cf02965b11c397dd37a0063e683cef005bc0ae,2018-01-12T23:29Z
839,CWE-200,"<S2SV_StartBug> err |= get_user ( length , & up -> length ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( err ) return - EFAULT ,torvalds@linux/12176503366885edd542389eed3aaf94be163fdb,CVE-2013-1928,https://github.com/torvalds/linux/commit/12176503366885edd542389eed3aaf94be163fdb,2013-04-29T14:55Z
840,CWE-119,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vpx_svc_parameters_t * const params = va_arg ( args , vpx_svc_parameters_t * ) ; <S2SV_EndBug> <S2SV_StartBug> if ( params == NULL ) <S2SV_EndBug> <S2SV_StartBug> cpi -> svc . spatial_layer_id = params -> spatial_layer ; <S2SV_EndBug> <S2SV_StartBug> cpi -> svc . temporal_layer_id = params -> temporal_layer ; <S2SV_EndBug> <S2SV_StartBug> cpi -> lst_fb_idx = params -> lst_fb_idx ; <S2SV_EndBug> <S2SV_StartBug> cpi -> gld_fb_idx = params -> gld_fb_idx ; <S2SV_EndBug> <S2SV_StartBug> cpi -> alt_fb_idx = params -> alt_fb_idx ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_svc_extra_cfg_t <S2SV_ModEnd> <S2SV_ModStart> vpx_svc_extra_cfg_t <S2SV_ModEnd> <S2SV_ModStart> int sl , tl ; for ( sl = 0 ; sl < <S2SV_ModEnd> <S2SV_ModStart> number_spatial_layers ; ++ sl ) { for ( tl = 0 ; tl < <S2SV_ModEnd> <S2SV_ModStart> number_temporal_layers ; ++ tl ) { const int layer = LAYER_IDS_TO_IDX ( sl , tl , cpi -> svc . number_temporal_layers ) ; LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ; lc -> max_q <S2SV_ModEnd> <S2SV_ModStart> max_quantizers [ sl ] ; lc -> min_q <S2SV_ModEnd> <S2SV_ModStart> min_quantizers [ sl ] ; lc -> scaling_factor_num <S2SV_ModEnd> <S2SV_ModStart> scaling_factor_num [ sl ] ; lc -> scaling_factor_den <S2SV_ModEnd> <S2SV_ModStart> scaling_factor_den [ sl ] ; } } <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
841,CWE-000,<S2SV_StartBug> if ( prev ) { <S2SV_EndBug> <S2SV_StartBug> int i = ( FRAG6_CB ( prev ) -> offset + prev -> len ) - offset ; <S2SV_EndBug> <S2SV_StartBug> if ( i > 0 ) { <S2SV_EndBug> <S2SV_StartBug> while ( next && FRAG6_CB ( next ) -> offset < end ) { <S2SV_EndBug> <S2SV_StartBug> err : <S2SV_EndBug> ,<S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> goto discard_fq ; if <S2SV_ModEnd> <S2SV_ModStart> goto discard_fq ; <S2SV_ModEnd> <S2SV_ModStart> discard_fq : fq_kill ( fq ) ; ,torvalds@linux/70789d7052239992824628db8133de08dc78e593,CVE-2012-4444,https://github.com/torvalds/linux/commit/70789d7052239992824628db8133de08dc78e593,2012-12-21T11:47Z
842,CWE-190,"<S2SV_StartBug> uint16 bitspersample , samplesperpixel ; <S2SV_EndBug> <S2SV_StartBug> uint16 input_compression , input_photometric ; <S2SV_EndBug> ",<S2SV_ModStart> = 1 <S2SV_ModStart> = PHOTOMETRIC_MINISBLACK ,vadz@libtiff/43c0b81a818640429317c80fea1e66771e85024b,CVE-2016-9538,https://github.com/vadz/libtiff/commit/43c0b81a818640429317c80fea1e66771e85024b#diff-c8b4b355f9b5c06d585b23138e1c185f,2016-11-22T19:59Z
843,CWE-20,"<S2SV_StartBug> # if ! defined ( HAVE_LSTAT ) <S2SV_EndBug> <S2SV_StartBug> r = lstat ( a -> name , & st ) ; <S2SV_EndBug> <S2SV_StartBug> if ( r != 0 ) { <S2SV_EndBug> <S2SV_StartBug> archive_set_error ( & a -> archive , errno , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! S_ISLNK ( a -> mode ) ) { <S2SV_EndBug> ","<S2SV_ModStart> struct archive_string error_string ; int error_number ; int rc ; archive_string_init ( & error_string ) ; rc = check_symlinks_fsobj <S2SV_ModEnd> <S2SV_ModStart> error_number , & error_string , a -> flags <S2SV_ModEnd> <S2SV_ModStart> rc != ARCHIVE_OK <S2SV_ModEnd> <S2SV_ModStart> error_number , ""%s"" , error_string . s <S2SV_ModEnd> <S2SV_ModStart> archive_string_free ( & error_string ) ; <S2SV_ModStart> return rc ; } <S2SV_ModEnd> ",libarchive@libarchive/dfd6b54ce33960e420fb206d8872fb759b577ad9,CVE-2016-5418,https://github.com/libarchive/libarchive/commit/dfd6b54ce33960e420fb206d8872fb759b577ad9,2016-09-21T14:25Z
844,CWE-59,"<S2SV_StartBug> if ( mount ( hostpath , path , 0 , MS_BIND , NULL ) != 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> safe_mount ( hostpath , path , 0 , MS_BIND , NULL , rootfs -> path ? rootfs -> mount : <S2SV_ModEnd> ",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z
845,CWE-399,"<S2SV_StartBug> unsigned int link_count ; <S2SV_EndBug> <S2SV_StartBug> struct buffer_head * nbh = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ie -> indirectICB . extLength && <S2SV_EndBug> <S2SV_StartBug> ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 , <S2SV_EndBug> <S2SV_StartBug> brelse ( nbh ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned int indirections = 0 ; reread : <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) { brelse ( bh ) ; brelse ( ibh ) ; memcpy ( & iinfo -> i_location <S2SV_ModEnd> <S2SV_ModStart> sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > UDF_MAX_ICB_NESTING ) { udf_err ( inode -> i_sb , ""too<S2SV_blank>many<S2SV_blank>ICBs<S2SV_blank>in<S2SV_blank>ICB<S2SV_blank>hierarchy"" ""<S2SV_blank>(max<S2SV_blank>%d<S2SV_blank>supported)\\n"" , UDF_MAX_ICB_NESTING ) ; make_bad_inode <S2SV_ModEnd> <S2SV_ModStart> goto reread <S2SV_ModEnd> ",torvalds@linux/c03aa9f6e1f938618e6db2e23afef0574efeeb65,CVE-2014-6410,https://github.com/torvalds/linux/commit/c03aa9f6e1f938618e6db2e23afef0574efeeb65,2014-09-28T10:55Z
846,CWE-119,"<S2SV_StartBug> const TX_SIZE tx_size_uv = get_uv_tx_size ( mbmi ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( & lfm -> lfl_y [ index ] , filter_level , w ) ; <S2SV_EndBug> <S2SV_StartBug> * int_4x4_y |= ( size_mask [ block_size ] & 0xffffffffffffffff ) << shift_y ; <S2SV_EndBug> ","<S2SV_ModStart> get_uv_tx_size_impl ( tx_size_y , block_size , 1 , 1 <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> 0xffffffffffffffffULL <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
847,CWE-20,"<S2SV_StartBug> int namelen = strlen ( name ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> <S2SV_StartBug> data ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ! size ) <S2SV_EndBug> <S2SV_StartBug> if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { <S2SV_EndBug> <S2SV_StartBug> snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> GetByteContext gb <S2SV_ModEnd> <S2SV_ModStart> data >= data_end <S2SV_ModEnd> <S2SV_ModStart> bytestream2_init ( & gb , data , data_end - <S2SV_ModEnd> <S2SV_ModStart> return amf_get_field_value2 ( & gb <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> ",FFmpeg@FFmpeg/ffcc82219cef0928bed2d558b19ef6ea35634130,CVE-2017-11665,https://github.com/FFmpeg/FFmpeg/commit/ffcc82219cef0928bed2d558b19ef6ea35634130,2017-07-27T12:29Z
848,CWE-119,"<S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> ","<S2SV_ModStart> alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ",TeX-Live@texlive-source/6ed0077520e2b0da1fd060c7f88db7b2e6068e4c,CVE-2018-17407,https://github.com/TeX-Live/texlive-source/commit/6ed0077520e2b0da1fd060c7f88db7b2e6068e4c,2018-09-23T21:29Z
849,CWE-362,"<S2SV_StartBug> spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> ) ; hctx = q -> mq_ops -> map_queue ( q , flush_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , flush_rq -> tag , fq -> orig_rq ",torvalds@linux/0048b4837affd153897ed1222283492070027aa9,CVE-2015-9016,https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9,2018-04-05T18:29Z
850,CWE-269,"<S2SV_StartBug> k -> get_config ( vdev , vdev -> config ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; } <S2SV_ModStart>  <S2SV_ModEnd> ,qemu@qemu/5f5a1318653c08e435cfa52f60b6a712815b659d,CVE-2013-2016,https://github.com/qemu/qemu/commit/5f5a1318653c08e435cfa52f60b6a712815b659d,2019-12-30T22:15Z
851,CWE-400,"<S2SV_StartBug> return ! match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , 0 ",ccxvii@mujs/00d4606c3baf813b7b1c176823b2729bf51002a2,CVE-2019-11413,https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2,2019-04-22T11:29Z
852,CWE-119,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> horDiff16 ( tif , cp0 , cc ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( ! <S2SV_ModStart> ) return 0 <S2SV_ModStart> return 1 ; ,vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1,CVE-2016-9535,https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1,2016-11-22T19:59Z
853,CWE-000,"<S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ",<S2SV_ModStart> ssplit <S2SV_ModEnd> ,embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z
854,CWE-362,<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> daddr = inet -> inet_daddr ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt && inet -> opt -> srr ) <S2SV_EndBug> ,<S2SV_ModStart> struct ip_options_rcu * inet_opt ; <S2SV_ModStart> rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; <S2SV_ModStart> inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ; rcu_read_unlock ( ) <S2SV_ModEnd> ,torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z
855,CWE-125,"<S2SV_StartBug> void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) <S2SV_EndBug> ",<S2SV_ModStart> static ,FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,CVE-2018-8789,https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,2018-11-29T18:29Z
856,CWE-362,"<S2SV_StartBug> pid_t pid ; <S2SV_EndBug> <S2SV_StartBug> memset ( c_path , 0 , sizeof ( c_path ) ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( c_path , ""%s%s%d_C_%lu"" , HSM_FM_SCK_PREFIX , mgr_prefix , <S2SV_EndBug> <S2SV_StartBug> hdl -> instance , ( long unsigned ) pid ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""%s%s%d_C_XXXXXX"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",01org@opa-fm/c5759e7b76f5bf844be6c6641cc1b356bbc83869,CVE-2015-5232,https://github.com/01org/opa-fm/commit/c5759e7b76f5bf844be6c6641cc1b356bbc83869,2017-06-07T20:29Z
857,CWE-119,<S2SV_StartBug> * replySize < ( int ) sizeof ( effect_param_t ) ) { <S2SV_EndBug> ,<S2SV_ModStart> sizeof ( effect_param_t ) || ( ( effect_param_t * ) pCmdData ) -> psize > * replySize - ,hardware@qcom@audio/073a80800f341325932c66818ce4302b312909a4,CVE-2016-3745,https://android.googlesource.com/platform/hardware/qcom/audio/+/073a80800f341325932c66818ce4302b312909a4,2016-07-11T01:59Z
858,CWE-399,"<S2SV_StartBug> ""InvalidGeometry"" , ""`%s\'"" , option ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; page_geometry = DestroyString ( page_geometry ,ImageMagick@ImageMagick/35ccb468ee2dcbe8ce9cf1e2f1957acc27f54c34,CVE-2019-13137,https://github.com/ImageMagick/ImageMagick/commit/35ccb468ee2dcbe8ce9cf1e2f1957acc27f54c34,2019-07-01T20:15Z
859,CWE-264,"<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> len = ipv6_getsockopt_sticky ( sk , np -> opt , <S2SV_EndBug> ","<S2SV_ModStart> struct ipv6_txoptions * opt ; <S2SV_ModStart> opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
860,CWE-189,<S2SV_StartBug> currkvno = key_data [ i ] . key_data_kvno ; <S2SV_EndBug> ,<S2SV_ModStart> if ( i < n_key_data - 1 ) <S2SV_ModStart> + 1 ,krb5@krb5/dc7ed55c689d57de7f7408b34631bf06fec9dab1,CVE-2014-4345,https://github.com/krb5/krb5/commit/dc7ed55c689d57de7f7408b34631bf06fec9dab1,2014-08-14T05:01Z
861,CWE-119,"<S2SV_StartBug> L3 = emitjump ( J , F , OP_JUMP ) ; <S2SV_EndBug> ","<S2SV_ModStart> emit ( J , F , OP_ENDTRY ) ; ",ccxvii@mujs/1e5479084bc9852854feb1ba9bf68b52cd127e02,CVE-2019-11412,https://github.com/ccxvii/mujs/commit/1e5479084bc9852854feb1ba9bf68b52cd127e02,2019-04-22T11:29Z
862,CWE-119,"<S2SV_StartBug> if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> <S2SV_StartBug> l_row -- ; <S2SV_EndBug> ",<S2SV_ModStart> 3 == <S2SV_ModStart> && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> <S2SV_ModStart> LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ; ,hfp@libxsmm/151481489192e6d1997f8bde52c5c425ea41741d,CVE-2018-20542,https://github.com/hfp/libxsmm/commit/151481489192e6d1997f8bde52c5c425ea41741d,2018-12-28T16:29Z
863,CWE-787,"<S2SV_StartBug> memcpy ( sbuf + 1 , crgram , crgram_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( sizeof sbuf - 1 < crgram_len ) return SC_ERROR_INVALID_ARGUMENTS ; ,OpenSC@OpenSC/9d294de90d1cc66956389856e60b6944b27b4817,CVE-2020-26572,https://github.com/OpenSC/OpenSC/commit/9d294de90d1cc66956389856e60b6944b27b4817,2020-10-06T02:15Z
864,CWE-787,"<S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> STREAM s ; <S2SV_EndBug> <S2SV_StartBug> ber_parse_header ( s , MCS_CONNECT_RESPONSE , & length ) ; <S2SV_EndBug> <S2SV_StartBug> mcs_parse_domain_params ( s ) ; <S2SV_EndBug> ","<S2SV_ModStart> uint32 <S2SV_ModEnd> <S2SV_ModStart> ; struct stream packet <S2SV_ModStart> packet = * s ; <S2SV_ModStart> if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""mcs_recv_connect_response(),<S2SV_blank>consume<S2SV_blank>connect<S2SV_blank>id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } ",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z
865,CWE-617,<S2SV_StartBug> assert ( status != NULL ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( status == NULL ) status = ""UNKNOWN_REASON"" <S2SV_ModEnd> ",krb5@krb5/ffb35baac6981f9e8914f8f3bffd37f284b85970,CVE-2017-11368,https://github.com/krb5/krb5/commit/ffb35baac6981f9e8914f8f3bffd37f284b85970,2017-08-09T18:29Z
866,CWE-119,"<S2SV_StartBug> if ( c == 0 ) { <S2SV_EndBug> <S2SV_StartBug> xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , ""Name"" ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; return ( NULL ) ; } if ( ctxt -> input -> cur - ctxt -> input -> base < len ) { xmlFatalErr ( ctxt , XML_ERR_INTERNAL_ERROR , ""unexpected<S2SV_blank>change<S2SV_blank>of<S2SV_blank>input<S2SV_blank>buffer"" ",GNOME@libxml2/e26630548e7d138d2c560844c43820b6767251e3,CVE-2017-16931,https://github.com/GNOME/libxml2/commit/e26630548e7d138d2c560844c43820b6767251e3,2017-11-23T21:29Z
867,CWE-401,<S2SV_StartBug> goto err_free ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( ch ) ; ,torvalds@linux/27d461333459d282ffa4a2bdb6b215a59d493a8f,CVE-2019-19043,https://github.com/torvalds/linux/commit/27d461333459d282ffa4a2bdb6b215a59d493a8f,2019-11-18T06:15Z
868,CWE-119,<S2SV_StartBug> if ( * rsize >= 17 && rdesc [ 11 ] == 0x3c && rdesc [ 12 ] == 0x02 ) { <S2SV_EndBug> ,<S2SV_ModStart> 18 <S2SV_ModEnd> ,torvalds@linux/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,CVE-2014-3184,https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,2014-09-28T10:55Z
869,CWE-20,"<S2SV_StartBug> if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) <S2SV_EndBug> <S2SV_StartBug> if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ; ,torvalds@linux/d2f007dbe7e4c9583eea6eb04d60001e85c6f1bd,CVE-2018-18955,https://github.com/torvalds/linux/commit/d2f007dbe7e4c9583eea6eb04d60001e85c6f1bd,2018-11-16T20:29Z
870,CWE-787,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> return - 1 ; ,radare@radare2/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,CVE-2017-9949,https://github.com/radare/radare2/commit/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,2017-06-26T20:29Z
871,CWE-476,<S2SV_StartBug> smb_ofile_t * of = NULL ; <S2SV_EndBug> <S2SV_StartBug> of = sr -> fid_ofile ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> smb_ofile_flush ( sr , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",illumos@illumos-gate/6d1c73b5858fefc6161c7d686345f0dc887ea799,CVE-2016-6561,https://github.com/illumos/illumos-gate/commit/6d1c73b5858fefc6161c7d686345f0dc887ea799,2017-03-31T19:59Z
872,CWE-190,<S2SV_StartBug> uchar * dataptr ; <S2SV_EndBug> ,<S2SV_ModStart> jas_uchar <S2SV_ModEnd> ,mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
873,CWE-119,"<S2SV_StartBug> vpx_memset ( xd -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> xd -> pre . y_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 0 ] + recon_yoffset ; <S2SV_EndBug> <S2SV_StartBug> xd -> pre . u_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 1 ] + recon_uvoffset ; <S2SV_EndBug> <S2SV_StartBug> xd -> pre . v_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 2 ] + recon_uvoffset ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> if ( xd -> mode_info_context -> mbmi . ref_frame >= LAST_FRAME ) { const MV_REFERENCE_FRAME ref = xd -> mode_info_context -> mbmi . ref_frame ; <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> } else { xd -> pre . y_buffer = 0 ; xd -> pre . u_buffer = 0 ; xd -> pre . v_buffer = 0 ; } ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
874,CWE-200,<S2SV_StartBug> addr -> addrtype = TIPC_ADDR_ID ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & addr -> addr , 0 , sizeof ( addr -> addr ) ) ",torvalds@linux/60085c3d009b0df252547adb336d1ccca5ce52ec,CVE-2013-3235,https://github.com/torvalds/linux/commit/60085c3d009b0df252547adb336d1ccca5ce52ec,2013-04-22T11:41Z
875,CWE-20,<S2SV_StartBug> if ( user_alloc && ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) ) <S2SV_EndBug> ,"<S2SV_ModStart> ( <S2SV_ModStart> ) ) || ! access_ok ( VERIFY_WRITE , mem -> userspace_addr , mem -> memory_size ",torvalds@linux/fa3d315a4ce2c0891cdde262562e710d95fba19e,CVE-2013-1943,https://github.com/torvalds/linux/commit/fa3d315a4ce2c0891cdde262562e710d95fba19e,2013-07-16T14:08Z
876,CWE-772,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_EndBug> ,<S2SV_ModStart> quantum_info = ( QuantumInfo * ) NULL ; <S2SV_ModStart> if ( quantum_info != ( QuantumInfo * ) NULL ) ,ImageMagick@ImageMagick/79e5dbcdd1fc2f714f9bae548bc55d5073f3ed20,CVE-2017-13146,https://github.com/ImageMagick/ImageMagick/commit/79e5dbcdd1fc2f714f9bae548bc55d5073f3ed20,2017-08-23T06:29Z
877,CWE-119,"<S2SV_StartBug> if ( tmp_line [ tmp_line_len - 1 ] == '\\n' ) { <S2SV_EndBug> <S2SV_StartBug> if ( tmp_line [ tmp_line_len - 1 ] == '\\r' ) { <S2SV_EndBug> <S2SV_StartBug> # define CHECK_FOR_CNTRL_CHARS ( val ) { if ( val ) { unsigned char * s , * e ; int l ; l = php_url_decode ( val , strlen ( val ) ) ; s = ( unsigned char * ) val ; e = s + l ; while ( s < e ) { if ( iscntrl ( * s ) ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s"" , new_path ) ; goto out ; } s ++ ; } } } <S2SV_EndBug> ",<S2SV_ModStart> tmp_line_len >= 1 && <S2SV_ModStart> tmp_line_len >= 1 && <S2SV_ModStart> \\\n} <S2SV_ModEnd> ,php@php-src/523f230c831d7b33353203fa34aee4e92ac12bba,CVE-2018-7584,https://github.com/php/php-src/commit/523f230c831d7b33353203fa34aee4e92ac12bba,2018-03-01T19:29Z
878,CWE-125,"<S2SV_StartBug> PyObject * u ; <S2SV_EndBug> <S2SV_StartBug> const char * end ; <S2SV_EndBug> <S2SV_StartBug> if ( * s & 0x80 ) { <S2SV_EndBug> <S2SV_StartBug> p += 5 ; <S2SV_EndBug> <S2SV_StartBug> assert ( p - buf <= Py_SIZE ( u ) ) ; <S2SV_EndBug> <S2SV_StartBug> return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> v , * <S2SV_ModStart> ; const char * first_invalid_escape <S2SV_ModStart> s >= end || <S2SV_ModStart> ; if ( s >= end ) break <S2SV_ModStart> PyBytes_GET_SIZE <S2SV_ModEnd> <S2SV_ModStart> v = _PyUnicode_DecodeUnicodeEscape ( s , len , NULL , & first_invalid_escape ) ; if ( v != NULL && first_invalid_escape != NULL ) { if ( warn_invalid_escape_sequence ( c , n , * first_invalid_escape ) < 0 ) { Py_XDECREF ( u ) ; Py_DECREF ( v ) ; return NULL ; } } Py_XDECREF ( u ) ; return v <S2SV_ModEnd> ",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
879,CWE-125,"<S2SV_StartBug> if ( libfvalue_value_type_initialize ( <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> # if defined ( HAVE_DEBUG_OUTPUT ) <S2SV_EndBug> <S2SV_StartBug> & ( record_data [ data_offset ] ) , <S2SV_EndBug> ","<S2SV_ModStart> user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } if ( <S2SV_ModStart> if ( strings_size > ( ( record_data_size - 4 ) - strings_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } <S2SV_ModStart> if ( data_size > ( ( record_data_size - 4 ) - record_data_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ; goto on_error ; } <S2SV_ModStart> record_data_offset <S2SV_ModEnd> ",libyal@libevt/9d2cc3ca0a1612a6b271abcacffc2e3eea42925e,CVE-2018-8754,https://github.com/libyal/libevt/commit/9d2cc3ca0a1612a6b271abcacffc2e3eea42925e,2018-03-18T03:29Z
880,CWE-119,"<S2SV_StartBug> uint32_t bcount ; <S2SV_EndBug> <S2SV_StartBug> int supported = TRUE , format ; <S2SV_EndBug> ","<S2SV_ModStart> int format_chunk = 0 ; <S2SV_ModStart> if ( format_chunk ++ ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } ",dbry@WavPack/26cb47f99d481ad9b93eeff80d26e6b63bbd7e15,CVE-2018-10537,https://github.com/dbry/WavPack/commit/26cb47f99d481ad9b93eeff80d26e6b63bbd7e15,2018-04-29T15:29Z
881,CWE-824,<S2SV_StartBug> uint32_t sampleRate ; <S2SV_EndBug> <S2SV_StartBug> if ( ! config -> num_channels ) { <S2SV_EndBug> ,<S2SV_ModStart> = 0 <S2SV_ModStart> || ! config -> sample_rate ,dbry@WavPack/bc6cba3f552c44565f7f1e66dc1580189addb2b4,CVE-2019-11498,https://github.com/dbry/WavPack/commit/bc6cba3f552c44565f7f1e66dc1580189addb2b4,2019-04-24T05:29Z
882,CWE-125,"<S2SV_StartBug> ND_TCHECK ( * vtp_vlan ) ; <S2SV_EndBug> <S2SV_StartBug> fn_printzp ( ndo , tptr + VTP_VLAN_INFO_OFFSET , vtp_vlan -> name_len , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; <S2SV_EndBug> <S2SV_StartBug> tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; <S2SV_EndBug> <S2SV_StartBug> type = * tptr ; <S2SV_EndBug> <S2SV_StartBug> if ( type == 0 || tlv_len == 0 ) { <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> len -= 2 + tlv_len * 2 ; <S2SV_EndBug> ","<S2SV_ModStart> if ( len < VTP_VLAN_INFO_FIXED_PART_LEN ) goto trunc ; <S2SV_ModStart> len -= VTP_VLAN_INFO_FIXED_PART_LEN ; tptr += VTP_VLAN_INFO_FIXED_PART_LEN ; if ( len < 4 * ( ( <S2SV_ModEnd> <S2SV_ModStart> + 3 ) / 4 ) ) goto trunc ; ND_TCHECK2 ( * tptr , <S2SV_ModEnd> <S2SV_ModStart> ) ; fn_printzp ( ndo , tptr , <S2SV_ModEnd> <S2SV_ModStart> , NULL ) ; len -= 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; tptr += 4 * ( ( vtp_vlan -> name_len <S2SV_ModStart> if ( len < 2 ) goto trunc ; ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> len < tlv_len * 2 + 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(TLV<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>packet)"" ) ) ; <S2SV_ModEnd> <S2SV_ModStart> if ( tlv_len != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>TLV<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>1)"" , tlv_len ) ) ; return ; } else { <S2SV_ModStart> } ",the-tcpdump-group@tcpdump/ae83295915d08a854de27a88efac5dd7353e6d3f,CVE-2017-13033,https://github.com/the-tcpdump-group/tcpdump/commit/ae83295915d08a854de27a88efac5dd7353e6d3f,2017-09-14T06:29Z
883,CWE-20,"<S2SV_StartBug> spin_unlock_irqrestore ( & slave_active_lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> list_del_init ( & timeri -> ack_list ) ; list_del_init ( & timeri -> active_list ) ; ,torvalds@linux/b5a663aa426f4884c71cd8580adae73f33570f0d,CVE-2016-2548,https://github.com/torvalds/linux/commit/b5a663aa426f4884c71cd8580adae73f33570f0d,2016-04-27T17:59Z
884,CWE-20,"<S2SV_StartBug> struct stat stb ; <S2SV_EndBug> <S2SV_StartBug> int setimes , targisdir , wrerrno = 0 ; <S2SV_EndBug> <S2SV_StartBug> wrerr = NO ; <S2SV_EndBug> <S2SV_StartBug> if ( wrerr == NO ) { <S2SV_EndBug> <S2SV_StartBug> wrerr = YES ; <S2SV_EndBug> <S2SV_StartBug> if ( count != 0 && wrerr == NO && <S2SV_EndBug> <S2SV_StartBug> wrerr = YES ; <S2SV_EndBug> <S2SV_StartBug> ftruncate ( ofd , size ) != 0 ) { <S2SV_EndBug> <S2SV_StartBug> wrerr = DISPLAYED ; <S2SV_EndBug> <S2SV_StartBug> run_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> np , strerror ( errno ) ) ; <S2SV_EndBug> <S2SV_StartBug> run_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> np , strerror ( errno ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( close ( ofd ) == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( setimes && wrerr == NO ) { <S2SV_EndBug> <S2SV_StartBug> run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> wrerr = DISPLAYED ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> wrerr <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> ! wrerr <S2SV_ModEnd> <S2SV_ModStart> note_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = 1 <S2SV_ModEnd> <S2SV_ModStart> ! wrerr <S2SV_ModEnd> <S2SV_ModStart> note_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = 1 ; } if ( ! wrerr <S2SV_ModEnd> <S2SV_ModStart> note_err <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> note_err <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> note_err <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> note_err ( np , ""%s:<S2SV_blank>close:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; <S2SV_ModEnd> <S2SV_ModStart> ! wrerr <S2SV_ModEnd> <S2SV_ModStart> note_err <S2SV_ModEnd> <S2SV_ModStart> } } if ( note_err ( NULL ) == 0 ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",openssh@openssh-portable/aad87b88fc2536b1ea023213729aaf4eaabe1894,CVE-2020-12062,https://github.com/openssh/openssh-portable/commit/aad87b88fc2536b1ea023213729aaf4eaabe1894,2020-06-01T16:15Z
885,CWE-284,"<S2SV_StartBug> else if ( ! strcasecmp ( target , ""LIST"" ) && myentity_find_ext ( target ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> else if ( ! strcasecmp ( target , ""CLEAR"" ) && myentity_find_ext ( target ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> else if ( ! strcasecmp ( target , ""MODIFY"" ) && myentity_find_ext ( target ) == NULL ) <S2SV_EndBug> ",<S2SV_ModStart> anope_flags_compat && <S2SV_ModStart> anope_flags_compat && <S2SV_ModStart> anope_flags_compat && ,atheme@atheme/c597156adc60a45b5f827793cd420945f47bc03b,CVE-2014-9773,https://github.com/atheme/atheme/commit/c597156adc60a45b5f827793cd420945f47bc03b,2016-06-13T19:59Z
886,CWE-476,"<S2SV_StartBug> ghash_flush ( ctx , dctx ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! ctx -> gf128 ) return - ENOKEY ; ,torvalds@linux/7ed47b7d142ec99ad6880bbbec51e9f12b3af74c,CVE-2011-4081,https://github.com/torvalds/linux/commit/7ed47b7d142ec99ad6880bbbec51e9f12b3af74c,2012-05-24T23:55Z
887,CWE-200,<S2SV_StartBug> if ( ! ( ast -> sub_ctx = avformat_alloc_context ( ) ) ) <S2SV_EndBug> ,"<S2SV_ModStart> strcmp ( sub_demuxer -> name , ""srt"" ) && strcmp ( sub_demuxer -> name , ""ass"" ) ) goto error ; if ( ",FFmpeg@FFmpeg/a5d849b149ca67ced2d271dc84db0bc95a548abb,CVE-2017-9993,https://github.com/FFmpeg/FFmpeg/commit/a5d849b149ca67ced2d271dc84db0bc95a548abb,2017-06-28T06:29Z
888,CWE-000,"<S2SV_StartBug> int need_error_free = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( inbuf . data , sendauth_version ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( appl_version && strcmp ( inbuf . data , appl_version ) ) { <S2SV_EndBug> ","<S2SV_ModStart> krb5_data d ; <S2SV_ModStart> d = make_data ( ( char * ) sendauth_version , strlen ( sendauth_version ) + 1 ) ; if ( ! data_eq ( inbuf , d <S2SV_ModEnd> <S2SV_ModStart> != NULL && ! problem ) { d = make_data ( appl_version , strlen ( appl_version ) + 1 ) ; if ( ! data_eq ( inbuf , d ) <S2SV_ModEnd> ",krb5@krb5/102bb6ebf20f9174130c85c3b052ae104e5073ec,CVE-2014-5355,https://github.com/krb5/krb5/commit/102bb6ebf20f9174130c85c3b052ae104e5073ec,2015-02-20T11:59Z
889,CWE-119,"<S2SV_StartBug> static INLINE int write_bit_gte ( vp9_writer * w , int word , int test ) { <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , word >= test , 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> vpx_write_literal <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
890,CWE-285,"<S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( ret ) return ret <S2SV_ModEnd> ",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z
891,CWE-20,<S2SV_StartBug> * dptr ++ = 0xAA ; <S2SV_EndBug> ,<S2SV_ModStart> ROSE_CALL_REQ_ADDR_LEN_VAL <S2SV_ModEnd> ,torvalds@linux/e0bccd315db0c2f919e7fcf9cb60db21d9986f52,CVE-2011-4914,https://github.com/torvalds/linux/commit/e0bccd315db0c2f919e7fcf9cb60db21d9986f52,2012-06-21T23:55Z
892,CWE-400,<S2SV_StartBug> if ( new_fs ) { <S2SV_EndBug> ,<S2SV_ModStart> new_ns -> mounts ++ ; ,torvalds@linux/d29216842a85c7970c536108e093963f02714498,CVE-2016-6213,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,2016-12-28T07:59Z
893,CWE-119,"<S2SV_StartBug> vpx_memset ( & oci -> postproc_state , 0 , sizeof ( oci -> postproc_state ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( oci -> post_proc_buffer . buffer_alloc , 128 , <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
894,CWE-416,<S2SV_StartBug> zip_object_handlers . get_properties = php_zip_get_properties ; <S2SV_EndBug> ,<S2SV_ModStart> get_gc = php_zip_get_gc ; zip_object_handlers . ,php@php-src/f6aef68089221c5ea047d4a74224ee3deead99a6,CVE-2016-5773,https://github.com/php/php-src/commit/f6aef68089221c5ea047d4a74224ee3deead99a6?w=1,2016-08-07T10:59Z
895,CWE-190,<S2SV_StartBug> return ( ( iova < mem -> iova ) || <S2SV_EndBug> <S2SV_StartBug> ( ( iova + length ) > ( mem -> iova + mem -> length ) ) ) ? <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> || length > mem -> length || iova > <S2SV_ModEnd> <S2SV_ModStart> - length ) return - EFAULT ; return <S2SV_ModEnd> ,torvalds@linux/647bf3d8a8e5777319da92af672289b2a6c4dc66,CVE-2016-8636,https://github.com/torvalds/linux/commit/647bf3d8a8e5777319da92af672289b2a6c4dc66,2017-02-22T16:59Z
896,CWE-125,<S2SV_StartBug> ni6 = ( const struct icmp6_nodeinfo * ) dp ; <S2SV_EndBug> <S2SV_StartBug> cp = ( const u_char * ) ( ni6 + 1 ) + 4 ; <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; <S2SV_ModStart> ; ND_TCHECK ( cp [ 0 ] ) ",the-tcpdump-group@tcpdump/f4b9e24c7384d882a7f434cc7413925bf871d63e,CVE-2017-13041,https://github.com/the-tcpdump-group/tcpdump/commit/f4b9e24c7384d882a7f434cc7413925bf871d63e,2017-09-14T06:29Z
897,CWE-119,"<S2SV_StartBug> struct strbuf * path , const char * name , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,git@git/de1e67d0703894cb6ea782e36abb63976ab07e60,CVE-2016-2324,https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60,2016-04-08T14:59Z
898,CWE-362,<S2SV_StartBug> * sent = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/ea702b80e0bbb2448e201472127288beb82ca2fe,CVE-2013-3302,https://github.com/torvalds/linux/commit/ea702b80e0bbb2448e201472127288beb82ca2fe,2013-04-29T14:55Z
899,CWE-416,"<S2SV_StartBug> static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , <S2SV_EndBug> <S2SV_StartBug> ref -> ref ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> bool <S2SV_ModEnd> <S2SV_ModStart> if ( ref -> ref > INT_MAX / 2 ) return false ; <S2SV_ModStart> return true ; ,torvalds@linux/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,CVE-2019-11487,https://github.com/torvalds/linux/commit/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,2019-04-23T22:29Z
900,CWE-189,<S2SV_StartBug> if ( cluster != fs -> clusters - 1 ) <S2SV_EndBug> ,<S2SV_ModStart> + <S2SV_ModEnd> ,dosfstools@dosfstools/07908124838afcc99c577d1d3e84cef2dbd39cb7,CVE-2015-8872,https://github.com/dosfstools/dosfstools/commit/07908124838afcc99c577d1d3e84cef2dbd39cb7,2016-06-03T14:59Z
901,CWE-119,"<S2SV_StartBug> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
902,CWE-000,<S2SV_StartBug> sock_put ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> sk_nulls_node_init ( & sk -> sk_nulls_node ) ; ,torvalds@linux/a134f083e79fb4c3d0a925691e732c56911b4326,CVE-2015-3636,https://github.com/torvalds/linux/commit/a134f083e79fb4c3d0a925691e732c56911b4326,2015-08-06T01:59Z
903,CWE-20,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ; ,external@libavc/d4841f1161bdb5e13cb19e81af42437a634dd6ef,CVE-2016-3755,https://android.googlesource.com/platform/external/libavc/+/d4841f1161bdb5e13cb19e81af42437a634dd6ef,2016-07-11T01:59Z
904,CWE-362,<S2SV_StartBug> if ( ! mm ) <S2SV_EndBug> ,<S2SV_ModStart> || ! mm -> env_end ,torvalds@linux/8148a73c9901a8794a50f950083c00ccf97d43b3,CVE-2016-7916,https://github.com/torvalds/linux/commit/8148a73c9901a8794a50f950083c00ccf97d43b3,2016-11-16T05:59Z
905,CWE-20,"<S2SV_StartBug> int parse_rock_ridge_inode ( struct iso_directory_record * de , struct inode * inode ) <S2SV_EndBug> <S2SV_StartBug> int result = parse_rock_ridge_inode_internal ( de , inode , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> result = parse_rock_ridge_inode_internal ( de , inode , 14 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int relocated ) { int flags = relocated ? RR_RELOC_DE : 0 ; <S2SV_ModEnd> <S2SV_ModStart> flags <S2SV_ModEnd> <S2SV_ModStart> flags | RR_REGARD_XA <S2SV_ModEnd> ",torvalds@linux/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4,CVE-2014-5472,https://github.com/torvalds/linux/commit/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4,2014-09-01T01:55Z
906,CWE-399,"<S2SV_StartBug> static struct fsnotify_group * inotify_new_group ( struct user_struct * user , unsigned int max_events ) <S2SV_EndBug> <S2SV_StartBug> group -> inotify_data . user = user ; <S2SV_EndBug> <S2SV_StartBug> group -> inotify_data . fa = NULL ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> fa = NULL <S2SV_ModEnd> <S2SV_ModStart> user = get_current_user ( ) ; if ( atomic_inc_return ( & group -> inotify_data . user -> inotify_devs ) > inotify_max_user_instances ) { fsnotify_put_group ( group ) ; return ERR_PTR ( - EMFILE ) ; } <S2SV_ModEnd> ,torvalds@linux/d0de4dc584ec6aa3b26fffea320a8457827768fc,CVE-2011-1479,https://github.com/torvalds/linux/commit/d0de4dc584ec6aa3b26fffea320a8457827768fc,2012-06-21T23:55Z
907,CWE-119,<S2SV_StartBug> for ( p = 0 ; p < 4 && in -> data [ p ] ; p ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && in -> linesize [ p ] ,FFmpeg@FFmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,CVE-2013-4263,https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,2013-11-23T17:55Z
908,CWE-189,<S2SV_StartBug> pairs = palloc ( pcount * sizeof ( Pairs ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( pcount < 0 || pcount > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , pcount , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ; ",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z
909,CWE-476,<S2SV_StartBug> if ( screen -> buffers [ 1 ] ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,vim@vim/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,CVE-2018-20786,https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,2019-02-24T14:29Z
910,CWE-119,<S2SV_StartBug> regs [ value_regno ] . var_off = <S2SV_EndBug> ,"<S2SV_ModStart> coerce_reg_to_size ( & <S2SV_ModStart> , size <S2SV_ModEnd> ",torvalds@linux/0c17d1d2c61936401f4702e1846e2c19b200f958,CVE-2017-16996,https://github.com/torvalds/linux/commit/0c17d1d2c61936401f4702e1846e2c19b200f958,2017-12-27T17:08Z
911,CWE-190,"<S2SV_StartBug> uint16 strip , nstrips = TIFFNumberOfStrips ( in ) ; <S2SV_EndBug> ",<S2SV_ModStart> uint32 <S2SV_ModEnd> ,vadz@libtiff/43c0b81a818640429317c80fea1e66771e85024b,CVE-2016-9538,https://github.com/vadz/libtiff/commit/43c0b81a818640429317c80fea1e66771e85024b,2016-11-22T19:59Z
912,CWE-125,<S2SV_StartBug> const char need_to_append_dot = base_name [ base_len - 1 ] == '.' ? 0 : 1 ; <S2SV_EndBug> <S2SV_StartBug> struct search_domain * dom ; <S2SV_EndBug> ,<S2SV_ModStart> char need_to_append_dot ; struct search_domain * dom ; if ( ! base_len ) return NULL ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,libevent@libevent/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e,CVE-2016-10197,https://github.com/libevent/libevent/commit/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e,2017-03-15T15:59Z
913,CWE-284,"<S2SV_StartBug> err = nanosleep ( & delay , & delay ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ,system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
914,CWE-20,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
915,CWE-119,"<S2SV_StartBug> offset , <S2SV_EndBug> <S2SV_StartBug> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) <S2SV_EndBug> <S2SV_StartBug> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) <S2SV_EndBug> ","<S2SV_ModStart> pixel_info_length ; ssize_t count , offset <S2SV_ModEnd> <S2SV_ModStart> ( offset < 0 ) || ( <S2SV_ModStart> ) <S2SV_ModStart> ( offset < 0 ) || ( <S2SV_ModStart> ) ",ImageMagick@ImageMagick/139d4323c40d7363bfdd2382c3821a6f76d69430,CVE-2016-10050,https://github.com/ImageMagick/ImageMagick/commit/139d4323c40d7363bfdd2382c3821a6f76d69430,2017-03-23T17:59Z
916,CWE-787,"<S2SV_StartBug> static void nsc_rle_decompress_data ( NSC_CONTEXT * context ) <S2SV_EndBug> <S2SV_StartBug> rle = context -> Planes ; <S2SV_EndBug> <S2SV_StartBug> FillMemory ( context -> priv -> PlaneBuffers [ i ] , originalSize , 0xFF ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( planeSize < originalSize ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decode ( rle , context -> priv -> PlaneBuffers [ i ] , originalSize ) ; <S2SV_EndBug> <S2SV_StartBug> rle += planeSize ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> if ( ! context ) return FALSE ; <S2SV_ModStart> { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModStart> } <S2SV_ModStart> { if ( ! <S2SV_ModStart> context -> priv -> PlaneBuffersLength , originalSize ) ) return FALSE ; } else { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> return TRUE ; ",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z
917,CWE-264,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( ! inode_owner_or_capable ( inode ) ) return - EACCES ; ,torvalds@linux/163ae1c6ad6299b19e22b4a35d5ab24a89791a98,CVE-2016-10318,https://github.com/torvalds/linux/commit/163ae1c6ad6299b19e22b4a35d5ab24a89791a98,2017-04-04T16:59Z
918,CWE-000,"<S2SV_StartBug> httpSetHostName ( state -> host , stok ( sclone ( value ) , ""<S2SV_blank>\\t,"" , NULL ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ssplit <S2SV_ModEnd> ,embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z
919,CWE-476,"<S2SV_StartBug> . match_data . cmp = type -> match , <S2SV_EndBug> ",<S2SV_ModStart> key_default_cmp <S2SV_ModEnd> ,torvalds@linux/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,CVE-2017-2647,https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,2017-03-31T04:59Z
920,CWE-200,<S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug> <S2SV_StartBug> IP6CB ( skb ) -> iif ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; * addr_len = sizeof ( * sin6 ,torvalds@linux/bceaa90240b6019ed73b49965eac7d167610be69,CVE-2013-7281,https://github.com/torvalds/linux/commit/bceaa90240b6019ed73b49965eac7d167610be69,2014-01-08T16:55Z
921,CWE-119,<S2SV_StartBug> if ( ! job_id || ! prev_hash || ! coinbase1 || ! coinbase2 || ! bbversion || ! nbit || ! ntime ) { <S2SV_EndBug> <S2SV_StartBug> if ( job_id ) <S2SV_EndBug> ,<S2SV_ModStart> valid_hex ( job_id ) || ! valid_hex ( prev_hash ) || ! valid_hex ( coinbase1 ) || ! valid_hex ( coinbase2 ) || ! valid_hex ( bbversion ) || ! valid_hex ( nbit ) || ! valid_hex ( ntime ) ) { free <S2SV_ModEnd> <S2SV_ModStart> ; free ( coinbase1 ) ; <S2SV_ModEnd> ,sgminer-dev@sgminer/e1c5050734123973b99d181c45e74b2cbb00272e,CVE-2014-4502,https://github.com/sgminer-dev/sgminer/commit/e1c5050734123973b99d181c45e74b2cbb00272e,2014-07-23T14:55Z
922,CWE-284,"<S2SV_StartBug> ssize_t ret = write ( fd , data + transmitted_length , length ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ,system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
923,CWE-190,"<S2SV_StartBug> void * ptr = malloc ( num * size ) ; <S2SV_EndBug> <S2SV_StartBug> memset ( ptr , '\\0' , ( num * size ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; void * ptr ; <S2SV_ModEnd> <S2SV_ModStart> res <S2SV_ModEnd> <S2SV_ModStart> res <S2SV_ModEnd> ",verdammelt@tnef/c5044689e50039635e7700fe2472fd632ac77176,CVE-2017-6308,https://github.com/verdammelt/tnef/commit/c5044689e50039635e7700fe2472fd632ac77176,2017-02-24T04:59Z
924,CWE-400,<S2SV_StartBug> put_io_context ( ioc ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/61cc74fbb87af6aa551a06a370590c9bc07e29d9,CVE-2012-0879,https://github.com/torvalds/linux/commit/61cc74fbb87af6aa551a06a370590c9bc07e29d9,2012-05-17T11:00Z
925,CWE-125,"<S2SV_StartBug> PyObject * res ; <S2SV_EndBug> <S2SV_StartBug> PyObject * dict = _PyObject_GetAttrId ( self , & PyId___dict__ ) ; <S2SV_EndBug> <S2SV_StartBug> res = Py_BuildValue ( ""O()O"" , Py_TYPE ( self ) , dict ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & dict ) < 0 ) { <S2SV_ModEnd> <S2SV_ModStart> return Py_BuildValue ( ""O()N"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
926,CWE-400,"<S2SV_StartBug> USB_DT_OTG , ( void * * ) & desc ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( * desc ) ",torvalds@linux/704620afc70cf47abb9d6a1a57f3825d2bca49cf,CVE-2018-20169,https://github.com/torvalds/linux/commit/704620afc70cf47abb9d6a1a57f3825d2bca49cf,2018-12-17T07:29Z
927,CWE-264,"<S2SV_StartBug> void ( * func ) ( struct perf_event * ) ; <S2SV_EndBug> <S2SV_StartBug> case PERF_EVENT_IOC_PERIOD : <S2SV_EndBug> <S2SV_StartBug> return perf_event_period ( event , ( u64 __user * ) arg ) ; <S2SV_EndBug> <S2SV_StartBug> case PERF_EVENT_IOC_SET_FILTER : <S2SV_EndBug> ","<S2SV_ModStart> struct perf_event_context * ctx ; long ret ; ctx = perf_event_ctx_lock ( event ) ; ret = _perf_ioctl ( event , cmd <S2SV_ModEnd> <S2SV_ModStart> perf_event_ctx_unlock <S2SV_ModEnd> <S2SV_ModStart> ctx ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/f63a8daa5812afef4f06c962351687e1ff9ccb2b,CVE-2016-6787,https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b,2016-12-28T07:59Z
928,CWE-189,<S2SV_StartBug> tp -> prr_delivered += newly_acked_sacked ; <S2SV_EndBug> ,<S2SV_ModStart> if ( newly_acked_sacked <= 0 || WARN_ON_ONCE ( ! tp -> prior_cwnd ) ) return ; ,torvalds@linux/8b8a321ff72c785ed5e8b4cf6eda20b35d427390,CVE-2016-2070,https://github.com/torvalds/linux/commit/8b8a321ff72c785ed5e8b4cf6eda20b35d427390,2016-05-02T10:59Z
929,CWE-119,"<S2SV_StartBug> static MB_PREDICTION_MODE read_intra_mode_uv ( VP9_COMMON * cm , vp9_reader * r , <S2SV_EndBug> <S2SV_StartBug> MB_PREDICTION_MODE y_mode ) { <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE uv_mode = read_intra_mode ( r , <S2SV_EndBug> <S2SV_StartBug> cm -> fc . uv_mode_prob [ y_mode ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ","<S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> MACROBLOCKD * xd , vpx_reader <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
930,CWE-476,"<S2SV_StartBug> return crypto_alloc_skcipher ( name , type , mask ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> struct skcipher_tfm * tfm ; struct crypto_skcipher * skcipher ; tfm = kzalloc ( sizeof ( * tfm ) , GFP_KERNEL ) ; if ( ! tfm ) return ERR_PTR ( - ENOMEM ) ; skcipher = <S2SV_ModEnd> <S2SV_ModStart> if ( IS_ERR ( skcipher ) ) { kfree ( tfm ) ; return ERR_CAST ( skcipher ) ; } tfm -> skcipher = skcipher ; return tfm ; ",torvalds@linux/dd504589577d8e8e70f51f997ad487a4cb6c026f,CVE-2015-8970,https://github.com/torvalds/linux/commit/dd504589577d8e8e70f51f997ad487a4cb6c026f,2016-11-28T03:59Z
931,CWE-401,<S2SV_StartBug> ret = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> goto e_ctx ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( hmac_buf ) ; <S2SV_ModStart> e_data <S2SV_ModEnd> ,torvalds@linux/128c66429247add5128c03dc1e144ca56f05a4e2,CVE-2019-18808,https://github.com/torvalds/linux/commit/128c66429247add5128c03dc1e144ca56f05a4e2,2019-11-07T16:15Z
932,CWE-189,"<S2SV_StartBug> c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * 3 ,FFmpeg@FFmpeg/821a5938d100458f4d09d634041b05c860554ce0,CVE-2013-7013,https://github.com/FFmpeg/FFmpeg/commit/821a5938d100458f4d09d634041b05c860554ce0,2013-12-09T16:36Z
933,CWE-326,<S2SV_StartBug> return Qnil ; <S2SV_EndBug> ,"<S2SV_ModStart> rb_ivar_set ( self , id_key_set , Qtrue ) ; ",ruby@openssl/8108e0a6db133f3375608303fdd2083eb5115062,CVE-2016-7798,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,2017-01-30T22:59Z
934,CWE-119,"
","
",mdadams@jasper/4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a,CVE-2016-8654,https://github.com/mdadams/jasper/commit/4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a,2018-08-01T16:29Z
935,CWE-119,"<S2SV_StartBug> register_savevm ( dev , ""stellaris_enet"" , - 1 , 1 , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,qemu@qemu/2e1198672759eda6e122ff38fcf6df06f27e0fe2,CVE-2013-4532,https://github.com/qemu/qemu/commit/2e1198672759eda6e122ff38fcf6df06f27e0fe2,2020-01-02T16:15Z
936,CWE-125,"<S2SV_StartBug> register u_int length = h -> len ; <S2SV_EndBug> <S2SV_StartBug> return ( chdlc_print ( ndo , p , length ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart> h -> len <S2SV_ModEnd> ,the-tcpdump-group@tcpdump/a1eefe986065846b6c69dbc09afd9fa1a02c4a3d,CVE-2017-13687,https://github.com/the-tcpdump-group/tcpdump/commit/a1eefe986065846b6c69dbc09afd9fa1a02c4a3d,2017-09-14T06:29Z
937,CWE-20,<S2SV_StartBug> if ( ! rc && cifs_sb -> prepathlen && tcon ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/70945643722ffeac779d2529a348f99567fa5c33,CVE-2011-3363,https://github.com/torvalds/linux/commit/70945643722ffeac779d2529a348f99567fa5c33,2012-05-24T23:55Z
938,CWE-125,<S2SV_StartBug> ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <S2SV_EndBug> ,<S2SV_ModStart> SKB_EXT_ERR ( skb ) -> opt_stats <S2SV_ModEnd> ,torvalds@linux/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,CVE-2017-7277,https://github.com/torvalds/linux/commit/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,2017-03-28T06:59Z
939,CWE-200,<S2SV_StartBug> if ( rdf_parser -> uri_filter ) <S2SV_EndBug> ,"<S2SV_ModStart> raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ; ",dajobe@raptor/a676f235309a59d4aa78eeffd2574ae5d341fcb0,CVE-2012-0037,https://github.com/dajobe/raptor/commit/a676f235309a59d4aa78eeffd2574ae5d341fcb0,2012-06-17T03:41Z
940,CWE-310,<S2SV_StartBug> if ( ( rsa = RSA_new ( ) ) == NULL ) <S2SV_EndBug> ,"<S2SV_ModStart> ! SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_SERVER_CERTIFICATE , SSL_R_UNEXPECTED_MESSAGE ) ; goto f_err ; } if ( ",openssl@openssl/ce325c60c74b0fa784f5872404b722e120e5cab0,CVE-2015-0204,https://github.com/openssl/openssl/commit/ce325c60c74b0fa784f5872404b722e120e5cab0,2015-01-09T02:59Z
941,CWE-120,<S2SV_StartBug> return SECURE_ELEMENT_ERROR_NPE ; <S2SV_EndBug> ,<S2SV_ModStart> ; } if ( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE ) { return SECURE_ELEMENT_ERROR_BUF_SIZE ,Lora-net@LoRaMac-node/e3063a91daa7ad8a687223efa63079f0c24568e4,CVE-2020-11068,https://github.com/Lora-net/LoRaMac-node/commit/e3063a91daa7ad8a687223efa63079f0c24568e4,2020-06-23T17:15Z
942,CWE-400,<S2SV_StartBug> iframe -> state = NGHTTP2_IB_READ_SETTINGS ; <S2SV_EndBug> ,<S2SV_ModStart> if ( session -> obq_flood_counter_ >= session -> max_outbound_ack && ! ( iframe -> frame . hd . flags & NGHTTP2_FLAG_ACK ) ) { return NGHTTP2_ERR_FLOODED ; } ,nghttp2@nghttp2/f8da73bd042f810f34d19f9eae02b46d870af394,CVE-2020-11080,https://github.com/nghttp2/nghttp2/commit/f8da73bd042f810f34d19f9eae02b46d870af394,2020-06-03T23:15Z
943,CWE-400,<S2SV_StartBug> return new_ns ; <S2SV_EndBug> ,<S2SV_ModStart> new_ns -> mounts = 0 ; new_ns -> pending_mounts = 0 ; ,torvalds@linux/d29216842a85c7970c536108e093963f02714498,CVE-2016-6213,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,2016-12-28T07:59Z
944,CWE-416,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> atomic_set ( & opt2 -> refcnt , 1 ) ; ",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
945,CWE-20,<S2SV_StartBug> x86_pmu . extra_regs = intel_snb_extra_regs ; <S2SV_EndBug> <S2SV_StartBug> x86_pmu . pebs_aliases = intel_pebs_aliases_snb ; <S2SV_EndBug> ,<S2SV_ModStart> if ( boot_cpu_data . x86_model == 45 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else <S2SV_ModStart> if ( boot_cpu_data . x86_model == 62 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else ,torvalds@linux/f1923820c447e986a9da0fc6bf60c1dccdf0408e,CVE-2013-2146,https://github.com/torvalds/linux/commit/f1923820c447e986a9da0fc6bf60c1dccdf0408e,2013-06-07T14:03Z
946,CWE-119,<S2SV_StartBug> int n_read = r -> end - r -> begin ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned int actual_size = rtype == 2 ? n * 2 : n ; unsigned int limit_r_begin = ( r -> begin < actual_size ? r -> begin : actual_size ) ; unsigned int limit_r_end = ( r -> end < actual_size ? r -> end : actual_size ) ; <S2SV_ModStart> limit_r_end - limit_r_begin <S2SV_ModEnd> ,nothings@stb/244d83bc3d859293f55812d48b3db168e581f6ab,CVE-2018-1000050,https://github.com/nothings/stb/commit/244d83bc3d859293f55812d48b3db168e581f6ab,2018-02-09T23:29Z
947,CWE-200,<S2SV_StartBug> u32 now ; <S2SV_EndBug> <S2SV_StartBug> challenge_timestamp = now ; <S2SV_EndBug> <S2SV_StartBug> challenge_count = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> count , <S2SV_ModStart> u32 half = ( sysctl_tcp_challenge_ack_limit + 1 ) >> 1 ; <S2SV_ModStart> WRITE_ONCE ( challenge_count , half + prandom_u32_max ( sysctl_tcp_challenge_ack_limit ) ) ; } count = READ_ONCE ( challenge_count ) ; if ( count > 0 ) { WRITE_ONCE ( challenge_count , count - 1 ) ; <S2SV_ModEnd> ",torvalds@linux/75ff39ccc1bd5d3c455b6822ab09e533c551f758,CVE-2016-5696,https://github.com/torvalds/linux/commit/75ff39ccc1bd5d3c455b6822ab09e533c551f758,2016-08-06T20:59Z
948,CWE-200,<S2SV_StartBug> struct llc_pktinfo info ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & info , 0 , sizeof ( info ) ) ",torvalds@linux/b8670c09f37bdf2847cc44f36511a53afc6161fd,CVE-2016-4485,https://github.com/torvalds/linux/commit/b8670c09f37bdf2847cc44f36511a53afc6161fd,2016-05-23T10:59Z
949,CWE-119,"<S2SV_StartBug> static void pack_mb_tokens ( vp9_writer * w , <S2SV_EndBug> <S2SV_StartBug> TOKENEXTRA * * tp , const TOKENEXTRA * stop ) { <S2SV_EndBug> <S2SV_StartBug> const vp9_extra_bit * const b = & vp9_extra_bits [ t ] ; <S2SV_EndBug> <S2SV_StartBug> int i = 0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , bb , pb [ i >> 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_bit ( w , e & 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> const stop , vpx_bit_depth_t bit_depth <S2SV_ModEnd> <S2SV_ModStart> int i = 0 ; int v = a -> value ; int n = a -> len ; # if CONFIG_VP9_HIGHBITDEPTH <S2SV_ModStart> b ; if ( bit_depth == VPX_BITS_12 ) b = & vp9_extra_bits_high12 [ t ] ; else if ( bit_depth == VPX_BITS_10 ) b = & vp9_extra_bits_high10 [ t ] ; else <S2SV_ModEnd> <S2SV_ModStart> # else const vp9_extra_bit * const b = & vp9_extra_bits [ t ] ; ( void ) bit_depth ; # endif <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write_bit <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
950,CWE-119,"<S2SV_StartBug> struct vp9_write_bit_buffer wb = { data , 0 } ; <S2SV_EndBug> <S2SV_StartBug> struct vp9_write_bit_buffer saved_wb ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( & wb , 0 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> uncompressed_hdr_size = vp9_rb_bytes_written ( & wb ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_compute_update_table ( ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( & saved_wb , ( int ) first_part_size , 16 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_bytes_written <S2SV_ModEnd> <S2SV_ModStart> vpx_clear_system_state <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
951,CWE-476,"<S2SV_StartBug> static int dev_get_valid_name ( struct net * net , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/0ad646c81b2182f7fa67ec0c8c825e0ee165696d,CVE-2018-7191,https://github.com/torvalds/linux/commit/0ad646c81b2182f7fa67ec0c8c825e0ee165696d,2019-05-17T05:29Z
952,CWE-125,"<S2SV_StartBug> int ret , n ; <S2SV_EndBug> <S2SV_StartBug> hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; <S2SV_EndBug> <S2SV_StartBug> hid -> country = hdesc -> bCountryCode ; <S2SV_EndBug> <S2SV_StartBug> for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) <S2SV_EndBug> ","<S2SV_ModStart> ; int num_descriptors ; size_t offset = offsetof ( struct hid_descriptor , desc ) <S2SV_ModStart> if ( hdesc -> bLength < sizeof ( struct hid_descriptor ) ) { dbg_hid ( ""hid<S2SV_blank>descriptor<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\\n"" ) ; return - EINVAL ; } <S2SV_ModStart> ; num_descriptors = min_t ( int , hdesc -> bNumDescriptors , ( hdesc -> bLength - offset ) / sizeof ( struct hid_class_descriptor ) ) <S2SV_ModStart> num_descriptors <S2SV_ModEnd> ",torvalds@linux/f043bfc98c193c284e2cd768fefabe18ac2fed9b,CVE-2017-16533,https://github.com/torvalds/linux/commit/f043bfc98c193c284e2cd768fefabe18ac2fed9b,2017-11-04T01:29Z
953,CWE-125,<S2SV_StartBug> struct ikev2_id id ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> ,<S2SV_ModStart> const struct ikev2_id * idp ; <S2SV_ModStart> idp = ( const struct ikev2_id * ) ext ; <S2SV_ModStart> idp <S2SV_ModEnd> ,the-tcpdump-group@tcpdump/8dca25d26c7ca2caf6138267f6f17111212c156e,CVE-2017-13690,https://github.com/the-tcpdump-group/tcpdump/commit/8dca25d26c7ca2caf6138267f6f17111212c156e,2017-09-14T06:29Z
954,CWE-264,<S2SV_StartBug> # ifdef CONFIG_FUTEX <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( tsk -> robust_list ) ) <S2SV_EndBug> ,"<S2SV_ModStart> if ( group_dead ) tty_audit_exit ( ) ; if ( unlikely ( tsk -> audit_context ) ) audit_free ( tsk ) ; tsk -> exit_code = code ; taskstats_exit ( tsk , group_dead ) ; exit_mm ( tsk ) ; if ( group_dead ) acct_process ( ) ; trace_sched_process_exit ( tsk ) ; exit_sem ( tsk ) ; exit_files ( tsk ) ; exit_fs ( tsk ) ; check_stack_usage ( ) ; exit_thread ( ) ; cgroup_exit ( tsk , 1 ) ; exit_keys ( tsk ) ; if ( group_dead && tsk -> signal -> leader ) disassociate_ctty ( 1 ) ; module_put ( task_thread_info ( tsk ) -> exec_domain -> module ) ; if ( tsk -> binfmt ) module_put ( tsk -> binfmt -> module ) ; proc_exit_connector ( tsk ) ; exit_notify ( tsk , group_dead ) ; # ifdef CONFIG_NUMA mpol_put ( tsk -> mempolicy ) ; tsk -> mempolicy = NULL ; # endif <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/8141c7f3e7aee618312fa1c15109e1219de784a7,CVE-2012-0028,https://github.com/torvalds/linux/commit/8141c7f3e7aee618312fa1c15109e1219de784a7,2012-06-21T23:55Z
955,CWE-119,"<S2SV_StartBug> struct strbuf * path , const char * last , <S2SV_EndBug> <S2SV_StartBug> char * name = path_name ( path , last ) ; <S2SV_EndBug> <S2SV_StartBug> free ( ( char * ) name ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,git@git/de1e67d0703894cb6ea782e36abb63976ab07e60,CVE-2016-2324,https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60,2016-04-08T14:59Z
956,CWE-416,<S2SV_StartBug> jas_tvparser_destroy ( tvp ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> jas_tvparser_destroy ( tvp ) ; ,mdadams@jasper/df5d2867e8004e51e18b89865bc4aa69229227b3,CVE-2015-5221,https://github.com/mdadams/jasper/commit/df5d2867e8004e51e18b89865bc4aa69229227b3,2017-07-25T18:29Z
957,CWE-401,<S2SV_StartBug> ret = - EINVAL ; <S2SV_EndBug> ,<S2SV_ModStart> usb_free_urb ( urb ) ; ,torvalds@linux/b8d17e7d93d2beb89e4f34c59996376b8b544792,CVE-2019-19078,https://github.com/torvalds/linux/commit/b8d17e7d93d2beb89e4f34c59996376b8b544792,2019-11-18T06:15Z
958,CWE-787,"<S2SV_StartBug> WORD32 xt0_0 , yt0_0 , xt1_0 , yt1_0 , xt2_0 , yt2_0 ; <S2SV_EndBug> <S2SV_StartBug> WORD32 xh0_0 , xh1_0 , xh20_0 , xh21_0 , xl0_0 , xl1_0 , xl20_0 , xl21_0 ; <S2SV_EndBug> <S2SV_StartBug> xh0_0 = x_0 + x_l1_0 ; <S2SV_EndBug> <S2SV_StartBug> xl0_0 = x_0 - x_l1_0 ; <S2SV_EndBug> <S2SV_StartBug> xh20_0 = x_h2_0 + x_l2_0 ; <S2SV_EndBug> <S2SV_StartBug> xl20_0 = x_h2_0 - x_l2_0 ; <S2SV_EndBug> <S2SV_StartBug> x [ 0 ] = xh0_0 + xh20_0 ; <S2SV_EndBug> <S2SV_StartBug> xt0_0 = xh0_0 - xh20_0 ; <S2SV_EndBug> <S2SV_StartBug> xh1_0 = x_1 + x_l1_1 ; <S2SV_EndBug> <S2SV_StartBug> xl1_0 = x_1 - x_l1_1 ; <S2SV_EndBug> <S2SV_StartBug> xh21_0 = x_h2_1 + x_l2_1 ; <S2SV_EndBug> <S2SV_StartBug> xl21_0 = x_h2_1 - x_l2_1 ; <S2SV_EndBug> <S2SV_StartBug> x [ 1 ] = xh1_0 + xh21_0 ; <S2SV_EndBug> <S2SV_StartBug> yt0_0 = xh1_0 - xh21_0 ; <S2SV_EndBug> <S2SV_StartBug> xt1_0 = xl0_0 + xl21_0 ; <S2SV_EndBug> <S2SV_StartBug> xt2_0 = xl0_0 - xl21_0 ; <S2SV_EndBug> <S2SV_StartBug> yt2_0 = xl1_0 + xl20_0 ; <S2SV_EndBug> <S2SV_StartBug> yt1_0 = xl1_0 - xl20_0 ; <S2SV_EndBug> ","<S2SV_ModStart> WORD64 <S2SV_ModEnd> <S2SV_ModStart> WORD64 <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) x_0 + ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) x_0 - ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) x_h2_0 + ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) x_h2_0 - ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD32 ) ixheaacd_add64_sat ( xh0_0 , xh20_0 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) xh0_0 - ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) x_1 + ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) x_1 - ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) x_h2_1 + ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) x_h2_1 - ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD32 ) ixheaacd_add64_sat ( xh1_0 , xh21_0 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) xh1_0 - ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) xl0_0 + ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) xl0_0 - ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) xl1_0 + ( WORD64 ) <S2SV_ModEnd> <S2SV_ModStart> ( WORD64 ) xl1_0 - ( WORD64 ) <S2SV_ModEnd> ",external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z
959,CWE-000,<S2SV_StartBug> if ( tag == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( len <= 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( n > sizeof ( size_t ) - 1 ) ) <S2SV_EndBug> <S2SV_StartBug> for ( len = 0 ; n > 0 ; n -- ) { <S2SV_EndBug> <S2SV_StartBug> dp += len ; <S2SV_EndBug> ,<S2SV_ModStart> ASN1_EOC <S2SV_ModEnd> <S2SV_ModStart> goto check_length ; <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> len = 0 ; for ( <S2SV_ModEnd> <S2SV_ModStart> check_length : if ( len > datalen - dp ) goto data_overrun_error ; ,torvalds@linux/23c8a812dc3c621009e4f0e5342aa4e2ede1ceaa,CVE-2016-0758,https://github.com/torvalds/linux/commit/23c8a812dc3c621009e4f0e5342aa4e2ede1ceaa,2016-06-27T10:59Z
960,CWE-200,<S2SV_StartBug> if ( flags & __GFP_ZERO ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/6829e274a623187c24f7cfc0e3d35f25d087fcc5,CVE-2015-8950,https://github.com/torvalds/linux/commit/6829e274a623187c24f7cfc0e3d35f25d087fcc5,2016-10-10T10:59Z
961,CWE-59,"<S2SV_StartBug> return mount_entry_on_generic ( mntent , mntent -> mnt_dir ) ; <S2SV_EndBug> ","<S2SV_ModStart> , NULL ",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z
962,CWE-119,"<S2SV_StartBug> PHP_SHA512Init ( & context ) ; <S2SV_EndBug> <S2SV_StartBug> PHP_SHA256Init ( & context ) ; <S2SV_EndBug> <S2SV_StartBug> PHP_SHA1Init ( & context ) ; <S2SV_EndBug> <S2SV_StartBug> PHP_MD5Init ( & context ) ; <S2SV_EndBug> <S2SV_StartBug> * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } <S2SV_ModStart> if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } <S2SV_ModStart> if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } <S2SV_ModStart> if ( sig_len < sizeof ( digest <S2SV_ModEnd> <S2SV_ModStart> PHP_MD5Init ( & context ) ; read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_MD5Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_MD5Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } ",php@php-src/0bfb970f43acd1e81d11be1154805f86655f15d5,CVE-2016-7414,https://github.com/php/php-src/commit/0bfb970f43acd1e81d11be1154805f86655f15d5?w=1,2016-09-17T21:59Z
963,CWE-125,<S2SV_StartBug> value [ n ] >= min && value [ n ] <= max && <S2SV_EndBug> <S2SV_StartBug> && field -> usage [ field -> value [ n ] - min ] . hid <S2SV_EndBug> <S2SV_StartBug> && field -> usage [ value [ n ] - min ] . hid <S2SV_EndBug> ,<S2SV_ModStart> && value [ n ] - min < field -> maxusage <S2SV_ModStart> value [ n ] - min < field -> maxusage && field -> <S2SV_ModStart> value [ n ] - min < field -> maxusage && ,torvalds@linux/50220dead1650609206efe91f0cc116132d59b3f,CVE-2016-7915,https://github.com/torvalds/linux/commit/50220dead1650609206efe91f0cc116132d59b3f,2016-11-16T05:59Z
964,CWE-119,"<S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , scaling_active ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> display_width - 1 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> display_height - 1 , 16 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
965,CWE-119,<S2SV_StartBug> if ( argReg >= regsz ) { <S2SV_EndBug> ,<S2SV_ModStart> > <S2SV_ModEnd> <S2SV_ModStart> return ; ,radare@radare2/ad55822430a03fe075221b543efb434567e9e431,CVE-2017-6319,https://github.com/radare/radare2/commit/ad55822430a03fe075221b543efb434567e9e431,2017-03-02T01:59Z
966,CWE-444,"<S2SV_StartBug> rb_hash_aset ( env , server_name_val , req_server_name ( req ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> remote_addr_val , req_remote_addr ( req ) ) ; rb_hash_aset ( env , server_port_val , req_server_port ( req ) ) ; rb_hash_aset ( env , <S2SV_ModStart>  <S2SV_ModEnd> ",ohler55@agoo/23d03535cf7b50d679a60a953a0cae9519a4a130,CVE-2020-7670,https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130,2020-06-10T16:15Z
967,CWE-19,<S2SV_StartBug> valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; <S2SV_EndBug> <S2SV_StartBug> valuelen ) ; <S2SV_EndBug> <S2SV_StartBug> args -> valuelen = valuelen ; <S2SV_EndBug> <S2SV_StartBug> if ( args -> valuelen < valuelen ) { <S2SV_EndBug> <S2SV_StartBug> args -> valuelen = valuelen ; <S2SV_EndBug> ,<S2SV_ModStart> args -> rmtvaluelen <S2SV_ModEnd> <S2SV_ModStart> args -> rmtvaluelen <S2SV_ModEnd> <S2SV_ModStart> args -> rmtvaluelen <S2SV_ModEnd> <S2SV_ModStart> args -> rmtvaluelen ) { args -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> <S2SV_ModStart> args -> rmtvaluelen <S2SV_ModEnd> ,torvalds@linux/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,CVE-2015-0274,https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,2015-03-16T10:59Z
968,CWE-189,<S2SV_StartBug> size_t sz = sizeof ( * info ) + size ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( sz < sizeof ( * info ) ) return NULL ,torvalds@linux/d157bd761585605b7882935ffb86286919f62ea1,CVE-2016-3135,https://github.com/torvalds/linux/commit/d157bd761585605b7882935ffb86286919f62ea1,2016-04-27T17:59Z
969,CWE-125,"<S2SV_StartBug> int col_type , prepare_retval ; <S2SV_EndBug> <S2SV_StartBug> ""ERROR:<S2SV_blank>Trying<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>new<S2SV_blank>stmt<S2SV_blank>while<S2SV_blank>we<S2SV_blank>have<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>already<S2SV_blank>not<S2SV_blank>closed<S2SV_blank>one<S2SV_blank>\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> ""\\t\\tERROR:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>return<S2SV_blank>MYSQL_STMT<S2SV_blank>structure<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>from<S2SV_blank>mysql_stmt_init():<S2SV_blank>ERROR<S2SV_blank>NO:<S2SV_blank>%d<S2SV_blank>ERROR<S2SV_blank>MSG:%s\\n"" , <S2SV_EndBug> <S2SV_StartBug> int has_statement_fields = imp_sth -> stmt -> fields != 0 ; <S2SV_EndBug> <S2SV_StartBug> col_type = ( has_statement_fields ? <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""ERROR:<S2SV_blank>Trying<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>new<S2SV_blank>stmt<S2SV_blank>while<S2SV_blank>we<S2SV_blank>have<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>already<S2SV_blank>not<S2SV_blank>closed<S2SV_blank>one<S2SV_blank>\\n"" <S2SV_ModEnd> <S2SV_ModStart> ""\\t\\tERROR:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>return<S2SV_blank>MYSQL_STMT<S2SV_blank>structure<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>from<S2SV_blank>mysql_stmt_init():<S2SV_blank>ERROR<S2SV_blank>NO:<S2SV_blank>%d<S2SV_blank>ERROR<S2SV_blank>MSG:%s\\n"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> bind -> buffer_type = MYSQL_TYPE_STRING <S2SV_ModEnd> ",perl5-dbi@DBD-mysql/793b72b1a0baa5070adacaac0e12fd995a6fbabe,CVE-2016-1249,https://github.com/perl5-dbi/DBD-mysql/commit/793b72b1a0baa5070adacaac0e12fd995a6fbabe,2017-02-17T02:59Z
970,CWE-20,<S2SV_StartBug> if ( key -> type -> destroy ) <S2SV_EndBug> ,"<S2SV_ModStart> test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && ",torvalds@linux/ce1fad2740c648a4340f6f6c391a8a83769d2e8c,CVE-2015-7872,https://github.com/torvalds/linux/commit/ce1fad2740c648a4340f6f6c391a8a83769d2e8c,2015-11-16T11:59Z
971,CWE-189,"<S2SV_StartBug> commonlen = COMPUTESIZE ( state . num , state . sumlen ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( LTXTQUERY_TOO_BIG ( state . num , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""ltxtquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ; ",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z
972,CWE-000,"<S2SV_StartBug> int need = 0 ; <S2SV_EndBug> <S2SV_StartBug> need *= 4 ; <S2SV_EndBug> <S2SV_StartBug> TRACE ( ( ""Salted<S2SV_blank>TEXT:%u:%s\\n"" , ( unsigned ) ( lp - line ) , <S2SV_EndBug> <S2SV_StartBug> visibleChars ( line , ( unsigned ) ( lp - line ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> scp -> data_length = ( size_t ) ( lp - line ) ; <S2SV_EndBug> ","<S2SV_ModStart> = 0 ; size_t have <S2SV_ModStart> if ( need > 0 ) { if ( screen -> max_combining > 0 ) need += screen -> max_combining ; need *= 6 ; } <S2SV_ModEnd> <S2SV_ModStart> have = ( size_t ) ( lp - line ) ; if ( ( have * 2 ) < ( size_t ) need ) { scp -> data_limit = have + 1 ; line = realloc ( line , scp -> data_limit ) ; } <S2SV_ModStart> have <S2SV_ModEnd> <S2SV_ModStart> have <S2SV_ModEnd> <S2SV_ModStart> have <S2SV_ModEnd> ",ThomasDickey@xterm-snapshots/82ba55b8f994ab30ff561a347b82ea340ba7075c,CVE-2021-27135,https://github.com/ThomasDickey/xterm-snapshots/commit/82ba55b8f994ab30ff561a347b82ea340ba7075c,2021-02-10T16:15Z
973,CWE-20,<S2SV_StartBug> if ( handle && ! ext4_handle_valid ( handle ) ) <S2SV_EndBug> <S2SV_StartBug> if ( sbi -> s_journal && ! handle ) <S2SV_EndBug> ,<S2SV_ModStart> ! EXT4_SB ( inode -> i_sb ) -> s_journal <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/c9b92530a723ac5ef8e352885a1862b18f31b2f5,CVE-2015-7509,https://github.com/torvalds/linux/commit/c9b92530a723ac5ef8e352885a1862b18f31b2f5,2015-12-28T11:59Z
974,CWE-119,"<S2SV_StartBug> void ftoa_bounded_extra ( JsVarFloat val , char * str , size_t len , int radix , int fractionalDigits ) { <S2SV_EndBug> <S2SV_StartBug> if ( isnan ( val ) ) strncpy ( str , ""NaN"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( val < 0 ) strncpy ( str , ""-Infinity"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> else strncpy ( str , ""Infinity"" , len ) ; <S2SV_EndBug> ",<S2SV_ModStart> assert ( len > 9 ) ; <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,espruino@Espruino/0a7619875bf79877907205f6bee08465b89ff10b,CVE-2018-11595,https://github.com/espruino/Espruino/commit/0a7619875bf79877907205f6bee08465b89ff10b,2018-05-31T16:29Z
975,CWE-787,"<S2SV_StartBug> if ( fscanf ( f , ""PG%[<S2SV_blank>\\t]%c%c%[<S2SV_blank>\\t+-]%d%[<S2SV_blank>\\t]%d%[<S2SV_blank>\\t]%d"" , temp , & endian1 , <S2SV_EndBug> ","<S2SV_ModStart> ""PG%31[<S2SV_blank>\\t]%c%c%31[<S2SV_blank>\\t+-]%d%31[<S2SV_blank>\\t]%d%31[<S2SV_blank>\\t]%d"" <S2SV_ModEnd> ",uclouvain@openjpeg/e5285319229a5d77bf316bb0d3a6cbd3cb8666d9,CVE-2017-14041,https://github.com/uclouvain/openjpeg/commit/e5285319229a5d77bf316bb0d3a6cbd3cb8666d9,2017-08-30T22:29Z
976,CWE-787,<S2SV_StartBug> if ( size < 6 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> 5 + 1 <S2SV_ModEnd> <S2SV_ModStart> for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , ""DEADBEEF"" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , ""%2.0f"" , 1.6314159265358979e+125 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , ""163141592653589790215729350939528493057529598899734151772468186268423257777068536614838678161083520756952076273094236944990208"" ) == 0 ) ; ASSERT ( length == 126 ) ; if ( size < 126 + 1 ) ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & ""DEADBEEF"" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; } ",coreutils@gnulib/278b4175c9d7dd47c1a3071554aac02add3b3c35,CVE-2018-17942,https://github.com/coreutils/gnulib/commit/278b4175c9d7dd47c1a3071554aac02add3b3c35,2018-10-03T08:29Z
977,CWE-200,<S2SV_StartBug> if ( unlikely ( crng_init == 0 ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> this_cpu_add ( net_rand_state . s1 , fast_pool -> pool [ cycles & 3 ] ) ; ",torvalds@linux/f227e3ec3b5cad859ad15666874405e8c1bbc1d4,CVE-2020-16166,https://github.com/torvalds/linux/commit/f227e3ec3b5cad859ad15666874405e8c1bbc1d4,2020-07-30T21:15Z
978,CWE-119,"<S2SV_StartBug> strncpy ( str , ""ID:"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( str , jslGetTokenValueAsString ( ) , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( str , ""String:\'"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( str , jslGetTokenValueAsString ( ) , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> espruino_snprintf <S2SV_ModEnd> <S2SV_ModStart> len , ""ID:%s"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> espruino_snprintf <S2SV_ModEnd> <S2SV_ModStart> len , ""String:\'%s\'"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",espruino@Espruino/0a7619875bf79877907205f6bee08465b89ff10b,CVE-2018-11595,https://github.com/espruino/Espruino/commit/0a7619875bf79877907205f6bee08465b89ff10b,2018-05-31T16:29Z
979,CWE-22,"<S2SV_StartBug> char * to , * repl ; <S2SV_EndBug> <S2SV_StartBug> if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { <S2SV_EndBug> <S2SV_StartBug> to = g . hname ; <S2SV_EndBug> <S2SV_StartBug> len = strlen ( g . hname ) ; <S2SV_EndBug> <S2SV_StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; <S2SV_EndBug> <S2SV_StartBug> g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( g . outf , to , len ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <S2SV_EndBug> ","<S2SV_ModStart> = g . inf , * sufx = """" ; size_t pre = 0 <S2SV_ModEnd> <S2SV_ModStart> ) { if ( <S2SV_ModEnd> <S2SV_ModStart> pre = justname ( g . inf ) - g . inf ; to = justname ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> to ) ; } else if ( <S2SV_ModEnd> <S2SV_ModStart> == 0 ) sufx = "".tar"" ; } else sufx = g . sufx ; <S2SV_ModEnd> <S2SV_ModStart> pre + len + strlen ( sufx ) <S2SV_ModEnd> <S2SV_ModStart> g . inf , pre ) ; memcpy <S2SV_ModEnd> <S2SV_ModStart> pre , to , len ) ; strcpy ( g . outf + pre + len , <S2SV_ModEnd> ",madler@pigz/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,CVE-2015-1191,https://github.com/madler/pigz/commit/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,2015-01-21T18:59Z
980,CWE-119,"
","
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
981,CWE-252,"<S2SV_StartBug> int <S2SV_EndBug> <S2SV_StartBug> for ( i = 2 ; i < ( ssize_t ) ( argc - 1 ) ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> ( void ) fputc ( ( char ) c , output ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) fclose ( input ) ; <S2SV_EndBug> <S2SV_StartBug> return ( MagickTrue ) ; <S2SV_EndBug> ","<S2SV_ModStart> MagickBooleanType status ; <S2SV_ModStart> status = MagickTrue ; <S2SV_ModStart> { <S2SV_ModEnd> <S2SV_ModStart> if ( fputc ( ( char ) c , output ) != c ) status = MagickFalse ; <S2SV_ModStart> fclose ( input <S2SV_ModEnd> <S2SV_ModStart> remove_utf8 ( argv [ i ] ) ; } ( void ) fclose ( <S2SV_ModEnd> <S2SV_ModStart> status <S2SV_ModEnd> ",ImageMagick@ImageMagick/933e96f01a8c889c7bf5ffd30020e86a02a046e7,CVE-2016-10060,https://github.com/ImageMagick/ImageMagick/commit/933e96f01a8c889c7bf5ffd30020e86a02a046e7,2017-03-02T21:59Z
982,CWE-119,<S2SV_StartBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <S2SV_EndBug> ,<S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
983,CWE-20,"<S2SV_StartBug> ext3_msg ( sb , ""error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>journal<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%ld"" , <S2SV_EndBug> ","<S2SV_ModStart> KERN_ERR , ",torvalds@linux/8d0c2d10dd72c5292eda7a06231056a4c972e4cc,CVE-2013-1848,https://github.com/torvalds/linux/commit/8d0c2d10dd72c5292eda7a06231056a4c972e4cc,2013-03-22T11:59Z
984,CWE-264,"<S2SV_StartBug> int setpwnam ( struct passwd * pwd ) <S2SV_EndBug> <S2SV_StartBug> char * atomic_dir = ""/etc"" ; <S2SV_EndBug> <S2SV_StartBug> if ( ( fp = xfmkstemp ( & tmpname , atomic_dir ) ) == NULL ) <S2SV_EndBug> ","<S2SV_ModStart> , const char * prefix <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""/etc"" , prefix <S2SV_ModEnd> ",karelzak@util-linux/bde91c85bdc77975155058276f99d2e0f5eab5a9,CVE-2015-5224,https://github.com/karelzak/util-linux/commit/bde91c85bdc77975155058276f99d2e0f5eab5a9,2017-08-23T15:29Z
985,CWE-119,"<S2SV_StartBug> static unsigned int convert_distribution ( unsigned int i , vp9_tree tree , <S2SV_EndBug> ",<S2SV_ModStart> vpx_tree <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
986,CWE-125,"<S2SV_StartBug> return pure_memcmp ( s1 , s2 , strlen ( s1 ) + 1U ) ; <S2SV_EndBug> ",<S2SV_ModStart> const size_t s1_len = strlen ( s1 ) ; const size_t s2_len = strlen ( s2 ) ; const size_t len = ( s1_len < s2_len ) ? s1_len : s2_len ; <S2SV_ModStart> len + 1 <S2SV_ModEnd> ,jedisct1@pure-ftpd/bf6fcd4935e95128cf22af5924cdc8fe5c0579da,CVE-2020-9365,https://github.com/jedisct1/pure-ftpd/commit/bf6fcd4935e95128cf22af5924cdc8fe5c0579da,2020-02-24T16:15Z
987,CWE-346,<S2SV_StartBug> const gchar * to = xmpp_stanza_get_to ( message ) ; <S2SV_EndBug> <S2SV_StartBug> Jid * jid_to = jid_create ( to ) ; <S2SV_EndBug> ,"<S2SV_ModStart> Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ; const char * const stanza_from = xmpp_stanza_get_from ( stanza ) ; Jid * msg_jid = jid_create ( stanza_from ) ; if ( g_strcmp0 ( my_jid -> barejid , msg_jid -> barejid ) != 0 ) { log_warning ( ""Invalid<S2SV_blank>carbon<S2SV_blank>received,<S2SV_blank>from:<S2SV_blank>%s"" , stanza_from ) ; return TRUE ; } <S2SV_ModStart>  <S2SV_ModEnd> ",boothj5@profanity/8e75437a7e43d4c55e861691f74892e666e29b0b,CVE-2017-5592,https://github.com/boothj5/profanity/commit/8e75437a7e43d4c55e861691f74892e666e29b0b,2017-02-09T20:59Z
988,CWE-119,<S2SV_StartBug> if ( getClientTypeByName ( v [ j ] ) == - 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> int class = <S2SV_ModEnd> <S2SV_ModStart> ; if ( class <S2SV_ModStart> || class == CLIENT_TYPE_MASTER ,antirez@redis/6d9f8e2462fc2c426d48c941edeb78e5df7d2977,CVE-2016-8339,https://github.com/antirez/redis/commit/6d9f8e2462fc2c426d48c941edeb78e5df7d2977,2016-10-28T14:59Z
989,CWE-476,"<S2SV_StartBug> static int dev_get_valid_name ( struct net * net , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/0ad646c81b2182f7fa67ec0c8c825e0ee165696d,CVE-2018-7191,https://github.com/torvalds/linux/commit/0ad646c81b2182f7fa67ec0c8c825e0ee165696d,2019-05-17T05:29Z
990,CWE-295,"<S2SV_StartBug> parse_global_option ( CMD_PRINT_HELP , NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> parse_global_option ( CMD_PRINT_DEFAULTS , NULL , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> , NULL <S2SV_ModStart> , NULL ",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z
991,CWE-20,<S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
992,CWE-125,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> ,python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
993,CWE-125,<S2SV_StartBug> st -> st_state -> name ) ; <S2SV_EndBug> ,<S2SV_ModStart> finite_states [ smc -> state ] <S2SV_ModEnd> ,libreswan@libreswan/471a3e41a449d7c753bc4edbba4239501bb62ba8,CVE-2020-1763,https://github.com/libreswan/libreswan/commit/471a3e41a449d7c753bc4edbba4239501bb62ba8,2020-05-12T14:15Z
994,CWE-787,<S2SV_StartBug> ps_dec -> u2_header_done = 1 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ps_dec -> u2_horizontal_size ; } ,external@libmpeg2/bef16671c891e16f25a7b174bc528eea109357be,CVE-2018-9497,https://android.googlesource.com/platform/external/libmpeg2/+/bef16671c891e16f25a7b174bc528eea109357be,2018-10-02T19:29Z
995,CWE-190,"<S2SV_StartBug> int x , y , i ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( tilemap = malloc ( x_size * y_size * sizeof ( struct map_tile ) ) ) ) <S2SV_EndBug> ",<S2SV_ModStart> size_t tilemap_size ; <S2SV_ModStart> tilemap_size = <S2SV_ModEnd> <S2SV_ModStart> ; if ( x_size == 0 || tilemap_size / x_size / sizeof ( struct map_tile ) != y_size || ! ( tilemap = malloc ( tilemap_size ,fatcerberus@minisphere/252c1ca184cb38e1acb917aa0e451c5f08519996,CVE-2018-1000524,https://github.com/fatcerberus/minisphere/commit/252c1ca184cb38e1acb917aa0e451c5f08519996,2018-06-26T16:29Z
996,CWE-125,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , length ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ipaddr_string ( ndo , & cp [ len ] ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> ( 0 ) <S2SV_ModStart> ) ; ND_TCHECK ( cp [ 2 ] <S2SV_ModStart> ND_TCHECK2 ( cp [ len ] , 4 ) ; <S2SV_ModStart> return ( 0 ) ; trunc : return ( - 1 ) ; ",the-tcpdump-group@tcpdump/eee0b04bcfdae319c242b0b8fc3d07029ee65b8c,CVE-2017-13022,https://github.com/the-tcpdump-group/tcpdump/commit/eee0b04bcfdae319c242b0b8fc3d07029ee65b8c,2017-09-14T06:29Z
997,CWE-119,<S2SV_StartBug> static char * print_string ( cJSON * item ) <S2SV_EndBug> <S2SV_StartBug> return print_string_ptr ( item -> valuestring ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , printbuffer * p <S2SV_ModStart> , p ",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
998,CWE-119,"<S2SV_StartBug> res = ctx -> iface -> enc . encode ( ctx -> priv -> alg_priv , img , pts , <S2SV_EndBug> <S2SV_StartBug> if ( ( res = ctx -> iface -> enc . encode ( ctx -> priv -> alg_priv , img , pts , <S2SV_EndBug> ",<S2SV_ModStart> get_alg_priv ( ctx ) <S2SV_ModEnd> <S2SV_ModStart> get_alg_priv ( ctx ) <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
999,CWE-119,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> ret = sscanf ( argv [ i ] + 1 , ""prestring=%s"" , buf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( len = strlen ( buf ) ) > L_BUF_SIZE - 3 ) { <S2SV_EndBug> <S2SV_StartBug> ret = sscanf ( argv [ i ] + 1 , ""protos=%s"" , buf ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""cpp<S2SV_blank>-ansi<S2SV_blank>-DNO_PROTOS<S2SV_blank>%s<S2SV_blank>%s"" , <S2SV_EndBug> ","<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> ""prestring=%490s"" <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> ""protos=%490s"" <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> ",DanBloomberg@leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a,CVE-2018-7186,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,2018-02-16T16:29Z
1000,CWE-20,<S2SV_StartBug> if ( chunk_num > chm -> num_chunks ) return NULL ; <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> ,kyz@libmspack/72e70a921f0f07fee748aec2274b30784e1d312a,CVE-2018-14680,https://github.com/kyz/libmspack/commit/72e70a921f0f07fee748aec2274b30784e1d312a,2018-07-28T23:29Z
1001,CWE-264,"<S2SV_StartBug> if ( ! validate_event ( & fake_pmu , leader ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! validate_event ( & fake_pmu , sibling ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! validate_event ( & fake_pmu , event ) ) <S2SV_EndBug> ","<S2SV_ModStart> event -> pmu , <S2SV_ModStart> event -> pmu , <S2SV_ModStart> event -> pmu , ",torvalds@linux/8fff105e13041e49b82f92eef034f363a6b1c071,CVE-2015-8955,https://github.com/torvalds/linux/commit/8fff105e13041e49b82f92eef034f363a6b1c071,2016-10-10T10:59Z
1002,CWE-000,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> win_maximise ( arg1 ? 2 : 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> usleep ( 1000 ) ; <S2SV_ModStart> ) ; usleep ( 1000 ,mintty@mintty/bd52109993440b6996760aaccb66e68e782762b9,CVE-2021-28848,https://github.com/mintty/mintty/commit/bd52109993440b6996760aaccb66e68e782762b9,2021-06-03T12:15Z
1003,CWE-617,<S2SV_StartBug> av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,FFmpeg@FFmpeg/bd27a9364ca274ca97f1df6d984e88a0700fb235,CVE-2018-13304,https://github.com/FFmpeg/FFmpeg/commit/bd27a9364ca274ca97f1df6d984e88a0700fb235,2018-07-05T17:29Z
1004,CWE-189,<S2SV_StartBug> if ( nsops < 1 ) <S2SV_EndBug> ,<S2SV_ModStart> || nsops > SEMOPM ,torvalds@linux/0f22072ab50cac7983f9660d33974b45184da4f9,CVE-2011-1759,https://github.com/torvalds/linux/commit/0f22072ab50cac7983f9660d33974b45184da4f9,2012-06-13T10:24Z
1005,CWE-119,<S2SV_StartBug> for ( i = cols ; i < cols + 17 ; i ++ ) <S2SV_EndBug> ,<S2SV_ModStart> 0 ; i < 17 ; i ++ ) s [ i + cols <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1006,CWE-787,<S2SV_StartBug> if ( fileblock < INDIRECT_BLOCKS ) <S2SV_EndBug> <S2SV_StartBug> else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } ,radare@radare2/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,CVE-2017-9949,https://github.com/radare/radare2/commit/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,2017-06-26T20:29Z
1007,CWE-119,"<S2SV_StartBug> WritePixel ( i , & context , casspecial ) ; npix -- ; <S2SV_EndBug> <S2SV_StartBug> WritePixels ( i , & context , stackp , stack_top - stackp ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( npix > 0 ) <S2SV_ModStart> if ( npix >= ( <S2SV_ModEnd> <S2SV_ModStart> ) { WritePixels ( i , & context , stackp , stack_top - stackp ) ; } else if ( npix > 0 ) { WritePixels ( i , & context , stackp , npix ) ; } <S2SV_ModEnd> ",miniupnp@ngiflib/cf429e0a2fe26b5f01ce0c8e9b79432e94509b6e,CVE-2018-10717,https://github.com/miniupnp/ngiflib/commit/cf429e0a2fe26b5f01ce0c8e9b79432e94509b6e,2018-05-03T17:29Z
1008,CWE-20,"<S2SV_StartBug> size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> tail = <S2SV_ModEnd> <S2SV_ModStart> ; if ( cdf_check_stream_offset ( sst , h , p , tail * sizeof ( uint32_t ) , __LINE__ ) == - 1 ) goto out ; size_t ofs = CDF_GETUINT32 ( p , tail ",file@file/93e063ee374b6a75729df9e7201fb511e47e259d,CVE-2014-3487,https://github.com/file/file/commit/93e063ee374b6a75729df9e7201fb511e47e259d,2014-07-09T11:07Z
1009,CWE-125,<S2SV_StartBug> next_input = input + i * input_incr ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> ip = next_opcode ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; next_input = input + i * input_incr <S2SV_ModStart> bytes_matched = yr_min ( bytes_matched , max_bytes_matched ) ; ",VirusTotal@yara/992480c30f75943e9cd6245bb2015c7737f9b661,CVE-2017-9465,https://github.com/VirusTotal/yara/commit/992480c30f75943e9cd6245bb2015c7737f9b661,2017-06-06T21:29Z
1010,CWE-787,"<S2SV_StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <S2SV_EndBug> <S2SV_StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED<S2SV_blank>STRING"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED<S2SV_blank>REGEX"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED<S2SV_blank>COMMENT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( len >= 10 ) ; <S2SV_EndBug> ",<S2SV_ModStart> assert ( len > 28 ) ; <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,espruino@Espruino/bed844f109b6c222816740555068de2e101e8018,CVE-2018-11593,https://github.com/espruino/Espruino/commit/bed844f109b6c222816740555068de2e101e8018,2018-05-31T16:29Z
1011,CWE-284,<S2SV_StartBug> unlock_mount_hash ( ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( unlikely ( ! list_empty ( & mnt -> mnt_mounts ) ) ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { umount_mnt ( p ) ; } } ",torvalds@linux/ce07d891a0891d3c0d0c2d73d577490486b809e1,CVE-2014-9717,https://github.com/torvalds/linux/commit/ce07d891a0891d3c0d0c2d73d577490486b809e1,2016-05-02T10:59Z
1012,CWE-119,"<S2SV_StartBug> static void encode_term_subexp ( vp9_writer * w , int word ) { <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , word , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , word - 16 , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , word - 32 , 5 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> vpx_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_write_literal <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1013,CWE-125,"
","
",mdadams@jasper/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d,CVE-2016-9583,https://github.com/mdadams/jasper/commit/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d,2018-08-01T17:29Z
1014,CWE-119,<S2SV_StartBug> if ( ! e || e == p ) <S2SV_EndBug> ,<S2SV_ModStart> ) goto not_found ; if ( e - p > HOST_NAME_MAX - 1 ,keszybz@systemd/cb31827d62066a04b02111df3052949fda4b6888,CVE-2015-7510,https://github.com/keszybz/systemd/commit/cb31827d62066a04b02111df3052949fda4b6888,2017-09-25T21:29Z
1015,CWE-119,<S2SV_StartBug> int err = - EIO ; <S2SV_EndBug> <S2SV_StartBug> uint32_t pos ; <S2SV_EndBug> <S2SV_StartBug> if ( ! bh ) <S2SV_EndBug> <S2SV_StartBug> out : <S2SV_EndBug> <S2SV_StartBug> kunmap ( page ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( inode -> i_size > inode -> i_sb -> s_blocksize ) { err = - ENAMETOOLONG ; goto out_unmap ; } <S2SV_ModStart> { err = - EIO ; goto out_unlock_inode ; } <S2SV_ModEnd> <S2SV_ModStart> out_unlock_inode <S2SV_ModEnd> <S2SV_ModStart> out_unmap : ,torvalds@linux/a1d47b262952a45aae62bd49cfaf33dd76c11a2c,CVE-2014-9728,https://github.com/torvalds/linux/commit/a1d47b262952a45aae62bd49cfaf33dd76c11a2c,2015-08-31T10:59Z
1016,CWE-264,<S2SV_StartBug> else if ( vcpu -> arch . apic_base & X2APIC_ENABLE ) { <S2SV_EndBug> ,<S2SV_ModStart> cpu_has_secondary_exec_ctrls ( ) && ( vmcs_read32 ( SECONDARY_VM_EXEC_CONTROL ) & SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE ) <S2SV_ModEnd> ,torvalds@linux/3ce424e45411cf5a13105e0386b6ecf6eeb4f66f,CVE-2016-4440,https://github.com/torvalds/linux/commit/3ce424e45411cf5a13105e0386b6ecf6eeb4f66f,2016-06-27T10:59Z
1017,CWE-000,<S2SV_StartBug> if ( ent != NULL ) { <S2SV_EndBug> <S2SV_StartBug> cleanup : <S2SV_EndBug> ,"<S2SV_ModStart> == NULL ) { st = KRB5_KDB_NOENTRY ; <S2SV_ModEnd> <S2SV_ModStart> st = populate_policy ( context , ld , ent , pol_name , * policy ) ; ",krb5@krb5/d1f707024f1d0af6e54a18885322d70fa15ec4d3,CVE-2014-5353,https://github.com/krb5/krb5/commit/d1f707024f1d0af6e54a18885322d70fa15ec4d3,2014-12-16T23:59Z
1018,CWE-119,"<S2SV_StartBug> UEV_PARSE ( ""num_tile_columns_minus1"" , value , ps_bitstrm ) ; <S2SV_EndBug> <S2SV_StartBug> ( ps_pps -> i1_num_tile_columns > ps_sps -> i2_pic_wd_in_ctb ) || <S2SV_EndBug> <S2SV_StartBug> ( ps_pps -> i1_num_tile_rows > ps_sps -> i2_pic_ht_in_ctb ) ) <S2SV_EndBug> ",<S2SV_ModStart> WORD32 wd = ALIGN64 ( ps_codec -> i4_wd ) ; WORD32 ht = ALIGN64 ( ps_codec -> i4_ht ) ; WORD32 max_tile_cols = ( wd + MIN_TILE_WD - 1 ) / MIN_TILE_WD ; WORD32 max_tile_rows = ( ht + MIN_TILE_HT - 1 ) / MIN_TILE_HT ; <S2SV_ModStart> max_tile_cols <S2SV_ModEnd> <S2SV_ModStart> max_tile_rows <S2SV_ModEnd> ,external@libhevc/ebaa71da6362c497310377df509651974401d258,CVE-2017-0637,https://android.googlesource.com/platform/external/libhevc/+/ebaa71da6362c497310377df509651974401d258,2017-06-14T13:29Z
1019,CWE-119,<S2SV_StartBug> struct buffer_head * dibh = mp -> mp_bh [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> const unsigned end_of_metadata = height - 1 ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> super_block * sb = sdp -> sd_vfs ; struct <S2SV_ModStart> ; int ret <S2SV_ModStart> if ( buffer_zeronew ( bh_map ) ) { ret = sb_issue_zeroout ( sb , dblock , dblks , GFP_NOFS ) ; if ( ret ) { fs_err ( sdp , ""Failed<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>data<S2SV_blank>buffers\\n"" ) ; clear_buffer_zeronew ( bh_map ) ; } } ",torvalds@linux/64dd153c83743af81f20924c6343652d731eeecb,CVE-2011-4098,https://github.com/torvalds/linux/commit/64dd153c83743af81f20924c6343652d731eeecb,2013-06-08T13:05Z
1020,CWE-119,"<S2SV_StartBug> { switch ( c ) <S2SV_EndBug> <S2SV_StartBug> float32_be_write ( floatdata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> <S2SV_StartBug> float32_le_write ( floatdata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> <S2SV_StartBug> double64_be_write ( doubledata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> <S2SV_StartBug> double64_le_write ( doubledata , psf -> header + psf -> headindex ) ; <S2SV_EndBug> <S2SV_StartBug> size += ( size & 1 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex - 1 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( psf -> rwf_endian == SF_ENDIAN_BIG ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> header_put_byte ( psf , size ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> <S2SV_StartBug> if ( psf -> headindex + size < sizeof ( psf -> header ) ) <S2SV_EndBug> <S2SV_StartBug> { memcpy ( & ( psf -> header [ psf -> headindex ] ) , bindata , size ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex ++ ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ( psf -> header [ psf -> headindex ] ) , bindata , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += 16 ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += size ; <S2SV_EndBug> <S2SV_StartBug> if ( size < sizeof ( psf -> header ) ) <S2SV_EndBug> ","<S2SV_ModStart> if ( psf -> header . indx + 16 >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count ; <S2SV_ModStart> . ptr + psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr + psf -> header . indx ) ; psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr + psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr + psf -> header . indx ) ; psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> ; if ( psf -> header . indx + ( sf_count_t ) size >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . indx += size ; psf -> header . ptr <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; if ( psf -> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . indx += size ; psf -> header . ptr <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> if ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; memcpy ( & ( psf -> header . ptr [ psf -> header . indx ] ) , bindata , size ) ; psf -> header . indx += size ; count += size ; break ; case 'z' : size = va_arg ( argptr , size_t ) ; if ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; count += size ; while ( size ) { psf -> header . ptr <S2SV_ModEnd> <S2SV_ModStart> header . indx ] <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> if ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; psf -> header . indx <S2SV_ModEnd> <S2SV_ModStart> ( sf_count_t ) size >= psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; psf -> header . indx = size <S2SV_ModEnd> ",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z
1021,CWE-125,<S2SV_StartBug> if ( debug ) { <S2SV_EndBug> <S2SV_StartBug> if ( d -> msg_len > ( CX24116_ARGLEN - CX24116_DISEQC_MSGOFS ) ) <S2SV_EndBug> ,<S2SV_ModStart> d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ; if ( <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/1fa2337a315a2448c5434f41e00d56b01a22283c,CVE-2015-9289,https://github.com/torvalds/linux/commit/1fa2337a315a2448c5434f41e00d56b01a22283c,2019-07-27T22:15Z
1022,CWE-200,<S2SV_StartBug> cinfo . hci_handle = sco_pi ( sk ) -> conn -> hcon -> handle ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & cinfo , 0 , sizeof ( cinfo ) ) ; ",torvalds@linux/c4c896e1471aec3b004a693c689f60be3b17ac86,CVE-2011-1078,https://github.com/torvalds/linux/commit/c4c896e1471aec3b004a693c689f60be3b17ac86,2012-06-21T23:55Z
1023,CWE-125,<S2SV_StartBug> if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && <S2SV_EndBug> <S2SV_StartBug> ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) <S2SV_EndBug> <S2SV_StartBug> length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( ( number_pixels * <S2SV_ModEnd> <S2SV_ModStart> ) > ( 8 * <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> bytes_per_line <S2SV_ModEnd> ,ImageMagick@ImageMagick/b8f17d08b7418204bf8a05a5c24e87b2fc395b75,CVE-2015-8958,https://github.com/ImageMagick/ImageMagick/commit/b8f17d08b7418204bf8a05a5c24e87b2fc395b75,2017-04-20T18:59Z
1024,CWE-269,"<S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rv ) <S2SV_EndBug> <S2SV_StartBug> fs_logger2 ( ""clone"" , dest ) ; <S2SV_EndBug> ",<S2SV_ModStart> copy_file_as_user <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,netblue30@firejail/b8a4ff9775318ca5e679183884a6a63f3da8f863,CVE-2017-5940,https://github.com/netblue30/firejail/commit/b8a4ff9775318ca5e679183884a6a63f3da8f863,2017-02-09T18:59Z
1025,CWE-20,"<S2SV_StartBug> guint pkt_len ; <S2SV_EndBug> <S2SV_StartBug> num_items_scanned = sscanf ( line + 64 , ""LEN=%9u"" , & pkt_len ) ; <S2SV_EndBug> <S2SV_StartBug> * err_info = g_strdup ( ""toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> int pkt_len , <S2SV_ModEnd> <S2SV_ModStart> ""LEN=%9d"" <S2SV_ModEnd> <S2SV_ModStart> ) ; return FALSE ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ",wireshark@wireshark/3270dfac43da861c714df76513456b46765ff47f,CVE-2016-5355,https://github.com/wireshark/wireshark/commit/3270dfac43da861c714df76513456b46765ff47f,2016-08-07T16:59Z
1026,CWE-200,<S2SV_StartBug> int err = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> = 0 ; msg -> msg_namelen ,torvalds@linux/a5598bd9c087dc0efc250a5221e5d0e6f584ee88,CVE-2013-3229,https://github.com/torvalds/linux/commit/a5598bd9c087dc0efc250a5221e5d0e6f584ee88,2013-04-22T11:41Z
1027,CWE-000,"<S2SV_StartBug> if ( zend_symtable_find ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P ( key ) + 1 , ( void * * ) & old_data ) == SUCCESS ) { <S2SV_EndBug> ",<S2SV_ModStart> zend_hash_find <S2SV_ModEnd> ,php@php-src/b585a3aed7880a5fa5c18e2b838fc96f40e075bd,CVE-2015-0231,https://github.com/php/php-src/commit/b585a3aed7880a5fa5c18e2b838fc96f40e075bd,2015-01-27T20:03Z
1028,CWE-200,"<S2SV_StartBug> strcpy ( link_info . str , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> nla_strlcpy <S2SV_ModEnd> <S2SV_ModStart> , TIPC_MAX_LINK_NAME ",torvalds@linux/5d2be1422e02ccd697ccfcd45c85b4a26e6178e2,CVE-2016-5243,https://github.com/torvalds/linux/commit/5d2be1422e02ccd697ccfcd45c85b4a26e6178e2,2016-06-27T10:59Z
1029,CWE-416,<S2SV_StartBug> io -> io_cleanup = mem_cleanup ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> io -> io_cleanup = mem_cleanup ; ,torvalds@linux/401e7e88d4ef80188ffa07095ac00456f901b8c4,CVE-2019-11811,https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4,2019-05-07T14:29Z
1030,CWE-416,"<S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> ,torvalds@linux/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,CVE-2019-11487,https://github.com/torvalds/linux/commit/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,2019-04-23T22:29Z
1031,CWE-119,<S2SV_StartBug> if ( p -> tokenpos == p -> tokenlen ) { <S2SV_EndBug> ,<S2SV_ModStart> >= ( <S2SV_ModEnd> <S2SV_ModStart> - 1 ) ,stedolan@jq/8eb1367ca44e772963e704a700ef72ae2e12babd,CVE-2015-8863,https://github.com/stedolan/jq/commit/8eb1367ca44e772963e704a700ef72ae2e12babd,2016-05-06T17:59Z
1032,CWE-119,<S2SV_StartBug> static vp9_variance_fn_t get_block_variance_fn ( BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> return vp9_mse8x8 ; <S2SV_EndBug> <S2SV_StartBug> return vp9_mse16x8 ; <S2SV_EndBug> <S2SV_StartBug> return vp9_mse8x16 ; <S2SV_EndBug> <S2SV_StartBug> return vp9_mse16x16 ; <S2SV_EndBug> ,<S2SV_ModStart> vpx_variance_fn_t <S2SV_ModEnd> <S2SV_ModStart> vpx_mse8x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_mse16x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_mse8x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_mse16x16 <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1033,CWE-000,<S2SV_StartBug> dev -> header_ops = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> ,torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z
1034,CWE-834,<S2SV_StartBug> for ( i = 0 ; i < frame_count ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> chunk_size [ i ] = avio_rl32 ( pb ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < frame_count ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> chunk_offset [ i ] = avio_rl32 ( pb ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < frame_count ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < frame_count ; i ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } <S2SV_ModStart> { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } <S2SV_ModStart> { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } ,FFmpeg@FFmpeg/96f24d1bee7fe7bac08e2b7c74db1a046c9dc0de,CVE-2017-14056,https://github.com/FFmpeg/FFmpeg/commit/96f24d1bee7fe7bac08e2b7c74db1a046c9dc0de,2017-08-31T15:29Z
1035,CWE-369,<S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ,<S2SV_ModStart> rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if ( ,uclouvain@openjpeg/d27ccf01c68a31ad62b33d2dc1ba2bb1eeaafe7b,CVE-2016-10506,https://github.com/uclouvain/openjpeg/commit/d27ccf01c68a31ad62b33d2dc1ba2bb1eeaafe7b,2017-08-30T09:29Z
1036,CWE-000,<S2SV_StartBug> if ( rep -> u . dh_Info . kdfID ) { <S2SV_EndBug> <S2SV_StartBug> secret . data = server_key ; <S2SV_EndBug> ,<S2SV_ModStart> != NULL && rep <S2SV_ModStart> ( char * ) ,krb5@krb5/db64ca25d661a47b996b4e2645998b5d7f0eb52c,CVE-2012-1016,https://github.com/krb5/krb5/commit/db64ca25d661a47b996b4e2645998b5d7f0eb52c,2013-03-05T04:54Z
1037,CWE-120,"<S2SV_StartBug> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <S2SV_EndBug> ",<S2SV_ModStart> HeapOverflowSanityCheck <S2SV_ModEnd> ,ImageMagick@ImageMagick/e45e48b881038487d0bc94d92a16c1537616cc0a,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/e45e48b881038487d0bc94d92a16c1537616cc0a,2017-03-03T17:59Z
1038,CWE-119,"<S2SV_StartBug> sprintf ( address , ""%s:%s"" , url , port ) ; <S2SV_EndBug> ","<S2SV_ModStart> snprintf ( address , 254 <S2SV_ModEnd> ",ckolivas@cgminer/e1c5050734123973b99d181c45e74b2cbb00272e,CVE-2014-4501,https://github.com/ckolivas/cgminer/commit/e1c5050734123973b99d181c45e74b2cbb00272e,2014-07-23T14:55Z
1039,CWE-22,"<S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> <S2SV_StartBug> file_write ( page , wikitext ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> if ( page && ( unlink ( page ) > 0 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> ",<S2SV_ModStart> page_name_is_good ( page ) && <S2SV_ModStart> if ( page_name_is_good ( page ) ) { <S2SV_ModStart> } <S2SV_ModStart> page_name_is_good ( page ) && <S2SV_ModStart> && page_name_is_good ( page ) ,yarolig@didiwiki/5e5c796617e1712905dc5462b94bd5e6c08d15ea,CVE-2013-7448,https://github.com/yarolig/didiwiki/commit/5e5c796617e1712905dc5462b94bd5e6c08d15ea,2016-02-23T19:59Z
1040,CWE-119,<S2SV_StartBug> int n_read = r -> end - r -> begin ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned int actual_size = f -> blocksize_1 / 2 ; unsigned int limit_r_begin = r -> begin < actual_size ? r -> begin : actual_size ; unsigned int limit_r_end = r -> end < actual_size ? r -> end : actual_size ; <S2SV_ModStart> limit_r_end - limit_r_begin <S2SV_ModEnd> ,nothings@stb/244d83bc3d859293f55812d48b3db168e581f6ab,CVE-2018-1000050,https://github.com/nothings/stb/commit/244d83bc3d859293f55812d48b3db168e581f6ab,2018-02-09T23:29Z
1041,CWE-119,<S2SV_StartBug> hdr = ( void * ) p - head -> iov_base ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( hdr > head -> iov_len ) return 0 ,torvalds@linux/13bf9fbff0e5e099e2b6f003a0ab8ae145436309,CVE-2017-7895,https://github.com/torvalds/linux/commit/13bf9fbff0e5e099e2b6f003a0ab8ae145436309,2017-04-28T10:59Z
1042,CWE-476,<S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> <S2SV_StartBug> write_lock ( & cluster -> cl_nodes_lock ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> o2nm_unlock_subsystem ( ) ; ,torvalds@linux/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,CVE-2017-18216,https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,2018-03-05T18:29Z
1043,CWE-476,<S2SV_StartBug> v4l2_buf = to_vb2_v4l2_buffer ( & vb -> vb . vb2_buf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vb ) { <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! vb ) { dev_dbg ( & dev -> pci -> dev , ""vb<S2SV_blank>is<S2SV_blank>empty,<S2SV_blank>dropping<S2SV_blank>frame\\n"" ) ; return ; } <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/2e7682ebfc750177a4944eeb56e97a3f05734528,CVE-2019-20806,https://github.com/torvalds/linux/commit/2e7682ebfc750177a4944eeb56e97a3f05734528,2020-05-27T12:15Z
1044,CWE-190,<S2SV_StartBug> void * zcalloc ( size_t size ) { <S2SV_EndBug> ,<S2SV_ModStart> ASSERT_NO_SIZE_OVERFLOW ( size ) ; ,redis@redis/c992857618db99776917f10bf4f2345a5fdc78b0,CVE-2021-21309,https://github.com/redis/redis/commit/c992857618db99776917f10bf4f2345a5fdc78b0,2021-02-26T22:15Z
1045,CWE-189,<S2SV_StartBug> ssize_t count ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( bytes == 0 || items == 0 ) return 0 ,erikd@libsndfile/725c7dbb95bfaf8b4bb7b04820e3a00cceea9ce6,CVE-2014-9756,https://github.com/erikd/libsndfile/commit/725c7dbb95bfaf8b4bb7b04820e3a00cceea9ce6,2015-11-19T20:59Z
1046,CWE-125,<S2SV_StartBug> rxent -> serviceId == EXTRACT_32BITS ( & rxh -> serviceId ) && <S2SV_EndBug> ,<S2SV_ModStart> EXTRACT_16BITS <S2SV_ModEnd> ,the-tcpdump-group@tcpdump/c24922e692a52121e853a84ead6b9337f4c08a94,CVE-2018-14466,https://github.com/the-tcpdump-group/tcpdump/commit/c24922e692a52121e853a84ead6b9337f4c08a94,2019-10-03T16:15Z
1047,CWE-476,"<S2SV_StartBug> ret = key_permission ( key_ref , KEY_NEED_READ ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { ret = - ENOKEY ; goto error2 ; } ",torvalds@linux/37863c43b2c6464f252862bf2e9768264e961678,CVE-2017-12192,https://github.com/torvalds/linux/commit/37863c43b2c6464f252862bf2e9768264e961678,2017-10-12T00:29Z
1048,CWE-120,"<S2SV_StartBug> memset ( adhoc_start -> ssid , 0 , IEEE80211_MAX_SSID_LEN ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( req_ssid -> ssid_len > IEEE80211_MAX_SSID_LEN ) req_ssid -> ssid_len = IEEE80211_MAX_SSID_LEN ,torvalds@linux/5c455c5ab332773464d02ba17015acdca198f03d,CVE-2020-36158,https://github.com/torvalds/linux/commit/5c455c5ab332773464d02ba17015acdca198f03d,2021-01-05T05:15Z
1049,CWE-400,<S2SV_StartBug> if ( error ) <S2SV_EndBug> <S2SV_StartBug> if ( context -> seen_enough ) <S2SV_EndBug> ,<S2SV_ModStart> { kmem_free ( sbuf ) ; <S2SV_ModStart> } ,torvalds@linux/2e83b79b2d6c78bf1b4aa227938a214dcbddc83f,CVE-2016-9685,https://github.com/torvalds/linux/commit/2e83b79b2d6c78bf1b4aa227938a214dcbddc83f,2016-12-28T07:59Z
1050,CWE-310,<S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ; ",openssl@openssl/684400ce192dac51df3d3e92b61830a6ef90be3e,CVE-2014-8275,https://github.com/openssl/openssl/commit/684400ce192dac51df3d3e92b61830a6ef90be3e,2015-01-09T02:59Z
1051,CWE-20,<S2SV_StartBug> hrtimer_cancel ( & stime -> hrt ) ; <S2SV_EndBug> ,<S2SV_ModStart> hrtimer_try_to_cancel <S2SV_ModEnd> ,torvalds@linux/2ba1fe7a06d3624f9a7586d672b55f08f7c670f3,CVE-2016-2549,https://github.com/torvalds/linux/commit/2ba1fe7a06d3624f9a7586d672b55f08f7c670f3,2016-04-27T17:59Z
1052,CWE-125,"<S2SV_StartBug> while ( p < q ) p += enclen ( reg -> enc , p ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( q >= end ) return 0 ; ,kkos@oniguruma/9690d3ab1f9bcd2db8cbe1fe3ee4a5da606b8814,CVE-2017-9227,https://github.com/kkos/oniguruma/commit/9690d3ab1f9bcd2db8cbe1fe3ee4a5da606b8814,2017-05-24T15:29Z
1053,CWE-787,<S2SV_StartBug> struct l2cap_conf_rfc rfc = { . mode = L2CAP_MODE_BASIC } ; <S2SV_EndBug> <S2SV_StartBug> switch ( pi -> mode ) { <S2SV_EndBug> <S2SV_StartBug> rfc . txwin_size = L2CAP_DEFAULT_RX_WINDOW ; <S2SV_EndBug> <S2SV_StartBug> rfc . retrans_timeout = cpu_to_le16 ( L2CAP_DEFAULT_RETRANS_TO ) ; <S2SV_EndBug> <S2SV_StartBug> rfc . monitor_timeout = cpu_to_le16 ( L2CAP_DEFAULT_MONITOR_TO ) ; <S2SV_EndBug> ,"<S2SV_ModStart> L2CAP_MODE_ERTM <S2SV_ModEnd> <S2SV_ModStart> if ( pi -> num_conf_req || pi -> num_conf_rsp ) goto done ; switch ( pi -> mode ) { case L2CAP_MODE_STREAMING : case L2CAP_MODE_ERTM : pi -> conf_state |= L2CAP_CONF_STATE2_DEVICE ; if ( ! l2cap_mode_supported ( pi -> mode , pi -> conn -> feat_mask ) ) { struct l2cap_disconn_req req ; req . dcid = cpu_to_le16 ( pi -> dcid ) ; req . scid = cpu_to_le16 ( pi -> scid ) ; l2cap_send_cmd ( pi -> conn , l2cap_get_ident ( pi -> conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & req ) ; } break ; default : pi -> mode = l2cap_select_mode ( rfc . mode , pi -> conn -> feat_mask ) ; break ; } done : <S2SV_ModStart> L2CAP_DEFAULT_TX_WINDOW <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> 0 ; rfc . max_pdu_size = cpu_to_le16 ( L2CAP_DEFAULT_MAX_RX_APDU ) ; l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; break ; case L2CAP_MODE_STREAMING : rfc . mode = L2CAP_MODE_STREAMING ; rfc . txwin_size = 0 ; rfc . max_transmit = 0 ; rfc . retrans_timeout = 0 ; rfc . monitor_timeout = 0 <S2SV_ModEnd> ",torvalds@linux/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,CVE-2017-1000251,https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,2017-09-12T17:29Z
1054,CWE-284,"<S2SV_StartBug> do ret = recv ( sock_fd , buf , r , MSG_WAITALL ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ,system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
1055,CWE-119,<S2SV_StartBug> s -> chunksize = - 1 ; <S2SV_EndBug> ,<S2SV_ModStart> UINT64_MAX <S2SV_ModEnd> ,FFmpeg@FFmpeg/2a05c8f813de6f2278827734bf8102291e7484aa,CVE-2016-10190,https://github.com/FFmpeg/FFmpeg/commit/2a05c8f813de6f2278827734bf8102291e7484aa,2017-02-09T15:59Z
1056,CWE-200,<S2SV_StartBug> if ( ( ps_dec -> u4_first_slice_in_pic != 0 ) && <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,external@libavc/0b23c81c3dd9ec38f7e6806a3955fed1925541a0,CVE-2017-0555,https://android.googlesource.com/platform/external/libavc/+/0b23c81c3dd9ec38f7e6806a3955fed1925541a0,2017-04-07T22:59Z
1057,CWE-000,<S2SV_StartBug> while ( pair != 0 ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z
1058,CWE-476,"<S2SV_StartBug> err = tfm -> seed ( tfm , seed , slen ) ; <S2SV_EndBug> ",<S2SV_ModStart> crypto_rng_alg ( tfm ) <S2SV_ModEnd> ,torvalds@linux/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,CVE-2017-15116,https://github.com/torvalds/linux/commit/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,2017-11-30T18:29Z
1059,CWE-416,"<S2SV_StartBug> atomic_set ( & new -> count , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! atomic_add_unless ( & ucounts -> count , 1 , INT_MAX ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> == INT_MAX ) ucounts = NULL ; else ucounts -> count += 1 <S2SV_ModEnd> ,torvalds@linux/040757f738e13caaa9c5078bca79aa97e11dde88,CVE-2017-6874,https://github.com/torvalds/linux/commit/040757f738e13caaa9c5078bca79aa97e11dde88,2017-03-14T09:59Z
1060,CWE-19,<S2SV_StartBug> out_put : <S2SV_EndBug> <S2SV_StartBug> return datagrams ; <S2SV_EndBug> <S2SV_StartBug> return datagrams ; <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( err == 0 ) goto out_put ; if ( datagrams <S2SV_ModEnd> <S2SV_ModStart> { datagrams = err ; goto out_put ; } <S2SV_ModEnd> <S2SV_ModStart> out_put : fput_light ( sock -> file , fput_needed ) ; <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/34b88a68f26a75e4fded796f1a49c40f82234b7d,CVE-2016-7117,https://github.com/torvalds/linux/commit/34b88a68f26a75e4fded796f1a49c40f82234b7d,2016-10-10T11:00Z
1061,CWE-125,<S2SV_StartBug> void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> ,<S2SV_ModStart> static ,FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,CVE-2018-8789,https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,2018-11-29T18:29Z
1062,CWE-310,"<S2SV_StartBug> static void prefetch_table ( const volatile byte * tab , size_t len ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < len ; i += 8 * 32 ) <S2SV_EndBug> <S2SV_StartBug> ( void ) tab [ len - 1 ] ; <S2SV_EndBug> ",<S2SV_ModStart> inline <S2SV_ModStart> len - i >= 8 * 32 <S2SV_ModEnd> <S2SV_ModStart> for ( ; i < len ; i += 32 ) { ( void ) tab [ i ] ; } ,gpg@libgcrypt/daedbbb5541cd8ecda1459d3b843ea4d92788762,CVE-2019-12904,https://github.com/gpg/libgcrypt/commit/daedbbb5541cd8ecda1459d3b843ea4d92788762,2019-06-20T00:15Z
1063,CWE-000,<S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_PRE_IO ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) <S2SV_ModEnd> <S2SV_ModStart> if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result ) ; ,torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z
1064,CWE-000,"<S2SV_StartBug> static int update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , nfs4_stateid * delegation , int open_flags ) <S2SV_EndBug> <S2SV_StartBug> open_flags &= ( FMODE_READ | FMODE_WRITE ) ; <S2SV_EndBug> <S2SV_StartBug> ( deleg_cur -> type & open_flags ) != open_flags ) <S2SV_EndBug> <S2SV_StartBug> __update_open_stateid ( state , open_stateid , & deleg_cur -> stateid , open_flags ) ; <S2SV_EndBug> <S2SV_StartBug> __update_open_stateid ( state , open_stateid , NULL , open_flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode ) != fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> ,torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z
1065,CWE-200,"<S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; ( void ) ResetMagickMemory ( global_colormap , 0 , 3 * MagickMax ( global_colors , 256 ) * sizeof ( * global_colormap ) ",ImageMagick@ImageMagick/9fd10cf630832b36a588c1545d8736539b2f1fb5,CVE-2017-15277,https://github.com/ImageMagick/ImageMagick/commit/9fd10cf630832b36a588c1545d8736539b2f1fb5,2017-10-12T08:29Z
1066,CWE-284,"<S2SV_StartBug> return send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ,system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
1067,CWE-287,<S2SV_StartBug> static void oidc_scrub_headers ( request_rec * r ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,pingidentity@mod_auth_openidc/21e3728a825c41ab41efa75e664108051bb9665e,CVE-2017-6413,https://github.com/pingidentity/mod_auth_openidc/commit/21e3728a825c41ab41efa75e664108051bb9665e,2017-03-02T06:59Z
1068,CWE-119,"<S2SV_StartBug> int * out_rate_sum , int64_t * out_dist_sum ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> ( void ) cpi -> fn_ptr [ bs ] . vf ( p -> src . buf , p -> src . stride , <S2SV_EndBug> <S2SV_StartBug> pd -> dst . buf , pd -> dst . stride , & sse ) ; <S2SV_EndBug> <S2SV_StartBug> if ( i == 0 ) <S2SV_EndBug> <S2SV_StartBug> x -> pred_sse [ ref ] = sse ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> speed > 4 ) { <S2SV_EndBug> <S2SV_StartBug> int64_t dist ; <S2SV_EndBug> <S2SV_StartBug> int64_t square_error = sse ; <S2SV_EndBug> <S2SV_StartBug> int quantizer = ( pd -> dequant [ 1 ] >> 3 ) ; <S2SV_EndBug> <S2SV_StartBug> int rate ; <S2SV_EndBug> <S2SV_StartBug> * out_rate_sum = ( int ) rate_sum ; <S2SV_EndBug> ","<S2SV_ModStart> , int * skip_txfm_sb , int64_t * skip_sse_sb <S2SV_ModStart> unsigned int var = 0 ; unsigned int sum_sse = 0 ; int64_t total_sse = 0 ; int skip_flag = 1 ; const int shift = 6 ; int rate ; int64_t dist ; const int dequant_shift = # if CONFIG_VP9_HIGHBITDEPTH ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) ? xd -> bd - 5 : # endif 3 ; x -> pred_sse [ ref ] = 0 ; <S2SV_ModStart> const TX_SIZE max_tx_size = max_txsize_lookup <S2SV_ModEnd> <S2SV_ModStart> ; const BLOCK_SIZE unit_size = txsize_to_bsize [ max_tx_size ] ; const int64_t dc_thr = p -> quant_thred [ 0 ] >> shift ; const int64_t ac_thr = p -> quant_thred [ 1 ] >> shift ; const int64_t low_dc_thr = MIN ( 50 , dc_thr >> 2 ) ; const int64_t low_ac_thr = MIN ( 80 , ac_thr >> 2 ) ; int bw = 1 << ( b_width_log2_lookup [ bs ] - b_width_log2_lookup [ unit_size ] ) ; int bh = 1 << ( b_height_log2_lookup [ bs ] - b_width_log2_lookup [ unit_size ] ) ; int idx , idy ; int lw = b_width_log2_lookup [ unit_size ] + 2 ; int lh = b_height_log2_lookup [ unit_size ] + 2 ; sum_sse = 0 ; for ( idy = 0 ; idy < bh ; ++ idy ) { for ( idx = 0 ; idx < bw ; ++ idx ) { uint8_t * src = <S2SV_ModEnd> <S2SV_ModStart> + ( idy * <S2SV_ModEnd> <S2SV_ModStart> << lh ) + ( idx << lw ) ; uint8_t * dst = <S2SV_ModEnd> <S2SV_ModStart> + ( idy * <S2SV_ModEnd> <S2SV_ModStart> << lh ) + ( idx << lh ) ; int block_idx = ( idy << 1 ) + idx ; int low_err_skip = 0 ; var = cpi -> fn_ptr [ unit_size ] . vf ( src , p -> src . stride , dst , pd -> dst . stride <S2SV_ModStart> x -> bsse [ ( i << 2 ) + block_idx ] = sse ; sum_sse += sse ; x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_NONE ; if ( ! x -> select_tx_size ) { if ( var < ac_thr || var <S2SV_ModEnd> <S2SV_ModStart> { x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_AC_ONLY ; if ( sse - var < dc_thr || sse == var ) { x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_AC_DC ; if ( ! sse || ( var < low_ac_thr && sse - var < low_dc_thr ) ) low_err_skip = 1 ; } } } if ( skip_flag && ! low_err_skip ) skip_flag = 0 ; if ( i == 0 ) x -> <S2SV_ModEnd> <S2SV_ModStart> += sse ; } } total_sse += sum_sse ; <S2SV_ModEnd> <S2SV_ModStart> sf . simple_model_rd_from_var <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModEnd> <S2SV_ModStart> sum_sse <S2SV_ModEnd> <S2SV_ModStart> dequant_shift <S2SV_ModEnd> <S2SV_ModStart> vp9_model_rd_from_var_lapndz ( sum_sse , num_pels_log2_lookup [ bs ] , pd -> dequant [ 1 ] >> dequant_shift , <S2SV_ModEnd> <S2SV_ModStart> skip_txfm_sb = skip_flag ; * skip_sse_sb = total_sse << 4 ; * ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1069,CWE-264,<S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> ,<S2SV_ModStart> pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ,torvalds@linux/4a1d704194a441bf83c636004a479e01360ec850,CVE-2012-1179,https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850,2012-05-17T11:00Z
1070,CWE-125,<S2SV_StartBug> ND_TCHECK ( * pptr ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ,"<S2SV_ModStart> tptr <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""[|esis]"" ) ) <S2SV_ModEnd> ",the-tcpdump-group@tcpdump/331530a4076c69bbd2e3214db6ccbe834fb75640,CVE-2017-13047,https://github.com/the-tcpdump-group/tcpdump/commit/331530a4076c69bbd2e3214db6ccbe834fb75640,2017-09-14T06:29Z
1071,CWE-120,"<S2SV_StartBug> if ( ( * ptr == '<S2SV_blank>' ) || ( * ptr == '\\t' ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( * ret_username = malloc ( index + 1 ) ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> ( void ) strcpy ( * ret_username , username ) ; <S2SV_EndBug> ",<S2SV_ModStart> || ( index >= PAM_MAX_RESP_SIZE ) ) { break ; } <S2SV_ModEnd> <S2SV_ModStart> index >= PAM_MAX_RESP_SIZE || <S2SV_ModStart> strdup ( username <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,illumos@illumos-gate/1d276e0b382cf066dae93640746d8b4c54d15452,CVE-2020-27678,https://github.com/illumos/illumos-gate/commit/1d276e0b382cf066dae93640746d8b4c54d15452,2020-10-26T12:17Z
1072,CWE-119,"<S2SV_StartBug> static int read_segment_id ( vp9_reader * r , const struct segmentation * seg ) { <S2SV_EndBug> <S2SV_StartBug> return vp9_read_tree ( r , vp9_segment_tree , seg -> tree_probs ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_read_tree <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1073,CWE-200,<S2SV_StartBug> uint32_t backup_handle ; <S2SV_EndBug> <S2SV_StartBug> if ( ret == 0 && res -> backup -> base . num_pages * PAGE_SIZE < <S2SV_EndBug> <S2SV_StartBug> goto out_unlock ; <S2SV_EndBug> ,<S2SV_ModStart> = 0 <S2SV_ModStart> ) { if ( <S2SV_ModEnd> <S2SV_ModStart> } else { backup_handle = req -> buffer_handle ; } ,torvalds@linux/07678eca2cf9c9a18584e546c2b2a0d0c9a3150c,CVE-2017-9605,https://github.com/torvalds/linux/commit/07678eca2cf9c9a18584e546c2b2a0d0c9a3150c,2017-06-13T19:29Z
1074,CWE-362,<S2SV_StartBug> static struct desc_struct * get_desc ( unsigned short sel ) <S2SV_EndBug> <S2SV_StartBug> struct desc_struct * desc = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ldt && sel < ldt -> nr_entries ) <S2SV_EndBug> <S2SV_StartBug> desc = & ldt -> entries [ sel ] ; <S2SV_EndBug> <S2SV_StartBug> return desc ; <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> bool get_desc ( <S2SV_ModStart> out , <S2SV_ModEnd> <S2SV_ModStart> bool success = false <S2SV_ModEnd> <S2SV_ModStart> { * out = <S2SV_ModEnd> <S2SV_ModStart> success = true ; } <S2SV_ModStart> success <S2SV_ModEnd> <S2SV_ModStart> false ; * out = * <S2SV_ModEnd> <S2SV_ModStart> return true ; ",torvalds@linux/de9f869616dd95e95c00bdd6b0fcd3421e8a4323,CVE-2019-13233,https://github.com/torvalds/linux/commit/de9f869616dd95e95c00bdd6b0fcd3421e8a4323,2019-07-04T13:15Z
1075,CWE-119,"<S2SV_StartBug> vpx_memset ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst_ptr1 , src_ptr1 , linesize ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst_ptr2 , src_ptr2 , linesize ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1076,CWE-310,"<S2SV_StartBug> struct sctp_sockaddr_entry * laddr ; <S2SV_EndBug> <S2SV_StartBug> __u8 matchlen = 0 ; <S2SV_EndBug> <S2SV_StartBug> dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ; <S2SV_EndBug> <S2SV_StartBug> dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ; <S2SV_EndBug> ","<S2SV_ModStart> ipv6_pinfo * np = inet6_sk ( sk ) ; struct <S2SV_ModStart> struct in6_addr * final_p , final ; <S2SV_ModStart> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_ModStart> final_p <S2SV_ModEnd> <S2SV_ModStart> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_ModStart> final_p <S2SV_ModEnd> ",torvalds@linux/95ee62083cb6453e056562d91f597552021e6ae7,CVE-2013-4350,https://github.com/torvalds/linux/commit/95ee62083cb6453e056562d91f597552021e6ae7,2013-09-25T10:31Z
1077,CWE-400,"<S2SV_StartBug> static void kgdb_hw_overflow_handler ( struct perf_event * event , int nmi , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
1078,CWE-674,"<S2SV_StartBug> buf2 = smb_fdata ( ndo , buf , fmt , maxbuf , unicodestr ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( depth == 10 ) ND_PRINT ( ( ndo , ""(too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>levels,<S2SV_blank>not<S2SV_blank>recursing)"" ) ) ; else ",the-tcpdump-group@tcpdump/24182d959f661327525a20d9a94c98a8ec016778,CVE-2018-16452,https://github.com/the-tcpdump-group/tcpdump/commit/24182d959f661327525a20d9a94c98a8ec016778,2019-10-03T16:15Z
1079,CWE-835,<S2SV_StartBug> if ( client -> priv -> protocol_timeout ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,GNOME@gnome-session/b0dc999e0b45355314616321dbb6cb71e729fc9d,CVE-2017-11171,https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d,2017-07-11T20:29Z
1080,CWE-20,<S2SV_StartBug> while ( -- n >= 0 && ! ND_TTEST ( * ps ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( ie = io + ps -> nid ; io < ie && ! ND_TTEST ( * io ) ; ++ io ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,the-tcpdump-group@tcpdump/3ed82f4ed0095768529afc22b923c8f7171fff70,CVE-2015-3138,https://github.com/the-tcpdump-group/tcpdump/commit/3ed82f4ed0095768529afc22b923c8f7171fff70,2017-09-28T01:29Z
1081,CWE-20,"<S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ; <S2SV_EndBug> <S2SV_StartBug> header . controlWord = htole16 ( TX_CTRL_TXIC | ( context -> frameId ++ & TX_CTRL_TXFID ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851ClearBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_TXQCR , TXQCR_METFE ) ; <S2SV_EndBug> <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ; <S2SV_EndBug> ","<S2SV_ModStart> KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_TX_CTRL_TXIC <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_TX_CTRL_TXFID <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_TXQCR , KSZ8851_TXQCR_METFE <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> ",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
1082,CWE-310,<S2SV_StartBug> return key ; <S2SV_EndBug> ,"<S2SV_ModStart> rb_ivar_set ( self , id_key_set , Qtrue ) ; ",ruby@openssl/8108e0a6db133f3375608303fdd2083eb5115062,CVE-2016-7798,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,2017-01-30T22:59Z
1083,CWE-476,<S2SV_StartBug> goto present_leaves_cluster_but_not_new_leaf ; <S2SV_EndBug> <S2SV_StartBug> present_leaves_cluster_but_not_new_leaf : <S2SV_EndBug> ,"<S2SV_ModStart> pr_devel ( ""present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n"" ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/ea6789980fdaa610d7eb63602c746bf6ec70cd2b,CVE-2017-12193,https://github.com/torvalds/linux/commit/ea6789980fdaa610d7eb63602c746bf6ec70cd2b,2017-11-22T18:29Z
1084,CWE-20,<S2SV_StartBug> settings . udpport = 11211 ; <S2SV_EndBug> ,<S2SV_ModStart> 0 <S2SV_ModEnd> ,memcached@memcached/dbb7a8af90054bf4ef51f5814ef7ceb17d83d974,CVE-2018-1000115,https://github.com/memcached/memcached/commit/dbb7a8af90054bf4ef51f5814ef7ceb17d83d974,2018-03-05T14:29Z
1085,CWE-399,<S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart> reference_queue_proccess_all ( ) ; ,mono@mono/8eb1189099e02372fd45ca1c67230eccf1edddc0,CVE-2011-0991,https://github.com/mono/mono/commit/8eb1189099e02372fd45ca1c67230eccf1edddc0,2011-04-13T21:55Z
1086,CWE-787,"<S2SV_StartBug> WORD32 x_8 , x_9 , x_a , x_b , x_c , x_d , x_e , x_f ; <S2SV_EndBug> <S2SV_StartBug> n00 = x_0 + x_2 ; <S2SV_EndBug> <S2SV_StartBug> y1 [ h2 ] = n10 ; <S2SV_EndBug> <S2SV_StartBug> y1 [ h2 + 1 ] = n11 ; <S2SV_EndBug> <S2SV_StartBug> y3 [ h2 ] = n30 ; <S2SV_EndBug> <S2SV_StartBug> y3 [ h2 + 1 ] = n31 ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> y0 [ h2 ] = ixheaacd_add32_sat ( x_0 , x_2 ) ; y0 [ h2 + 1 ] = ixheaacd_add32_sat ( x_1 , x_3 ) ; y1 [ h2 ] = ixheaacd_add32_sat ( x_4 , x_6 ) ; y1 [ h2 + 1 ] = ixheaacd_add32_sat ( x_5 , x_7 ) ; y2 [ h2 ] = ixheaacd_sub32_sat ( x_0 , x_2 ) ; y2 [ h2 + 1 ] = ixheaacd_sub32_sat ( x_1 , x_3 ) ; y3 [ h2 ] = ixheaacd_sub32_sat ( x_4 , x_6 ) ; y3 [ h2 + 1 ] = ixheaacd_sub32_sat ( x_5 , x_7 ) ; x_8 = * x2 ++ ; x_9 = * x2 ++ ; x_a = * x2 ++ ; x_b = * x2 ++ ; x_c = * x2 ++ ; x_d = * x2 ++ ; x_e = * x2 ++ ; x_f = * x2 ++ ; y0 [ h2 + 2 ] = ixheaacd_add32_sat ( x_8 , x_a ) ; y0 [ h2 + 3 ] = ixheaacd_add32_sat ( x_9 , x_b ) <S2SV_ModEnd> <S2SV_ModStart> + 2 ] = ixheaacd_add32_sat ( x_c , x_e ) <S2SV_ModEnd> <S2SV_ModStart> 3 ] = ixheaacd_add32_sat ( x_d , x_f ) ; y2 [ h2 + 2 ] = ixheaacd_sub32_sat ( x_8 , x_a ) ; y2 [ h2 + 3 ] = ixheaacd_sub32_sat ( x_9 , x_b ) <S2SV_ModEnd> <S2SV_ModStart> + 2 ] = ixheaacd_sub32_sat ( x_c , x_e ) <S2SV_ModEnd> <S2SV_ModStart> 3 ] = ixheaacd_sub32_sat ( x_d , x_f ) <S2SV_ModEnd> ",external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z
1087,CWE-189,"<S2SV_StartBug> clips = kzalloc ( num_clips * sizeof ( * clips ) , GFP_KERNEL ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS ) { ret = - EINVAL ; goto out_err1 ; } ,torvalds@linux/a5cd335165e31db9dbab636fd29895d41da55dd2,CVE-2012-0044,https://github.com/torvalds/linux/commit/a5cd335165e31db9dbab636fd29895d41da55dd2,2012-05-17T11:00Z
1088,CWE-264,<S2SV_StartBug> if ( unlikely ( pmd_trans_huge ( * pmd ) ) ) <S2SV_EndBug> ,<S2SV_ModStart> pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ,torvalds@linux/4a1d704194a441bf83c636004a479e01360ec850,CVE-2012-1179,https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850,2012-05-17T11:00Z
1089,CWE-399,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
1090,CWE-125,"<S2SV_StartBug> for ( j = 0 ; j < size ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> r_cons_printf ( ""%02x"" , buf [ j + idx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( op . val != UT64_MAX ) <S2SV_EndBug> <S2SV_StartBug> if ( op . ptr != UT64_MAX ) <S2SV_EndBug> <S2SV_StartBug> printline ( ""ptr"" , ""0x%08"" PFMT64x ""\\n"" , op . ptr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( op . refptr != - 1 ) <S2SV_EndBug> <S2SV_StartBug> printline ( ""refptr"" , ""%d\\n"" , op . refptr ) ; <S2SV_EndBug> ","<S2SV_ModStart> int minsz = R_MIN ( len , size ) ; minsz = R_MAX ( minsz , 0 ) ; <S2SV_ModStart> minsz <S2SV_ModEnd> <S2SV_ModStart> ut8 ch = ( ( j + idx - 1 ) > minsz ) ? 0xff : <S2SV_ModEnd> <S2SV_ModStart> ; r_cons_printf ( ""%02x"" , ch <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } ",radare@radare2/a1bc65c3db593530775823d6d7506a457ed95267,CVE-2018-20461,https://github.com/radare/radare2/commit/a1bc65c3db593530775823d6d7506a457ed95267,2018-12-25T19:29Z
1091,CWE-119,"<S2SV_StartBug> int width , height , target_width , target_height ; <S2SV_EndBug> <S2SV_StartBug> usage ( argv [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> usage ( argv [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> usage ( argv [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> usage ( argv [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> usage ( argv [ 0 ] ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; exec_name = argv [ 0 ] <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1092,CWE-125,<S2SV_StartBug> while ( readw ( chip -> DSPQ + JQS_wTail ) != readw ( chip -> DSPQ + JQS_wHead ) ) { <S2SV_EndBug> <S2SV_StartBug> wTmp = readw ( chip -> DSPQ + JQS_wHead ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( wTmp > readw ( chip -> DSPQ + JQS_wSize ) ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> u16 head , tail , size ; head <S2SV_ModEnd> <S2SV_ModStart> ; tail = readw ( chip -> DSPQ + JQS_wTail ) ; size = <S2SV_ModEnd> <S2SV_ModStart> ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * head ) ) ; if ( ++ head > size ) head = 0 ; writew ( head <S2SV_ModEnd> <S2SV_ModStart> out : ",torvalds@linux/20e2b791796bd68816fa115f12be5320de2b8021,CVE-2017-9985,https://github.com/torvalds/linux/commit/20e2b791796bd68816fa115f12be5320de2b8021,2017-06-28T06:29Z
1093,CWE-125,<S2SV_StartBug> OPCODE_DESC * opcode_desc ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 2 ) { return NULL ; } ,radare@radare2/b35530fa0681b27eba084de5527037ebfb397422,CVE-2018-11377,https://github.com/radare/radare2/commit/b35530fa0681b27eba084de5527037ebfb397422,2018-05-22T19:29Z
1094,CWE-755,<S2SV_StartBug> ACPI_FUNCTION_TRACE ( ns_terminate ) ; <S2SV_EndBug> <S2SV_StartBug> union acpi_operand_object * next ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; ACPI_FUNCTION_TRACE ( ns_terminate ) <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/3b2d69114fefa474fca542e51119036dceb4aa6f,CVE-2017-11472,https://github.com/torvalds/linux/commit/3b2d69114fefa474fca542e51119036dceb4aa6f,2017-07-20T04:29Z
1095,CWE-119,<S2SV_StartBug> data -> l_head = NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> ",miniupnp@miniupnp/7aeb624b44f86d335841242ff427433190e7168a,CVE-2017-1000494,https://github.com/miniupnp/miniupnp/commit/7aeb624b44f86d335841242ff427433190e7168a,2018-01-03T14:29Z
1096,CWE-119,"<S2SV_StartBug> strcpy ( the_url , url_arg ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! e ) strcpy ( the_url , gf_dm_sess_get_cache_name ( sess ) ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( the_url , ""MP4Client<S2SV_blank>"" GPAC_FULL_VERSION ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { fprintf ( stderr , ""Input<S2SV_blank>url<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>truncating<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>chars.\\n"" , url_arg , ( int ) ( sizeof ( the_url ) - 1 ) ) ; strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; } else { <S2SV_ModStart> } <S2SV_ModStart> { strncpy <S2SV_ModEnd> <S2SV_ModStart> , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; } <S2SV_ModEnd> <S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <S2SV_ModEnd> ",gpac@gpac/35ab4475a7df9b2a4bcab235e379c0c3ec543658,CVE-2018-20762,https://github.com/gpac/gpac/commit/35ab4475a7df9b2a4bcab235e379c0c3ec543658,2019-02-06T23:29Z
1097,CWE-125,"<S2SV_StartBug> int i , result ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
1098,CWE-476,"<S2SV_StartBug> . match_data . cmp = type -> match , <S2SV_EndBug> ",<S2SV_ModStart> key_default_cmp <S2SV_ModEnd> ,torvalds@linux/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,CVE-2017-2647,https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81,2017-03-31T04:59Z
1099,CWE-119,"<S2SV_StartBug> struct vpx_codec_alg_priv * priv ; <S2SV_EndBug> <S2SV_StartBug> priv = calloc ( 1 , sizeof ( struct vpx_codec_alg_priv ) ) ; <S2SV_EndBug> <S2SV_StartBug> ctx -> priv = & priv -> base ; <S2SV_EndBug> <S2SV_StartBug> ctx -> priv -> alg_priv -> cfg = * ctx -> config . enc ; <S2SV_EndBug> <S2SV_StartBug> ctx -> config . enc = & ctx -> priv -> alg_priv -> cfg ; <S2SV_EndBug> <S2SV_StartBug> priv -> vp8_cfg = extracfg_map [ i ] . cfg ; <S2SV_EndBug> <S2SV_StartBug> set_vp8e_config ( & ctx -> priv -> alg_priv -> oxcf , <S2SV_EndBug> <S2SV_StartBug> ctx -> priv -> alg_priv -> cfg , <S2SV_EndBug> <S2SV_StartBug> optr = vp8_create_compressor ( & ctx -> priv -> alg_priv -> oxcf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! optr ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> ","<S2SV_ModStart> vp8_rtcd ( ) ; vpx_dsp_rtcd ( ) ; vpx_scale_rtcd ( ) ; if ( ! ctx -> priv ) { <S2SV_ModStart> = <S2SV_ModEnd> <S2SV_ModStart> * ) vpx_calloc ( 1 , sizeof ( * priv <S2SV_ModStart> ( vpx_codec_priv_t * ) <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart> priv -> cfg ; } <S2SV_ModEnd> <S2SV_ModStart> default_extracfg <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart> priv -> cfg , priv <S2SV_ModEnd> <S2SV_ModStart> priv -> cpi <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart> priv -> cpi <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1100,CWE-476,"<S2SV_StartBug> error = xfs_da_shrink_inode ( args , 0 , bp ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( bp && ( <S2SV_ModEnd> <S2SV_ModStart> != 0 ) <S2SV_ModEnd> ,torvalds@linux/bb3d48dcf86a97dc25fe9fc2c11938e19cb4399a,CVE-2018-13094,https://github.com/torvalds/linux/commit/bb3d48dcf86a97dc25fe9fc2c11938e19cb4399a,2018-07-03T10:29Z
1101,CWE-119,"<S2SV_StartBug> if ( ( ret = s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ) < 0 ) <S2SV_EndBug> ",<S2SV_ModStart> x >= 16 || c >= 256 ) { return AVERROR_INVALIDDATA ; } if ( ,FFmpeg@FFmpeg/2171dfae8c065878a2e130390eb78cf2947a5b69,CVE-2017-9995,https://github.com/FFmpeg/FFmpeg/commit/2171dfae8c065878a2e130390eb78cf2947a5b69,2017-06-28T06:29Z
1102,CWE-20,"<S2SV_StartBug> list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , <S2SV_EndBug> <S2SV_StartBug> spin_lock_irq ( & slave_active_lock ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irq ( & slave_active_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> spin_lock_irq ( & slave_active_lock ) ; spin_lock ( & timer -> lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> list_del_init ( & slave -> ack_list ) ; list_del_init ( & slave -> active_list ) ; } spin_unlock ( & timer -> lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/b5a663aa426f4884c71cd8580adae73f33570f0d,CVE-2016-2548,https://github.com/torvalds/linux/commit/b5a663aa426f4884c71cd8580adae73f33570f0d,2016-04-27T17:59Z
1103,CWE-000,"<S2SV_StartBug> err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX , <S2SV_EndBug> <S2SV_StartBug> attrs [ TIPC_NLA_SOCK ] , <S2SV_EndBug> <S2SV_StartBug> tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ; <S2SV_EndBug> <S2SV_StartBug> lock_sock ( & tsk -> sk ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX , attrs [ TIPC_NLA_SOCK ] , tipc_nl_sock_policy ) ; if ( err ) return err ; if ( ! sock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ; } if ( done ) return 0 ; tsk = tipc_sk_lookup ( net , tsk_portid ) ; if ( ! tsk ) return - EINVAL ; ",torvalds@linux/45e093ae2830cd1264677d47ff9a95a71f5d9f9c,CVE-2016-4951,https://github.com/torvalds/linux/commit/45e093ae2830cd1264677d47ff9a95a71f5d9f9c,2016-05-23T10:59Z
1104,CWE-119,"<S2SV_StartBug> vpx_memset ( ( void * ) ctx -> fragments . ptrs , 0 , sizeof ( ctx -> fragments . ptrs ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ctx -> fragments . sizes , 0 , sizeof ( ctx -> fragments . sizes ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ctx -> fragments . enabled ) <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> && ( data == NULL && data_sz == 0 ) ) { return 0 ; } if ( ! ctx -> fragments . enabled ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1105,CWE-476,"<S2SV_StartBug> vma_stop ( priv , vma ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! IS_ERR ( vma ) ) ,torvalds@linux/76597cd31470fa130784c78fadb4dab2e624a723,CVE-2011-3637,https://github.com/torvalds/linux/commit/76597cd31470fa130784c78fadb4dab2e624a723,2012-05-17T11:00Z
1106,CWE-125,<S2SV_StartBug> length = cap -> bLength ; <S2SV_EndBug> ,<S2SV_ModStart> if ( total_len < sizeof ( * cap ) || total_len < <S2SV_ModEnd> <S2SV_ModStart> ) { dev -> bos -> desc -> bNumDeviceCaps = i ; break ; } length = cap -> bLength <S2SV_ModEnd> ,torvalds@linux/1c0edc3633b56000e18d82fc241e3995ca18a69e,CVE-2017-16535,https://github.com/torvalds/linux/commit/1c0edc3633b56000e18d82fc241e3995ca18a69e,2017-11-04T01:29Z
1107,CWE-17,<S2SV_StartBug> struct task_struct * task = current ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/eee5cc2702929fd41cce28058dc6d6717f723f87,CVE-2014-8172,https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87,2015-03-16T10:59Z
1108,CWE-119,<S2SV_StartBug> switch ( fe -> icbTag . fileType ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ; if ( inode -> i_size > inode -> i_sb -> s_blocksize - udf_file_entry_alloc_offset ( inode ) ) goto out ; } ,torvalds@linux/e159332b9af4b04d882dbcfe1bb0117f0a6d4b58,CVE-2014-9728,https://github.com/torvalds/linux/commit/e159332b9af4b04d882dbcfe1bb0117f0a6d4b58,2015-08-31T10:59Z
1109,CWE-20,"<S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIREGADR , address & REG_ADDR_MASK ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIWRL , LSB ( data ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIWRH , MSB ( data ) ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc28j60ReadReg ( interface , ENC28J60_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) <S2SV_EndBug> ",<S2SV_ModStart> ENC28J60_MIREGADR <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MIWRL <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MIWRH <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MISTAT ) & ENC28J60_MISTAT_BUSY <S2SV_ModEnd> ,Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
1110,CWE-134,<S2SV_StartBug> static int bad_format_imginfo ( <S2SV_EndBug> <S2SV_StartBug> char * ptr ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return bad_format_check ( ""^"" SAFE_STRING ""%s"" SAFE_STRING ""%lu"" SAFE_STRING ""%lu"" SAFE_STRING ""$"" , fmt <S2SV_ModEnd> ",oetiker@rrdtool-1.x/85261a013112e278c90224033f5b0592ee387786,CVE-2014-6262,https://github.com/oetiker/rrdtool-1.x/commit/85261a013112e278c90224033f5b0592ee387786,2020-02-12T02:15Z
1111,CWE-362,<S2SV_StartBug> kfree ( inet -> opt ) ; <S2SV_EndBug> ,"<S2SV_ModStart> rcu_dereference_protected ( inet -> inet_opt , 1 ) <S2SV_ModEnd> ",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z
1112,CWE-20,<S2SV_StartBug> if ( likely ( walk . nbytes == nbytes ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/ecaaab5649781c5a0effdaf298a925063020500e,CVE-2017-17805,https://github.com/torvalds/linux/commit/ecaaab5649781c5a0effdaf298a925063020500e,2017-12-20T23:29Z
1113,CWE-835,<S2SV_StartBug> if ( ! saw_digit ) <S2SV_EndBug> <S2SV_StartBug> goto invalid ; <S2SV_EndBug> <S2SV_StartBug> if ( * bp != '\\r' ) <S2SV_EndBug> <S2SV_StartBug> goto invalid ; <S2SV_EndBug> <S2SV_StartBug> if ( * bp != '\\n' ) <S2SV_EndBug> <S2SV_StartBug> goto invalid ; <S2SV_EndBug> <S2SV_StartBug> return ( - 2 ) ; <S2SV_EndBug> <S2SV_StartBug> return ( - 5 ) ; <S2SV_EndBug> ,<S2SV_ModStart> { bp ++ ; <S2SV_ModStart> } <S2SV_ModStart> { bp ++ ; <S2SV_ModStart> } <S2SV_ModStart> { bp ++ ; <S2SV_ModStart> } <S2SV_ModStart> * endp = bp ; <S2SV_ModStart> * endp = bp ; ,the-tcpdump-group@tcpdump/db24063b01cba8e9d4d88b7d8ac70c9000c104e4,CVE-2017-12989,https://github.com/the-tcpdump-group/tcpdump/commit/db24063b01cba8e9d4d88b7d8ac70c9000c104e4,2017-09-14T06:29Z
1114,CWE-19,<S2SV_StartBug> args -> valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; <S2SV_EndBug> <S2SV_StartBug> args -> valuelen ) ; <S2SV_EndBug> ,<S2SV_ModStart> rmtvaluelen = be32_to_cpu ( name_rmt -> valuelen ) ; args -> rmtblkno <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rmtvaluelen <S2SV_ModEnd> ,torvalds@linux/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,CVE-2015-0274,https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,2015-03-16T10:59Z
1115,CWE-358,<S2SV_StartBug> # endif <S2SV_EndBug> ,"<S2SV_ModStart> UtRegisterTest ( ""DefragTestBadProto"" , DefragTestBadProto ) ; ",inliniac@suricata/4a04f814b15762eb446a5ead4d69d021512df6f8,CVE-2017-7177,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,2017-03-18T20:59Z
1116,CWE-415,<S2SV_StartBug> if ( object_data ) { <S2SV_EndBug> ,"<S2SV_ModStart> coolkey_find_object_by_id ( & priv -> objects_list , object_id ) != NULL ) { return SC_ERROR_INTERNAL ; } if ( ",OpenSC@OpenSC/c246f6f69a749d4f68626b40795a4f69168008f4,CVE-2019-20792,https://github.com/OpenSC/OpenSC/commit/c246f6f69a749d4f68626b40795a4f69168008f4,2020-04-29T04:15Z
1117,CWE-476,<S2SV_StartBug> char key [ 32 ] = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> if ( vdaux < 1 || vstart + vdaux < vstart ) { <S2SV_EndBug> <S2SV_StartBug> vstart += vdaux ; <S2SV_EndBug> <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> ,<S2SV_ModStart> size_t vstart_off = i ; <S2SV_ModStart> shdr -> sh_size - vstart_off < vdaux <S2SV_ModEnd> <S2SV_ModStart> += vdaux ; vstart_off <S2SV_ModStart> vstart_off += aux . vda_next ; ,radare@radare2/fbaf24bce7ea4211e4608b3ab6c1b45702cb243d,CVE-2017-16359,https://github.com/radare/radare2/commit/fbaf24bce7ea4211e4608b3ab6c1b45702cb243d,2017-11-01T17:29Z
1118,CWE-20,"<S2SV_StartBug> separator = strchr ( token , '=' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> ,Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
1119,CWE-125,"<S2SV_StartBug> if ( j >= length ) return - 1 ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( cp , packet + j , label_len ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( j + label_len > length ) return - 1 ; ,libevent@libevent/96f64a022014a208105ead6c8a7066018449d86d,CVE-2016-10195,https://github.com/libevent/libevent/commit/96f64a022014a208105ead6c8a7066018449d86d,2017-03-15T15:59Z
1120,CWE-119,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % ( bps * stride ) ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""fpAcc"" , ""%s"" , ""cc%(bps*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModStart> return 1 ; ",vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1,CVE-2016-9535,https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1,2016-11-22T19:59Z
1121,CWE-20,"<S2SV_StartBug> if ( vma -> vm_ops ) { <S2SV_EndBug> <S2SV_StartBug> pmd , flags , entry ) ; <S2SV_EndBug> <S2SV_StartBug> pte , pmd , flags ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pmd , flags , entry ) ; <S2SV_ModEnd> <S2SV_ModStart> pte , pmd , <S2SV_ModEnd> ",torvalds@linux/6b7339f4c31ad69c8e9c0b2859276e22cf72176d,CVE-2015-3288,https://github.com/torvalds/linux/commit/6b7339f4c31ad69c8e9c0b2859276e22cf72176d,2016-10-16T21:59Z
1122,CWE-119,"<S2SV_StartBug> char * r = pool_alloc ( strlen ( s ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( r , s ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t len = strlen ( s ) + 1 ; <S2SV_ModStart> len ) ; memcpy <S2SV_ModEnd> <S2SV_ModStart> , len ",git@git/34fa79a6cde56d6d428ab0d3160cb094ebad3305,CVE-2016-2315,https://github.com/git/git/commit/34fa79a6cde56d6d428ab0d3160cb094ebad3305,2016-04-08T14:59Z
1123,CWE-20,<S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> ,<S2SV_ModStart> key_is_positive <S2SV_ModEnd> ,torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z
1124,CWE-264,"<S2SV_StartBug> if ( ! new_idmap_permitted ( ns , cap_setid , & new_map ) ) <S2SV_EndBug> ","<S2SV_ModStart> file , ",torvalds@linux/6708075f104c3c9b04b23336bb0366ca30c3931b,CVE-2013-1959,https://github.com/torvalds/linux/commit/6708075f104c3c9b04b23336bb0366ca30c3931b,2013-05-03T11:57Z
1125,CWE-119,"<S2SV_StartBug> sdb_set ( s , ""DW_AT_comp_dir"" , name , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> if ( name > 1024 ) { <S2SV_ModStart> else { eprintf ( ""Invalid<S2SV_blank>string<S2SV_blank>pointer<S2SV_blank>at<S2SV_blank>%p\\n"" , name ) ; } } ",radare@radare2/bd1bab05083d80464fea854bf4b5c49aaf1b8401,CVE-2018-14015,https://github.com/radare/radare2/commit/bd1bab05083d80464fea854bf4b5c49aaf1b8401,2018-07-12T20:29Z
1126,CWE-120,<S2SV_StartBug> p_enc -> fmt_out . p_extra = malloc ( len + sizeof ( eos ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len > UINT32_MAX - sizeof ( eos ) ) return NULL ; ,videolan@vlc/9bb0353a5c63a7f8c6fc853faa3df4b4df1f5eb5,CVE-2014-9629,https://github.com/videolan/vlc/commit/9bb0353a5c63a7f8c6fc853faa3df4b4df1f5eb5,2020-01-24T22:15Z
1127,CWE-134,"<S2SV_StartBug> char * fname = talloc_size ( mf , strlen ( filename ) + 32 ) ; <S2SV_EndBug> <S2SV_StartBug> mp_info ( log , ""search<S2SV_blank>expr:<S2SV_blank>%s\\n"" , filename ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( fname , filename , count ++ ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t fname_avail = <S2SV_ModEnd> <S2SV_ModStart> ; char * fname = talloc_size ( mf , fname_avail <S2SV_ModStart> const char * f = filename ; int MAXDIGS = 3 , nspec = 0 , bad_spec = 0 , c ; while ( nspec < 2 && ( c = * f ++ ) ) { if ( c != '%' ) continue ; if ( * f != '%' ) { nspec ++ ; if ( * f == '.' ) f ++ ; for ( int ndig = 0 ; mp_isdigit ( * f ) && ndig < MAXDIGS ; ndig ++ , f ++ ) ; if ( * f != 'd' ) { bad_spec ++ ; break ; } } f ++ ; } if ( bad_spec || nspec != 1 ) { mp_err ( log , ""unsupported<S2SV_blank>expr<S2SV_blank>format:<S2SV_blank>\'%s\'\\n"" , filename ) ; goto exit_mf ; } <S2SV_ModStart> if ( snprintf ( fname , fname_avail <S2SV_ModEnd> <S2SV_ModStart> >= fname_avail ) { mp_err ( log , ""format<S2SV_blank>result<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>\'%s\'\\n"" , filename ) ; goto exit_mf ; } <S2SV_ModEnd> ",mpv-player@mpv/d0c530919d8cd4d7a774e38ab064e0fabdae34e6,CVE-2021-30145,https://github.com/mpv-player/mpv/commit/d0c530919d8cd4d7a774e38ab064e0fabdae34e6,2021-05-18T14:15Z
1128,CWE-125,"<S2SV_StartBug> cp += advance ; <S2SV_EndBug> <S2SV_StartBug> nh = * cp ; <S2SV_EndBug> <S2SV_StartBug> advance = rt6_print ( ndo , cp , ( const u_char * ) ip6 ) ; <S2SV_EndBug> <S2SV_StartBug> nh = * cp ; <S2SV_EndBug> <S2SV_StartBug> advance = ah_print ( ndo , cp ) ; <S2SV_EndBug> <S2SV_StartBug> nh = enh & 0xff ; <S2SV_EndBug> ",<S2SV_ModStart> if ( len < ( u_int ) advance ) goto trunc ; <S2SV_ModStart> if ( advance < 0 ) return ; <S2SV_ModStart> ND_TCHECK ( * cp ) ; <S2SV_ModStart> if ( advance < 0 ) return ; <S2SV_ModStart> ; if ( advance < 0 ) return <S2SV_ModStart> if ( advance < 0 ) return ; ,the-tcpdump-group@tcpdump/66df248b49095c261138b5a5e34d341a6bf9ac7f,CVE-2017-12985,https://github.com/the-tcpdump-group/tcpdump/commit/66df248b49095c261138b5a5e34d341a6bf9ac7f,2017-09-14T06:29Z
1129,CWE-125,"<S2SV_StartBug> uint32 num_properties = GETINT32 ( buf + idx ) ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < ( a -> names [ i ] . len >> 1 ) ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( a -> type == szMAPI_UNICODE_STRING ) <S2SV_EndBug> <S2SV_StartBug> v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; assert ( ( num_properties + 1 ) != 0 <S2SV_ModStart> assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ; <S2SV_ModStart> assert ( v -> len + idx <= len ) ; <S2SV_ModStart> assert ( v -> len != 0 ) ; ,verdammelt@tnef/1a17af1ed0c791aec44dbdc9eab91218cc1e335a,CVE-2017-6307,https://github.com/verdammelt/tnef/commit/1a17af1ed0c791aec44dbdc9eab91218cc1e335a,2017-02-24T04:59Z
1130,CWE-000,<S2SV_StartBug> switch ( fe -> icbTag . fileType ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ; if ( inode -> i_size > inode -> i_sb -> s_blocksize - udf_file_entry_alloc_offset ( inode ) ) goto out ; } ,torvalds@linux/e159332b9af4b04d882dbcfe1bb0117f0a6d4b58,CVE-2014-9729,https://github.com/torvalds/linux/commit/e159332b9af4b04d882dbcfe1bb0117f0a6d4b58,2015-08-31T10:59Z
1131,CWE-667,"<S2SV_StartBug> vma = find_vma_prev ( mm , start , & prev ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! mmget_still_valid ( mm ) ) goto out_unlock ; ,torvalds@linux/04f5866e41fb70690e28397487d8bd8eea7d712a,CVE-2019-11599,https://github.com/torvalds/linux/commit/04f5866e41fb70690e28397487d8bd8eea7d712a,2019-04-29T18:29Z
1132,CWE-119,"<S2SV_StartBug> act = vp8_variance16x16 ( x -> src . y_buffer , <S2SV_EndBug> ",<S2SV_ModStart> ( void ) cpi ; act = vpx_variance16x16 <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1133,CWE-119,"<S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> ","<S2SV_ModStart> alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ",TeX-Live@texlive-source/6ed0077520e2b0da1fd060c7f88db7b2e6068e4c,CVE-2018-17407,https://github.com/TeX-Live/texlive-source/commit/6ed0077520e2b0da1fd060c7f88db7b2e6068e4c,2018-09-23T21:29Z
1134,CWE-119,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> if ( data ) { <S2SV_EndBug> <S2SV_StartBug> vp9_get_reference_dec ( ctx -> pbi , data -> idx , & fb ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ctx -> frame_parallel_decode ) { set_error_detail ( ctx , ""Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode"" ) ; return VPX_CODEC_INCAPABLE ; } if ( <S2SV_ModStart> VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; fb = get_ref_frame ( & frame_worker_data -> pbi -> common <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( fb == NULL ) return VPX_CODEC_ERROR <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1135,CWE-000,"<S2SV_StartBug> ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; <S2SV_EndBug> <S2SV_StartBug> setup_syscalls_segments ( ctxt , & cs , & ss ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! ( em_syscall_is_enabled ( ctxt ) ) ) return emulate_ud ( ctxt ) ; <S2SV_ModStart> ) ; if ( ! ( efer & EFER_SCE ) ) return emulate_ud ( ctxt ,torvalds@linux/c2226fc9e87ba3da060e47333657cd6616652b84,CVE-2012-0045,https://github.com/torvalds/linux/commit/c2226fc9e87ba3da060e47333657cd6616652b84,2012-07-03T16:40Z
1136,CWE-787,<S2SV_StartBug> data_ref = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> if ( length > end - start ) return AVERROR_INVALIDDATA ; ,FFmpeg@FFmpeg/1812352d767ccf5431aa440123e2e260a4db2726,CVE-2020-12284,https://github.com/FFmpeg/FFmpeg/commit/1812352d767ccf5431aa440123e2e260a4db2726,2020-04-28T06:15Z
1137,CWE-125,"<S2SV_StartBug> if ( NCH ( n ) == 1 ) { <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> REQ ( CHILD ( n , 1 ) , EQUAL ) ; <S2SV_EndBug> <S2SV_StartBug> targets = _Py_asdl_seq_new ( NCH ( n ) / 2 , c -> c_arena ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < NCH ( n ) - 2 ; i += 2 ) { <S2SV_EndBug> <S2SV_StartBug> value = CHILD ( n , NCH ( n ) - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> return Assign ( targets , expression , LINENO ( n ) , n -> n_col_offset , <S2SV_EndBug> ","<S2SV_ModStart> int num = <S2SV_ModEnd> <S2SV_ModStart> ; if ( num <S2SV_ModStart> , nch_minus_type , has_type_comment <S2SV_ModStart> string type_comment ; <S2SV_ModStart> has_type_comment = TYPE ( CHILD ( n , num - 1 ) ) == TYPE_COMMENT ; nch_minus_type = num - has_type_comment ; <S2SV_ModStart> nch_minus_type <S2SV_ModEnd> <S2SV_ModStart> nch_minus_type <S2SV_ModEnd> <S2SV_ModStart> nch_minus_type <S2SV_ModEnd> <S2SV_ModStart> if ( has_type_comment ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , nch_minus_type ) ) ; if ( ! type_comment ) return NULL ; } else type_comment = NULL ; <S2SV_ModStart> type_comment , ",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z
1138,CWE-119,"<S2SV_StartBug> int vp8_denoiser_filter_c ( YV12_BUFFER_CONFIG * mc_running_avg , <S2SV_EndBug> <S2SV_StartBug> unsigned char * mc_running_avg_y = mc_running_avg -> y_buffer + y_offset ; <S2SV_EndBug> <S2SV_StartBug> unsigned char * running_avg_y = running_avg -> y_buffer + y_offset ; <S2SV_EndBug> <S2SV_StartBug> int r , c , i ; <S2SV_EndBug> <S2SV_StartBug> int adj_val [ 3 ] = { 3 , 4 , 6 } ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 3 ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( absdiff <= 3 ) <S2SV_EndBug> <S2SV_StartBug> sum_diff += diff ; <S2SV_EndBug> <S2SV_StartBug> if ( absdiff >= 4 && absdiff <= 7 ) <S2SV_EndBug> <S2SV_StartBug> sum_diff += adjustment ; <S2SV_EndBug> <S2SV_StartBug> running_avg_y [ c ] = sig [ c ] - adjustment ; <S2SV_EndBug> <S2SV_StartBug> if ( abs ( sum_diff ) > SUM_DIFF_THRESHOLD ) <S2SV_EndBug> <S2SV_StartBug> vp8_copy_mem16x16 ( running_avg -> y_buffer + y_offset , avg_y_stride , <S2SV_EndBug> <S2SV_StartBug> signal -> thismb , sig_stride ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , int mc_avg_y_stride , <S2SV_ModEnd> <S2SV_ModStart> , int avg_y_stride , unsigned char * sig , int sig_stride , unsigned int motion_magnitude , int increase_denoising ) { unsigned char * running_avg_y_start = running_avg_y ; unsigned char * sig_start = sig ; int sum_diff_thresh <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } ; int shift_inc1 = 0 ; int shift_inc2 = 1 ; int col_sum [ 16 ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 <S2SV_ModStart> if ( increase_denoising ) { shift_inc1 = 1 ; shift_inc2 = 2 ; } adj_val [ 0 ] += shift_inc2 ; adj_val [ 1 ] += shift_inc2 ; adj_val [ 2 ] += shift_inc2 <S2SV_ModEnd> <S2SV_ModStart> + shift_inc1 <S2SV_ModStart> col_sum [ c ] <S2SV_ModEnd> <S2SV_ModStart> + shift_inc1 <S2SV_ModStart> col_sum [ c ] += adjustment ; } else { if ( ( sig [ c ] - adjustment ) < 0 ) running_avg_y [ c ] = 0 ; else running_avg_y [ c ] = sig [ c ] - adjustment ; col_sum [ c ] -= adjustment ; } } } sig += sig_stride ; mc_running_avg_y += mc_avg_y_stride ; running_avg_y += avg_y_stride ; } for ( c = 0 ; c < 16 ; ++ c ) { if ( col_sum [ c ] >= 128 ) { col_sum [ c ] = 127 ; } sum_diff += col_sum [ c ] ; } sum_diff_thresh = SUM_DIFF_THRESHOLD ; if ( increase_denoising ) sum_diff_thresh = SUM_DIFF_THRESHOLD_HIGH ; if ( abs ( sum_diff ) > sum_diff_thresh ) { int delta = ( ( abs ( sum_diff ) - sum_diff_thresh ) >> 8 ) + 1 ; if ( delta < 4 ) { sig -= sig_stride * 16 ; mc_running_avg_y -= mc_avg_y_stride * 16 ; running_avg_y -= avg_y_stride * 16 ; for ( r = 0 ; r < 16 ; ++ r ) { for ( c = 0 ; c < 16 ; ++ c ) { int diff = mc_running_avg_y <S2SV_ModEnd> <S2SV_ModStart> sig [ c ] ; int adjustment = abs ( diff ) ; if ( adjustment > delta ) adjustment = delta ; if ( diff > 0 ) { if ( running_avg_y [ c ] - adjustment < 0 ) running_avg_y [ c ] = 0 ; else running_avg_y [ c ] = running_avg_y [ c ] - adjustment ; col_sum [ c ] -= adjustment ; } else if ( diff < 0 ) { if ( running_avg_y [ c ] + adjustment > 255 ) running_avg_y [ c ] = 255 ; else running_avg_y [ c ] = running_avg_y [ c ] + adjustment ; col_sum [ c ] += adjustment ; } } sig += sig_stride ; mc_running_avg_y += mc_avg_y_stride ; running_avg_y += avg_y_stride ; } sum_diff = 0 ; for ( c = 0 ; c < 16 ; ++ c ) { if ( col_sum [ c ] >= 128 ) { col_sum [ c ] = 127 ; } sum_diff += col_sum [ c ] <S2SV_ModEnd> <S2SV_ModStart> sum_diff_thresh <S2SV_ModEnd> <S2SV_ModStart> } else { return COPY_BLOCK ; } } vp8_copy_mem16x16 ( running_avg_y_start <S2SV_ModEnd> <S2SV_ModStart> sig_start <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1139,CWE-119,"<S2SV_StartBug> Ns_Log ( Dev , ""===<S2SV_blank>length<S2SV_blank><<S2SV_blank>avail<S2SV_blank>(length<S2SV_blank>%"" PRIuz <S2SV_EndBug> <S2SV_StartBug> bool complete ; <S2SV_EndBug> <S2SV_StartBug> complete = ChunkedDecode ( reqPtr , NS_TRUE ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ! complete ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> Debug <S2SV_ModEnd> <S2SV_ModStart> SockState chunkState <S2SV_ModEnd> <S2SV_ModStart> chunkState <S2SV_ModEnd> <S2SV_ModStart> chunkState == SOCK_MORE <S2SV_ModEnd> <S2SV_ModStart> else if ( chunkState != SOCK_READY ) { return chunkState ; } ,naviserver@naviserver/a5c3079f1d8996d5f34c9384a440acf3519ca3bb,CVE-2020-13111,https://bitbucket.org/naviserver/naviserver/commit/a5c3079f1d8996d5f34c9384a440acf3519ca3bb,2020-05-16T15:15Z
1140,CWE-20,<S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( ! access_ok ( VERIFY_READ , uregs , sizeof ( elf_xtregs_t ) ) ) return - EFAULT ",torvalds@linux/0d0138ebe24b94065580bd2601f8bb7eb6152f56,CVE-2011-2707,https://github.com/torvalds/linux/commit/0d0138ebe24b94065580bd2601f8bb7eb6152f56,2012-05-24T23:55Z
1141,CWE-20,<S2SV_StartBug> message -> srcIpAddr = queueItem -> srcIpAddr ; <S2SV_EndBug> ,<S2SV_ModStart> interface = queueItem -> interface ; message -> ,Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
1142,CWE-22,<S2SV_StartBug> struct se_device * remote_dev ; <S2SV_EndBug> <S2SV_StartBug> remote_dev = xop -> dst_dev ; <S2SV_EndBug> <S2SV_StartBug> remote_dev = xop -> src_dev ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pr_debug ( ""putting<S2SV_blank>dst<S2SV_blank>lun_ref<S2SV_blank>for<S2SV_blank>%p\\n"" , <S2SV_ModEnd> <S2SV_ModStart> ) ; else pr_debug ( ""putting<S2SV_blank>src<S2SV_blank>lun_ref<S2SV_blank>for<S2SV_blank>%p\\n"" , <S2SV_ModEnd> <S2SV_ModStart> ) ; percpu_ref_put ( xop -> remote_lun_ref <S2SV_ModEnd> ",torvalds@linux/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,CVE-2020-28374,https://github.com/torvalds/linux/commit/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4,2021-01-13T04:15Z
1143,CWE-284,"<S2SV_StartBug> err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS."" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; err = - errno ; goto close_sock ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVHOPLIMIT , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVHOPLIMIT,."" ",jpirko@libndp/a4892df306e0532487f1634ba6d4c6d4bb381c7f,CVE-2016-3698,https://github.com/jpirko/libndp/commit/a4892df306e0532487f1634ba6d4c6d4bb381c7f,2016-06-13T19:59Z
1144,CWE-19,<S2SV_StartBug> if ( header ) { <S2SV_EndBug> <S2SV_StartBug> ext2_xattr_cache_insert ( new_bh ) ; <S2SV_EndBug> <S2SV_StartBug> ext2_xattr_cache_insert ( new_bh ) ; <S2SV_EndBug> <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> ,"<S2SV_ModStart> struct mb2_cache * ext2_mb_cache = EXT2_SB ( sb ) -> s_mb_cache ; <S2SV_ModStart> ext2_mb_cache , <S2SV_ModStart> ext2_mb_cache , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> __u32 hash = le32_to_cpu ( HDR ( old_bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( ext2_mb_cache , hash , old_bh -> b_blocknr <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/be0726d33cb8f411945884664924bed3cb8c70ee,CVE-2015-8952,https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee,2016-10-16T21:59Z
1145,CWE-310,"<S2SV_StartBug> snprintf ( rcomp . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""compression"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> ""compression"" , sizeof ( rcomp . type ) <S2SV_ModEnd> ",torvalds@linux/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,CVE-2013-2548,https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,2013-03-15T20:55Z
1146,CWE-119,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_set_active_map ( ctx -> cpi , map -> active_map , map -> rows , map -> cols ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( int ) <S2SV_ModStart> ( int ) ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1147,CWE-285,"<S2SV_StartBug> rc = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> return rc ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( rc ) return rc ; inode -> i_ctime = CURRENT_TIME ; mark_inode_dirty ( inode ) ; } break ; case ACL_TYPE_DEFAULT : ea_name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) return - ENOMEM ; rc = posix_acl_to_xattr ( & init_user_ns , acl , value , size <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z
1148,CWE-476,<S2SV_StartBug> DestroyImage ( RemoveFirstImageFromList ( & image ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( GetNextImageInList ( image ) != ( Image * ) NULL ) ,ImageMagick@ImageMagick/d31fec57e9dfb0516deead2053a856e3c71e9751,CVE-2017-6501,https://github.com/ImageMagick/ImageMagick/commit/d31fec57e9dfb0516deead2053a856e3c71e9751,2017-03-06T02:59Z
1149,CWE-400,"<S2SV_StartBug> task_event -> event_id . header . size , 0 , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
1150,CWE-119,<S2SV_StartBug> size_t maxlen = 3 * len ; <S2SV_EndBug> ,<S2SV_ModStart> + 8 ,m6w6@ext-http/3724cd76a28be1d6049b5537232e97ac567ae1f5,CVE-2016-5873,https://github.com/m6w6/ext-http/commit/3724cd76a28be1d6049b5537232e97ac,2017-01-23T21:59Z
1151,CWE-189,<S2SV_StartBug> SEPARATE_ZVAL ( ( var ) ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_long ( * var ) ; <S2SV_EndBug> <S2SV_StartBug> points [ i ] . x = Z_LVAL_PP ( var ) ; <S2SV_EndBug> <S2SV_StartBug> SEPARATE_ZVAL ( var ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_long ( * var ) ; <S2SV_EndBug> <S2SV_StartBug> points [ i ] . y = Z_LVAL_PP ( var ) ; <S2SV_EndBug> <S2SV_StartBug> if ( filled ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( Z_TYPE_PP ( var ) != IS_LONG ) { zval lval ; lval = * * var ; zval_copy_ctor ( & lval <S2SV_ModEnd> <S2SV_ModStart> & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { points [ i ] . x = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( var ) != IS_LONG ) { zval lval ; lval = * * var ; zval_copy_ctor ( & lval <S2SV_ModEnd> <S2SV_ModStart> & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { points [ i ] . y = <S2SV_ModStart> } ,php@php-src/2938329ce19cb8c4197dec146c3ec887c6f61d01,CVE-2014-2020,https://github.com/php/php-src/commit/2938329ce19cb8c4197dec146c3ec887c6f61d01,2014-02-18T11:55Z
1152,CWE-125,<S2SV_StartBug> sig_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/cef31d9af908243421258f1df35a4a644604efbe,CVE-2017-18344,https://github.com/torvalds/linux/commit/cef31d9af908243421258f1df35a4a644604efbe,2018-07-26T19:29Z
1153,CWE-119,"<S2SV_StartBug> imbuf = ( unsigned char * ) AcquireQuantumMemory ( imsx * imsy , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) ResetMagickMemory ( imbuf , background_color_index , imsx * imsy ) ; <S2SV_EndBug> <S2SV_StartBug> dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) ResetMagickMemory ( dmbuf , background_color_index , dmsx * dmsy ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) CopyMagickMemory ( dmbuf + dmsx * y , imbuf + imsx * y , imsx ) ; <S2SV_EndBug> <S2SV_StartBug> dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) ResetMagickMemory ( dmbuf , background_color_index , dmsx * dmsy ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) CopyMagickMemory ( dmbuf + dmsx * y , imbuf + imsx * y , imsx ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) ResetMagickMemory ( imbuf + imsx * y + posision_x , color_index , repeat_count ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ) == NULL ) { <S2SV_EndBug> ","<S2SV_ModStart> , imsy <S2SV_ModEnd> <S2SV_ModStart> ( size_t ) <S2SV_ModStart> , dmsy <S2SV_ModEnd> <S2SV_ModStart> ( size_t ) <S2SV_ModStart> ( size_t ) <S2SV_ModStart> , dmsy <S2SV_ModEnd> <S2SV_ModStart> ( size_t ) <S2SV_ModStart> ( size_t ) <S2SV_ModStart> ( size_t ) <S2SV_ModStart> , dmsy <S2SV_ModEnd> ",ImageMagick@ImageMagick/10b3823a7619ed22d42764733eb052c4159bc8c1,CVE-2016-10057,https://github.com/ImageMagick/ImageMagick/commit/10b3823a7619ed22d42764733eb052c4159bc8c1,2017-03-23T17:59Z
1154,CWE-119,"<S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> ","<S2SV_ModStart> alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ",TeX-Live@texlive-source/6ed0077520e2b0da1fd060c7f88db7b2e6068e4c,CVE-2018-17407,https://github.com/TeX-Live/texlive-source/commit/6ed0077520e2b0da1fd060c7f88db7b2e6068e4c,2018-09-23T21:29Z
1155,CWE-119,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ; <S2SV_EndBug> <S2SV_StartBug> image2yuvconfig ( & frame -> img , & sd ) ; <S2SV_EndBug> <S2SV_StartBug> return vp9_copy_reference_dec ( ctx -> pbi , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx , ""Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode"" ) ; return VPX_CODEC_INCAPABLE ; } <S2SV_ModStart> VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; <S2SV_ModStart> frame_worker_data <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1156,CWE-89,"<S2SV_StartBug> pop3c -> mailbox = curl_easy_unescape ( data , path , 0 , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! pop3c -> mailbox ) <S2SV_EndBug> ","<S2SV_ModStart> return Curl_urldecode <S2SV_ModEnd> <S2SV_ModStart> & <S2SV_ModEnd> <S2SV_ModStart> , NULL , TRUE ) <S2SV_ModEnd> ",bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238,CVE-2012-0036,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,2012-04-13T20:55Z
1157,CWE-20,<S2SV_StartBug> facilities_len -= len + 1 ; <S2SV_EndBug> <S2SV_StartBug> facilities_len -= len + 1 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 0 ) return 0 ; <S2SV_ModStart> if ( len < 0 ) return 0 ; ,torvalds@linux/be20250c13f88375345ad99950190685eda51eb8,CVE-2011-4913,https://github.com/torvalds/linux/commit/be20250c13f88375345ad99950190685eda51eb8,2012-06-21T23:55Z
1158,CWE-476,<S2SV_StartBug> sh -> first_slice_in_pic_flag = get_bits1 ( gb ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( s -> ref && sh -> first_slice_in_pic_flag ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\n"" ) ; return 1 ; } ",FFmpeg@FFmpeg/54655623a82632e7624714d7b2a3e039dc5faa7e,CVE-2019-11338,https://github.com/FFmpeg/FFmpeg/commit/54655623a82632e7624714d7b2a3e039dc5faa7e,2019-04-19T00:29Z
1159,CWE-20,<S2SV_StartBug> ps_dec -> ps_cur_slice -> u1_bottom_field_flag = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,external@libavc/cc676ebd95247646e67907ccab150fb77a847335,CVE-2016-3741,https://android.googlesource.com/platform/external/libavc/+/cc676ebd95247646e67907ccab150fb77a847335,2016-07-11T01:59Z
1160,CWE-119,<S2SV_StartBug> UWORD32 u4_x_dst_offset = 0 ; <S2SV_EndBug> <S2SV_StartBug> impeg2d_dec_pnb_mb_params ( ps_dec ) ; <S2SV_EndBug> <S2SV_StartBug> impeg2d_dec_p_mb_params ( ps_dec ) ; <S2SV_EndBug> ,<S2SV_ModStart> WORD32 ret ; <S2SV_ModStart> ret = <S2SV_ModStart> ret = <S2SV_ModStart> ; if ( ret ) return IMPEG2D_MB_TEX_DECODE_ERR ,external@libmpeg2/58a6822d7140137ce957c6d2fc20bae1374186c1,CVE-2016-0835,https://android.googlesource.com/platform/external/libmpeg2/+/58a6822d7140137ce957c6d2fc20bae1374186c1,2016-04-18T00:59Z
1161,CWE-119,<S2SV_StartBug> const YV12_BUFFER_CONFIG * const cfg = <S2SV_EndBug> <S2SV_StartBug> & cm -> frame_bufs [ cm -> ref_frame_map [ 0 ] ] . buf ; <S2SV_EndBug> ,"<S2SV_ModStart> get_ref_frame ( cm , 0 ) ; if ( cfg == NULL ) { vpx_internal_error ( <S2SV_ModStart> error , VPX_CODEC_ERROR , ""No<S2SV_blank>\'last\'<S2SV_blank>reference<S2SV_blank>frame"" ) ; return VPX_CODEC_ERROR ; } <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1162,CWE-190,<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> int rowstep ; <S2SV_EndBug> ,<S2SV_ModStart> jas_matind_t i ; jas_matind_t <S2SV_ModEnd> <S2SV_ModStart> jas_matind_t <S2SV_ModEnd> ,mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
1163,CWE-119,<S2SV_StartBug> const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi ) <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> if ( xd -> mb_to_right_edge < 0 || xd -> mb_to_bottom_edge < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( xd -> mb_to_bottom_edge < 0 ) <S2SV_EndBug> <S2SV_StartBug> i = 0 ; <S2SV_EndBug> <S2SV_StartBug> for ( r = 0 ; r < num_4x4_h ; r += ( 1 << tx_size ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( r < max_blocks_high && c < max_blocks_wide ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> , pd <S2SV_ModStart> = 0 , r , c ; const int max_blocks_wide = num_4x4_w + <S2SV_ModEnd> <S2SV_ModStart> >= 0 ? 0 : <S2SV_ModEnd> <S2SV_ModStart> const int max_blocks_high = num_4x4_h + <S2SV_ModEnd> <S2SV_ModStart> >= 0 ? 0 : <S2SV_ModEnd> <S2SV_ModStart> const int extra_step = ( ( num_4x4_w - max_blocks_wide ) >> tx_size ) * step <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; r += ( 1 << tx_size ) ) { for ( c = 0 ; <S2SV_ModEnd> <S2SV_ModStart> ; c += ( 1 << tx_size ) ) { <S2SV_ModEnd> <S2SV_ModStart> i += extra_step <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1164,CWE-254,<S2SV_StartBug> mm -> mmap_legacy_base = mmap_legacy_base ( random_factor ) ; <S2SV_EndBug> ,<S2SV_ModStart> TASK_UNMAPPED_BASE + random_factor <S2SV_ModEnd> ,torvalds@linux/8b8addf891de8a00e4d39fc32f93f7c5eb8feceb,CVE-2016-3672,https://github.com/torvalds/linux/commit/8b8addf891de8a00e4d39fc32f93f7c5eb8feceb,2016-04-27T17:59Z
1165,CWE-119,<S2SV_StartBug> # if ! ( CONFIG_FAST_UNALIGNED ) <S2SV_EndBug> ,"<S2SV_ModStart> memcpy ( dst , src , 8 ) ; <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1166,CWE-190,"<S2SV_StartBug> case 'c' : return getnum ( L , fmt , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> int sz = getnum ( L , fmt , sizeof ( int ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,antirez@redis/1eb08bcd4634ae42ec45e8284923ac048beaa4c3,CVE-2018-11219,https://github.com/antirez/redis/commit/1eb08bcd4634ae42ec45e8284923ac048beaa4c3,2018-06-17T17:29Z
1167,CWE-787,"<S2SV_StartBug> rowstoread = rowsperstrip - ( row + img -> row_offset ) % rowsperstrip ; <S2SV_EndBug> <S2SV_StartBug> if ( buf == NULL ) <S2SV_EndBug> <S2SV_StartBug> ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> <S2SV_StartBug> p0 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> <S2SV_StartBug> p1 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> <S2SV_StartBug> p2 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> <S2SV_StartBug> pa , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> ","<S2SV_ModStart> uint32 temp ; <S2SV_ModStart> temp = ( row + img -> row_offset ) % rowsperstrip + nrow ; if ( scanline > 0 && temp > ( size_t ) ( TIFF_TMSIZE_T_MAX / scanline ) ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , ""Integer<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>gtStripSeparate"" ) ; return 0 ; } <S2SV_ModStart> temp <S2SV_ModEnd> <S2SV_ModStart> temp <S2SV_ModEnd> <S2SV_ModStart> temp <S2SV_ModEnd> <S2SV_ModStart> temp <S2SV_ModEnd> <S2SV_ModStart> temp <S2SV_ModEnd> ",OSGeo@gdal/21674033ee246f698887604c7af7ba1962a40ddf,CVE-2019-17546,https://github.com/OSGeo/gdal/commit/21674033ee246f698887604c7af7ba1962a40ddf,2019-10-14T02:15Z
1168,CWE-125,<S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> abort ( ) <S2SV_ModEnd> ,python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
1169,CWE-119,<S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 2 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> . ptr [ <S2SV_ModEnd> <S2SV_ModStart> . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z
1170,CWE-20,<S2SV_StartBug> if ( upid == - 1 ) <S2SV_EndBug> ,<S2SV_ModStart> INT_MIN ) return - ESRCH ; if ( upid == ,torvalds@linux/dd83c161fbcc5d8be637ab159c0de015cbff5ba4,CVE-2018-10087,https://github.com/torvalds/linux/commit/dd83c161fbcc5d8be637ab159c0de015cbff5ba4,2018-04-13T13:29Z
1171,CWE-287,"<S2SV_StartBug> err = scm_send ( sock , msg , siocb -> scm ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false ",torvalds@linux/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea,CVE-2012-3520,https://github.com/torvalds/linux/commit/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea,2012-10-03T11:02Z
1172,CWE-190,<S2SV_StartBug> if ( num & ( 1 << ( number - 1 ) ) ) <S2SV_EndBug> ,<S2SV_ModStart> number && ,libming@libming/a009a38dce1d9316cad1ab522b813b1d5ba4c62a,CVE-2019-12980,https://github.com/libming/libming/commit/a009a38dce1d9316cad1ab522b813b1d5ba4c62a,2019-06-26T18:15Z
1173,CWE-119,"<S2SV_StartBug> const int w = vpx_img_plane_width ( img , plane ) ; <S2SV_EndBug> <S2SV_StartBug> if ( fread ( buf , 1 , w , file ) != w ) <S2SV_EndBug> ",<S2SV_ModStart> * ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) <S2SV_ModStart> ( size_t ) ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1174,CWE-119,"<S2SV_StartBug> uint16_t attr_len ; <S2SV_EndBug> <S2SV_StartBug> if ( avp -> length < sizeof ( struct l2tp_avp_t ) + 2 ) { <S2SV_EndBug> <S2SV_StartBug> ntohs ( avp -> type ) , avp -> length ) ; <S2SV_EndBug> <S2SV_StartBug> attr_len = avp -> length - sizeof ( struct l2tp_avp_t ) ; <S2SV_EndBug> ",<S2SV_ModStart> avp_len ; uint16_t <S2SV_ModStart> avp_len = avp -> flags & L2TP_AVP_LEN_MASK ; if ( avp_len <S2SV_ModEnd> <S2SV_ModStart> avp_len <S2SV_ModEnd> <S2SV_ModStart> avp_len <S2SV_ModEnd> ,accel-ppp@accel-ppp/2324bcd5ba12cf28f47357a8f03cd41b7c04c52b,CVE-2020-15173,https://github.com/accel-ppp/accel-ppp/commit/2324bcd5ba12cf28f47357a8f03cd41b7c04c52b,2020-09-09T23:15Z
1175,CWE-264,"<S2SV_StartBug> return __blkdev_driver_ioctl ( lc -> dev -> bdev , lc -> dev -> mode , cmd , arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct dm_dev * dev = lc -> dev ; int r = 0 ; if <S2SV_ModEnd> <S2SV_ModStart> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/ec8013beddd717d1740cfefb1a9b900deef85462,CVE-2011-4127,https://github.com/torvalds/linux/commit/ec8013beddd717d1740cfefb1a9b900deef85462,2012-07-03T16:40Z
1176,CWE-125,<S2SV_StartBug> len -= POLY1305_BLOCK_SIZE ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len < POLY1305_BLOCK_SIZE ) return 0 ; ,openssl@openssl/00d965474b22b54e4275232bc71ee0c699c5cd21,CVE-2017-3731,https://github.com/openssl/openssl/commit/00d965474b22b54e4275232bc71ee0c699c5cd21,2017-05-04T19:29Z
1177,CWE-264,"<S2SV_StartBug> request_module ( ""%s"" , name ) ; <S2SV_EndBug> <S2SV_StartBug> request_module ( ""%s-all"" , name ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""crypto-%s"" <S2SV_ModEnd> <S2SV_ModStart> ""crypto-%s-all"" <S2SV_ModEnd> ",torvalds@linux/5d26a105b5a73e5635eae0629b42fa0a90e07b7b,CVE-2013-7421,https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b,2015-03-02T11:59Z
1178,CWE-400,"<S2SV_StartBug> comm_event -> event_id . header . size , 0 , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
1179,CWE-284,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> unlink ( RUN_LIB_FILE ) ; ,netblue30@firejail/eecf35c2f8249489a1d3e512bb07f0d427183134,CVE-2019-12589,https://github.com/netblue30/firejail/commit/eecf35c2f8249489a1d3e512bb07f0d427183134,2019-06-03T03:29Z
1180,CWE-20,<S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> ,<S2SV_ModStart> key_is_positive <S2SV_ModEnd> ,torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z
1181,CWE-200,"<S2SV_StartBug> BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; memset ( sa , 0 , sizeof ( * sa ) ",torvalds@linux/9344a972961d1a6d2c04d9008b13617bcb6ec2ef,CVE-2012-6545,https://github.com/torvalds/linux/commit/9344a972961d1a6d2c04d9008b13617bcb6ec2ef,2013-03-15T20:55Z
1182,CWE-119,"<S2SV_StartBug> memcpy ( pass_salt , cpkt . data , cpkt . length ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( cpkt . length != 16 ) { fprintf ( stderr , _ ( ""Invalid<S2SV_blank>salt<S2SV_blank>length:<S2SV_blank>%d<S2SV_blank>(instead<S2SV_blank>of<S2SV_blank>16)<S2SV_blank>received<S2SV_blank>from<S2SV_blank>server<S2SV_blank>%s\\n"" ) , cpkt . length , ether_ntoa ( ( struct ether_addr * ) dstmac ) ) ; } <S2SV_ModStart> 16 <S2SV_ModEnd> ",haakonnessjoen@MAC-Telnet/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a,CVE-2016-7115,https://github.com/haakonnessjoen/MAC-Telnet/commit/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a,2016-08-30T17:59Z
1183,CWE-476,<S2SV_StartBug> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ; <S2SV_EndBug> <S2SV_StartBug> if ( ses -> server -> sign ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> | NTLMSSP_NEGOTIATE_SEAL <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/cabfb3680f78981d26c078a26e5c748531257ebb,CVE-2018-1066,https://github.com/torvalds/linux/commit/cabfb3680f78981d26c078a26e5c748531257ebb,2018-03-02T08:29Z
1184,CWE-522,<S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> <S2SV_StartBug> goto err_close_conn ; <S2SV_EndBug> <S2SV_StartBug> # ifdef USE_SSL <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart> bail <S2SV_ModEnd> <S2SV_ModStart> bail <S2SV_ModEnd> <S2SV_ModStart> bail <S2SV_ModEnd> <S2SV_ModStart> bail <S2SV_ModEnd> <S2SV_ModStart> bail <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,neomutt@neomutt/9c36717a3e2af1f2c1b7242035455ec8112b4b06,CVE-2020-28896,https://github.com/neomutt/neomutt/commit/9c36717a3e2af1f2c1b7242035455ec8112b4b06,2020-11-23T19:15Z
1185,CWE-200,"<S2SV_StartBug> strlcpy ( rkpp . type , ""kpp"" , sizeof ( rkpp . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> ,torvalds@linux/f43f39958beb206b53292801e216d9b8a660f087,CVE-2018-19854,https://github.com/torvalds/linux/commit/f43f39958beb206b53292801e216d9b8a660f087,2018-12-04T16:29Z
1186,CWE-119,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % stride ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horDiff8"" , ""%s"" , ""(cc%stride)!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; ",vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1,CVE-2016-9535,https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1,2016-11-22T19:59Z
1187,CWE-369,<S2SV_StartBug> g -> head <= 0 || <S2SV_EndBug> ,<S2SV_ModStart> 0 || ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == ,torvalds@linux/f3554aeb991214cbfafd17d55e2bfddb50282e32,CVE-2019-14284,https://github.com/torvalds/linux/commit/f3554aeb991214cbfafd17d55e2bfddb50282e32,2019-07-26T13:15Z
1188,CWE-787,"<S2SV_StartBug> if ( recv ( gpsd_sock , line + pos , sizeof ( line ) - 1 , 0 ) <= 0 ) <S2SV_EndBug> ",<S2SV_ModStart> pos - ,aircrack-ng@aircrack-ng/ff70494dd389ba570dbdbf36f217c28d4381c6b5,CVE-2014-8321,https://github.com/aircrack-ng/aircrack-ng/commit/ff70494dd389ba570dbdbf36f217c28d4381c6b5,2020-01-31T22:15Z
1189,CWE-674,"<S2SV_StartBug> & clen , & remainder , & rlen ) ; <S2SV_EndBug> ","<S2SV_ModStart> , 0 ",krb5@krb5/57415dda6cf04e73ffc3723be518eddfae599bfd,CVE-2020-28196,https://github.com/krb5/krb5/commit/57415dda6cf04e73ffc3723be518eddfae599bfd,2020-11-06T08:15Z
1190,CWE-119,"<S2SV_StartBug> read_userfile ( ) ; <S2SV_EndBug> <S2SV_StartBug> md5data [ 0 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( md5data + 1 , user -> password , 82 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( md5data + 1 + strlen ( user -> password ) , curconn -> pass_salt , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> md5_append ( & state , ( const md5_byte_t * ) md5data , strlen ( user -> password ) + 17 ) ; <S2SV_EndBug> ",<S2SV_ModStart> int act_pass_len ; <S2SV_ModStart> act_pass_len = strlen ( user -> password ) ; act_pass_len = act_pass_len <= 82 ? act_pass_len : 82 ; <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> act_pass_len <S2SV_ModEnd> <S2SV_ModStart> act_pass_len <S2SV_ModEnd> <S2SV_ModStart> 1 + act_pass_len + 16 <S2SV_ModEnd> ,haakonnessjoen@MAC-Telnet/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a,CVE-2016-7115,https://github.com/haakonnessjoen/MAC-Telnet/commit/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a,2016-08-30T17:59Z
1191,CWE-59,"<S2SV_StartBug> return mount_entry_on_generic ( mntent , path ) ; <S2SV_EndBug> ","<S2SV_ModStart> , rootfs -> mount ",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z
1192,CWE-125,"<S2SV_StartBug> if ( PyUnicode_CompareWithASCIIString ( name , ""__debug__"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( PyUnicode_CompareWithASCIIString ( name , * p ) == 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> _PyUnicode_EqualToASCIIString <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> _PyUnicode_EqualToASCIIString <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
1193,CWE-772,<S2SV_StartBug> if ( len <= 0 ) <S2SV_EndBug> <S2SV_StartBug> len -= bytes ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned short prev_bi_vcnt = bio -> bi_vcnt ; <S2SV_ModStart> if ( bio -> bi_vcnt == prev_bi_vcnt ) put_page ( pages [ j ] ) ; ,torvalds@linux/95d78c28b5a85bacbc29b8dba7c04babb9b0d467,CVE-2017-12190,https://github.com/torvalds/linux/commit/95d78c28b5a85bacbc29b8dba7c04babb9b0d467,2017-11-22T18:29Z
1194,CWE-000,<S2SV_StartBug> assert ( numcolors <= RAS_CMAP_MAXSIZ ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( numcolors > RAS_CMAP_MAXSIZ ) { return - 1 ; } <S2SV_ModEnd> ,mdadams@jasper/411a4068f8c464e883358bf403a3e25158863823,CVE-2016-9388,https://github.com/mdadams/jasper/commit/411a4068f8c464e883358bf403a3e25158863823,2017-03-23T18:59Z
1195,CWE-89,"<S2SV_StartBug> const char * path = conn -> data -> state . path ; <S2SV_EndBug> <S2SV_StartBug> smtpc -> domain = curl_easy_unescape ( conn -> data , path , 0 , & len ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> result = Curl_urldecode ( conn -> data , path , 0 , & <S2SV_ModStart> , NULL , TRUE ) ; if ( result ) return result <S2SV_ModEnd> ",bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238,CVE-2012-0036,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,2012-04-13T20:55Z
1196,CWE-119,"<S2SV_StartBug> strncpy ( str , ""ID:"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( str , jslGetTokenValueAsString ( ) , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( str , ""String:\'"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( str , jslGetTokenValueAsString ( ) , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> espruino_snprintf <S2SV_ModEnd> <S2SV_ModStart> len , ""ID:%s"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> espruino_snprintf <S2SV_ModEnd> <S2SV_ModStart> len , ""String:\'%s\'"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",espruino@Espruino/0a7619875bf79877907205f6bee08465b89ff10b,CVE-2018-11595,https://github.com/espruino/Espruino/commit/0a7619875bf79877907205f6bee08465b89ff10b,2018-05-31T16:29Z
1197,CWE-125,"<S2SV_StartBug> for ( i = j = 0 ; i < sizeof ( buf ) - 1 && str [ i ] ; i ++ , j ++ ) { <S2SV_EndBug> ",<S2SV_ModStart> j <S2SV_ModEnd> ,devnexen@radare2/88a8adf080a9f8ed5a4250a2507752e133ba54dd,CVE-2018-20459,https://github.com/devnexen/radare2/commit/88a8adf080a9f8ed5a4250a2507752e133ba54dd,2018-12-25T19:29Z
1198,CWE-190,<S2SV_StartBug> uchar buf [ 2 ] ; <S2SV_EndBug> ,<S2SV_ModStart> jas_uchar <S2SV_ModEnd> ,mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
1199,CWE-000,<S2SV_StartBug> return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ; <S2SV_EndBug> ,"<S2SV_ModStart> scat = & rm -> data . op_sg [ sg ] ; ret = <S2SV_ModEnd> <S2SV_ModStart> ; ret = min_t ( int , ret , scat -> length - conn -> c_xmit_data_off ) ; return ret ",torvalds@linux/6094628bfd94323fc1cea05ec2c6affd98c18f7f,CVE-2011-1023,https://github.com/torvalds/linux/commit/6094628bfd94323fc1cea05ec2c6affd98c18f7f,2012-06-21T23:55Z
1200,CWE-476,"<S2SV_StartBug> priv -> base = devm_ioremap ( & pdev -> dev , r -> start , resource_size ( r ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! r ) return - EINVAL ; ,torvalds@linux/297a6961ffb8ff4dc66c9fbf53b924bd1dda05d5,CVE-2018-8043,https://github.com/torvalds/linux/commit/297a6961ffb8ff4dc66c9fbf53b924bd1dda05d5,2018-03-10T22:29Z
1201,CWE-476,<S2SV_StartBug> return FALSE ; <S2SV_EndBug> ,<S2SV_ModStart> transport -> credssp = NULL ; ,FreeRDP@FreeRDP/0773bb9303d24473fe1185d85a424dfe159aff53,CVE-2013-4119,https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53,2016-10-03T21:59Z
1202,CWE-125,"
","
",mdadams@jasper/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d,CVE-2016-9583,https://github.com/mdadams/jasper/commit/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d,2018-08-01T17:29Z
1203,CWE-78,"<S2SV_StartBug> r_cons_printf ( ""k<S2SV_blank>bin/pe/%s/%d=%s.%s\\n"" , <S2SV_EndBug> <S2SV_StartBug> r_cons_printf ( ""k<S2SV_blank>bin/pe/%s/%d=%s\\n"" , <S2SV_EndBug> ","<S2SV_ModStart> ""\\""k<S2SV_blank>bin/pe/%s/%d=%s.%s\\""\\n"" <S2SV_ModEnd> <S2SV_ModStart> ""\\""k<S2SV_blank>bin/pe/%s/%d=%s\\""\\n"" <S2SV_ModEnd> ",radareorg@radare2/5411543a310a470b1257fb93273cdd6e8dfcb3af,CVE-2019-16718,https://github.com/radareorg/radare2/commit/5411543a310a470b1257fb93273cdd6e8dfcb3af,2019-09-23T14:15Z
1204,CWE-189,"<S2SV_StartBug> status = decode_getacl ( xdr , rqstp , & res -> acl_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> res <S2SV_ModEnd> ,torvalds@linux/bf118a342f10dafe44b14451a1392c3254629a1f,CVE-2011-4131,https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f,2012-05-17T11:00Z
1205,CWE-59,"<S2SV_StartBug> return mount_entry_on_generic ( mntent , mntent -> mnt_dir ) ; <S2SV_EndBug> ","<S2SV_ModStart> , NULL ",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z
1206,CWE-310,<S2SV_StartBug> return Qnil ; <S2SV_EndBug> ,"<S2SV_ModStart> rb_ivar_set ( self , id_key_set , Qtrue ) ; ",ruby@openssl/8108e0a6db133f3375608303fdd2083eb5115062,CVE-2016-7798,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,2017-01-30T22:59Z
1207,CWE-617,<S2SV_StartBug> return KRB5KDC_ERR_BADOPTION ; <S2SV_EndBug> <S2SV_StartBug> server_princ ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> * status = ""INVALID_S4U2PROXY_OPTIONS"" ; <S2SV_ModStart> * status = ""EVIDENCE_TICKET_MISMATCH"" ; ",krb5@krb5/ffb35baac6981f9e8914f8f3bffd37f284b85970,CVE-2017-11368,https://github.com/krb5/krb5/commit/ffb35baac6981f9e8914f8f3bffd37f284b85970,2017-08-09T18:29Z
1208,CWE-264,<S2SV_StartBug> thread -> tp_value = childregs -> ARM_r3 ; <S2SV_EndBug> ,<S2SV_ModStart> [ 0 ] <S2SV_ModStart> ; thread -> tp_value [ 1 ] = get_tpuser ( ) ,torvalds@linux/a4780adeefd042482f624f5e0d577bf9cdcbb760,CVE-2014-9870,https://github.com/torvalds/linux/commit/a4780adeefd042482f624f5e0d577bf9cdcbb760,2016-08-06T10:59Z
1209,CWE-190,<S2SV_StartBug> jas_stream_t * stream ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( stream = jas_stream_create ( ) ) ) { <S2SV_EndBug> <S2SV_StartBug> obj -> bufsize_ = 1024 ; <S2SV_EndBug> <S2SV_StartBug> obj -> bufsize_ = bufsize ; <S2SV_EndBug> <S2SV_StartBug> obj -> growable_ = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> char * new_buf ; size_t new_bufsize <S2SV_ModEnd> <S2SV_ModStart> bufsize < 0 ) { jas_deprecated ( ""negative<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>for<S2SV_blank>jas_stream_memopen"" ) ; } if ( buf && bufsize <= 0 ) { jas_eprintf ( ""Invalid<S2SV_blank>use<S2SV_blank>of<S2SV_blank>jas_stream_memopen<S2SV_blank>detected.\\n"" ) ; jas_deprecated ( ""A<S2SV_blank>user-provided<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>"" ""jas_stream_memopen<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>growable.\\n"" ) ; } <S2SV_ModEnd> <S2SV_ModStart> new_bufsize = 0 ; new_buf = 0 <S2SV_ModEnd> <S2SV_ModStart> new_bufsize <S2SV_ModEnd> <S2SV_ModStart> new_buf = buf ; } return jas_stream_memopen2 ( new_buf , new_bufsize ) <S2SV_ModEnd> ",mdadams@jasper/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,CVE-2016-9262,https://github.com/mdadams/jasper/commit/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,2017-03-23T18:59Z
1210,CWE-200,"<S2SV_StartBug> struct sshbuf * b ; <S2SV_EndBug> <S2SV_StartBug> char * pkalg , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ; <S2SV_EndBug> <S2SV_StartBug> u_char * pkblob , * sig , have_sig ; <S2SV_EndBug> <S2SV_StartBug> if ( ! authctxt -> valid ) { <S2SV_EndBug> <S2SV_StartBug> __func__ , ssh_err ( r ) ) ; <S2SV_EndBug> <S2SV_StartBug> free ( sig ) ; <S2SV_EndBug> <S2SV_StartBug> fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; <S2SV_EndBug> <S2SV_StartBug> return authenticated ; <S2SV_EndBug> ","<S2SV_ModStart> = NULL <S2SV_ModStart> = NULL <S2SV_ModStart> = NULL <S2SV_ModStart> = NULL <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; } if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; goto done <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; goto done ; } <S2SV_ModStart> free ( sig ) ; ",openbsd@src/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0,CVE-2018-15473,https://github.com/openbsd/src/commit/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0,2018-08-17T19:29Z
1211,CWE-908,<S2SV_StartBug> uint32_t bcount ; <S2SV_EndBug> ,<S2SV_ModStart> ; CLEAR ( WaveHeader ) ,dbry@WavPack/33a0025d1d63ccd05d9dbaa6923d52b1446a62fe,CVE-2019-1010319,https://github.com/dbry/WavPack/commit/33a0025d1d63ccd05d9dbaa6923d52b1446a62fe,2019-07-11T20:15Z
1212,CWE-362,<S2SV_StartBug> get_block = ocfs2_get_block ; <S2SV_EndBug> <S2SV_StartBug> get_block = ocfs2_dio_get_block ; <S2SV_EndBug> ,<S2SV_ModStart> ocfs2_lock_get_block <S2SV_ModEnd> <S2SV_ModStart> ocfs2_dio_wr_get_block <S2SV_ModEnd> ,torvalds@linux/3e4c56d41eef5595035872a2ec5a483f42e8917f,CVE-2017-18224,https://github.com/torvalds/linux/commit/3e4c56d41eef5595035872a2ec5a483f42e8917f,2018-03-12T03:29Z
1213,CWE-287,"<S2SV_StartBug> if ( ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) ) { <S2SV_EndBug> ","<S2SV_ModStart> || ( ctx -> cb ) ( sx_sasl_cb_CHECK_MECH , ( void * ) mech , NULL , s , ctx -> cbarg ) != sx_sasl_ret_OK ",jabberd2@jabberd2/8416ae54ecefa670534f27a31db71d048b9c7f16,CVE-2017-10807,https://github.com/jabberd2/jabberd2/commit/8416ae54ecefa670534f27a31db71d048b9c7f16,2017-07-04T15:29Z
1214,CWE-119,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> return - EACCES ; ,torvalds@linux/ea25f914dc164c8d56b36147ecc86bc65f83c469,CVE-2017-17857,https://github.com/torvalds/linux/commit/ea25f914dc164c8d56b36147ecc86bc65f83c469,2017-12-27T17:08Z
1215,CWE-416,"<S2SV_StartBug> if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { <S2SV_EndBug> ","<S2SV_ModStart> memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteFujiEntry ) ) ; ",libexif@libexif/ec412aa4583ad71ecabb967d3c77162760169d1f,CVE-2020-13113,https://github.com/libexif/libexif/commit/ec412aa4583ad71ecabb967d3c77162760169d1f,2020-05-21T17:15Z
1216,CWE-19,<S2SV_StartBug> sb -> s_op = & ext2_sops ; <S2SV_EndBug> <S2SV_StartBug> percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ; <S2SV_EndBug> ,"<S2SV_ModStart> # ifdef CONFIG_EXT2_FS_XATTR sbi -> s_mb_cache = ext2_xattr_create_cache ( ) ; if ( ! sbi -> s_mb_cache ) { ext2_msg ( sb , KERN_ERR , ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>an<S2SV_blank>mb_cache"" ) ; goto failed_mount3 ; } # endif <S2SV_ModStart> if ( sbi -> s_mb_cache ) ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ; ",torvalds@linux/be0726d33cb8f411945884664924bed3cb8c70ee,CVE-2015-8952,https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee,2016-10-16T21:59Z
1217,CWE-20,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( is_restricted_mode ( ) && ! btif_storage_is_restricted_device ( bd_addr ) ) return BT_STATUS_SUCCESS ; ,system@bt/37c88107679d36c419572732b4af6e18bb2f7dce,CVE-2016-3760,https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce,2016-07-11T02:00Z
1218,CWE-416,<S2SV_StartBug> if ( len < tcp_hdrlen ) <S2SV_EndBug> <S2SV_StartBug> if ( skb_tailroom ( skb ) < TCPOLEN_MSS ) { <S2SV_EndBug> ,<S2SV_ModStart> || tcp_hdrlen < sizeof ( struct tcphdr ) <S2SV_ModStart> tcp_hdrlen >= 15 * 4 ) return 0 ; if ( ,torvalds@linux/2638fd0f92d4397884fd991d8f4925cb3f081901,CVE-2017-18017,https://github.com/torvalds/linux/commit/2638fd0f92d4397884fd991d8f4925cb3f081901,2018-01-03T06:29Z
1219,CWE-190,<S2SV_StartBug> if ( numrows < 0 || numcols < 0 ) { <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> matrix -> datasize_ = numrows * numcols ; <S2SV_EndBug> <S2SV_StartBug> jas_matrix_destroy ( matrix ) ; <S2SV_EndBug> <S2SV_StartBug> jas_matrix_destroy ( matrix ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> size_t size ; matrix = 0 ; <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> 0 ; if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) { goto error ; } matrix -> datasize_ = size <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> error : if ( matrix ) { jas_matrix_destroy ( matrix ) ; } return 0 ; ",mdadams@jasper/988f8365f7d8ad8073b6786e433d34c553ecf568,CVE-2016-10249,https://github.com/mdadams/jasper/commit/988f8365f7d8ad8073b6786e433d34c553ecf568,2017-03-15T14:59Z
1220,CWE-000,<S2SV_StartBug> ipv6_select_ident ( fh ) ; <S2SV_EndBug> <S2SV_StartBug> ipv6_select_ident ( fh ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , rt <S2SV_ModStart> , rt ",torvalds@linux/87c48fa3b4630905f98268dde838ee43626a060c,CVE-2011-2699,https://github.com/torvalds/linux/commit/87c48fa3b4630905f98268dde838ee43626a060c,2012-05-24T23:55Z
1221,CWE-19,"<S2SV_StartBug> ext4_xattr_cache_insert ( struct mb_cache * ext4_mb_cache , struct buffer_head * bh ) <S2SV_EndBug> <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ; <S2SV_EndBug> <S2SV_StartBug> error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_free ( ce ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error == - EBUSY ) { <S2SV_EndBug> <S2SV_StartBug> error = 0 ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> ","<S2SV_ModStart> mb2_cache <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> error = mb2_cache_entry_create <S2SV_ModEnd> <S2SV_ModStart> , hash , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/82939d7999dfc1f1998c4b1c12e2f19edbdff272,CVE-2015-8952,https://github.com/torvalds/linux/commit/82939d7999dfc1f1998c4b1c12e2f19edbdff272,2016-10-16T21:59Z
1222,CWE-119,"<S2SV_StartBug> SCSIDiskReq * r ; <S2SV_EndBug> <S2SV_StartBug> r = DO_UPCAST ( SCSIDiskReq , req , req ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,bonzini@qemu/7285477ab11831b1cf56e45878a89170dd06d9b9,CVE-2011-3346,https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9,2014-04-01T06:35Z
1223,CWE-189,<S2SV_StartBug> int avail ; <S2SV_EndBug> <S2SV_StartBug> avail = buf -> len - buf -> cursor ; <S2SV_EndBug> <S2SV_StartBug> if ( nxip < 0 || nxip > avail || expect > avail ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> TXID_SNAPSHOT_MAX_NXIP <S2SV_ModEnd> ,postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z
1224,CWE-119,<S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> . ptr [ <S2SV_ModEnd> <S2SV_ModStart> . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z
1225,CWE-399,<S2SV_StartBug> if ( ret || cm_id -> device -> node_type != RDMA_NODE_IB_CA ) <S2SV_EndBug> ,<S2SV_ModStart> ! cm_id -> device || ,torvalds@linux/c2349758acf1874e4c2b93fe41d072336f1a31d0,CVE-2013-7339,https://github.com/torvalds/linux/commit/c2349758acf1874e4c2b93fe41d072336f1a31d0,2014-03-24T16:40Z
1226,CWE-416,<S2SV_StartBug> struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> struct xfrm_dump_info info ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cb -> args [ 0 ] ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/1137b5e2529a8f5ca8ee709288ecba3e68044df2,CVE-2017-16939,https://github.com/torvalds/linux/commit/1137b5e2529a8f5ca8ee709288ecba3e68044df2,2017-11-24T10:29Z
1227,CWE-552,"<S2SV_StartBug> epoll_t * epoll = _cast_epoll ( epoll_ ) ; <S2SV_EndBug> <S2SV_StartBug> if ( oe_syscall_write_ocall ( & ret , epoll -> host_fd , buf , count ) != OE_OK ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ",<S2SV_ModStart> file <S2SV_ModEnd> <S2SV_ModStart> ! file || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( <S2SV_ModStart> file <S2SV_ModEnd> <S2SV_ModStart> if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } ,openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z
1228,CWE-20,<S2SV_StartBug> struct dentry * upper = ovl_dentry_upper ( dentry ) ; <S2SV_EndBug> <S2SV_StartBug> err = - ESTALE ; <S2SV_EndBug> <S2SV_StartBug> if ( upper -> d_parent == upperdir ) { <S2SV_EndBug> <S2SV_StartBug> dput ( upper ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> inode_unlock ( dir ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> upper = lookup_one_len ( dentry -> d_name . name , upperdir , dentry -> d_name . len ) ; err = PTR_ERR ( upper ) ; if ( IS_ERR ( upper ) ) goto out_unlock ; <S2SV_ModStart> == ovl_dentry_upper ( dentry ) ) { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dput ( upper ) ; <S2SV_ModStart> out_unlock : ",torvalds@linux/11f3710417d026ea2f4fcf362d866342c5274185,CVE-2016-6197,https://github.com/torvalds/linux/commit/11f3710417d026ea2f4fcf362d866342c5274185,2016-08-06T20:59Z
1229,CWE-295,"<S2SV_StartBug> errstr = parse_global_option ( CMD_INITIALIZE , NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * section_ptr == & new_service_options ) <S2SV_EndBug> ","<S2SV_ModStart> & new_global_options , <S2SV_ModStart>  <S2SV_ModEnd> ",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z
1230,CWE-000,<S2SV_StartBug> if ( ! * ptrptr && ! ( nmemb && size ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,FFmpeg@FFmpeg/c94f9e854228e0ea00e1de8769d8d3f7cab84a55,CVE-2013-4265,https://github.com/FFmpeg/FFmpeg/commit/c94f9e854228e0ea00e1de8769d8d3f7cab84a55,2013-11-23T17:55Z
1231,CWE-125,<S2SV_StartBug> if ( a -> name == MAPI_BODY_HTML ) <S2SV_EndBug> <S2SV_StartBug> else if ( a -> name == MAPI_RTF_COMPRESSED ) <S2SV_EndBug> ,<S2SV_ModStart> type == szMAPI_BINARY && a -> <S2SV_ModStart> a -> type == szMAPI_BINARY && ,verdammelt@tnef/8dccf79857ceeb7a6d3e42c1e762e7b865d5344d,CVE-2017-6310,https://github.com/verdammelt/tnef/commit/8dccf79857ceeb7a6d3e42c1e762e7b865d5344d,2017-02-24T04:59Z
1232,CWE-787,"<S2SV_StartBug> WritePixel ( i , & context , casspecial ) ; npix -- ; <S2SV_EndBug> <S2SV_StartBug> WritePixels ( i , & context , stackp , stack_top - stackp ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( npix > 0 ) <S2SV_ModStart> if ( npix >= ( <S2SV_ModEnd> <S2SV_ModStart> ) { WritePixels ( i , & context , stackp , stack_top - stackp ) ; } else if ( npix > 0 ) { WritePixels ( i , & context , stackp , npix ) ; } <S2SV_ModEnd> ",miniupnp@ngiflib/cf429e0a2fe26b5f01ce0c8e9b79432e94509b6e,CVE-2018-10717,https://github.com/miniupnp/ngiflib/commit/cf429e0a2fe26b5f01ce0c8e9b79432e94509b6e,2018-05-03T17:29Z
1233,CWE-399,<S2SV_StartBug> default : <S2SV_EndBug> ,<S2SV_ModStart> case MAGIC_PARAM_ELF_NOTES_MAX : * ( size_t * ) val = ms -> elf_notes_max ; return 0 ; ,file@file/ce90e05774dd77d86cfc8dfa6da57b32816841c4,CVE-2014-9620,https://github.com/file/file/commit/ce90e05774dd77d86cfc8dfa6da57b32816841c4,2015-01-21T18:59Z
1234,CWE-476,"<S2SV_StartBug> jas_eprintf ( ""box<S2SV_blank>type<S2SV_blank>%s\\n"" , box -> info -> name ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""got<S2SV_blank>box<S2SV_blank>type<S2SV_blank>%s\\n"" <S2SV_ModEnd> ",mdadams@jasper/e24bdc716c3327b067c551bc6cfb97fd2370358d,CVE-2016-8887,https://github.com/mdadams/jasper/commit/e24bdc716c3327b067c551bc6cfb97fd2370358d,2017-03-23T18:59Z
1235,CWE-732,"
","
",Monetra@mstdlib/db124b8f607dd0a40a9aef2d4d468fad433522a7,CVE-2018-14043,https://github.com/Monetra/mstdlib/commit/db124b8f607dd0a40a9aef2d4d468fad433522a7,2018-07-13T14:29Z
1236,CWE-189,"<S2SV_StartBug> err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf , p + 4 , c , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> + p <S2SV_ModEnd> ,torvalds@linux/b769f49463711205d57286e64cf535ed4daf59e9,CVE-2011-1476,https://github.com/torvalds/linux/commit/b769f49463711205d57286e64cf535ed4daf59e9,2012-06-21T23:55Z
1237,CWE-000,<S2SV_StartBug> journal_t * journal = EXT4_JOURNAL ( page -> mapping -> host ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; if ( ext4_should_dioread_nolock ( page -> mapping -> host ) ) ext4_invalidatepage_free_endio ( page , offset ",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z
1238,CWE-476,"<S2SV_StartBug> trak = gf_isom_get_track ( movie -> moov , i + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> GF_SAFEALLOC ( writer , TrackWriter ) ; <S2SV_EndBug> ",<S2SV_ModStart> GF_SampleTableBox * stbl ; <S2SV_ModStart> stbl = ( trak -> Media && trak -> Media -> information ) ? trak -> Media -> information -> sampleTable : NULL ; if ( ! stbl || ! stbl -> SampleSize || ! stbl -> ChunkOffset || ! stbl -> SampleToChunk ) { return GF_ISOM_INVALID_FILE ; } ,gpac@gpac/dae9900580a8888969481cd72035408091edb11b,CVE-2020-35981,https://github.com/gpac/gpac/commit/dae9900580a8888969481cd72035408091edb11b,2021-04-21T16:15Z
1239,CWE-787,"<S2SV_StartBug> static UINT32 nsc_rle_encode ( BYTE * in , BYTE * out , UINT32 originalSize ) <S2SV_EndBug> ",<S2SV_ModStart> const ,FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z
1240,CWE-119,"<S2SV_StartBug> int plen ; <S2SV_EndBug> <S2SV_StartBug> md5data [ 0 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( md5data + 1 , password , 82 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( md5data + 1 + strlen ( password ) , pass_salt , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> md5_append ( & state , ( const md5_byte_t * ) md5data , strlen ( password ) + 17 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , act_pass_len <S2SV_ModStart> act_pass_len = strnlen ( password , 82 ) ; <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> act_pass_len ) <S2SV_ModEnd> <S2SV_ModStart> act_pass_len <S2SV_ModEnd> <S2SV_ModStart> 1 + act_pass_len + 16 <S2SV_ModEnd> ",haakonnessjoen@MAC-Telnet/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a,CVE-2016-7115,https://github.com/haakonnessjoen/MAC-Telnet/commit/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a,2016-08-30T17:59Z
1241,CWE-000,<S2SV_StartBug> void * dllhandle ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( COM_CompareExtension ( name , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , name ) ; return NULL ; } ",JACoders@OpenJK/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,CVE-2017-6903,https://github.com/JACoders/OpenJK/commit/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,2017-03-14T22:59Z
1242,CWE-59,<S2SV_StartBug> if ( _mibindexes ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,net-snmp@net-snmp/4fd9a450444a434a993bc72f7c3486ccce41f602,CVE-2020-15861,https://github.com/net-snmp/net-snmp/commit/4fd9a450444a434a993bc72f7c3486ccce41f602,2020-08-20T01:17Z
1243,CWE-401,"<S2SV_StartBug> # define PCDGetBits ( n ) { sum = ( sum << n ) & 0xffffffff ; bits -= n ; while ( bits <= 24 ) { if ( p >= ( buffer + 0x800 ) ) { count = ReadBlob ( image , 0x800 , buffer ) ; p = buffer ; } sum |= ( ( unsigned int ) ( * p ) << ( 24 - bits ) ) ; bits += 8 ; p ++ ; } } <S2SV_EndBug> <S2SV_StartBug> ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , <S2SV_EndBug> <S2SV_StartBug> buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> for ( j = 0 ; j < i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ; <S2SV_ModStart> ) ; for ( j = 0 ; j <= i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ,ImageMagick@ImageMagick/1e6a3ace073c9ec9c71e439c111d23c6e66cb6ae,CVE-2019-7175,https://github.com/ImageMagick/ImageMagick/commit/1e6a3ace073c9ec9c71e439c111d23c6e66cb6ae,2019-03-07T23:29Z
1244,CWE-125,"<S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> ",<S2SV_ModStart> i < NCH ( n ) && ,python@typed_ast/dc317ac9cff859aa84eeabe03fb5004982545b3b,CVE-2019-19275,https://github.com/python/typed_ast/commit/dc317ac9cff859aa84eeabe03fb5004982545b3b,2019-11-26T15:15Z
1245,CWE-20,<S2SV_StartBug> g_hash_table_destroy ( headers ) ; <S2SV_EndBug> ,"<S2SV_ModStart> g_hash_table_remove_all ( headers ) ; g_hash_table_insert ( headers , g_strdup ( ""Cookie"" ) , g_strdup ( ""cockpit=d"" ) ) ; if ( cockpit_auth_check_cookie ( test -> auth , ""/cockpit"" , headers ) ) g_assert_not_reached ( ) ; ",cockpit-project@cockpit/c51f6177576d7e12614c64d316cf0b67addd17c9,CVE-2019-3804,https://github.com/cockpit-project/cockpit/commit/c51f6177576d7e12614c64d316cf0b67addd17c9,2019-03-26T18:29Z
1246,CWE-918,"<S2SV_StartBug> char * p ; <S2SV_EndBug> <S2SV_StartBug> p = memchr ( str + 1 , ']' , str_len - 2 ) ; <S2SV_EndBug> <S2SV_StartBug> * portno = atoi ( p + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> * portno = atoi ( colon + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> return host ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> char * <S2SV_ModStart> , * e = NULL <S2SV_ModStart> strtol <S2SV_ModEnd> <S2SV_ModStart> , & e , 10 ) ; if ( e && * e ) { if ( get_err ) { * err = strpprintf ( 0 , ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>address<S2SV_blank>\\""%s\\"""" , str ) ; } return NULL ; } <S2SV_ModEnd> <S2SV_ModStart> char * e = NULL ; <S2SV_ModStart> strtol ( colon + 1 , & e , 10 ) ; if ( ! e || ! * e ) { return <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",php@php-src/bab0b99f376dac9170ac81382a5ed526938d595a,CVE-2017-7272,https://github.com/php/php-src/commit/bab0b99f376dac9170ac81382a5ed526938d595a,2017-03-27T17:59Z
1247,CWE-000,"<S2SV_StartBug> i , ( unsigned ) JPC_QCX_GETEXPN ( qcd -> compparms . stepsizes [ i ] ) , <S2SV_EndBug> <S2SV_StartBug> i , ( unsigned ) JPC_QCX_GETMANT ( qcd -> compparms . stepsizes [ i ] ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> JAS_CAST ( unsigned , <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> JAS_CAST ( unsigned , <S2SV_ModEnd> <S2SV_ModStart> ) ",mdadams@jasper/1e84674d95353c64e5c4c0e7232ae86fd6ea813b,CVE-2016-9391,https://github.com/mdadams/jasper/commit/1e84674d95353c64e5c4c0e7232ae86fd6ea813b,2017-03-23T18:59Z
1248,CWE-119,"<S2SV_StartBug> for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst , src , src_ybc -> y_width ) ; <S2SV_EndBug> ","<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( src_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) { const uint16_t * src16 = CONVERT_TO_SHORTPTR ( src ) ; uint16_t * dst16 = CONVERT_TO_SHORTPTR ( dst ) ; <S2SV_ModStart> memcpy ( dst16 , src16 , src_ybc -> y_width * sizeof ( uint16_t ) ) ; src16 += src_ybc -> y_stride ; dst16 += dst_ybc -> y_stride ; } return ; } # endif for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) { memcpy <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1249,CWE-119,<S2SV_StartBug> c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , ""cblk<S2SV_blank>size<S2SV_blank>><S2SV_blank>64"" ) ; return AVERROR_PATCHWELCOME ; } ",FFmpeg@FFmpeg/9a271a9368eaabf99e6c2046103acb33957e63b7,CVE-2013-7018,https://github.com/FFmpeg/FFmpeg/commit/9a271a9368eaabf99e6c2046103acb33957e63b7,2013-12-09T16:36Z
1250,CWE-119,<S2SV_StartBug> if ( '%' == * ptr ) { <S2SV_EndBug> ,<S2SV_ModStart> && ptr [ 1 ] ,curl@curl/1890d59905414ab84a35892b2e45833654aa5c13,CVE-2017-7407,https://github.com/curl/curl/commit/1890d59905414ab84a35892b2e45833654aa5c13,2017-04-03T20:59Z
1251,CWE-119,"<S2SV_StartBug> static void encode_rd_sb_row ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( mi_col = tile -> mi_col_start ; mi_col < tile -> mi_col_end ; <S2SV_EndBug> <S2SV_StartBug> int dummy_rate ; <S2SV_EndBug> <S2SV_StartBug> BLOCK_SIZE i ; <S2SV_EndBug> <S2SV_StartBug> for ( i = BLOCK_4X4 ; i < BLOCK_8X8 ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( sf -> partition_search_type == SEARCH_PARTITION && <S2SV_EndBug> <S2SV_StartBug> sf -> partition_search_type == VAR_BASED_PARTITION || <S2SV_EndBug> <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; <S2SV_EndBug> <S2SV_StartBug> & dummy_rate , & dummy_dist , 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , TileDataEnc * tile_data , int mi_row , TOKENEXTRA * * tp ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_ModEnd> <S2SV_ModStart> tile_info = & tile_data -> tile_info ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; SPEED_FEATURES * const sf = & cpi -> sf ; int mi_col ; memset ( & xd -> left_context , 0 , sizeof ( <S2SV_ModEnd> <S2SV_ModStart> ) ) ; memset ( xd -> left_seg_context <S2SV_ModStart> left_seg_context <S2SV_ModEnd> <S2SV_ModStart> tile_info <S2SV_ModEnd> <S2SV_ModStart> tile_info <S2SV_ModEnd> <S2SV_ModStart> const struct segmentation * const seg = & cm -> seg ; <S2SV_ModStart> RD_COST dummy_rdc ; int i ; int seg_skip = 0 ; const int idx_str = cm -> mi_stride * mi_row + mi_col ; MODE_INFO * * mi = cm -> mi_grid_visible + idx_str <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> 64 <S2SV_ModEnd> <S2SV_ModStart> td -> leaf_tree [ i ] . pred_interp_filter = SWITCHABLE ; for ( i = 0 ; i < 64 ; ++ i ) { td -> pc_tree [ i ] . vertical [ 0 ] . pred_interp_filter = SWITCHABLE ; td -> pc_tree [ i ] . vertical [ 1 ] . pred_interp_filter = SWITCHABLE ; td -> pc_tree [ i ] . horizontal [ 0 ] . pred_interp_filter = SWITCHABLE ; td -> pc_tree [ i ] . horizontal [ 1 ] . pred_interp_filter = SWITCHABLE ; } } vp9_zero ( x -> pred_mv ) ; td -> pc_root -> index = 0 ; if ( seg -> enabled ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; int segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ; seg_skip = segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ; } x -> source_variance = UINT_MAX <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> seg_skip ) { const BLOCK_SIZE bsize = seg_skip ? BLOCK_64X64 : sf -> always_this_block_size ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; set_fixed_partitioning ( cpi , tile_info , mi , mi_row , mi_col , bsize ) ; rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; } else if ( cpi -> partition_search_skippable_frame ) { BLOCK_SIZE bsize ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; bsize = get_rd_var_based_fixed_partition ( cpi , x , mi_row , mi_col ) ; set_fixed_partitioning ( cpi , tile_info , mi , mi_row , mi_col , bsize ) ; rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; } else if ( <S2SV_ModStart> && cm -> frame_type != KEY_FRAME ) { choose_partitioning ( cpi , tile_info , x , mi_row , mi_col ) ; rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; } else { if ( sf -> auto_min_max_partition_size <S2SV_ModEnd> <S2SV_ModStart> tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; rd_auto_partition_range ( cpi , tile_info , xd , mi_row , mi_col , & x -> min_partition_size , & x -> max_partition_size ) ; } rd_pick_partition ( cpi , td , tile_data <S2SV_ModEnd> <S2SV_ModStart> dummy_rdc , INT64_MAX , td -> pc_root <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1252,CWE-125,"<S2SV_StartBug> int hexdump ; <S2SV_EndBug> <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) <S2SV_EndBug> ","<S2SV_ModStart> , ret <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE ",the-tcpdump-group@tcpdump/d97e94223720684c6aa740ff219e0d19426c2220,CVE-2018-14464,https://github.com/the-tcpdump-group/tcpdump/commit/d97e94223720684c6aa740ff219e0d19426c2220,2019-10-03T16:15Z
1253,CWE-119,"<S2SV_StartBug> static void inc_mvs ( const MB_MODE_INFO * mbmi , const int_mv mvs [ 2 ] , <S2SV_EndBug> <S2SV_StartBug> const MV * ref = & mbmi -> ref_mvs [ mbmi -> ref_frame [ i ] ] [ 0 ] . as_mv ; <S2SV_EndBug> ","<S2SV_ModStart> const MB_MODE_INFO_EXT * mbmi_ext , <S2SV_ModStart> mbmi_ext <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1254,CWE-119,"<S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) ) <S2SV_EndBug> <S2SV_StartBug> encode_frame ( & codec , NULL , - 1 , writer ) ; <S2SV_EndBug> ",<S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> while ( <S2SV_ModStart> ) { } <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1255,CWE-399,"<S2SV_StartBug> if ( pskb_expand_head ( skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> skb_out <S2SV_ModEnd> ,torvalds@linux/5b6698b0e4a37053de35cc24ee695b98a7eb712b,CVE-2014-9428,https://github.com/torvalds/linux/commit/5b6698b0e4a37053de35cc24ee695b98a7eb712b,2015-01-02T21:59Z
1256,CWE-362,<S2SV_StartBug> spin_lock_init ( & sta -> lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; spin_lock_init ( & sta -> ps_lock ,torvalds@linux/1d147bfa64293b2723c4fec50922168658e613ba,CVE-2014-2706,https://github.com/torvalds/linux/commit/1d147bfa64293b2723c4fec50922168658e613ba,2014-04-14T23:55Z
1257,CWE-264,<S2SV_StartBug> perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) ) <S2SV_EndBug> ,<S2SV_ModStart> perf_paranoid_tracepoint_raw <S2SV_ModEnd> ,torvalds@linux/12ae030d54ef250706da5642fc7697cc60ad0df7,CVE-2013-2930,https://github.com/torvalds/linux/commit/12ae030d54ef250706da5642fc7697cc60ad0df7,2013-12-09T18:55Z
1258,CWE-119,<S2SV_StartBug> unregister_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> <S2SV_StartBug> sctp_v4_protosw_exit ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> sctp_ctrlsock_ops <S2SV_ModEnd> <S2SV_ModStart> ) ; unregister_pernet_subsys ( & sctp_defaults_ops ,torvalds@linux/8e2d61e0aed2b7c4ecb35844fe07e0b2b762dee4,CVE-2015-5283,https://github.com/torvalds/linux/commit/8e2d61e0aed2b7c4ecb35844fe07e0b2b762dee4,2015-10-19T10:59Z
1259,CWE-000,"<S2SV_StartBug> control_interface = usb_ifnum_to_if ( usb_dev , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( ! data_interface || ! control_interface ) return - ENODEV ,torvalds@linux/8835ba4a39cf53f705417b3b3a94eb067673f2c9,CVE-2016-3138,https://github.com/torvalds/linux/commit/8835ba4a39cf53f705417b3b3a94eb067673f2c9,2016-05-02T10:59Z
1260,CWE-399,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
1261,CWE-59,"<S2SV_StartBug> netsnmp_mibindex_load ( ) ; <S2SV_EndBug> <S2SV_StartBug> add_mibfile ( entry , NULL , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,net-snmp@net-snmp/4fd9a450444a434a993bc72f7c3486ccce41f602,CVE-2020-15861,https://github.com/net-snmp/net-snmp/commit/4fd9a450444a434a993bc72f7c3486ccce41f602,2020-08-20T01:17Z
1262,CWE-362,<S2SV_StartBug> struct list_head tmplist ; <S2SV_EndBug> <S2SV_StartBug> if ( oldsp -> do_auto_asconf ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sctp_copy_descendant <S2SV_ModEnd> ,torvalds@linux/2d45a02d0166caf2627fe91897c6ffc3b19514c4,CVE-2015-3212,https://github.com/torvalds/linux/commit/2d45a02d0166caf2627fe91897c6ffc3b19514c4,2015-08-31T10:59Z
1263,CWE-284,"<S2SV_StartBug> fd = open ( uinput_dev_path [ x ] , O_RDWR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( write ( fd , & dev , sizeof ( dev ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> ioctl ( fd , UI_SET_EVBIT , EV_KEY ) ; <S2SV_EndBug> <S2SV_StartBug> ioctl ( fd , UI_SET_EVBIT , EV_REL ) ; <S2SV_EndBug> <S2SV_StartBug> ioctl ( fd , UI_SET_EVBIT , EV_SYN ) ; <S2SV_EndBug> <S2SV_StartBug> ioctl ( fd , UI_SET_KEYBIT , key_map [ x ] . mapped_id ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ioctl ( fd , UI_DEV_CREATE , NULL ) < 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ; TEMP_FAILURE_RETRY ( <S2SV_ModEnd> <S2SV_ModStart> ) ; TEMP_FAILURE_RETRY ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ; if ( TEMP_FAILURE_RETRY <S2SV_ModEnd> <S2SV_ModStart> ) ,system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
1264,CWE-362,<S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ( desc -> type & BIT ( 3 ) ) ) <S2SV_EndBug> <S2SV_StartBug> switch ( ( desc -> l << 1 ) | desc -> d ) { <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_desc ( & desc , sel ) <S2SV_ModEnd> <S2SV_ModStart> . <S2SV_ModEnd> <S2SV_ModStart> . <S2SV_ModEnd> <S2SV_ModStart> . <S2SV_ModEnd> ",torvalds@linux/de9f869616dd95e95c00bdd6b0fcd3421e8a4323,CVE-2019-13233,https://github.com/torvalds/linux/commit/de9f869616dd95e95c00bdd6b0fcd3421e8a4323,2019-07-04T13:15Z
1265,CWE-119,<S2SV_StartBug> vp9_free_frame_buffer ( & ctx -> buf [ i ] . img ) ; <S2SV_EndBug> ,<S2SV_ModStart> vpx_free_frame_buffer <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1266,CWE-119,"<S2SV_StartBug> vp9_lpf_vertical_16 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_lpf_vertical_16 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_8 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } if ( mask_4x4_int & 1 ) vpx_lpf_vertical_4 <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1267,CWE-399,<S2SV_StartBug> atomic_dec ( & user -> inotify_devs ) ; <S2SV_EndBug> ,<S2SV_ModStart> fsnotify_put_group ( group ) ; ,torvalds@linux/a2ae4cc9a16e211c8a128ba10d22a85431f093ab,CVE-2010-4250,https://github.com/torvalds/linux/commit/a2ae4cc9a16e211c8a128ba10d22a85431f093ab,2012-06-21T23:55Z
1268,CWE-18,<S2SV_StartBug> iakerb_alloc_context ( iakerb_ctx_id_t * pctx ) <S2SV_EndBug> <S2SV_StartBug> code = krb5_gss_init_context ( & ctx -> k5c ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , int initiate <S2SV_ModStart> ctx -> initiate = initiate ; ctx -> established = 0 ; ",krb5@krb5/e04f0283516e80d2f93366e0d479d13c9b5c8c2a,CVE-2015-2696,https://github.com/krb5/krb5/commit/e04f0283516e80d2f93366e0d479d13c9b5c8c2a,2015-11-09T03:59Z
1269,CWE-190,<S2SV_StartBug> dst_known = tnum_is_const ( dst_reg -> var_off ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } ,torvalds@linux/bb7f0f989ca7de1153bd128a40a71709e339fa03,CVE-2017-17854,https://github.com/torvalds/linux/commit/bb7f0f989ca7de1153bd128a40a71709e339fa03,2017-12-27T17:08Z
1270,CWE-772,"<S2SV_StartBug> status = SetImageExtent ( screen , screen -> columns , screen -> rows ) ; <S2SV_EndBug> <S2SV_StartBug> if ( image == ( Image * ) NULL ) <S2SV_EndBug> ","<S2SV_ModStart> if ( image == ( Image * ) NULL ) image = screen ; else AppendImageToList ( & image , screen ) ; <S2SV_ModStart>  <S2SV_ModEnd> ",ImageMagick@ImageMagick/8c10b9247509c0484b55330458846115131ec2ae,CVE-2017-11447,https://github.com/ImageMagick/ImageMagick/commit/8c10b9247509c0484b55330458846115131ec2ae,2017-07-19T07:29Z
1271,CWE-254,"<S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) <S2SV_EndBug> ",<S2SV_ModStart> ( <S2SV_ModStart> ) && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) ,external@libmpeg2/ffab15eb80630dc799eb410855c93525b75233c3,CVE-2016-0824,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,2016-03-12T21:59Z
1272,CWE-401,<S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> ,<S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto out ; } ,torvalds@linux/c0a333d842ef67ac04adc72ff79dc1ccc3dca4ed,CVE-2019-18812,https://github.com/torvalds/linux/commit/c0a333d842ef67ac04adc72ff79dc1ccc3dca4ed,2019-11-07T16:15Z
1273,CWE-20,"<S2SV_StartBug> return mono_method_get_object ( mono_object_domain ( rmethod ) , inflated , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! mono_verifier_is_method_valid_generic_instantiation ( inflated ) ) mono_raise_exception ( mono_get_exception_argument ( ""typeArguments"" , ""Invalid<S2SV_blank>generic<S2SV_blank>arguments"" ) ) ; ",mono@mono/cf1ec146f7c6acdc6697032b3aaafc68ffacdcac,CVE-2010-4254,https://github.com/mono/mono/commit/cf1ec146f7c6acdc6697032b3aaafc68ffacdcac,2010-12-06T13:44Z
1274,CWE-119,"<S2SV_StartBug> int tmp ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( buf , buffer , count ) ) <S2SV_EndBug> ","<S2SV_ModStart> size_t size ; int tmp ; size = min ( count , sizeof ( buf ) ) <S2SV_ModEnd> <S2SV_ModStart> size <S2SV_ModEnd> ",torvalds@linux/201f99f170df14ba52ea4c52847779042b7a623b,CVE-2013-4512,https://github.com/torvalds/linux/commit/201f99f170df14ba52ea4c52847779042b7a623b,2013-11-12T14:35Z
1275,CWE-835,"<S2SV_StartBug> ""Pushing<S2SV_blank>input<S2SV_blank>%d<S2SV_blank>:<S2SV_blank>%.30s\\n"" , ctxt -> inputNr + 1 , input -> cur ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; } if ( ( ( ctxt -> inputNr > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> inputNr > 1024 ) ) { xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ; while ( ctxt -> inputNr > 1 ) xmlFreeInputStream ( inputPop ( ctxt ) ) ; return ( - 1 ",GNOME@libxml2/899a5d9f0ed13b8e32449a08a361e0de127dd961,CVE-2017-16932,https://github.com/GNOME/libxml2/commit/899a5d9f0ed13b8e32449a08a361e0de127dd961,2017-11-23T21:29Z
1276,CWE-000,"<S2SV_StartBug> if ( sanity_check_area_boundary ( sbi , bh ) ) <S2SV_EndBug> ","<S2SV_ModStart> le32_to_cpu ( raw_super -> segment_count ) > F2FS_MAX_SEGMENT ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>segment<S2SV_blank>count<S2SV_blank>(%u)"" , le32_to_cpu ( raw_super -> segment_count ) ) ; return 1 ; } if ( ",torvalds@linux/b9dd46188edc2f0d1f37328637860bb65a771124,CVE-2017-10662,https://github.com/torvalds/linux/commit/b9dd46188edc2f0d1f37328637860bb65a771124,2017-08-19T18:29Z
1277,CWE-252,"<S2SV_StartBug> char * last_elem , * wp ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( ( strncmp ( & name [ 1 ] , ""ORIGIN"" , 6 ) == 0 && ( len = 7 ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> || ( strncmp ( & name [ 1 ] , ""PLATFORM"" , 8 ) == 0 && ( len = 9 ) != 0 ) ) <S2SV_EndBug> <S2SV_StartBug> ? ( __libc_enable_secure ? NULL : l -> l_origin ) <S2SV_EndBug> ","<S2SV_ModStart> const char * const start = name ; <S2SV_ModStart> ""ORIGIN}"" <S2SV_ModEnd> <S2SV_ModStart> ""PLATFORM}"" <S2SV_ModEnd> <S2SV_ModStart> && ( ( name [ len ] != '\\0' && ( ! is_path || name [ len ] != ':' ) ) || ( name != start && ( ! is_path || name [ - 1 ] != ':' ) ) ) ",bminor@glibc/2864e767053317538feafa815046fff89e5a16be,CVE-1999-0199,https://github.com/bminor/glibc/commit/2864e767053317538feafa815046fff89e5a16be,2020-10-06T13:15Z
1278,CWE-119,<S2SV_StartBug> pDecCont = ( decContainer_t * ) H264SwDecMalloc ( sizeof ( decContainer_t ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , 1 ",frameworks@av/2b6f22dc64d456471a1dc6df09d515771d1427c8,CVE-2016-2463,https://android.googlesource.com/platform/frameworks/av/+/2b6f22dc64d456471a1dc6df09d515771d1427c8,2016-06-13T01:59Z
1279,CWE-416,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> opt = np -> opt ; <S2SV_EndBug> <S2SV_StartBug> return err < 0 ? err : len ; <S2SV_EndBug> ,<S2SV_ModStart> struct ipv6_txoptions * opt_to_free = NULL ; <S2SV_ModStart> { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> <S2SV_ModStart> txopt_put ( opt_to_free ) ; ,torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
1280,CWE-399,<S2SV_StartBug> if ( iph -> ihl == 5 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/f8e9881c2aef1e982e5abc25c046820cd0b7cf64,CVE-2011-4087,https://github.com/torvalds/linux/commit/f8e9881c2aef1e982e5abc25c046820cd0b7cf64,2013-06-08T13:05Z
1281,CWE-285,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> ",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z
1282,CWE-476,"<S2SV_StartBug> err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , <S2SV_EndBug> <S2SV_StartBug> rcu_read_unlock ( ) ; <S2SV_EndBug> ","<S2SV_ModStart> { if ( ! res . fi ) { err = fib_props [ res . type ] . error ; if ( ! err ) err = - EHOSTUNREACH ; <S2SV_ModEnd> <S2SV_ModStart> } err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ; } else { err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ; } if ( err < 0 ) goto errout_free ; ",torvalds@linux/bc3aae2bbac46dd894c89db5d5e98f7f0ef9e205,CVE-2017-13686,https://github.com/torvalds/linux/commit/bc3aae2bbac46dd894c89db5d5e98f7f0ef9e205,2017-08-24T22:29Z
1283,CWE-119,"<S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> ","<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } ",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z
1284,CWE-200,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> int limit = ( info -> type == 2 ? vi -> channels : 1 ) * ci -> blocksizes [ 1 ] / 2 ; if ( info -> begin > info -> end || info -> end > limit ) { goto errout ; } ,external@tremolo/eeb4e45d5683f88488c083ecf142dc89bc3f0b47,CVE-2017-0814,https://android.googlesource.com/platform/external/tremolo/+/eeb4e45d5683f88488c083ecf142dc89bc3f0b47,2017-10-04T01:29Z
1285,CWE-400,"<S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , 0 ) ) <S2SV_EndBug> ","<S2SV_ModStart> js_doregexec ( J , <S2SV_ModEnd> ",ccxvii@mujs/00d4606c3baf813b7b1c176823b2729bf51002a2,CVE-2019-11413,https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2,2019-04-22T11:29Z
1286,CWE-119,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> tcp_rcv_space_adjust ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } tp -> copied_seq = seq ; ,torvalds@linux/baff42ab1494528907bf4d5870359e31711746ae,CVE-2013-2128,https://github.com/torvalds/linux/commit/baff42ab1494528907bf4d5870359e31711746ae,2013-06-07T14:03Z
1287,CWE-000,<S2SV_StartBug> krb5_key_data * key_data ; <S2SV_EndBug> <S2SV_StartBug> if ( key_data_in == NULL ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i <= num_versions ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( ret [ i ] != NULL ) <S2SV_EndBug> ,<S2SV_ModStart> = NULL ; if ( n_key_data < <S2SV_ModEnd> <S2SV_ModStart> key_data <S2SV_ModEnd> <S2SV_ModStart> ret [ i ] != NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,krb5@krb5/04038bf3633c4b909b5ded3072dc88c8c419bf16,CVE-2014-5354,https://github.com/krb5/krb5/commit/04038bf3633c4b909b5ded3072dc88c8c419bf16,2014-12-16T23:59Z
1288,CWE-190,"<S2SV_StartBug> _Unpickler_MemoPut ( UnpicklerObject * self , Py_ssize_t idx , PyObject * value ) <S2SV_EndBug> ",<S2SV_ModStart> size_t <S2SV_ModEnd> ,python@cpython/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,CVE-2018-20406,https://github.com/python/cpython/commit/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,2018-12-23T23:29Z
1289,CWE-190,<S2SV_StartBug> pCsr -> zInput = sqlite3_malloc ( nByte + 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart> sqlite3_malloc64 <S2SV_ModEnd> ,chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4,CVE-2019-5827,https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4,2019-06-27T17:15Z
1290,CWE-362,<S2SV_StartBug> sock_release ( SOCKET_I ( inode ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> __sock_release <S2SV_ModEnd> <S2SV_ModStart> , inode ",torvalds@linux/6d8c50dcb029872b298eea68cc6209c866fd3e14,CVE-2018-12232,https://github.com/torvalds/linux/commit/6d8c50dcb029872b298eea68cc6209c866fd3e14,2018-06-12T12:29Z
1291,CWE-125,"<S2SV_StartBug> AsyncFor ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , int <S2SV_EndBug> <S2SV_StartBug> p -> v . AsyncFor . orelse = orelse ; <S2SV_EndBug> ","<S2SV_ModStart> string type_comment , int <S2SV_ModEnd> <S2SV_ModStart> ; p -> v . AsyncFor . type_comment = type_comment ",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z
1292,CWE-362,"<S2SV_StartBug> int mi_sort_index ( MI_CHECK * param , register MI_INFO * info , char * name ) <S2SV_EndBug> <S2SV_StartBug> MYF ( 0 ) ) || <S2SV_EndBug> ","<S2SV_ModStart> , my_bool no_copy_stat <S2SV_ModStart> no_copy_stat ? MYF ( MY_REDEL_NO_COPY_STAT ) : ",MariaDB@server/4e5473862e6852b0f3802b0cd0c6fa10b5253291,CVE-2016-6663,https://github.com/MariaDB/server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291,2016-12-13T21:59Z
1293,CWE-264,"<S2SV_StartBug> opt = xchg ( & inet6_sk ( sk ) -> opt , opt ) ; <S2SV_EndBug> ",<S2SV_ModStart> ( __force struct ipv6_txoptions * * ) ,torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
1294,CWE-399,<S2SV_StartBug> case DB_VECTOR : <S2SV_EndBug> ,"<S2SV_ModStart> AC_VECTOR : kvm_queue_exception_e ( vcpu , AC_VECTOR , error_code ) ; return 1 ; case ",torvalds@linux/54a20552e1eae07aa240fa370a0293e006b5faed,CVE-2015-5307,https://github.com/torvalds/linux/commit/54a20552e1eae07aa240fa370a0293e006b5faed,2015-11-16T11:59Z
1295,CWE-400,<S2SV_StartBug> default : <S2SV_EndBug> ,"<S2SV_ModStart> case NGHTTP2_ERR_TOO_MANY_SETTINGS : return ""SETTINGS<S2SV_blank>frame<S2SV_blank>contained<S2SV_blank>more<S2SV_blank>than<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>entries"" ; ",nghttp2@nghttp2/336a98feb0d56b9ac54e12736b18785c27f75090,CVE-2020-11080,https://github.com/nghttp2/nghttp2/commit/336a98feb0d56b9ac54e12736b18785c27f75090,2020-06-03T23:15Z
1296,CWE-125,"<S2SV_StartBug> Stream_Read_UINT16 ( s , eventId ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( Stream_GetRemainingLength ( s ) < 6 ) return ERROR_INVALID_DATA ; ,FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z
1297,CWE-134,"<S2SV_StartBug> if ( - 1 == zsocket_bind ( pData -> socket , ( char * ) pData -> description ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( - 1 == zsocket_connect ( pData -> socket , ( char * ) pData -> description ) ) { <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , <S2SV_ModStart> ""%s"" , ",rsyslog@rsyslog/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b,CVE-2017-12588,https://github.com/rsyslog/rsyslog/commit/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b,2017-08-06T14:29Z
1298,CWE-399,"<S2SV_StartBug> return chg ; <S2SV_EndBug> <S2SV_StartBug> return - ENOSPC ; <S2SV_EndBug> <S2SV_StartBug> ret = hugetlb_acct_memory ( h , chg ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> { ret = chg ; goto out_err ; } <S2SV_ModEnd> <S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto out_err ; } <S2SV_ModStart> goto out_err <S2SV_ModEnd> <S2SV_ModStart> out_err : resv_map_put ( vma ) ; return ret ; ,torvalds@linux/c50ac050811d6485616a193eb0f37bfbd191cc89,CVE-2012-2390,https://github.com/torvalds/linux/commit/c50ac050811d6485616a193eb0f37bfbd191cc89,2012-06-13T10:24Z
1299,CWE-310,"<S2SV_StartBug> struct flowi6 fl6 ; <S2SV_EndBug> <S2SV_StartBug> skb -> len , & fl6 . saddr , & fl6 . daddr ) ; <S2SV_EndBug> <S2SV_StartBug> SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ; <S2SV_EndBug> <S2SV_StartBug> return ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> ","<S2SV_ModStart> * fl6 = & transport -> fl . u . ip6 ; <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> IP6_ECN_flow_xmit ( sk , fl6 -> flowlabel <S2SV_ModEnd> <S2SV_ModStart> SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ; <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/95ee62083cb6453e056562d91f597552021e6ae7,CVE-2013-4350,https://github.com/torvalds/linux/commit/95ee62083cb6453e056562d91f597552021e6ae7,2013-09-25T10:31Z
1300,CWE-264,"<S2SV_StartBug> inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ; <S2SV_EndBug> ","<S2SV_ModStart> s -> s_stack_depth = path . dentry -> d_sb -> s_stack_depth + 1 ; rc = - EINVAL ; if ( s -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( ""eCryptfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n"" ) ; goto out_free ; } ",torvalds@linux/69c433ed2ecd2d3264efd7afec4439524b319121,CVE-2014-9922,https://github.com/torvalds/linux/commit/69c433ed2ecd2d3264efd7afec4439524b319121,2017-04-04T05:59Z
1301,CWE-399,"<S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
1302,CWE-20,<S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; ",ImageMagick@ImageMagick/8a370f9ab120faf182aa160900ba692ba8e2bcf0,CVE-2016-10069,https://github.com/ImageMagick/ImageMagick/commit/8a370f9ab120faf182aa160900ba692ba8e2bcf0,2017-03-02T21:59Z
1303,CWE-125,"<S2SV_StartBug> void nego_process_negotiation_failure ( rdpNego * nego , wStream * s ) <S2SV_EndBug> <S2SV_StartBug> WLog_DBG ( TAG , ""RDP_NEG_FAILURE"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> ; if ( Stream_GetRemainingLength ( s ) < 7 ) return FALSE <S2SV_ModStart> return TRUE ; ,FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z
1304,CWE-255,"<S2SV_StartBug> int ret , last_pwd ; <S2SV_EndBug> <S2SV_StartBug> ret = decrypt_key_data ( handle -> context , <S2SV_EndBug> <S2SV_StartBug> kdb -> n_key_data , kdb -> key_data , <S2SV_EndBug> ","<S2SV_ModStart> , n_new_keys <S2SV_ModStart> n_new_keys = count_new_keys ( kdb -> n_key_data , kdb -> key_data ) ; <S2SV_ModStart> n_new_keys <S2SV_ModEnd> ",krb5@krb5/af0ed4df4dfae762ab5fb605f5a0c8f59cb4f6ca,CVE-2014-5351,https://github.com/krb5/krb5/commit/af0ed4df4dfae762ab5fb605f5a0c8f59cb4f6ca,2014-10-10T01:55Z
1305,CWE-120,"<S2SV_StartBug> int len , result = RLC_OK ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( ! bn_is_zero ( t ) ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> <S2SV_StartBug> if ( pad != RSA_PUB ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( ! bn_is_zero ( t ) ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> <S2SV_StartBug> if ( pad != RSA_PRV ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> <S2SV_StartBug> } while ( pad != 0 && m_len > 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( m_len == 0 ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> ","<S2SV_ModStart> RLC_ERR <S2SV_ModEnd> <S2SV_ModStart> result = RLC_OK ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> == <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> result = ( m_len > <S2SV_ModEnd> <S2SV_ModStart> } } break ; case RSA_SIG : id = hash_id ( MD_MAP , & len ) ; bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PRV ) ; * p_len = k_len - 3 - m_len - len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , 8 * len ) ; bn_read_bin ( t , id , len ) ; bn_add ( m , m , t ) ; bn_lsh ( m , m , m_len * 8 ) ; result = RLC_OK ; break ; case RSA_SIG_HASH : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PRV ) ; * p_len = k_len - 3 - m_len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , m_len * 8 ) ; result = RLC_OK ; break ; case RSA_VER : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ; if ( bn_is_zero ( t ) ) { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; if ( pad == RSA_PRV ) { int counter = 0 ; do { counter ++ ; m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; } while ( pad == RSA_PAD && m_len > 0 ) ; id = hash_id ( MD_MAP , & len ) ; m_len -= len ; bn_rsh ( t , m , m_len * 8 ) ; int r = 0 ; for ( int i = 0 ; i < len ; i ++ ) { pad = ( uint8_t ) t -> dp [ 0 ] ; r |= pad ^ id [ len - i - 1 ] ; bn_rsh ( t , t , 8 ) ; } * p_len = k_len - m_len ; bn_mod_2b ( m , m , m_len * 8 ) ; if ( r && m_len > 0 && counter >= 8 ) { result = RLC_OK ; } } } <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> == <S2SV_ModEnd> <S2SV_ModStart> int counter = 0 ; do { counter ++ ; <S2SV_ModEnd> <S2SV_ModStart> == RSA_PAD <S2SV_ModEnd> <S2SV_ModStart> * p_len = k_len - m_len ; bn_mod_2b ( m , m , m_len * 8 ) ; <S2SV_ModStart> > 0 && counter >= 8 <S2SV_ModEnd> <S2SV_ModStart> RLC_OK ; } } } <S2SV_ModEnd> ",relic-toolkit@relic/76c9a1fdf19d9e92e566a77376673e522aae9f80,CVE-2020-36316,https://github.com/relic-toolkit/relic/commit/76c9a1fdf19d9e92e566a77376673e522aae9f80,2021-04-07T21:15Z
1306,CWE-125,"<S2SV_StartBug> r2 . re -> flags | RE_FLAGS_SCAN , <S2SV_EndBug> ","<S2SV_ModStart> 0 , ",VirusTotal@yara/83d799804648c2a0895d40a19835d9b757c6fa4e,CVE-2017-8294,https://github.com/VirusTotal/yara/commit/83d799804648c2a0895d40a19835d9b757c6fa4e,2017-04-27T14:59Z
1307,CWE-119,"<S2SV_StartBug> static vpx_codec_err_t vp8_get_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1308,CWE-362,"<S2SV_StartBug> rq = blk_mq_tag_to_rq ( hctx -> tags , off + bit ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> -> rqs [ <S2SV_ModEnd> <S2SV_ModStart> ] <S2SV_ModEnd> ,torvalds@linux/0048b4837affd153897ed1222283492070027aa9,CVE-2015-9016,https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9,2018-04-05T18:29Z
1309,CWE-119,"<S2SV_StartBug> if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL ) <S2SV_EndBug> ",<S2SV_ModStart> psf_allocate ( <S2SV_ModEnd> ,erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z
1310,CWE-119,<S2SV_StartBug> static void fix_interp_filter ( VP9_COMMON * cm ) { <S2SV_EndBug> <S2SV_StartBug> count [ i ] += cm -> counts . switchable_interp [ j ] [ i ] ; <S2SV_EndBug> ,"<S2SV_ModStart> , FRAME_COUNTS * counts <S2SV_ModStart> counts -> <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1311,CWE-787,<S2SV_StartBug> token ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> ; } if ( operand >= MAX_OPERANDS ) { eprintf ( ""Too<S2SV_blank>many<S2SV_blank>operands\\n"" ) ; return false ",radare@radare2/df167c7db545953bb7f71c72e98e7a3ca0c793bf,CVE-2018-20460,https://github.com/radare/radare2/commit/df167c7db545953bb7f71c72e98e7a3ca0c793bf,2018-12-25T19:29Z
1312,CWE-119,"<S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> x -> act_zbin_adj = 0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_setup_src_planes ( x , cpi -> Source , 0 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> xd -> mi [ 0 ] -> mbmi . mode = DC_PRED ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> above_seg_context , 0 , <S2SV_EndBug> ",<S2SV_ModStart> td . <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1313,CWE-787,<S2SV_StartBug> dst_name = malloc ( strlen ( name ) * 2 + 16 ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> ,enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6,CVE-2019-14934,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,2019-08-11T22:15Z
1314,CWE-000,"<S2SV_StartBug> retval = htc_request_check_host_hdr ( hp ) ; <S2SV_EndBug> <S2SV_StartBug> WSP ( sp , SLT_Error , ""Duplicated<S2SV_blank>Host<S2SV_blank>header"" ) ; <S2SV_EndBug> <S2SV_StartBug> return ( retval ) ; <S2SV_EndBug> ",<S2SV_ModStart> htc_request_check_hdrs <S2SV_ModEnd> <S2SV_ModStart> hp <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,varnish@Varnish-Cache/29870c8fe95e4e8a672f6f28c5fbe692bea09e9c,CVE-2015-8852,https://github.com/varnish/Varnish-Cache/commit/29870c8fe95e4e8a672f6f28c5fbe692bea09e9c,2016-04-25T14:59Z
1315,CWE-20,"<S2SV_StartBug> char <S2SV_EndBug> <S2SV_StartBug> count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; <S2SV_EndBug> <S2SV_StartBug> image -> page . x = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> image -> page . y = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> one = 1 ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum ( <S2SV_EndBug> <S2SV_StartBug> ReadBlobLSBShort ( image ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> <S2SV_StartBug> do <S2SV_EndBug> <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> plane = ( unsigned char ) operand ; <S2SV_EndBug> <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> <S2SV_StartBug> } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) == <S2SV_EndBug> <S2SV_StartBug> if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length + <S2SV_EndBug> <S2SV_StartBug> if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == <S2SV_EndBug> <S2SV_StartBug> if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == <S2SV_EndBug> <S2SV_StartBug> if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == <S2SV_EndBug> ","<S2SV_ModStart> # define ThrowRLEException ( exception , message ) \\\n{ if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; \\\n} <S2SV_ModStart> colormap = ( unsigned char * ) NULL ; pixel_info = ( MemoryInfo * ) NULL ; <S2SV_ModStart> ( ssize_t ) <S2SV_ModStart> ( ssize_t ) <S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> ThrowRLEException ( <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> ThrowRLEException ( <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> { <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> { <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> { <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } offset = ( ssize_t ) ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> ( offset + <S2SV_ModEnd> <S2SV_ModStart> ( ssize_t ) <S2SV_ModStart> == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> { <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> ( ssize_t ) ( <S2SV_ModStart> ) <S2SV_ModStart> ( offset + <S2SV_ModEnd> <S2SV_ModStart> ( ssize_t ) <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> ( ssize_t ) ( <S2SV_ModStart> ) <S2SV_ModStart> ssize_t <S2SV_ModEnd> <S2SV_ModStart> ( ssize_t ) <S2SV_ModStart> ( ssize_t ) <S2SV_ModStart> ( ssize_t ) ",ImageMagick@ImageMagick/7fdf9ea808caa3c81a0eb42656e5fafc59084198,CVE-2017-9144,https://github.com/ImageMagick/ImageMagick/commit/7fdf9ea808caa3c81a0eb42656e5fafc59084198,2017-05-22T14:29Z
1316,CWE-362,<S2SV_StartBug> INIT_LIST_HEAD ( & card -> controls ) ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_init ( & card -> user_ctl_lock ) ; ,torvalds@linux/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92,CVE-2014-4652,https://github.com/torvalds/linux/commit/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92,2014-07-03T04:22Z
1317,CWE-347,<S2SV_StartBug> s += padlen + 3 ; <S2SV_EndBug> <S2SV_StartBug> ( * psig ) = s ; <S2SV_EndBug> ,"<S2SV_ModStart> ( * psig ) = s + <S2SV_ModEnd> <S2SV_ModStart> { const u_char * p ; size_t cnt_ffs = 0 ; for ( p = s + 2 ; p < s + padlen + 2 ; p ++ ) if ( * p == 0xFF ) cnt_ffs ++ ; if ( cnt_ffs != padlen ) return ""4"" ""invalid<S2SV_blank>Padding<S2SV_blank>String"" ; } <S2SV_ModEnd> ",xelerance@Openswan/9eaa6c2a823c1d2b58913506a15f9474bf857a3d,CVE-2018-15836,https://github.com/xelerance/Openswan/commit/9eaa6c2a823c1d2b58913506a15f9474bf857a3d,2018-09-26T21:29Z
1318,CWE-284,"<S2SV_StartBug> int ret = write ( tap_fd , packet , len + sizeof ( tETH_HDR ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ,system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
1319,CWE-119,<S2SV_StartBug> if ( ps_dec -> u1_first_slice_in_stream ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,external@libavc/f634481e940421020e52f511c1fb34aac1db4b2f,CVE-2017-0543,https://android.googlesource.com/platform/external/libavc/+/f634481e940421020e52f511c1fb34aac1db4b2f,2017-04-07T22:59Z
1320,CWE-119,<S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> - 1 <S2SV_ModEnd> <S2SV_ModStart> if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> - 1 <S2SV_ModEnd> ,openssl@openssl/103b171d8fc282ef435f8de9afbf7782e312961f,CVE-2015-0206,https://github.com/openssl/openssl/commit/103b171d8fc282ef435f8de9afbf7782e312961f,2015-01-09T02:59Z
1321,CWE-310,"<S2SV_StartBug> struct flowi6 fl6 ; <S2SV_EndBug> <S2SV_StartBug> skb -> len , & fl6 . saddr , & fl6 . daddr ) ; <S2SV_EndBug> <S2SV_StartBug> SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ; <S2SV_EndBug> <S2SV_StartBug> return ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> ","<S2SV_ModStart> * fl6 = & transport -> fl . u . ip6 ; <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> IP6_ECN_flow_xmit ( sk , fl6 -> flowlabel <S2SV_ModEnd> <S2SV_ModStart> SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ; <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/95ee62083cb6453e056562d91f597552021e6ae7,CVE-2013-4350,https://github.com/torvalds/linux/commit/95ee62083cb6453e056562d91f597552021e6ae7,2013-09-25T10:31Z
1322,CWE-189,<S2SV_StartBug> if ( args -> buffer_count < 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> || args -> buffer_count > UINT_MAX / sizeof ( * exec2_list ) ,torvalds@linux/ed8cd3b2cd61004cab85380c52b1817aca1ca49b,CVE-2012-2383,https://github.com/torvalds/linux/commit/ed8cd3b2cd61004cab85380c52b1817aca1ca49b,2012-06-13T10:24Z
1323,CWE-362,"<S2SV_StartBug> mptctl_getiocinfo ( unsigned long arg , unsigned int data_size ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> struct pci_dev * pdev ; <S2SV_EndBug> <S2SV_StartBug> return PTR_ERR ( karg ) ; <S2SV_EndBug> ","<S2SV_ModStart> MPT_ADAPTER * ioc , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z
1324,CWE-119,"<S2SV_StartBug> lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ; <S2SV_EndBug> ","<S2SV_ModStart> luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_unpack_full"" ) ; ",antirez@redis/5ccb6f7a791bf3490357b00a898885759d98bab0,CVE-2018-11218,https://github.com/antirez/redis/commit/5ccb6f7a791bf3490357b00a898885759d98bab0,2018-06-17T17:29Z
1325,CWE-59,"<S2SV_StartBug> const char * path ) <S2SV_EndBug> <S2SV_StartBug> mntflags , mntdata , optional ) ; <S2SV_EndBug> ","<S2SV_ModStart> , const char * rootfs <S2SV_ModStart> , rootfs ",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z
1326,CWE-119,"<S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 3 * <S2SV_EndBug> ","<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } ",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z
1327,CWE-362,"<S2SV_StartBug> int i , len ; <S2SV_EndBug> <S2SV_StartBug> const char __user * p ; <S2SV_EndBug> <S2SV_StartBug> audit_log_format ( * ab , ""argc=%d"" , context -> execve . argc ) ; <S2SV_EndBug> <S2SV_StartBug> buf = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! buf ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < context -> execve . argc ; i ++ ) { <S2SV_EndBug> ","<S2SV_ModStart> long len_max ; long len_rem ; long len_full ; long len_buf ; long len_abuf ; long len_tmp ; bool require_data ; bool encode ; unsigned int iter ; unsigned int arg ; char * buf_head ; char * buf <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> char abuf [ 96 ] ; WARN_ON_ONCE ( MAX_EXECVE_AUDIT_LEN > 7500 ) ; len_max = MAX_EXECVE_AUDIT_LEN ; buf_head = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ; if ( ! buf_head ) { audit_panic ( ""out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>argv<S2SV_blank>string"" ) ; return ; } buf = buf_head ; <S2SV_ModStart> len_rem = len_max ; len_buf = 0 ; len_full = 0 ; require_data = true ; encode = false ; iter = 0 ; arg = 0 ; do { if ( len_full == 0 ) len_full = strnlen_user ( p , MAX_ARG_STRLEN ) - 1 ; if ( require_data ) { if ( buf != buf_head ) { memmove ( buf_head , buf , len_buf ) ; buf = buf_head ; } len_tmp = strncpy_from_user ( & buf_head [ len_buf ] , p , len_max - len_buf ) ; if ( len_tmp == - EFAULT ) { send_sig ( SIGKILL , current , 0 ) ; goto out ; } else if ( len_tmp == ( len_max - len_buf ) ) { require_data = true ; encode = true ; len_full = len_full * 2 ; p += len_tmp ; } else { require_data = false ; if ( ! encode ) encode = audit_string_contains_control ( buf , len_tmp ) ; if ( len_full < len_max ) len_full = ( encode ? len_tmp * 2 : len_tmp ) ; p += len_tmp + 1 ; } len_buf += len_tmp ; buf_head [ len_buf ] = '\\0' ; len_abuf = ( encode ? len_buf * 2 : len_buf + 2 ) ; } if ( len_buf > 0 ) { if ( ( sizeof ( abuf ) + 8 ) > len_rem ) { len_rem = len_max ; audit_log_end ( * ab ) ; * ab = audit_log_start ( context , GFP_KERNEL , AUDIT_EXECVE <S2SV_ModEnd> <S2SV_ModStart> * ab ) goto out ; } len_tmp = 0 ; if ( require_data || ( iter > 0 ) || ( ( len_abuf + sizeof ( abuf ) ) > len_rem ) ) { if ( iter == 0 ) { len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d_len=%lu"" , arg , len_full ) ; } len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d[%d]="" , arg , iter ++ ) ; } else len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d="" , arg ) ; WARN_ON ( len_tmp >= sizeof ( abuf ) ) ; abuf [ sizeof ( abuf ) - 1 ] = '\\0' ; audit_log_format ( * ab , ""%s"" , abuf ) ; len_rem -= len_tmp ; len_tmp = len_buf ; if ( encode ) { if ( len_abuf > len_rem ) len_tmp = len_rem / 2 ; audit_log_n_hex ( * ab , buf , len_tmp ) ; len_rem -= len_tmp * 2 ; len_abuf -= len_tmp * 2 ; } else { if ( len_abuf > len_rem ) len_tmp = len_rem - 2 ; audit_log_n_string ( * ab , buf , len_tmp ) ; len_rem -= len_tmp + 2 ; len_abuf -= len_tmp ; } len_buf -= len_tmp ; buf += len_tmp ; } if ( ( len_buf == 0 ) && ! require_data ) { arg ++ ; iter = 0 ; len_full = 0 ; require_data = true ; encode = false ; } } while ( arg <S2SV_ModEnd> <S2SV_ModStart> ) ; out : kfree ( buf_head <S2SV_ModEnd> ",torvalds@linux/43761473c254b45883a64441dd0bc85a42f3645c,CVE-2016-6136,https://github.com/torvalds/linux/commit/43761473c254b45883a64441dd0bc85a42f3645c,2016-08-06T20:59Z
1328,CWE-264,"<S2SV_StartBug> fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , mode > 0 ? mode : 0644 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ( mode == 0 || mode == MODE_INVALID ) ? 0644 : mode <S2SV_ModEnd> ,systemd@systemd/06eeacb6fe029804f296b065b3ce91e796e1cd0e,CVE-2016-10156,https://github.com/systemd/systemd/commit/06eeacb6fe029804f296b065b3ce91e796e1cd0e,2017-01-23T07:59Z
1329,CWE-20,"<S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> char line [ NETSCREEN_LINE_LENGTH ] ; <S2SV_EndBug> <S2SV_StartBug> pkt_len = parse_netscreen_rec_hdr ( phdr , line , cap_int , & cap_dir , <S2SV_EndBug> <S2SV_StartBug> if ( pkt_len == - 1 ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return parse_netscreen_packet ( wth -> random_fh , phdr , buf <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",wireshark@wireshark/6a140eca7b78b230f1f90a739a32257476513c78,CVE-2016-5357,https://github.com/wireshark/wireshark/commit/6a140eca7b78b230f1f90a739a32257476513c78,2016-08-07T16:59Z
1330,CWE-000,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> u64 irq_time ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( rq -> skip_clock_update ) return <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/f26f9aff6aaf67e9a430d16c266f91b13a5bff64,CVE-2011-4621,https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64,2012-05-17T11:00Z
1331,CWE-125,<S2SV_StartBug> switch ( depth ) <S2SV_EndBug> <S2SV_StartBug> CheckNumberCompactPixels ; <S2SV_EndBug> ,<S2SV_ModStart> CheckNumberCompactPixels ; <S2SV_ModStart>  <S2SV_ModEnd> ,ImageMagick@ImageMagick/30eec879c8b446b0ea9a3bb0da1a441cc8482bc4,CVE-2016-7521,https://github.com/ImageMagick/ImageMagick/commit/30eec879c8b446b0ea9a3bb0da1a441cc8482bc4,2017-04-20T18:59Z
1332,CWE-120,"<S2SV_StartBug> raw_printf ( ""Unknown<S2SV_blank>option:<S2SV_blank>%s"" , * argv ) ; <S2SV_EndBug> <S2SV_StartBug> raw_printf ( ""Unknown<S2SV_blank>option:<S2SV_blank>%s"" , * argv ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""Unknown<S2SV_blank>option:<S2SV_blank>%.60s"" <S2SV_ModEnd> <S2SV_ModStart> ""Unknown<S2SV_blank>option:<S2SV_blank>%.60s"" <S2SV_ModEnd> ",NetHack@NetHack/f3def5c0b999478da2d0a8f0b6a7c370a2065f77,CVE-2020-5210,https://github.com/NetHack/NetHack/commit/f3def5c0b999478da2d0a8f0b6a7c370a2065f77,2020-01-28T18:15Z
1333,CWE-200,"<S2SV_StartBug> struct blkif_response resp ; <S2SV_EndBug> <S2SV_StartBug> resp . id = id ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) , <S2SV_EndBug> <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) , <S2SV_EndBug> <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> * <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> resp = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> resp = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> resp = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> resp -> id = id ; resp -> operation = op ; resp -> status = st ; ,torvalds@linux/089bc0143f489bd3a4578bdff5f4ca68fb26f341,CVE-2017-10911,https://github.com/torvalds/linux/commit/089bc0143f489bd3a4578bdff5f4ca68fb26f341,2017-07-05T01:29Z
1334,CWE-000,<S2SV_StartBug> if ( ! ( mask & KADM5_ATTRIBUTES ) || <S2SV_EndBug> ,<S2SV_ModStart> password == NULL || ,krb5@krb5/c5be6209311d4a8f10fda37d0d3f876c1b33b77b,CVE-2012-1013,https://github.com/krb5/krb5/commit/c5be6209311d4a8f10fda37d0d3f876c1b33b77b,2012-06-07T19:55Z
1335,CWE-125,"<S2SV_StartBug> if ( ( datao + 12 < datao ) || ( datao + 12 < 12 ) || ( datao + 12 > buf_size ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) || <S2SV_EndBug> <S2SV_StartBug> if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) { <S2SV_EndBug> <S2SV_StartBug> ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) || <S2SV_EndBug> ","<S2SV_ModStart> CHECKOVERFLOW ( datao , buf_size , 12 <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( datao , buf_size , 2 <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components <S2SV_ModEnd> <S2SV_ModStart> ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( <S2SV_ModEnd> <S2SV_ModStart> ) , <S2SV_ModEnd> <S2SV_ModStart> ) ; continue ; } <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs <S2SV_ModEnd> ",libexif@libexif/435e21f05001fb03f9f186fa7cbc69454afd00d1,CVE-2020-13112,https://github.com/libexif/libexif/commit/435e21f05001fb03f9f186fa7cbc69454afd00d1,2020-05-21T16:15Z
1336,CWE-119,"<S2SV_StartBug> sprintf ( charbuf , ""%s/%s.html"" , dirout , rootname ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( charbuf , ""%s/%s-links.html"" , dirout , rootname ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( charbuf , ""%s_thumb_%03d"" , rootname , index ) ; <S2SV_EndBug> ","<S2SV_ModStart> snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> ",DanBloomberg@leptonica/c1079bb8e77cdd426759e466729917ca37a3ed9f,CVE-2018-7247,https://github.com/DanBloomberg/leptonica/commit/c1079bb8e77cdd426759e466729917ca37a3ed9f,2018-02-19T18:29Z
1337,CWE-125,<S2SV_StartBug> snapend_save = ndo -> ndo_snapend ; <S2SV_EndBug> ,<S2SV_ModStart> ; ND_TCHECK_16BITS ( & ip -> ip_len ) ,the-tcpdump-group@tcpdump/8509ef02eceb2bbb479cea10fe4a7ec6395f1a8b,CVE-2017-13012,https://github.com/the-tcpdump-group/tcpdump/commit/8509ef02eceb2bbb479cea10fe4a7ec6395f1a8b,2017-09-14T06:29Z
1338,CWE-416,<S2SV_StartBug> struct dentry * dir ; <S2SV_EndBug> <S2SV_StartBug> ci = d_inode ( dir ) -> i_crypt_info ; <S2SV_EndBug> <S2SV_StartBug> dir_has_key = ( ci != NULL ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> d_inode ( dir ) -> i_crypt_info <S2SV_ModEnd> ,torvalds@linux/1b53cf9815bb4744958d41f3795d5d5a1d365e2d,CVE-2017-7374,https://github.com/torvalds/linux/commit/1b53cf9815bb4744958d41f3795d5d5a1d365e2d,2017-03-31T20:59Z
1339,CWE-295,<S2SV_StartBug> void unbind_ports ( void ) { <S2SV_EndBug> <S2SV_StartBug> CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_SECTIONS ] ) ; <S2SV_EndBug> <S2SV_StartBug> service_options . next = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( opt -> ctx ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> NOEXPORT <S2SV_ModStart> for ( <S2SV_ModEnd> <S2SV_ModStart> opt ; opt = opt -> next <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } } <S2SV_ModEnd> ,mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z
1340,CWE-119,<S2SV_StartBug> numbers [ argc ++ ] = ( unsigned long ) mtree_atol ( & p ) ; <S2SV_EndBug> <S2SV_StartBug> if ( argc > MAX_PACK_ARGS ) { <S2SV_EndBug> ,"<S2SV_ModStart> if ( argc >= MAX_PACK_ARGS ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Too<S2SV_blank>many<S2SV_blank>arguments"" ) ; return ARCHIVE_WARN ; } <S2SV_ModStart>  <S2SV_ModEnd> ",libarchive@libarchive/a550daeecf6bc689ade371349892ea17b5b97c77,CVE-2016-4301,https://github.com/libarchive/libarchive/commit/a550daeecf6bc689ade371349892ea17b5b97c77,2016-09-21T14:25Z
1341,CWE-119,<S2SV_StartBug> context . Xtogo = i -> width ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\n"" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\n"" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\n"" ) ; # endif i -> posY = i -> parent -> height - i -> height ; } ",miniupnp@ngiflib/b588a2249c7abbfc52173e32ee11d6facef82f89,CVE-2018-10677,https://github.com/miniupnp/ngiflib/commit/b588a2249c7abbfc52173e32ee11d6facef82f89,2018-05-02T19:29Z
1342,CWE-125,<S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> ,<S2SV_ModStart> l > ( unsigned ) ( <S2SV_ModEnd> <S2SV_ModStart> - p ) <S2SV_ModStart> l > ( unsigned ) ( <S2SV_ModEnd> <S2SV_ModStart> - p ) <S2SV_ModStart> l > ( unsigned ) ( <S2SV_ModEnd> <S2SV_ModStart> - p ) <S2SV_ModStart> l > ( unsigned ) ( <S2SV_ModEnd> <S2SV_ModStart> - p ) ,miniupnp@miniupnp/b238cade9a173c6f751a34acf8ccff838a62aa47,CVE-2016-3178,https://github.com/miniupnp/miniupnp/commit/b238cade9a173c6f751a34acf8ccff838a62aa47,2017-03-24T15:59Z
1343,CWE-908,<S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> ,<S2SV_ModStart> = { 0 } ,radare@radare2/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,CVE-2018-11383,https://github.com/radare/radare2/commit/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,2018-05-22T19:29Z
1344,CWE-20,"<S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> if ( tag == 0xFFFEE0DD ) <S2SV_EndBug> ","<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ",ImageMagick@ImageMagick/16916c8979c32765c542e216b31cee2671b7afe7,CVE-2018-16644,https://github.com/ImageMagick/ImageMagick/commit/16916c8979c32765c542e216b31cee2671b7afe7,2018-09-06T22:29Z
1345,CWE-354,<S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! recovery_started ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , ""Not<S2SV_blank>in<S2SV_blank>Recovery<S2SV_blank>mode"" ) ; layoutHome ( ) ; return ; } ",keepkey@keepkey-firmware/769714fcb569e7a4faff9530a2d9ac1f9d6e5680,CVE-2019-18672,https://github.com/keepkey/keepkey-firmware/commit/769714fcb569e7a4faff9530a2d9ac1f9d6e5680,2019-12-06T18:15Z
1346,CWE-20,"<S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT1 , hashTable [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , hashTable [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , hashTable [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT4<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT4 ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ENC624J600_EHT1 , hashTable [ 0 ] ) ; enc624j600WriteReg ( interface , ENC624J600_EHT2 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EHT3 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EHT4 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EHT1 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EHT2 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EHT3 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EHT4 <S2SV_ModEnd> ",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
1347,CWE-125,"<S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 256UL , image -> rows * <S2SV_EndBug> ",<S2SV_ModStart> 257UL <S2SV_ModEnd> ,ImageMagick@ImageMagick/6d202a0514fb6a406456b8b728cde776becb25f8,CVE-2016-7537,https://github.com/ImageMagick/ImageMagick/commit/6d202a0514fb6a406456b8b728cde776becb25f8,2017-04-19T14:59Z
1348,CWE-416,"<S2SV_StartBug> if ( containsForbiddenChars ( p , l ) ) { <S2SV_EndBug> ","<S2SV_ModStart> memset ( newserv , 0 , sizeof ( struct service ) ) ; ",miniupnp@miniupnp/140ee8d2204b383279f854802b27bdb41c1d5d1a,CVE-2016-3179,https://github.com/miniupnp/miniupnp/commit/140ee8d2204b383279f854802b27bdb41c1d5d1a,2017-03-24T15:59Z
1349,CWE-000,"<S2SV_StartBug> WORD32 i ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < BUF_MGR_MAX_CNT ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , i , BUF_MGR_REF ) ; <S2SV_EndBug> ","<S2SV_ModStart> , j <S2SV_ModStart> j = 0 ; j < ps_codec -> i4_max_dpb_size ; j <S2SV_ModEnd> <S2SV_ModStart> j <S2SV_ModEnd> ",external@libhevc/913d9e8d93d6b81bb8eac3fc2c1426651f5b259d,CVE-2017-0642,https://android.googlesource.com/platform/external/libhevc/+/913d9e8d93d6b81bb8eac3fc2c1426651f5b259d,2017-06-14T13:29Z
1350,CWE-264,"<S2SV_StartBug> ret = put_user ( task_thread_info ( child ) -> tp_value , <S2SV_EndBug> ",<S2SV_ModStart> [ 0 ] ,torvalds@linux/a4780adeefd042482f624f5e0d577bf9cdcbb760,CVE-2014-9870,https://github.com/torvalds/linux/commit/a4780adeefd042482f624f5e0d577bf9cdcbb760,2016-08-06T10:59Z
1351,CWE-388,<S2SV_StartBug> goto fail ; <S2SV_EndBug> ,<S2SV_ModStart> ret = - EINVAL ; ,torvalds@linux/6b8ac63847bc2f958dd93c09edc941a0118992d9,CVE-2017-5577,https://github.com/torvalds/linux/commit/6b8ac63847bc2f958dd93c09edc941a0118992d9,2017-02-06T06:59Z
1352,CWE-119,"<S2SV_StartBug> static char * print_object ( cJSON * item , int depth , int fmt ) <S2SV_EndBug> <S2SV_StartBug> while ( child ) { <S2SV_EndBug> <S2SV_StartBug> names [ i ] = str = print_string_ptr ( child -> string ) ; <S2SV_EndBug> <S2SV_StartBug> entries [ i ++ ] = ret = print_value ( child , depth , fmt ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! fail ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < numentries ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> if ( fmt ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < numentries ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < depth ; ++ j ) <S2SV_EndBug> <S2SV_StartBug> strcpy ( ptr , names [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> ptr += strlen ( names [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( fmt ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < depth - 1 ; ++ i ) <S2SV_EndBug> <S2SV_StartBug> * ptr ++ = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> , printbuffer * p <S2SV_ModStart> size_t tmplen = 0 ; <S2SV_ModStart> numentries ++ , child = child -> next ; if ( ! numentries ) { if ( p ) out = ensure ( p , fmt ? depth + 4 : 3 ) ; else out = ( char * ) cJSON_malloc ( fmt ? depth + 4 : 3 ) ; if ( ! out ) return 0 ; ptr = out ; * ptr ++ = '{' ; if ( fmt ) { * ptr ++ = '\\n' ; for ( i = 0 ; i < depth ; i ++ ) * ptr ++ = '\\t' ; } * ptr ++ = '}' ; * ptr ++ = 0 ; return out ; } if ( p ) { i = p -> offset ; len = fmt ? 2 : 1 ; ptr = ensure ( p , len + 1 ) ; if ( ! ptr ) return 0 ; * ptr ++ = '{' ; if ( fmt ) * ptr ++ = '\\n' ; * ptr = 0 ; p -> offset += len ; child = item -> child ; depth ++ ; while ( child ) { if ( fmt ) { ptr = ensure ( p , depth ) ; if ( ! ptr ) return 0 ; for ( j = 0 ; j < depth ; j ++ ) * ptr ++ = '\\t' ; p -> offset += depth ; } print_string_ptr ( child -> string , p ) ; p -> offset = update ( p ) ; len = fmt ? 2 : 1 ; ptr = ensure ( p , len ) ; if ( ! ptr ) return 0 ; * ptr ++ = ':' ; if ( fmt ) * ptr ++ = '\\t' ; p -> offset += len ; print_value ( child , depth , fmt , p ) ; p -> offset = update ( p ) ; len = ( fmt ? 1 : 0 ) + ( child -> next ? 1 : 0 ) ; ptr = ensure ( p , len + 1 ) ; if ( ! ptr ) return 0 ; if ( child -> next ) * ptr ++ = ',' ; if ( fmt ) * ptr ++ = '\\n' ; * ptr = 0 ; p -> offset += len ; child = child -> next ; } ptr = ensure ( p , fmt ? ( depth + 1 ) : 2 ) ; if ( ! ptr ) return 0 ; if ( fmt ) for ( i = 0 ; i < depth - 1 ; i ++ ) * ptr ++ = '\\t' ; * ptr ++ = '}' ; * ptr = 0 ; out = ( p -> buffer ) + i ; } else { entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ; if ( ! entries ) return 0 ; names = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ; if ( ! names ) { cJSON_free ( entries ) ; return 0 ; } memset ( entries , 0 , sizeof ( char * ) * numentries ) ; memset ( names , 0 , sizeof ( char * ) * numentries ) ; child = item -> child ; depth ++ ; if ( fmt ) len += depth ; while ( child && ! fail ) <S2SV_ModEnd> <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> i ++ <S2SV_ModEnd> <S2SV_ModStart> if ( fmt ) <S2SV_ModEnd> <S2SV_ModStart> i ++ ) <S2SV_ModEnd> <S2SV_ModStart> j ++ ) <S2SV_ModEnd> <S2SV_ModStart> tmplen = strlen ( <S2SV_ModEnd> <S2SV_ModStart> memcpy ( ptr , <S2SV_ModEnd> <S2SV_ModStart> , tmplen ) ; ptr += tmplen <S2SV_ModEnd> <S2SV_ModStart> if ( fmt ) <S2SV_ModEnd> <S2SV_ModStart> i ++ ) <S2SV_ModEnd> <S2SV_ModStart> * ptr ++ = 0 ; } <S2SV_ModEnd> ",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
1353,CWE-125,<S2SV_StartBug> struct ikev2_id id ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> ,<S2SV_ModStart> const struct ikev2_id * idp ; <S2SV_ModStart> idp = ( const struct ikev2_id * ) ext ; <S2SV_ModStart> idp <S2SV_ModEnd> ,the-tcpdump-group@tcpdump/8dca25d26c7ca2caf6138267f6f17111212c156e,CVE-2017-13690,https://github.com/the-tcpdump-group/tcpdump/commit/8dca25d26c7ca2caf6138267f6f17111212c156e,2017-09-14T06:29Z
1354,CWE-787,"<S2SV_StartBug> ber_parse_header ( STREAM s , int tagval , int * length ) <S2SV_EndBug> ",<S2SV_ModStart> uint32 <S2SV_ModEnd> ,rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z
1355,CWE-000,<S2SV_StartBug> other = unix_peer_get ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unix_peer ( other ) != sk ) { <S2SV_EndBug> <S2SV_StartBug> if ( unix_recvq_full ( other ) ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( writable ) { unix_state_lock ( sk ) ; other = unix_peer ( sk ) ; if ( other && unix_peer ( <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> && unix_dgram_peer_wake_me ( sk , other ) <S2SV_ModStart> unix_state_unlock ( sk <S2SV_ModEnd> ",torvalds@linux/7d267278a9ece963d77eefec61630223fce08c6c,CVE-2013-7446,https://github.com/torvalds/linux/commit/7d267278a9ece963d77eefec61630223fce08c6c,2015-12-28T11:59Z
1356,CWE-125,<S2SV_StartBug> size_t <S2SV_EndBug> <S2SV_StartBug> value = ( size_t ) ( buffer [ 0 ] << 24 ) ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 1 ] << 16 ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 2 ] << 8 ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 3 ] ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffffffff ) ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned int <S2SV_ModEnd> <S2SV_ModStart> unsigned int ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( unsigned int ) <S2SV_ModStart> ( unsigned int ) <S2SV_ModStart> ( unsigned int ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,ImageMagick@ImageMagick/d8ab7f046587f2e9f734b687ba7e6e10147c294b,CVE-2016-5842,https://github.com/ImageMagick/ImageMagick/commit/d8ab7f046587f2e9f734b687ba7e6e10147c294b,2016-12-13T15:59Z
1357,CWE-20,"<S2SV_StartBug> outpos += sprintf ( outpos , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>re"" , x , y , w , h ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sendClean ( outputbuffer ) ; ,TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z
1358,CWE-399,"<S2SV_StartBug> if ( pskb_expand_head ( skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> skb_out <S2SV_ModEnd> ,torvalds@linux/5b6698b0e4a37053de35cc24ee695b98a7eb712b,CVE-2014-9428,https://github.com/torvalds/linux/commit/5b6698b0e4a37053de35cc24ee695b98a7eb712b,2015-01-02T21:59Z
1359,CWE-20,<S2SV_StartBug> void exit_io_context ( void ) <S2SV_EndBug> <S2SV_StartBug> task_lock ( current ) ; <S2SV_EndBug> <S2SV_StartBug> ioc = current -> io_context ; <S2SV_EndBug> <S2SV_StartBug> current -> io_context = NULL ; <S2SV_EndBug> <S2SV_StartBug> task_unlock ( current ) ; <S2SV_EndBug> ,<S2SV_ModStart> struct task_struct * task <S2SV_ModEnd> <S2SV_ModStart> task <S2SV_ModEnd> <S2SV_ModStart> task <S2SV_ModEnd> <S2SV_ModStart> task <S2SV_ModEnd> <S2SV_ModStart> task <S2SV_ModEnd> ,torvalds@linux/b69f2292063d2caf37ca9aec7d63ded203701bf3,CVE-2012-0879,https://github.com/torvalds/linux/commit/b69f2292063d2caf37ca9aec7d63ded203701bf3,2012-05-17T11:00Z
1360,CWE-200,<S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( ! access_ok ( VERIFY_READ , uregs , sizeof ( elf_xtregs_t ) ) ) return - EFAULT ",torvalds@linux/0d0138ebe24b94065580bd2601f8bb7eb6152f56,CVE-2011-2707,https://github.com/torvalds/linux/commit/0d0138ebe24b94065580bd2601f8bb7eb6152f56,2012-05-24T23:55Z
1361,CWE-119,<S2SV_StartBug> * minor_status = ( OM_uint32 ) KRB5_BAD_MSIZE ; <S2SV_EndBug> <S2SV_StartBug> if ( header -> buffer . length < token_wrapper_len + 14 ) { <S2SV_EndBug> ,<S2SV_ModStart> ; return GSS_S_DEFECTIVE_TOKEN ; } if ( ctx -> seq == NULL ) { * minor_status = 0 <S2SV_ModStart> 22 <S2SV_ModEnd> ,krb5@krb5/e6ae703ae597d798e310368d52b8f38ee11c6a73,CVE-2014-4342,https://github.com/krb5/krb5/commit/e6ae703ae597d798e310368d52b8f38ee11c6a73,2014-07-20T11:12Z
1362,CWE-264,"<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> ret = xen_pcibk_read_config_word ( dev , offset , value , data ) ; <S2SV_EndBug> <S2SV_StartBug> * value |= PCI_COMMAND_IO ; <S2SV_EndBug> ",<S2SV_ModStart> ret = pci_read_config_word <S2SV_ModEnd> <S2SV_ModStart> ) ; const struct pci_cmd_info * cmd = data ; * value &= PCI_COMMAND_GUEST ; <S2SV_ModEnd> <S2SV_ModStart> cmd -> val & ~ PCI_COMMAND_GUEST ; <S2SV_ModEnd> ,torvalds@linux/af6fc858a35b90e89ea7a7ee58e66628c55c776b,CVE-2015-2150,https://github.com/torvalds/linux/commit/af6fc858a35b90e89ea7a7ee58e66628c55c776b,2015-03-12T14:59Z
1363,CWE-119,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vp9_ref_frame_t * frame = va_arg ( args , vp9_ref_frame_t * ) ; <S2SV_EndBug> <S2SV_StartBug> YV12_BUFFER_CONFIG * fb ; <S2SV_EndBug> <S2SV_StartBug> vp9_get_reference_enc ( ctx -> cpi , frame -> idx , & fb ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> = get_ref_frame ( & <S2SV_ModEnd> <S2SV_ModStart> -> common <S2SV_ModStart> ) ; if ( fb == NULL ) return VPX_CODEC_ERROR <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1364,CWE-399,<S2SV_StartBug> kfree ( fpl ) ; <S2SV_EndBug> ,<S2SV_ModStart> free_uid ( fpl -> user ) ; ,torvalds@linux/415e3d3e90ce9e18727e8843ae343eda5a58fad6,CVE-2016-2550,https://github.com/torvalds/linux/commit/415e3d3e90ce9e18727e8843ae343eda5a58fad6,2016-04-27T17:59Z
1365,CWE-399,<S2SV_StartBug> kiocb_batch_free ( & batch ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ctx , ",torvalds@linux/802f43594d6e4d2ac61086d239153c17873a0428,CVE-2012-0058,https://github.com/torvalds/linux/commit/802f43594d6e4d2ac61086d239153c17873a0428,2012-05-17T11:00Z
1366,CWE-189,<S2SV_StartBug> req -> started = false ; <S2SV_EndBug> <S2SV_StartBug> if ( dep -> number > 1 ) <S2SV_EndBug> ,"<S2SV_ModStart> dwc3_gadget_del_and_unmap_request ( dep , req , status <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/c91815b596245fd7da349ecc43c8def670d2269e,CVE-2019-14763,https://github.com/torvalds/linux/commit/c91815b596245fd7da349ecc43c8def670d2269e,2019-08-07T22:15Z
1367,CWE-20,"<S2SV_StartBug> char prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> char * type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( prefix != '+' && prefix != '-' && prefix != '=' ) { <S2SV_EndBug> <S2SV_StartBug> YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ; <S2SV_EndBug> <S2SV_StartBug> { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } <S2SV_EndBug> <S2SV_StartBug> { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; } <S2SV_EndBug> <S2SV_StartBug> case 237 : <S2SV_EndBug> <S2SV_StartBug> # line 1082 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1090 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1091 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1095 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1106 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1120 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1124 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1125 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1129 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1130 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1134 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1135 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1140 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1144 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1148 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1152 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1153 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1158 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1162 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1163 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1168 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1170 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1172 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1174 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1176 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3826 ""ntp_parser.c"" <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; switch ( <S2SV_ModEnd> <S2SV_ModStart> [ 0 ] ) { case '+' : case '-' : case '=' : prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ; type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) <S2SV_ModStart> break ; default : prefix = '=' ; type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ; } ( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ; YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ; } break ; case 216 : # line 1022 ""ntp_parser.y"" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 217 : # line 1027 ""ntp_parser.y"" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 227 : # line 1058 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 228 : # line 1059 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; } break ; case 229 : # line 1064 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 230 : # line 1066 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 231 : # line 1071 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( 'i' , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 233 : # line 1077 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_shorts ( '-' , ( yyvsp [ ( 2 ) - ( 5 ) ] . Integer ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Integer ) ) ; } break ; case 234 : # line 1081 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 <S2SV_ModEnd> <S2SV_ModStart> ) ; } break ; case 235 : # line 1082 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ; } break ; case 236 : # line 1086 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] <S2SV_ModEnd> <S2SV_ModStart> , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; } break ; case 237 : # line 1087 ""ntp_parser.y"" { ( yyval <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( yyvsp [ ( 1 ) - ( 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 1092 <S2SV_ModEnd> <S2SV_ModStart> 1100 <S2SV_ModEnd> <S2SV_ModStart> 1101 <S2SV_ModEnd> <S2SV_ModStart> 1105 <S2SV_ModEnd> <S2SV_ModStart> 1116 <S2SV_ModEnd> <S2SV_ModStart> 1130 <S2SV_ModEnd> <S2SV_ModStart> 1134 <S2SV_ModEnd> <S2SV_ModStart> 1135 <S2SV_ModEnd> <S2SV_ModStart> 1139 <S2SV_ModEnd> <S2SV_ModStart> 1140 <S2SV_ModEnd> <S2SV_ModStart> 1144 <S2SV_ModEnd> <S2SV_ModStart> 1145 <S2SV_ModEnd> <S2SV_ModStart> 1150 <S2SV_ModEnd> <S2SV_ModStart> 1154 <S2SV_ModEnd> <S2SV_ModStart> 1158 <S2SV_ModEnd> <S2SV_ModStart> 1162 <S2SV_ModEnd> <S2SV_ModStart> 1163 <S2SV_ModEnd> <S2SV_ModStart> 1168 <S2SV_ModEnd> <S2SV_ModStart> 1172 <S2SV_ModEnd> <S2SV_ModStart> 1173 <S2SV_ModEnd> <S2SV_ModStart> 1178 <S2SV_ModEnd> <S2SV_ModStart> 1180 <S2SV_ModEnd> <S2SV_ModStart> 1182 <S2SV_ModEnd> <S2SV_ModStart> 1184 <S2SV_ModEnd> <S2SV_ModStart> 1186 <S2SV_ModEnd> <S2SV_ModStart> 3836 <S2SV_ModEnd> ",ntp-project@ntp/553f2fa65865c31c5e3c48812cfd46176cffdd27,CVE-2015-5194,https://github.com/ntp-project/ntp/commit/553f2fa65865c31c5e3c48812cfd46176cffdd27,2017-07-21T14:29Z
1368,CWE-000,"<S2SV_StartBug> [ DISCE_PROBE ] = sas_probe_devices , <S2SV_EndBug> <S2SV_StartBug> [ DISCE_RESUME ] = sas_resume_devices , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/0558f33c06bb910e2879e355192227a8e8f0219d,CVE-2017-18232,https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d,2018-03-15T04:29Z
1369,CWE-362,"<S2SV_StartBug> const char * name , int rep_quick ) <S2SV_EndBug> <S2SV_StartBug> mysql_file_close ( new_file , MYF ( 0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( param -> testflag & T_BACKUP_DATA ? <S2SV_EndBug> ","<S2SV_ModStart> , my_bool no_copy_stat <S2SV_ModStart> myf flags = 0 ; if ( param -> testflag & T_BACKUP_DATA ) flags |= MY_REDEL_MAKE_BACKUP ; if ( no_copy_stat ) flags |= MY_REDEL_NO_COPY_STAT ; <S2SV_ModStart> flags <S2SV_ModEnd> ",MariaDB@server/4e5473862e6852b0f3802b0cd0c6fa10b5253291,CVE-2016-6663,https://github.com/MariaDB/server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291,2016-12-13T21:59Z
1370,CWE-000,"<S2SV_StartBug> # if uECC_VLI_NATIVE_LITTLE_ENDIAN <S2SV_EndBug> <S2SV_StartBug> EccPoint_mult ( p , curve -> G , k2 [ ! carry ] , 0 , num_n_bits + 1 , curve ) ; <S2SV_EndBug> ","<S2SV_ModStart> uECC_word_t * initial_Z = 0 ; <S2SV_ModStart> if ( g_rng_function ) { if ( ! uECC_generate_random_int ( k2 [ carry ] , curve -> p , num_words ) ) { return 0 ; } initial_Z = k2 [ carry ] ; } <S2SV_ModStart> initial_Z <S2SV_ModEnd> ",kmackay@micro-ecc/1b5f5cea5145c96dd8791b9b2c41424fc74c2172,CVE-2020-27209,https://github.com/kmackay/micro-ecc/commit/1b5f5cea5145c96dd8791b9b2c41424fc74c2172,2021-05-20T21:15Z
1371,CWE-125,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-truncated]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , rpl_tstr <S2SV_ModEnd> ",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z
1372,CWE-200,<S2SV_StartBug> int family = sk -> sk_family ; <S2SV_EndBug> <S2SV_StartBug> if ( addr_len ) { <S2SV_EndBug> <S2SV_StartBug> sin = ( struct sockaddr_in * ) msg -> msg_name ; <S2SV_EndBug> <S2SV_StartBug> if ( isk -> cmsg_flags ) <S2SV_EndBug> <S2SV_StartBug> sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ; <S2SV_EndBug> <S2SV_StartBug> IP6CB ( skb ) -> iif ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> struct sockaddr_in * <S2SV_ModStart> * addr_len = sizeof ( * sin ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sin6 = ( struct sockaddr_in6 * <S2SV_ModStart> ) ; * addr_len = sizeof ( * sin6 ,torvalds@linux/bceaa90240b6019ed73b49965eac7d167610be69,CVE-2013-7281,https://github.com/torvalds/linux/commit/bceaa90240b6019ed73b49965eac7d167610be69,2014-01-08T16:55Z
1373,CWE-17,<S2SV_StartBug> flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT | <S2SV_EndBug> <S2SV_StartBug> if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & inode -> i_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> if ( max_blocks > 0 ) { <S2SV_EndBug> ,"<S2SV_ModStart> mutex_lock ( & inode -> i_mutex ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! <S2SV_ModEnd> <S2SV_ModStart> && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; } flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ; if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_ModStart> if ( partial_begin || partial_end ) { ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ; if ( ret ) goto out_mutex <S2SV_ModEnd> <S2SV_ModStart> flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ; ",torvalds@linux/0f2af21aae11972fa924374ddcf52e88347cf5a8,CVE-2015-0275,https://github.com/torvalds/linux/commit/0f2af21aae11972fa924374ddcf52e88347cf5a8,2015-10-19T10:59Z
1374,CWE-190,<S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( pool -> free_total < NW_BUF_POOL_MAX_SIZE ) <S2SV_ModStart> else { free ( buf ) ; } ,viabtc@viabtc_exchange_server/4a7c27bfe98f409623d4d857894d017ff0672cc9,CVE-2018-17568,https://github.com/viabtc/viabtc_exchange_server/commit/4a7c27bfe98f409623d4d857894d017ff0672cc9#diff-0c23effa84a7b85053bac7981a8580c8,2018-09-26T22:29Z
1375,CWE-000,"<S2SV_StartBug> bpf_map_inc ( map , true ) ; <S2SV_EndBug> ",<S2SV_ModStart> map = ,torvalds@linux/92117d8443bc5afacc8d5ba82e541946310f106e,CVE-2016-4558,https://github.com/torvalds/linux/commit/92117d8443bc5afacc8d5ba82e541946310f106e,2016-05-23T10:59Z
1376,CWE-269,"<S2SV_StartBug> while ( * cp ) { <S2SV_EndBug> <S2SV_StartBug> NEARDATA const char hex [ ] = ""00112233445566778899aAbBcCdDeEfF"" ; <S2SV_EndBug> <S2SV_StartBug> int dcount = 0 ; <S2SV_EndBug> <S2SV_StartBug> cp ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( * cp == 'x' || * cp == 'X' ) <S2SV_EndBug> <S2SV_StartBug> for ( ++ cp ; * cp && ( dp = index ( hex , * cp ) ) && ( dcount ++ < 2 ) ; cp ++ ) <S2SV_EndBug> <S2SV_StartBug> else if ( * cp == 'o' || * cp == 'O' ) <S2SV_EndBug> <S2SV_StartBug> cp ++ ; <S2SV_EndBug> <S2SV_StartBug> * tp ++ = cval ; <S2SV_EndBug> ","<S2SV_ModStart> static <S2SV_ModEnd> <S2SV_ModStart> oct [ ] = ""01234567"" , dec [ ] = ""0123456789"" , <S2SV_ModStart> cval , meta , dcount ; while ( * cp ) { meta = ( * cp == '\\\\' && ( cp [ 1 ] == 'm' || cp [ 1 ] == 'M' ) && cp [ 2 ] ) ; if ( meta ) cp += 2 ; cval = dcount <S2SV_ModEnd> <S2SV_ModStart> if ( ( * cp != '\\\\' && * cp != '^' ) || ! cp [ 1 ] ) { cval = * cp ++ ; } else if ( * cp == '^' ) { cval = ( * ++ cp & 0x1f ) ; ++ cp ; } else if ( index ( dec , cp [ 1 ] ) ) { ++ cp ; do { cval = ( cval * 10 ) + ( * cp - '0' ) ; } while ( * ++ cp && index ( dec , * cp ) && ++ dcount < 3 ) ; } else if ( ( cp [ 1 ] == 'o' || cp [ 1 ] == 'O' ) && cp [ 2 ] && index ( oct , cp [ 2 ] ) ) { cp += 2 ; do { cval = ( cval * 8 ) + ( * cp - '0' ) ; } while ( * ++ cp && index ( oct , * cp ) && ++ dcount < 3 ) ; } else if ( ( cp [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> cp [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> && cp [ 2 ] <S2SV_ModEnd> <S2SV_ModStart> cp [ 2 ] ) ) != 0 ) { cp += 2 ; do { <S2SV_ModEnd> <S2SV_ModStart> } while ( * ++ cp && ( dp = index ( hex , * cp ) ) != 0 && ++ dcount < 2 ) ; } else <S2SV_ModEnd> <S2SV_ModStart> ++ cp ; } <S2SV_ModEnd> <S2SV_ModStart> ( char ) ",NetHack@NetHack/612755bfb5c412079795c68ba392df5d93874ed8,CVE-2020-5253,https://github.com/NetHack/NetHack/commit/612755bfb5c412079795c68ba392df5d93874ed8,2020-03-10T17:15Z
1377,CWE-119,<S2SV_StartBug> int file_is_y4m ( const char detect [ 4 ] ) { <S2SV_EndBug> ,<S2SV_ModStart> static ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1378,CWE-190,<S2SV_StartBug> if ( size_left && size_left < 4 ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,phaag@nfdump/3b006ededaf351f1723aea6c727c9edd1b1fff9b,CVE-2019-14459,https://github.com/phaag/nfdump/commit/3b006ededaf351f1723aea6c727c9edd1b1fff9b,2019-07-31T21:15Z
1379,CWE-125,"<S2SV_StartBug> PIX * pixc , * pixm , * pixg , * pixd ; <S2SV_EndBug> <S2SV_StartBug> if ( ( pixc = pixFewColorsOctcubeQuant1 ( pixs , level ) ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> return ( PIX * ) ERROR_PTR ( ""too<S2SV_blank>many<S2SV_blank>colors"" , procName , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> * pix1 , <S2SV_ModStart> pix1 <S2SV_ModEnd> <S2SV_ModStart> ) ; pixc = pixConvertTo8 ( pix1 , 1 ) ; pixDestroy ( & pix1 ",DanBloomberg@leptonica/5ee24b398bb67666f6d173763eaaedd9c36fb1e5,CVE-2020-36281,https://github.com/DanBloomberg/leptonica/commit/5ee24b398bb67666f6d173763eaaedd9c36fb1e5,2021-03-12T01:15Z
1380,CWE-399,"<S2SV_StartBug> int i , ubits = BN_num_bits ( u ) , vbits = BN_num_bits ( v ) , <S2SV_EndBug> <S2SV_StartBug> if ( ubits <= BN_BITS2 && udp [ 0 ] == 1 ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ",<S2SV_ModStart> ; int <S2SV_ModEnd> <S2SV_ModStart> ; int <S2SV_ModEnd> <S2SV_ModStart> ; int <S2SV_ModEnd> <S2SV_ModStart> ) { if ( <S2SV_ModEnd> <S2SV_ModStart> 0 ) goto err ; if ( udp [ 0 ] == <S2SV_ModStart> } ,openssl@openssl/4924b37ee01f71ae19c94a8934b80eeb2f677932,CVE-2015-1788,https://github.com/openssl/openssl/commit/4924b37ee01f71ae19c94a8934b80eeb2f677932,2015-06-12T19:59Z
1381,CWE-119,<S2SV_StartBug> v_fn_ptr . vf = vp8_mse16x16 ; <S2SV_EndBug> ,<S2SV_ModStart> vpx_mse16x16 <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1382,CWE-000,"<S2SV_StartBug> strlcpy ( rkpp . type , ""kpp"" , sizeof ( rkpp . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> ,torvalds@linux/f43f39958beb206b53292801e216d9b8a660f087,CVE-2018-19854,https://github.com/torvalds/linux/commit/f43f39958beb206b53292801e216d9b8a660f087,2018-12-04T16:29Z
1383,CWE-89,<S2SV_StartBug> int strindex = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> ,bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238,CVE-2012-0036,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,2012-04-13T20:55Z
1384,CWE-119,"<S2SV_StartBug> value = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( msg -> oob ) { <S2SV_EndBug> <S2SV_StartBug> nbits = bits & 7 ; <S2SV_EndBug> <S2SV_StartBug> Huff_offsetReceive ( msgHuff . decompressor . tree , & get , msg -> data , & msg -> bit ) ; <S2SV_EndBug> <S2SV_StartBug> value |= ( get << ( i + nbits ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( msg -> readcount > msg -> cursize ) { return 0 ; } <S2SV_ModStart> if ( msg -> readcount + ( bits >> 3 ) > msg -> cursize ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <S2SV_ModStart> if ( msg -> bit + nbits > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <S2SV_ModStart> , msg -> cursize << 3 <S2SV_ModStart> if ( msg -> bit > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } ",ioquake@ioq3/d2b1d124d4055c2fcbe5126863487c52fd58cca1,CVE-2017-11721,https://github.com/ioquake/ioq3/commit/d2b1d124d4055c2fcbe5126863487c52fd58cca1,2017-08-03T08:29Z
1385,CWE-416,"<S2SV_StartBug> int err = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> up_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> for ( idx = 0 ; idx < kcontrol -> count ; idx ++ , id . index ++ , id . numid ++ ) <S2SV_EndBug> ",<S2SV_ModStart> unsigned int count ; <S2SV_ModStart> count = kcontrol -> count ; <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/fd9f26e4eca5d08a27d12c0933fceef76ed9663d,CVE-2014-4653,https://github.com/torvalds/linux/commit/fd9f26e4eca5d08a27d12c0933fceef76ed9663d,2014-07-03T04:22Z
1386,CWE-000,<S2SV_StartBug> free_netdev ( net ) ; <S2SV_EndBug> ,<S2SV_ModStart> cancel_work_sync ( & dev -> kevent ) ; del_timer_sync ( & dev -> delay ) ; ,torvalds@linux/1666984c8625b3db19a9abc298931d35ab7bc64b,CVE-2016-3951,https://github.com/torvalds/linux/commit/1666984c8625b3db19a9abc298931d35ab7bc64b,2016-05-02T10:59Z
1387,CWE-190,<S2SV_StartBug> int overhead = 16 + 4 + strlen ( ns ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> int size = overhead ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> ,10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z
1388,CWE-200,"<S2SV_StartBug> save_text_from_text_view ( GTK_TEXT_VIEW ( textview ) , item_name ) ; <S2SV_EndBug> ",<S2SV_ModStart> { <S2SV_ModStart> problem_data_reload_from_dump_dir ( ) ; update_gui_state_from_problem_data ( 0 ) ; } ,abrt@libreport/257578a23d1537a2d235aaa2b1488ee4f818e360,CVE-2015-5302,https://github.com/abrt/libreport/commit/257578a23d1537a2d235aaa2b1488ee4f818e360,2015-12-07T18:59Z
1389,CWE-20,<S2SV_StartBug> last_id = ntohs ( * pid ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( plen < 0 ) return 0 ; ,aircrack-ng@aircrack-ng/da087238963c1239fdabd47dc1b65279605aca70,CVE-2014-8323,https://github.com/aircrack-ng/aircrack-ng/commit/da087238963c1239fdabd47dc1b65279605aca70,2017-10-17T14:29Z
1390,CWE-285,<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> else { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> struct iattr iattr ; retval = posix_acl_update_mode ( inode , & iattr . ia_mode , & acl ) ; if ( retval <S2SV_ModEnd> <S2SV_ModStart> if ( ! acl ) { value = NULL ; size = 0 ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z
1391,CWE-125,<S2SV_StartBug> if ( bin -> methods [ i ] . class_id > bin -> header . types_size - 1 ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,radare@radare2/ead645853a63bf83d8386702cad0cf23b31d7eeb,CVE-2017-6387,https://github.com/radare/radare2/commit/ead645853a63bf83d8386702cad0cf23b31d7eeb,2017-03-02T01:59Z
1392,CWE-264,<S2SV_StartBug> case NPPVformValue : <S2SV_EndBug> <S2SV_StartBug> type = RPC_TYPE_BOOLEAN ; <S2SV_EndBug> ,<S2SV_ModStart> : case NPPVpluginNativeAccessibleAtkPlugId <S2SV_ModStart> case NPPVpluginUrlRequestsDisplayedBool : case NPPVpluginWantsAllNetworkStreams : case NPPVpluginCancelSrcStream : case NPPVSupportsAdvancedKeyHandling : ,davidben@nspluginwrapper/7e4ab8e1189846041f955e6c83f72bc1624e7a98,CVE-2011-2486,https://github.com/davidben/nspluginwrapper/commit/7e4ab8e1189846041f955e6c83f72bc1624e7a98,2012-11-19T12:10Z
1393,CWE-89,"<S2SV_StartBug> int alloc = ( length ? length : ( int ) strlen ( string ) ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> CURLcode res ; <S2SV_EndBug> <S2SV_StartBug> res = Curl_convert_from_network ( handle , & in , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( res ) { <S2SV_EndBug> <S2SV_StartBug> * olen = strindex ; <S2SV_EndBug> ","<S2SV_ModStart> char * str = NULL ; size_t inputlen = length ; size_t outputlen <S2SV_ModEnd> <S2SV_ModStart> = Curl_urldecode <S2SV_ModEnd> <S2SV_ModStart> string , inputlen , & str , & outputlen , FALSE <S2SV_ModEnd> <S2SV_ModStart> return NULL <S2SV_ModEnd> <S2SV_ModStart> curlx_uztosi ( outputlen ) ; return str <S2SV_ModEnd> ",bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238,CVE-2012-0036,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,2012-04-13T20:55Z
1394,CWE-125,"<S2SV_StartBug> void nego_process_negotiation_response ( rdpNego * nego , wStream * s ) <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> FALSE <S2SV_ModStart> return TRUE ; ,FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z
1395,CWE-119,"<S2SV_StartBug> int i , target_bits_per_mb ; <S2SV_EndBug> <S2SV_StartBug> const int bits_per_mb_at_this_q = ( int ) vp9_rc_bits_per_mb ( cm -> frame_type , i , <S2SV_EndBug> <S2SV_StartBug> correction_factor ) ; <S2SV_EndBug> <S2SV_StartBug> return q ; <S2SV_EndBug> ","<S2SV_ModStart> , bits_per_mb_at_this_q <S2SV_ModStart> if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled && cpi -> svc . temporal_layer_id == 0 && cpi -> svc . spatial_layer_id == 0 ) { bits_per_mb_at_this_q = ( int ) vp9_cyclic_refresh_rc_bits_per_mb ( cpi , i , correction_factor ) ; } else { <S2SV_ModEnd> <S2SV_ModStart> , cm -> bit_depth ) ; } <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> oxcf . rc_mode == VPX_CBR && ( cpi -> rc . rc_1_frame * cpi -> rc . rc_2_frame == - 1 ) && cpi -> rc . q_1_frame != cpi -> rc . q_2_frame ) { q = clamp ( q , MIN ( cpi -> rc . q_1_frame , cpi -> rc . q_2_frame ) , MAX ( cpi -> rc . q_1_frame , cpi -> rc . q_2_frame ) ) ; } ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1396,CWE-20,<S2SV_StartBug> value |= TJA1101_CONFIG1_MII_MODE_RMII_25MHZ ; <S2SV_EndBug> ,<S2SV_ModStart> TJA1101_CONFIG1_MII_MODE_RMII_50MHZ_REF_CLK_OUT <S2SV_ModEnd> ,Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
1397,CWE-200,"<S2SV_StartBug> strlcpy ( rcipher . type , ""cipher"" , sizeof ( rcipher . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> ,torvalds@linux/f43f39958beb206b53292801e216d9b8a660f087,CVE-2018-19854,https://github.com/torvalds/linux/commit/f43f39958beb206b53292801e216d9b8a660f087,2018-12-04T16:29Z
1398,CWE-125,<S2SV_StartBug> if ( len < sizeof ( * prep ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> || ! ND_TTEST ( * prep ) ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,the-tcpdump-group@tcpdump/cc356512f512e7fa423b3674db4bb31dbe40ffec,CVE-2017-13014,https://github.com/the-tcpdump-group/tcpdump/commit/cc356512f512e7fa423b3674db4bb31dbe40ffec,2017-09-14T06:29Z
1399,CWE-119,"<S2SV_StartBug> mark_object ( & c -> object , NULL , NULL , data ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,git@git/de1e67d0703894cb6ea782e36abb63976ab07e60,CVE-2016-2315,https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60,2016-04-08T14:59Z
1400,CWE-476,"<S2SV_StartBug> freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! res ) return - EINVAL ; ,torvalds@linux/9903e41ae1f5d50c93f268ca3304d4d7c64b9311,CVE-2018-10074,https://github.com/torvalds/linux/commit/9903e41ae1f5d50c93f268ca3304d4d7c64b9311,2018-04-12T18:29Z
1401,CWE-125,"<S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> ",<S2SV_ModStart> i < NCH ( n ) && ,python@typed_ast/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,CVE-2019-19275,https://github.com/python/typed_ast/commit/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,2019-11-26T15:15Z
1402,CWE-119,"<S2SV_StartBug> MB_PREDICTION_MODE mode , TX_SIZE tx_size , <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , left_col , 64 ) ; <S2SV_EndBug> <S2SV_StartBug> once ( init_intra_pred_fn_ptrs ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( left_col , 129 , 64 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( x0 + 2 * bs <= frame_width ) { <S2SV_EndBug> <S2SV_StartBug> if ( right_available && bs == 4 ) { <S2SV_EndBug> <S2SV_StartBug> if ( right_available && bs == 4 ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( above_row , above_ref , bs ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bs == 4 && right_available ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> above_row [ - 1 ] = 127 ; <S2SV_EndBug> ","<S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> DECLARE_ALIGNED <S2SV_ModEnd> <S2SV_ModStart> [ 32 ] ) ; DECLARE_ALIGNED ( 16 , uint8_t , above_data [ 64 + 16 ] <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( extend_modes [ mode ] & NEED_LEFT ) { <S2SV_ModEnd> <S2SV_ModStart> else { memset ( left_col , 129 , bs ) ; } } if ( extend_modes [ mode ] & NEED_ABOVE ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memcpy ( above_row , above_ref , bs ) ; } else if ( x0 <S2SV_ModEnd> <S2SV_ModStart> memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + bs - frame_width ) ; } <S2SV_ModEnd> <S2SV_ModStart> memcpy ( above_row , above_ref , bs ) ; } } above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } else { memset ( above_row , 127 , bs ) ; above_row [ - 1 ] = 127 ; } } if ( extend_modes [ mode ] & NEED_ABOVERIGHT ) { if ( up_available ) { const uint8_t * above_ref = ref - ref_stride ; if ( xd -> mb_to_right_edge < 0 ) { if ( x0 + 2 * bs <= frame_width ) { if ( right_available && bs == 4 ) { memcpy ( above_row , above_ref , 2 * bs ) ; } else { memcpy ( above_row , above_ref , bs ) ; memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 + bs <= frame_width ) { const int r = frame_width - x0 ; if ( right_available && bs == 4 ) { memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { memcpy ( above_row , above_ref , bs ) ; memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 <= frame_width ) { const int r = frame_width - x0 ; memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } } else { <S2SV_ModEnd> <S2SV_ModStart> && left_available ) { const_above_row = above_ref ; } else { memcpy ( above_row , above_ref , bs ) ; if ( bs == 4 && right_available ) memcpy ( above_row + bs , above_ref + bs , bs ) ; else memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } <S2SV_ModEnd> <S2SV_ModStart> else { memset <S2SV_ModEnd> <S2SV_ModStart> } ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1403,CWE-000,<S2SV_StartBug> end ++ ; <S2SV_EndBug> ,<S2SV_ModStart> if ( pattern [ end ] == 0 ) break ; ,chromium@chromium/094c773bb6c144f07b004ff3d1886100f157f4f6,,https://github.com/chromium/chromium/commit/094c773bb6c144f07b004ff3d1886100f157f4f6,
1404,CWE-119,"<S2SV_StartBug> void ftoa_bounded_extra ( JsVarFloat val , char * str , size_t len , int radix , int fractionalDigits ) { <S2SV_EndBug> <S2SV_StartBug> if ( isnan ( val ) ) strncpy ( str , ""NaN"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( val < 0 ) strncpy ( str , ""-Infinity"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> else strncpy ( str , ""Infinity"" , len ) ; <S2SV_EndBug> ",<S2SV_ModStart> assert ( len > 9 ) ; <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,espruino@Espruino/0a7619875bf79877907205f6bee08465b89ff10b,CVE-2018-11595,https://github.com/espruino/Espruino/commit/0a7619875bf79877907205f6bee08465b89ff10b,2018-05-31T16:29Z
1405,CWE-190,"<S2SV_StartBug> jas_iccprof_t * jas_iccprof_createfrombuf ( uchar * buf , int len ) <S2SV_EndBug> ",<S2SV_ModStart> jas_uchar <S2SV_ModEnd> ,mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
1406,CWE-000,<S2SV_StartBug> ei -> cur_aio_dio = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> spin_lock_init ( & ei -> i_completed_io_lock ) ; ,torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z
1407,CWE-476,<S2SV_StartBug> BUG_ON ( ! thresholds ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & memcg -> thresholds_lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! thresholds -> primary ) goto unlock <S2SV_ModStart> unlock : ,torvalds@linux/371528caec553785c37f73fa3926ea0de84f986f,CVE-2012-1146,https://github.com/torvalds/linux/commit/371528caec553785c37f73fa3926ea0de84f986f,2012-05-17T11:00Z
1408,CWE-264,"<S2SV_StartBug> static struct ion_handle * ion_handle_get_by_id ( struct ion_client * client , <S2SV_EndBug> <S2SV_StartBug> handle = idr_find ( & client -> idr , id ) ; <S2SV_EndBug> <S2SV_StartBug> return handle ? handle : ERR_PTR ( - EINVAL ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ion_handle_get_by_id_nolock ( client , id <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,CVE-2016-9120,https://github.com/torvalds/linux/commit/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,2016-12-08T21:59Z
1409,CWE-119,"<S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_FRAME_MARKER , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> frame_type ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> show_frame ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> error_resilient_mode ) ; <S2SV_EndBug> <S2SV_StartBug> const COLOR_SPACE cs = UNKNOWN ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> profile > PROFILE_1 ) { <S2SV_EndBug> <S2SV_StartBug> assert ( cm -> profile == PROFILE_1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , get_ref_frame_idx ( cpi , ref_frame ) , <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> ref_frame_sign_bias [ ref_frame ] ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> allow_high_precision_mv ) ; <S2SV_EndBug> <S2SV_StartBug> fix_interp_filter ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> refresh_frame_context ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> frame_parallel_decoding_mode ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> frame_context_idx , FRAME_CONTEXTS_LOG2 ) ; <S2SV_EndBug> <S2SV_StartBug> encode_segmentation ( cpi , wb ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> MACROBLOCKD * const xd = & cpi -> td . mb . e_mbd ; vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> write_sync_code ( wb ) ; write_bitdepth_colorspace_sampling ( cm , wb ) ; write_frame_size ( cm , wb ) ; } else { if ( ! cm -> show_frame ) vpx_wb_write_bit ( wb , cm -> intra_only ) ; if ( ! cm -> error_resilient_mode ) vpx_wb_write_literal ( wb , cm -> reset_frame_context , 2 ) ; if ( cm -> intra_only ) { <S2SV_ModEnd> <S2SV_ModStart> PROFILE_0 ) { write_bitdepth_colorspace_sampling ( cm , wb ) ; } vpx_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ; write_frame_size ( cm , wb ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> assert ( get_ref_frame_map_idx ( cpi , ref_frame ) != INVALID_IDX ) ; vpx_wb_write_literal ( wb , get_ref_frame_map_idx <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> , cpi -> td . counts <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> cm , xd <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1410,CWE-134,<S2SV_StartBug> if ( bad_format ( optarg ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( bad_format ( optarg ) ) { <S2SV_EndBug> ,<S2SV_ModStart> bad_format_axis ( optarg ) ) { <S2SV_ModEnd> <S2SV_ModStart> bad_format_axis ( optarg ) ) { <S2SV_ModEnd> ,oetiker@rrdtool-1.x/85261a013112e278c90224033f5b0592ee387786,CVE-2014-6262,https://github.com/oetiker/rrdtool-1.x/commit/85261a013112e278c90224033f5b0592ee387786,2020-02-12T02:15Z
1411,CWE-20,"<S2SV_StartBug> p = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> <S2SV_StartBug> q = strchr ( p + 1 , '<S2SV_blank>' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> ,Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
1412,CWE-125,"<S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> ",<S2SV_ModStart> i < NCH ( n ) && ,python@typed_ast/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,CVE-2019-19275,https://github.com/python/typed_ast/commit/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,2019-11-26T15:15Z
1413,CWE-119,"<S2SV_StartBug> vpx_memcpy ( pc -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> ref_lf_deltas , 0 , sizeof ( xd -> ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> mode_lf_deltas , 0 , sizeof ( xd -> mode_lf_deltas ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1414,CWE-20,"<S2SV_StartBug> uint16_t n ; <S2SV_EndBug> <S2SV_StartBug> Enc624j600Context * context ; <S2SV_EndBug> <S2SV_StartBug> if ( enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_PKTCNT ) <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXRDPT , context -> nextPacket ) ; <S2SV_EndBug> <S2SV_StartBug> ( uint8_t * ) & context -> nextPacket , sizeof ( uint16_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & RSV_RECEIVED_OK ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> n = MIN ( n , ETH_MAX_FRAME_SIZE ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , context -> rxBuffer , n ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , context -> nextPacket - 2 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_PKTDEC ) ; <S2SV_EndBug> <S2SV_StartBug> nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ; <S2SV_EndBug> ","<S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> uint8_t header [ 8 ] ; <S2SV_ModStart> ENC624J600_ESTAT ) & ENC624J600_ESTAT_PKTCNT <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ERXRDPT <S2SV_ModEnd> <S2SV_ModStart> header <S2SV_ModEnd> <S2SV_ModStart> header ) ) ; context -> nextPacket = LOAD16LE ( header ) ; length = LOAD16LE ( header + 2 ) ; status = LOAD32LE ( header + 4 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_RSV_RECEIVED_OK <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ERXTAIL , <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ERXTAIL , <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ECON1 , ENC624J600_ECON1_PKTDEC <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> ",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
1415,CWE-119,<S2SV_StartBug> while ( ibuf [ ind ] == 0x01 ) { <S2SV_EndBug> ,<S2SV_ModStart> && i < gemsafe_cert_max ,OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad,CVE-2018-16391,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-477b7a40136bb418b10ce271c8664536,2018-09-03T14:29Z
1416,CWE-264,"<S2SV_StartBug> if ( vmx_set_msr ( vcpu , & msr ) != 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> kvm_set_msr <S2SV_ModEnd> ,torvalds@linux/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,CVE-2014-3610,https://github.com/torvalds/linux/commit/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,2014-11-10T11:55Z
1417,CWE-611,"<S2SV_StartBug> static VALUE read_memory ( VALUE klass , VALUE content ) <S2SV_EndBug> <S2SV_StartBug> xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt ( <S2SV_EndBug> <S2SV_StartBug> ) ; <S2SV_EndBug> <S2SV_StartBug> return rb_schema ; <S2SV_EndBug> ","<S2SV_ModStart> int argc , VALUE * argv , VALUE klass ) { VALUE content ; VALUE parse_options ; int parse_options_int ; xmlSchemaParserCtxtPtr ctx ; <S2SV_ModEnd> <S2SV_ModStart> VALUE errors ; VALUE rb_schema ; int scanned_args = 0 ; scanned_args = rb_scan_args ( argc , argv , ""11"" , & content , & parse_options ) ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( ""ParseOptions"" ) ) , rb_intern ( ""DEFAULT_SCHEMA"" ) ) ; } parse_options_int = ( int ) NUM2INT ( rb_funcall ( parse_options , rb_intern ( ""to_i"" ) , 0 ) ) ; <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart> rb_iv_set ( rb_schema , ""@parse_options"" , parse_options ) ; ",sparklemotion@nokogiri/9c87439d9afa14a365ff13e73adc809cb2c3d97b,CVE-2020-26247,https://github.com/sparklemotion/nokogiri/commit/9c87439d9afa14a365ff13e73adc809cb2c3d97b,2020-12-30T19:15Z
1418,CWE-119,"<S2SV_StartBug> unsigned int len ; <S2SV_EndBug> <S2SV_StartBug> struct au1200fb_device * fbdev = info -> par ; <S2SV_EndBug> <S2SV_StartBug> return io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vm_iomap_memory <S2SV_ModEnd> <S2SV_ModStart> fbdev -> fb_phys , fbdev -> fb_len <S2SV_ModEnd> ",torvalds@linux/7314e613d5ff9f0934f7a0f74ed7973b903315d1,CVE-2013-6763,https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1,2013-11-12T14:35Z
1419,CWE-295,"<S2SV_StartBug> errstr = parse_global_option ( CMD_SET_VALUE , config_opt , config_arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> & new_global_options , ",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z
1420,CWE-119,<S2SV_StartBug> out += 4 ; <S2SV_EndBug> <S2SV_StartBug> out += 4 ; <S2SV_EndBug> ,<S2SV_ModStart> 3 <S2SV_ModEnd> <S2SV_ModStart> 3 <S2SV_ModEnd> ,python-pillow@Pillow/ae453aa18b66af54e7ff716f4ccb33adca60afd4,CVE-2016-2533,https://github.com/python-pillow/Pillow/commit/ae453aa18b66af54e7ff716f4ccb33adca60afd4,2016-04-13T16:59Z
1421,CWE-399,"<S2SV_StartBug> if ( perf_event_overflow ( event , 1 , & data , regs ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
1422,CWE-119,<S2SV_StartBug> if ( ( unsigned int ) arg >= cdi -> capacity ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/9de4ee40547fd315d4a0ed1dd15a2fa3559ad707,CVE-2018-10940,https://github.com/torvalds/linux/commit/9de4ee40547fd315d4a0ed1dd15a2fa3559ad707,2018-05-09T17:29Z
1423,CWE-362,<S2SV_StartBug> err = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> if ( match -> type == type && <S2SV_EndBug> <S2SV_StartBug> out : <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> spin_lock ( & po -> bind_lock ) ; if ( po -> running && <S2SV_ModEnd> <S2SV_ModStart> spin_unlock ( & po -> bind_lock ) ; if ( err && ! refcount_read ( & match -> sk_ref ) ) { list_del ( & match -> list ) ; kfree ( match ) ; } ,torvalds@linux/008ba2a13f2d04c947adc536d19debb8fe66f110,CVE-2017-15649,https://github.com/torvalds/linux/commit/008ba2a13f2d04c947adc536d19debb8fe66f110,2017-10-19T22:29Z
1424,CWE-400,<S2SV_StartBug> if ( handle -> nmi ) { <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
1425,CWE-119,"<S2SV_StartBug> int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs ) <S2SV_EndBug> <S2SV_StartBug> while ( * s && len > 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( u >= PLANE_SIZE ) { <S2SV_EndBug> <S2SV_StartBug> u -= PLANE_SIZE ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = ( wchar_t ) ( SURROGATE_PAIR | <S2SV_EndBug> <S2SV_StartBug> ( ( u >> 10 ) & SURROGATE_BITS ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( u & SURROGATE_BITS ) ) ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = ( wchar_t ) u ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = * s ++ ; <S2SV_EndBug> ","<S2SV_ModStart> enum utf16_endian endian , <S2SV_ModStart> , int maxlen <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && maxlen > 0 && * s <S2SV_ModStart> s += size ; len -= size ; <S2SV_ModStart> if ( maxlen < 2 ) break ; <S2SV_ModStart> put_utf16 ( op ++ , <S2SV_ModEnd> <S2SV_ModStart> , endian ) ; put_utf16 ( op ++ , <S2SV_ModEnd> <S2SV_ModStart> , endian ) ; maxlen -= 2 <S2SV_ModEnd> <S2SV_ModStart> put_utf16 ( op ++ , u , endian ) ; maxlen -- ; } <S2SV_ModEnd> <S2SV_ModStart> put_utf16 ( op ++ , * s ++ , endian ) ; len -- ; maxlen <S2SV_ModEnd> ",torvalds@linux/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,CVE-2013-1773,https://github.com/torvalds/linux/commit/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,2013-02-28T19:55Z
1426,CWE-787,"<S2SV_StartBug> int v , i ; <S2SV_EndBug> <S2SV_StartBug> ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) ) <S2SV_EndBug> ","<S2SV_ModStart> if ( ! ( s -> state & PNG_IHDR ) ) { av_log ( avctx , AV_LOG_ERROR , ""trns<S2SV_blank>before<S2SV_blank>IHDR\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( s -> state & PNG_IDAT ) { av_log ( avctx , AV_LOG_ERROR , ""trns<S2SV_blank>after<S2SV_blank>IDAT\\n"" ) ; return AVERROR_INVALIDDATA ; } <S2SV_ModStart> || s -> bit_depth == 1 ",FFmpeg@FFmpeg/e477f09d0b3619f3d29173b2cd593e17e2d1978e,CVE-2017-7863,https://github.com/FFmpeg/FFmpeg/commit/e477f09d0b3619f3d29173b2cd593e17e2d1978e,2017-04-14T04:59Z
1427,CWE-399,"<S2SV_StartBug> print_as ( ""Notification<S2SV_blank>setup<S2SV_blank>failed,<S2SV_blank>won\'t<S2SV_blank>be<S2SV_blank>able<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>after<S2SV_blank>failure"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""Notification<S2SV_blank>setup<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>won\'t<S2SV_blank>be<S2SV_blank>able<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>after<S2SV_blank>failure"" <S2SV_ModEnd> ",ClusterLabs@pacemaker/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,CVE-2013-0281,https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,2013-11-23T11:55Z
1428,CWE-358,<S2SV_StartBug> dt -> vlan_id [ 0 ] = p -> vlan_id [ 0 ] ; <S2SV_EndBug> ,<S2SV_ModStart> proto = IP_GET_IPPROTO ( p ) ; dt -> ,inliniac@suricata/4a04f814b15762eb446a5ead4d69d021512df6f8,CVE-2017-7177,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,2017-03-18T20:59Z
1429,CWE-20,"<S2SV_StartBug> status = ksz8851ReadReg ( interface , KSZ8851_REG_RXFHSR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & RXFHSR_RXFV ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( status & ( RXFHSR_RXMR | RXFHSR_RXFTL | RXFHSR_RXRF | RXFHSR_RXCE ) ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_RXFHBCR ) & RXFHBCR_RXBC_MASK ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_RXFDPR , RXFDPR_RXFPAI ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851ClearBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_RRXEF ) ; <S2SV_EndBug> ","<S2SV_ModStart> KSZ8851_RXFHSR <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXFHSR_RXFV <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXFHSR_RXMR | KSZ8851_RXFHSR_RXFTL | KSZ8851_RXFHSR_RXRF | KSZ8851_RXFHSR_RXCE <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXFHBCR ) & KSZ8851_RXFHBCR_RXBC <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXFDPR , KSZ8851_RXFDPR_RXFPAI <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXQCR , KSZ8851_RXQCR_RRXEF <S2SV_ModEnd> ",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
1430,CWE-125,"<S2SV_StartBug> ast_for_funcdef_impl ( struct compiling * c , const node * n , <S2SV_EndBug> <S2SV_StartBug> asdl_seq * decorator_seq , int is_async ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> type_comment , LINENO ( n ) , <S2SV_EndBug> ","<S2SV_ModStart> n0 <S2SV_ModEnd> <S2SV_ModStart> bool <S2SV_ModEnd> <S2SV_ModStart> const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; <S2SV_ModStart> n0 ) , n0 <S2SV_ModEnd> ",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
1431,CWE-264,"<S2SV_StartBug> pgd = pgd_offset ( mm , 0xA0000 ) ; <S2SV_EndBug> <S2SV_StartBug> flush_tlb ( ) ; <S2SV_EndBug> ",<S2SV_ModStart> down_write ( & mm -> mmap_sem ) ; <S2SV_ModStart> up_write ( & mm -> mmap_sem ) ; ,torvalds@linux/4a1d704194a441bf83c636004a479e01360ec850,CVE-2012-1179,https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850,2012-05-17T11:00Z
1432,CWE-20,"<S2SV_StartBug> return aa_audit ( AUDIT_APPARMOR_DENIED , NULL , GFP_KERNEL , <S2SV_EndBug> ","<S2SV_ModStart> __aa_current_profile ( ) , GFP_KERNEL , & sa , NULL <S2SV_ModEnd> ",torvalds@linux/a5b2c5b2ad5853591a6cac6134cd0f599a720865,CVE-2011-3619,https://github.com/torvalds/linux/commit/a5b2c5b2ad5853591a6cac6134cd0f599a720865,2013-06-08T13:05Z
1433,CWE-20,<S2SV_StartBug> cstate = 0 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth || <S2SV_EndBug> ,"<S2SV_ModStart> siz -> comps = 0 ; <S2SV_ModStart> goto error ; } if ( ! siz -> width || ! siz -> height ) { jas_eprintf ( ""reference<S2SV_blank>grid<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\n"" ) ; goto error ; } if ( ! siz -> tilewidth || ! siz -> tileheight ) { jas_eprintf ( ""tile<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\n"" ) ; goto error ; } if ( ! siz -> numcomps || siz -> numcomps > 16384 ) { jas_eprintf ( ""number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( siz -> xoff >= siz -> width ) { jas_eprintf ( ""XOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( siz -> yoff >= siz -> height ) { jas_eprintf ( ""YOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( siz -> tilexoff > siz -> xoff || siz -> tilexoff + siz -> tilewidth <= siz -> xoff ) { jas_eprintf ( ""XTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( siz -> tileyoff > siz -> yoff || siz -> tileyoff + siz -> tileheight <= siz -> yoff ) { jas_eprintf ( ""YTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { goto error ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { goto error ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . hsamp ) ; goto error ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . vsamp ) ; goto error ; } siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { goto error ; } return 0 ; error : if ( siz -> comps ) { jas_free ( siz -> comps ) ; } <S2SV_ModStart>  <S2SV_ModEnd> ",mdadams@jasper/f7038068550fba0e41e1d0c355787f1dcd5bf330,CVE-2016-9394,https://github.com/mdadams/jasper/commit/f7038068550fba0e41e1d0c355787f1dcd5bf330,2017-03-23T18:59Z
1434,CWE-401,"<S2SV_StartBug> option_number += previous_option_number ; <S2SV_EndBug> <S2SV_StartBug> ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , <S2SV_EndBug> <S2SV_StartBug> ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , <S2SV_EndBug> <S2SV_StartBug> ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , <S2SV_EndBug> ","<S2SV_ModStart> if ( sn_coap_parser_add_u16_limit ( option_number , previous_option_number , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> <S2SV_ModStart> if ( dst_coap_msg_ptr -> options_list_ptr -> etag_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_ETAG<S2SV_blank>exists!"" ) ; return - 1 ; } <S2SV_ModStart> if ( dst_coap_msg_ptr -> options_list_ptr -> location_query_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_QUERY<S2SV_blank>exists!"" ) ; return - 1 ; } <S2SV_ModStart> if ( dst_coap_msg_ptr -> uri_path_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_PATH<S2SV_blank>exists!"" ) ; return - 1 ; } ",mjurczak@mbed-coap/4647a68e364401e81dbd370728127d844f221d93,CVE-2020-12887,https://github.com/mjurczak/mbed-coap/commit/4647a68e364401e81dbd370728127d844f221d93,2020-06-18T19:15Z
1435,CWE-125,"<S2SV_StartBug> if ( ( setup_ret = _WM_SetupMidiEvent ( xmi_mdi , xmi_data , 0 ) ) == 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> xmi_size , ",Mindwerks@wildmidi/ad6d7cf88d6673167ca1f517248af9409a9f1be1,CVE-2017-11664,https://github.com/Mindwerks/wildmidi/commit/ad6d7cf88d6673167ca1f517248af9409a9f1be1,2017-08-17T16:29Z
1436,CWE-17,"<S2SV_StartBug> total_len = iov_length ( iov , nr_segs ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> void * addr ; <S2SV_EndBug> <S2SV_StartBug> size_t chars = buf -> len ; <S2SV_EndBug> <S2SV_StartBug> int error , atomic ; <S2SV_EndBug> <S2SV_StartBug> atomic = ! iov_fault_in_pages_write ( iov , chars ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct iov_iter iter ; <S2SV_ModStart> ; iov_iter_init ( & iter , iov , nr_segs , total_len , 0 ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; size_t written <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> written = copy_page_to_iter ( buf -> page , buf -> offset , chars , & iter ) ; if ( unlikely ( written < chars ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> ",torvalds@linux/637b58c2887e5e57850865839cc75f59184b23d1,CVE-2015-1805,https://github.com/torvalds/linux/commit/637b58c2887e5e57850865839cc75f59184b23d1,2015-08-08T10:59Z
1437,CWE-787,"<S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> <S2SV_StartBug> index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ; <S2SV_EndBug> <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> if ( k < 0 ) continue <S2SV_ModEnd> ,ImageMagick@ImageMagick/19651f3db63fa1511ed83a348c4c82fa553f8d01,CVE-2019-13308,https://github.com/ImageMagick/ImageMagick/commit/19651f3db63fa1511ed83a348c4c82fa553f8d01,2019-07-05T01:15Z
1438,CWE-20,<S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,libreswan@libreswan/2899351224fe2940aec37d7656e1e392c0fe07f0,CVE-2013-7294,https://github.com/libreswan/libreswan/commit/2899351224fe2940aec37d7656e1e392c0fe07f0,2014-01-16T05:05Z
1439,CWE-362,"<S2SV_StartBug> p_fm_config_conx_hdlt hdl ; <S2SV_EndBug> <S2SV_StartBug> goto die_clean ; <S2SV_EndBug> <S2SV_StartBug> goto die_clean ; <S2SV_EndBug> <S2SV_StartBug> return commandList [ i ] . cmdPtr ( hdl , commandList [ i ] . mgr , ( argc - optind ) , & argv [ optind ] ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> die_clean : <S2SV_EndBug> <S2SV_StartBug> return res ; <S2SV_EndBug> ",<S2SV_ModStart> = NULL <S2SV_ModStart> cleanup <S2SV_ModEnd> <S2SV_ModStart> cleanup <S2SV_ModEnd> <S2SV_ModStart> res = <S2SV_ModEnd> <S2SV_ModStart> goto cleanup ; <S2SV_ModStart> cleanup : if ( hdl ) { if ( hdl -> sm_hdl ) { if ( hdl -> sm_hdl -> c_path [ 0 ] ) unlink ( hdl -> sm_hdl -> c_path ) ; } if ( hdl -> pm_hdl ) { if ( hdl -> pm_hdl -> c_path [ 0 ] ) unlink ( hdl -> pm_hdl -> c_path ) ; } if ( hdl -> fe_hdl ) { if ( hdl -> fe_hdl -> c_path [ 0 ] ) unlink ( hdl -> fe_hdl -> c_path ) ; } <S2SV_ModEnd> <S2SV_ModStart> } ,01org@opa-fm/c5759e7b76f5bf844be6c6641cc1b356bbc83869,CVE-2015-5232,https://github.com/01org/opa-fm/commit/c5759e7b76f5bf844be6c6641cc1b356bbc83869,2017-06-07T20:29Z
1440,CWE-190,"<S2SV_StartBug> if ( jas_init ( ) ) { <S2SV_EndBug> <S2SV_StartBug> infile = 0 ; <S2SV_EndBug> <S2SV_StartBug> case OPT_MAXMEM : <S2SV_EndBug> <S2SV_StartBug> if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( numcmpts = jas_image_numcmpts ( image ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) { <S2SV_EndBug> <S2SV_StartBug> printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n"" , fmtname , numcmpts , width , height , depth , ( long ) jas_image_rawsize ( image ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t max_samples ; char optstr [ 32 ] ; <S2SV_ModStart> max_samples = 64 * JAS_MEBI ; <S2SV_ModStart> OPT_MAXSAMPLES : max_samples = strtoull ( jas_optarg , 0 , 10 ) ; break ; case <S2SV_ModStart> snprintf ( optstr , sizeof ( optstr ) , ""max_samples=%-zu"" , max_samples ) ; <S2SV_ModStart> optstr <S2SV_ModEnd> <S2SV_ModStart> fmtname = jas_image_fmttostr ( fmtid ) ) ) { jas_eprintf ( ""format<S2SV_blank>name<S2SV_blank>lookup<S2SV_blank>failed\\n"" ) ; return EXIT_FAILURE ; } if ( ! ( <S2SV_ModStart> printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n"" , fmtname <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( long , <S2SV_ModEnd> <S2SV_ModStart> ) ",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
1441,CWE-20,"<S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> ",<S2SV_ModStart> false ,system@bt/37c88107679d36c419572732b4af6e18bb2f7dce,CVE-2016-3760,https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce,2016-07-11T02:00Z
1442,CWE-287,<S2SV_StartBug> cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <S2SV_EndBug> ,<S2SV_ModStart> || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ,cherokee@webserver/fbda667221c51f0aa476a02366e0cf66cb012f88,CVE-2014-4668,https://github.com/cherokee/webserver/commit/fbda667221c51f0aa476a02366e0cf66cb012f88,2014-07-02T04:14Z
1443,CWE-119,"<S2SV_StartBug> for ( row = 0 ; row < height ; row ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( ( RAW ( row , col ) = pred [ col & 1 ] ) > 4098 && col < width ) <S2SV_EndBug> ",<S2SV_ModStart> raw_height <S2SV_ModEnd> <S2SV_ModStart> && row < height ,LibRaw@LibRaw/f1394822a0152ceed77815eafa5cac4e8baab10a,CVE-2017-16909,https://github.com/LibRaw/LibRaw/commit/f1394822a0152ceed77815eafa5cac4e8baab10a,2018-12-07T22:29Z
1444,CWE-787,<S2SV_StartBug> if ( len < needed ) { <S2SV_EndBug> ,<S2SV_ModStart> || len < sizeof ( nl -> dev ) ,torvalds@linux/4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a,CVE-2021-31916,https://github.com/torvalds/linux/commit/4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a,2021-05-06T17:15Z
1445,CWE-125,<S2SV_StartBug> ExitLoop : <S2SV_EndBug> ,<S2SV_ModStart> quantum_info = DestroyQuantumInfo ( quantum_info ) ; ,ImageMagick@ImageMagick/b173a352397877775c51c9a0e9d59eb6ce24c455,CVE-2016-10070,https://github.com/ImageMagick/ImageMagick/commit/b173a352397877775c51c9a0e9d59eb6ce24c455,2017-03-03T18:59Z
1446,CWE-20,"<S2SV_StartBug> int idx , ret = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; <S2SV_EndBug> <S2SV_StartBug> hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { <S2SV_EndBug> ","<S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> || hlist_empty ( <S2SV_ModEnd> <S2SV_ModStart> ) ) { pr_warn_once ( ""no<S2SV_blank>route<S2SV_blank>for<S2SV_blank>guest_irq<S2SV_blank>%u/%u<S2SV_blank>(broken<S2SV_blank>user<S2SV_blank>space?)\\n"" , guest_irq , irq_rt -> nr_rt_entries ) ; goto out ; } hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] ",torvalds@linux/3a8b0677fc6180a467e26cc32ce6b0c09a32f9bb,CVE-2017-1000252,https://github.com/torvalds/linux/commit/3a8b0677fc6180a467e26cc32ce6b0c09a32f9bb,2017-09-26T05:29Z
1447,CWE-416,<S2SV_StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <S2SV_EndBug> ,"<S2SV_ModStart> bfqd , ",torvalds@linux/2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9,CVE-2020-12657,https://github.com/torvalds/linux/commit/2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9,2020-05-05T07:15Z
1448,CWE-119,<S2SV_StartBug> return rold -> umin_value == 0 && <S2SV_EndBug> ,<S2SV_ModStart> false <S2SV_ModEnd> ,torvalds@linux/179d1c5602997fef5a940c6ddcf31212cbfebd14,CVE-2017-17855,https://github.com/torvalds/linux/commit/179d1c5602997fef5a940c6ddcf31212cbfebd14,2017-12-27T17:08Z
1449,CWE-200,"<S2SV_StartBug> BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; memset ( sa , 0 , sizeof ( * sa ) ",torvalds@linux/9344a972961d1a6d2c04d9008b13617bcb6ec2ef,CVE-2012-6545,https://github.com/torvalds/linux/commit/9344a972961d1a6d2c04d9008b13617bcb6ec2ef,2013-03-15T20:55Z
1450,CWE-476,<S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> ,<S2SV_ModStart> || ! SecIsValidHandle ( handle ) ,FreeRDP@FreeRDP/0773bb9303d24473fe1185d85a424dfe159aff53,CVE-2013-4119,https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53,2016-10-03T21:59Z
1451,CWE-125,<S2SV_StartBug> length += PRIMARY_DRAWING_ORDER_FIELD_BYTES [ orderInfo -> orderType ] ; <S2SV_EndBug> ,"<S2SV_ModStart> get_primary_drawing_order_field_bytes ( <S2SV_ModEnd> <S2SV_ModStart> , NULL ) <S2SV_ModEnd> ",FreeRDP@FreeRDP/733ee3208306b1ea32697b356c0215180fc3f049,CVE-2020-11095,https://github.com/FreeRDP/FreeRDP/commit/733ee3208306b1ea32697b356c0215180fc3f049,2020-06-22T22:15Z
1452,CWE-20,"<S2SV_StartBug> olddentry = ovl_dentry_upper ( old ) ; <S2SV_EndBug> <S2SV_StartBug> newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , <S2SV_EndBug> <S2SV_StartBug> err = PTR_ERR ( newdentry ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( newdentry ) ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( olddentry -> d_parent != old_upperdir ) <S2SV_EndBug> <S2SV_StartBug> if ( newdentry -> d_parent != new_upperdir ) <S2SV_EndBug> <S2SV_StartBug> goto out_dput ; <S2SV_EndBug> <S2SV_StartBug> out_unlock : <S2SV_EndBug> ","<S2SV_ModStart> lookup_one_len ( old <S2SV_ModEnd> <S2SV_ModStart> old_upperdir , old <S2SV_ModEnd> <S2SV_ModStart> olddentry <S2SV_ModEnd> <S2SV_ModStart> olddentry <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> != ovl_dentry_upper ( old ) ) goto out_dput_old ; newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , new -> d_name . len ) ; err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out_dput_old ; err = - ESTALE ; if ( ovl_dentry_upper ( new ) ) { if ( opaquedir ) { if ( newdentry != opaquedir <S2SV_ModEnd> <S2SV_ModStart> } else { if ( newdentry != ovl_dentry_upper ( new ) <S2SV_ModEnd> <S2SV_ModStart> } } else { new_create = true ; if ( ! d_is_negative ( newdentry ) && ( ! new_opaque || ! ovl_is_whiteout ( newdentry ) ) ) goto out_dput ; } <S2SV_ModStart> out_dput_old : dput ( olddentry ) ; ",torvalds@linux/11f3710417d026ea2f4fcf362d866342c5274185,CVE-2016-6197,https://github.com/torvalds/linux/commit/11f3710417d026ea2f4fcf362d866342c5274185,2016-08-06T20:59Z
1453,CWE-125,<S2SV_StartBug> # if 0 <S2SV_EndBug> <S2SV_StartBug> p ++ ; s ++ ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,kkos@oniguruma/690313a061f7a4fa614ec5cc8368b4f2284e059b,CVE-2017-9224,https://github.com/kkos/oniguruma/commit/690313a061f7a4fa614ec5cc8368b4f2284e059b,2017-05-24T15:29Z
1454,CWE-119,<S2SV_StartBug> for ( plane = 0 ; plane < MAX_MB_PLANE ; plane ++ ) <S2SV_EndBug> ,<S2SV_ModStart> ++ plane <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1455,CWE-20,"<S2SV_StartBug> int copied , error = - EINVAL ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
1456,CWE-59,"<S2SV_StartBug> return mount_entry_on_generic ( mntent , path ) ; <S2SV_EndBug> ","<S2SV_ModStart> , rootfs ",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z
1457,CWE-20,<S2SV_StartBug> return fd ; <S2SV_EndBug> ,<S2SV_ModStart> sr -> fd_is_fdt = MK_TRUE ; ,monkey@monkey/b2d0e6f92310bb14a15aa2f8e96e1fb5379776dd,CVE-2014-5336,https://github.com/monkey/monkey/commit/b2d0e6f92310bb14a15aa2f8e96e1fb5379776dd,2014-08-26T14:55Z
1458,CWE-862,"<S2SV_StartBug> static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <S2SV_EndBug> <S2SV_StartBug> kenter ( ""%p"" , dest_keyring ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int ret ; <S2SV_ModStart> bool do_perm_check = true ; <S2SV_ModStart> { do_perm_check = false ; break ; } <S2SV_ModEnd> <S2SV_ModStart> if ( dest_keyring && do_perm_check ) { ret = key_permission ( make_key_ref ( dest_keyring , 1 ) , KEY_NEED_WRITE ) ; if ( ret ) { key_put ( dest_keyring ) ; return ret ; } } <S2SV_ModStart> 0 ",torvalds@linux/4dca6ea1d9432052afb06baf2e3ae78188a4410b,CVE-2017-17807,https://github.com/torvalds/linux/commit/4dca6ea1d9432052afb06baf2e3ae78188a4410b,2017-12-20T23:29Z
1459,CWE-119,"<S2SV_StartBug> static void nonrd_pick_sb_modes ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> xd -> mi [ 0 ] -> mbmi . sb_type = bsize ; <S2SV_EndBug> <S2SV_StartBug> vp9_pick_inter_mode ( cpi , x , tile , mi_row , mi_col , <S2SV_EndBug> ","<S2SV_ModStart> TileDataEnc * tile_data , MACROBLOCK * const x , int mi_row , int mi_col , RD_COST * rd_cost , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_ModEnd> <S2SV_ModStart> tile_info = & tile_data -> tile_info <S2SV_ModEnd> <S2SV_ModStart> MB_MODE_INFO * mbmi ; <S2SV_ModStart> tile_info , x , mi_row , mi_col , bsize ) ; mbmi = & <S2SV_ModEnd> <S2SV_ModStart> ; mbmi -> sb_type = bsize ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) x -> rdmult = vp9_cyclic_refresh_get_rdmult ( cpi -> cyclic_refresh ) ; if ( cm -> frame_type == KEY_FRAME ) hybrid_intra_mode_search ( cpi , x , rd_cost , bsize , ctx ) ; else if ( segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) set_mode_info_seg_skip ( x , cm -> tx_mode , rd_cost , bsize ) ; else if ( bsize >= BLOCK_8X8 ) <S2SV_ModEnd> <S2SV_ModStart> tile_data , mi_row , mi_col , rd_cost , bsize , ctx ) ; else vp9_pick_inter_mode_sub8x8 ( cpi , x , mi_row , mi_col , rd_cost , bsize , ctx ) ; duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; if ( rd_cost -> rate == INT_MAX ) vp9_rd_cost_reset ( rd_cost ) ; ctx -> rate = rd_cost -> rate ; ctx -> dist = rd_cost -> dist <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1460,CWE-119,<S2SV_StartBug> dev -> hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ; <S2SV_EndBug> <S2SV_StartBug> dev -> features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/48900cb6af4282fa0fb6ff4d72a81aa3dadb5c39,CVE-2015-5156,https://github.com/torvalds/linux/commit/48900cb6af4282fa0fb6ff4d72a81aa3dadb5c39,2015-10-19T10:59Z
1461,CWE-787,"<S2SV_StartBug> * err = superblockRead ( & reader , & reader . superblock ) ; <S2SV_EndBug> ",<S2SV_ModStart> reader . recursive_counter = 0 ; ,hoene@libmysofa/2e6fac6ab6156dae8e8c6f417741388084b70d6f,CVE-2019-20016,https://github.com/hoene/libmysofa/commit/2e6fac6ab6156dae8e8c6f417741388084b70d6f,2019-12-27T02:15Z
1462,CWE-908,<S2SV_StartBug> if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) <S2SV_EndBug> ,"<S2SV_ModStart> ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; ",ImageMagick@ImageMagick/1c358ffe0049f768dd49a8a889c1cbf99ac9849b,CVE-2017-9098,https://github.com/ImageMagick/ImageMagick/commit/1c358ffe0049f768dd49a8a889c1cbf99ac9849b,2017-05-19T19:29Z
1463,CWE-119,"<S2SV_StartBug> int tmp ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( buf , buffer , count ) ) <S2SV_EndBug> ","<S2SV_ModStart> size_t size ; int tmp ; size = min ( count , sizeof ( buf ) ) <S2SV_ModEnd> <S2SV_ModStart> size <S2SV_ModEnd> ",torvalds@linux/201f99f170df14ba52ea4c52847779042b7a623b,CVE-2013-4512,https://github.com/torvalds/linux/commit/201f99f170df14ba52ea4c52847779042b7a623b,2013-11-12T14:35Z
1464,CWE-189,<S2SV_StartBug> pMap -> ranges = malloc ( sizeof ( MappedRange ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( pMap -> ranges == NULL ) { LOGE ( ""malloc<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; munmap ( memPtr , length ) ; return - 1 ; } ",bootable@recovery/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad,CVE-2016-0849,https://android.googlesource.com/platform/bootable/recovery/+/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad,2016-04-18T00:59Z
1465,CWE-476,<S2SV_StartBug> switch ( dip -> di_format ) { <S2SV_EndBug> ,"<S2SV_ModStart> fa = xfs_dinode_verify_fork ( dip , mp , XFS_DATA_FORK ) ; if ( fa ) return fa ; break ; case 0 : break ; default : return __this_address ; } if ( XFS_DFORK_Q ( dip ) ) { fa = xfs_dinode_verify_fork ( dip , mp , XFS_ATTR_FORK ) ; if ( fa ) return fa ; <S2SV_ModEnd> ",torvalds@linux/23fcb3340d033d9f081e21e6c12c2db7eaa541d3,CVE-2018-13095,https://github.com/torvalds/linux/commit/23fcb3340d033d9f081e21e6c12c2db7eaa541d3,2018-07-03T10:29Z
1466,CWE-119,"<S2SV_StartBug> if ( ( ret = s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ) < 0 ) <S2SV_EndBug> ",<S2SV_ModStart> x >= 16 || c >= 256 ) { return AVERROR_INVALIDDATA ; } if ( ,FFmpeg@FFmpeg/2171dfae8c065878a2e130390eb78cf2947a5b69,CVE-2017-9995,https://github.com/FFmpeg/FFmpeg/commit/2171dfae8c065878a2e130390eb78cf2947a5b69,2017-06-28T06:29Z
1467,CWE-416,<S2SV_StartBug> jas_tvparser_destroy ( tvp ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> jas_tvparser_destroy ( tvp ) ; ,mdadams@jasper/df5d2867e8004e51e18b89865bc4aa69229227b3,CVE-2015-5221,https://github.com/mdadams/jasper/commit/df5d2867e8004e51e18b89865bc4aa69229227b3,2017-07-25T18:29Z
1468,CWE-119,<S2SV_StartBug> if ( ( ( flags & VP8_EFLAG_NO_UPD_GF ) && ( flags & VP8_EFLAG_FORCE_GF ) ) <S2SV_EndBug> <S2SV_StartBug> round = ( vpx_codec_pts_t ) 1000000 <S2SV_EndBug> ,"<S2SV_ModStart> ! flags ) { flags = ctx -> control_frame_flags ; } ctx -> control_frame_flags = 0 ; res = set_reference_and_update ( ctx , flags ) ; <S2SV_ModEnd> <S2SV_ModStart> 10000000 <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1469,CWE-125,"<S2SV_StartBug> BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( unsigned char ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> double <S2SV_ModEnd> ,ImageMagick@ImageMagick/1bc1fd0ff8c555841c78829217ac81fa0598255d,CVE-2016-10071,https://github.com/ImageMagick/ImageMagick/commit/1bc1fd0ff8c555841c78829217ac81fa0598255d,2017-03-02T21:59Z
1470,CWE-362,<S2SV_StartBug> if ( ! head ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> WARN_ON_ONCE ( <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/12ca6ad2e3a896256f086497a7c7406a547ee373,CVE-2015-8963,https://github.com/torvalds/linux/commit/12ca6ad2e3a896256f086497a7c7406a547ee373,2016-11-16T05:59Z
1471,CWE-674,"<S2SV_StartBug> u_int atype , const u_char * pptr , u_int len ) <S2SV_EndBug> <S2SV_StartBug> if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) <S2SV_EndBug> ","<S2SV_ModStart> , const unsigned attr_set_level <S2SV_ModStart> attr_set_level == 10 ) ND_PRINT ( ( ndo , ""(too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>levels,<S2SV_blank>not<S2SV_blank>recursing)"" ) ) ; else if ( <S2SV_ModStart> , attr_set_level + 1 ",the-tcpdump-group@tcpdump/af2cf04a9394c1a56227c2289ae8da262828294a,CVE-2018-16300,https://github.com/the-tcpdump-group/tcpdump/commit/af2cf04a9394c1a56227c2289ae8da262828294a,2019-10-03T16:15Z
1472,CWE-352,"<S2SV_StartBug> ""<td<S2SV_blank>style=\'color:red;\'><form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Stop<S2SV_blank>Monit<S2SV_blank>http<S2SV_blank>server?<S2SV_blank>"" <S2SV_EndBug> <S2SV_StartBug> ""<td><form<S2SV_blank>method=GET<S2SV_blank>action=\'_viewlog\'>View<S2SV_blank>Monit<S2SV_blank>logfile?<S2SV_blank><input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'></form></td>"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""<td<S2SV_blank>style=\'color:red;\'>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Stop<S2SV_blank>Monit<S2SV_blank>http<S2SV_blank>server?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'stop\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'>"" ""</form>"" ""</td>"" , res -> token ) ; StringBuffer_append ( res -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Force<S2SV_blank>validate<S2SV_blank>now?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'validate\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'>"" ""</form>"" ""</td>"" , res -> token <S2SV_ModEnd> <S2SV_ModStart> ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\'_viewlog\'>View<S2SV_blank>Monit<S2SV_blank>logfile?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'>"" ""</form>"" ""</td>"" , res -> token <S2SV_ModEnd> ",tildeslash@monit/c6ec3820e627f85417053e6336de2987f2d863e3,CVE-2016-7067,https://bitbucket.org/tildeslash/monit/commit/c6ec3820e627f85417053e6336de2987f2d863e3,2018-09-10T14:29Z
1473,CWE-119,"<S2SV_StartBug> vpx_memcpy ( dest , source , dest_width ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1474,CWE-120,"<S2SV_StartBug> snprintf ( constr1 , 32 , ""%lld"" , deadline ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,keepkey@keepkey-firmware/e49d45594002d4d3fbc1f03488e6dfc0a0a65836,CVE-2021-31616,https://github.com/keepkey/keepkey-firmware/commit/e49d45594002d4d3fbc1f03488e6dfc0a0a65836,2021-05-06T13:15Z
1475,CWE-000,<S2SV_StartBug> assert ( n >= 0 && n < 32 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( n < 0 || n >= 32 ) { return - 1 ; } <S2SV_ModEnd> ,mdadams@jasper/1e84674d95353c64e5c4c0e7232ae86fd6ea813b,CVE-2016-9391,https://github.com/mdadams/jasper/commit/1e84674d95353c64e5c4c0e7232ae86fd6ea813b,2017-03-23T18:59Z
1476,CWE-000,"<S2SV_StartBug> & len , & iovec , compat ) ; <S2SV_EndBug> <S2SV_StartBug> len , iovec ) ; <S2SV_EndBug> <S2SV_StartBug> iov_iter_init ( & iter , rw , iovec , nr_segs , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> , & iter <S2SV_ModStart> , & iter <S2SV_ModStart> ret = iter_op ( req , & iter ) ; } else { ret = rw_op ( req , iter . iov , iter . <S2SV_ModEnd> ",torvalds@linux/4c185ce06dca14f5cea192f5a2c981ef50663f2b,CVE-2015-8830,https://github.com/torvalds/linux/commit/4c185ce06dca14f5cea192f5a2c981ef50663f2b,2016-05-02T10:59Z
1477,CWE-20,<S2SV_StartBug> if ( ! el ) <S2SV_EndBug> ,"<S2SV_ModStart> { if ( c -> rbytes > 1024 ) { char * ptr = c -> rcurr ; while ( * ptr == '<S2SV_blank>' ) { ++ ptr ; } if ( strcmp ( ptr , ""get<S2SV_blank>"" ) && strcmp ( ptr , ""gets<S2SV_blank>"" ) ) { conn_set_state ( c , conn_closing ) ; return 1 ; } } return 0 ; } <S2SV_ModEnd> ",memcached@memcached/75cc83685e103bc8ba380a57468c8f04413033f9,CVE-2010-1152,https://github.com/memcached/memcached/commit/75cc83685e103bc8ba380a57468c8f04413033f9,2010-04-12T18:30Z
1478,CWE-400,"<S2SV_StartBug> USB_DT_OTG , ( void * * ) & desc ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( * desc ) ",torvalds@linux/704620afc70cf47abb9d6a1a57f3825d2bca49cf,CVE-2018-20169,https://github.com/torvalds/linux/commit/704620afc70cf47abb9d6a1a57f3825d2bca49cf,2018-12-17T07:29Z
1479,CWE-119,<S2SV_StartBug> if ( iad_num == USB_MAXIADS ) { <S2SV_EndBug> <S2SV_StartBug> ( struct usb_interface_assoc_descriptor <S2SV_EndBug> ,"<S2SV_ModStart> struct usb_interface_assoc_descriptor * d ; d = ( struct usb_interface_assoc_descriptor * ) header ; if ( d -> bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE ) { dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>interface<S2SV_blank>association<S2SV_blank>descriptor<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>skipping\\n"" , cfgno , d -> bLength ) ; continue ; } <S2SV_ModStart> d <S2SV_ModEnd> ",torvalds@linux/bd7a3fe770ebd8391d1c7d072ff88e9e76d063eb,CVE-2017-16531,https://github.com/torvalds/linux/commit/bd7a3fe770ebd8391d1c7d072ff88e9e76d063eb,2017-11-04T01:29Z
1480,CWE-190,<S2SV_StartBug> if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> ,"<S2SV_ModStart> info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; if ( replace ) { err = snd_ctl_remove_user_ctl ( file , & info -> id ) ; if ( err ) return err ; } if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/82262a46627bebb0febcc26664746c25cef08563,CVE-2014-4655,https://github.com/torvalds/linux/commit/82262a46627bebb0febcc26664746c25cef08563,2014-07-03T04:22Z
1481,CWE-285,"<S2SV_StartBug> exit_client ( client_p , client_p , client_p , ""Mixing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>protocol"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; return 0 ; } if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) { exit_client ( client_p , client_p , client_p , ""Malformed<S2SV_blank>AUTHENTICATE"" ",charybdis-ircd@charybdis/818a3fda944b26d4814132cee14cfda4ea4aa824,CVE-2016-7143,https://github.com/charybdis-ircd/charybdis/commit/818a3fda944b26d4814132cee14cfda4ea4aa824,2016-09-21T14:25Z
1482,CWE-284,<S2SV_StartBug> if ( ctxt -> rip_relative ) <S2SV_EndBug> ,<S2SV_ModStart> && likely ( ctxt -> memopp ) ,torvalds@linux/d9092f52d7e61dd1557f2db2400ddb430e85937e,CVE-2016-8630,https://github.com/torvalds/linux/commit/d9092f52d7e61dd1557f2db2400ddb430e85937e,2016-11-28T03:59Z
1483,CWE-400,"<S2SV_StartBug> mmap_event -> event_id . header . size , 0 , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
1484,CWE-264,<S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> ,<S2SV_ModStart> ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ,torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z
1485,CWE-119,<S2SV_StartBug> distortion = vp8_variance16x16 <S2SV_EndBug> ,<S2SV_ModStart> vpx_variance16x16 <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1486,CWE-20,"<S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ECON2 , ECON2_ETHEN | ECON2_STRCH ) ; <S2SV_EndBug> <S2SV_StartBug> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR1 ) ; <S2SV_EndBug> <S2SV_StartBug> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR2 ) ; <S2SV_EndBug> <S2SV_StartBug> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR3 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MAADR1 , temp ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MAADR2 , temp ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MAADR3 , temp ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXST , ENC624J600_RX_BUFFER_START ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXFCON , ERXFCON_HTEN | <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT2 , 0x0000 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , 0x0000 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , 0x0000 ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 , <S2SV_EndBug> <S2SV_StartBug> enc624j600WritePhyReg ( interface , ENC624J600_PHY_REG_PHANA , PHANA_ADPAUS0 | <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EIE , EIE_INTIE | <S2SV_EndBug> <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_RXEN ) ; <S2SV_EndBug> ","<S2SV_ModStart> ENC624J600_ECON2 , ENC624J600_ECON2_ETHEN | ENC624J600_ECON2_STRCH <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MAADR1 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MAADR2 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MAADR3 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MAADR1 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MAADR2 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MAADR3 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ERXST <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ERXTAIL <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ERXFCON , ENC624J600_ERXFCON_HTEN | ENC624J600_ERXFCON_CRCEN | ENC624J600_ERXFCON_RUNTEN | ENC624J600_ERXFCON_UCEN | ENC624J600_ERXFCON_BCEN ) ; enc624j600WriteReg ( interface , ENC624J600_EHT1 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EHT2 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EHT3 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EHT4 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT ) ; enc624j600WriteReg ( interface , ENC624J600_MAMXFL <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_PHANA , ENC624J600_PHANA_ADPAUS0 | ENC624J600_PHANA_AD100FD | ENC624J600_PHANA_AD100 | ENC624J600_PHANA_AD10FD | ENC624J600_PHANA_AD10 | ENC624J600_PHANA_ADIEEE_DEFAULT ) ; enc624j600WriteReg ( interface , ENC624J600_EIR <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EIE , ENC624J600_EIE_INTIE | ENC624J600_EIE_LINKIE | ENC624J600_EIE_PKTIE | ENC624J600_EIE_TXIE | ENC624J600_EIE_TXABTIE <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ECON1 , ENC624J600_ECON1_RXEN <S2SV_ModEnd> ",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
1487,CWE-119,<S2SV_StartBug> maxlen = strlen ( ( char * ) psf -> header ) ; <S2SV_EndBug> <S2SV_StartBug> start = ( ( char * ) psf -> header ) + maxlen ; <S2SV_EndBug> <S2SV_StartBug> maxlen = sizeof ( psf -> header ) - maxlen ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex = strlen ( ( char * ) psf -> header ) ; <S2SV_EndBug> ,<S2SV_ModStart> . ptr <S2SV_ModStart> . ptr <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> . len <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr ,erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z
1488,CWE-119,<S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct arpt_entry ) && <S2SV_EndBug> <S2SV_StartBug> t -> verdict < 0 && unconditional ( & e -> arp ) ) || <S2SV_EndBug> ,<S2SV_ModStart> unconditional ( e <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z
1489,CWE-119,<S2SV_StartBug> if ( ! job_id || ! prev_hash || ! coinbase1 || ! coinbase2 || ! bbversion || ! nbit || ! ntime ) { <S2SV_EndBug> <S2SV_StartBug> if ( job_id ) <S2SV_EndBug> ,<S2SV_ModStart> valid_hex ( job_id ) || ! valid_hex ( prev_hash ) || ! valid_hex ( coinbase1 ) || ! valid_hex ( coinbase2 ) || ! valid_hex ( bbversion ) || ! valid_hex ( nbit ) || ! valid_hex ( ntime ) ) { free <S2SV_ModEnd> <S2SV_ModStart> ; free ( coinbase1 ) ; <S2SV_ModEnd> ,ckolivas@cgminer/e1c5050734123973b99d181c45e74b2cbb00272e,CVE-2014-4501,https://github.com/ckolivas/cgminer/commit/e1c5050734123973b99d181c45e74b2cbb00272e,2014-07-23T14:55Z
1490,CWE-119,<S2SV_StartBug> if ( ctx -> priv -> alg_priv ) <S2SV_EndBug> <S2SV_StartBug> ctx -> iface -> destroy ( ctx -> priv -> alg_priv ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( vpx_codec_alg_priv_t * ) <S2SV_ModStart>  <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1491,CWE-20,<S2SV_StartBug> return 1 ; <S2SV_EndBug> ,<S2SV_ModStart> case EXIT_REASON_INVEPT : ,torvalds@linux/bfd0a56b90005f8c8a004baf407ad90045c2b11e,CVE-2014-3645,https://github.com/torvalds/linux/commit/bfd0a56b90005f8c8a004baf407ad90045c2b11e,2014-11-10T11:55Z
1492,CWE-119,"<S2SV_StartBug> sf -> adaptive_rd_thresh = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> sf -> less_rectangular_check = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD <S2SV_EndBug> <S2SV_StartBug> sf -> auto_mv_step_size = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> subpel_iters_per_step = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; <S2SV_EndBug> <S2SV_StartBug> sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD <S2SV_EndBug> <S2SV_StartBug> if ( MIN ( cm -> width , cm -> height ) >= 720 ) <S2SV_EndBug> <S2SV_StartBug> sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_LOW_MOTION ; <S2SV_EndBug> <S2SV_StartBug> if ( MIN ( cm -> width , cm -> height ) >= 720 ) <S2SV_EndBug> <S2SV_StartBug> sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ; <S2SV_EndBug> <S2SV_StartBug> sf -> disable_split_mask = DISABLE_ALL_SPLIT ; <S2SV_EndBug> <S2SV_StartBug> sf -> adaptive_rd_thresh = 4 ; <S2SV_EndBug> <S2SV_StartBug> sf -> mode_search_skip_flags |= FLAG_SKIP_COMP_REFMISMATCH | <S2SV_EndBug> <S2SV_StartBug> sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_ALL ; <S2SV_EndBug> <S2SV_StartBug> sf -> use_lp32x32fdct = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> partition_search_type = FIXED_PARTITION ; <S2SV_EndBug> <S2SV_StartBug> sf -> search_method = HEX ; <S2SV_EndBug> <S2SV_StartBug> sf -> intra_y_mode_mask [ i ] = INTRA_DC_ONLY ; <S2SV_EndBug> <S2SV_StartBug> sf -> intra_uv_mode_mask [ i ] = INTRA_DC_ONLY ; <S2SV_EndBug> ",<S2SV_ModStart> const int boosted = frame_is_boosted ( cpi ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ( cpi -> twopass . fr_content_type == FC_GRAPHICS_ANIMATION ) || vp9_internal_image_edge ( cpi ) ) { sf -> use_square_partition_only = ! frame_is_boosted ( cpi ) ; } else { <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mv . <S2SV_ModStart> mv . <S2SV_ModStart> ; sf -> tx_size_search_breakout = 1 ; sf -> partition_search_breakout_rate_thr = 80 <S2SV_ModStart> frame_is_boosted <S2SV_ModEnd> <S2SV_ModStart> sf -> reference_masking = cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ? 1 : 0 ; sf -> mode_search_skip_flags = <S2SV_ModEnd> <S2SV_ModStart> frame_type == KEY_FRAME ) ? 0 : <S2SV_ModEnd> <S2SV_ModStart> allow_partition_search_skip = 1 <S2SV_ModEnd> <S2SV_ModStart> sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; sf -> tx_size_search_method = frame_is_intra_only ( cm ) ? USE_FULL_RD : USE_LARGESTALL ; sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED ; sf -> adaptive_pred_interp_filter = 0 ; sf -> adaptive_mode_search = 1 ; sf -> cb_partition_search = ! boosted ; sf -> cb_pred_filter_search = 1 ; sf -> alt_ref_search_fp = 1 <S2SV_ModEnd> <S2SV_ModStart> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC ; sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC ; sf -> adaptive_interp_filter_search <S2SV_ModEnd> <S2SV_ModStart> mv . search_method = BIGDIA ; sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED_MORE <S2SV_ModEnd> <S2SV_ModStart> if ( cm -> frame_type != KEY_FRAME ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ; sf -> use_fast_coef_costing = 1 ; sf -> motion_field_mode_search = ! boosted ; sf -> partition_search_breakout_rate_thr = 300 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mv . <S2SV_ModStart> INTRA_DC <S2SV_ModEnd> <S2SV_ModStart> INTRA_DC ; } sf -> partition_search_breakout_rate_thr = 500 ; sf -> mv . reduce_first_step_size = 1 ; sf -> simple_model_rd_from_var = 1 <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1493,CWE-20,"<S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> ",<S2SV_ModStart> _dh <S2SV_ModEnd> ,torvalds@linux/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,CVE-2014-2523,https://github.com/torvalds/linux/commit/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,2014-03-24T16:40Z
1494,CWE-200,"<S2SV_StartBug> if ( copy_from_user ( & tx32 , utp , sizeof ( struct compat_timex ) ) ) <S2SV_EndBug> ","<S2SV_ModStart> memset ( txc , 0 , sizeof ( struct timex ) ) ; ",torvalds@linux/0a0b98734479aa5b3c671d5190e86273372cab95,CVE-2018-11508,https://github.com/torvalds/linux/commit/0a0b98734479aa5b3c671d5190e86273372cab95,2018-05-28T13:29Z
1495,CWE-284,"<S2SV_StartBug> int ret = poll ( pfds , ts [ h ] . poll_count , - 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ,system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
1496,CWE-416,<S2SV_StartBug> int goodsize = inuse + ( inuse / 8 ) + 2 * EXTRA_STACK ; <S2SV_EndBug> ,<S2SV_ModStart> BASIC_STACK_SIZE <S2SV_ModEnd> ,lua@lua/6298903e35217ab69c279056f925fb72900ce0b7,CVE-2020-15888,https://github.com/lua/lua/commit/6298903e35217ab69c279056f925fb72900ce0b7,2020-07-21T22:15Z
1497,CWE-125,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> ,python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
1498,CWE-125,"<S2SV_StartBug> const char * raw , * s = STR ( CHILD ( n , 0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> char * s = """" ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const ,python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
1499,CWE-119,"<S2SV_StartBug> int is_keyframe_qaunt_set = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( ""encoding-mode"" , option_name ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( ""layers"" , option_name ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( ""quantizers"" , option_name ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! is_keyframe_qaunt_set ) { <S2SV_EndBug> <S2SV_StartBug> is_keyframe_qaunt_set = 1 ; <S2SV_EndBug> <S2SV_StartBug> return res ; <S2SV_EndBug> ","<S2SV_ModStart> SvcInternal_t * const si = get_svc_internal ( svc_ctx ) ; vpx_codec_err_t res = VPX_CODEC_OK ; int i , alt_ref_enabled = 0 <S2SV_ModEnd> <S2SV_ModStart> ""spatial-layers"" , option_name ) == 0 ) { svc_ctx -> spatial_layers = atoi ( option_value ) ; } else if ( strcmp ( ""temporal-layers"" , option_name ) == 0 ) { svc_ctx -> temporal_layers = atoi ( option_value ) ; } else if ( strcmp ( ""scale-factors"" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , SCALE_FACTOR , option_value , si -> svc_params . scaling_factor_num , si -> svc_params . scaling_factor_den <S2SV_ModEnd> <S2SV_ModStart> ""max-quantizers"" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . max_quantizers , NULL <S2SV_ModEnd> <S2SV_ModStart> ""min-quantizers"" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . min_quantizers , NULL <S2SV_ModEnd> <S2SV_ModStart> } else if ( strcmp ( ""auto-alt-refs"" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , AUTO_ALT_REF , option_value , si -> enable_auto_alt_ref , NULL <S2SV_ModEnd> <S2SV_ModStart> } else if ( strcmp ( ""bitrates"" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , BITRATE , option_value , si -> bitrates , NULL ) ; if ( res != VPX_CODEC_OK ) break ; } else if ( strcmp ( ""multi-frame-contexts"" , option_name ) == 0 ) { si -> use_multiple_frame_contexts = atoi ( option_value ) <S2SV_ModEnd> <S2SV_ModStart> for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) { if ( si -> svc_params . max_quantizers [ i ] > MAX_QUANTIZER || si -> svc_params . max_quantizers [ i ] < 0 || si -> svc_params . min_quantizers [ i ] > si -> svc_params . max_quantizers [ i ] || si -> svc_params . min_quantizers [ i ] < 0 ) res = VPX_CODEC_INVALID_PARAM ; } if ( si -> use_multiple_frame_contexts && ( svc_ctx -> spatial_layers > 3 || svc_ctx -> spatial_layers * svc_ctx -> temporal_layers > 4 ) ) res = VPX_CODEC_INVALID_PARAM ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) alt_ref_enabled += si -> enable_auto_alt_ref [ i ] ; if ( alt_ref_enabled > REF_FRAMES - svc_ctx -> spatial_layers ) { svc_log ( svc_ctx , SVC_LOG_ERROR , ""svc:<S2SV_blank>auto<S2SV_blank>alt<S2SV_blank>ref:<S2SV_blank>Maxinum<S2SV_blank>%d(REF_FRAMES<S2SV_blank>-<S2SV_blank>layers)<S2SV_blank>layers<S2SV_blank>could"" ""enabled<S2SV_blank>auto<S2SV_blank>alt<S2SV_blank>reference<S2SV_blank>frame,<S2SV_blank>but<S2SV_blank>%<S2SV_blank>layers<S2SV_blank>are<S2SV_blank>enabled\\n"" , REF_FRAMES - svc_ctx -> spatial_layers , alt_ref_enabled ) ; res = VPX_CODEC_INVALID_PARAM ; } ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1500,CWE-416,<S2SV_StartBug> if ( ! head ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> WARN_ON_ONCE ( <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/12ca6ad2e3a896256f086497a7c7406a547ee373,CVE-2015-8963,https://github.com/torvalds/linux/commit/12ca6ad2e3a896256f086497a7c7406a547ee373,2016-11-16T05:59Z
1501,CWE-119,<S2SV_StartBug> for ( s += 9 ; isspace ( * s ) ; s ++ ) ; <S2SV_EndBug> <S2SV_StartBug> while ( * t && ! isspace ( * t ) ) t ++ ; <S2SV_EndBug> ,<S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) ,kohler@t1utils/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33,CVE-2015-3905,https://github.com/kohler/t1utils/commit/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33,2015-06-08T14:59Z
1502,CWE-000,<S2SV_StartBug> if ( ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_LAST_PWD_CHANGE ) || <S2SV_EndBug> <S2SV_StartBug> if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) <S2SV_EndBug> <S2SV_StartBug> if ( entry == ( kadm5_principal_ent_t ) NULL ) <S2SV_EndBug> ,<S2SV_ModStart> entry == NULL ) return EINVAL ; if ( <S2SV_ModStart> entry -> policy == NULL <S2SV_ModEnd> <S2SV_ModStart> ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK <S2SV_ModEnd> ,krb5@krb5/b863de7fbf080b15e347a736fdda0a82d42f4f6b,CVE-2015-8630,https://github.com/krb5/krb5/commit/b863de7fbf080b15e347a736fdda0a82d42f4f6b,2016-02-13T02:59Z
1503,CWE-119,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> <S2SV_StartBug> for ( plane = 1 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) <S2SV_EndBug> ,<S2SV_ModStart> [ plane ] && frame -> linesize <S2SV_ModStart> && frame -> linesize [ plane ] ,FFmpeg@FFmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,CVE-2013-4263,https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,2013-11-23T17:55Z
1504,CWE-119,"<S2SV_StartBug> fprintf ( mvs , ""\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> mb_index = 0 ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1505,CWE-190,<S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> ,python@cpython/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,CVE-2018-20406,https://github.com/python/cpython/commit/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd,2018-12-23T23:29Z
1506,CWE-119,"
","
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
1507,CWE-125,<S2SV_StartBug> if ( data [ 1 ] <= 127 ) <S2SV_EndBug> <S2SV_StartBug> else op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ; <S2SV_EndBug> <S2SV_StartBug> op -> fail = addr + op -> size ; <S2SV_EndBug> ,<S2SV_ModStart> len > 1 ) { if ( <S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> } } else { op -> jump = addr ; } ,radare@radare2/bbb4af56003c1afdad67af0c4339267ca38b1017,CVE-2018-12322,https://github.com/radare/radare2/commit/bbb4af56003c1afdad67af0c4339267ca38b1017,2018-06-13T16:29Z
1508,CWE-416,"<S2SV_StartBug> do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) , <S2SV_EndBug> ",<S2SV_ModStart> if ( imp_dbh -> pmysql ) ,perl5-dbi@DBD-mysql/a56ae87a4c1c1fead7d09c3653905841ccccf1cc,CVE-2014-9906,https://github.com/perl5-dbi/DBD-mysql/commit/a56ae87a4c1c1fead7d09c3653905841ccccf1cc,2016-08-19T21:59Z
1509,CWE-284,"<S2SV_StartBug> if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( ioctl ( slot -> fd , FIONREAD , & size ) == 0 && size ) ) <S2SV_EndBug> <S2SV_StartBug> pthread_mutex_unlock ( & slot_lock ) ; <S2SV_EndBug> <S2SV_StartBug> BTA_JvRfcommWrite ( slot -> rfc_handle , slot -> id ) ; <S2SV_EndBug> <S2SV_StartBug> if ( need_close || ioctl ( slot -> fd , FIONREAD , & size ) != 0 || ! size ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> { <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ,system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
1510,CWE-20,"<S2SV_StartBug> struct ieee_802_11_phdr phdr ; <S2SV_EndBug> <S2SV_StartBug> dissector_try_uint ( wtap_encap_dissector_table , <S2SV_EndBug> <S2SV_StartBug> wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; int wtap_encap ; struct eth_phdr eth ; void * phdrp <S2SV_ModStart> wtap_encap = wtap_pcap_encap_to_wtap_encap ( dlt ) ; switch ( wtap_encap ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdrp = & eth ; break ; default : phdrp = NULL ; break ; } dissector_try_uint_new <S2SV_ModEnd> <S2SV_ModStart> wtap_encap <S2SV_ModEnd> <S2SV_ModStart> , TRUE , phdrp ",wireshark@wireshark/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7,CVE-2016-5358,https://github.com/wireshark/wireshark/commit/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7,2016-08-07T16:59Z
1511,CWE-190,<S2SV_StartBug> sh = s_malloc ( hdrlen + initlen + 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart> assert ( initlen + hdrlen + 1 > initlen ) ; ,redis@redis/c992857618db99776917f10bf4f2345a5fdc78b0,CVE-2021-21309,https://github.com/redis/redis/commit/c992857618db99776917f10bf4f2345a5fdc78b0,2021-02-26T22:15Z
1512,CWE-787,"<S2SV_StartBug> static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , <S2SV_EndBug> <S2SV_StartBug> UINT32 tempWidth ; <S2SV_EndBug> <S2SV_StartBug> for ( y = 0 ; y < context -> height ; y ++ ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! context || data || ( scanline == 0 ) ) return FALSE <S2SV_ModStart> if ( context -> priv -> PlaneBuffersLength < rw * scanline ) return FALSE ; if ( rw < scanline * 2 ) return FALSE ; <S2SV_ModStart> return TRUE ; ,FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z
1513,CWE-399,<S2SV_StartBug> while ( offset < end_offset ) <S2SV_EndBug> <S2SV_StartBug> return offset ; <S2SV_EndBug> ,<S2SV_ModStart> > 0 && offset <S2SV_ModStart> { <S2SV_ModStart> } ,wireshark@wireshark/b4d16b4495b732888e12baf5b8a7e9bf2665e22b,CVE-2016-5350,https://github.com/wireshark/wireshark/commit/b4d16b4495b732888e12baf5b8a7e9bf2665e22b,2016-08-07T16:59Z
1514,CWE-401,<S2SV_StartBug> return ERR_PTR ( - EINVAL ) ; <S2SV_EndBug> ,<S2SV_ModStart> { ret = - EINVAL ; goto out_free ; } <S2SV_ModEnd> ,torvalds@linux/96c5c6e6a5b6db592acae039fed54b5c8844cd35,CVE-2019-19072,https://github.com/torvalds/linux/commit/96c5c6e6a5b6db592acae039fed54b5c8844cd35,2019-11-18T06:15Z
1515,CWE-119,"<S2SV_StartBug> const RATE_CONTROL * rc = & cpi -> rc ; <S2SV_EndBug> <S2SV_StartBug> target = ( ( cpi -> oxcf . starting_buffer_level / 2 ) > INT_MAX ) <S2SV_EndBug> <S2SV_StartBug> ? INT_MAX : ( int ) ( cpi -> oxcf . starting_buffer_level / 2 ) ; <S2SV_EndBug> <S2SV_StartBug> int kf_boost = MAX ( initial_boost , ( int ) ( 2 * cpi -> output_framerate - 16 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc -> frames_since_key < cpi -> output_framerate / 2 ) { <S2SV_EndBug> <S2SV_StartBug> ( cpi -> output_framerate / 2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> target = ( ( 16 + kf_boost ) * rc -> av_per_frame_bandwidth ) >> 4 ; <S2SV_EndBug> ","<S2SV_ModStart> ; const VP9EncoderConfig * oxcf = & cpi -> oxcf ; const SVC * const svc = & cpi -> svc <S2SV_ModStart> rc -> <S2SV_ModEnd> <S2SV_ModStart> rc -> starting_buffer_level / 2 ) ; } else { int kf_boost = 32 ; double framerate = cpi -> framerate ; if ( svc -> number_temporal_layers > 1 && oxcf -> rc_mode == VPX_CBR ) { const int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , svc -> temporal_layer_id , svc -> number_temporal_layers ) ; const LAYER_CONTEXT * lc = & svc -> layer_context [ layer ] ; framerate = lc -> framerate ; } <S2SV_ModEnd> <S2SV_ModStart> kf_boost , ( int ) ( 2 * framerate <S2SV_ModEnd> <S2SV_ModStart> framerate <S2SV_ModEnd> <S2SV_ModStart> framerate <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1516,CWE-399,<S2SV_StartBug> update_db_bp_intercept ( vcpu ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/cbdb967af3d54993f5814f1cee0ed311a055377d,CVE-2015-8104,https://github.com/torvalds/linux/commit/cbdb967af3d54993f5814f1cee0ed311a055377d,2015-11-16T11:59Z
1517,CWE-119,"<S2SV_StartBug> static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data ) <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> indx , data , size , 100 ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> const <S2SV_ModStart> u8 * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> kfree ( buf ) ; ",torvalds@linux/5593523f968bc86d42a035c6df47d5e0979b5ace,CVE-2017-8068,https://github.com/torvalds/linux/commit/5593523f968bc86d42a035c6df47d5e0979b5ace,2017-04-23T05:59Z
1518,CWE-119,"<S2SV_StartBug> static TX_MODE read_tx_mode ( vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> TX_MODE tx_mode = vp9_read_literal ( r , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> tx_mode += vp9_read_bit ( r ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_read_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_read_bit <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1519,CWE-125,<S2SV_StartBug> register const struct hello6 * hellop = ( const struct hello6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; ND_TCHECK_32BITS ( & hellop -> hello_options ,the-tcpdump-group@tcpdump/88b2dac837e81cf56dce05e6e7b5989332c0092d,CVE-2017-13036,https://github.com/the-tcpdump-group/tcpdump/commit/88b2dac837e81cf56dce05e6e7b5989332c0092d,2017-09-14T06:29Z
1520,CWE-129,<S2SV_StartBug> if ( * ( unsigned char * ) data > 1 ) <S2SV_EndBug> ,<S2SV_ModStart> datalen != 1 ) return - EINVAL ; if ( ,torvalds@linux/c4c07b4d6fa1f11880eab8e076d3d060ef3f55fc,CVE-2019-9162,https://github.com/torvalds/linux/commit/c4c07b4d6fa1f11880eab8e076d3d060ef3f55fc,2019-02-25T23:29Z
1521,CWE-119,"<S2SV_StartBug> rc -> uwbd . task = kthread_run ( uwbd , rc , ""uwbd"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc -> uwbd . task == NULL ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> struct task_struct * <S2SV_ModEnd> <S2SV_ModStart> IS_ERR ( task ) ) { <S2SV_ModStart> = NULL ; <S2SV_ModEnd> <S2SV_ModStart> } else { rc -> uwbd . task = task ; <S2SV_ModEnd> <S2SV_ModStart> } ,torvalds@linux/bbf26183b7a6236ba602f4d6a2f7cade35bba043,CVE-2017-16526,https://github.com/torvalds/linux/commit/bbf26183b7a6236ba602f4d6a2f7cade35bba043,2017-11-04T01:29Z
1522,CWE-674,"<S2SV_StartBug> # line 96 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1045 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 97 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 98 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 99 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 100 ""re_grammar.y"" <S2SV_EndBug> ","<S2SV_ModStart> 104 <S2SV_ModEnd> <S2SV_ModStart> 1053 <S2SV_ModEnd> <S2SV_ModStart> 105 ""re_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1059 <S2SV_ModEnd> <S2SV_ModStart> 106 ""re_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1065 <S2SV_ModEnd> <S2SV_ModStart> 107 ""re_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1071 <S2SV_ModEnd> <S2SV_ModStart> 108 ""re_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1077 <S2SV_ModEnd> ",VirusTotal@yara/925bcf3c3b0a28b5b78e25d9efda5c0bf27ae699,CVE-2017-9304,https://github.com/VirusTotal/yara/commit/925bcf3c3b0a28b5b78e25d9efda5c0bf27ae699,2017-05-31T04:29Z
1523,CWE-125,<S2SV_StartBug> * ptr = ( char ) ( ( existing & ~ ( mask << bitIdx ) ) | ( ( col & mask ) << bitIdx ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ; ,espruino@Espruino/8a44b04b584b3d3ab1cb68fed410f7ecb165e50e,CVE-2018-11592,https://github.com/espruino/Espruino/commit/8a44b04b584b3d3ab1cb68fed410f7ecb165e50e,2018-05-31T16:29Z
1524,CWE-119,"<S2SV_StartBug> MACROBLOCKD * xd = args -> xd ; <S2SV_EndBug> <S2SV_StartBug> struct macroblock_plane * p = & cpi -> mb . plane [ plane ] ; <S2SV_EndBug> <S2SV_StartBug> const int16_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> common . fc . coef_probs [ tx_size ] [ type ] [ ref ] ; <S2SV_EndBug> <S2SV_StartBug> cpi -> common . counts . eob_branch [ tx_size ] [ type ] [ ref ] ; <S2SV_EndBug> <S2SV_StartBug> int aoff , loff ; <S2SV_EndBug> <S2SV_StartBug> add_token ( & t , coef_probs [ band [ c ] ] [ pt ] , <S2SV_EndBug> <S2SV_StartBug> vp9_dct_value_tokens_ptr [ v ] . extra , <S2SV_EndBug> <S2SV_StartBug> ( uint8_t ) vp9_dct_value_tokens_ptr [ v ] . token , <S2SV_EndBug> <S2SV_StartBug> vp9_pt_energy_class [ vp9_dct_value_tokens_ptr [ v ] . token ] ; <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * const td = args -> td ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd <S2SV_ModEnd> <S2SV_ModStart> x -> <S2SV_ModEnd> <S2SV_ModStart> tran_low_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; const int segment_id = mbmi -> segment_id ; const int16_t * scan , * nb ; const scan_order * so ; const int ref = is_inter_block ( mbmi ) ; unsigned int ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = td -> rd_counts . coef_counts [ tx_size ] [ type ] [ ref ] ; vpx_prob <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> td -> counts -> <S2SV_ModEnd> <S2SV_ModStart> int16_t token ; EXTRABIT extra ; <S2SV_ModStart> vp9_get_token_extra ( v , & token , & extra ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1525,CWE-674,<S2SV_StartBug> SrcList * pSrc = pSelect -> pSrc ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( pSelect -> selFlags & SF_View ) return WRC_Prune ,sqlite@sqlite/38096961c7cd109110ac21d3ed7dad7e0cb0ae06,CVE-2019-19645,https://github.com/sqlite/sqlite/commit/38096961c7cd109110ac21d3ed7dad7e0cb0ae06,2019-12-09T16:15Z
1526,CWE-000,<S2SV_StartBug> if ( shmflg & SHM_RND ) <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) && addr >= shmlba ,torvalds@linux/95e91b831f87ac8e1f8ed50c14d709089b4e01b8,CVE-2017-5669,https://github.com/torvalds/linux/commit/95e91b831f87ac8e1f8ed50c14d709089b4e01b8,2017-02-24T15:59Z
1527,CWE-404,"<S2SV_StartBug> serv = svc_create ( & nfs4_callback_program , NFS4_CALLBACK_BUFSIZE , sv_ops ) ; <S2SV_EndBug> ",<S2SV_ModStart> svc_create_pooled <S2SV_ModEnd> ,torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z
1528,CWE-347,"<S2SV_StartBug> void pointZZ_pMul ( PointZZ_p * rop , const PointZZ_p * point , const mpz_t scalar , const CurveZZ_p * curve ) { <S2SV_EndBug> ",<S2SV_ModStart> if ( pointZZ_pIsIdentityElement ( point ) ) { return pointZZ_pSetToIdentityElement ( rop ) ; } ,AntonKueltz@fastecdsa/e592f106edd5acf6dacedfab2ad16fe6c735c9d1,CVE-2020-12607,https://github.com/AntonKueltz/fastecdsa/commit/e592f106edd5acf6dacedfab2ad16fe6c735c9d1,2020-06-02T21:15Z
1529,CWE-772,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> <S2SV_StartBug> exit_func : <S2SV_EndBug> ",<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : <S2SV_ModStart>  <S2SV_ModEnd> ,krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z
1530,CWE-264,<S2SV_StartBug> case NPNVSupportsWindowless : <S2SV_EndBug> ,<S2SV_ModStart> : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling ,davidben@nspluginwrapper/7e4ab8e1189846041f955e6c83f72bc1624e7a98,CVE-2011-2486,https://github.com/davidben/nspluginwrapper/commit/7e4ab8e1189846041f955e6c83f72bc1624e7a98,2012-11-19T12:10Z
1531,CWE-284,"<S2SV_StartBug> ssize_t ret = sendmsg ( socket -> fd , & msg , MSG_DONTWAIT ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ,system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
1532,CWE-284,"<S2SV_StartBug> do ret = send ( sock_fd , buf , s , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ,system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
1533,CWE-264,"<S2SV_StartBug> for ( xIter = crm_first_attr ( xml ) ; xIter != NULL ; xIter = xIter -> next ) { <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( prop_name , XML_ATTR_ID ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> char * path = xml_get_path ( xml ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> char * path = xml_get_path ( xml ) ; <S2SV_ModStart> && strstr ( path , ""/"" XML_CIB_TAG_ACLS ""/"" ) == NULL <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> free ( path ) ; ",ClusterLabs@pacemaker/84ac07c7d02b3badd708b1ef13a2159dede70715,CVE-2015-1867,https://github.com/ClusterLabs/pacemaker/commit/84ac07c,2015-08-12T14:59Z
1534,CWE-119,"<S2SV_StartBug> sprintf ( charbuf , ""%s/%s.html"" , dirout , rootname ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( charbuf , ""%s/%s-links.html"" , dirout , rootname ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( charbuf , ""%s_thumb_%03d"" , rootname , index ) ; <S2SV_EndBug> ","<S2SV_ModStart> snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> ",DanBloomberg@leptonica/c1079bb8e77cdd426759e466729917ca37a3ed9f,CVE-2018-7247,https://github.com/DanBloomberg/leptonica/commit/c1079bb8e77cdd426759e466729917ca37a3ed9f,2018-02-19T18:29Z
1535,CWE-119,<S2SV_StartBug> static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) { <S2SV_EndBug> <S2SV_StartBug> return ( const SvcInternal * ) svc_ctx -> internal ; <S2SV_EndBug> ,<S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> <S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1536,CWE-264,"<S2SV_StartBug> spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> ) ; hctx = q -> mq_ops -> map_queue ( q , flush_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , flush_rq -> tag , fq -> orig_rq ",torvalds@linux/0048b4837affd153897ed1222283492070027aa9,CVE-2015-9016,https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9,2018-04-05T18:29Z
1537,CWE-787,"<S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; <S2SV_EndBug> ","<S2SV_ModStart> uint32 length ; struct stream packet = * s <S2SV_ModEnd> <S2SV_ModStart> if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""mcs_parse_domain_params(),<S2SV_blank>consume<S2SV_blank>domain<S2SV_blank>params<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } ",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z
1538,CWE-704,<S2SV_StartBug> if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) { <S2SV_EndBug> ,<S2SV_ModStart> && Z_TYPE_PP ( ptr ) == IS_ARRAY ,m6w6@ext-http/17137d4ab1ce81a2cee0fae842340a344ef3da83,CVE-2016-7398,https://github.com/m6w6/ext-http/commit/17137d4ab1ce81a2cee0fae842340a344ef3da83,2019-09-06T19:15Z
1539,CWE-119,"<S2SV_StartBug> char buffer [ 80 ] ; <S2SV_EndBug> <S2SV_StartBug> _y4m -> vpx_bps = 12 ; <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( _y4m -> chroma_type , ""420"" ) == 0 || <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( _y4m -> chroma_type , ""420mpeg2"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> _y4m -> vpx_bps = 16 ; <S2SV_EndBug> <S2SV_StartBug> _y4m -> convert = y4m_convert_null ; <S2SV_EndBug> <S2SV_StartBug> _y4m -> vpx_bps = 24 ; <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( _y4m -> chroma_type , ""444alpha"" ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( only_420 ) { <S2SV_EndBug> <S2SV_StartBug> _y4m -> dst_c_dec_h = 2 ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Unknown<S2SV_blank>chroma<S2SV_blank>sampling<S2SV_blank>type:<S2SV_blank>%s\\n"" , _y4m -> chroma_type ) ; <S2SV_EndBug> <S2SV_StartBug> _y4m -> dst_buf_sz = _y4m -> pic_w * _y4m -> pic_h <S2SV_EndBug> <S2SV_StartBug> _y4m -> dst_buf = ( unsigned char * ) malloc ( _y4m -> dst_buf_sz ) ; <S2SV_EndBug> <S2SV_StartBug> _y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz ) ; <S2SV_EndBug> ","<S2SV_ModStart> = { 0 } <S2SV_ModStart> bps <S2SV_ModEnd> <S2SV_ModStart> _y4m -> bit_depth = 8 ; <S2SV_ModStart> ""420p10"" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; _y4m -> bit_depth = 10 ; _y4m -> bps = 15 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42016 ; if ( only_420 ) { fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>420p10<S2SV_blank>to<S2SV_blank>420jpeg\\n"" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , ""420p12"" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; _y4m -> bit_depth = 12 ; _y4m -> bps = 18 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42016 ; if ( only_420 ) { fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>420p12<S2SV_blank>to<S2SV_blank>420jpeg\\n"" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , <S2SV_ModStart> bps <S2SV_ModEnd> <S2SV_ModStart> ; } } else if ( strcmp ( _y4m -> chroma_type , ""422p10"" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ; _y4m -> bps = 20 ; _y4m -> bit_depth = 10 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>422p10<S2SV_blank>to<S2SV_blank>420jpeg\\n"" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , ""422p12"" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ; _y4m -> bps = 24 ; _y4m -> bit_depth = 12 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>422p12<S2SV_blank>to<S2SV_blank>420jpeg\\n"" ) ; return - 1 <S2SV_ModStart> bps <S2SV_ModEnd> <S2SV_ModStart> ""444p10"" <S2SV_ModEnd> <S2SV_ModStart> _y4m -> vpx_fmt = VPX_IMG_FMT_I44416 ; _y4m -> bps = 30 ; _y4m -> bit_depth = 10 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>444p10<S2SV_blank>to<S2SV_blank>420jpeg\\n"" <S2SV_ModEnd> <S2SV_ModStart> } else if ( strcmp ( _y4m -> chroma_type , ""444p12"" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I44416 ; _y4m -> bps = 36 ; _y4m -> bit_depth = 12 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>444p12<S2SV_blank>to<S2SV_blank>420jpeg\\n"" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , ""444alpha"" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; if ( only_420 ) { _y4m -> dst_c_dec_h = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> convert = y4m_convert_444_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_444A ; _y4m -> bps = 32 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 4 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; } } else if ( strcmp ( _y4m -> chroma_type , ""mono"" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> src_c_dec_v = 0 ; _y4m -> dst_c_dec_h = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_mono_420jpeg ; } else { fprintf ( stderr , ""Unknown<S2SV_blank>chroma<S2SV_blank>sampling<S2SV_blank>type:<S2SV_blank>%s\\n"" , _y4m -> chroma_type ) ; return - 1 ; } <S2SV_ModStart> if ( _y4m -> bit_depth == 8 ) <S2SV_ModStart> else _y4m -> dst_buf <S2SV_ModEnd> <S2SV_ModStart> 2 * _y4m -> dst_buf_sz ) ; if ( <S2SV_ModStart> > 0 ) _y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1540,CWE-120,"<S2SV_StartBug> struct obj * otmp = readobjnam ( buf , ( struct obj * ) 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> otmp ; if ( strlen ( buf ) >= BUFSZ ) buf [ BUFSZ - 1 ] = '\\0' ; ,NetHack@NetHack/f4a840a48f4bcf11757b3d859e9d53cc9d5ef226,CVE-2019-19905,https://github.com/NetHack/NetHack/commit/f4a840a48f4bcf11757b3d859e9d53cc9d5ef226,2019-12-19T18:15Z
1541,CWE-20,"<S2SV_StartBug> long long directory_table_end , table_start ; <S2SV_EndBug> <S2SV_StartBug> return FALSE ; <S2SV_EndBug> <S2SV_StartBug> return FALSE ; <S2SV_EndBug> <S2SV_StartBug> return FALSE ; <S2SV_EndBug> <S2SV_StartBug> if ( read_fragment_table ( & directory_table_end ) == FALSE ) <S2SV_EndBug> <S2SV_StartBug> return FALSE ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> table_start ; if ( sBlk . s . xattr_id_table_start != SQUASHFS_INVALID_BLK ) { if ( sBlk . s . xattr_id_table_start >= sBlk . s . bytes_used ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>xattr<S2SV_blank>id<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } <S2SV_ModEnd> <S2SV_ModStart> goto corrupted ; } else table_start = sBlk . s . bytes_used ; if ( sBlk . s . id_table_start >= table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>id<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( sBlk . s . no_ids == 0 ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>id<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( sBlk . s . no_ids > ( sBlk . s . inodes * 2L ) ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>id<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( read_id_table <S2SV_ModEnd> <S2SV_ModStart> goto corrupted ; if ( sBlk . s . lookup_table_start != SQUASHFS_INVALID_BLK ) { if ( sBlk . s . lookup_table_start >= table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>lookup<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } <S2SV_ModEnd> <S2SV_ModStart> goto corrupted ; } if ( sBlk . s . fragments != 0 ) { if ( sBlk . s . fragment_table_start >= table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>fragment<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( sBlk . s . fragments > sBlk . s . inodes ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>fragment<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } <S2SV_ModEnd> <S2SV_ModStart> table_start ) == FALSE ) goto corrupted ; } else { if ( sBlk . s . fragment_table_start != table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>fragment<S2SV_blank>table<S2SV_blank>start<S2SV_blank>invalid<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } } if ( sBlk . s . directory_table_start >= table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>directory<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } if ( read_directory_table ( sBlk . s . directory_table_start , table_start ) == FALSE ) goto corrupted ; if ( sBlk . s . inode_table_start >= sBlk . s . directory_table_start ) { ERROR ( ""read_filesystem_tables:<S2SV_blank>inode<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; goto corrupted ; } <S2SV_ModEnd> <S2SV_ModStart> goto corrupted <S2SV_ModEnd> <S2SV_ModStart> corrupted : ERROR ( ""File<S2SV_blank>system<S2SV_blank>corruption<S2SV_blank>detected\\n"" ) ; return FALSE ; ",plougher@squashfs-tools/f95864afe8833fe3ad782d714b41378e860977b1,CVE-2015-4646,https://github.com/plougher/squashfs-tools/commit/f95864afe8833fe3ad782d714b41378e860977b1,2017-04-13T17:59Z
1542,CWE-732,<S2SV_StartBug> createenv ( const struct rule * rule ) <S2SV_EndBug> <S2SV_StartBug> env -> count = 0 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> , const struct passwd * mypw , const struct passwd * targpw <S2SV_ModStart> ; addnode ( env , ""DOAS_USER"" , mypw -> pw_name ) <S2SV_ModStart> else { static const char * copyset [ ] = { ""DISPLAY"" , ""TERM"" , NULL } ; addnode ( env , ""HOME"" , targpw -> pw_dir ) ; addnode ( env , ""LOGNAME"" , targpw -> pw_name ) ; addnode ( env , ""PATH"" , getenv ( ""PATH"" ) ) ; addnode ( env , ""SHELL"" , targpw -> pw_shell ) ; addnode ( env , ""USER"" , targpw -> pw_name ) ; fillenv ( env , copyset ) ; } ",Duncaen@OpenDoas/01c658f8c45cb92a343be5f32aa6da70b2032168,CVE-2019-25016,https://github.com/Duncaen/OpenDoas/commit/01c658f8c45cb92a343be5f32aa6da70b2032168,2021-01-28T20:15Z
1543,CWE-189,<S2SV_StartBug> if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) { <S2SV_EndBug> ,<S2SV_ModStart> skb -> mac_header <S2SV_ModEnd> ,torvalds@linux/0e033e04c2678dbbe74a46b23fffb7bb918c288e,CVE-2013-4563,https://github.com/torvalds/linux/commit/0e033e04c2678dbbe74a46b23fffb7bb918c288e,2013-11-20T13:19Z
1544,CWE-119,"<S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> segmentation_map , 0 , cm -> mi_rows * cm -> mi_cols ) ; <S2SV_EndBug> <S2SV_StartBug> in_frame_q_adj_ratio [ segment ] ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> vpx_clear_system_state <S2SV_ModEnd> <S2SV_ModStart> const int aq_strength = get_aq_c_strength ( cm -> base_qindex , cm -> bit_depth ) ; memset ( cpi -> segmentation_map , DEFAULT_AQ2_SEG , cm -> mi_rows * cm -> mi_cols ) ; vp9_clearall_segfeatures ( seg ) ; if ( cpi -> rc . sb64_target_rate < 256 ) { vp9_disable_segmentation ( seg ) ; return ; } vp9_enable_segmentation ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vp9_disable_segfeature ( seg , DEFAULT_AQ2_SEG , SEG_LVL_ALT_Q ) ; for ( segment = 0 ; segment < AQ_C_SEGMENTS ; ++ segment ) { int qindex_delta ; if ( segment == DEFAULT_AQ2_SEG ) continue ; <S2SV_ModEnd> <S2SV_ModStart> aq_c_q_adj_factor [ aq_strength ] [ segment ] , cm -> bit_depth ) ; if ( ( cm -> base_qindex != 0 ) && ( ( cm -> base_qindex + qindex_delta ) == 0 ) ) { qindex_delta = - cm -> base_qindex + 1 ; } if ( ( cm -> base_qindex + qindex_delta ) > 0 ) { <S2SV_ModEnd> <S2SV_ModStart> } ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1545,CWE-125,"<S2SV_StartBug> Module_type = make_type ( ""Module"" , mod_type , Module_fields , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! Module_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> Interactive_type = make_type ( ""Interactive"" , mod_type , Interactive_fields , <S2SV_EndBug> <S2SV_StartBug> if ( ! Interactive_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> Expression_type = make_type ( ""Expression"" , mod_type , Expression_fields , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! FunctionDef_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> AsyncFunctionDef_fields , 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! AsyncFunctionDef_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> ClassDef_type = make_type ( ""ClassDef"" , stmt_type , ClassDef_fields , 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ClassDef_type ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> Return_type = make_type ( ""Return"" , stmt_type , Return_fields , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> Delete_type = make_type ( ""Delete"" , stmt_type , Delete_fields , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> Assign_type = make_type ( ""Assign"" , stmt_type , Assign_fields , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> AugAssign_type = make_type ( ""AugAssign"" , stmt_type , AugAssign_fields , 3 ) ; <S2SV_EndBug> <S2SV_StartBug> arg_type = make_type ( ""arg"" , & AST_type , arg_fields , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> initialized = 1 ; <S2SV_EndBug> ","<S2SV_ModStart> 2 ) ; if ( ! Module_type ) return 0 ; Interactive_type = make_type ( ""Interactive"" , mod_type , Interactive_fields , <S2SV_ModStart> Interactive_type ) return 0 ; Expression_type = make_type ( ""Expression"" <S2SV_ModEnd> <S2SV_ModStart> Expression_fields , <S2SV_ModEnd> <S2SV_ModStart> Expression_type ) return 0 ; FunctionType_type = make_type ( ""FunctionType"" <S2SV_ModEnd> <S2SV_ModStart> FunctionType_fields , 2 ) ; if ( ! FunctionType_type <S2SV_ModEnd> <S2SV_ModStart> 6 ) ; if ( ! FunctionDef_type ) return 0 ; AsyncFunctionDef_type = make_type ( ""AsyncFunctionDef"" , stmt_type , AsyncFunctionDef_fields , 6 ) ; if ( ! AsyncFunctionDef_type ) return 0 ; ClassDef_type = make_type ( ""ClassDef"" , stmt_type , ClassDef_fields , <S2SV_ModStart> ClassDef_type ) return 0 ; Return_type = make_type ( ""Return"" <S2SV_ModEnd> <S2SV_ModStart> Return_fields , 1 ) ; if ( ! Return_type ) return 0 ; Delete_type = make_type ( ""Delete"" , stmt_type , Delete_fields , 1 ) ; if ( ! Delete_type ) return 0 ; Assign_type = make_type ( ""Assign"" , stmt_type , Assign_fields , 3 ) ; if ( ! Assign_type ) return 0 ; AugAssign_type = make_type ( ""AugAssign"" , stmt_type , AugAssign_fields , 3 ) ; if ( ! AugAssign_type ) return 0 ; AnnAssign_type = make_type ( ""AnnAssign"" , stmt_type , AnnAssign_fields , 4 ) ; if ( ! AnnAssign_type ) return 0 ; For_type = make_type ( ""For"" , stmt_type , For_fields <S2SV_ModEnd> <S2SV_ModStart> For_type ) return 0 ; AsyncFor_type = make_type ( ""AsyncFor"" <S2SV_ModEnd> <S2SV_ModStart> AsyncFor_fields <S2SV_ModEnd> <S2SV_ModStart> AsyncFor_type ) return 0 ; While_type = make_type ( ""While"" <S2SV_ModEnd> <S2SV_ModStart> While_fields , 3 ) ; if ( ! While_type ) return 0 ; If_type = make_type ( ""If"" <S2SV_ModEnd> <S2SV_ModStart> If_fields , 3 ) ; if ( ! If_type ) return 0 ; With_type = make_type ( ""With"" <S2SV_ModEnd> <S2SV_ModStart> With_fields , 3 ) ; if ( ! With_type ) return 0 ; AsyncWith_type = make_type ( ""AsyncWith"" <S2SV_ModEnd> <S2SV_ModStart> AsyncWith_fields , 3 <S2SV_ModEnd> <S2SV_ModStart> 3 <S2SV_ModEnd> <S2SV_ModStart> type_ignore_type = make_type ( ""type_ignore"" , & AST_type , NULL , 0 ) ; if ( ! type_ignore_type ) return 0 ; if ( ! add_attributes ( type_ignore_type , NULL , 0 ) ) return 0 ; TypeIgnore_type = make_type ( ""TypeIgnore"" , type_ignore_type , TypeIgnore_fields , 1 ) ; if ( ! TypeIgnore_type ) return 0 ; ",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z
1546,CWE-284,"<S2SV_StartBug> logfile_fd = open ( log_path , O_WRONLY | O_CREAT | O_TRUNC , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH ) ; <S2SV_EndBug> <S2SV_StartBug> write ( logfile_fd , ""btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea"" , 16 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ,system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
1547,CWE-787,<S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; } ,miniupnp@ngiflib/37d939a6f511d16d4c95678025c235fe62e6417a,CVE-2019-16347,https://github.com/miniupnp/ngiflib/commit/37d939a6f511d16d4c95678025c235fe62e6417a,2019-09-16T13:15Z
1548,CWE-119,<S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart> else ( void ) cpi ; # ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1549,CWE-476,"<S2SV_StartBug> smb_flush_file ( sr , sr -> fid_ofile ) ; <S2SV_EndBug> <S2SV_StartBug> smb_flush_file ( sr , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> smb_ofile_flush <S2SV_ModEnd> <S2SV_ModStart> smb_ofile_flush <S2SV_ModEnd> ,illumos@illumos-gate/6d1c73b5858fefc6161c7d686345f0dc887ea799,CVE-2016-6561,https://github.com/illumos/illumos-gate/commit/6d1c73b5858fefc6161c7d686345f0dc887ea799,2017-03-31T19:59Z
1550,CWE-119,"<S2SV_StartBug> int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs ) <S2SV_EndBug> <S2SV_StartBug> while ( * s && len > 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( u >= PLANE_SIZE ) { <S2SV_EndBug> <S2SV_StartBug> u -= PLANE_SIZE ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = ( wchar_t ) ( SURROGATE_PAIR | <S2SV_EndBug> <S2SV_StartBug> ( ( u >> 10 ) & SURROGATE_BITS ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( u & SURROGATE_BITS ) ) ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = ( wchar_t ) u ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = * s ++ ; <S2SV_EndBug> ","<S2SV_ModStart> enum utf16_endian endian , <S2SV_ModStart> , int maxlen <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && maxlen > 0 && * s <S2SV_ModStart> s += size ; len -= size ; <S2SV_ModStart> if ( maxlen < 2 ) break ; <S2SV_ModStart> put_utf16 ( op ++ , <S2SV_ModEnd> <S2SV_ModStart> , endian ) ; put_utf16 ( op ++ , <S2SV_ModEnd> <S2SV_ModStart> , endian ) ; maxlen -= 2 <S2SV_ModEnd> <S2SV_ModStart> put_utf16 ( op ++ , u , endian ) ; maxlen -- ; } <S2SV_ModEnd> <S2SV_ModStart> put_utf16 ( op ++ , * s ++ , endian ) ; len -- ; maxlen <S2SV_ModEnd> ",torvalds@linux/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,CVE-2013-1773,https://github.com/torvalds/linux/commit/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,2013-02-28T19:55Z
1551,CWE-706,"<S2SV_StartBug> if ( ( strchr ( cp , '/' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) { <S2SV_EndBug> ","<S2SV_ModStart> * cp == '\\0' || <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> ""."" ) == 0 || strcmp ( cp , <S2SV_ModStart>  <S2SV_ModEnd> ",openssh@openssh-portable/6010c0303a422a9c5fa8860c061bf7105eb7f8b2,CVE-2018-20685,https://github.com/openssh/openssh-portable/commit/6010c0303a422a9c5fa8860c061bf7105eb7f8b2,2019-01-10T21:29Z
1552,CWE-20,"<S2SV_StartBug> int num , i , num1 , num2 ; <S2SV_EndBug> <S2SV_StartBug> char * s , * t , * StartClean ; <S2SV_EndBug> <S2SV_StartBug> double * argbuf = 0 ; <S2SV_EndBug> <S2SV_StartBug> outpos = outputbuffer ; <S2SV_EndBug> <S2SV_StartBug> outpos += sprintf ( outpos , ""\\\\axo@setObject{%s}%%\\n{%s%c}%%\\n{"" , s , t , TERMCHAR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * s == '0' && s [ 1 ] == ']' ) { <S2SV_EndBug> <S2SV_StartBug> outpos += sprintf ( outpos , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output.}"" , VERSION , SUBVERSION ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( outfile , ""%s"" , outputbuffer ) ; <S2SV_EndBug> <S2SV_StartBug> if ( argbuf ) free ( argbuf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ( argbuf = ReadTail ( t , & num ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> <S2SV_StartBug> free ( argbuf ) ; <S2SV_EndBug> ","<S2SV_ModStart> , retcode <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; retcode = - 1 <S2SV_ModStart> fprintf ( outfile , ""\\\\axo@setObject{%s}%%\\n{%s%c}%%\\n{"" , s , t , TERMCHAR ) ; <S2SV_ModStart> nameobject = t ; while ( * t != '<S2SV_blank>' && * t != '\\t' && * t != '\\n' && * t ) t ++ ; * t ++ = 0 ; while ( * t == '<S2SV_blank>' || * t == '\\t' || * t == '\\n' ) t ++ <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> fprintf ( outfile , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output."" <S2SV_ModEnd> <S2SV_ModStart> goto SUCCESS ; } else { fprintf ( <S2SV_ModEnd> <S2SV_ModStart> goto EXIT ; } } <S2SV_ModEnd> <S2SV_ModStart> goto EXIT <S2SV_ModEnd> <S2SV_ModStart> goto EXIT <S2SV_ModEnd> <S2SV_ModStart> argbuf = 0 ; <S2SV_ModStart> goto EXIT <S2SV_ModEnd> <S2SV_ModStart> goto EXIT <S2SV_ModEnd> <S2SV_ModStart> argbuf = 0 ; <S2SV_ModStart> goto EXIT <S2SV_ModEnd> <S2SV_ModStart> argbuf = 0 ; <S2SV_ModStart> goto EXIT <S2SV_ModEnd> <S2SV_ModStart> goto EXIT ; } } SUCCESS : retcode = 0 ; EXIT : if ( argbuf ) { <S2SV_ModStart> } fprintf ( outfile , ""}\\n"" ) ; return ( retcode <S2SV_ModEnd> ",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z
1553,CWE-399,<S2SV_StartBug> default : <S2SV_EndBug> ,<S2SV_ModStart> case MAGIC_PARAM_ELF_NOTES_MAX : * ( size_t * ) val = ms -> elf_notes_max ; return 0 ; ,file@file/ce90e05774dd77d86cfc8dfa6da57b32816841c4,CVE-2014-9620,https://github.com/file/file/commit/ce90e05774dd77d86cfc8dfa6da57b32816841c4,2015-01-21T18:59Z
1554,CWE-326,"<S2SV_StartBug> static u32 ip_idents_hashrnd __read_mostly ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <S2SV_EndBug> <S2SV_StartBug> hash = jhash_3words ( ( __force u32 ) iph -> daddr , <S2SV_EndBug> <S2SV_StartBug> iph -> protocol ^ net_hash_mix ( net ) , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key <S2SV_ModEnd> <S2SV_ModStart> net -> ipv4 . ip_id_key <S2SV_ModEnd> <S2SV_ModStart> siphash_3u32 <S2SV_ModEnd> <S2SV_ModStart> , & net -> ipv4 . ip_id_key <S2SV_ModEnd> ",torvalds@linux/df453700e8d81b1bdafdf684365ee2b9431fb702,CVE-2019-10638,https://github.com/torvalds/linux/commit/df453700e8d81b1bdafdf684365ee2b9431fb702,2019-07-05T23:15Z
1555,CWE-125,"<S2SV_StartBug> if ( exists_not_none ( obj , & PyId_lower ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_lower ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> slice_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_slice ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( dims , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Index"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; lower = NULL ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_upper , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; upper = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & upper , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_step , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; step = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & step , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Slice ( lower , upper , step , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ExtSlice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * dims ; if ( lookup_attr_id ( obj , & PyId_dims , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""dims\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExtSlice"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Index"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * out = Index ( value , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
1556,CWE-119,"<S2SV_StartBug> static void write_intra_mode ( vp9_writer * w , MB_PREDICTION_MODE mode , <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * probs ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1557,CWE-000,<S2SV_StartBug> if ( setpwnam ( ctl -> pw ) < 0 ) { <S2SV_EndBug> ,"<S2SV_ModStart> , "".chfn"" ",karelzak@util-linux/bde91c85bdc77975155058276f99d2e0f5eab5a9,CVE-2015-5224,https://github.com/karelzak/util-linux/commit/bde91c85bdc77975155058276f99d2e0f5eab5a9,2017-08-23T15:29Z
1558,CWE-119,<S2SV_StartBug> if ( radiotap_header -> it_version ) <S2SV_EndBug> <S2SV_StartBug> ( unsigned long ) iterator -> _rtheader > <S2SV_EndBug> ,<S2SV_ModStart> max_length < sizeof ( struct ieee80211_radiotap_header ) ) return - EINVAL ; if ( <S2SV_ModStart> + sizeof ( uint32_t ) ,torvalds@linux/f5563318ff1bde15b10e736e97ffce13be08bc1a,CVE-2013-7027,https://github.com/torvalds/linux/commit/f5563318ff1bde15b10e736e97ffce13be08bc1a,2013-12-09T18:55Z
1559,CWE-401,"<S2SV_StartBug> if ( ! nfp_abm_u32_check_knode ( alink -> abm , knode , proto , extack ) ) <S2SV_EndBug> <S2SV_StartBug> goto err_delete ; <S2SV_EndBug> <S2SV_StartBug> goto err_delete ; <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> <S2SV_StartBug> list_add ( & match -> list , & alink -> dscp_map ) ; <S2SV_EndBug> <S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug> ",<S2SV_ModStart> { err = - EOPNOTSUPP ; <S2SV_ModStart> } <S2SV_ModStart> err = - EOPNOTSUPP ; <S2SV_ModStart> { err = <S2SV_ModEnd> <S2SV_ModStart> goto err_delete ; } <S2SV_ModStart> err <S2SV_ModEnd> ,torvalds@linux/78beef629fd95be4ed853b2d37b832f766bd96ca,CVE-2019-19076,https://github.com/torvalds/linux/commit/78beef629fd95be4ed853b2d37b832f766bd96ca,2019-11-18T06:15Z
1560,CWE-189,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> dst_state -> speculative = src -> speculative ; ,torvalds@linux/979d63d50c0c0f7bc537bf821e056cc9fe5abd38,CVE-2019-7308,https://github.com/torvalds/linux/commit/979d63d50c0c0f7bc537bf821e056cc9fe5abd38,2019-02-01T22:29Z
1561,CWE-787,"<S2SV_StartBug> ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( input <= 0.0 || output <= 0.0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Gamma<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>positive"" ) ; RETURN_FALSE ; } ",php@php-src/1bd103df00f49cf4d4ade2cfe3f456ac058a4eae,CVE-2016-7127,https://github.com/php/php-src/commit/1bd103df00f49cf4d4ade2cfe3f456ac058a4eae?w=1,2016-09-12T01:59Z
1562,CWE-119,<S2SV_StartBug> stream -> config . cfg . g_pass = global -> passes == 2 <S2SV_EndBug> <S2SV_StartBug> if ( pass ) <S2SV_EndBug> <S2SV_StartBug> stream -> cx_time = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> # if CONFIG_FP_MB_STATS if ( stream -> config . fpmb_stats_fn ) { if ( ! stats_open_file ( & stream -> fpmb_stats , stream -> config . fpmb_stats_fn , pass ) ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>mb<S2SV_blank>statistics<S2SV_blank>store"" ) ; } else { if ( ! stats_open_mem ( & stream -> fpmb_stats , pass ) ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>mb<S2SV_blank>statistics<S2SV_blank>store"" ) ; } # endif <S2SV_ModStart> { <S2SV_ModStart> # if CONFIG_FP_MB_STATS stream -> config . cfg . rc_firstpass_mb_stats_in = stats_get ( & stream -> fpmb_stats ) ; # endif } ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1563,CWE-000,<S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> ,<S2SV_ModStart> sas_eh_finish_cmd <S2SV_ModEnd> ,torvalds@linux/318aaf34f1179b39fa9c30fa0f3288b645beee39,CVE-2018-10021,https://github.com/torvalds/linux/commit/318aaf34f1179b39fa9c30fa0f3288b645beee39,2018-04-11T17:29Z
1564,CWE-74,<S2SV_StartBug> else <S2SV_EndBug> ,"<S2SV_ModStart> if ( strcmp ( arg , ""@@"" ) == 0 || strcmp ( arg , ""@@u"" ) == 0 ) g_print ( _ ( ""Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\n"" ) , arg ) ; else ",flatpak@flatpak/8279c5818425b6812523e3805bbe242fb6a5d961,CVE-2021-21381,https://github.com/flatpak/flatpak/commit/8279c5818425b6812523e3805bbe242fb6a5d961,2021-03-11T17:15Z
1565,CWE-119,"<S2SV_StartBug> VP9_COMMON * const cm = & pbi -> common ; <S2SV_EndBug> <S2SV_StartBug> const uint8_t * end = NULL ; <S2SV_EndBug> <S2SV_StartBug> vp9_reader r ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cm -> above_context , 0 , <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cm -> above_seg_context , 0 , <S2SV_EndBug> <S2SV_StartBug> sizeof ( * cm -> above_seg_context ) * aligned_cols ) ; <S2SV_EndBug> <S2SV_StartBug> const int last_tile = tile_row == tile_rows - 1 && <S2SV_EndBug> ","<S2SV_ModStart> ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) <S2SV_ModStart> int mi_row , mi_col ; TileData * tile_data <S2SV_ModEnd> <S2SV_ModStart> if ( cm -> lf . filter_level && ! cm -> skip_loop_filter && pbi -> lf_worker . data1 == NULL ) { CHECK_MEM_ERROR ( cm , pbi -> lf_worker . data1 , vpx_memalign ( 32 , sizeof ( LFWorkerData ) ) ) ; pbi -> lf_worker . hook = ( VPxWorkerHook ) vp9_loop_filter_worker ; if ( pbi -> max_threads > 1 && ! winterface -> reset ( & pbi -> lf_worker ) ) { vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Loop<S2SV_blank>filter<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed"" ) ; } } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; winterface -> sync ( & pbi -> lf_worker ) ; vp9_loop_filter_data_reset ( lf_data , get_frame_new_buffer ( cm ) , cm , pbi -> mb . plane ) ; } <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ; if ( pbi -> tile_data == NULL || ( tile_cols * tile_rows ) != pbi -> total_tiles ) { vpx_free ( pbi -> tile_data ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_data , vpx_memalign ( 32 , tile_cols * tile_rows * ( sizeof ( * pbi -> tile_data ) ) ) ) ; pbi -> total_tiles = tile_rows * tile_cols ; } <S2SV_ModStart> TileBuffer * const buf = & tile_buffers [ tile_row ] [ tile_col ] ; tile_data = pbi -> tile_data + tile_cols * tile_row + tile_col ; tile_data -> cm = cm ; tile_data -> xd = pbi -> mb ; tile_data -> xd . corrupted = 0 ; tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? NULL : & cm -> counts ; vp9_zero ( tile_data -> dqcoeff ) ; vp9_tile_init ( & tile_data -> xd . tile , tile_data -> cm , tile_row , tile_col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader , pbi -> decrypt_cb , pbi -> decrypt_state ) ; vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> dqcoeff ) ; } } for ( tile_row = 0 ; tile_row < tile_rows ; ++ tile_row ) { TileInfo tile ; vp9_tile_set_row ( & tile , cm , tile_row ) ; for ( mi_row = tile . mi_row_start ; mi_row < tile . mi_row_end ; mi_row += MI_BLOCK_SIZE ) { for ( tile_col = 0 ; tile_col < tile_cols ; ++ tile_col ) { const int col = pbi -> inv_tile_order ? tile_cols - tile_col - 1 : tile_col ; tile_data = pbi -> tile_data + tile_cols * tile_row + col ; vp9_tile_set_col ( & tile , tile_data -> cm , col ) ; vp9_zero ( tile_data -> xd . left_context ) ; vp9_zero ( tile_data -> xd . left_seg_context ) ; for ( mi_col = tile . mi_col_start ; mi_col < tile . mi_col_end ; mi_col += MI_BLOCK_SIZE ) { decode_partition ( pbi , & tile_data -> xd , mi_row , mi_col , & tile_data -> bit_reader , BLOCK_64X64 , 4 ) ; } pbi -> mb . corrupted |= tile_data -> xd . corrupted ; if ( pbi -> mb . corrupted ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>tile<S2SV_blank>data"" ) ; } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { const int lf_start = mi_row - MI_BLOCK_SIZE ; LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; if ( lf_start < 0 ) continue ; if ( mi_row + MI_BLOCK_SIZE >= cm -> mi_rows ) continue ; winterface -> sync ( & pbi -> lf_worker ) ; lf_data -> start = lf_start ; lf_data -> stop = mi_row ; if ( pbi -> max_threads > 1 ) { winterface -> launch ( & pbi -> lf_worker ) ; } else { winterface -> execute ( & pbi -> lf_worker ) ; } } if ( pbi -> frame_parallel_decode ) vp9_frameworker_broadcast ( pbi -> cur_buf , mi_row << MI_BLOCK_SIZE_LOG2 ) ; } } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; winterface -> sync ( & pbi -> lf_worker ) ; lf_data -> start = lf_data -> stop ; lf_data -> stop = cm -> mi_rows ; winterface -> execute ( & pbi -> lf_worker ) ; } tile_data = pbi -> tile_data + tile_cols * <S2SV_ModEnd> <S2SV_ModStart> ; if ( pbi -> frame_parallel_decode ) vp9_frameworker_broadcast ( pbi -> cur_buf , INT_MAX ) ; return vpx_reader_find_end ( & tile_data -> bit_reader ) <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1566,CWE-119,"<S2SV_StartBug> VP9Decoder * vp9_decoder_create ( const VP9D_CONFIG * oxcf ) { <S2SV_EndBug> <S2SV_StartBug> VP9Decoder * const pbi = vpx_memalign ( 32 , sizeof ( * pbi ) ) ; <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * const cm = pbi ? & pbi -> common : NULL ; <S2SV_EndBug> <S2SV_StartBug> vp9_initialize_dec ( ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> current_video_frame = 0 ; <S2SV_EndBug> <S2SV_StartBug> pbi -> oxcf = * oxcf ; <S2SV_EndBug> <S2SV_StartBug> pbi -> decoded_key_frame = 0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_init_dequantizer ( cm ) ; <S2SV_EndBug> ","<S2SV_ModStart> BufferPool * const pool <S2SV_ModEnd> <S2SV_ModStart> volatile <S2SV_ModStart> volatile <S2SV_ModStart> CHECK_MEM_ERROR ( cm , cm -> fc , ( FRAME_CONTEXT * ) vpx_calloc ( 1 , sizeof ( * cm -> fc ) ) ) ; CHECK_MEM_ERROR ( cm , cm -> frame_contexts , ( FRAME_CONTEXT * ) vpx_calloc ( FRAME_CONTEXTS , sizeof ( * cm -> frame_contexts ) ) ) ; pbi -> need_resync = 1 ; once ( initialize_dec ) ; memset <S2SV_ModEnd> <S2SV_ModStart> memset ( & cm -> next_ref_frame_map , - 1 , sizeof ( cm -> next_ref_frame_map ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> common . buffer_pool = pool ; cm -> bit_depth = VPX_BITS_8 ; cm -> dequant_bit_depth = VPX_BITS_8 ; cm -> alloc_mi = vp9_dec_alloc_mi ; cm -> free_mi = vp9_dec_free_mi ; cm -> setup_mi = vp9_dec_setup_mi ; vp9_loop_filter_init ( cm ) ; cm -> error . setjmp <S2SV_ModEnd> <S2SV_ModStart> vpx_get_worker_interface ( ) -> init <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1567,CWE-401,"<S2SV_StartBug> GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\n"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ; <S2SV_EndBug> ","<S2SV_ModStart> GF_Box * dref ; <S2SV_ModStart> ) ; dref = gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF <S2SV_ModStart> dref ; gf_isom_box_add_for_dump_mode ( s , dref <S2SV_ModEnd> ",gpac@gpac/d2371b4b204f0a3c0af51ad4e9b491144dd1225c,CVE-2018-21017,https://github.com/gpac/gpac/commit/d2371b4b204f0a3c0af51ad4e9b491144dd1225c,2019-09-16T13:15Z
1568,CWE-835,"<S2SV_StartBug> client -> priv -> protocol_timeout = g_timeout_add_seconds ( 5 , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,GNOME@gnome-session/b0dc999e0b45355314616321dbb6cb71e729fc9d,CVE-2017-11171,https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d,2017-07-11T20:29Z
1569,CWE-399,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> new_fpl -> user = get_uid ( fpl -> user ) ; ,torvalds@linux/415e3d3e90ce9e18727e8843ae343eda5a58fad6,CVE-2016-2550,https://github.com/torvalds/linux/commit/415e3d3e90ce9e18727e8843ae343eda5a58fad6,2016-04-27T17:59Z
1570,CWE-362,<S2SV_StartBug> struct ip_options * opt ; <S2SV_EndBug> <S2SV_StartBug> if ( opt == NULL || opt -> cipso == 0 ) <S2SV_EndBug> ,<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> opt . ,torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z
1571,CWE-119,"<S2SV_StartBug> static void tree2tok ( struct vp9_token * tokens , const vp9_tree_index * tree , <S2SV_EndBug> <S2SV_StartBug> const vp9_tree_index j = tree [ i ++ ] ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_tree_index <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_index <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1572,CWE-119,"<S2SV_StartBug> if ( img ) <S2SV_EndBug> <S2SV_StartBug> res = validate_img ( ctx , img ) ; <S2SV_EndBug> <S2SV_StartBug> if ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF | <S2SV_EndBug> <S2SV_StartBug> if ( res == VPX_CODEC_OK && ctx -> cpi != NULL ) { <S2SV_EndBug> <S2SV_StartBug> unsigned int lib_flags ; <S2SV_EndBug> <S2SV_StartBug> int64_t dst_time_stamp , dst_end_time_stamp ; <S2SV_EndBug> <S2SV_StartBug> ( ( VP9_COMP * ) ctx -> cpi ) -> b_calculate_psnr = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_receive_raw_frame ( ctx -> cpi , lib_flags , <S2SV_EndBug> <S2SV_StartBug> VP9_COMP * cpi = ( VP9_COMP * ) ctx -> cpi ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> cx_data_sz = ctx -> cx_data_sz ; <S2SV_EndBug> <S2SV_StartBug> - 1 != vp9_get_compressed_data ( ctx -> cpi , & lib_flags , & size , <S2SV_EndBug> <S2SV_StartBug> vpx_codec_pts_t round , delta ; <S2SV_EndBug> <S2SV_StartBug> VP9_COMP * const cpi = ( VP9_COMP * ) ctx -> cpi ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> common . show_frame == 0 ) { <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> pkt . kind = VPX_CODEC_CX_FRAME_PKT ; <S2SV_EndBug> <S2SV_StartBug> ( dst_time_stamp * ctx -> cfg . g_timebase . den + round ) <S2SV_EndBug> <S2SV_StartBug> ( ( delta * ctx -> cfg . g_timebase . den + round ) <S2SV_EndBug> <S2SV_StartBug> pkt . data . frame . flags = lib_flags << 16 ; <S2SV_EndBug> <S2SV_StartBug> size += write_superframe_index ( ctx ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> VP9_COMP * const cpi = ctx -> cpi ; const vpx_rational_t * const timebase = & ctx -> cfg . g_timebase ; size_t data_sz ; <S2SV_ModStart> != NULL ) { <S2SV_ModEnd> <S2SV_ModStart> if ( res == VPX_CODEC_OK && cpi != NULL ) { data_sz = ctx -> cfg . g_w * ctx -> cfg . g_h * get_image_bps ( img ) / 8 * ( cpi -> multi_arf_allowed ? 8 : 2 ) ; if ( data_sz < 4096 ) data_sz = 4096 ; if ( ctx -> cx_data == NULL || ctx -> cx_data_sz < data_sz ) { ctx -> cx_data_sz = data_sz ; free ( ctx -> cx_data ) ; ctx -> cx_data = ( unsigned char * ) malloc ( ctx -> cx_data_sz ) ; if ( ctx -> cx_data == NULL ) { return VPX_CODEC_MEM_ERROR ; } } } } <S2SV_ModStart> vp9_apply_encoding_flags ( cpi , flags ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = 0 <S2SV_ModStart> = timebase_units_to_ticks ( timebase , pts ) ; int64_t dst_end_time_stamp = timebase_units_to_ticks ( timebase , pts + duration ) <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cpi , flags | ctx -> next_frame_flags <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ctx -> next_frame_flags = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_SPATIAL_SVC if ( cpi -> use_svc ) cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers ] . layer_size += size ; # endif if ( ! <S2SV_ModEnd> <S2SV_ModStart> || ( cpi -> use_svc && cpi -> svc . spatial_layer_id < cpi -> svc . number_spatial_layers - 1 ) <S2SV_ModEnd> <S2SV_ModStart> if ( ctx -> output_cx_pkt_cb . output_cx_pkt ) { pkt . kind = VPX_CODEC_CX_FRAME_PKT ; pkt . data . frame . pts = ticks_to_timebase_units ( timebase , dst_time_stamp ) ; pkt . data . frame . duration = ( unsigned long ) ticks_to_timebase_units ( timebase , <S2SV_ModEnd> <S2SV_ModStart> data . frame . flags = get_frame_pkt_flags ( cpi , lib_flags ) ; pkt . data . frame . buf = ctx -> pending_cx_data ; pkt . data . frame . sz = size ; ctx -> pending_cx_data = NULL ; ctx -> pending_cx_data_sz = 0 ; ctx -> pending_frame_count = 0 ; ctx -> pending_frame_magnitude = 0 ; ctx -> output_cx_pkt_cb . output_cx_pkt ( & pkt , ctx -> output_cx_pkt_cb . user_priv ) ; } continue ; } pkt . <S2SV_ModStart> ticks_to_timebase_units ( timebase , dst_time_stamp ) <S2SV_ModEnd> <S2SV_ModStart> ticks_to_timebase_units ( timebase , dst_end_time_stamp - dst_time_stamp <S2SV_ModEnd> <S2SV_ModStart> get_frame_pkt_flags ( cpi , lib_flags ) <S2SV_ModEnd> <S2SV_ModStart> if ( ! ctx -> output_cx_pkt_cb . output_cx_pkt ) <S2SV_ModStart> if ( ctx -> output_cx_pkt_cb . output_cx_pkt ) ctx -> output_cx_pkt_cb . output_cx_pkt ( & pkt , ctx -> output_cx_pkt_cb . user_priv ) ; else <S2SV_ModStart> # if VPX_ENCODER_ABI_VERSION > ( 5 + VPX_CODEC_ABI_VERSION ) # if CONFIG_SPATIAL_SVC if ( cpi -> use_svc && ! ctx -> output_cx_pkt_cb . output_cx_pkt ) { vpx_codec_cx_pkt_t pkt_sizes , pkt_psnr ; int sl ; vp9_zero ( pkt_sizes ) ; vp9_zero ( pkt_psnr ) ; pkt_sizes . kind = VPX_CODEC_SPATIAL_SVC_LAYER_SIZES ; pkt_psnr . kind = VPX_CODEC_SPATIAL_SVC_LAYER_PSNR ; for ( sl = 0 ; sl < cpi -> svc . number_spatial_layers ; ++ sl ) { LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ sl * cpi -> svc . number_temporal_layers ] ; pkt_sizes . data . layer_sizes [ sl ] = lc -> layer_size ; pkt_psnr . data . layer_psnr [ sl ] = lc -> psnr_pkt ; lc -> layer_size = 0 ; } vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt_sizes ) ; vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt_psnr ) ; } # endif # endif if ( is_one_pass_cbr_svc ( cpi ) && ( cpi -> svc . spatial_layer_id == cpi -> svc . number_spatial_layers - 1 ) ) { break ; } ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1573,CWE-416,<S2SV_StartBug> ctx -> clockid = clockid ; <S2SV_EndBug> ,<S2SV_ModStart> spin_lock_init ( & ctx -> cancel_lock ) ; ,torvalds@linux/1e38da300e1e395a15048b0af1e5305bd91402f6,CVE-2017-10661,https://github.com/torvalds/linux/commit/1e38da300e1e395a15048b0af1e5305bd91402f6,2017-08-19T18:29Z
1574,CWE-400,"<S2SV_StartBug> struct mount * child , * p ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_MNT_SHARED ( dest_mnt ) ) { <S2SV_EndBug> <S2SV_StartBug> err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ; <S2SV_EndBug> <S2SV_StartBug> umount_tree ( child , UMOUNT_SYNC ) ; <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> ","<S2SV_ModStart> mnt_namespace * ns = dest_mnt -> mnt_ns ; struct <S2SV_ModStart> ! parent_path ) { err = count_mounts ( ns , source_mnt <S2SV_ModEnd> <S2SV_ModStart> } if ( IS_MNT_SHARED ( dest_mnt ) ) { err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; <S2SV_ModStart> child -> mnt_parent -> mnt_ns -> pending_mounts = 0 ; <S2SV_ModStart> ns -> pending_mounts = 0 ; ",torvalds@linux/d29216842a85c7970c536108e093963f02714498,CVE-2016-6213,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,2016-12-28T07:59Z
1575,CWE-674,"<S2SV_StartBug> ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len ) ; <S2SV_EndBug> ","<S2SV_ModStart> , 0 ",krb5@krb5/57415dda6cf04e73ffc3723be518eddfae599bfd,CVE-2020-28196,https://github.com/krb5/krb5/commit/57415dda6cf04e73ffc3723be518eddfae599bfd,2020-11-06T08:15Z
1576,CWE-119,<S2SV_StartBug> void fadst16_8col ( __m128i * in ) { <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_m16_m16 = _mm_set1_epi16 ( - cospi_16_64 ) ; <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug> ,<S2SV_ModStart> static <S2SV_ModStart> ( int16_t ) <S2SV_ModStart> ( int16_t ) ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1577,CWE-119,"<S2SV_StartBug> static int frame_max_bits ( const RATE_CONTROL * rc , const VP9_CONFIG * oxcf ) { <S2SV_EndBug> <S2SV_StartBug> int64_t max_bits = ( ( int64_t ) rc -> av_per_frame_bandwidth * <S2SV_EndBug> ",<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1578,CWE-190,<S2SV_StartBug> uchar magicbuf [ MIF_MAGICLEN ] ; <S2SV_EndBug> ,<S2SV_ModStart> jas_uchar <S2SV_ModEnd> ,mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
1579,CWE-119,"<S2SV_StartBug> void Huff_transmit ( huff_t * huff , int ch , byte * fout ) { <S2SV_EndBug> <S2SV_StartBug> Huff_transmit ( huff , NYT , fout ) ; <S2SV_EndBug> <S2SV_StartBug> send ( huff -> loc [ ch ] , NULL , fout ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int maxoffset <S2SV_ModStart> , maxoffset <S2SV_ModStart> , maxoffset ",ioquake@ioq3/d2b1d124d4055c2fcbe5126863487c52fd58cca1,CVE-2017-11721,https://github.com/ioquake/ioq3/commit/d2b1d124d4055c2fcbe5126863487c52fd58cca1,2017-08-03T08:29Z
1580,CWE-119,"<S2SV_StartBug> static void encode_superblock ( VP9_COMP * cpi , TOKENEXTRA * * t , int output_enabled , <S2SV_EndBug> <S2SV_StartBug> int mi_row , int mi_col , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> x -> skip_recode = ! x -> select_txfm_size && mbmi -> sb_type >= BLOCK_8X8 && <S2SV_EndBug> <S2SV_StartBug> x -> skip_optimize = ctx -> is_coded ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_type == KEY_FRAME ) { <S2SV_EndBug> <S2SV_StartBug> set_ref_ptrs ( cm , xd , mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_setup_pre_planes ( xd , ref , cfg , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> skip ) { <S2SV_EndBug> <S2SV_StartBug> vp9_tokenize_sb ( cpi , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> ++ get_tx_counts ( max_txsize_lookup [ bsize ] , vp9_get_tx_size_context ( xd ) , <S2SV_EndBug> <S2SV_StartBug> & cm -> counts . tx ) [ mbmi -> tx_size ] ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , <S2SV_ModStart> , PICK_MODE_CONTEXT * ctx <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> const int seg_skip = segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) <S2SV_ModEnd> <S2SV_ModStart> select_tx_size <S2SV_ModEnd> <S2SV_ModStart> if ( ! x -> skip_recode && ! cpi -> sf . use_nonrd_pick_mode ) memset ( x -> skip_txfm , 0 , sizeof ( x -> skip_txfm ) ) ; <S2SV_ModStart> ! is_inter_block ( mbmi ) ) { int plane ; mbmi -> skip = 1 ; for ( plane = 0 ; plane < MAX_MB_PLANE ; ++ plane ) vp9_encode_intra_block_plane ( x , MAX ( bsize , BLOCK_8X8 ) , plane ) ; if ( output_enabled ) sum_intra_stats ( td -> counts , mi ) ; vp9_tokenize_sb ( cpi , td , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ; <S2SV_ModEnd> <S2SV_ModStart> int ref ; const int is_compound = has_second_ref ( mbmi ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> assert ( cfg != NULL ) ; <S2SV_ModStart> if ( ! ( cpi -> sf . reuse_inter_pred_sby && ctx -> pred_pixel_ready ) || seg_skip ) vp9_build_inter_predictors_sby <S2SV_ModEnd> <S2SV_ModStart> vp9_build_inter_predictors_sbuv ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) <S2SV_ModEnd> <S2SV_ModStart> , td <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> seg_skip <S2SV_ModEnd> <S2SV_ModStart> get_tx_size_context <S2SV_ModEnd> <S2SV_ModStart> td -> counts -> <S2SV_ModEnd> <S2SV_ModStart> ++ td -> counts -> tx . tx_totals [ mbmi -> tx_size ] ; ++ td -> counts -> tx . tx_totals [ get_uv_tx_size ( mbmi , & xd -> plane [ 1 ] ) ] ; ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1581,CWE-119,<S2SV_StartBug> if ( iad_num == USB_MAXIADS ) { <S2SV_EndBug> <S2SV_StartBug> ( struct usb_interface_assoc_descriptor <S2SV_EndBug> ,"<S2SV_ModStart> struct usb_interface_assoc_descriptor * d ; d = ( struct usb_interface_assoc_descriptor * ) header ; if ( d -> bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE ) { dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>interface<S2SV_blank>association<S2SV_blank>descriptor<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>skipping\\n"" , cfgno , d -> bLength ) ; continue ; } <S2SV_ModStart> d <S2SV_ModEnd> ",torvalds@linux/bd7a3fe770ebd8391d1c7d072ff88e9e76d063eb,CVE-2017-16531,https://github.com/torvalds/linux/commit/bd7a3fe770ebd8391d1c7d072ff88e9e76d063eb,2017-11-04T01:29Z
1582,CWE-119,"<S2SV_StartBug> int rc ; <S2SV_EndBug> <S2SV_StartBug> struct crypto_skcipher * tfm_des ; <S2SV_EndBug> <S2SV_StartBug> tfm_des = crypto_alloc_skcipher ( ""ecb(des)"" , 0 , CRYPTO_ALG_ASYNC ) ; <S2SV_EndBug> <S2SV_StartBug> rc = PTR_ERR ( tfm_des ) ; <S2SV_EndBug> <S2SV_StartBug> goto smbhash_err ; <S2SV_EndBug> <S2SV_StartBug> sg_init_one ( & sgin , in , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> smbhash_err : <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> crypto_cipher * tfm_des <S2SV_ModEnd> <S2SV_ModStart> crypto_alloc_cipher ( ""des"" <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return PTR_ERR ( tfm_des ) ; } crypto_cipher_setkey <S2SV_ModEnd> <S2SV_ModStart> crypto_cipher_encrypt_one ( tfm_des , out , in ) ; crypto_free_cipher <S2SV_ModEnd> <S2SV_ModStart> return 0 <S2SV_ModEnd> ",torvalds@linux/06deeec77a5a689cc94b21a8a91a76e42176685d,CVE-2016-10154,https://github.com/torvalds/linux/commit/06deeec77a5a689cc94b21a8a91a76e42176685d,2017-02-06T06:59Z
1583,CWE-119,<S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 4 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = ( x >> 24 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> . ptr [ <S2SV_ModEnd> <S2SV_ModStart> . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z
1584,CWE-129,"<S2SV_StartBug> uint32_t value ; <S2SV_EndBug> <S2SV_StartBug> int position , zeroes , i , j ; <S2SV_EndBug> <S2SV_StartBug> zeroes = i = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( get_bits_left ( gbc ) < zeroes + 1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( get_bits1 ( gbc ) ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> bits [ i ++ ] = ( value >> ( zeroes - j - 1 ) & 1 ) ? '1' : '0' ; <S2SV_EndBug> <S2SV_StartBug> value += ( 1 << zeroes ) - 1 ; <S2SV_EndBug> ","<S2SV_ModStart> zeroes , bits_value , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> break ; ++ zeroes ; } if ( zeroes >= 32 ) { value = MAX_UINT_BITS ( 32 ) ; } else { if ( get_bits_left ( gbc ) < zeroes ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>uvlc<S2SV_blank>code<S2SV_blank>at<S2SV_blank>"" ""%s:<S2SV_blank>bitstream<S2SV_blank>ended.\\n"" , name ) ; return AVERROR_INVALIDDATA ; } bits_value = get_bits_long ( gbc , zeroes ) ; value = bits_value + ( UINT32_C ( 1 ) << zeroes ) - 1 ; } if ( ctx -> trace_enable ) { char bits [ 65 ] ; int i , j , k ; if ( zeroes >= 32 ) { while ( zeroes > 32 ) { k = FFMIN ( zeroes - 32 , 32 ) ; for ( i = 0 ; i < k ; i ++ ) bits [ i ] = '0' ; bits [ i ] = 0 ; ff_cbs_trace_syntax_element ( ctx , position , name , NULL , bits , 0 ) ; zeroes -= k ; position += k ; } } for ( i = 0 ; i < zeroes ; i ++ ) bits [ i ] = '0' ; <S2SV_ModEnd> <S2SV_ModStart> if ( zeroes < 32 ) { <S2SV_ModEnd> <S2SV_ModStart> bits_value <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModEnd> ",FFmpeg@FFmpeg/b97a4b658814b2de8b9f2a3bce491c002d34de31,CVE-2019-1000016,https://github.com/FFmpeg/FFmpeg/commit/b97a4b658814b2de8b9f2a3bce491c002d34de31,2019-02-04T21:29Z
1585,CWE-200,<S2SV_StartBug> else if ( i > pos && i + insn -> off + 1 < pos ) <S2SV_EndBug> ,<S2SV_ModStart> + delta <S2SV_ModStart> <= pos + delta <S2SV_ModEnd> ,torvalds@linux/a1b14d27ed0965838350f1377ff97c93ee383492,CVE-2016-2383,https://github.com/torvalds/linux/commit/a1b14d27ed0965838350f1377ff97c93ee383492,2016-04-27T17:59Z
1586,CWE-000,<S2SV_StartBug> case EXIT_REASON_INVEPT : <S2SV_EndBug> ,<S2SV_ModStart> case EXIT_REASON_INVVPID : ,torvalds@linux/a642fc305053cc1c6e47e4f4df327895747ab485,CVE-2014-3646,https://github.com/torvalds/linux/commit/a642fc305053cc1c6e47e4f4df327895747ab485,2014-11-10T11:55Z
1587,CWE-20,"<S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> <S2SV_StartBug> else if ( isalnum ( c ) || strchr ( ""!#$%&\'*+-.^_`|~"" , c ) || c >= 128 ) <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> ,Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
1588,CWE-416,"<S2SV_StartBug> packet -> http_contentlen . ptr = NULL , packet -> http_contentlen . len = 0 , packet -> http_cookie . ptr = NULL , <S2SV_EndBug> ","<S2SV_ModStart> content_disposition_line . ptr = NULL , packet -> content_disposition_line . len = 0 , packet -> ",ntop@nDPI/6a9f5e4f7c3fd5ddab3e6727b071904d76773952,CVE-2020-15475,https://github.com/ntop/nDPI/commit/6a9f5e4f7c3fd5ddab3e6727b071904d76773952,2020-07-01T11:15Z
1589,CWE-20,<S2SV_StartBug> nd -> last_type = LAST_BIND ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/86acdca1b63e6890540fa19495cfc708beff3d8b,CVE-2014-0203,https://github.com/torvalds/linux/commit/86acdca1b63e6890540fa19495cfc708beff3d8b,2014-06-23T11:21Z
1590,CWE-617,"<S2SV_StartBug> assert ( pow ( ( float ) r + 1 , dim ) > entries ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ( int ) floor ( pow ( ( float ) r , dim ) ) <= entries ) ; <S2SV_EndBug> ",<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> <= entries ) return - 1 ; if <S2SV_ModEnd> <S2SV_ModStart> > entries ) return - 1 <S2SV_ModEnd> ,nothings@stb/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,CVE-2019-13223,https://github.com/nothings/stb/commit/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,2019-08-15T17:15Z
1591,CWE-20,"<S2SV_StartBug> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , <S2SV_EndBug> <S2SV_StartBug> Min ( 4 , dds_info -> height - y ) , exception ) ; <S2SV_EndBug> <S2SV_StartBug> SkipDXTMipmaps ( image , dds_info , 8 ) ; <S2SV_EndBug> ","<S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> return ( <S2SV_ModStart> , exception ) ) <S2SV_ModEnd> ",ImageMagick@ImageMagick/d7325bac173492b358417a0ad49fabad44447d52,CVE-2014-9907,https://github.com/ImageMagick/ImageMagick/commit/d7325bac173492b358417a0ad49fabad44447d52,2017-04-19T14:59Z
1592,CWE-665,<S2SV_StartBug> if ( iph -> ihl == 5 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/f8e9881c2aef1e982e5abc25c046820cd0b7cf64,CVE-2011-4087,https://github.com/torvalds/linux/commit/f8e9881c2aef1e982e5abc25c046820cd0b7cf64,2013-06-08T13:05Z
1593,CWE-704,<S2SV_StartBug> if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) { <S2SV_EndBug> ,<S2SV_ModStart> && Z_TYPE_PP ( ptr ) == IS_ARRAY ,m6w6@ext-http/17137d4ab1ce81a2cee0fae842340a344ef3da83,CVE-2016-7398,https://github.com/m6w6/ext-http/commit/17137d4ab1ce81a2cee0fae842340a344ef3da83,2019-09-06T19:15Z
1594,CWE-284,"<S2SV_StartBug> int ret = recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ; <S2SV_EndBug> <S2SV_StartBug> ret = recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ,system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
1595,CWE-20,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> char * outpos = outputbuffer ; <S2SV_ModStart> sendClean ( outputbuffer ) ; ,TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z
1596,CWE-200,"<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> struct stat st ; <S2SV_EndBug> <S2SV_StartBug> if ( lstat ( filename , & st ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> file = fopen ( filename , ""a"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> struct stat st ; FILE * file = NULL ; int fd = - 1 ; <S2SV_ModStart> fd = open ( filename , O_WRONLY | O_APPEND | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY ) ; if ( fd >= 0 && ( fstat ( fd <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> fdopen ( fd <S2SV_ModEnd> <S2SV_ModStart> cfg -> is_custom_debug_file = 1 ; file = NULL ; fd = - 1 ; <S2SV_ModEnd> <S2SV_ModStart> if ( fd != - 1 ) close ( fd ) ; if ( file != NULL ) fclose ( file ) ; ",Yubico@pam-u2f/18b1914e32b74ff52000f10e97067e841e5fff62,CVE-2019-12210,https://github.com/Yubico/pam-u2f/commit/18b1914e32b74ff52000f10e97067e841e5fff62,2019-06-04T21:29Z
1597,CWE-476,"<S2SV_StartBug> if ( test_opt ( sbi , FLUSH_MERGE ) && ! f2fs_readonly ( sbi -> sb ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/d4fdf8ba0e5808ba9ad6b44337783bd9935e0982,CVE-2017-18241,https://github.com/torvalds/linux/commit/d4fdf8ba0e5808ba9ad6b44337783bd9935e0982,2018-03-21T16:29Z
1598,CWE-125,<S2SV_StartBug> if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && <S2SV_EndBug> <S2SV_StartBug> ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) <S2SV_EndBug> <S2SV_StartBug> length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( ( number_pixels * <S2SV_ModEnd> <S2SV_ModStart> ) > ( 8 * <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> bytes_per_line <S2SV_ModEnd> ,ImageMagick@ImageMagick/b8f17d08b7418204bf8a05a5c24e87b2fc395b75,CVE-2015-8958,https://github.com/ImageMagick/ImageMagick/commit/b8f17d08b7418204bf8a05a5c24e87b2fc395b75,2017-04-20T18:59Z
1599,CWE-20,<S2SV_StartBug> outpos += <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sendClean ( outputbuffer ) ; ,TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z
1600,CWE-125,"<S2SV_StartBug> WLog_VRB ( AUTODETECT_TAG , ""received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( Stream_GetRemainingLength ( s ) < 8 ) return - 1 ,FreeRDP@FreeRDP/f5e73cc7c9cd973b516a618da877c87b80950b65,CVE-2020-11047,https://github.com/FreeRDP/FreeRDP/commit/f5e73cc7c9cd973b516a618da877c87b80950b65,2020-05-07T20:15Z
1601,CWE-416,<S2SV_StartBug> _ipmi_destroy_user ( user ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/77f8269606bf95fcb232ee86f6da80886f1dfae8,CVE-2019-9003,https://github.com/torvalds/linux/commit/77f8269606bf95fcb232ee86f6da80886f1dfae8,2019-02-22T15:29Z
1602,CWE-119,"<S2SV_StartBug> if ( ( cpi -> current_layer == 0 ) && <S2SV_EndBug> <S2SV_StartBug> else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) ) <S2SV_EndBug> <S2SV_StartBug> pack_tokens ( w , tp_start , tok_count ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { if <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> { if ( cpi -> consec_zero_last [ map_index + mb_col ] < 255 ) cpi -> consec_zero_last [ map_index + mb_col ] += 1 ; if ( cpi -> consec_zero_last_mvbias [ map_index + mb_col ] < 255 ) cpi -> consec_zero_last_mvbias [ map_index + mb_col ] += 1 ; } else { cpi -> consec_zero_last [ map_index + mb_col ] = 0 ; cpi -> consec_zero_last_mvbias [ map_index + mb_col ] = 0 ; } if ( x -> zero_last_dot_suppress ) cpi -> consec_zero_last_mvbias [ map_index + mb_col ] = 0 ; } if ( ( cpi -> current_layer == 0 ) && ( cpi -> cyclic_refresh_mode_enabled && xd -> segmentation_enabled ) ) { cpi -> segmentation_map [ map_index + mb_col ] = xd -> mode_info_context -> mbmi . segment_id ; if ( xd -> mode_info_context -> mbmi . segment_id ) cpi -> cyclic_refresh_map [ map_index + mb_col ] = - 1 ; else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) <S2SV_ModStart> vp8_pack_tokens <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1603,CWE-000,<S2SV_StartBug> if ( type == ARPHRD_ETHER ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; } ,torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z
1604,CWE-119,"<S2SV_StartBug> in_uint16_le ( s , type ) ; <S2SV_EndBug> <S2SV_StartBug> if ( status == CLIPRDR_ERROR ) <S2SV_EndBug> ","<S2SV_ModStart> struct stream packet = * s ; <S2SV_ModStart> ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cliprdr_process(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } if ( ",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-20182,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-03-15T18:29Z
1605,CWE-000,<S2SV_StartBug> if ( pbi -> b_multithreaded_rd ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,external@libvpx/6886e8e0a9db2dbad723dc37a548233e004b33bc,CVE-2017-0393,https://android.googlesource.com/platform/external/libvpx/+/6886e8e0a9db2dbad723dc37a548233e004b33bc,2017-01-12T20:59Z
1606,CWE-476,<S2SV_StartBug> if ( rows > 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> l == NULL ) break ; if ( ,tats@w3m/7fdc83b0364005a0b5ed869230dd81752ba022e8,CVE-2018-6197,https://github.com/tats/w3m/commit/7fdc83b0364005a0b5ed869230dd81752ba022e8,2018-01-25T03:29Z
1607,CWE-119,<S2SV_StartBug> if ( xWantedSize > 0 ) <S2SV_EndBug> <S2SV_StartBug> xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> && ( ( xWantedSize + xHeapStructSize ) > xWantedSize ) ) <S2SV_ModStart> if ( ( xWantedSize + <S2SV_ModEnd> <S2SV_ModStart> ) > xWantedSize ) { xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ; } else { xWantedSize = 0 ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { xWantedSize = 0 <S2SV_ModEnd> ,FreeRTOS@FreeRTOS-Kernel/c7a9a01c94987082b223d3e59969ede64363da63,CVE-2021-32020,https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/c7a9a01c94987082b223d3e59969ede64363da63,2021-05-03T22:15Z
1608,CWE-119,"<S2SV_StartBug> void vp9_iht8x8_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1609,CWE-400,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
1610,CWE-119,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % ( bps * stride ) ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""fpDiff"" , ""%s"" , ""(cc%(bps*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModStart> return 1 ; ",vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1,CVE-2016-9535,https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1,2016-11-22T19:59Z
1611,CWE-787,"<S2SV_StartBug> uint16 num_updates ; <S2SV_EndBug> <S2SV_StartBug> logger ( Protocol , Debug , ""%s()"" , __func__ ) ; <S2SV_EndBug> <S2SV_StartBug> in_uint16_le ( s , left ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> uint16 num_updates <S2SV_ModEnd> <S2SV_ModStart> process_bitmap_data ( s <S2SV_ModEnd> ,rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z
1612,CWE-400,<S2SV_StartBug> if ( error ) <S2SV_EndBug> <S2SV_StartBug> if ( context -> seen_enough ) <S2SV_EndBug> ,<S2SV_ModStart> { kmem_free ( sbuf ) ; <S2SV_ModStart> } ,torvalds@linux/2e83b79b2d6c78bf1b4aa227938a214dcbddc83f,CVE-2016-9685,https://github.com/torvalds/linux/commit/2e83b79b2d6c78bf1b4aa227938a214dcbddc83f,2016-12-28T07:59Z
1613,CWE-125,"<S2SV_StartBug> ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> u_int name_entries = EXTRACT_16BITS ( msg_data + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> u_int addr_size = 4 ; <S2SV_EndBug> <S2SV_StartBug> int name_entries_valid = 0 ; <S2SV_EndBug> <S2SV_StartBug> name_entries_valid = 1 ; <S2SV_EndBug> ","<S2SV_ModStart> if ( is_ipv6 ) { <S2SV_ModStart> olsr_msg6 ) ) ; <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_ModStart> ; u_int addr_size ; int name_entries_valid ; u_int i ; if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entries <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( is_ipv6 ) addr_size = 16 ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",the-tcpdump-group@tcpdump/0cb1b8a434b599b8d636db029aadb757c24e39d6,CVE-2017-13688,https://github.com/the-tcpdump-group/tcpdump/commit/0cb1b8a434b599b8d636db029aadb757c24e39d6,2017-09-14T06:29Z
1614,CWE-190,"<S2SV_StartBug> uint16 bitspersample , samplesperpixel ; <S2SV_EndBug> <S2SV_StartBug> uint16 input_compression , input_photometric ; <S2SV_EndBug> ",<S2SV_ModStart> = 1 <S2SV_ModStart> = PHOTOMETRIC_MINISBLACK ,vadz@libtiff/43c0b81a818640429317c80fea1e66771e85024b,CVE-2016-9538,https://github.com/vadz/libtiff/commit/43c0b81a818640429317c80fea1e66771e85024b,2016-11-22T19:59Z
1615,CWE-000,"<S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ",<S2SV_ModStart> ssplit <S2SV_ModEnd> ,embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z
1616,CWE-119,<S2SV_StartBug> vp9_coeff_stats * coef_branch_ct ) { <S2SV_EndBug> <S2SV_StartBug> vp9_coeff_probs_model * coef_probs = cpi -> frame_coef_probs [ tx_size ] ; <S2SV_EndBug> ,"<S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ) { vp9_coeff_count * coef_counts <S2SV_ModStart> td . rd_counts . <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1617,CWE-255,<S2SV_StartBug> assert ( name ) ; <S2SV_EndBug> ,"<S2SV_ModStart> name ) ; r = vt_verify_kbmode ( fd ) ; if ( r == - EBUSY ) { log_warning_errno ( r , ""Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>K_XLATE<S2SV_blank>or<S2SV_blank>K_UNICODE:<S2SV_blank>%m"" , name ) ; return 0 ; } else if ( r < 0 ) return log_warning_errno ( r , ""Failed<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>kbdmode<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m"" , ",systemd@systemd/9725f1a10f80f5e0ae7d9b60547458622aeb322f,CVE-2018-20839,https://github.com/systemd/systemd/commit/9725f1a10f80f5e0ae7d9b60547458622aeb322f,2019-05-17T04:29Z
1618,CWE-119,"<S2SV_StartBug> static int su3000_frontend_attach ( struct dvb_usb_adapter * d ) <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x02 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> msleep ( 300 ) ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_EndBug> <S2SV_StartBug> d -> fe_adap [ 0 ] . fe = dvb_attach ( ds3000_attach , & su3000_ds3000_config , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ; <S2SV_EndBug> <S2SV_StartBug> if ( d -> fe_adap [ 0 ] . fe == NULL ) <S2SV_EndBug> <S2SV_StartBug> if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ) { <S2SV_EndBug> ","<S2SV_ModStart> adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x02 ; state -> data [ 2 ] = 1 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> msleep ( 300 ) ; state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data [ 1 ] = 0x83 ; state -> data <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data [ 0 ] = 0x51 <S2SV_ModEnd> <S2SV_ModStart> , state -> data , 1 , state -> data <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/606142af57dad981b78707234cfbd15f9f7b7125,CVE-2017-8062,https://github.com/torvalds/linux/commit/606142af57dad981b78707234cfbd15f9f7b7125,2017-04-23T05:59Z
1619,CWE-362,<S2SV_StartBug> sock_release ( SOCKET_I ( inode ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> __sock_release <S2SV_ModEnd> <S2SV_ModStart> , inode ",torvalds@linux/6d8c50dcb029872b298eea68cc6209c866fd3e14,CVE-2018-12232,https://github.com/torvalds/linux/commit/6d8c50dcb029872b298eea68cc6209c866fd3e14,2018-06-12T12:29Z
1620,CWE-119,"<S2SV_StartBug> vpx_codec_enc_cfg_t * cfg , <S2SV_EndBug> <S2SV_StartBug> else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> priv ) <S2SV_EndBug> ",<S2SV_ModStart> const <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1621,CWE-119,"<S2SV_StartBug> int uv_block_size , <S2SV_EndBug> <S2SV_StartBug> vp9_get_interp_kernel ( xd -> mi [ 0 ] -> mbmi . interp_filter ) ; <S2SV_EndBug> <S2SV_StartBug> if ( uv_block_size == 8 ) { <S2SV_EndBug> <S2SV_StartBug> vp9_build_inter_predictor ( y_mb_ptr , stride , <S2SV_EndBug> <S2SV_StartBug> & pred [ 256 ] , uv_block_size , <S2SV_EndBug> <S2SV_StartBug> & pred [ 512 ] , uv_block_size , <S2SV_EndBug> ","<S2SV_ModStart> uv_block_width , int uv_block_height <S2SV_ModEnd> <S2SV_ModStart> vp9_filter_kernels [ <S2SV_ModEnd> <S2SV_ModStart> ] <S2SV_ModEnd> <S2SV_ModStart> uv_block_width <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_highbd_build_inter_predictor ( y_mb_ptr , stride , & pred [ 0 ] , 16 , & mv , scale , 16 , 16 , which_mv , kernel , MV_PRECISION_Q3 , x , y , xd -> bd ) ; vp9_highbd_build_inter_predictor ( u_mb_ptr , uv_stride , & pred [ 256 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height , which_mv , kernel , mv_precision_uv , x , y , xd -> bd ) ; vp9_highbd_build_inter_predictor ( v_mb_ptr , uv_stride , & pred [ 512 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height , which_mv , kernel , mv_precision_uv , x , y , xd -> bd ) ; return ; } # endif <S2SV_ModStart> uv_block_width , & mv , scale , uv_block_width , uv_block_height <S2SV_ModEnd> <S2SV_ModStart> uv_block_width , & mv , scale , uv_block_width , uv_block_height <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1622,CWE-120,"<S2SV_StartBug> mungspaces ( strcpy ( buf , origbuf ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> while ( * origbuf == '<S2SV_blank>' || * origbuf == '\\t' ) ++ origbuf ; ( void ) strncpy ( buf , origbuf , sizeof buf - 1 ) ; buf [ sizeof buf - 1 ] = '\\0' ; mungspaces ( buf <S2SV_ModEnd> ",NetHack@NetHack/f4a840a48f4bcf11757b3d859e9d53cc9d5ef226,CVE-2019-19905,https://github.com/NetHack/NetHack/commit/f4a840a48f4bcf11757b3d859e9d53cc9d5ef226,2019-12-19T18:15Z
1623,CWE-119,"<S2SV_StartBug> cJSON * cJSON_CreateFloatArray ( double * numbers , int count ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; a && i < count ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> n = cJSON_CreateFloat ( numbers [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! i ) <S2SV_EndBug> ",<S2SV_ModStart> const float <S2SV_ModEnd> <S2SV_ModStart> i ++ <S2SV_ModEnd> <S2SV_ModStart> cJSON_CreateNumber <S2SV_ModEnd> <S2SV_ModStart> if ( ! n ) { cJSON_Delete ( a ) ; return 0 ; } ,esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
1624,CWE-400,<S2SV_StartBug> goto retry_rebind ; <S2SV_EndBug> ,<S2SV_ModStart> switch ( task -> tk_status ) { case - EACCES : case - EIO : goto die ; default : <S2SV_ModStart> } ,torvalds@linux/0b760113a3a155269a3fba93a409c640031dd68f,CVE-2011-2491,https://github.com/torvalds/linux/commit/0b760113a3a155269a3fba93a409c640031dd68f,2013-03-01T12:37Z
1625,CWE-399,"<S2SV_StartBug> unsigned int link_count ; <S2SV_EndBug> <S2SV_StartBug> struct buffer_head * nbh = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ie -> indirectICB . extLength && <S2SV_EndBug> <S2SV_StartBug> ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 , <S2SV_EndBug> <S2SV_StartBug> brelse ( nbh ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned int indirections = 0 ; reread : <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) { brelse ( bh ) ; brelse ( ibh ) ; memcpy ( & iinfo -> i_location <S2SV_ModEnd> <S2SV_ModStart> sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > UDF_MAX_ICB_NESTING ) { udf_err ( inode -> i_sb , ""too<S2SV_blank>many<S2SV_blank>ICBs<S2SV_blank>in<S2SV_blank>ICB<S2SV_blank>hierarchy"" ""<S2SV_blank>(max<S2SV_blank>%d<S2SV_blank>supported)\\n"" , UDF_MAX_ICB_NESTING ) ; make_bad_inode <S2SV_ModEnd> <S2SV_ModStart> goto reread <S2SV_ModEnd> ",torvalds@linux/c03aa9f6e1f938618e6db2e23afef0574efeeb65,CVE-2014-6410,https://github.com/torvalds/linux/commit/c03aa9f6e1f938618e6db2e23afef0574efeeb65,2014-09-28T10:55Z
1626,CWE-119,"<S2SV_StartBug> float * w = get_window ( f , n ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( w == NULL ) return 0 ,nothings@stb/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,CVE-2019-13217,https://github.com/nothings/stb/commit/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,2019-08-15T17:15Z
1627,CWE-787,"<S2SV_StartBug> uint32 num_properties = GETINT32 ( buf + idx ) ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < ( a -> names [ i ] . len >> 1 ) ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( a -> type == szMAPI_UNICODE_STRING ) <S2SV_EndBug> <S2SV_StartBug> v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; assert ( ( num_properties + 1 ) != 0 <S2SV_ModStart> assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ; <S2SV_ModStart> assert ( v -> len + idx <= len ) ; <S2SV_ModStart> assert ( v -> len != 0 ) ; ,verdammelt@tnef/1a17af1ed0c791aec44dbdc9eab91218cc1e335a,CVE-2017-6307,https://github.com/verdammelt/tnef/commit/1a17af1ed0c791aec44dbdc9eab91218cc1e335a,2017-02-24T04:59Z
1628,CWE-119,"<S2SV_StartBug> VP9_COMMON * const cm = & pbi -> common ; <S2SV_EndBug> <S2SV_StartBug> const int num_workers = MIN ( pbi -> oxcf . max_threads & ~ 1 , tile_cols ) ; <S2SV_EndBug> <S2SV_StartBug> TileBuffer tile_buffers [ 1 << 6 ] ; <S2SV_EndBug> <S2SV_StartBug> const int num_threads = pbi -> oxcf . max_threads & ~ 1 ; <S2SV_EndBug> <S2SV_StartBug> vpx_malloc ( num_threads * sizeof ( * pbi -> tile_workers ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> VP9Worker * const worker = & pbi -> tile_workers [ i ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_worker_init ( worker ) ; <S2SV_EndBug> <S2SV_StartBug> if ( i < num_threads - 1 && ! vp9_worker_reset ( worker ) ) { <S2SV_EndBug> <S2SV_StartBug> pbi -> tile_workers [ n ] . hook = ( VP9WorkerHook ) tile_worker_hook ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cm -> above_seg_context , 0 , <S2SV_EndBug> <S2SV_StartBug> for ( n = 0 ; n < tile_cols ; ++ n ) { <S2SV_EndBug> <S2SV_StartBug> get_tile ( data_end , n == tile_cols - 1 , & cm -> error , & data ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_worker_launch ( worker ) ; <S2SV_EndBug> <S2SV_StartBug> VP9Worker * const worker = & pbi -> tile_workers [ i - 1 ] ; <S2SV_EndBug> <S2SV_StartBug> pbi -> mb . corrupted |= ! vp9_worker_sync ( worker ) ; <S2SV_EndBug> <S2SV_StartBug> bit_reader_end = vp9_reader_find_end ( & tile_data -> bit_reader ) ; <S2SV_EndBug> <S2SV_StartBug> final_worker = - 1 ; <S2SV_EndBug> ","<S2SV_ModStart> ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ] [ 1 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ) ) ; assert ( ( sizeof ( * pbi -> tile_worker_data ) % 16 ) == 0 ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_worker_data , vpx_memalign ( 32 , num_threads * sizeof ( * pbi -> tile_worker_data ) ) ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_worker_info , vpx_malloc ( num_threads * sizeof ( * pbi -> tile_worker_info <S2SV_ModStart> VPxWorker <S2SV_ModEnd> <S2SV_ModStart> winterface -> init ( worker <S2SV_ModEnd> <S2SV_ModStart> winterface -> reset <S2SV_ModEnd> <S2SV_ModStart> VPxWorker * const worker = & <S2SV_ModStart> ; winterface -> sync ( worker ) ; worker -> <S2SV_ModEnd> <S2SV_ModStart> VPxWorkerHook <S2SV_ModEnd> <S2SV_ModStart> worker -> data1 = & pbi -> tile_worker_data [ n ] ; worker -> data2 = & pbi -> tile_worker_info [ n ] ; } memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ; qsort ( tile_buffers [ 0 ] , tile_cols , sizeof ( tile_buffers [ 0 ] [ 0 ] ) , compare_tile_buffers ) ; { int group_start = 0 ; while ( group_start < tile_cols ) { const TileBuffer largest = tile_buffers [ 0 ] [ group_start ] ; const int group_end = MIN ( group_start + num_workers , tile_cols ) - 1 ; memmove ( tile_buffers [ 0 ] + group_start , tile_buffers [ 0 ] + group_start + 1 , ( group_end - group_start ) * sizeof ( tile_buffers [ 0 ] [ 0 ] ) ) ; tile_buffers [ 0 ] [ group_end ] = largest ; group_start = group_end + 1 ; } } if ( ! cm -> frame_parallel_decoding_mode ) { int i ; for ( i = 0 ; i < num_workers ; ++ i ) { TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ; vp9_zero ( tile_data -> counts ) ; } } n = 0 ; while ( n < tile_cols ) { int i ; for ( i = 0 ; i < num_workers && n < tile_cols ; ++ i ) { VPxWorker * const worker = & pbi -> tile_workers [ i ] ; TileWorkerData * const tile_data = ( TileWorkerData * ) worker -> data1 ; TileInfo * const tile = ( TileInfo * ) worker -> data2 ; TileBuffer * const buf = & tile_buffers [ 0 ] [ n ] ; tile_data -> pbi = pbi ; tile_data -> xd = pbi -> mb ; tile_data -> xd . corrupted = 0 ; tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? 0 : & tile_data -> counts ; vp9_zero ( tile_data -> dqcoeff ) ; vp9_tile_init ( tile , cm , 0 , buf -> col ) ; vp9_tile_init ( & tile_data -> xd . tile , cm , 0 , buf -> col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader , pbi -> decrypt_cb , pbi -> decrypt_state ) ; vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> dqcoeff ) ; worker -> had_error = 0 ; if ( i == num_workers - 1 || <S2SV_ModEnd> <S2SV_ModStart> ) { winterface -> execute <S2SV_ModEnd> <S2SV_ModStart> winterface -> launch <S2SV_ModEnd> <S2SV_ModStart> VPxWorker <S2SV_ModEnd> <S2SV_ModStart> winterface -> sync <S2SV_ModEnd> <S2SV_ModStart> vpx_reader_find_end <S2SV_ModEnd> <S2SV_ModStart> } if ( n >= tile_cols && ! cm -> frame_parallel_decoding_mode ) { for ( i = 0 ; i < num_workers ; ++ i ) { TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ; vp9_accumulate_frame_counts ( cm , & tile_data -> counts , 1 ) ; } ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1629,CWE-835,<S2SV_StartBug> offset = base + get4 ( ) + 8 ; <S2SV_EndBug> <S2SV_StartBug> switch ( tag ) <S2SV_EndBug> ,<S2SV_ModStart> # ifdef LIBRAW_LIBRARY_BUILD if ( offset > ifp -> size ( ) - 8 ) offset = ifp -> size ( ) - 8 ; # endif <S2SV_ModStart> if ( len < 0 ) return ; ,LibRaw@LibRaw/e47384546b43d0fd536e933249047bc397a4d88b,CVE-2018-5813,https://github.com/LibRaw/LibRaw/commit/e47384546b43d0fd536e933249047bc397a4d88b,2018-12-07T22:29Z
1630,CWE-362,<S2SV_StartBug> err = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> if ( match -> type == type && <S2SV_EndBug> <S2SV_StartBug> out : <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> spin_lock ( & po -> bind_lock ) ; if ( po -> running && <S2SV_ModEnd> <S2SV_ModStart> spin_unlock ( & po -> bind_lock ) ; if ( err && ! refcount_read ( & match -> sk_ref ) ) { list_del ( & match -> list ) ; kfree ( match ) ; } ,torvalds@linux/008ba2a13f2d04c947adc536d19debb8fe66f110,CVE-2017-15649,https://github.com/torvalds/linux/commit/008ba2a13f2d04c947adc536d19debb8fe66f110,2017-10-19T22:29Z
1631,CWE-119,"<S2SV_StartBug> struct segmentation * seg = & cm -> seg ; <S2SV_EndBug> <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = ENERGY_MIN ; i <= ENERGY_MAX ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> int qindex_delta , segment_rdmult ; <S2SV_EndBug> <S2SV_StartBug> if ( Q_RATIO ( i ) == 1 ) { <S2SV_EndBug> <S2SV_StartBug> qindex_delta = vp9_compute_qdelta ( & cpi -> rc , base_q , base_q * Q_RATIO ( i ) ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_set_segdata ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q , qindex_delta ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_enable_segfeature ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q ) ; <S2SV_EndBug> <S2SV_StartBug> segment_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + qindex_delta + <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_clear_system_state <S2SV_ModEnd> <S2SV_ModStart> 0 ; i < MAX_SEGMENTS ; ++ i <S2SV_ModEnd> <S2SV_ModStart> = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , cm -> base_qindex , rate_ratio [ i ] , cm -> bit_depth ) <S2SV_ModEnd> <S2SV_ModStart> ( cm -> base_qindex != 0 ) && ( ( cm -> base_qindex + qindex_delta ) == 0 ) ) { qindex_delta = - cm -> base_qindex + 1 ; } if ( rate_ratio [ i ] == 1.0 ) { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> i <S2SV_ModEnd> <S2SV_ModStart> i <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1632,CWE-000,"<S2SV_StartBug> if ( ! net_eq ( net , & init_net ) ) <S2SV_EndBug> ",<S2SV_ModStart> protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if ( ,torvalds@linux/79462ad02e861803b3840cc782248c7359451cd9,CVE-2015-8543,https://github.com/torvalds/linux/commit/79462ad02e861803b3840cc782248c7359451cd9,2015-12-28T11:59Z
1633,CWE-119,"<S2SV_StartBug> ( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ; <S2SV_EndBug> ",<S2SV_ModStart> TIFFGetFieldDefaulted <S2SV_ModEnd> ,vadz@libtiff/5c080298d59efa53264d7248bbe3a04660db6ef7,CVE-2017-5225,https://github.com/vadz/libtiff/commit/5c080298d59efa53264d7248bbe3a04660db6ef7,2017-01-12T11:59Z
1634,CWE-119,<S2SV_StartBug> ctx -> base . err_detail = error -> has_detail ? error -> detail : NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> set_error_detail ( ctx , <S2SV_ModEnd> <S2SV_ModStart> ) ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1635,CWE-125,"<S2SV_StartBug> for ( i = j = 0 ; i < sizeof ( buf ) - 1 && str [ i ] ; i ++ , j ++ ) { <S2SV_EndBug> ",<S2SV_ModStart> j <S2SV_ModEnd> ,radareorg@radare2/e5c14c167b0dcf0a53d76bd50bacbbcc0dfc1ae7,CVE-2018-20459,https://github.com/radareorg/radare2/commit/e5c14c167b0dcf0a53d76bd50bacbbcc0dfc1ae7,2018-12-25T19:29Z
1636,CWE-399,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
1637,CWE-125,"<S2SV_StartBug> b = BCON_NEW ( ""my_dbref"" , <S2SV_EndBug> ","<S2SV_ModStart> VALIDATE_TEST ( ""test59.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ; ",mongodb@mongo-c-driver/0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84,CVE-2018-16790,https://github.com/mongodb/mongo-c-driver/commit/0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84,2018-09-10T05:29Z
1638,CWE-20,<S2SV_StartBug> x86_pmu . extra_regs = intel_snb_extra_regs ; <S2SV_EndBug> <S2SV_StartBug> x86_pmu . pebs_aliases = intel_pebs_aliases_snb ; <S2SV_EndBug> ,<S2SV_ModStart> if ( boot_cpu_data . x86_model == 45 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else <S2SV_ModStart> if ( boot_cpu_data . x86_model == 62 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else ,torvalds@linux/f1923820c447e986a9da0fc6bf60c1dccdf0408e,CVE-2013-2146,https://github.com/torvalds/linux/commit/f1923820c447e986a9da0fc6bf60c1dccdf0408e,2013-06-07T14:03Z
1639,CWE-20,"<S2SV_StartBug> pocstruct_t * ps_prev_poc , * ps_cur_poc ; <S2SV_EndBug> ","<S2SV_ModStart> ; WORD32 size ; size = sizeof ( pred_info_t ) * 2 * 32 ; memset ( ps_dec -> ps_pred , 0 , size ) ; size = sizeof ( disp_mgr_t ) ; memset ( ps_dec -> pv_disp_buf_mgr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_pic_buf_mgr , 0 , size ) ; size = sizeof ( dec_err_status_t ) ; memset ( ps_dec -> ps_dec_err_status , 0 , size ) ; size = sizeof ( sei ) ; memset ( ps_dec -> ps_sei , 0 , size ) ; size = sizeof ( dpb_commands_t ) ; memset ( ps_dec -> ps_dpb_cmds , 0 , size ) ; size = sizeof ( dec_bit_stream_t ) ; memset ( ps_dec -> ps_bitstrm , 0 , size ) ; size = sizeof ( dec_slice_params_t ) ; memset ( ps_dec -> ps_cur_slice , 0 , size ) ; size = MAX ( sizeof ( dec_seq_params_t ) , sizeof ( dec_pic_params_t ) ) ; memset ( ps_dec -> pv_scratch_sps_pps , 0 , size ) ; size = sizeof ( ctxt_inc_mb_info_t ) ; memset ( ps_dec -> ps_left_mb_ctxt_info , 0 , size ) ; size = ( sizeof ( neighbouradd_t ) << 2 ) ; memset ( ps_dec -> ps_left_mvpred_addr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_mv_buf_mgr , 0 , size ) ",external@libavc/ecf6c7ce6d5a22d52160698aab44fc234c63291a,CVE-2016-3743,https://android.googlesource.com/platform/external/libavc/+/ecf6c7ce6d5a22d52160698aab44fc234c63291a,2016-07-11T01:59Z
1640,CWE-000,<S2SV_StartBug> if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end && <S2SV_EndBug> <S2SV_StartBug> vma -> vm_userfaultfd_ctx . ctx != ctx ) ; <S2SV_EndBug> ,<S2SV_ModStart> ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ; <S2SV_ModStart> ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ,torvalds@linux/29ec90660d68bbdd69507c1c8b4e33aa299278b1,CVE-2018-18397,https://github.com/torvalds/linux/commit/29ec90660d68bbdd69507c1c8b4e33aa299278b1,2018-12-12T10:29Z
1641,CWE-000,<S2SV_StartBug> krb5_key_data * key_data ; <S2SV_EndBug> <S2SV_StartBug> if ( key_data_in == NULL ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i <= num_versions ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( ret [ i ] != NULL ) <S2SV_EndBug> ,<S2SV_ModStart> = NULL ; if ( n_key_data < <S2SV_ModEnd> <S2SV_ModStart> key_data <S2SV_ModEnd> <S2SV_ModStart> ret [ i ] != NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,krb5@krb5/04038bf3633c4b909b5ded3072dc88c8c419bf16,CVE-2014-5354,https://github.com/krb5/krb5/commit/04038bf3633c4b909b5ded3072dc88c8c419bf16,2014-12-16T23:59Z
1642,CWE-284,"<S2SV_StartBug> ssize_t ret = read ( fd , btpan_cb . congest_packet , sizeof ( btpan_cb . congest_packet ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( poll ( & ufd , 1 , 0 ) <= 0 || IS_EXCEPTION ( ufd . revents ) ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ,system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
1643,CWE-264,"<S2SV_StartBug> if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) { <S2SV_EndBug> ",<S2SV_ModStart> dumpable != SUID_DUMP_USER && <S2SV_ModEnd> ,torvalds@linux/d049f74f2dbe71354d43d393ac3a188947811348,CVE-2013-2929,https://github.com/torvalds/linux/commit/d049f74f2dbe71354d43d393ac3a188947811348,2013-12-09T18:55Z
1644,CWE-119,"<S2SV_StartBug> static int su3000_frontend_attach ( struct dvb_usb_adapter * d ) <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x02 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> msleep ( 300 ) ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x83 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_EndBug> <S2SV_StartBug> d -> fe_adap [ 0 ] . fe = dvb_attach ( ds3000_attach , & su3000_ds3000_config , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ; <S2SV_EndBug> <S2SV_StartBug> if ( d -> fe_adap [ 0 ] . fe == NULL ) <S2SV_EndBug> <S2SV_StartBug> if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ) { <S2SV_EndBug> ","<S2SV_ModStart> adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x02 ; state -> data [ 2 ] = 1 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> msleep ( 300 ) ; state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data [ 1 ] = 0x83 ; state -> data <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data [ 0 ] = 0x51 <S2SV_ModEnd> <S2SV_ModStart> , state -> data , 1 , state -> data <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",torvalds@linux/606142af57dad981b78707234cfbd15f9f7b7125,CVE-2017-8062,https://github.com/torvalds/linux/commit/606142af57dad981b78707234cfbd15f9f7b7125,2017-04-23T05:59Z
1645,CWE-190,"<S2SV_StartBug> static int getnum ( const char * * fmt , int df ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> ","<S2SV_ModStart> lua_State * L , <S2SV_ModStart> if ( a > ( INT_MAX / 10 ) || a * 10 > ( INT_MAX - ( * * fmt - '0' ) ) ) luaL_error ( L , ""integral<S2SV_blank>size<S2SV_blank>overflow"" ) ; ",antirez@redis/ef764dde1cca2f25d00686673d1bc89448819571,CVE-2020-14147,https://github.com/antirez/redis/commit/ef764dde1cca2f25d00686673d1bc89448819571,2020-06-15T18:15Z
1646,CWE-125,"<S2SV_StartBug> markold ( g , g -> survival , g -> reallyold ) ; <S2SV_EndBug> ",<S2SV_ModStart> allgc <S2SV_ModEnd> ,lua@lua/127e7a6c8942b362aa3c6627f44d660a4fb75312,CVE-2020-15889,https://github.com/lua/lua/commit/127e7a6c8942b362aa3c6627f44d660a4fb75312,2020-07-21T22:15Z
1647,CWE-401,<S2SV_StartBug> return - EIO ; <S2SV_EndBug> ,<S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> if ( ! ret ) ,torvalds@linux/2289adbfa559050d2a38bcd9caac1c18b800e928,CVE-2019-18809,https://github.com/torvalds/linux/commit/2289adbfa559050d2a38bcd9caac1c18b800e928,2019-11-07T16:15Z
1648,CWE-295,"<S2SV_StartBug> ( void ) opt ; <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( safe_memcmp ( buffer , ssl_request , sizeof ssl_request ) ) { <S2SV_EndBug> <S2SV_StartBug> s_log ( LOG_ERR , ""PostgreSQL<S2SV_blank>client<S2SV_blank>did<S2SV_blank>not<S2SV_blank>request<S2SV_blank>TLS,<S2SV_blank>rejecting"" ) ; <S2SV_EndBug> <S2SV_StartBug> s_write ( c , c -> local_wfd . fd , ssl_ok , sizeof ssl_ok ) ; <S2SV_EndBug> ","<S2SV_ModStart> static const uint8_t gss_request [ 8 ] = { 0 , 0 , 0 , 8 , 0x04 , 0xd2 , 0x16 , 0x30 } ; static const uint8_t gss_response [ 62 ] = { 'E' , 0 , 0 , 0 , 61 , 'S' , 'E' , 'R' , 'R' , 'O' , 'R' , 0 , 'C' , 'X' , 'X' , '0' , '0' , '0' , 0 , 'M' , 'S' , 'S' , 'L' , '<S2SV_blank>' , 'e' , 'x' , 'p' , 'e' , 'c' , 't' , 'e' , 'd' , '<S2SV_blank>' , 'b' , 'u' , 't' , '<S2SV_blank>' , 'n' , 'o' , 't' , '<S2SV_blank>' , 'r' , 'e' , 'q' , 'u' , 'e' , 's' , 't' , 'e' , 'd' , '<S2SV_blank>' , 'b' , 'y' , '<S2SV_blank>' , 'c' , 'l' , 'i' , 'e' , 'n' , 't' , 0 , 0 } ; <S2SV_ModStart> ; s_log ( LOG_DEBUG , ""Started<S2SV_blank>server-side<S2SV_blank>psql<S2SV_blank>protcol<S2SV_blank>negotiation"" ) <S2SV_ModStart> ! <S2SV_ModStart> gss_request , sizeof gss_request <S2SV_ModEnd> <S2SV_ModStart> LOG_INFO , ""GSSAPI<S2SV_blank>encryption<S2SV_blank>requested,<S2SV_blank>rejecting<S2SV_blank>gracefully"" ) ; <S2SV_ModEnd> <S2SV_ModStart> gss_response , sizeof gss_response ) ; throw_exception ( c , 2 ) ; } if ( safe_memcmp ( buffer , ssl_request , sizeof ssl_request ) ) { s_log ( LOG_ERR , ""PostgreSQL<S2SV_blank>client<S2SV_blank>did<S2SV_blank>not<S2SV_blank>request<S2SV_blank>TLS,<S2SV_blank>rejecting"" ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_DEBUG , ""SSLRequest<S2SV_blank>received"" ) ; s_write ( c , c -> local_wfd . fd , ",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z
1649,CWE-399,"<S2SV_StartBug> cib_tls_signon ( cib_t * cib , struct remote_connection_s * connection ) <S2SV_EndBug> <S2SV_StartBug> struct sockaddr_in addr ; <S2SV_EndBug> <S2SV_StartBug> char * server = private -> server ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> . dispatch = cib_remote_dispatch , <S2SV_EndBug> <S2SV_StartBug> . destroy = cib_remote_connection_destroy , <S2SV_EndBug> <S2SV_StartBug> sock = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ; <S2SV_EndBug> <S2SV_StartBug> gnutls_global_init ( ) ; <S2SV_EndBug> <S2SV_StartBug> connection -> session = create_tls_session ( sock , GNUTLS_CLIENT ) ; <S2SV_EndBug> <S2SV_StartBug> close ( sock ) ; <S2SV_EndBug> <S2SV_StartBug> answer = crm_recv_remote_msg ( connection -> session , connection -> encrypted ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc != 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , gboolean event_channel <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int disconnected = 0 <S2SV_ModEnd> <S2SV_ModStart> { 0 , } ; cib_fd_callbacks <S2SV_ModEnd> <S2SV_ModStart> event_channel ? cib_remote_callback_dispatch : cib_remote_command_dispatch ; cib_fd_callbacks <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> crm_remote_tcp_connect ( private -> server , private -> port ) ; if ( sock <= 0 ) { crm_perror ( LOG_ERR , ""remote<S2SV_blank>tcp<S2SV_blank>connection<S2SV_blank>to<S2SV_blank>%s:%d<S2SV_blank>failed"" , private -> server , private -> port ) ; } connection -> socket = sock ; <S2SV_ModEnd> <S2SV_ModStart> if ( remote_gnutls_credentials_init == FALSE ) { <S2SV_ModStart> remote_gnutls_credentials_init = TRUE ; } connection -> session = crm_create_anon_tls_session <S2SV_ModEnd> <S2SV_ModStart> , anon_cred_c ) ; if ( crm_initiate_client_tls_handshake ( connection -> session , DEFAULT_CLIENT_HANDSHAKE_TIMEOUT ) != 0 ) { crm_err ( ""Session<S2SV_blank>creation<S2SV_blank>for<S2SV_blank>%s:%d<S2SV_blank>failed"" , private -> <S2SV_ModEnd> <S2SV_ModStart> gnutls_deinit ( * connection -> session ) ; gnutls_free ( connection -> session ) ; connection -> session = NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> & connection -> recv_buf , <S2SV_ModStart> , - 1 , & disconnected ) ; if ( disconnected ) { rc = - ENOTCONN ; } answer = crm_parse_remote_buffer ( & connection -> recv_buf <S2SV_ModStart> free_xml ( answer ) ; answer = NULL ; <S2SV_ModStart> return rc ; } crm_trace ( ""remote<S2SV_blank>client<S2SV_blank>connection<S2SV_blank>established"" ) <S2SV_ModEnd> ",ClusterLabs@pacemaker/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,CVE-2013-0281,https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,2013-11-23T11:55Z
1650,CWE-119,"<S2SV_StartBug> vpx_memset ( cpi , 0 , sizeof ( VP8_COMP ) ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> kf_overspend_bits = 0 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> cyclic_refresh_mode_enabled = cpi -> oxcf . error_resilient_mode ; <S2SV_EndBug> <S2SV_StartBug> cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 5 ; <S2SV_EndBug> <S2SV_StartBug> # ifdef VP8_ENTROPY_STATS <S2SV_EndBug> <S2SV_StartBug> cpi -> b_calculate_psnr = CONFIG_INTERNAL_STATS ; <S2SV_EndBug> <S2SV_StartBug> # if 0 <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . sdf = vp8_sad16x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . vf = vp8_variance16x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . svf = vp8_sub_pixel_variance16x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_h = vp8_variance_halfpixvar16x16_h ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_v = vp8_variance_halfpixvar16x16_v ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_hv = vp8_variance_halfpixvar16x16_hv ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx3f = vp8_sad16x16x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx8f = vp8_sad16x16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx4df = vp8_sad16x16x4d ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . sdf = vp8_sad16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . vf = vp8_variance16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . svf = vp8_sub_pixel_variance16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx3f = vp8_sad16x8x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx8f = vp8_sad16x8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx4df = vp8_sad16x8x4d ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . sdf = vp8_sad8x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . vf = vp8_variance8x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . svf = vp8_sub_pixel_variance8x16 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx3f = vp8_sad8x16x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx8f = vp8_sad8x16x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx4df = vp8_sad8x16x4d ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . sdf = vp8_sad8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . vf = vp8_variance8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . svf = vp8_sub_pixel_variance8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx3f = vp8_sad8x8x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx8f = vp8_sad8x8x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx4df = vp8_sad8x8x4d ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . sdf = vp8_sad4x4 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . vf = vp8_variance4x4 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . svf = vp8_sub_pixel_variance4x4 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx3f = vp8_sad4x4x3 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx8f = vp8_sad4x4x8 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx4df = vp8_sad4x4x4d ; <S2SV_EndBug> ","<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> temporal_layer_id = - 1 ; cpi -> <S2SV_ModStart> mse_source_denoised = 0 ; cpi -> <S2SV_ModStart> if ( cpi -> oxcf . number_of_layers == 1 ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 20 ; } else if ( cpi -> oxcf . number_of_layers == 2 ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 10 ; } <S2SV_ModStart> CHECK_MEM_ERROR ( cpi -> consec_zero_last , vpx_calloc ( cm -> mb_rows * cm -> mb_cols , 1 ) ) ; CHECK_MEM_ERROR ( cpi -> consec_zero_last_mvbias , vpx_calloc ( ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , 1 ) ) ; <S2SV_ModStart> force_maxqp = 0 ; cpi -> <S2SV_ModStart> ifdef OUTPUT_YUV_DENOISED yuv_denoised_file = fopen ( ""denoised.yuv"" , ""ab"" ) ; # endif # <S2SV_ModStart> vpx_sad16x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance16x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_sub_pixel_variance16x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance_halfpixvar16x16_h <S2SV_ModEnd> <S2SV_ModStart> vpx_variance_halfpixvar16x16_v <S2SV_ModEnd> <S2SV_ModStart> vpx_variance_halfpixvar16x16_hv <S2SV_ModEnd> <S2SV_ModStart> vpx_sad16x16x3 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad16x16x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad16x16x4d <S2SV_ModEnd> <S2SV_ModStart> vpx_sad16x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance16x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_sub_pixel_variance16x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad16x8x3 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad16x8x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad16x8x4d <S2SV_ModEnd> <S2SV_ModStart> vpx_sad8x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance8x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_sub_pixel_variance8x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad8x16x3 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad8x16x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad8x16x4d <S2SV_ModEnd> <S2SV_ModStart> vpx_sad8x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance8x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_sub_pixel_variance8x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad8x8x3 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad8x8x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad8x8x4d <S2SV_ModEnd> <S2SV_ModStart> vpx_sad4x4 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance4x4 <S2SV_ModEnd> <S2SV_ModStart> vpx_sub_pixel_variance4x4 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad4x4x3 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad4x4x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_sad4x4x4d <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1651,CWE-20,"<S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> ",<S2SV_ModStart> _dh <S2SV_ModEnd> ,torvalds@linux/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,CVE-2014-2523,https://github.com/torvalds/linux/commit/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92,2014-03-24T16:40Z
1652,CWE-399,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
1653,CWE-125,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , mldv2_tstr <S2SV_ModEnd> ",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z
1654,CWE-400,"<S2SV_StartBug> ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ; <S2SV_EndBug> ",<S2SV_ModStart> -> unary . child ,xkbcommon@libxkbcommon/1f9d1248c07cda8aaff762429c0dce146de8632a,CVE-2018-15853,https://github.com/xkbcommon/libxkbcommon/commit/1f9d1248c07cda8aaff762429c0dce146de8632a,2018-08-25T21:29Z
1655,CWE-835,"<S2SV_StartBug> while ( ( c != '\\n' ) && ( c != '\\0' ) ) <S2SV_EndBug> <S2SV_StartBug> ( void ) sscanf ( value , ""%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g"" , <S2SV_EndBug> <S2SV_StartBug> & white_point [ 0 ] , & white_point [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> ( void ) sscanf ( value , ""%d<S2SV_blank>+X<S2SV_blank>%d"" , & height , & width ) ; <S2SV_EndBug> <S2SV_StartBug> image -> rows = ( size_t ) height ; <S2SV_EndBug> ",<S2SV_ModStart> && ( c != EOF ) <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> == 8 ) { <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> == 2 ) { <S2SV_ModEnd> <S2SV_ModStart> } ,ImageMagick@ImageMagick/97aa7d7cfd2027f6ba7ce42caf8b798541b9cdc6,CVE-2015-8900,https://github.com/ImageMagick/ImageMagick/commit/97aa7d7cfd2027f6ba7ce42caf8b798541b9cdc6,2017-02-27T22:59Z
1656,CWE-362,"<S2SV_StartBug> mptctl_mpt_command ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> struct mpt_ioctl_command karg ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <S2SV_EndBug> <S2SV_StartBug> rc = mptctl_do_mpt_command ( karg , & uarg -> MF ) ; <S2SV_EndBug> ","<S2SV_ModStart> MPT_ADAPTER * ioc , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ioc , ",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z
1657,CWE-834,"<S2SV_StartBug> * image ; <S2SV_EndBug> <S2SV_StartBug> padding , <S2SV_EndBug> <S2SV_StartBug> value = XBMInteger ( image , hex_digits ) ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) ( value >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> <S2SV_StartBug> byte = ( size_t ) ( * p ++ ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; int c <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> c <S2SV_ModEnd> <S2SV_ModStart> ; if ( c < 0 ) break <S2SV_ModStart> c <S2SV_ModEnd> <S2SV_ModStart> c <S2SV_ModEnd> <S2SV_ModStart> if ( c < 0 ) break ; <S2SV_ModStart> c ; } if ( EOFBlob ( image ) != MagickFalse ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) <S2SV_ModEnd> <S2SV_ModStart> unsigned int <S2SV_ModEnd> ",ImageMagick@ImageMagick/b8c63b156bf26b52e710b1a0643c846a6cd01e56,CVE-2017-14175,https://github.com/ImageMagick/ImageMagick/commit/b8c63b156bf26b52e710b1a0643c846a6cd01e56,2017-09-07T06:29Z
1658,CWE-190,"<S2SV_StartBug> if ( ! ( com -> data = JAS_CAST ( uchar * , jas_strdup ( buf ) ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart> jas_uchar <S2SV_ModEnd> ,mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
1659,CWE-120,<S2SV_StartBug> chanmode_found = 1 ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> ,<S2SV_ModStart> if ( ! chanmode_found ) { <S2SV_ModStart> } ,weechat@weechat/6f4f147d8e86adf9ad34a8ffd7e7f1f23a7e74da,CVE-2020-8955,https://github.com/weechat/weechat/commit/6f4f147d8e86adf9ad34a8ffd7e7f1f23a7e74da,2020-02-12T22:15Z
1660,CWE-119,"<S2SV_StartBug> static int decode_uniform ( vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> const int v = vp9_read_literal ( r , l - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> return v < m ? v : ( v << 1 ) - m + vp9_read_bit ( r ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_read_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_read_bit <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1661,CWE-284,<S2SV_StartBug> int is_valid ; <S2SV_EndBug> <S2SV_StartBug> giterr_clear ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> = ( error == GIT_OK ) <S2SV_ModStart>  <S2SV_ModEnd> ,libgit2@libgit2/9a64e62f0f20c9cf9b2e1609f037060eb2d8eb22,CVE-2016-10130,https://github.com/libgit2/libgit2/commit/9a64e62f0f20c9cf9b2e1609f037060eb2d8eb22,2017-03-24T15:59Z
1662,CWE-119,"<S2SV_StartBug> void vp9_cost_tokens_skip ( int * costs , const vp9_prob * probs , vp9_tree tree ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_tree <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1663,CWE-119,"<S2SV_StartBug> vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> ( REFERENCE_MODE ) vp9_read ( r , cm -> fc . comp_inter_prob [ ctx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1664,CWE-787,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> return - 1 ; ,radare@radare2/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,CVE-2017-9949,https://github.com/radare/radare2/commit/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,2017-06-26T20:29Z
1665,CWE-119,"<S2SV_StartBug> if ( ! stream ) <S2SV_EndBug> <S2SV_StartBug> fatal ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>new<S2SV_blank>stream."" ) ; <S2SV_EndBug> <S2SV_StartBug> res = vpx_codec_enc_config_default ( global -> codec -> interface ( ) , <S2SV_EndBug> <S2SV_StartBug> stream -> config . stereo_fmt = STEREO_FORMAT_MONO ; <S2SV_EndBug> <S2SV_StartBug> stream -> config . write_webm = 1 ; <S2SV_EndBug> <S2SV_StartBug> stream -> ebml . last_pts_ms = - 1 ; <S2SV_EndBug> ",<S2SV_ModStart> stream == NULL ) { <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> write_webm = 1 ; # if CONFIG_WEBM_IO stream -> config . <S2SV_ModStart> ebml . last_pts_ns <S2SV_ModEnd> <S2SV_ModStart> ; stream -> ebml . writer = NULL ; stream -> ebml . segment = NULL ,external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1666,CWE-125,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""[ndp<S2SV_blank>opt]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , icmp6_tstr <S2SV_ModEnd> ",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z
1667,CWE-674,<S2SV_StartBug> ( * re_ast ) -> root_node = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> levels = 0 ; ( * re_ast ) -> ,VirusTotal@yara/925bcf3c3b0a28b5b78e25d9efda5c0bf27ae699,CVE-2017-9304,https://github.com/VirusTotal/yara/commit/925bcf3c3b0a28b5b78e25d9efda5c0bf27ae699,2017-05-31T04:29Z
1668,CWE-000,<S2SV_StartBug> other = unix_peer_get ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unix_peer ( other ) != sk ) { <S2SV_EndBug> <S2SV_StartBug> if ( unix_recvq_full ( other ) ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( writable ) { unix_state_lock ( sk ) ; other = unix_peer ( sk ) ; if ( other && unix_peer ( <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> && unix_dgram_peer_wake_me ( sk , other ) <S2SV_ModStart> unix_state_unlock ( sk <S2SV_ModEnd> ",torvalds@linux/7d267278a9ece963d77eefec61630223fce08c6c,CVE-2013-7446,https://github.com/torvalds/linux/commit/7d267278a9ece963d77eefec61630223fce08c6c,2015-12-28T11:59Z
1669,CWE-20,"<S2SV_StartBug> ret = var_expand ( path , key -> key -> key , iter -> var_expand_table , & error ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB , <S2SV_EndBug> <S2SV_StartBug> ""Failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , key -> key -> key , error ) ; <S2SV_EndBug> <S2SV_StartBug> ret = dict_lookup ( iter -> conn -> dict , iter -> pool , <S2SV_EndBug> ","<S2SV_ModStart> str_append ( path , key -> key -> key ) ; ret = dict_lookup ( iter -> conn -> dict , iter -> pool , str_c ( path ) , & key -> value <S2SV_ModEnd> <S2SV_ModStart> > <S2SV_ModEnd> <S2SV_ModStart> auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Lookup:<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>%s"" , str_c ( path ) , key -> value ) ; } else if ( ret < 0 ) { <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>lookup<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , str_c ( path ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",dovecot@core/000030feb7a30f193197f1aab8a7b04a26b42735,CVE-2017-2669,https://github.com/dovecot/core/commit/000030feb7a30f193197f1aab8a7b04a26b42735,2018-06-21T13:29Z
1670,CWE-189,<S2SV_StartBug> if ( A > skb -> len - sizeof ( struct nlattr ) ) <S2SV_EndBug> <S2SV_StartBug> if ( nla -> nla_len > A - skb -> len ) <S2SV_EndBug> ,<S2SV_ModStart> skb -> len < sizeof ( struct nlattr ) ) return 0 ; if ( <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> - A ,torvalds@linux/05ab8f2647e4221cbdb3856dd7d32bd5407316b3,CVE-2014-3145,https://github.com/torvalds/linux/commit/05ab8f2647e4221cbdb3856dd7d32bd5407316b3,2014-05-11T21:55Z
1671,CWE-189,<S2SV_StartBug> length = icon_file . directory [ i ] . size ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( ~ length < 16 ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ",ImageMagick@ImageMagick/0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734,CVE-2015-8896,https://github.com/ImageMagick/ImageMagick/commit/0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734,2017-03-15T19:59Z
1672,CWE-20,"<S2SV_StartBug> ""<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost\'>"" <S2SV_EndBug> ","<S2SV_ModStart> ""<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'stabber@localhost\'>"" <S2SV_ModEnd> ",boothj5@profanity/8e75437a7e43d4c55e861691f74892e666e29b0b,CVE-2017-5592,https://github.com/boothj5/profanity/commit/8e75437a7e43d4c55e861691f74892e666e29b0b,2017-02-09T20:59Z
1673,CWE-415,"<S2SV_StartBug> memcpy ( serial -> value , priv -> cac_id , priv -> cac_id_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> serial -> len <S2SV_ModEnd> ,OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad,CVE-2018-16425,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad,2018-09-04T00:29Z
1674,CWE-125,<S2SV_StartBug> tok -> level = 0 ; <S2SV_EndBug> <S2SV_StartBug> return tok ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tok -> async_always = 0 ; ,python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
1675,CWE-476,<S2SV_StartBug> if ( av1 -> av1_config ) { <S2SV_EndBug> ,<S2SV_ModStart> && av1 -> av1_config -> config ,gpac@gpac/b2eab95e07cb5819375a50358d4806a8813b6e50,CVE-2021-31262,https://github.com/gpac/gpac/commit/b2eab95e07cb5819375a50358d4806a8813b6e50,2021-04-19T19:15Z
1676,CWE-400,"<S2SV_StartBug> GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\n"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ; <S2SV_EndBug> ","<S2SV_ModStart> GF_Box * dref ; <S2SV_ModStart> ) ; dref = gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF <S2SV_ModStart> dref ; gf_isom_box_add_for_dump_mode ( s , dref <S2SV_ModEnd> ",gpac@gpac/d2371b4b204f0a3c0af51ad4e9b491144dd1225c,CVE-2018-21017,https://github.com/gpac/gpac/commit/d2371b4b204f0a3c0af51ad4e9b491144dd1225c,2019-09-16T13:15Z
1677,CWE-415,<S2SV_StartBug> buff [ r ] = '\\0' ; <S2SV_EndBug> ,"<S2SV_ModStart> MIN ( ( size_t ) r , ( sizeof buff ) - 1 ) <S2SV_ModEnd> ",OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad,CVE-2018-16425,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad,2018-09-04T00:29Z
1678,CWE-119,<S2SV_StartBug> ASSERT ( dpbSize ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( picSizeInMbs > ( UINT32_MAX - 32 - 15 ) / 384 ) { ALOGE ( ""b/28533562"" ) ; android_errorWriteLog ( 0x534e4554 , ""28533562"" ) ; return ( MEMORY_ALLOCATION_ERROR ) ; } ",frameworks@av/590d1729883f700ab905cdc9ad850f3ddd7e1f56,CVE-2016-3819,https://android.googlesource.com/platform/frameworks/av/+/590d1729883f700ab905cdc9ad850f3ddd7e1f56,2016-08-05T20:59Z
1679,CWE-552,<S2SV_StartBug> oe_errno = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! sock ) <S2SV_EndBug> <S2SV_StartBug> if ( addrlen ) <S2SV_EndBug> <S2SV_StartBug> addrlen_in = * addrlen ; <S2SV_EndBug> <S2SV_StartBug> addrlen ) != OE_OK ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ,<S2SV_ModStart> oe_socklen_t addrlen_out = 0 ; <S2SV_ModStart> || ! addr || ! addrlen <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( addrlen_in < 0 ) OE_RAISE_ERRNO ( OE_EINVAL ) <S2SV_ModStart> & addrlen_out <S2SV_ModEnd> <S2SV_ModStart> if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; * addrlen = addrlen_out ; ,openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z
1680,CWE-119,"
","
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
1681,CWE-125,"<S2SV_StartBug> nego_process_negotiation_request ( nego , s ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) return FALSE ,FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z
1682,CWE-264,<S2SV_StartBug> struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt == NULL ) <S2SV_EndBug> <S2SV_StartBug> fl6_sock_release ( flowlabel ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; struct ipv6_txoptions * opt_to_free = NULL <S2SV_ModStart> ! opt ) { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> <S2SV_ModStart> ) ; txopt_put ( opt_to_free ,torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
1683,CWE-119,"<S2SV_StartBug> unsigned int i , found , upx_success = 0 , min = 0 , max = 0 , err , overlays = 0 ; <S2SV_EndBug> <S2SV_StartBug> uint32_t valign , falign , hdr_size , j ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < nsections ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> strncpy ( sname , ( char * ) section_hdr [ i ] . Name , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> sname [ 8 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( exe_sections [ i ] . raw >= fsize ) { <S2SV_EndBug> ","<S2SV_ModStart> j , <S2SV_ModStart> , rescan = 1 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> while ( rescan == 1 ) { rescan = 0 ; <S2SV_ModStart> exe_sections [ i ] . rva = PEALIGN ( EC32 ( section_hdr [ i ] . VirtualAddress ) , valign ) ; exe_sections [ i ] . vsz = PESALIGN ( EC32 ( section_hdr [ i ] . VirtualSize ) , valign ) ; exe_sections [ i ] . raw = PEALIGN ( EC32 ( section_hdr [ i ] . PointerToRawData ) , falign ) ; exe_sections [ i ] . rsz = PESALIGN ( EC32 ( section_hdr [ i ] . SizeOfRawData ) , falign ) ; exe_sections [ i ] . chr = EC32 ( section_hdr [ i ] . Characteristics ) ; exe_sections [ i ] . urva = EC32 ( section_hdr [ i ] . VirtualAddress ) ; exe_sections [ i ] . uvsz = EC32 ( section_hdr [ i ] . VirtualSize ) ; exe_sections [ i ] . uraw = EC32 ( section_hdr [ i ] . PointerToRawData ) ; exe_sections [ i ] . ursz = EC32 ( section_hdr [ i ] . SizeOfRawData ) ; if ( exe_sections [ i ] . rsz ) { if ( ! CLI_ISCONTAINED ( 0 , fsize , exe_sections [ i ] . uraw , exe_sections [ i ] . ursz ) || exe_sections [ i ] . raw >= fsize ) { cli_dbgmsg ( ""Broken<S2SV_blank>PE<S2SV_blank>file<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>%d<S2SV_blank>starts<S2SV_blank>or<S2SV_blank>exists<S2SV_blank>beyond<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>(Offset@<S2SV_blank>%lu,<S2SV_blank>Total<S2SV_blank>filesize<S2SV_blank>%lu)\\n"" , i , ( unsigned long ) exe_sections [ i ] . raw , ( unsigned long ) fsize ) ; if ( nsections == 1 ) { free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ; return CL_VIRUS ; } return CL_CLEAN ; } for ( j = i ; j < nsections - 1 ; j ++ ) memcpy ( & exe_sections [ j ] , & exe_sections [ j + 1 ] , sizeof ( struct cli_exe_section ) ) ; for ( j = i ; j < nsections - 1 ; j ++ ) memcpy ( & section_hdr [ j ] , & section_hdr [ j + 1 ] , sizeof ( struct pe_image_section_hdr ) ) ; nsections -- ; rescan = 1 ; break ; } } } } for ( i = 0 ; i < nsections ; i ++ ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> ",vrtadmin@clamav-devel/fc3794a54d2affe5770c1f876484a871c783e91e,CVE-2014-9050,https://github.com/vrtadmin/clamav-devel/commit/fc3794a54d2affe5770c1f876484a871c783e91e,2014-12-01T15:59Z
1684,CWE-20,"<S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPAR , 0x40 | address ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS | EPCR_ERPRR ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( dm9000ReadReg ( DM9000_REG_EPCR ) & EPCR_ERRE ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS ) ; <S2SV_EndBug> <S2SV_StartBug> return ( dm9000ReadReg ( DM9000_REG_EPDRH ) << 8 ) | dm9000ReadReg ( DM9000_REG_EPDRL ) ; <S2SV_EndBug> ","<S2SV_ModStart> DM9000_EPAR <S2SV_ModEnd> <S2SV_ModStart> DM9000_EPCR , DM9000_EPCR_EPOS | DM9000_EPCR_ERPRR <S2SV_ModEnd> <S2SV_ModStart> DM9000_EPCR ) & DM9000_EPCR_ERRE <S2SV_ModEnd> <S2SV_ModStart> DM9000_EPCR , DM9000_EPCR_EPOS <S2SV_ModEnd> <S2SV_ModStart> DM9000_EPDRH <S2SV_ModEnd> <S2SV_ModStart> DM9000_EPDRL <S2SV_ModEnd> ",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
1685,CWE-787,"<S2SV_StartBug> & bufferoffset , <S2SV_EndBug> ","<S2SV_ModStart> t2p -> tiff_datasize , ",vadz@libtiff/83a4b92815ea04969d494416eaae3d4c6b338e4a,CVE-2016-9533,https://github.com/vadz/libtiff/commit/83a4b92815ea04969d494416eaae3d4c6b338e4a#diff-bdc795f6afeb9558c1012b3cfae729ef,2016-11-22T19:59Z
1686,CWE-264,"<S2SV_StartBug> ! inode_capable ( inode , CAP_CHOWN ) ) <S2SV_EndBug> <S2SV_StartBug> ! inode_capable ( inode , CAP_CHOWN ) ) <S2SV_EndBug> <S2SV_StartBug> ! inode_capable ( inode , CAP_FSETID ) ) <S2SV_EndBug> ",<S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> <S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> <S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> ,torvalds@linux/23adbe12ef7d3d4195e80800ab36b37bee28cd03,CVE-2014-4014,https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03,2014-06-23T11:21Z
1687,CWE-787,"<S2SV_StartBug> static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , <S2SV_EndBug> <S2SV_StartBug> UINT32 tempWidth ; <S2SV_EndBug> <S2SV_StartBug> for ( y = 0 ; y < context -> height ; y ++ ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! context || data || ( scanline == 0 ) ) return FALSE <S2SV_ModStart> if ( context -> priv -> PlaneBuffersLength < rw * scanline ) return FALSE ; if ( rw < scanline * 2 ) return FALSE ; <S2SV_ModStart> return TRUE ; ,FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z
1688,CWE-20,"<S2SV_StartBug> static int isofs_read_inode ( struct inode * inode ) <S2SV_EndBug> <S2SV_StartBug> parse_rock_ridge_inode ( de , inode ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int relocated <S2SV_ModStart> , relocated ",torvalds@linux/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4,CVE-2014-5472,https://github.com/torvalds/linux/commit/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4,2014-09-01T01:55Z
1689,CWE-269,"<S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> <S2SV_StartBug> __ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> current_cred ( ) <S2SV_ModEnd> ,torvalds@linux/6994eefb0053799d2e07cd140df6c2ea106c41ee,CVE-2019-13272,https://github.com/torvalds/linux/commit/6994eefb0053799d2e07cd140df6c2ea106c41ee,2019-07-17T13:15Z
1690,CWE-674,<S2SV_StartBug> ( * re_ast ) -> root_node = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> levels = 0 ; ( * re_ast ) -> ,VirusTotal@yara/925bcf3c3b0a28b5b78e25d9efda5c0bf27ae699,CVE-2017-9304,https://github.com/VirusTotal/yara/commit/925bcf3c3b0a28b5b78e25d9efda5c0bf27ae699,2017-05-31T04:29Z
1691,CWE-399,"<S2SV_StartBug> rc = cib_tls_signon ( cib , & ( private -> command ) ) ; <S2SV_EndBug> <S2SV_StartBug> rc = cib_tls_signon ( cib , & ( private -> callback ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> , FALSE <S2SV_ModStart> , TRUE ",ClusterLabs@pacemaker/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,CVE-2013-0281,https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,2013-11-23T11:55Z
1692,CWE-20,<S2SV_StartBug> msg . msg_name = ( struct sockaddr * ) & address ; <S2SV_EndBug> <S2SV_StartBug> msg . msg_namelen = sizeof ( address ) ; <S2SV_EndBug> ,<S2SV_ModStart> addr ? <S2SV_ModStart> : NULL <S2SV_ModStart> 0 <S2SV_ModEnd> ,torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
1693,CWE-119,"<S2SV_StartBug> int num00 , tmp_err , n , sr = 0 ; <S2SV_EndBug> <S2SV_StartBug> int new_mv_mode_penalty = 256 ; <S2SV_EndBug> <S2SV_StartBug> const int quart_frm = MIN ( cpi -> common . width , cpi -> common . height ) ; <S2SV_EndBug> <S2SV_StartBug> tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv , <S2SV_EndBug> <S2SV_StartBug> x -> sadperbit16 , & num00 , & v_fn_ptr , <S2SV_EndBug> <S2SV_StartBug> best_mv -> row = tmp_mv . row ; <S2SV_EndBug> <S2SV_StartBug> tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv , <S2SV_EndBug> <S2SV_StartBug> x -> nmvjointcost , <S2SV_EndBug> <S2SV_StartBug> best_mv -> row = tmp_mv . row ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> NEW_MV_MODE_PENALTY ; int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param <S2SV_ModEnd> <S2SV_ModStart> sr = get_search_range ( cpi ) <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { v_fn_ptr . vf = highbd_get_block_variance_fn ( bsize , xd -> bd ) ; } # endif <S2SV_ModStart> cpi -> ss_cfg , & <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * best_mv = tmp_mv <S2SV_ModEnd> <S2SV_ModStart> , & cpi -> ss_cfg <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * best_mv = tmp_mv <S2SV_ModEnd> ",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
1694,CWE-119,"<S2SV_StartBug> ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , <S2SV_EndBug> ","<S2SV_ModStart> , filename , page_size , off ) ; goto error ; } if ( off + page_size > h -> size ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>extends<S2SV_blank>beyond<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file,<S2SV_blank>bad<S2SV_blank>registry"" ",libguestfs@hivex/4bbdf555f88baeae0fa804a369a81a83908bd705,CVE-2014-9273,https://github.com/libguestfs/hivex/commit/4bbdf555f88baeae0fa804a369a81a83908bd705,2014-12-08T16:59Z
1695,CWE-611,<S2SV_StartBug> return merged ; <S2SV_EndBug> ,<S2SV_ModStart> merged -> xml_external_entity = ( child -> xml_external_entity == NOT_SET ? parent -> xml_external_entity : child -> xml_external_entity ) ; ,SpiderLabs@ModSecurity/d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe,CVE-2013-1915,https://github.com/SpiderLabs/ModSecurity/commit/d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe,2013-04-25T23:55Z
1696,CWE-476,"<S2SV_StartBug> if ( used_address && used_address -> name_len == msg_sys -> msg_namelen && <S2SV_EndBug> <S2SV_StartBug> ! memcmp ( & used_address -> name , msg -> msg_name , <S2SV_EndBug> <S2SV_StartBug> memcpy ( & used_address -> name , msg -> msg_name , <S2SV_EndBug> ",<S2SV_ModStart> msg_sys -> msg_name && <S2SV_ModStart> msg_sys <S2SV_ModEnd> <S2SV_ModStart> if ( msg_sys -> msg_name ) <S2SV_ModStart> msg_sys <S2SV_ModEnd> ,torvalds@linux/bc909d9ddbf7778371e36a651d6e4194b1cc7d4c,CVE-2011-4594,https://github.com/torvalds/linux/commit/bc909d9ddbf7778371e36a651d6e4194b1cc7d4c,2012-05-17T11:00Z
1697,CWE-20,<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> ,torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
1698,CWE-119,"<S2SV_StartBug> offset , <S2SV_EndBug> <S2SV_StartBug> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) <S2SV_EndBug> <S2SV_StartBug> p = pixels + offset ; <S2SV_EndBug> <S2SV_StartBug> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) <S2SV_EndBug> ","<S2SV_ModStart> pixel_info_length ; ssize_t count , offset <S2SV_ModEnd> <S2SV_ModStart> ( offset < 0 ) || ( <S2SV_ModStart> ) <S2SV_ModStart> if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } <S2SV_ModStart>  <S2SV_ModEnd> ",ImageMagick@ImageMagick/73fb0aac5b958521e1511e179ecc0ad49f70ebaf,CVE-2016-10050,https://github.com/ImageMagick/ImageMagick/commit/73fb0aac5b958521e1511e179ecc0ad49f70ebaf,2017-03-23T17:59Z
1699,CWE-119,"<S2SV_StartBug> ( r = sshbuf_put_u32 ( b , comp -> enabled ) ) != 0 || <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> ,openbsd@src/3095060f479b86288e31c79ecbc5131a66bcd2f9,CVE-2016-10012,https://github.com/openbsd/src/commit/3095060f479b86288e31c79ecbc5131a66bcd2f9,2017-01-05T02:59Z
1700,CWE-000,"<S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ",<S2SV_ModStart> ssplit <S2SV_ModEnd> ,embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z
1701,CWE-399,<S2SV_StartBug> cib_client_t * client = user_data ; <S2SV_EndBug> <S2SV_StartBug> free ( client -> name ) ; <S2SV_EndBug> <S2SV_StartBug> free ( client ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ; int csock = 0 <S2SV_ModStart> if ( client -> remote_auth_timeout ) { g_source_remove ( client -> remote_auth_timeout ) ; } if ( client -> encrypted ) { # ifdef HAVE_GNUTLS_GNUTLS_H if ( client -> session ) { void * sock_ptr = gnutls_transport_get_ptr ( * client -> session ) ; csock = GPOINTER_TO_INT ( sock_ptr ) ; if ( client -> handshake_complete ) { gnutls_bye ( * client -> session , GNUTLS_SHUT_WR ) ; } gnutls_deinit ( * client -> session ) ; gnutls_free ( client -> session ) ; } # endif } else { csock = GPOINTER_TO_INT ( client -> session ) ; } client -> session = NULL ; if ( csock > 0 ) { close ( csock ) ; } <S2SV_ModStart> -> recv_buf ) ; free ( client ",ClusterLabs@pacemaker/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,CVE-2013-0281,https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,2013-11-23T11:55Z
1702,CWE-763,<S2SV_StartBug> * p = thread -> twups ; <S2SV_EndBug> <S2SV_StartBug> work ++ ; <S2SV_EndBug> ,<S2SV_ModStart> lua_assert ( ! isold ( thread ) || thread -> openupval == NULL ) ; <S2SV_ModStart> lua_assert ( getage ( uv ) <= getage ( thread ) ) ; ,lua@lua/a6da1472c0c5e05ff249325f979531ad51533110,CVE-2020-24371,https://github.com/lua/lua/commit/a6da1472c0c5e05ff249325f979531ad51533110,2020-08-17T17:15Z
1703,CWE-476,<S2SV_StartBug> px -> ft -> data = px ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! px -> ft ) { return FALSE ; } ,bitlbee@bitlbee/30d598ce7cd3f136ee9d7097f39fa9818a272441,CVE-2017-5668,https://github.com/bitlbee/bitlbee/commit/30d598ce7cd3f136ee9d7097f39fa9818a272441,2017-03-14T14:59Z
1704,CWE-476,<S2SV_StartBug> return FALSE ; <S2SV_EndBug> ,<S2SV_ModStart> transport -> credssp = NULL ; ,FreeRDP@FreeRDP/0773bb9303d24473fe1185d85a424dfe159aff53,CVE-2013-4119,https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53,2016-10-03T21:59Z
1705,CWE-20,"<S2SV_StartBug> olddentry = ovl_dentry_upper ( old ) ; <S2SV_EndBug> <S2SV_StartBug> newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , <S2SV_EndBug> <S2SV_StartBug> err = PTR_ERR ( newdentry ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( newdentry ) ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( olddentry -> d_parent != old_upperdir ) <S2SV_EndBug> <S2SV_StartBug> if ( newdentry -> d_parent != new_upperdir ) <S2SV_EndBug> <S2SV_StartBug> goto out_dput ; <S2SV_EndBug> <S2SV_StartBug> out_unlock : <S2SV_EndBug> ","<S2SV_ModStart> lookup_one_len ( old <S2SV_ModEnd> <S2SV_ModStart> old_upperdir , old <S2SV_ModEnd> <S2SV_ModStart> olddentry <S2SV_ModEnd> <S2SV_ModStart> olddentry <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> != ovl_dentry_upper ( old ) ) goto out_dput_old ; newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , new -> d_name . len ) ; err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out_dput_old ; err = - ESTALE ; if ( ovl_dentry_upper ( new ) ) { if ( opaquedir ) { if ( newdentry != opaquedir <S2SV_ModEnd> <S2SV_ModStart> } else { if ( newdentry != ovl_dentry_upper ( new ) <S2SV_ModEnd> <S2SV_ModStart> } } else { new_create = true ; if ( ! d_is_negative ( newdentry ) && ( ! new_opaque || ! ovl_is_whiteout ( newdentry ) ) ) goto out_dput ; } <S2SV_ModStart> out_dput_old : dput ( olddentry ) ; ",torvalds@linux/11f3710417d026ea2f4fcf362d866342c5274185,CVE-2016-6197,https://github.com/torvalds/linux/commit/11f3710417d026ea2f4fcf362d866342c5274185,2016-08-06T20:59Z
