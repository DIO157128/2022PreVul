,source,target
0,"CWE-119 bool initiate_stratum ( struct pool * pool ) { bool ret = false , recvd = false , noresume = false , sockd = false ; char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; json_error_t err ; int n2size ; resend : if ( ! setup_stratum_socket ( pool ) ) { sockd = false ; goto out ; } sockd = true ; if ( recvd ) { clear_sock ( pool ) ; sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[]}"" , swork_id ++ ) ; } else { if ( pool -> sessionid ) sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\"""" PACKAGE ""/"" VERSION ""\\"",<S2SV_blank>\\""%s\\""]}"" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\"""" PACKAGE ""/"" VERSION ""\\""]}"" , swork_id ++ ) ; } if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) { applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>s<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } if ( ! socket_full ( pool , DEFAULT_SOCKWAIT ) ) { applog ( LOG_DEBUG , ""Timed<S2SV_blank>out<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , ""JSON<S2SV_blank>decode<S2SV_blank>failed(%d):<S2SV_blank>%s"" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , ""result"" ) ; err_val = json_object_get ( val , ""error"" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val ) ) ) { char * ss ; if ( err_val ) ss = json_dumps ( err_val , JSON_INDENT ( 3 ) ) ; else ss = strdup ( ""(unknown<S2SV_blank>reason)"" ) ; applog ( LOG_INFO , ""JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s"" , ss ) ; free ( ss ) ; goto out ; } sessionid = get_sessionid ( res_val ) ; if ( ! sessionid ) applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; nonce1 = json_array_string ( res_val , 1 ) ; <S2SV_StartBug> if ( ! nonce1 ) { <S2SV_EndBug> <S2SV_StartBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; <S2SV_EndBug> free ( sessionid ) ; goto out ; } n2size = json_integer_value ( json_array_get ( res_val , 2 ) ) ; <S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> <S2SV_StartBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; <S2SV_EndBug> free ( sessionid ) ; free ( nonce1 ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; pool -> sessionid = sessionid ; pool -> nonce1 = nonce1 ; pool -> n1_len = strlen ( nonce1 ) / 2 ; free ( pool -> nonce1bin ) ; pool -> nonce1bin = calloc ( pool -> n1_len , 1 ) ; if ( unlikely ( ! pool -> nonce1bin ) ) quithere ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>pool->nonce1bin"" ) ; hex2bin ( pool -> nonce1bin , pool -> nonce1 , pool -> n1_len ) ; pool -> n2size = n2size ; cg_wunlock ( & pool -> data_lock ) ; if ( sessionid ) applog ( LOG_DEBUG , ""Pool<S2SV_blank>%d<S2SV_blank>stratum<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , pool -> pool_no , pool -> sessionid ) ; ret = true ; out : if ( ret ) { if ( ! pool -> stratum_url ) pool -> stratum_url = pool -> sockaddr_url ; pool -> stratum_active = true ; pool -> sdiff = 1 ; if ( opt_protocol ) { applog ( LOG_DEBUG , ""Pool<S2SV_blank>%d<S2SV_blank>confirmed<S2SV_blank>mining.subscribe<S2SV_blank>with<S2SV_blank>extranonce1<S2SV_blank>%s<S2SV_blank>extran2size<S2SV_blank>%d"" , pool -> pool_no , pool -> nonce1 , pool -> n2size ) ; } } else { if ( recvd && ! noresume ) { cg_wlock ( & pool -> data_lock ) ; free ( pool -> sessionid ) ; free ( pool -> nonce1 ) ; pool -> sessionid = pool -> nonce1 = NULL ; cg_wunlock ( & pool -> data_lock ) ; applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>resume<S2SV_blank>stratum,<S2SV_blank>trying<S2SV_blank>afresh"" ) ; noresume = true ; json_decref ( val ) ; goto resend ; } applog ( LOG_DEBUG , ""Initiate<S2SV_blank>stratum<S2SV_blank>failed"" ) ; if ( sockd ) suspend_stratum ( pool ) ; } json_decref ( val ) ; return ret ; }
","<S2SV_ModStart> if ( ! valid_hex ( nonce1 ) <S2SV_ModEnd> ) { applog <S2SV_ModStart> ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" <S2SV_ModEnd> ) ; free <S2SV_ModStart> ; if ( n2size < 2 || n2size > 16 <S2SV_ModEnd> ) { applog <S2SV_ModStart> ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" <S2SV_ModEnd> ) ; free
"
1,"CWE-125 void eap_print ( netdissect_options * ndo , register const u_char * cp , u_int length ) { const struct eap_frame_t * eap ; const u_char * tptr ; u_int tlen , type , subtype ; int count = 0 , len ; tptr = cp ; tlen = length ; eap = ( const struct eap_frame_t * ) cp ; ND_TCHECK ( * eap ) ; if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ; return ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ; tptr += sizeof ( const struct eap_frame_t ) ; tlen -= sizeof ( const struct eap_frame_t ) ; switch ( eap -> type ) { case EAP_FRAME_TYPE_PACKET : <S2SV_StartBug> type = * ( tptr ) ; <S2SV_EndBug> len = EXTRACT_16BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>id<S2SV_blank>%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_code_values , ""unknown"" , type ) , type , * ( tptr + 1 ) , len ) ) ; ND_TCHECK2 ( * tptr , len ) ; if ( type <= 2 ) { <S2SV_StartBug> subtype = * ( tptr + 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>Type<S2SV_blank>%s<S2SV_blank>(%u)"" , <S2SV_StartBug> tok2str ( eap_type_values , ""unknown"" , * ( tptr + 4 ) ) , <S2SV_EndBug> * ( tptr + 4 ) ) ) ; switch ( subtype ) { case EAP_TYPE_IDENTITY : if ( len - 5 > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Identity:<S2SV_blank>"" ) ) ; safeputs ( ndo , tptr + 5 , len - 5 ) ; } break ; case EAP_TYPE_NOTIFICATION : if ( len - 5 > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Notification:<S2SV_blank>"" ) ) ; safeputs ( ndo , tptr + 5 , len - 5 ) ; } break ; case EAP_TYPE_NAK : count = 5 ; while ( count < len ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" , <S2SV_EndBug> tok2str ( eap_type_values , ""unknown"" , * ( tptr + count ) ) , * ( tptr + count ) ) ) ; count ++ ; } break ; case EAP_TYPE_TTLS : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" , <S2SV_EndBug> EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ; <S2SV_StartBug> case EAP_TYPE_TLS : <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; if ( EAP_TLS_EXTRACT_BIT_L ( * ( tptr + 5 ) ) ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ; <S2SV_EndBug> } break ; case EAP_TYPE_FAST : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" , <S2SV_EndBug> EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; if ( EAP_TLS_EXTRACT_BIT_L ( * ( tptr + 5 ) ) ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ; <S2SV_EndBug> } break ; case EAP_TYPE_AKA : case EAP_TYPE_SIM : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , <S2SV_EndBug> tok2str ( eap_aka_subtype_values , ""unknown"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; break ; case EAP_TYPE_MD5_CHALLENGE : case EAP_TYPE_OTP : case EAP_TYPE_GTC : case EAP_TYPE_EXPANDED_TYPES : case EAP_TYPE_EXPERIMENTAL : default : break ; } } break ; case EAP_FRAME_TYPE_LOGOFF : case EAP_FRAME_TYPE_ENCAP_ASF_ALERT : default : break ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t[|EAP]"" ) ) ; }
","<S2SV_ModStart> case EAP_FRAME_TYPE_PACKET : ND_TCHECK_8BITS ( tptr ) ; <S2SV_ModStart> * ( tptr ) ; ND_TCHECK_16BITS ( tptr + 2 <S2SV_ModStart> 2 ) { ND_TCHECK_8BITS ( tptr + 4 ) ; <S2SV_ModStart> , ""unknown"" , subtype ) , subtype <S2SV_ModEnd> ) ) ; <S2SV_ModStart> len ) { ND_TCHECK_8BITS ( tptr + count ) ; <S2SV_ModStart> case EAP_TYPE_TTLS : case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ; if ( subtype == EAP_TYPE_TTLS ) <S2SV_ModStart> ) ) ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> case EAP_TYPE_FAST : ND_TCHECK_8BITS ( tptr + 5 ) ; <S2SV_ModStart> ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> case EAP_TYPE_SIM : ND_TCHECK_8BITS ( tptr + 5 ) ;
"
2,"CWE-401 int ath9k_wmi_cmd ( struct wmi * wmi , enum wmi_cmd_id cmd_id , u8 * cmd_buf , u32 cmd_len , u8 * rsp_buf , u32 rsp_len , u32 timeout ) { struct ath_hw * ah = wmi -> drv_priv -> ah ; struct ath_common * common = ath9k_hw_common ( ah ) ; u16 headroom = sizeof ( struct htc_frame_hdr ) + sizeof ( struct wmi_cmd_hdr ) ; struct sk_buff * skb ; unsigned long time_left ; int ret = 0 ; if ( ah -> ah_flags & AH_UNPLUGGED ) return 0 ; skb = alloc_skb ( headroom + cmd_len , GFP_ATOMIC ) ; if ( ! skb ) return - ENOMEM ; skb_reserve ( skb , headroom ) ; if ( cmd_len != 0 && cmd_buf != NULL ) { skb_put_data ( skb , cmd_buf , cmd_len ) ; } mutex_lock ( & wmi -> op_mutex ) ; if ( unlikely ( wmi -> stopped ) ) { ret = - EPROTO ; goto out ; } wmi -> cmd_rsp_buf = rsp_buf ; wmi -> cmd_rsp_len = rsp_len ; ret = ath9k_wmi_cmd_issue ( wmi , skb , cmd_id , cmd_len ) ; if ( ret ) goto out ; time_left = wait_for_completion_timeout ( & wmi -> cmd_wait , timeout ) ; if ( ! time_left ) { ath_dbg ( common , WMI , ""Timeout<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>WMI<S2SV_blank>command:<S2SV_blank>%s\\n"" , wmi_cmd_to_name ( cmd_id ) ) ; mutex_unlock ( & wmi -> op_mutex ) ; <S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug> } mutex_unlock ( & wmi -> op_mutex ) ; return 0 ; out : ath_dbg ( common , WMI , ""WMI<S2SV_blank>failure<S2SV_blank>for:<S2SV_blank>%s\\n"" , wmi_cmd_to_name ( cmd_id ) ) ; mutex_unlock ( & wmi -> op_mutex ) ; kfree_skb ( skb ) ; return ret ; }
","<S2SV_ModStart> op_mutex ) ; kfree_skb ( skb ) ;
"
3,"CWE-399 static int yam_ioctl ( struct net_device * dev , struct ifreq * ifr , int cmd ) { struct yam_port * yp = netdev_priv ( dev ) ; struct yamdrv_ioctl_cfg yi ; struct yamdrv_ioctl_mcs * ym ; int ioctl_cmd ; if ( copy_from_user ( & ioctl_cmd , ifr -> ifr_data , sizeof ( int ) ) ) return - EFAULT ; if ( yp -> magic != YAM_MAGIC ) return - EINVAL ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( cmd != SIOCDEVPRIVATE ) return - EINVAL ; switch ( ioctl_cmd ) { case SIOCYAMRESERVED : return - EINVAL ; case SIOCYAMSMCS : if ( netif_running ( dev ) ) return - EINVAL ; if ( ( ym = kmalloc ( sizeof ( struct yamdrv_ioctl_mcs ) , GFP_KERNEL ) ) == NULL ) return - ENOBUFS ; if ( copy_from_user ( ym , ifr -> ifr_data , sizeof ( struct yamdrv_ioctl_mcs ) ) ) { kfree ( ym ) ; return - EFAULT ; } if ( ym -> bitrate > YAM_MAXBITRATE ) { kfree ( ym ) ; return - EINVAL ; } add_mcs ( ym -> bits , ym -> bitrate , 0 ) ; kfree ( ym ) ; break ; case SIOCYAMSCFG : if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM ; if ( copy_from_user ( & yi , ifr -> ifr_data , sizeof ( struct yamdrv_ioctl_cfg ) ) ) return - EFAULT ; if ( ( yi . cfg . mask & YAM_IOBASE ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_IRQ ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_BITRATE ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_BAUDRATE ) && netif_running ( dev ) ) return - EINVAL ; if ( yi . cfg . mask & YAM_IOBASE ) { yp -> iobase = yi . cfg . iobase ; dev -> base_addr = yi . cfg . iobase ; } if ( yi . cfg . mask & YAM_IRQ ) { if ( yi . cfg . irq > 15 ) return - EINVAL ; yp -> irq = yi . cfg . irq ; dev -> irq = yi . cfg . irq ; } if ( yi . cfg . mask & YAM_BITRATE ) { if ( yi . cfg . bitrate > YAM_MAXBITRATE ) return - EINVAL ; yp -> bitrate = yi . cfg . bitrate ; } if ( yi . cfg . mask & YAM_BAUDRATE ) { if ( yi . cfg . baudrate > YAM_MAXBAUDRATE ) return - EINVAL ; yp -> baudrate = yi . cfg . baudrate ; } if ( yi . cfg . mask & YAM_MODE ) { if ( yi . cfg . mode > YAM_MAXMODE ) return - EINVAL ; yp -> dupmode = yi . cfg . mode ; } if ( yi . cfg . mask & YAM_HOLDDLY ) { if ( yi . cfg . holddly > YAM_MAXHOLDDLY ) return - EINVAL ; yp -> holdd = yi . cfg . holddly ; } if ( yi . cfg . mask & YAM_TXDELAY ) { if ( yi . cfg . txdelay > YAM_MAXTXDELAY ) return - EINVAL ; yp -> txd = yi . cfg . txdelay ; } if ( yi . cfg . mask & YAM_TXTAIL ) { if ( yi . cfg . txtail > YAM_MAXTXTAIL ) return - EINVAL ; yp -> txtail = yi . cfg . txtail ; } if ( yi . cfg . mask & YAM_PERSIST ) { if ( yi . cfg . persist > YAM_MAXPERSIST ) return - EINVAL ; yp -> pers = yi . cfg . persist ; } if ( yi . cfg . mask & YAM_SLOTTIME ) { if ( yi . cfg . slottime > YAM_MAXSLOTTIME ) return - EINVAL ; yp -> slot = yi . cfg . slottime ; yp -> slotcnt = yp -> slot / 10 ; } break ; case SIOCYAMGCFG : <S2SV_StartBug> yi . cfg . mask = 0xffffffff ; <S2SV_EndBug> yi . cfg . iobase = yp -> iobase ; yi . cfg . irq = yp -> irq ; yi . cfg . bitrate = yp -> bitrate ; yi . cfg . baudrate = yp -> baudrate ; yi . cfg . mode = yp -> dupmode ; yi . cfg . txdelay = yp -> txd ; yi . cfg . holddly = yp -> holdd ; yi . cfg . txtail = yp -> txtail ; yi . cfg . persist = yp -> pers ; yi . cfg . slottime = yp -> slot ; if ( copy_to_user ( ifr -> ifr_data , & yi , sizeof ( struct yamdrv_ioctl_cfg ) ) ) return - EFAULT ; break ; default : return - EINVAL ; } return 0 ; }
","<S2SV_ModStart> case SIOCYAMGCFG : memset ( & yi , 0 , sizeof ( yi ) ) ;
"
4,"CWE-189 static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY | SKB_GSO_UDP_TUNNEL | SKB_GSO_GRE | SKB_GSO_IPIP | SKB_GSO_SIT | SKB_GSO_MPLS ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & SKB_GSO_UDP_TUNNEL ) segs = skb_udp_tunnel_segment ( skb , features ) ; else { offset = skb_checksum_start_offset ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; tnl_hlen = skb_tnl_header_len ( skb ) ; <S2SV_StartBug> if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) { <S2SV_EndBug> if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ; } unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen ; packet_start = ( u8 * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset ; memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ) ; SKB_GSO_CB ( skb ) -> mac_offset -= frag_hdr_sz ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; ipv6_select_ident ( fptr , ( struct rt6_info * ) skb_dst ( skb ) ) ; segs = skb_segment ( skb , features ) ; } out : return segs ; }
","<S2SV_ModStart> ; if ( skb -> mac_header <S2SV_ModEnd> < ( tnl_hlen
"
5,"CWE-834 static int read_tfra ( MOVContext * mov , AVIOContext * f ) { MOVFragmentIndex * index = NULL ; int version , fieldlength , i , j ; int64_t pos = avio_tell ( f ) ; uint32_t size = avio_rb32 ( f ) ; void * tmp ; if ( avio_rb32 ( f ) != MKBETAG ( 't' , 'f' , 'r' , 'a' ) ) { return 1 ; } av_log ( mov -> fc , AV_LOG_VERBOSE , ""found<S2SV_blank>tfra\\n"" ) ; index = av_mallocz ( sizeof ( MOVFragmentIndex ) ) ; if ( ! index ) { return AVERROR ( ENOMEM ) ; } tmp = av_realloc_array ( mov -> fragment_index_data , mov -> fragment_index_count + 1 , sizeof ( MOVFragmentIndex * ) ) ; if ( ! tmp ) { av_freep ( & index ) ; return AVERROR ( ENOMEM ) ; } mov -> fragment_index_data = tmp ; mov -> fragment_index_data [ mov -> fragment_index_count ++ ] = index ; version = avio_r8 ( f ) ; avio_rb24 ( f ) ; index -> track_id = avio_rb32 ( f ) ; fieldlength = avio_rb32 ( f ) ; index -> item_count = avio_rb32 ( f ) ; index -> items = av_mallocz_array ( index -> item_count , sizeof ( MOVFragmentIndexItem ) ) ; if ( ! index -> items ) { index -> item_count = 0 ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < index -> item_count ; i ++ ) { <S2SV_StartBug> int64_t time , offset ; <S2SV_EndBug> if ( version == 1 ) { time = avio_rb64 ( f ) ; offset = avio_rb64 ( f ) ; } else { time = avio_rb32 ( f ) ; offset = avio_rb32 ( f ) ; } index -> items [ i ] . time = time ; index -> items [ i ] . moof_offset = offset ; for ( j = 0 ; j < ( ( fieldlength >> 4 ) & 3 ) + 1 ; j ++ ) avio_r8 ( f ) ; for ( j = 0 ; j < ( ( fieldlength >> 2 ) & 3 ) + 1 ; j ++ ) avio_r8 ( f ) ; for ( j = 0 ; j < ( ( fieldlength >> 0 ) & 3 ) + 1 ; j ++ ) avio_r8 ( f ) ; } avio_seek ( f , pos + size , SEEK_SET ) ; return 0 ; }
","<S2SV_ModStart> , offset ; if ( avio_feof ( f ) ) { index -> item_count = 0 ; av_freep ( & index -> items ) ; return AVERROR_INVALIDDATA ; }
"
6,"CWE-119 static struct se_portal_group * vhost_scsi_make_tpg ( struct se_wwn * wwn , struct config_group * group , const char * name ) { struct vhost_scsi_tport * tport = container_of ( wwn , struct vhost_scsi_tport , tport_wwn ) ; struct vhost_scsi_tpg * tpg ; <S2SV_StartBug> unsigned long tpgt ; <S2SV_EndBug> int ret ; if ( strstr ( name , ""tpgt_"" ) != name ) return ERR_PTR ( - EINVAL ) ; <S2SV_StartBug> if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) <S2SV_EndBug> return ERR_PTR ( - EINVAL ) ; tpg = kzalloc ( sizeof ( struct vhost_scsi_tpg ) , GFP_KERNEL ) ; if ( ! tpg ) { pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>struct<S2SV_blank>vhost_scsi_tpg"" ) ; return ERR_PTR ( - ENOMEM ) ; } mutex_init ( & tpg -> tv_tpg_mutex ) ; INIT_LIST_HEAD ( & tpg -> tv_tpg_list ) ; tpg -> tport = tport ; tpg -> tport_tpgt = tpgt ; ret = core_tpg_register ( & vhost_scsi_fabric_configfs -> tf_ops , wwn , & tpg -> se_tpg , tpg , TRANSPORT_TPG_TYPE_NORMAL ) ; if ( ret < 0 ) { kfree ( tpg ) ; return NULL ; } mutex_lock ( & vhost_scsi_mutex ) ; list_add_tail ( & tpg -> tv_tpg_list , & vhost_scsi_list ) ; mutex_unlock ( & vhost_scsi_mutex ) ; return & tpg -> se_tpg ; }
","<S2SV_ModStart> * tpg ; u16 <S2SV_ModEnd> tpgt ; int <S2SV_ModStart> ; if ( kstrtou16 <S2SV_ModEnd> ( name + <S2SV_ModStart> ) || tpgt >= VHOST_SCSI_MAX_TARGET <S2SV_ModEnd> ) return ERR_PTR
"
7,"CWE-416 void CleanWriters ( GF_List * writers ) { while ( gf_list_count ( writers ) ) { <S2SV_StartBug> TrackWriter * writer = ( TrackWriter * ) gf_list_get ( writers , 0 ) ; <S2SV_EndBug> gf_isom_box_del ( writer -> stco ) ; gf_isom_box_del ( ( GF_Box * ) writer -> stsc ) ; gf_free ( writer ) ; gf_list_rem ( writers , 0 ) ; } }
","<S2SV_ModStart> writers , 0 ) ; gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stco ) ; gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stsc
"
8,"CWE-20 void kvm_lapic_sync_from_vapic ( struct kvm_vcpu * vcpu ) { <S2SV_StartBug> u32 data ; <S2SV_EndBug> void * vapic ; if ( test_bit ( KVM_APIC_PV_EOI_PENDING , & vcpu -> arch . apic_attention ) ) apic_sync_pv_eoi_from_guest ( vcpu , vcpu -> arch . apic ) ; if ( ! test_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ) return ; <S2SV_StartBug> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <S2SV_EndBug> data = * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) ; kunmap_atomic ( vapic ) ; apic_set_tpr ( vcpu -> arch . apic , data & 0xff ) ; }
","<S2SV_ModStart> { u32 data <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) return ; kvm_read_guest_cached ( vcpu -> kvm , & <S2SV_ModEnd> vcpu -> arch <S2SV_ModStart> . apic -> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> ) ; apic_set_tpr
"
9,"CWE-20 int arch_dup_task_struct ( struct task_struct * dst , struct task_struct * src ) { flush_fp_to_thread ( src ) ; flush_altivec_to_thread ( src ) ; flush_vsx_to_thread ( src ) ; flush_spe_to_thread ( src ) ; <S2SV_StartBug> * dst = * src ; <S2SV_EndBug> clear_task_ebb ( dst ) ; return 0 ; }
","<S2SV_ModStart> src ) ; __switch_to_tm ( src ) ; tm_recheckpoint_new_task ( src ) ;
"
10,"CWE-119 cJSON * cJSON_GetArrayItem ( cJSON * array , int item ) { <S2SV_StartBug> cJSON * c = array -> child ; <S2SV_EndBug> <S2SV_StartBug> while ( c && item > 0 ) { <S2SV_EndBug> -- item ; c = c -> next ; <S2SV_StartBug> } <S2SV_EndBug> return c ; }
","<S2SV_ModStart> c = array ? array -> child : 0 <S2SV_ModEnd> ; while ( <S2SV_ModStart> > 0 ) item -- , <S2SV_ModEnd> c = c <S2SV_ModStart> -> next ; <S2SV_ModEnd> return c ;
"
11,"CWE-20 static ext3_fsblk_t get_sb_block ( void * * data , struct super_block * sb ) { ext3_fsblk_t sb_block ; char * options = ( char * ) * data ; if ( ! options || strncmp ( options , ""sb="" , 3 ) != 0 ) return 1 ; options += 3 ; sb_block = simple_strtoul ( options , & options , 0 ) ; if ( * options && * options != ',' ) { <S2SV_StartBug> ext3_msg ( sb , ""error:<S2SV_blank>invalid<S2SV_blank>sb<S2SV_blank>specification:<S2SV_blank>%s"" , <S2SV_EndBug> ( char * ) * data ) ; return 1 ; } if ( * options == ',' ) options ++ ; * data = ( void * ) options ; return sb_block ; }
","<S2SV_ModStart> ( sb , KERN_ERR ,
"
12,"CWE-000 static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , u32 features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * mac_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } offset = skb_checksum_start_offset ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; if ( ( skb_mac_header ( skb ) < skb -> head + frag_hdr_sz ) && pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ; unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = skb_network_header ( skb ) - skb_mac_header ( skb ) + unfrag_ip6hlen ; mac_start = skb_mac_header ( skb ) ; memmove ( mac_start - frag_hdr_sz , mac_start , unfrag_len ) ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; <S2SV_StartBug> ipv6_select_ident ( fptr ) ; <S2SV_EndBug> segs = skb_segment ( skb , features ) ; out : return segs ; }
","<S2SV_ModStart> ipv6_select_ident ( fptr , ( struct rt6_info * ) skb_dst ( skb )
"
13,"CWE-400 <S2SV_StartBug> void __perf_sw_event ( u32 event_id , u64 nr , int nmi , <S2SV_EndBug> struct pt_regs * regs , u64 addr ) { struct perf_sample_data data ; int rctx ; preempt_disable_notrace ( ) ; rctx = perf_swevent_get_recursion_context ( ) ; if ( rctx < 0 ) return ; perf_sample_data_init ( & data , addr ) ; <S2SV_StartBug> do_perf_sw_event ( PERF_TYPE_SOFTWARE , event_id , nr , nmi , & data , regs ) ; <S2SV_EndBug> perf_swevent_put_recursion_context ( rctx ) ; preempt_enable_notrace ( ) ; }
","<S2SV_ModStart> u64 nr , <S2SV_ModEnd> struct pt_regs * <S2SV_ModStart> , nr , <S2SV_ModEnd> & data ,
"
14,"CWE-119 static grub_disk_addr_t grub_ext2_read_block ( grub_fshelp_node_t node , grub_disk_addr_t fileblock ) { struct grub_ext2_data * data = node -> data ; struct grub_ext2_inode * inode = & node -> inode ; int blknr = - 1 ; unsigned int blksz = EXT2_BLOCK_SIZE ( data ) ; int log2_blksz = LOG2_EXT2_BLOCK_SIZE ( data ) ; if ( grub_le_to_cpu32 ( inode -> flags ) & EXT4_EXTENTS_FLAG ) { <S2SV_StartBug> # ifndef _MSC_VER <S2SV_EndBug> <S2SV_StartBug> char buf [ EXT2_BLOCK_SIZE ( data ) ] ; <S2SV_EndBug> # else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; # endif struct grub_ext4_extent_header * leaf ; struct grub_ext4_extent * ext ; int i ; leaf = grub_ext4_find_leaf ( data , buf , ( struct grub_ext4_extent_header * ) inode -> blocks . dir_blocks , fileblock ) ; if ( ! leaf ) { <S2SV_StartBug> grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ; <S2SV_EndBug> return - 1 ; } ext = ( struct grub_ext4_extent * ) ( leaf + 1 ) ; for ( i = 0 ; i < grub_le_to_cpu16 ( leaf -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( ext [ i ] . block ) ) break ; } if ( -- i >= 0 ) { fileblock -= grub_le_to_cpu32 ( ext [ i ] . block ) ; <S2SV_StartBug> if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> else <S2SV_EndBug> { grub_disk_addr_t start ; start = grub_le_to_cpu16 ( ext [ i ] . start_hi ) ; start = ( start << 32 ) + grub_le_to_cpu32 ( ext [ i ] . start ) ; <S2SV_StartBug> return fileblock + start ; <S2SV_EndBug> } } else { grub_error ( GRUB_ERR_BAD_FS , ""something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent"" ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> } if ( fileblock < INDIRECT_BLOCKS ) { blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ; } else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) { grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ; <S2SV_StartBug> if ( ! indir ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz , <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ; grub_free ( indir ) ; } else if ( fileblock < ( grub_disk_addr_t ) ( INDIRECT_BLOCKS + blksz / 4 ) * ( grub_disk_addr_t ) ( blksz / 4 + 1 ) ) { unsigned int perblock = blksz / 4 ; unsigned int rblock = fileblock - ( INDIRECT_BLOCKS + blksz / 4 ) ; grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ; <S2SV_StartBug> if ( ! indir ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz , <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz , <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ; grub_free ( indir ) ; } else { grub_error ( GRUB_ERR_NOT_IMPLEMENTED_YET , ""ext2fs<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>triple<S2SV_blank>indirect<S2SV_blank>blocks"" ) ; } return blknr ; }
","<S2SV_ModStart> EXT4_EXTENTS_FLAG ) { char * buf = grub_malloc ( <S2SV_ModEnd> EXT2_BLOCK_SIZE ( data <S2SV_ModStart> ( data ) ) ; if ( ! buf ) { return - 1 ; } <S2SV_ModEnd> struct grub_ext4_extent_header * <S2SV_ModStart> GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ; free ( buf <S2SV_ModStart> len ) ) { free ( buf ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModStart> start ) ; free ( buf ) ; <S2SV_ModStart> ""something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent"" ) ; free ( buf ) ; <S2SV_ModStart> 1 ; } free ( buf ) ; <S2SV_ModStart> ! indir ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> ! indir ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; }
"
15,"CWE-119 <S2SV_StartBug> static void fdct16 ( const int16_t in [ 16 ] , int16_t out [ 16 ] ) { <S2SV_EndBug> <S2SV_StartBug> int step1 [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int step2 [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int step3 [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int input [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int temp1 , temp2 ; <S2SV_EndBug> input [ 0 ] = in [ 0 ] + in [ 15 ] ; input [ 1 ] = in [ 1 ] + in [ 14 ] ; input [ 2 ] = in [ 2 ] + in [ 13 ] ; input [ 3 ] = in [ 3 ] + in [ 12 ] ; input [ 4 ] = in [ 4 ] + in [ 11 ] ; input [ 5 ] = in [ 5 ] + in [ 10 ] ; input [ 6 ] = in [ 6 ] + in [ 9 ] ; input [ 7 ] = in [ 7 ] + in [ 8 ] ; step1 [ 0 ] = in [ 7 ] - in [ 8 ] ; step1 [ 1 ] = in [ 6 ] - in [ 9 ] ; step1 [ 2 ] = in [ 5 ] - in [ 10 ] ; step1 [ 3 ] = in [ 4 ] - in [ 11 ] ; step1 [ 4 ] = in [ 3 ] - in [ 12 ] ; step1 [ 5 ] = in [ 2 ] - in [ 13 ] ; step1 [ 6 ] = in [ 1 ] - in [ 14 ] ; step1 [ 7 ] = in [ 0 ] - in [ 15 ] ; { <S2SV_StartBug> int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; <S2SV_EndBug> <S2SV_StartBug> int t0 , t1 , t2 , t3 ; <S2SV_EndBug> <S2SV_StartBug> int x0 , x1 , x2 , x3 ; <S2SV_EndBug> s0 = input [ 0 ] + input [ 7 ] ; s1 = input [ 1 ] + input [ 6 ] ; s2 = input [ 2 ] + input [ 5 ] ; s3 = input [ 3 ] + input [ 4 ] ; s4 = input [ 3 ] - input [ 4 ] ; s5 = input [ 2 ] - input [ 5 ] ; s6 = input [ 1 ] - input [ 6 ] ; s7 = input [ 0 ] - input [ 7 ] ; x0 = s0 + s3 ; x1 = s1 + s2 ; x2 = s1 - s2 ; x3 = s0 - s3 ; t0 = ( x0 + x1 ) * cospi_16_64 ; t1 = ( x0 - x1 ) * cospi_16_64 ; t2 = x3 * cospi_8_64 + x2 * cospi_24_64 ; t3 = x3 * cospi_24_64 - x2 * cospi_8_64 ; <S2SV_StartBug> out [ 0 ] = fdct_round_shift ( t0 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 4 ] = fdct_round_shift ( t2 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 8 ] = fdct_round_shift ( t1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 12 ] = fdct_round_shift ( t3 ) ; <S2SV_EndBug> t0 = ( s6 - s5 ) * cospi_16_64 ; t1 = ( s6 + s5 ) * cospi_16_64 ; t2 = fdct_round_shift ( t0 ) ; t3 = fdct_round_shift ( t1 ) ; x0 = s4 + t2 ; x1 = s4 - t2 ; x2 = s7 - t3 ; x3 = s7 + t3 ; t0 = x0 * cospi_28_64 + x3 * cospi_4_64 ; t1 = x1 * cospi_12_64 + x2 * cospi_20_64 ; t2 = x2 * cospi_12_64 + x1 * - cospi_20_64 ; t3 = x3 * cospi_28_64 + x0 * - cospi_4_64 ; <S2SV_StartBug> out [ 2 ] = fdct_round_shift ( t0 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 6 ] = fdct_round_shift ( t2 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 10 ] = fdct_round_shift ( t1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 14 ] = fdct_round_shift ( t3 ) ; <S2SV_EndBug> } temp1 = ( step1 [ 5 ] - step1 [ 2 ] ) * cospi_16_64 ; temp2 = ( step1 [ 4 ] - step1 [ 3 ] ) * cospi_16_64 ; step2 [ 2 ] = fdct_round_shift ( temp1 ) ; step2 [ 3 ] = fdct_round_shift ( temp2 ) ; temp1 = ( step1 [ 4 ] + step1 [ 3 ] ) * cospi_16_64 ; temp2 = ( step1 [ 5 ] + step1 [ 2 ] ) * cospi_16_64 ; step2 [ 4 ] = fdct_round_shift ( temp1 ) ; step2 [ 5 ] = fdct_round_shift ( temp2 ) ; step3 [ 0 ] = step1 [ 0 ] + step2 [ 3 ] ; step3 [ 1 ] = step1 [ 1 ] + step2 [ 2 ] ; step3 [ 2 ] = step1 [ 1 ] - step2 [ 2 ] ; step3 [ 3 ] = step1 [ 0 ] - step2 [ 3 ] ; step3 [ 4 ] = step1 [ 7 ] - step2 [ 4 ] ; step3 [ 5 ] = step1 [ 6 ] - step2 [ 5 ] ; step3 [ 6 ] = step1 [ 6 ] + step2 [ 5 ] ; step3 [ 7 ] = step1 [ 7 ] + step2 [ 4 ] ; temp1 = step3 [ 1 ] * - cospi_8_64 + step3 [ 6 ] * cospi_24_64 ; <S2SV_StartBug> temp2 = step3 [ 2 ] * - cospi_24_64 - step3 [ 5 ] * cospi_8_64 ; <S2SV_EndBug> step2 [ 1 ] = fdct_round_shift ( temp1 ) ; step2 [ 2 ] = fdct_round_shift ( temp2 ) ; <S2SV_StartBug> temp1 = step3 [ 2 ] * - cospi_8_64 + step3 [ 5 ] * cospi_24_64 ; <S2SV_EndBug> temp2 = step3 [ 1 ] * cospi_24_64 + step3 [ 6 ] * cospi_8_64 ; step2 [ 5 ] = fdct_round_shift ( temp1 ) ; step2 [ 6 ] = fdct_round_shift ( temp2 ) ; step1 [ 0 ] = step3 [ 0 ] + step2 [ 1 ] ; step1 [ 1 ] = step3 [ 0 ] - step2 [ 1 ] ; <S2SV_StartBug> step1 [ 2 ] = step3 [ 3 ] - step2 [ 2 ] ; <S2SV_EndBug> step1 [ 3 ] = step3 [ 3 ] + step2 [ 2 ] ; step1 [ 4 ] = step3 [ 4 ] + step2 [ 5 ] ; step1 [ 5 ] = step3 [ 4 ] - step2 [ 5 ] ; step1 [ 6 ] = step3 [ 7 ] - step2 [ 6 ] ; step1 [ 7 ] = step3 [ 7 ] + step2 [ 6 ] ; temp1 = step1 [ 0 ] * cospi_30_64 + step1 [ 7 ] * cospi_2_64 ; temp2 = step1 [ 1 ] * cospi_14_64 + step1 [ 6 ] * cospi_18_64 ; <S2SV_StartBug> out [ 1 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 9 ] = fdct_round_shift ( temp2 ) ; <S2SV_EndBug> temp1 = step1 [ 2 ] * cospi_22_64 + step1 [ 5 ] * cospi_10_64 ; temp2 = step1 [ 3 ] * cospi_6_64 + step1 [ 4 ] * cospi_26_64 ; <S2SV_StartBug> out [ 5 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 13 ] = fdct_round_shift ( temp2 ) ; <S2SV_EndBug> temp1 = step1 [ 3 ] * - cospi_26_64 + step1 [ 4 ] * cospi_6_64 ; temp2 = step1 [ 2 ] * - cospi_10_64 + step1 [ 5 ] * cospi_22_64 ; <S2SV_StartBug> out [ 3 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 11 ] = fdct_round_shift ( temp2 ) ; <S2SV_EndBug> temp1 = step1 [ 1 ] * - cospi_18_64 + step1 [ 6 ] * cospi_14_64 ; temp2 = step1 [ 0 ] * - cospi_2_64 + step1 [ 7 ] * cospi_30_64 ; <S2SV_StartBug> out [ 7 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> <S2SV_StartBug> out [ 15 ] = fdct_round_shift ( temp2 ) ; <S2SV_EndBug> }
","<S2SV_ModStart> fdct16 ( const tran_low_t <S2SV_ModEnd> in [ 16 <S2SV_ModStart> 16 ] , tran_low_t <S2SV_ModEnd> out [ 16 <S2SV_ModStart> ] ) { tran_high_t <S2SV_ModEnd> step1 [ 8 <S2SV_ModStart> 8 ] ; tran_high_t <S2SV_ModEnd> step2 [ 8 <S2SV_ModStart> 8 ] ; tran_high_t <S2SV_ModEnd> step3 [ 8 <S2SV_ModStart> 8 ] ; tran_high_t <S2SV_ModEnd> input [ 8 <S2SV_ModStart> 8 ] ; tran_high_t <S2SV_ModEnd> temp1 , temp2 <S2SV_ModStart> ] ; { tran_high_t <S2SV_ModEnd> s0 , s1 <S2SV_ModStart> , s7 ; tran_high_t <S2SV_ModEnd> t0 , t1 <S2SV_ModStart> , t3 ; tran_high_t <S2SV_ModEnd> x0 , x1 <S2SV_ModStart> 0 ] = ( tran_low_t ) <S2SV_ModStart> 4 ] = ( tran_low_t ) <S2SV_ModStart> 8 ] = ( tran_low_t ) <S2SV_ModStart> 12 ] = ( tran_low_t ) <S2SV_ModStart> 2 ] = ( tran_low_t ) <S2SV_ModStart> 6 ] = ( tran_low_t ) <S2SV_ModStart> 10 ] = ( tran_low_t ) <S2SV_ModStart> 14 ] = ( tran_low_t ) <S2SV_ModStart> 2 ] * cospi_24_64 + <S2SV_ModEnd> step3 [ 5 <S2SV_ModStart> 2 ] * cospi_8_64 - <S2SV_ModEnd> step3 [ 5 <S2SV_ModStart> [ 3 ] + step2 [ 2 ] ; step1 [ 3 ] = step3 [ 3 ] - step2 [ 2 ] ; step1 [ 4 ] = step3 [ 4 ] - step2 [ 5 ] ; step1 [ 5 ] = step3 [ 4 ] + <S2SV_ModEnd> step2 [ 5 <S2SV_ModStart> 1 ] = ( tran_low_t ) <S2SV_ModStart> 9 ] = ( tran_low_t ) <S2SV_ModStart> 5 ] = ( tran_low_t ) <S2SV_ModStart> 13 ] = ( tran_low_t ) <S2SV_ModStart> 3 ] = ( tran_low_t ) <S2SV_ModStart> 11 ] = ( tran_low_t ) <S2SV_ModStart> 7 ] = ( tran_low_t ) <S2SV_ModStart> 15 ] = ( tran_low_t )
"
16,"CWE-20 int bpf_check ( struct bpf_prog * * prog , union bpf_attr * attr ) { struct bpf_verifier_env * env ; struct bpf_verifer_log * log ; int ret = - EINVAL ; if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) return - EINVAL ; env = kzalloc ( sizeof ( struct bpf_verifier_env ) , GFP_KERNEL ) ; if ( ! env ) return - ENOMEM ; log = & env -> log ; env -> insn_aux_data = vzalloc ( sizeof ( struct bpf_insn_aux_data ) * ( * prog ) -> len ) ; ret = - ENOMEM ; if ( ! env -> insn_aux_data ) goto err_free_env ; env -> prog = * prog ; env -> ops = bpf_verifier_ops [ env -> prog -> type ] ; mutex_lock ( & bpf_verifier_lock ) ; if ( attr -> log_level || attr -> log_buf || attr -> log_size ) { log -> level = attr -> log_level ; log -> ubuf = ( char __user * ) ( unsigned long ) attr -> log_buf ; log -> len_total = attr -> log_size ; ret = - EINVAL ; if ( log -> len_total < 128 || log -> len_total > UINT_MAX >> 8 || ! log -> level || ! log -> ubuf ) goto err_unlock ; } env -> strict_alignment = ! ! ( attr -> prog_flags & BPF_F_STRICT_ALIGNMENT ) ; if ( ! IS_ENABLED ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) ) env -> strict_alignment = true ; if ( env -> prog -> aux -> offload ) { ret = bpf_prog_offload_verifier_prep ( env ) ; if ( ret ) goto err_unlock ; } ret = replace_map_fd_with_map_ptr ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> explored_states = kcalloc ( env -> prog -> len , sizeof ( struct bpf_verifier_state_list * ) , GFP_USER ) ; ret = - ENOMEM ; if ( ! env -> explored_states ) goto skip_full_check ; ret = check_cfg ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> allow_ptr_leaks = capable ( CAP_SYS_ADMIN ) ; ret = do_check ( env ) ; if ( env -> cur_state ) { free_verifier_state ( env -> cur_state , true ) ; env -> cur_state = NULL ; } skip_full_check : while ( ! pop_stack ( env , NULL , NULL ) ) ; free_states ( env ) ; if ( ret == 0 ) <S2SV_StartBug> ret = convert_ctx_accesses ( env ) ; <S2SV_EndBug> if ( ret == 0 ) ret = fixup_bpf_calls ( env ) ; if ( log -> level && bpf_verifier_log_full ( log ) ) ret = - ENOSPC ; if ( log -> level && ! log -> ubuf ) { ret = - EFAULT ; goto err_release_maps ; } if ( ret == 0 && env -> used_map_cnt ) { env -> prog -> aux -> used_maps = kmalloc_array ( env -> used_map_cnt , sizeof ( env -> used_maps [ 0 ] ) , GFP_KERNEL ) ; if ( ! env -> prog -> aux -> used_maps ) { ret = - ENOMEM ; goto err_release_maps ; } memcpy ( env -> prog -> aux -> used_maps , env -> used_maps , sizeof ( env -> used_maps [ 0 ] ) * env -> used_map_cnt ) ; env -> prog -> aux -> used_map_cnt = env -> used_map_cnt ; convert_pseudo_ld_imm64 ( env ) ; } err_release_maps : if ( ! env -> prog -> aux -> used_maps ) release_maps ( env ) ; * prog = env -> prog ; err_unlock : mutex_unlock ( & bpf_verifier_lock ) ; vfree ( env -> insn_aux_data ) ; err_free_env : kfree ( env ) ; return ret ; }
","<S2SV_ModStart> == 0 ) sanitize_dead_code ( env ) ; if ( ret == 0 )
"
17,"CWE-835 int WavpackSetConfiguration64 ( WavpackContext * wpc , WavpackConfig * config , int64_t total_samples , const unsigned char * chan_ids ) { uint32_t flags , bps = 0 ; uint32_t chan_mask = config -> channel_mask ; int num_chans = config -> num_channels ; <S2SV_StartBug> int i ; <S2SV_EndBug> wpc -> stream_version = ( config -> flags & CONFIG_COMPATIBLE_WRITE ) ? CUR_STREAM_VERS : MAX_STREAM_VERS ; if ( ( config -> qmode & QMODE_DSD_AUDIO ) && config -> bytes_per_sample == 1 && config -> bits_per_sample == 8 ) { # ifdef ENABLE_DSD wpc -> dsd_multiplier = 1 ; flags = DSD_FLAG ; for ( i = 14 ; i >= 0 ; -- i ) if ( config -> sample_rate % sample_rates [ i ] == 0 ) { int divisor = config -> sample_rate / sample_rates [ i ] ; if ( divisor && ( divisor & ( divisor - 1 ) ) == 0 ) { config -> sample_rate /= divisor ; wpc -> dsd_multiplier = divisor ; break ; } } if ( config -> flags & CONFIG_HYBRID_FLAG ) { strcpy ( wpc -> error_message , ""hybrid<S2SV_blank>mode<S2SV_blank>not<S2SV_blank>available<S2SV_blank>for<S2SV_blank>DSD!"" ) ; return FALSE ; } config -> flags &= ( CONFIG_HIGH_FLAG | CONFIG_MD5_CHECKSUM | CONFIG_PAIR_UNDEF_CHANS ) ; config -> float_norm_exp = config -> xmode = 0 ; # else strcpy ( wpc -> error_message , ""libwavpack<S2SV_blank>not<S2SV_blank>configured<S2SV_blank>for<S2SV_blank>DSD!"" ) ; return FALSE ; # endif } else flags = config -> bytes_per_sample - 1 ; wpc -> total_samples = total_samples ; wpc -> config . sample_rate = config -> sample_rate ; wpc -> config . num_channels = config -> num_channels ; wpc -> config . channel_mask = config -> channel_mask ; wpc -> config . bits_per_sample = config -> bits_per_sample ; wpc -> config . bytes_per_sample = config -> bytes_per_sample ; wpc -> config . block_samples = config -> block_samples ; wpc -> config . flags = config -> flags ; wpc -> config . qmode = config -> qmode ; if ( config -> flags & CONFIG_VERY_HIGH_FLAG ) wpc -> config . flags |= CONFIG_HIGH_FLAG ; for ( i = 0 ; i < 15 ; ++ i ) if ( wpc -> config . sample_rate == sample_rates [ i ] ) break ; flags |= i << SRATE_LSB ; if ( ! ( flags & DSD_FLAG ) ) { if ( config -> float_norm_exp ) { wpc -> config . float_norm_exp = config -> float_norm_exp ; wpc -> config . flags |= CONFIG_FLOAT_DATA ; flags |= FLOAT_DATA ; } else flags |= ( ( config -> bytes_per_sample * 8 ) - config -> bits_per_sample ) << SHIFT_LSB ; if ( config -> flags & CONFIG_HYBRID_FLAG ) { flags |= HYBRID_FLAG | HYBRID_BITRATE | HYBRID_BALANCE ; if ( ! ( wpc -> config . flags & CONFIG_SHAPE_OVERRIDE ) ) { wpc -> config . flags |= CONFIG_HYBRID_SHAPE | CONFIG_AUTO_SHAPING ; flags |= HYBRID_SHAPE | NEW_SHAPING ; } else if ( wpc -> config . flags & CONFIG_HYBRID_SHAPE ) { wpc -> config . shaping_weight = config -> shaping_weight ; flags |= HYBRID_SHAPE | NEW_SHAPING ; } if ( wpc -> config . flags & ( CONFIG_CROSS_DECORR | CONFIG_OPTIMIZE_WVC ) ) flags |= CROSS_DECORR ; if ( config -> flags & CONFIG_BITRATE_KBPS ) { bps = ( uint32_t ) floor ( config -> bitrate * 256000.0 / config -> sample_rate / config -> num_channels + 0.5 ) ; if ( bps > ( 64 << 8 ) ) bps = 64 << 8 ; } else bps = ( uint32_t ) floor ( config -> bitrate * 256.0 + 0.5 ) ; } else flags |= CROSS_DECORR ; if ( ! ( config -> flags & CONFIG_JOINT_OVERRIDE ) || ( config -> flags & CONFIG_JOINT_STEREO ) ) flags |= JOINT_STEREO ; if ( config -> flags & CONFIG_CREATE_WVC ) wpc -> wvc_flag = TRUE ; } if ( chan_ids ) { int lastchan = 0 , mask_copy = chan_mask ; if ( ( int ) strlen ( ( char * ) chan_ids ) > num_chans ) { strcpy ( wpc -> error_message , ""chan_ids<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>num<S2SV_blank>channels!"" ) ; return FALSE ; } while ( * chan_ids ) if ( * chan_ids <= 32 && * chan_ids > lastchan && ( mask_copy & ( 1 << ( * chan_ids - 1 ) ) ) ) { mask_copy &= ~ ( 1 << ( * chan_ids - 1 ) ) ; lastchan = * chan_ids ++ ; } else break ; for ( i = 0 ; chan_ids [ i ] ; i ++ ) if ( chan_ids [ i ] != 0xff ) { wpc -> channel_identities = ( unsigned char * ) strdup ( ( char * ) chan_ids ) ; break ; } } for ( wpc -> current_stream = 0 ; num_chans ; wpc -> current_stream ++ ) { WavpackStream * wps = malloc ( sizeof ( WavpackStream ) ) ; unsigned char left_chan_id = 0 , right_chan_id = 0 ; int pos , chans = 1 ; wpc -> streams = realloc ( wpc -> streams , ( wpc -> current_stream + 1 ) * sizeof ( wpc -> streams [ 0 ] ) ) ; wpc -> streams [ wpc -> current_stream ] = wps ; CLEAR ( * wps ) ; if ( chan_mask ) for ( pos = 0 ; pos < 32 ; ++ pos ) if ( chan_mask & ( 1 << pos ) ) { if ( left_chan_id ) { right_chan_id = pos + 1 ; break ; } else { chan_mask &= ~ ( 1 << pos ) ; left_chan_id = pos + 1 ; } } while ( ! right_chan_id && chan_ids && * chan_ids ) if ( left_chan_id ) right_chan_id = * chan_ids ; else left_chan_id = * chan_ids ++ ; if ( ! left_chan_id ) left_chan_id = right_chan_id = 0xff ; else if ( ! right_chan_id ) right_chan_id = 0xff ; if ( num_chans >= 2 ) { if ( ( config -> flags & CONFIG_PAIR_UNDEF_CHANS ) && left_chan_id == 0xff && right_chan_id == 0xff ) chans = 2 ; else for ( i = 0 ; i < NUM_STEREO_PAIRS ; ++ i ) if ( ( left_chan_id == stereo_pairs [ i ] . a && right_chan_id == stereo_pairs [ i ] . b ) || ( left_chan_id == stereo_pairs [ i ] . b && right_chan_id == stereo_pairs [ i ] . a ) ) { if ( right_chan_id <= 32 && ( chan_mask & ( 1 << ( right_chan_id - 1 ) ) ) ) chan_mask &= ~ ( 1 << ( right_chan_id - 1 ) ) ; else if ( chan_ids && * chan_ids == right_chan_id ) chan_ids ++ ; chans = 2 ; break ; } } num_chans -= chans ; if ( num_chans && wpc -> current_stream == NEW_MAX_STREAMS - 1 ) break ; memcpy ( wps -> wphdr . ckID , ""wvpk"" , 4 ) ; wps -> wphdr . ckSize = sizeof ( WavpackHeader ) - 8 ; SET_TOTAL_SAMPLES ( wps -> wphdr , wpc -> total_samples ) ; wps -> wphdr . version = wpc -> stream_version ; wps -> wphdr . flags = flags ; wps -> bits = bps ; if ( ! wpc -> current_stream ) wps -> wphdr . flags |= INITIAL_BLOCK ; if ( ! num_chans ) wps -> wphdr . flags |= FINAL_BLOCK ; if ( chans == 1 ) { wps -> wphdr . flags &= ~ ( JOINT_STEREO | CROSS_DECORR | HYBRID_BALANCE ) ; wps -> wphdr . flags |= MONO_FLAG ; } } wpc -> num_streams = wpc -> current_stream ; wpc -> current_stream = 0 ; if ( num_chans ) { strcpy ( wpc -> error_message , ""too<S2SV_blank>many<S2SV_blank>channels!"" ) ; return FALSE ; } if ( config -> flags & CONFIG_EXTRA_MODE ) wpc -> config . xmode = config -> xmode ? config -> xmode : 1 ; return TRUE ; }
","<S2SV_ModStart> int i ; if ( ! config -> sample_rate ) { strcpy ( wpc -> error_message , ""sample<S2SV_blank>rate<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>zero!"" ) ; return FALSE ; }
"
18,"CWE-787 int sr_do_ioctl ( Scsi_CD * cd , struct packet_command * cgc ) { struct scsi_device * SDev ; struct scsi_sense_hdr sshdr ; int result , err = 0 , retries = 0 ; <S2SV_StartBug> SDev = cd -> device ; <S2SV_EndBug> retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) { err = - ENODEV ; goto out ; } result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen , <S2SV_StartBug> ( unsigned char * ) cgc -> sense , & sshdr , <S2SV_EndBug> cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( driver_byte ( result ) != 0 ) { switch ( sshdr . sense_key ) { case UNIT_ATTENTION : SDev -> changed = 1 ; if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""disc<S2SV_blank>change<S2SV_blank>detected.\\n"" ) ; if ( retries ++ < 10 ) goto retry ; err = - ENOMEDIUM ; break ; case NOT_READY : if ( sshdr . asc == 0x04 && sshdr . ascq == 0x01 ) { if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""CDROM<S2SV_blank>not<S2SV_blank>ready<S2SV_blank>yet.\\n"" ) ; if ( retries ++ < 10 ) { ssleep ( 2 ) ; goto retry ; } else { err = - ENOMEDIUM ; break ; } } if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""CDROM<S2SV_blank>not<S2SV_blank>ready.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>there<S2SV_blank>"" ""is<S2SV_blank>a<S2SV_blank>disc<S2SV_blank>in<S2SV_blank>the<S2SV_blank>drive.\\n"" ) ; err = - ENOMEDIUM ; break ; case ILLEGAL_REQUEST : err = - EIO ; if ( sshdr . asc == 0x20 && sshdr . ascq == 0x00 ) err = - EDRIVE_CANT_DO_THIS ; break ; default : err = - EIO ; } } out : cgc -> stat = err ; return err ; }
","<S2SV_ModStart> = 0 ; unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ; <S2SV_ModStart> cd -> device ; if ( cgc -> sense ) senseptr = sense_buffer <S2SV_ModStart> -> buflen , senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( cgc -> sense ) memcpy ( cgc -> sense , sense_buffer , sizeof ( * <S2SV_ModEnd> cgc -> sense <S2SV_ModStart> cgc -> sense ) <S2SV_ModEnd> ) ; if
"
19,"CWE-119 int CLASS parse_jpeg ( int offset ) { int len , save , hlen , mark ; fseek ( ifp , offset , SEEK_SET ) ; if ( fgetc ( ifp ) != 0xff || fgetc ( ifp ) != 0xd8 ) return 0 ; while ( fgetc ( ifp ) == 0xff && ( mark = fgetc ( ifp ) ) != 0xda ) { order = 0x4d4d ; len = get2 ( ) - 2 ; save = ftell ( ifp ) ; if ( mark == 0xc0 || mark == 0xc3 || mark == 0xc9 ) { fgetc ( ifp ) ; raw_height = get2 ( ) ; raw_width = get2 ( ) ; } order = get2 ( ) ; hlen = get4 ( ) ; <S2SV_StartBug> if ( get4 ( ) == 0x48454150 ) <S2SV_EndBug> { # ifdef LIBRAW_LIBRARY_BUILD <S2SV_StartBug> imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_FixedLens ; <S2SV_EndBug> imgdata . lens . makernotes . LensMount = LIBRAW_MOUNT_FixedLens ; # endif parse_ciff ( save + hlen , len - hlen , 0 ) ; } if ( parse_tiff ( save + 6 ) ) apply_tiff ( ) ; fseek ( ifp , save + len , SEEK_SET ) ; } return 1 ; }
","<S2SV_ModStart> ) == 0x48454150 <S2SV_ModEnd> # ifdef LIBRAW_LIBRARY_BUILD <S2SV_ModStart> # ifdef LIBRAW_LIBRARY_BUILD && ( save + hlen ) >= 0 && ( save + hlen ) <= ifp -> size ( ) # endif ) { # ifdef LIBRAW_LIBRARY_BUILD
"
20,"CWE-119 <S2SV_StartBug> static void search_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi , <S2SV_EndBug> int partial_frame ) { <S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> struct loopfilter * const lf = & cm -> lf ; <S2SV_EndBug> const int min_filter_level = 0 ; const int max_filter_level = get_max_filter_level ( cpi ) ; <S2SV_StartBug> int best_err ; <S2SV_EndBug> int filt_best ; <S2SV_StartBug> int filt_direction = 0 ; <S2SV_EndBug> int filt_mid = clamp ( lf -> filter_level , min_filter_level , max_filter_level ) ; int filter_step = filt_mid < 16 ? 4 : filt_mid / 4 ; <S2SV_StartBug> int ss_err [ MAX_LOOP_FILTER + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ss_err , 0xFF , sizeof ( ss_err ) ) ; <S2SV_EndBug> vpx_yv12_copy_y ( cm -> frame_to_show , & cpi -> last_frame_uf ) ; best_err = try_filter_frame ( sd , cpi , filt_mid , partial_frame ) ; filt_best = filt_mid ; ss_err [ filt_mid ] = best_err ; while ( filter_step > 0 ) { const int filt_high = MIN ( filt_mid + filter_step , max_filter_level ) ; const int filt_low = MAX ( filt_mid - filter_step , min_filter_level ) ; <S2SV_StartBug> int filt_err ; <S2SV_EndBug> int bias = ( best_err >> ( 15 - ( filt_mid / 8 ) ) ) * filter_step ; <S2SV_StartBug> if ( cpi -> twopass . section_intra_rating < 20 ) <S2SV_EndBug> <S2SV_StartBug> bias = bias * cpi -> twopass . section_intra_rating / 20 ; <S2SV_EndBug> if ( cm -> tx_mode != ONLY_4X4 ) bias >>= 1 ; if ( filt_direction <= 0 && filt_low != filt_mid ) { if ( ss_err [ filt_low ] < 0 ) { <S2SV_StartBug> filt_err = try_filter_frame ( sd , cpi , filt_low , partial_frame ) ; <S2SV_EndBug> <S2SV_StartBug> ss_err [ filt_low ] = filt_err ; <S2SV_EndBug> } else { filt_err = ss_err [ filt_low ] ; } if ( ( filt_err - bias ) < best_err ) { <S2SV_StartBug> if ( filt_err < best_err ) <S2SV_EndBug> best_err = filt_err ; filt_best = filt_low ; } } if ( filt_direction >= 0 && filt_high != filt_mid ) { if ( ss_err [ filt_high ] < 0 ) { <S2SV_StartBug> filt_err = try_filter_frame ( sd , cpi , filt_high , partial_frame ) ; <S2SV_EndBug> <S2SV_StartBug> ss_err [ filt_high ] = filt_err ; <S2SV_EndBug> } else { filt_err = ss_err [ filt_high ] ; } if ( filt_err < ( best_err - bias ) ) { <S2SV_StartBug> best_err = filt_err ; <S2SV_EndBug> filt_best = filt_high ; } } if ( filt_best == filt_mid ) { filter_step /= 2 ; filt_direction = 0 ; } else { filt_direction = ( filt_best < filt_mid ) ? - 1 : 1 ; filt_mid = filt_best ; } } <S2SV_StartBug> lf -> filter_level = filt_best ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> search_filter_level ( const <S2SV_ModStart> partial_frame ) { const <S2SV_ModStart> -> common ; const <S2SV_ModStart> ) ; int <S2SV_ModEnd> filt_direction = 0 <S2SV_ModStart> filt_direction = 0 ; int64_t best_err ; int filt_best <S2SV_ModStart> / 4 ; int64_t <S2SV_ModEnd> ss_err [ MAX_LOOP_FILTER <S2SV_ModStart> 1 ] ; memset <S2SV_ModEnd> ( ss_err , <S2SV_ModStart> min_filter_level ) ; int64_t <S2SV_ModEnd> bias = ( <S2SV_ModStart> filter_step ; if ( ( cpi -> oxcf . pass == 2 ) && <S2SV_ModStart> < 20 ) ) bias = ( <S2SV_ModEnd> bias * cpi <S2SV_ModStart> twopass . section_intra_rating ) <S2SV_ModStart> 0 ) { ss_err [ filt_low ] <S2SV_ModEnd> = try_filter_frame ( <S2SV_ModStart> partial_frame ) ; } if ( ( ss_err [ filt_low ] <S2SV_ModEnd> - bias ) <S2SV_ModStart> { if ( ss_err [ filt_low ] < best_err ) best_err = ss_err [ filt_low ] <S2SV_ModEnd> ; filt_best = <S2SV_ModStart> 0 ) { ss_err [ filt_high ] <S2SV_ModEnd> = try_filter_frame ( <S2SV_ModStart> partial_frame ) ; } if ( ss_err [ filt_high ] <S2SV_ModEnd> < ( best_err <S2SV_ModStart> { best_err = ss_err [ filt_high ] <S2SV_ModEnd> ; filt_best = <S2SV_ModStart> ; } } return <S2SV_ModEnd> filt_best ; }
"
21,"CWE-787 int mp_unpack_full ( lua_State * L , int limit , int offset ) { size_t len ; const char * s ; mp_cur c ; int cnt ; int decode_all = ( ! limit && ! offset ) ; s = luaL_checklstring ( L , 1 , & len ) ; if ( offset < 0 || limit < 0 ) return luaL_error ( L , ""Invalid<S2SV_blank>request<S2SV_blank>to<S2SV_blank>unpack<S2SV_blank>with<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d."" , offset , len ) ; else if ( offset > len ) return luaL_error ( L , ""Start<S2SV_blank>offset<S2SV_blank>%d<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>input<S2SV_blank>length<S2SV_blank>%d."" , offset , len ) ; if ( decode_all ) limit = INT_MAX ; mp_cur_init ( & c , ( const unsigned char * ) s + offset , len - offset ) ; for ( cnt = 0 ; c . left > 0 && cnt < limit ; cnt ++ ) { mp_decode_to_lua_type ( L , & c ) ; if ( c . err == MP_CUR_ERROR_EOF ) { return luaL_error ( L , ""Missing<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>input."" ) ; } else if ( c . err == MP_CUR_ERROR_BADFMT ) { return luaL_error ( L , ""Bad<S2SV_blank>data<S2SV_blank>format<S2SV_blank>in<S2SV_blank>input."" ) ; } } if ( ! decode_all ) { int offset = len - c . left ; <S2SV_StartBug> lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ; <S2SV_EndBug> lua_insert ( L , 2 ) ; cnt += 1 ; } return cnt ; }
","<S2SV_ModStart> . left ; luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_unpack_full"" ) ;
"
22,"CWE-119 <S2SV_StartBug> static void encode_mv_component ( vp9_writer * w , int comp , <S2SV_EndBug> const nmv_component * mvcomp , int usehp ) { int offset ; const int sign = comp < 0 ; const int mag = sign ? - comp : comp ; const int mv_class = vp9_get_mv_class ( mag - 1 , & offset ) ; const int d = offset >> 3 ; const int fr = ( offset >> 1 ) & 3 ; const int hp = offset & 1 ; assert ( comp != 0 ) ; <S2SV_StartBug> vp9_write ( w , sign , mvcomp -> sign ) ; <S2SV_EndBug> vp9_write_token ( w , vp9_mv_class_tree , mvcomp -> classes , & mv_class_encodings [ mv_class ] ) ; if ( mv_class == MV_CLASS_0 ) { vp9_write_token ( w , vp9_mv_class0_tree , mvcomp -> class0 , & mv_class0_encodings [ d ] ) ; } else { int i ; const int n = mv_class + CLASS0_BITS - 1 ; for ( i = 0 ; i < n ; ++ i ) <S2SV_StartBug> vp9_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ; <S2SV_EndBug> } vp9_write_token ( w , vp9_mv_fp_tree , mv_class == MV_CLASS_0 ? mvcomp -> class0_fp [ d ] : mvcomp -> fp , & mv_fp_encodings [ fr ] ) ; if ( usehp ) <S2SV_StartBug> vp9_write ( w , hp , <S2SV_EndBug> mv_class == MV_CLASS_0 ? mvcomp -> class0_hp : mvcomp -> hp ) ; }
","<S2SV_ModStart> void encode_mv_component ( vpx_writer <S2SV_ModEnd> * w , <S2SV_ModStart> 0 ) ; vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> ++ i ) vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> ( usehp ) vpx_write <S2SV_ModEnd> ( w ,
"
23,"CWE-476 static unsigned int seedsize ( struct crypto_alg * alg ) { struct rng_alg * ralg = container_of ( alg , struct rng_alg , base ) ; <S2SV_StartBug> return alg -> cra_rng . rng_make_random ? <S2SV_EndBug> alg -> cra_rng . seedsize : ralg -> seedsize ; }
","<S2SV_ModStart> ) ; return <S2SV_ModEnd> ralg -> seedsize
"
24,"CWE-200 static int pptp_connect ( struct socket * sock , struct sockaddr * uservaddr , int sockaddr_len , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_pppox * sp = ( struct sockaddr_pppox * ) uservaddr ; struct pppox_sock * po = pppox_sk ( sk ) ; struct pptp_opt * opt = & po -> proto . pptp ; struct rtable * rt ; struct flowi4 fl4 ; int error = 0 ; <S2SV_StartBug> if ( sp -> sa_protocol != PX_PROTO_PPTP ) <S2SV_EndBug> return - EINVAL ; if ( lookup_chan_dst ( sp -> sa_addr . pptp . call_id , sp -> sa_addr . pptp . sin_addr . s_addr ) ) return - EALREADY ; lock_sock ( sk ) ; if ( sk -> sk_state & PPPOX_CONNECTED ) { error = - EBUSY ; goto end ; } if ( sk -> sk_state & PPPOX_DEAD ) { error = - EALREADY ; goto end ; } if ( ! opt -> src_addr . sin_addr . s_addr || ! sp -> sa_addr . pptp . sin_addr . s_addr ) { error = - EINVAL ; goto end ; } po -> chan . private = sk ; po -> chan . ops = & pptp_chan_ops ; rt = ip_route_output_ports ( sock_net ( sk ) , & fl4 , sk , opt -> dst_addr . sin_addr . s_addr , opt -> src_addr . sin_addr . s_addr , 0 , 0 , IPPROTO_GRE , RT_CONN_FLAGS ( sk ) , 0 ) ; if ( IS_ERR ( rt ) ) { error = - EHOSTUNREACH ; goto end ; } sk_setup_caps ( sk , & rt -> dst ) ; po -> chan . mtu = dst_mtu ( & rt -> dst ) ; if ( ! po -> chan . mtu ) po -> chan . mtu = PPP_MRU ; ip_rt_put ( rt ) ; po -> chan . mtu -= PPTP_HEADER_OVERHEAD ; po -> chan . hdrlen = 2 + sizeof ( struct pptp_gre_header ) ; error = ppp_register_channel ( & po -> chan ) ; if ( error ) { pr_err ( ""PPTP:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>PPP<S2SV_blank>channel<S2SV_blank>(%d)\\n"" , error ) ; goto end ; } opt -> dst_addr = sp -> sa_addr . pptp ; sk -> sk_state = PPPOX_CONNECTED ; end : release_sock ( sk ) ; return error ; }
","<S2SV_ModStart> ; if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ; if (
"
25,"CWE-20 error_t coapClientSetRxBlockSize ( CoapClientRequest * request , uint_t blockSize ) { if ( request == NULL ) return ERROR_INVALID_PARAMETER ; osAcquireMutex ( & request -> context -> mutex ) ; if ( blockSize == 16 ) <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_16 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 32 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_32 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 64 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_64 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 128 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_128 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 256 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_256 ; <S2SV_EndBug> <S2SV_StartBug> else if ( blockSize == 512 ) <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_512 ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> request -> rxBlockSzx = COAP_BLOCK_SIZE_1024 ; <S2SV_EndBug> if ( request -> rxBlockSzx > coapClientGetMaxBlockSize ( ) ) <S2SV_StartBug> request -> rxBlockSzx = coapClientGetMaxBlockSize ( ) ; <S2SV_EndBug> osReleaseMutex ( & request -> context -> mutex ) ; return NO_ERROR ; }
","<S2SV_ModStart> == 16 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_16 ; } <S2SV_ModStart> == 32 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_32 ; } <S2SV_ModStart> == 64 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_64 ; } <S2SV_ModStart> == 128 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_128 ; } <S2SV_ModStart> == 256 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_256 ; } <S2SV_ModStart> == 512 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_512 ; } else { <S2SV_ModEnd> request -> rxBlockSzx <S2SV_ModStart> = COAP_BLOCK_SIZE_1024 ; } <S2SV_ModStart> ( ) ) { <S2SV_ModStart> ( ) ; }
"
26,"CWE-476 int main ( int argc , char * * argv ) { int fmtid ; int id ; char * infile ; jas_stream_t * instream ; jas_image_t * image ; int width ; int height ; int depth ; int numcmpts ; int verbose ; <S2SV_StartBug> char * fmtname ; <S2SV_EndBug> if ( jas_init ( ) ) { abort ( ) ; } cmdname = argv [ 0 ] ; infile = 0 ; verbose = 0 ; <S2SV_StartBug> while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) { <S2SV_EndBug> switch ( id ) { case OPT_VERBOSE : verbose = 1 ; break ; case OPT_VERSION : printf ( ""%s\\n"" , JAS_VERSION ) ; exit ( EXIT_SUCCESS ) ; break ; <S2SV_StartBug> case OPT_INFILE : <S2SV_EndBug> infile = jas_optarg ; break ; case OPT_HELP : default : usage ( ) ; break ; } } <S2SV_StartBug> if ( infile ) { <S2SV_EndBug> if ( ! ( instream = jas_stream_fopen ( infile , ""rb"" ) ) ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>input<S2SV_blank>image<S2SV_blank>file<S2SV_blank>%s\\n"" , infile ) ; exit ( EXIT_FAILURE ) ; } } else { if ( ! ( instream = jas_stream_fdopen ( 0 , ""rb"" ) ) ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>standard<S2SV_blank>input\\n"" ) ; exit ( EXIT_FAILURE ) ; } } if ( ( fmtid = jas_image_getfmt ( instream ) ) < 0 ) { fprintf ( stderr , ""unknown<S2SV_blank>image<S2SV_blank>format\\n"" ) ; } <S2SV_StartBug> if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) { <S2SV_EndBug> fprintf ( stderr , ""cannot<S2SV_blank>load<S2SV_blank>image\\n"" ) ; return EXIT_FAILURE ; } jas_stream_close ( instream ) ; numcmpts = jas_image_numcmpts ( image ) ; width = jas_image_cmptwidth ( image , 0 ) ; height = jas_image_cmptheight ( image , 0 ) ; depth = jas_image_cmptprec ( image , 0 ) ; if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) { abort ( ) ; } printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n"" , fmtname , numcmpts , width , height , depth , ( long ) jas_image_rawsize ( image ) ) ; jas_image_destroy ( image ) ; jas_image_clearfmts ( ) ; return EXIT_SUCCESS ; }
","<S2SV_ModStart> char * fmtname ; int debug <S2SV_ModStart> = 0 ; debug = 0 ; <S2SV_ModStart> break ; case OPT_DEBUG : debug = atoi ( jas_optarg ) ; break ; case <S2SV_ModStart> ; } } jas_setdbglevel ( debug ) ; <S2SV_ModStart> ) ) { jas_stream_close ( instream ) ;
"
27,"CWE-000 asmlinkage void bad_mode ( struct pt_regs * regs , int reason , unsigned int esr ) <S2SV_StartBug> { <S2SV_EndBug> console_verbose ( ) ; pr_crit ( ""Bad<S2SV_blank>mode<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>handler<S2SV_blank>detected,<S2SV_blank>code<S2SV_blank>0x%08x\\n"" , handler [ reason ] , esr ) ; <S2SV_StartBug> die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , 0 ) ; <S2SV_EndBug> local_irq_disable ( ) ; panic ( ""bad<S2SV_blank>mode"" ) ; }
","<S2SV_ModStart> esr ) { siginfo_t info ; void __user * pc = ( void __user * ) instruction_pointer ( regs ) ; <S2SV_ModStart> esr ) ; __show_regs ( regs ) ; info . si_signo = SIGILL ; info . si_errno = 0 ; info . si_code = ILL_ILLOPC ; info . si_addr = pc ; arm64_notify_die <S2SV_ModEnd> ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , <S2SV_ModStart> , regs , & info , 0 <S2SV_ModEnd> ) ; }
"
28,"CWE-125 static void l2tp_ppp_discon_cc_print ( netdissect_options * ndo , const u_char * dat , u_int length ) { const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x,<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_cc_direction2str , <S2SV_StartBug> ""Direction-#%u"" , * ( ( const u_char * ) ptr ++ ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( length > 5 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; <S2SV_StartBug> print_string ( ndo , ( const u_char * ) ptr , length - 5 ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> ) dat ; if ( length < 5 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModStart> , EXTRACT_16BITS ( dat <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ) ) ; dat += 2 ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> , EXTRACT_16BITS ( dat <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ) ) ; dat += 2 ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> , ""Direction-#%u"" , EXTRACT_8BITS ( ptr <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ) ) ; ptr ++ ; length -- ; <S2SV_ModStart> if ( length != 0 <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> ptr , length <S2SV_ModEnd> ) ; }
"
29,"CWE-125 static int uas_switch_interface ( struct usb_device * udev , struct usb_interface * intf ) { <S2SV_StartBug> int alt ; <S2SV_EndBug> alt = uas_find_uas_alt_setting ( intf ) ; <S2SV_StartBug> if ( alt < 0 ) <S2SV_EndBug> return alt ; return usb_set_interface ( udev , <S2SV_StartBug> intf -> altsetting [ 0 ] . desc . bInterfaceNumber , alt ) ; <S2SV_EndBug> }
","<S2SV_ModStart> intf ) { struct usb_host_interface * <S2SV_ModEnd> alt ; alt <S2SV_ModStart> ; if ( ! alt ) return - ENODEV <S2SV_ModEnd> ; return usb_set_interface <S2SV_ModStart> ( udev , alt -> <S2SV_ModEnd> desc . bInterfaceNumber <S2SV_ModStart> bInterfaceNumber , alt -> desc . bAlternateSetting
"
30,"CWE-17 <S2SV_StartBug> static void udf_pc_to_char ( struct super_block * sb , unsigned char * from , <S2SV_EndBug> <S2SV_StartBug> int fromlen , unsigned char * to ) <S2SV_EndBug> { struct pathComponent * pc ; int elen = 0 ; <S2SV_StartBug> unsigned char * p = to ; <S2SV_EndBug> while ( elen < fromlen ) { pc = ( struct pathComponent * ) ( from + elen ) ; switch ( pc -> componentType ) { case 1 : if ( pc -> lengthComponentIdent > 0 ) break ; case 2 : <S2SV_StartBug> p = to ; <S2SV_EndBug> * p ++ = '/' ; <S2SV_StartBug> break ; <S2SV_EndBug> case 3 : memcpy ( p , ""../"" , 3 ) ; p += 3 ; <S2SV_StartBug> break ; <S2SV_EndBug> case 4 : <S2SV_StartBug> memcpy ( p , ""./"" , 2 ) ; <S2SV_EndBug> p += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> case 5 : <S2SV_StartBug> p += udf_get_filename ( sb , pc -> componentIdent , p , <S2SV_EndBug> pc -> lengthComponentIdent ) ; <S2SV_StartBug> * p ++ = '/' ; <S2SV_EndBug> break ; } elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ; } if ( p > to + 1 ) p [ - 1 ] = '\\0' ; else p [ 0 ] = '\\0' ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> udf_pc_to_char ( struct <S2SV_ModStart> char * to , int tolen <S2SV_ModStart> = 0 ; int comp_len ; <S2SV_ModStart> p = to ; tolen -- <S2SV_ModStart> case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ; <S2SV_ModStart> = '/' ; tolen -- ; break ; case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ; <S2SV_ModEnd> memcpy ( p <S2SV_ModStart> += 3 ; tolen -= 3 ; <S2SV_ModStart> case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ; <S2SV_ModStart> += 2 ; tolen -= 2 ; <S2SV_ModStart> case 5 : comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ; p += comp_len ; tolen -= comp_len ; if ( tolen == 0 ) return - ENAMETOOLONG <S2SV_ModEnd> ; * p <S2SV_ModStart> ++ = '/' ; tolen -- <S2SV_ModStart> = '\\0' ; return 0 ;
"
31,"CWE-119 void loadServerConfigFromString ( char * config ) { char * err = NULL ; int linenum = 0 , totlines , i ; int slaveof_linenum = 0 ; sds * lines ; lines = sdssplitlen ( config , strlen ( config ) , ""\\n"" , 1 , & totlines ) ; for ( i = 0 ; i < totlines ; i ++ ) { sds * argv ; int argc ; linenum = i + 1 ; lines [ i ] = sdstrim ( lines [ i ] , ""<S2SV_blank>\\t\\r\\n"" ) ; if ( lines [ i ] [ 0 ] == '#' || lines [ i ] [ 0 ] == '\\0' ) continue ; argv = sdssplitargs ( lines [ i ] , & argc ) ; if ( argv == NULL ) { err = ""Unbalanced<S2SV_blank>quotes<S2SV_blank>in<S2SV_blank>configuration<S2SV_blank>line"" ; goto loaderr ; } if ( argc == 0 ) { sdsfreesplitres ( argv , argc ) ; continue ; } sdstolower ( argv [ 0 ] ) ; if ( ! strcasecmp ( argv [ 0 ] , ""timeout"" ) && argc == 2 ) { server . maxidletime = atoi ( argv [ 1 ] ) ; if ( server . maxidletime < 0 ) { err = ""Invalid<S2SV_blank>timeout<S2SV_blank>value"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""tcp-keepalive"" ) && argc == 2 ) { server . tcpkeepalive = atoi ( argv [ 1 ] ) ; if ( server . tcpkeepalive < 0 ) { err = ""Invalid<S2SV_blank>tcp-keepalive<S2SV_blank>value"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""protected-mode"" ) && argc == 2 ) { if ( ( server . protected_mode = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""port"" ) && argc == 2 ) { server . port = atoi ( argv [ 1 ] ) ; if ( server . port < 0 || server . port > 65535 ) { err = ""Invalid<S2SV_blank>port"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""tcp-backlog"" ) && argc == 2 ) { server . tcp_backlog = atoi ( argv [ 1 ] ) ; if ( server . tcp_backlog < 0 ) { err = ""Invalid<S2SV_blank>backlog<S2SV_blank>value"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""bind"" ) && argc >= 2 ) { int j , addresses = argc - 1 ; if ( addresses > CONFIG_BINDADDR_MAX ) { err = ""Too<S2SV_blank>many<S2SV_blank>bind<S2SV_blank>addresses<S2SV_blank>specified"" ; goto loaderr ; } for ( j = 0 ; j < addresses ; j ++ ) server . bindaddr [ j ] = zstrdup ( argv [ j + 1 ] ) ; server . bindaddr_count = addresses ; } else if ( ! strcasecmp ( argv [ 0 ] , ""unixsocket"" ) && argc == 2 ) { server . unixsocket = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""unixsocketperm"" ) && argc == 2 ) { errno = 0 ; server . unixsocketperm = ( mode_t ) strtol ( argv [ 1 ] , NULL , 8 ) ; if ( errno || server . unixsocketperm > 0777 ) { err = ""Invalid<S2SV_blank>socket<S2SV_blank>file<S2SV_blank>permissions"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""save"" ) ) { if ( argc == 3 ) { int seconds = atoi ( argv [ 1 ] ) ; int changes = atoi ( argv [ 2 ] ) ; if ( seconds < 1 || changes < 0 ) { err = ""Invalid<S2SV_blank>save<S2SV_blank>parameters"" ; goto loaderr ; } appendServerSaveParams ( seconds , changes ) ; } else if ( argc == 2 && ! strcasecmp ( argv [ 1 ] , """" ) ) { resetServerSaveParams ( ) ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""dir"" ) && argc == 2 ) { if ( chdir ( argv [ 1 ] ) == - 1 ) { serverLog ( LL_WARNING , ""Can\'t<S2SV_blank>chdir<S2SV_blank>to<S2SV_blank>\'%s\':<S2SV_blank>%s"" , argv [ 1 ] , strerror ( errno ) ) ; exit ( 1 ) ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""loglevel"" ) && argc == 2 ) { server . verbosity = configEnumGetValue ( loglevel_enum , argv [ 1 ] ) ; if ( server . verbosity == INT_MIN ) { err = ""Invalid<S2SV_blank>log<S2SV_blank>level.<S2SV_blank>"" ""Must<S2SV_blank>be<S2SV_blank>one<S2SV_blank>of<S2SV_blank>debug,<S2SV_blank>verbose,<S2SV_blank>notice,<S2SV_blank>warning"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""logfile"" ) && argc == 2 ) { FILE * logfp ; zfree ( server . logfile ) ; server . logfile = zstrdup ( argv [ 1 ] ) ; if ( server . logfile [ 0 ] != '\\0' ) { logfp = fopen ( server . logfile , ""a"" ) ; if ( logfp == NULL ) { err = sdscatprintf ( sdsempty ( ) , ""Can\'t<S2SV_blank>open<S2SV_blank>the<S2SV_blank>log<S2SV_blank>file:<S2SV_blank>%s"" , strerror ( errno ) ) ; goto loaderr ; } fclose ( logfp ) ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""syslog-enabled"" ) && argc == 2 ) { if ( ( server . syslog_enabled = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""syslog-ident"" ) && argc == 2 ) { if ( server . syslog_ident ) zfree ( server . syslog_ident ) ; server . syslog_ident = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""syslog-facility"" ) && argc == 2 ) { server . syslog_facility = configEnumGetValue ( syslog_facility_enum , argv [ 1 ] ) ; if ( server . syslog_facility == INT_MIN ) { err = ""Invalid<S2SV_blank>log<S2SV_blank>facility.<S2SV_blank>Must<S2SV_blank>be<S2SV_blank>one<S2SV_blank>of<S2SV_blank>USER<S2SV_blank>or<S2SV_blank>between<S2SV_blank>LOCAL0-LOCAL7"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""databases"" ) && argc == 2 ) { server . dbnum = atoi ( argv [ 1 ] ) ; if ( server . dbnum < 1 ) { err = ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>databases"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""include"" ) && argc == 2 ) { loadServerConfig ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""maxclients"" ) && argc == 2 ) { server . maxclients = atoi ( argv [ 1 ] ) ; if ( server . maxclients < 1 ) { err = ""Invalid<S2SV_blank>max<S2SV_blank>clients<S2SV_blank>limit"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""maxmemory"" ) && argc == 2 ) { server . maxmemory = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""maxmemory-policy"" ) && argc == 2 ) { server . maxmemory_policy = configEnumGetValue ( maxmemory_policy_enum , argv [ 1 ] ) ; if ( server . maxmemory_policy == INT_MIN ) { err = ""Invalid<S2SV_blank>maxmemory<S2SV_blank>policy"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""maxmemory-samples"" ) && argc == 2 ) { server . maxmemory_samples = atoi ( argv [ 1 ] ) ; if ( server . maxmemory_samples <= 0 ) { err = ""maxmemory-samples<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""lfu-log-factor"" ) && argc == 2 ) { server . lfu_log_factor = atoi ( argv [ 1 ] ) ; if ( server . maxmemory_samples < 0 ) { err = ""lfu-log-factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>0<S2SV_blank>or<S2SV_blank>greater"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""lfu-decay-time"" ) && argc == 2 ) { server . lfu_decay_time = atoi ( argv [ 1 ] ) ; if ( server . maxmemory_samples < 1 ) { err = ""lfu-decay-time<S2SV_blank>must<S2SV_blank>be<S2SV_blank>0<S2SV_blank>or<S2SV_blank>greater"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""slaveof"" ) && argc == 3 ) { slaveof_linenum = linenum ; server . masterhost = sdsnew ( argv [ 1 ] ) ; server . masterport = atoi ( argv [ 2 ] ) ; server . repl_state = REPL_STATE_CONNECT ; } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-ping-slave-period"" ) && argc == 2 ) { server . repl_ping_slave_period = atoi ( argv [ 1 ] ) ; if ( server . repl_ping_slave_period <= 0 ) { err = ""repl-ping-slave-period<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-timeout"" ) && argc == 2 ) { server . repl_timeout = atoi ( argv [ 1 ] ) ; if ( server . repl_timeout <= 0 ) { err = ""repl-timeout<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-disable-tcp-nodelay"" ) && argc == 2 ) { if ( ( server . repl_disable_tcp_nodelay = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-diskless-sync"" ) && argc == 2 ) { if ( ( server . repl_diskless_sync = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-diskless-sync-delay"" ) && argc == 2 ) { server . repl_diskless_sync_delay = atoi ( argv [ 1 ] ) ; if ( server . repl_diskless_sync_delay < 0 ) { err = ""repl-diskless-sync-delay<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>negative"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-backlog-size"" ) && argc == 2 ) { long long size = memtoll ( argv [ 1 ] , NULL ) ; if ( size <= 0 ) { err = ""repl-backlog-size<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater."" ; goto loaderr ; } resizeReplicationBacklog ( size ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""repl-backlog-ttl"" ) && argc == 2 ) { server . repl_backlog_time_limit = atoi ( argv [ 1 ] ) ; if ( server . repl_backlog_time_limit < 0 ) { err = ""repl-backlog-ttl<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>negative<S2SV_blank>"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""masterauth"" ) && argc == 2 ) { zfree ( server . masterauth ) ; server . masterauth = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""slave-serve-stale-data"" ) && argc == 2 ) { if ( ( server . repl_serve_stale_data = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""slave-read-only"" ) && argc == 2 ) { if ( ( server . repl_slave_ro = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""rdbcompression"" ) && argc == 2 ) { if ( ( server . rdb_compression = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""rdbchecksum"" ) && argc == 2 ) { if ( ( server . rdb_checksum = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""activerehashing"" ) && argc == 2 ) { if ( ( server . activerehashing = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""lazyfree-lazy-eviction"" ) && argc == 2 ) { if ( ( server . lazyfree_lazy_eviction = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""lazyfree-lazy-expire"" ) && argc == 2 ) { if ( ( server . lazyfree_lazy_expire = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""lazyfree-lazy-server-del"" ) && argc == 2 ) { if ( ( server . lazyfree_lazy_server_del = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""slave-lazy-flush"" ) && argc == 2 ) { if ( ( server . repl_slave_lazy_flush = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""daemonize"" ) && argc == 2 ) { if ( ( server . daemonize = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""hz"" ) && argc == 2 ) { server . hz = atoi ( argv [ 1 ] ) ; if ( server . hz < CONFIG_MIN_HZ ) server . hz = CONFIG_MIN_HZ ; if ( server . hz > CONFIG_MAX_HZ ) server . hz = CONFIG_MAX_HZ ; } else if ( ! strcasecmp ( argv [ 0 ] , ""appendonly"" ) && argc == 2 ) { int yes ; if ( ( yes = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } server . aof_state = yes ? AOF_ON : AOF_OFF ; } else if ( ! strcasecmp ( argv [ 0 ] , ""appendfilename"" ) && argc == 2 ) { if ( ! pathIsBaseName ( argv [ 1 ] ) ) { err = ""appendfilename<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>a<S2SV_blank>path,<S2SV_blank>just<S2SV_blank>a<S2SV_blank>filename"" ; goto loaderr ; } zfree ( server . aof_filename ) ; server . aof_filename = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""no-appendfsync-on-rewrite"" ) && argc == 2 ) { if ( ( server . aof_no_fsync_on_rewrite = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""appendfsync"" ) && argc == 2 ) { server . aof_fsync = configEnumGetValue ( aof_fsync_enum , argv [ 1 ] ) ; if ( server . aof_fsync == INT_MIN ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'no\',<S2SV_blank>\'always\'<S2SV_blank>or<S2SV_blank>\'everysec\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""auto-aof-rewrite-percentage"" ) && argc == 2 ) { server . aof_rewrite_perc = atoi ( argv [ 1 ] ) ; if ( server . aof_rewrite_perc < 0 ) { err = ""Invalid<S2SV_blank>negative<S2SV_blank>percentage<S2SV_blank>for<S2SV_blank>AOF<S2SV_blank>auto<S2SV_blank>rewrite"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""auto-aof-rewrite-min-size"" ) && argc == 2 ) { server . aof_rewrite_min_size = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""aof-rewrite-incremental-fsync"" ) && argc == 2 ) { if ( ( server . aof_rewrite_incremental_fsync = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""aof-load-truncated"" ) && argc == 2 ) { if ( ( server . aof_load_truncated = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""aof-use-rdb-preamble"" ) && argc == 2 ) { if ( ( server . aof_use_rdb_preamble = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""requirepass"" ) && argc == 2 ) { if ( strlen ( argv [ 1 ] ) > CONFIG_AUTHPASS_MAX_LEN ) { err = ""Password<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>CONFIG_AUTHPASS_MAX_LEN"" ; goto loaderr ; } server . requirepass = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""pidfile"" ) && argc == 2 ) { zfree ( server . pidfile ) ; server . pidfile = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""dbfilename"" ) && argc == 2 ) { if ( ! pathIsBaseName ( argv [ 1 ] ) ) { err = ""dbfilename<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>a<S2SV_blank>path,<S2SV_blank>just<S2SV_blank>a<S2SV_blank>filename"" ; goto loaderr ; } zfree ( server . rdb_filename ) ; server . rdb_filename = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""hash-max-ziplist-entries"" ) && argc == 2 ) { server . hash_max_ziplist_entries = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""hash-max-ziplist-value"" ) && argc == 2 ) { server . hash_max_ziplist_value = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""list-max-ziplist-entries"" ) && argc == 2 ) { } else if ( ! strcasecmp ( argv [ 0 ] , ""list-max-ziplist-value"" ) && argc == 2 ) { } else if ( ! strcasecmp ( argv [ 0 ] , ""list-max-ziplist-size"" ) && argc == 2 ) { server . list_max_ziplist_size = atoi ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""list-compress-depth"" ) && argc == 2 ) { server . list_compress_depth = atoi ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""set-max-intset-entries"" ) && argc == 2 ) { server . set_max_intset_entries = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""zset-max-ziplist-entries"" ) && argc == 2 ) { server . zset_max_ziplist_entries = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""zset-max-ziplist-value"" ) && argc == 2 ) { server . zset_max_ziplist_value = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""hll-sparse-max-bytes"" ) && argc == 2 ) { server . hll_sparse_max_bytes = memtoll ( argv [ 1 ] , NULL ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""rename-command"" ) && argc == 3 ) { struct redisCommand * cmd = lookupCommand ( argv [ 1 ] ) ; int retval ; if ( ! cmd ) { err = ""No<S2SV_blank>such<S2SV_blank>command<S2SV_blank>in<S2SV_blank>rename-command"" ; goto loaderr ; } retval = dictDelete ( server . commands , argv [ 1 ] ) ; serverAssert ( retval == DICT_OK ) ; if ( sdslen ( argv [ 2 ] ) != 0 ) { sds copy = sdsdup ( argv [ 2 ] ) ; retval = dictAdd ( server . commands , copy , cmd ) ; if ( retval != DICT_OK ) { sdsfree ( copy ) ; err = ""Target<S2SV_blank>command<S2SV_blank>name<S2SV_blank>already<S2SV_blank>exists"" ; goto loaderr ; } } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-enabled"" ) && argc == 2 ) { if ( ( server . cluster_enabled = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-config-file"" ) && argc == 2 ) { zfree ( server . cluster_configfile ) ; server . cluster_configfile = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-announce-ip"" ) && argc == 2 ) { zfree ( server . cluster_announce_ip ) ; server . cluster_announce_ip = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-announce-port"" ) && argc == 2 ) { server . cluster_announce_port = atoi ( argv [ 1 ] ) ; if ( server . cluster_announce_port < 0 || server . cluster_announce_port > 65535 ) { err = ""Invalid<S2SV_blank>port"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-announce-bus-port"" ) && argc == 2 ) { server . cluster_announce_bus_port = atoi ( argv [ 1 ] ) ; if ( server . cluster_announce_bus_port < 0 || server . cluster_announce_bus_port > 65535 ) { err = ""Invalid<S2SV_blank>port"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-require-full-coverage"" ) && argc == 2 ) { if ( ( server . cluster_require_full_coverage = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-node-timeout"" ) && argc == 2 ) { server . cluster_node_timeout = strtoll ( argv [ 1 ] , NULL , 10 ) ; if ( server . cluster_node_timeout <= 0 ) { err = ""cluster<S2SV_blank>node<S2SV_blank>timeout<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-migration-barrier"" ) && argc == 2 ) { server . cluster_migration_barrier = atoi ( argv [ 1 ] ) ; if ( server . cluster_migration_barrier < 0 ) { err = ""cluster<S2SV_blank>migration<S2SV_blank>barrier<S2SV_blank>must<S2SV_blank>zero<S2SV_blank>or<S2SV_blank>positive"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""cluster-slave-validity-factor"" ) && argc == 2 ) { server . cluster_slave_validity_factor = atoi ( argv [ 1 ] ) ; if ( server . cluster_slave_validity_factor < 0 ) { err = ""cluster<S2SV_blank>slave<S2SV_blank>validity<S2SV_blank>factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>zero<S2SV_blank>or<S2SV_blank>positive"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""lua-time-limit"" ) && argc == 2 ) { server . lua_time_limit = strtoll ( argv [ 1 ] , NULL , 10 ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""slowlog-log-slower-than"" ) && argc == 2 ) { server . slowlog_log_slower_than = strtoll ( argv [ 1 ] , NULL , 10 ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""latency-monitor-threshold"" ) && argc == 2 ) { server . latency_monitor_threshold = strtoll ( argv [ 1 ] , NULL , 10 ) ; if ( server . latency_monitor_threshold < 0 ) { err = ""The<S2SV_blank>latency<S2SV_blank>threshold<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>negative"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""slowlog-max-len"" ) && argc == 2 ) { server . slowlog_max_len = strtoll ( argv [ 1 ] , NULL , 10 ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""client-output-buffer-limit"" ) && argc == 5 ) { int class = getClientTypeByName ( argv [ 1 ] ) ; unsigned long long hard , soft ; int soft_seconds ; <S2SV_StartBug> if ( class == - 1 ) { <S2SV_EndBug> err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class"" ; goto loaderr ; } hard = memtoll ( argv [ 2 ] , NULL ) ; soft = memtoll ( argv [ 3 ] , NULL ) ; soft_seconds = atoi ( argv [ 4 ] ) ; if ( soft_seconds < 0 ) { err = ""Negative<S2SV_blank>number<S2SV_blank>of<S2SV_blank>seconds<S2SV_blank>in<S2SV_blank>soft<S2SV_blank>limit<S2SV_blank>is<S2SV_blank>invalid"" ; goto loaderr ; } server . client_obuf_limits [ class ] . hard_limit_bytes = hard ; server . client_obuf_limits [ class ] . soft_limit_bytes = soft ; server . client_obuf_limits [ class ] . soft_limit_seconds = soft_seconds ; } else if ( ! strcasecmp ( argv [ 0 ] , ""stop-writes-on-bgsave-error"" ) && argc == 2 ) { if ( ( server . stop_writes_on_bgsave_err = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""slave-priority"" ) && argc == 2 ) { server . slave_priority = atoi ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""slave-announce-ip"" ) && argc == 2 ) { zfree ( server . slave_announce_ip ) ; server . slave_announce_ip = zstrdup ( argv [ 1 ] ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""slave-announce-port"" ) && argc == 2 ) { server . slave_announce_port = atoi ( argv [ 1 ] ) ; if ( server . slave_announce_port < 0 || server . slave_announce_port > 65535 ) { err = ""Invalid<S2SV_blank>port"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""min-slaves-to-write"" ) && argc == 2 ) { server . repl_min_slaves_to_write = atoi ( argv [ 1 ] ) ; if ( server . repl_min_slaves_to_write < 0 ) { err = ""Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>min-slaves-to-write."" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""min-slaves-max-lag"" ) && argc == 2 ) { server . repl_min_slaves_max_lag = atoi ( argv [ 1 ] ) ; if ( server . repl_min_slaves_max_lag < 0 ) { err = ""Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>min-slaves-max-lag."" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""notify-keyspace-events"" ) && argc == 2 ) { int flags = keyspaceEventsStringToFlags ( argv [ 1 ] ) ; if ( flags == - 1 ) { err = ""Invalid<S2SV_blank>event<S2SV_blank>class<S2SV_blank>character.<S2SV_blank>Use<S2SV_blank>\'g$lshzxeA\'."" ; goto loaderr ; } server . notify_keyspace_events = flags ; } else if ( ! strcasecmp ( argv [ 0 ] , ""supervised"" ) && argc == 2 ) { server . supervised_mode = configEnumGetValue ( supervised_mode_enum , argv [ 1 ] ) ; if ( server . supervised_mode == INT_MIN ) { err = ""Invalid<S2SV_blank>option<S2SV_blank>for<S2SV_blank>\'supervised\'.<S2SV_blank>"" ""Allowed<S2SV_blank>values:<S2SV_blank>\'upstart\',<S2SV_blank>\'systemd\',<S2SV_blank>\'auto\',<S2SV_blank>or<S2SV_blank>\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""loadmodule"" ) && argc >= 2 ) { queueLoadModule ( argv [ 1 ] , & argv [ 2 ] , argc - 2 ) ; } else if ( ! strcasecmp ( argv [ 0 ] , ""sentinel"" ) ) { if ( argc != 1 ) { if ( ! server . sentinel_mode ) { err = ""sentinel<S2SV_blank>directive<S2SV_blank>while<S2SV_blank>not<S2SV_blank>in<S2SV_blank>sentinel<S2SV_blank>mode"" ; goto loaderr ; } err = sentinelHandleConfiguration ( argv + 1 , argc - 1 ) ; if ( err ) goto loaderr ; } } else { err = ""Bad<S2SV_blank>directive<S2SV_blank>or<S2SV_blank>wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments"" ; goto loaderr ; } sdsfreesplitres ( argv , argc ) ; } if ( server . cluster_enabled && server . masterhost ) { linenum = slaveof_linenum ; i = linenum - 1 ; err = ""slaveof<S2SV_blank>directive<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>cluster<S2SV_blank>mode"" ; goto loaderr ; } sdsfreesplitres ( lines , totlines ) ; return ; loaderr : fprintf ( stderr , ""\\n***<S2SV_blank>FATAL<S2SV_blank>CONFIG<S2SV_blank>FILE<S2SV_blank>ERROR<S2SV_blank>***\\n"" ) ; fprintf ( stderr , ""Reading<S2SV_blank>the<S2SV_blank>configuration<S2SV_blank>file,<S2SV_blank>at<S2SV_blank>line<S2SV_blank>%d\\n"" , linenum ) ; fprintf ( stderr , "">>><S2SV_blank>\'%s\'\\n"" , lines [ i ] ) ; fprintf ( stderr , ""%s\\n"" , err ) ; exit ( 1 ) ; }
","<S2SV_ModStart> == - 1 || class == CLIENT_TYPE_MASTER ) { err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class:<S2SV_blank>the<S2SV_blank>user<S2SV_blank>specified<S2SV_blank>"" ""an<S2SV_blank>invalid<S2SV_blank>one,<S2SV_blank>or<S2SV_blank>\'master\'<S2SV_blank>which<S2SV_blank>has<S2SV_blank>no<S2SV_blank>buffer<S2SV_blank>limits."" <S2SV_ModEnd> ; goto loaderr
"
32,"CWE-119 static struct nvmet_fc_tgt_queue * nvmet_fc_find_target_queue ( struct nvmet_fc_tgtport * tgtport , u64 connection_id ) { struct nvmet_fc_tgt_assoc * assoc ; struct nvmet_fc_tgt_queue * queue ; u64 association_id = nvmet_fc_getassociationid ( connection_id ) ; u16 qid = nvmet_fc_getqueueid ( connection_id ) ; <S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> spin_lock_irqsave ( & tgtport -> lock , flags ) ; list_for_each_entry ( assoc , & tgtport -> assoc_list , a_list ) { if ( association_id == assoc -> association_id ) { queue = assoc -> queues [ qid ] ; if ( queue && ( ! atomic_read ( & queue -> connected ) || ! nvmet_fc_tgt_q_get ( queue ) ) ) queue = NULL ; spin_unlock_irqrestore ( & tgtport -> lock , flags ) ; return queue ; } } spin_unlock_irqrestore ( & tgtport -> lock , flags ) ; return NULL ; }
","<S2SV_ModStart> unsigned long flags ; if ( qid > NVMET_NR_QUEUES ) return NULL
"
33,"CWE-476 static int tower_probe ( struct usb_interface * interface , const struct usb_device_id * id ) { struct device * idev = & interface -> dev ; struct usb_device * udev = interface_to_usbdev ( interface ) ; struct lego_usb_tower * dev = NULL ; struct usb_host_interface * iface_desc ; struct usb_endpoint_descriptor * endpoint ; struct tower_get_version_reply get_version_reply ; int i ; int retval = - ENOMEM ; int result ; dev = kmalloc ( sizeof ( struct lego_usb_tower ) , GFP_KERNEL ) ; if ( ! dev ) goto exit ; mutex_init ( & dev -> lock ) ; dev -> udev = udev ; dev -> open_count = 0 ; dev -> read_buffer = NULL ; dev -> read_buffer_length = 0 ; dev -> read_packet_length = 0 ; spin_lock_init ( & dev -> read_buffer_lock ) ; dev -> packet_timeout_jiffies = msecs_to_jiffies ( packet_timeout ) ; dev -> read_last_arrival = jiffies ; init_waitqueue_head ( & dev -> read_wait ) ; init_waitqueue_head ( & dev -> write_wait ) ; dev -> interrupt_in_buffer = NULL ; dev -> interrupt_in_endpoint = NULL ; dev -> interrupt_in_urb = NULL ; dev -> interrupt_in_running = 0 ; dev -> interrupt_in_done = 0 ; dev -> interrupt_out_buffer = NULL ; dev -> interrupt_out_endpoint = NULL ; dev -> interrupt_out_urb = NULL ; dev -> interrupt_out_busy = 0 ; iface_desc = interface -> cur_altsetting ; for ( i = 0 ; i < iface_desc -> desc . bNumEndpoints ; ++ i ) { endpoint = & iface_desc -> endpoint [ i ] . desc ; if ( usb_endpoint_xfer_int ( endpoint ) ) { if ( usb_endpoint_dir_in ( endpoint ) ) dev -> interrupt_in_endpoint = endpoint ; else dev -> interrupt_out_endpoint = endpoint ; } } if ( dev -> interrupt_in_endpoint == NULL ) { dev_err ( idev , ""interrupt<S2SV_blank>in<S2SV_blank>endpoint<S2SV_blank>not<S2SV_blank>found\\n"" ) ; goto error ; } if ( dev -> interrupt_out_endpoint == NULL ) { dev_err ( idev , ""interrupt<S2SV_blank>out<S2SV_blank>endpoint<S2SV_blank>not<S2SV_blank>found\\n"" ) ; goto error ; } dev -> read_buffer = kmalloc ( read_buffer_size , GFP_KERNEL ) ; if ( ! dev -> read_buffer ) goto error ; dev -> interrupt_in_buffer = kmalloc ( usb_endpoint_maxp ( dev -> interrupt_in_endpoint ) , GFP_KERNEL ) ; if ( ! dev -> interrupt_in_buffer ) goto error ; dev -> interrupt_in_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! dev -> interrupt_in_urb ) goto error ; dev -> interrupt_out_buffer = kmalloc ( write_buffer_size , GFP_KERNEL ) ; if ( ! dev -> interrupt_out_buffer ) goto error ; dev -> interrupt_out_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! dev -> interrupt_out_urb ) goto error ; dev -> interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev -> interrupt_in_endpoint -> bInterval ; dev -> interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev -> interrupt_out_endpoint -> bInterval ; <S2SV_StartBug> usb_set_intfdata ( interface , dev ) ; <S2SV_EndBug> retval = usb_register_dev ( interface , & tower_class ) ; if ( retval ) { dev_err ( idev , ""Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\n"" ) ; usb_set_intfdata ( interface , NULL ) ; goto error ; } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>"" ""%d<S2SV_blank>minor<S2SV_blank>%d\\n"" , ( dev -> minor - LEGO_USB_TOWER_MINOR_BASE ) , USB_MAJOR , dev -> minor ) ; result = usb_control_msg ( udev , usb_rcvctrlpipe ( udev , 0 ) , LEGO_USB_TOWER_REQUEST_GET_VERSION , USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE , 0 , 0 , & get_version_reply , sizeof ( get_version_reply ) , 1000 ) ; if ( result < 0 ) { dev_err ( idev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>get<S2SV_blank>version<S2SV_blank>control<S2SV_blank>request<S2SV_blank>failed\\n"" ) ; retval = result ; goto error ; } dev_info ( & interface -> dev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>firmware<S2SV_blank>version<S2SV_blank>is<S2SV_blank>%d.%d<S2SV_blank>"" ""build<S2SV_blank>%d\\n"" , get_version_reply . major , get_version_reply . minor , le16_to_cpu ( get_version_reply . build_no ) ) ; <S2SV_StartBug> exit : <S2SV_EndBug> return retval ; error : tower_delete ( dev ) ; return retval ; }
","<S2SV_ModStart> -> bInterval ; <S2SV_ModEnd> result = usb_control_msg <S2SV_ModStart> ) ) ; usb_set_intfdata ( interface , dev ) ; retval = usb_register_dev ( interface , & tower_class ) ; if ( retval ) { dev_err ( idev , ""Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\n"" ) ; usb_set_intfdata ( interface , NULL ) ; goto error ; } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>"" ""%d<S2SV_blank>minor<S2SV_blank>%d\\n"" , ( dev -> minor - LEGO_USB_TOWER_MINOR_BASE ) , USB_MAJOR , dev -> minor ) ;
"
34,"CWE-476 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = """" ; const char * link_section_name = """" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n"" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ; for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( end - ( char * ) defs > i ) ; ++ cnt ) { Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) int vdaux = verdef -> vd_aux ; <S2SV_StartBug> if ( vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux ) { <S2SV_EndBug> sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux ; if ( vstart > end || end - vstart < sizeof ( Elf_ ( Verdaux ) ) ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , ""idx"" , i , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_version"" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_ndx"" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_cnt"" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , ""flags"" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || end - vstart < sizeof ( Elf_ ( Verdaux ) ) ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , ""idx"" , isum , 0 ) ; sdb_num_set ( sdb_parent , ""parent"" , j , 0 ) ; sdb_set ( sdb_parent , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , ""parent%d"" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , ""verdef%d"" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( ""Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n"" ) ; break ; } i += verdef -> vd_next ; } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }
","<S2SV_ModStart> < 1 || vstart + vdaux < vstart <S2SV_ModEnd> ) { sdb_free
"
35,"CWE-862 <S2SV_StartBug> static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <S2SV_EndBug> { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; <S2SV_StartBug> kenter ( ""%p"" , dest_keyring ) ; <S2SV_EndBug> if ( dest_keyring ) { key_get ( dest_keyring ) ; <S2SV_StartBug> } else { <S2SV_EndBug> switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <S2SV_StartBug> break ; <S2SV_EndBug> } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } <S2SV_StartBug> } <S2SV_EndBug> * _dest_keyring = dest_keyring ; kleave ( ""<S2SV_blank>[dk<S2SV_blank>%d]"" , key_serial ( dest_keyring ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> construct_get_dest_keyring ( struct <S2SV_ModStart> * authkey ; int ret ; <S2SV_ModStart> } else { bool do_perm_check = true ; <S2SV_ModStart> ( dest_keyring ) { do_perm_check = false ; break ; } <S2SV_ModEnd> } case KEY_REQKEY_DEFL_THREAD_KEYRING <S2SV_ModStart> ) ; } if ( dest_keyring && do_perm_check ) { ret = key_permission ( make_key_ref ( dest_keyring , 1 ) , KEY_NEED_WRITE ) ; if ( ret ) { key_put ( dest_keyring ) ; return ret ; } } <S2SV_ModStart> ) ; return 0
"
36,"CWE-763 static OM_uint32 init_ctx_new ( OM_uint32 * minor_status , spnego_gss_cred_id_t spcred , gss_ctx_id_t * ctx , send_token_flag * tokflag ) { OM_uint32 ret ; spnego_gss_ctx_id_t sc = NULL ; <S2SV_StartBug> sc = create_spnego_ctx ( ) ; <S2SV_EndBug> if ( sc == NULL ) return GSS_S_FAILURE ; ret = get_negotiable_mechs ( minor_status , spcred , GSS_C_INITIATE , & sc -> mech_set ) ; if ( ret != GSS_S_COMPLETE ) goto cleanup ; sc -> internal_mech = & sc -> mech_set -> elements [ 0 ] ; if ( put_mech_set ( sc -> mech_set , & sc -> DER_mechTypes ) < 0 ) { ret = GSS_S_FAILURE ; goto cleanup ; } sc -> ctx_handle = GSS_C_NO_CONTEXT ; * ctx = ( gss_ctx_id_t ) sc ; sc = NULL ; * tokflag = INIT_TOKEN_SEND ; ret = GSS_S_CONTINUE_NEEDED ; cleanup : release_spnego_ctx ( & sc ) ; return ret ; }
","<S2SV_ModStart> = create_spnego_ctx ( 1
"
37,"CWE-416 static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; <S2SV_StartBug> if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> if ( addr -> l2tp_family != AF_INET ) <S2SV_EndBug> return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
","<S2SV_ModStart> ; if ( addr_len < sizeof ( struct sockaddr_l2tpip <S2SV_ModEnd> ) ) return <S2SV_ModStart> ; if ( addr -> l2tp_family != AF_INET <S2SV_ModEnd> ) return - <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> ret = - <S2SV_ModStart> ( sk ) ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out
"
38,"CWE-264 <S2SV_StartBug> static unsigned int stack_maxrandom_size ( void ) <S2SV_EndBug> { <S2SV_StartBug> unsigned int max = 0 ; <S2SV_EndBug> if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) { <S2SV_StartBug> max = ( ( - 1U ) & STACK_RND_MASK ) << PAGE_SHIFT ; <S2SV_EndBug> } return max ; }
","<S2SV_ModStart> <S2SV_null> static unsigned long <S2SV_ModEnd> stack_maxrandom_size ( void <S2SV_ModStart> ) { unsigned long <S2SV_ModEnd> max = 0 <S2SV_ModStart> ( ( - 1UL <S2SV_ModEnd> ) & STACK_RND_MASK
"
39,"CWE-20 static void activate_desktop_file ( ActivateParameters * parameters , NautilusFile * file ) { ActivateParametersDesktop * parameters_desktop ; char * primary , * secondary , * display_name ; GtkWidget * dialog ; GdkScreen * screen ; char * uri ; screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window ) ) ; if ( ! nautilus_file_is_trusted_link ( file ) ) { parameters_desktop = g_new0 ( ActivateParametersDesktop , 1 ) ; if ( parameters -> parent_window ) { parameters_desktop -> parent_window = parameters -> parent_window ; g_object_add_weak_pointer ( G_OBJECT ( parameters_desktop -> parent_window ) , ( gpointer * ) & parameters_desktop -> parent_window ) ; } parameters_desktop -> file = nautilus_file_ref ( file ) ; primary = _ ( ""Untrusted<S2SV_blank>application<S2SV_blank>launcher"" ) ; display_name = nautilus_file_get_display_name ( file ) ; secondary = g_strdup_printf ( _ ( ""The<S2SV_blank>application<S2SV_blank>launcher<S2SV_blank>“%s”<S2SV_blank>has<S2SV_blank>not<S2SV_blank>been<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>trusted.<S2SV_blank>"" ""If<S2SV_blank>you<S2SV_blank>do<S2SV_blank>not<S2SV_blank>know<S2SV_blank>the<S2SV_blank>source<S2SV_blank>of<S2SV_blank>this<S2SV_blank>file,<S2SV_blank>launching<S2SV_blank>it<S2SV_blank>may<S2SV_blank>be<S2SV_blank>unsafe."" ) , display_name ) ; dialog = gtk_message_dialog_new ( parameters -> parent_window , 0 , GTK_MESSAGE_WARNING , GTK_BUTTONS_NONE , NULL ) ; g_object_set ( dialog , ""text"" , primary , ""secondary-text"" , secondary , NULL ) ; gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , <S2SV_StartBug> _ ( ""_Launch<S2SV_blank>Anyway"" ) , RESPONSE_RUN ) ; <S2SV_EndBug> if ( nautilus_file_can_set_permissions ( file ) ) { gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , <S2SV_StartBug> _ ( ""Mark<S2SV_blank>as<S2SV_blank>_Trusted"" ) , RESPONSE_MARK_TRUSTED ) ; <S2SV_EndBug> } <S2SV_StartBug> gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , <S2SV_EndBug> _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL ) ; g_signal_connect ( dialog , ""response"" , G_CALLBACK ( untrusted_launcher_response_callback ) , parameters_desktop ) ; gtk_widget_show ( dialog ) ; g_free ( display_name ) ; g_free ( secondary ) ; return ; } uri = nautilus_file_get_uri ( file ) ; DEBUG ( ""Launching<S2SV_blank>trusted<S2SV_blank>launcher<S2SV_blank>%s"" , uri ) ; nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ; g_free ( uri ) ; }
","<S2SV_ModStart> , _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , _ ( ""Trust<S2SV_blank>and<S2SV_blank>_Launch"" ) , GTK_RESPONSE_OK <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> g_signal_connect ( dialog
"
40,"CWE-416 char * my_asctime ( time_t t ) { struct tm * tm ; char * str ; int len ; <S2SV_StartBug> tm = localtime ( & t ) ; <S2SV_EndBug> str = g_strdup ( asctime ( tm ) ) ; len = strlen ( str ) ; if ( len > 0 ) str [ len - 1 ] = '\\0' ; return str ; }
","<S2SV_ModStart> ( & t ) ; if ( tm == NULL ) return g_strdup ( ""???""
"
41,"CWE-787 static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; <S2SV_StartBug> memcpy ( hashed , password , strlen ( password ) ) ; <S2SV_EndBug> attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr -> data , hashed , length ) ; } }
","<S2SV_ModStart> , password , length <S2SV_ModEnd> ) ; attr
"
42,"CWE-119 <S2SV_StartBug> static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * d ) <S2SV_EndBug> { u8 obuf [ ] = { 0x51 } ; u8 ibuf [ ] = { 0 } ; <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> d -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ; <S2SV_EndBug> <S2SV_StartBug> if ( d -> fe_adap [ 0 ] . fe == NULL ) <S2SV_EndBug> return - EIO ; <S2SV_StartBug> if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe , <S2SV_EndBug> & dw2104_ts2020_config , <S2SV_StartBug> & d -> dev -> i2c_adap ) ) { <S2SV_EndBug> info ( ""Attached<S2SV_blank>RS2000/TS2020!"" ) ; return 0 ; } info ( ""Failed<S2SV_blank>to<S2SV_blank>attach<S2SV_blank>RS2000/TS2020!"" ) ; return - EIO ; }
","<S2SV_ModStart> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> & d -> <S2SV_ModEnd> i2c_adap ) ; <S2SV_ModStart> ; if ( adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> ( ts2020_attach , adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> , & d <S2SV_ModEnd> -> i2c_adap )
"
43,"CWE-362 void sctp_generate_heartbeat_event ( unsigned long data ) { int error = 0 ; struct sctp_transport * transport = ( struct sctp_transport * ) data ; struct sctp_association * asoc = transport -> asoc ; <S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\n"" , __func__ ) ; if ( ! mod_timer ( & transport -> hb_timer , jiffies + ( HZ / 20 ) ) ) sctp_transport_hold ( transport ) ; goto out_unlock ; } if ( transport -> dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( SCTP_EVENT_TIMEOUT_HEARTBEAT ) , asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; if ( error ) <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> out_unlock : <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> sctp_transport_put ( transport ) ; }
","<S2SV_ModStart> asoc ; struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> ( error ) <S2SV_ModEnd> sk -> sk_err <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;
"
44,"CWE-200 inline int web_client_api_request_v1_data ( RRDHOST * host , struct web_client * w , char * url ) { debug ( D_WEB_CLIENT , ""%llu:<S2SV_blank>API<S2SV_blank>v1<S2SV_blank>data<S2SV_blank>with<S2SV_blank>URL<S2SV_blank>\'%s\'"" , w -> id , url ) ; int ret = 400 ; BUFFER * dimensions = NULL ; buffer_flush ( w -> response . data ) ; char * google_version = ""0.6"" , * google_reqId = ""0"" , * google_sig = ""0"" , * google_out = ""json"" , * responseHandler = NULL , * outFileName = NULL ; time_t last_timestamp_in_data = 0 , google_timestamp = 0 ; char * chart = NULL , * before_str = NULL , * after_str = NULL , * group_time_str = NULL , * points_str = NULL ; int group = RRDR_GROUPING_AVERAGE ; uint32_t format = DATASOURCE_JSON ; uint32_t options = 0x00000000 ; while ( url ) { char * value = mystrsep ( & url , ""?&"" ) ; if ( ! value || ! * value ) continue ; char * name = mystrsep ( & value , ""="" ) ; if ( ! name || ! * name ) continue ; if ( ! value || ! * value ) continue ; debug ( D_WEB_CLIENT , ""%llu:<S2SV_blank>API<S2SV_blank>v1<S2SV_blank>data<S2SV_blank>query<S2SV_blank>param<S2SV_blank>\'%s\'<S2SV_blank>with<S2SV_blank>value<S2SV_blank>\'%s\'"" , w -> id , name , value ) ; if ( ! strcmp ( name , ""chart"" ) ) chart = value ; else if ( ! strcmp ( name , ""dimension"" ) || ! strcmp ( name , ""dim"" ) || ! strcmp ( name , ""dimensions"" ) || ! strcmp ( name , ""dims"" ) ) { if ( ! dimensions ) dimensions = buffer_create ( 100 ) ; buffer_strcat ( dimensions , ""|"" ) ; buffer_strcat ( dimensions , value ) ; } else if ( ! strcmp ( name , ""after"" ) ) after_str = value ; else if ( ! strcmp ( name , ""before"" ) ) before_str = value ; else if ( ! strcmp ( name , ""points"" ) ) points_str = value ; else if ( ! strcmp ( name , ""gtime"" ) ) group_time_str = value ; else if ( ! strcmp ( name , ""group"" ) ) { group = web_client_api_request_v1_data_group ( value , RRDR_GROUPING_AVERAGE ) ; } else if ( ! strcmp ( name , ""format"" ) ) { format = web_client_api_request_v1_data_format ( value ) ; } else if ( ! strcmp ( name , ""options"" ) ) { options |= web_client_api_request_v1_data_options ( value ) ; } else if ( ! strcmp ( name , ""callback"" ) ) { responseHandler = value ; } else if ( ! strcmp ( name , ""filename"" ) ) { outFileName = value ; } else if ( ! strcmp ( name , ""tqx"" ) ) { char * tqx_name , * tqx_value ; while ( value ) { tqx_value = mystrsep ( & value , "";"" ) ; if ( ! tqx_value || ! * tqx_value ) continue ; tqx_name = mystrsep ( & tqx_value , "":"" ) ; if ( ! tqx_name || ! * tqx_name ) continue ; if ( ! tqx_value || ! * tqx_value ) continue ; if ( ! strcmp ( tqx_name , ""version"" ) ) google_version = tqx_value ; else if ( ! strcmp ( tqx_name , ""reqId"" ) ) google_reqId = tqx_value ; else if ( ! strcmp ( tqx_name , ""sig"" ) ) { google_sig = tqx_value ; google_timestamp = strtoul ( google_sig , NULL , 0 ) ; } else if ( ! strcmp ( tqx_name , ""out"" ) ) { google_out = tqx_value ; format = web_client_api_request_v1_data_google_format ( google_out ) ; } else if ( ! strcmp ( tqx_name , ""responseHandler"" ) ) responseHandler = tqx_value ; else if ( ! strcmp ( tqx_name , ""outFileName"" ) ) outFileName = tqx_value ; } } } <S2SV_StartBug> if ( ! chart || ! * chart ) { <S2SV_EndBug> buffer_sprintf ( w -> response . data , ""No<S2SV_blank>chart<S2SV_blank>id<S2SV_blank>is<S2SV_blank>given<S2SV_blank>at<S2SV_blank>the<S2SV_blank>request."" ) ; goto cleanup ; } RRDSET * st = rrdset_find ( host , chart ) ; if ( ! st ) st = rrdset_find_byname ( host , chart ) ; if ( ! st ) { buffer_strcat ( w -> response . data , ""Chart<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found:<S2SV_blank>"" ) ; buffer_strcat_htmlescape ( w -> response . data , chart ) ; ret = 404 ; goto cleanup ; } st -> last_accessed_time = now_realtime_sec ( ) ; long long before = ( before_str && * before_str ) ? str2l ( before_str ) : 0 ; long long after = ( after_str && * after_str ) ? str2l ( after_str ) : 0 ; int points = ( points_str && * points_str ) ? str2i ( points_str ) : 0 ; long group_time = ( group_time_str && * group_time_str ) ? str2l ( group_time_str ) : 0 ; debug ( D_WEB_CLIENT , ""%llu:<S2SV_blank>API<S2SV_blank>command<S2SV_blank>\'data\'<S2SV_blank>for<S2SV_blank>chart<S2SV_blank>\'%s\',<S2SV_blank>dimensions<S2SV_blank>\'%s\',<S2SV_blank>after<S2SV_blank>\'%lld\',<S2SV_blank>before<S2SV_blank>\'%lld\',<S2SV_blank>points<S2SV_blank>\'%d\',<S2SV_blank>group<S2SV_blank>\'%d\',<S2SV_blank>format<S2SV_blank>\'%u\',<S2SV_blank>options<S2SV_blank>\'0x%08x\'"" , w -> id , chart , ( dimensions ) ? buffer_tostring ( dimensions ) : """" , after , before , points , group , format , options ) ; if ( outFileName && * outFileName ) { buffer_sprintf ( w -> response . header , ""Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\""%s\\""\\r\\n"" , outFileName ) ; debug ( D_WEB_CLIENT , ""%llu:<S2SV_blank>generating<S2SV_blank>outfilename<S2SV_blank>header:<S2SV_blank>\'%s\'"" , w -> id , outFileName ) ; } if ( format == DATASOURCE_DATATABLE_JSONP ) { if ( responseHandler == NULL ) responseHandler = ""google.visualization.Query.setResponse"" ; debug ( D_WEB_CLIENT_ACCESS , ""%llu:<S2SV_blank>GOOGLE<S2SV_blank>JSON/JSONP:<S2SV_blank>version<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>reqId<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>sig<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>out<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>responseHandler<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>outFileName<S2SV_blank>=<S2SV_blank>\'%s\'"" , w -> id , google_version , google_reqId , google_sig , google_out , responseHandler , outFileName ) ; buffer_sprintf ( w -> response . data , ""%s({version:\'%s\',reqId:\'%s\',status:\'ok\',sig:\'%ld\',table:"" , responseHandler , google_version , google_reqId , st -> last_updated . tv_sec ) ; } else if ( format == DATASOURCE_JSONP ) { if ( responseHandler == NULL ) responseHandler = ""callback"" ; buffer_strcat ( w -> response . data , responseHandler ) ; buffer_strcat ( w -> response . data , ""("" ) ; } ret = rrdset2anything_api_v1 ( st , w -> response . data , dimensions , format , points , after , before , group , group_time , options , & last_timestamp_in_data ) ; if ( format == DATASOURCE_DATATABLE_JSONP ) { if ( google_timestamp < last_timestamp_in_data ) buffer_strcat ( w -> response . data , ""});"" ) ; else { buffer_flush ( w -> response . data ) ; buffer_sprintf ( w -> response . data , ""%s({version:\'%s\',reqId:\'%s\',status:\'error\',errors:[{reason:\'not_modified\',message:\'Data<S2SV_blank>not<S2SV_blank>modified\'}]});"" , responseHandler , google_version , google_reqId ) ; } } else if ( format == DATASOURCE_JSONP ) buffer_strcat ( w -> response . data , "");"" ) ; cleanup : buffer_free ( dimensions ) ; return ret ; }
","<S2SV_ModStart> } } } fix_google_param ( google_out ) ; fix_google_param ( google_sig ) ; fix_google_param ( google_reqId ) ; fix_google_param ( google_version ) ; fix_google_param ( responseHandler ) ; fix_google_param ( outFileName ) ;
"
45,"CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> horAcc8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; unsigned char * cp = ( unsigned char * ) cp0 ; <S2SV_StartBug> assert ( ( cc % stride ) == 0 ) ; <S2SV_EndBug> if ( cc > stride ) { if ( stride == 3 ) { unsigned int cr = cp [ 0 ] ; unsigned int cg = cp [ 1 ] ; unsigned int cb = cp [ 2 ] ; cc -= 3 ; cp += 3 ; while ( cc > 0 ) { cp [ 0 ] = ( unsigned char ) ( ( cr += cp [ 0 ] ) & 0xff ) ; cp [ 1 ] = ( unsigned char ) ( ( cg += cp [ 1 ] ) & 0xff ) ; cp [ 2 ] = ( unsigned char ) ( ( cb += cp [ 2 ] ) & 0xff ) ; cc -= 3 ; cp += 3 ; } } else if ( stride == 4 ) { unsigned int cr = cp [ 0 ] ; unsigned int cg = cp [ 1 ] ; unsigned int cb = cp [ 2 ] ; unsigned int ca = cp [ 3 ] ; cc -= 4 ; cp += 4 ; while ( cc > 0 ) { cp [ 0 ] = ( unsigned char ) ( ( cr += cp [ 0 ] ) & 0xff ) ; cp [ 1 ] = ( unsigned char ) ( ( cg += cp [ 1 ] ) & 0xff ) ; cp [ 2 ] = ( unsigned char ) ( ( cb += cp [ 2 ] ) & 0xff ) ; cp [ 3 ] = ( unsigned char ) ( ( ca += cp [ 3 ] ) & 0xff ) ; cc -= 4 ; cp += 4 ; } } else { cc -= stride ; do { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] + * cp ) & 0xff ) ; cp ++ ) cc -= stride ; } while ( cc > 0 ) ; } } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horAcc8 ( TIFF <S2SV_ModStart> ) cp0 ; if <S2SV_ModEnd> ( ( cc <S2SV_ModStart> % stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horAcc8"" , ""%s"" , ""(cc%stride)!=0"" ) ; return 0 ; } <S2SV_ModEnd> if ( cc <S2SV_ModStart> ; } } return 1 ;
"
46,"CWE-119 DECLAREcpFunc ( cpContig2SeparateByRow ) { tsize_t scanlinesizein = TIFFScanlineSize ( in ) ; tsize_t scanlinesizeout = TIFFScanlineSize ( out ) ; tdata_t inbuf ; tdata_t outbuf ; register uint8 * inp , * outp ; register uint32 n ; uint32 row ; tsample_t s ; <S2SV_StartBug> inbuf = _TIFFmalloc ( scanlinesizein ) ; <S2SV_EndBug> outbuf = _TIFFmalloc ( scanlinesizeout ) ; if ( ! inbuf || ! outbuf ) goto bad ; _TIFFmemset ( inbuf , 0 , scanlinesizein ) ; _TIFFmemset ( outbuf , 0 , scanlinesizeout ) ; for ( s = 0 ; s < spp ; s ++ ) { for ( row = 0 ; row < imagelength ; row ++ ) { if ( TIFFReadScanline ( in , inbuf , row , 0 ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>scanline<S2SV_blank>%lu"" , ( unsigned long ) row ) ; goto bad ; } inp = ( ( uint8 * ) inbuf ) + s ; outp = ( uint8 * ) outbuf ; for ( n = imagewidth ; n -- > 0 ; ) { * outp ++ = * inp ; inp += spp ; } if ( TIFFWriteScanline ( out , outbuf , row , s ) < 0 ) { TIFFError ( TIFFFileName ( out ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>write<S2SV_blank>scanline<S2SV_blank>%lu"" , ( unsigned long ) row ) ; goto bad ; } } } if ( inbuf ) _TIFFfree ( inbuf ) ; if ( outbuf ) _TIFFfree ( outbuf ) ; return 1 ; bad : if ( inbuf ) _TIFFfree ( inbuf ) ; if ( outbuf ) _TIFFfree ( outbuf ) ; return 0 ; }
","<S2SV_ModStart> tsample_t s ; uint16 bps = 0 ; ( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; if ( bps != 8 ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s"" , ""cpContig2SeparateByRow"" ) ; return 0 ; }
"
47,"CWE-399 static void free_huge_page ( struct page * page ) { struct hstate * h = page_hstate ( page ) ; int nid = page_to_nid ( page ) ; <S2SV_StartBug> struct address_space * mapping ; <S2SV_EndBug> mapping = ( struct address_space * ) page_private ( page ) ; set_page_private ( page , 0 ) ; page -> mapping = NULL ; BUG_ON ( page_count ( page ) ) ; BUG_ON ( page_mapcount ( page ) ) ; INIT_LIST_HEAD ( & page -> lru ) ; spin_lock ( & hugetlb_lock ) ; if ( h -> surplus_huge_pages_node [ nid ] && huge_page_order ( h ) < MAX_ORDER ) { update_and_free_page ( h , page ) ; h -> surplus_huge_pages -- ; h -> surplus_huge_pages_node [ nid ] -- ; } else { enqueue_huge_page ( h , page ) ; } spin_unlock ( & hugetlb_lock ) ; <S2SV_StartBug> if ( mapping ) <S2SV_EndBug> hugetlb_put_quota ( mapping , 1 ) ; }
","<S2SV_ModStart> ) ; struct hugepage_subpool * spool = ( struct hugepage_subpool <S2SV_ModEnd> * ) page_private <S2SV_ModStart> hugetlb_lock ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , 1 )
"
48,"CWE-835 static int read_part_of_packet ( AVFormatContext * s , int64_t * pts , int * len , int * strid , int read_packet ) { AVIOContext * pb = s -> pb ; PVAContext * pvactx = s -> priv_data ; int syncword , streamid , reserved , flags , length , pts_flag ; int64_t pva_pts = AV_NOPTS_VALUE , startpos ; int ret ; recover : startpos = avio_tell ( pb ) ; syncword = avio_rb16 ( pb ) ; streamid = avio_r8 ( pb ) ; avio_r8 ( pb ) ; reserved = avio_r8 ( pb ) ; flags = avio_r8 ( pb ) ; length = avio_rb16 ( pb ) ; pts_flag = flags & 0x10 ; if ( syncword != PVA_MAGIC ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>syncword\\n"" ) ; return AVERROR ( EIO ) ; } if ( streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>streamid\\n"" ) ; return AVERROR ( EIO ) ; } if ( reserved != 0x55 ) { pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>reserved<S2SV_blank>byte<S2SV_blank>to<S2SV_blank>be<S2SV_blank>0x55\\n"" ) ; } if ( length > PVA_MAX_PAYLOAD_LENGTH ) { pva_log ( s , AV_LOG_ERROR , ""invalid<S2SV_blank>payload<S2SV_blank>length<S2SV_blank>%u\\n"" , length ) ; return AVERROR ( EIO ) ; } if ( streamid == PVA_VIDEO_PAYLOAD && pts_flag ) { pva_pts = avio_rb32 ( pb ) ; length -= 4 ; } else if ( streamid == PVA_AUDIO_PAYLOAD ) { if ( ! pvactx -> continue_pes ) { int pes_signal , pes_header_data_length , pes_packet_length , pes_flags ; unsigned char pes_header_data [ 256 ] ; pes_signal = avio_rb24 ( pb ) ; avio_r8 ( pb ) ; pes_packet_length = avio_rb16 ( pb ) ; pes_flags = avio_rb16 ( pb ) ; pes_header_data_length = avio_r8 ( pb ) ; <S2SV_StartBug> if ( pes_signal != 1 || pes_header_data_length == 0 ) { <S2SV_EndBug> pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\n"" ) ; avio_skip ( pb , length - 9 ) ; if ( ! read_packet ) return AVERROR ( EIO ) ; goto recover ; } ret = avio_read ( pb , pes_header_data , pes_header_data_length ) ; if ( ret != pes_header_data_length ) return ret < 0 ? ret : AVERROR_INVALIDDATA ; length -= 9 + pes_header_data_length ; pes_packet_length -= 3 + pes_header_data_length ; pvactx -> continue_pes = pes_packet_length ; if ( pes_flags & 0x80 && ( pes_header_data [ 0 ] & 0xf0 ) == 0x20 ) { if ( pes_header_data_length < 5 ) { pva_log ( s , AV_LOG_ERROR , ""header<S2SV_blank>too<S2SV_blank>short\\n"" ) ; avio_skip ( pb , length ) ; return AVERROR_INVALIDDATA ; } pva_pts = ff_parse_pes_pts ( pes_header_data ) ; } } pvactx -> continue_pes -= length ; if ( pvactx -> continue_pes < 0 ) { pva_log ( s , AV_LOG_WARNING , ""audio<S2SV_blank>data<S2SV_blank>corruption\\n"" ) ; pvactx -> continue_pes = 0 ; } } if ( pva_pts != AV_NOPTS_VALUE ) av_add_index_entry ( s -> streams [ streamid - 1 ] , startpos , pva_pts , 0 , 0 , AVINDEX_KEYFRAME ) ; * pts = pva_pts ; * len = length ; * strid = streamid ; return 0 ; }
","<S2SV_ModStart> ; if ( avio_feof ( pb ) ) { return AVERROR_EOF ; } if (
"
49,"CWE-119 enum nss_status _nss_mymachines_getpwnam_r ( const char * name , struct passwd * pwd , char * buffer , size_t buflen , int * errnop ) { _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL ; _cleanup_bus_message_unref_ sd_bus_message * reply = NULL ; _cleanup_bus_flush_close_unref_ sd_bus * bus = NULL ; const char * p , * e , * machine ; uint32_t mapped ; uid_t uid ; size_t l ; int r ; assert ( name ) ; assert ( pwd ) ; p = startswith ( name , ""vu-"" ) ; if ( ! p ) goto not_found ; e = strrchr ( p , '-' ) ; <S2SV_StartBug> if ( ! e || e == p ) <S2SV_EndBug> goto not_found ; r = parse_uid ( e + 1 , & uid ) ; if ( r < 0 ) goto not_found ; machine = strndupa ( p , e - p ) ; if ( ! machine_name_is_valid ( machine ) ) goto not_found ; r = sd_bus_open_system ( & bus ) ; if ( r < 0 ) goto fail ; r = sd_bus_call_method ( bus , ""org.freedesktop.machine1"" , ""/org/freedesktop/machine1"" , ""org.freedesktop.machine1.Manager"" , ""MapFromMachineUser"" , & error , & reply , ""su"" , machine , ( uint32_t ) uid ) ; if ( r < 0 ) { if ( sd_bus_error_has_name ( & error , BUS_ERROR_NO_SUCH_USER_MAPPING ) ) goto not_found ; goto fail ; } r = sd_bus_message_read ( reply , ""u"" , & mapped ) ; if ( r < 0 ) goto fail ; l = strlen ( name ) ; if ( buflen < l + 1 ) { * errnop = ENOMEM ; return NSS_STATUS_TRYAGAIN ; } memcpy ( buffer , name , l + 1 ) ; pwd -> pw_name = buffer ; pwd -> pw_uid = mapped ; pwd -> pw_gid = 65534 ; pwd -> pw_gecos = buffer ; pwd -> pw_passwd = ( char * ) ""*"" ; pwd -> pw_dir = ( char * ) ""/"" ; pwd -> pw_shell = ( char * ) ""/sbin/nologin"" ; * errnop = 0 ; return NSS_STATUS_SUCCESS ; not_found : * errnop = 0 ; return NSS_STATUS_NOTFOUND ; fail : * errnop = - r ; return NSS_STATUS_UNAVAIL ; }
","<S2SV_ModStart> e == p ) goto not_found ; if ( e - p > HOST_NAME_MAX - 1
"
50,"CWE-416 <S2SV_StartBug> void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) <S2SV_EndBug> { <S2SV_StartBug> get_page ( buf -> page ) ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> bool <S2SV_ModEnd> generic_pipe_buf_get ( struct <S2SV_ModStart> buf ) { return try_get_page <S2SV_ModEnd> ( buf ->
"
51,"CWE-125 static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , ""<S2SV_blank>#%u<S2SV_blank>type=%s<S2SV_blank>id=%s<S2SV_blank>"" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>#%u<S2SV_blank>type=%s<S2SV_blank>id=%u<S2SV_blank>"" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { <S2SV_StartBug> cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , <S2SV_EndBug> map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
","<S2SV_ModStart> , cp , ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart> < ep2 ) <S2SV_ModEnd> ND_PRINT ( (
"
52,"CWE-264 int inode_change_ok ( const struct inode * inode , struct iattr * attr ) { unsigned int ia_valid = attr -> ia_valid ; if ( ia_valid & ATTR_SIZE ) { int error = inode_newsize_ok ( inode , attr -> ia_size ) ; if ( error ) return error ; } if ( ia_valid & ATTR_FORCE ) return 0 ; if ( ( ia_valid & ATTR_UID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) && <S2SV_StartBug> ! inode_capable ( inode , CAP_CHOWN ) ) <S2SV_EndBug> return - EPERM ; if ( ( ia_valid & ATTR_GID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ( ! in_group_p ( attr -> ia_gid ) && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) && <S2SV_StartBug> ! inode_capable ( inode , CAP_CHOWN ) ) <S2SV_EndBug> return - EPERM ; if ( ia_valid & ATTR_MODE ) { if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr -> ia_gid : inode -> i_gid ) && <S2SV_StartBug> ! inode_capable ( inode , CAP_FSETID ) ) <S2SV_EndBug> attr -> ia_mode &= ~ S_ISGID ; } if ( ia_valid & ( ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET ) ) { if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; } return 0 ; }
","<S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,
"
53,"CWE-284 static bool has_byte ( const eager_reader_t * reader ) { assert ( reader != NULL ) ; fd_set read_fds ; FD_ZERO ( & read_fds ) ; FD_SET ( reader -> bytes_available_fd , & read_fds ) ; struct timeval timeout ; timeout . tv_sec = 0 ; timeout . tv_usec = 0 ; <S2SV_StartBug> select ( reader -> bytes_available_fd + 1 , & read_fds , NULL , NULL , & timeout ) ; <S2SV_EndBug> return FD_ISSET ( reader -> bytes_available_fd , & read_fds ) ; }
","<S2SV_ModStart> = 0 ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> & timeout ) )
"
54,"CWE-400 static void fpm_child_init ( struct fpm_worker_pool_s * wp ) { <S2SV_StartBug> fpm_globals . max_requests = wp -> config -> pm_max_requests ; <S2SV_EndBug> if ( 0 > fpm_stdio_init_child ( wp ) || 0 > fpm_log_init_child ( wp ) || 0 > fpm_status_init_child ( wp ) || 0 > fpm_unix_init_child ( wp ) || 0 > fpm_signals_init_child ( ) || 0 > fpm_env_init_child ( wp ) || 0 > fpm_php_init_child ( wp ) ) { zlog ( ZLOG_ERROR , ""[pool<S2SV_blank>%s]<S2SV_blank>child<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>initialize"" , wp -> config -> name ) ; exit ( FPM_EXIT_SOFTWARE ) ; } }
","<S2SV_ModStart> config -> pm_max_requests ; fpm_globals . listening_socket = dup ( wp -> listening_socket )
"
55,"CWE-119 <S2SV_StartBug> static int detect_transition_to_still ( struct twopass_rc * twopass , <S2SV_EndBug> int frame_interval , int still_interval , double loop_decay_rate , double last_decay_rate ) { <S2SV_StartBug> int trans_to_still = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( frame_interval > MIN_GF_INTERVAL && <S2SV_EndBug> loop_decay_rate >= 0.999 && last_decay_rate < 0.9 ) { int j ; <S2SV_StartBug> const FIRSTPASS_STATS * position = twopass -> stats_in ; <S2SV_EndBug> FIRSTPASS_STATS tmp_next_frame ; for ( j = 0 ; j < still_interval ; ++ j ) { <S2SV_StartBug> if ( EOF == input_stats ( twopass , & tmp_next_frame ) ) <S2SV_EndBug> break ; <S2SV_StartBug> if ( tmp_next_frame . pcnt_inter - tmp_next_frame . pcnt_motion < 0.999 ) <S2SV_EndBug> break ; } <S2SV_StartBug> reset_fpf_position ( twopass , position ) ; <S2SV_EndBug> <S2SV_StartBug> if ( j == still_interval ) <S2SV_EndBug> trans_to_still = 1 ; } <S2SV_StartBug> return trans_to_still ; <S2SV_EndBug> }
","<S2SV_ModStart> int detect_transition_to_still ( VP9_COMP * cpi <S2SV_ModEnd> , int frame_interval <S2SV_ModStart> last_decay_rate ) { TWO_PASS * const twopass = & cpi -> twopass ; RATE_CONTROL * const rc = & cpi -> rc <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( frame_interval > rc -> min_gf_interval <S2SV_ModEnd> && loop_decay_rate >= <S2SV_ModStart> int j ; <S2SV_ModEnd> for ( j <S2SV_ModStart> j ) { const FIRSTPASS_STATS * stats = & twopass -> stats_in [ j ] ; if ( stats >= twopass -> stats_in_end <S2SV_ModEnd> ) break ; <S2SV_ModStart> ; if ( stats -> pcnt_inter - stats -> <S2SV_ModEnd> pcnt_motion < 0.999 <S2SV_ModStart> break ; } return <S2SV_ModEnd> j == still_interval <S2SV_ModStart> j == still_interval <S2SV_ModEnd> ; } return <S2SV_ModStart> ; } return 0 <S2SV_ModEnd> ; } <S2SV_null>
"
56,"CWE-416 int __ext4_journal_stop ( const char * where , unsigned int line , handle_t * handle ) { struct super_block * sb ; int err ; int rc ; if ( ! ext4_handle_valid ( handle ) ) { ext4_put_nojournal ( handle ) ; return 0 ; } <S2SV_StartBug> if ( ! handle -> h_transaction ) { <S2SV_EndBug> <S2SV_StartBug> err = jbd2_journal_stop ( handle ) ; <S2SV_EndBug> <S2SV_StartBug> return handle -> h_err ? handle -> h_err : err ; <S2SV_EndBug> } <S2SV_StartBug> sb = handle -> h_transaction -> t_journal -> j_private ; <S2SV_EndBug> err = handle -> h_err ; rc = jbd2_journal_stop ( handle ) ; if ( ! err ) err = rc ; if ( err ) __ext4_std_error ( sb , where , line , err ) ; return err ; }
","<S2SV_ModStart> 0 ; } err = handle -> h_err ; <S2SV_ModStart> h_transaction ) { rc <S2SV_ModEnd> = jbd2_journal_stop ( <S2SV_ModStart> ) ; return err ? err : rc <S2SV_ModEnd> ; } sb <S2SV_ModStart> t_journal -> j_private <S2SV_ModEnd> ; rc =
"
57,"CWE-000 static int ext4_end_io_nolock ( ext4_io_end_t * io ) { struct inode * inode = io -> inode ; loff_t offset = io -> offset ; ssize_t size = io -> size ; int ret = 0 ; ext4_debug ( ""ext4_end_io_nolock:<S2SV_blank>io<S2SV_blank>0x%p<S2SV_blank>from<S2SV_blank>inode<S2SV_blank>%lu,list->next<S2SV_blank>0x%p,"" ""list->prev<S2SV_blank>0x%p\\n"" , io , inode -> i_ino , io -> list . next , io -> list . prev ) ; if ( list_empty ( & io -> list ) ) return ret ; if ( io -> flag != EXT4_IO_UNWRITTEN ) return ret ; <S2SV_StartBug> if ( offset + size <= i_size_read ( inode ) ) <S2SV_EndBug> ret = ext4_convert_unwritten_extents ( inode , offset , size ) ; if ( ret < 0 ) { printk ( KERN_EMERG ""%s:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>unwritten"" ""extents<S2SV_blank>to<S2SV_blank>written<S2SV_blank>extents,<S2SV_blank>error<S2SV_blank>is<S2SV_blank>%d"" ""<S2SV_blank>io<S2SV_blank>is<S2SV_blank>still<S2SV_blank>on<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>aio<S2SV_blank>dio<S2SV_blank>list\\n"" , __func__ , ret , inode -> i_ino ) ; return ret ; } io -> flag = 0 ; return ret ; }
","<S2SV_ModStart> return ret ; <S2SV_ModEnd> ret = ext4_convert_unwritten_extents
"
58,"CWE-19 STATIC int xfs_attr3_leaf_add_work ( struct xfs_buf * bp , struct xfs_attr3_icleaf_hdr * ichdr , struct xfs_da_args * args , int mapindex ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_name_local * name_loc ; struct xfs_attr_leaf_name_remote * name_rmt ; struct xfs_mount * mp ; int tmp ; int i ; trace_xfs_attr_leaf_add_work ( args ) ; leaf = bp -> b_addr ; ASSERT ( mapindex >= 0 && mapindex < XFS_ATTR_LEAF_MAPSIZE ) ; ASSERT ( args -> index >= 0 && args -> index <= ichdr -> count ) ; entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ; if ( args -> index < ichdr -> count ) { tmp = ichdr -> count - args -> index ; tmp *= sizeof ( xfs_attr_leaf_entry_t ) ; memmove ( entry + 1 , entry , tmp ) ; xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , entry , tmp + sizeof ( * entry ) ) ) ; } ichdr -> count ++ ; mp = args -> trans -> t_mountp ; ASSERT ( ichdr -> freemap [ mapindex ] . base < XFS_LBSIZE ( mp ) ) ; ASSERT ( ( ichdr -> freemap [ mapindex ] . base & 0x3 ) == 0 ) ; ASSERT ( ichdr -> freemap [ mapindex ] . size >= xfs_attr_leaf_newentsize ( args -> namelen , args -> valuelen , mp -> m_sb . sb_blocksize , NULL ) ) ; ASSERT ( ichdr -> freemap [ mapindex ] . size < XFS_LBSIZE ( mp ) ) ; ASSERT ( ( ichdr -> freemap [ mapindex ] . size & 0x3 ) == 0 ) ; ichdr -> freemap [ mapindex ] . size -= xfs_attr_leaf_newentsize ( args -> namelen , args -> valuelen , mp -> m_sb . sb_blocksize , & tmp ) ; entry -> nameidx = cpu_to_be16 ( ichdr -> freemap [ mapindex ] . base + ichdr -> freemap [ mapindex ] . size ) ; entry -> hashval = cpu_to_be32 ( args -> hashval ) ; entry -> flags = tmp ? XFS_ATTR_LOCAL : 0 ; entry -> flags |= XFS_ATTR_NSP_ARGS_TO_ONDISK ( args -> flags ) ; if ( args -> op_flags & XFS_DA_OP_RENAME ) { entry -> flags |= XFS_ATTR_INCOMPLETE ; if ( ( args -> blkno2 == args -> blkno ) && ( args -> index2 <= args -> index ) ) { args -> index2 ++ ; } } xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , entry , sizeof ( * entry ) ) ) ; ASSERT ( ( args -> index == 0 ) || ( be32_to_cpu ( entry -> hashval ) >= be32_to_cpu ( ( entry - 1 ) -> hashval ) ) ) ; ASSERT ( ( args -> index == ichdr -> count - 1 ) || ( be32_to_cpu ( entry -> hashval ) <= be32_to_cpu ( ( entry + 1 ) -> hashval ) ) ) ; if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ; name_loc -> namelen = args -> namelen ; name_loc -> valuelen = cpu_to_be16 ( args -> valuelen ) ; memcpy ( ( char * ) name_loc -> nameval , args -> name , args -> namelen ) ; memcpy ( ( char * ) & name_loc -> nameval [ args -> namelen ] , args -> value , be16_to_cpu ( name_loc -> valuelen ) ) ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; name_rmt -> namelen = args -> namelen ; memcpy ( ( char * ) name_rmt -> name , args -> name , args -> namelen ) ; entry -> flags |= XFS_ATTR_INCOMPLETE ; name_rmt -> valuelen = 0 ; name_rmt -> valueblk = 0 ; args -> rmtblkno = 1 ; args -> rmtblkcnt = xfs_attr3_rmt_blocks ( mp , args -> valuelen ) ; <S2SV_StartBug> } <S2SV_EndBug> xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , xfs_attr3_leaf_name ( leaf , args -> index ) , xfs_attr_leaf_entsize ( leaf , args -> index ) ) ) ; if ( be16_to_cpu ( entry -> nameidx ) < ichdr -> firstused ) ichdr -> firstused = be16_to_cpu ( entry -> nameidx ) ; ASSERT ( ichdr -> firstused >= ichdr -> count * sizeof ( xfs_attr_leaf_entry_t ) + xfs_attr3_leaf_hdr_size ( leaf ) ) ; tmp = ( ichdr -> count - 1 ) * sizeof ( xfs_attr_leaf_entry_t ) + xfs_attr3_leaf_hdr_size ( leaf ) ; for ( i = 0 ; i < XFS_ATTR_LEAF_MAPSIZE ; i ++ ) { if ( ichdr -> freemap [ i ] . base == tmp ) { ichdr -> freemap [ i ] . base += sizeof ( xfs_attr_leaf_entry_t ) ; ichdr -> freemap [ i ] . size -= sizeof ( xfs_attr_leaf_entry_t ) ; } } ichdr -> usedbytes += xfs_attr_leaf_entsize ( leaf , args -> index ) ; return 0 ; }
","<S2SV_ModStart> valuelen ) ; args -> rmtvaluelen = args -> valuelen ;
"
59,"CWE-269 struct crypto_alg * crypto_larval_lookup ( const char * name , u32 type , u32 mask ) { struct crypto_alg * alg ; if ( ! name ) return ERR_PTR ( - ENOENT ) ; mask &= ~ ( CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD ) ; type &= mask ; alg = crypto_alg_lookup ( name , type , mask ) ; if ( ! alg ) { <S2SV_StartBug> request_module ( ""%s"" , name ) ; <S2SV_EndBug> if ( ! ( ( type ^ CRYPTO_ALG_NEED_FALLBACK ) & mask & CRYPTO_ALG_NEED_FALLBACK ) ) <S2SV_StartBug> request_module ( ""%s-all"" , name ) ; <S2SV_EndBug> alg = crypto_alg_lookup ( name , type , mask ) ; } if ( alg ) return crypto_is_larval ( alg ) ? crypto_larval_wait ( alg ) : alg ; return crypto_larval_add ( name , type , mask ) ; }
","<S2SV_ModStart> { request_module ( ""crypto-%s"" <S2SV_ModEnd> , name ) <S2SV_ModStart> ) request_module ( ""crypto-%s-all"" <S2SV_ModEnd> , name )
"
60,"CWE-125 static int isis_print_mt_capability_subtlv ( netdissect_options * ndo , const uint8_t * tptr , int len ) { int stlv_type , stlv_len , tmp ; while ( len > 2 ) { <S2SV_StartBug> stlv_type = * ( tptr ++ ) ; <S2SV_EndBug> stlv_len = * ( tptr ++ ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>subTLV<S2SV_blank>#%u,<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( isis_mt_capability_subtlv_values , ""unknown"" , stlv_type ) , stlv_type , stlv_len ) ) ; <S2SV_StartBug> len = len - 2 ; <S2SV_EndBug> switch ( stlv_type ) { case ISIS_SUBTLV_SPB_INSTANCE : <S2SV_StartBug> ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>CIST<S2SV_blank>Root-ID:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>Path<S2SV_blank>Cost:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>Prio:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr ) ) ) ; tptr = tptr + 2 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr ) >> 5 ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>V:<S2SV_blank>%d"" , ( EXTRACT_16BITS ( tptr ) >> 4 ) & 0x0001 ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>SPSource-ID:<S2SV_blank>%d"" , ( EXTRACT_32BITS ( tptr ) & 0x000fffff ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>No<S2SV_blank>of<S2SV_blank>Trees:<S2SV_blank>%x"" , * ( tptr ) ) ) ; tmp = * ( tptr ++ ) ; len = len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; <S2SV_StartBug> while ( tmp ) <S2SV_EndBug> { <S2SV_StartBug> ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>U:%d,<S2SV_blank>M:%d,<S2SV_blank>A:%d,<S2SV_blank>RES:%d"" , * ( tptr ) >> 7 , ( * ( tptr ) >> 6 ) & 0x01 , ( * ( tptr ) >> 5 ) & 0x01 , ( * ( tptr ) & 0x1f ) ) ) ; tptr ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>ECT:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>BVID:<S2SV_blank>%d,<S2SV_blank>SPVID:<S2SV_blank>%d"" , ( EXTRACT_24BITS ( tptr ) >> 12 ) & 0x000fff , EXTRACT_24BITS ( tptr ) & 0x000fff ) ) ; tptr = tptr + 3 ; <S2SV_StartBug> len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ; <S2SV_EndBug> tmp -- ; } break ; case ISIS_SUBTLV_SPBM_SI : <S2SV_StartBug> ND_TCHECK2 ( * tptr , 8 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>BMAC:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , ""%04x"" , EXTRACT_16BITS ( tptr ) ) ) ; tptr = tptr + 2 ; ND_PRINT ( ( ndo , "",<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>VID:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr ) >> 12 , ( EXTRACT_16BITS ( tptr ) ) & 0x0fff ) ) ; tptr = tptr + 2 ; len = len - 8 ; stlv_len = stlv_len - 8 ; while ( stlv_len >= 4 ) { ND_TCHECK2 ( * tptr , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>T:<S2SV_blank>%d,<S2SV_blank>R:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>ISID:<S2SV_blank>%d"" , ( EXTRACT_32BITS ( tptr ) >> 31 ) , ( EXTRACT_32BITS ( tptr ) >> 30 ) & 0x01 , ( EXTRACT_32BITS ( tptr ) >> 24 ) & 0x03f , ( EXTRACT_32BITS ( tptr ) ) & 0x0ffffff ) ) ; tptr = tptr + 4 ; len = len - 4 ; stlv_len = stlv_len - 4 ; } break ; default : break ; } <S2SV_StartBug> } <S2SV_EndBug> return 0 ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( 1 ) ; }
","<S2SV_ModStart> 2 ) { ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> len - 2 ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len ) <S2SV_ModStart> case ISIS_SUBTLV_SPB_INSTANCE : if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; <S2SV_ModStart> tmp ) { if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ; stlv_len = stlv_len <S2SV_ModStart> case ISIS_SUBTLV_SPBM_SI : if ( stlv_len < 8 ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> break ; } tptr += stlv_len ; len -= stlv_len ;
"
61,"CWE-000 static void dispatch_cmd ( conn c ) { int r , i , timeout = - 1 ; size_t z ; unsigned int count ; job j ; unsigned char type ; char * size_buf , * delay_buf , * ttr_buf , * pri_buf , * end_buf , * name ; unsigned int pri , body_size ; usec delay , ttr ; uint64_t id ; tube t = NULL ; c -> cmd [ c -> cmd_len - 2 ] = '\\0' ; if ( strlen ( c -> cmd ) != c -> cmd_len - 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } type = which_cmd ( c ) ; dprintf ( ""got<S2SV_blank>%s<S2SV_blank>command:<S2SV_blank>\\""%s\\""\\n"" , op_names [ ( int ) type ] , c -> cmd ) ; switch ( type ) { case OP_PUT : r = read_pri ( & pri , c -> cmd + 4 , & delay_buf ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_delay ( & delay , delay_buf , & ttr_buf ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_ttr ( & ttr , ttr_buf , & size_buf ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; errno = 0 ; body_size = strtoul ( size_buf , & end_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; if ( body_size > job_data_size_limit ) { <S2SV_StartBug> return reply_msg ( c , MSG_JOB_TOO_BIG ) ; <S2SV_EndBug> } if ( end_buf [ 0 ] != '\\0' ) return reply_msg ( c , MSG_BAD_FORMAT ) ; conn_set_producer ( c ) ; c -> in_job = make_job ( pri , delay , ttr ? : 1 , body_size + 2 , c -> use ) ; if ( ! c -> in_job ) { twarnx ( ""server<S2SV_blank>error:<S2SV_blank>"" MSG_OUT_OF_MEMORY ) ; return skip ( c , body_size + 2 , MSG_OUT_OF_MEMORY ) ; } fill_extra_data ( c ) ; maybe_enqueue_incoming_job ( c ) ; break ; case OP_PEEK_READY : if ( c -> cmd_len != CMD_PEEK_READY_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; j = job_copy ( pq_peek ( & c -> use -> ready ) ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; reply_job ( c , j , MSG_FOUND ) ; break ; case OP_PEEK_DELAYED : if ( c -> cmd_len != CMD_PEEK_DELAYED_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; j = job_copy ( pq_peek ( & c -> use -> delay ) ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; reply_job ( c , j , MSG_FOUND ) ; break ; case OP_PEEK_BURIED : if ( c -> cmd_len != CMD_PEEK_BURIED_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; j = job_copy ( buried_job_p ( c -> use ) ? j = c -> use -> buried . next : NULL ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; reply_job ( c , j , MSG_FOUND ) ; break ; case OP_PEEKJOB : errno = 0 ; id = strtoull ( c -> cmd + CMD_PEEKJOB_LEN , & end_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; j = job_copy ( peek_job ( id ) ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; reply_job ( c , j , MSG_FOUND ) ; break ; case OP_RESERVE_TIMEOUT : errno = 0 ; timeout = strtol ( c -> cmd + CMD_RESERVE_TIMEOUT_LEN , & end_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; case OP_RESERVE : if ( type == OP_RESERVE && c -> cmd_len != CMD_RESERVE_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; conn_set_worker ( c ) ; if ( conn_has_close_deadline ( c ) && ! conn_ready ( c ) ) { return reply_msg ( c , MSG_DEADLINE_SOON ) ; } wait_for_job ( c , timeout ) ; process_queue ( ) ; break ; case OP_DELETE : errno = 0 ; id = strtoull ( c -> cmd + CMD_DELETE_LEN , & end_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; j = job_find ( id ) ; j = remove_reserved_job ( c , j ) ? : remove_ready_job ( j ) ? : remove_buried_job ( j ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; j -> state = JOB_STATE_INVALID ; r = binlog_write_job ( j ) ; job_free ( j ) ; if ( ! r ) return reply_serr ( c , MSG_INTERNAL_ERROR ) ; reply ( c , MSG_DELETED , MSG_DELETED_LEN , STATE_SENDWORD ) ; break ; case OP_RELEASE : errno = 0 ; id = strtoull ( c -> cmd + CMD_RELEASE_LEN , & pri_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_pri ( & pri , pri_buf , & delay_buf ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_delay ( & delay , delay_buf , NULL ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; j = remove_reserved_job ( c , job_find ( id ) ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; if ( delay ) { z = binlog_reserve_space_update ( j ) ; if ( ! z ) return reply_serr ( c , MSG_OUT_OF_MEMORY ) ; j -> reserved_binlog_space += z ; } j -> pri = pri ; j -> delay = delay ; j -> release_ct ++ ; r = enqueue_job ( j , delay , ! ! delay ) ; if ( r < 0 ) return reply_serr ( c , MSG_INTERNAL_ERROR ) ; if ( r == 1 ) { return reply ( c , MSG_RELEASED , MSG_RELEASED_LEN , STATE_SENDWORD ) ; } bury_job ( j , 0 ) ; reply ( c , MSG_BURIED , MSG_BURIED_LEN , STATE_SENDWORD ) ; break ; case OP_BURY : errno = 0 ; id = strtoull ( c -> cmd + CMD_BURY_LEN , & pri_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_pri ( & pri , pri_buf , NULL ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; j = remove_reserved_job ( c , job_find ( id ) ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; j -> pri = pri ; r = bury_job ( j , 1 ) ; if ( ! r ) return reply_serr ( c , MSG_INTERNAL_ERROR ) ; reply ( c , MSG_BURIED , MSG_BURIED_LEN , STATE_SENDWORD ) ; break ; case OP_KICK : errno = 0 ; count = strtoul ( c -> cmd + CMD_KICK_LEN , & end_buf , 10 ) ; if ( end_buf == c -> cmd + CMD_KICK_LEN ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; i = kick_jobs ( c -> use , count ) ; return reply_line ( c , STATE_SENDWORD , ""KICKED<S2SV_blank>%u\\r\\n"" , i ) ; case OP_TOUCH : errno = 0 ; id = strtoull ( c -> cmd + CMD_TOUCH_LEN , & end_buf , 10 ) ; if ( errno ) return twarn ( ""strtoull"" ) , reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; j = touch_job ( c , job_find ( id ) ) ; if ( j ) { reply ( c , MSG_TOUCHED , MSG_TOUCHED_LEN , STATE_SENDWORD ) ; } else { return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; } break ; case OP_STATS : if ( c -> cmd_len != CMD_STATS_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; do_stats ( c , fmt_stats , NULL ) ; break ; case OP_JOBSTATS : errno = 0 ; id = strtoull ( c -> cmd + CMD_JOBSTATS_LEN , & end_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; j = peek_job ( id ) ; if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; if ( ! j -> tube ) return reply_serr ( c , MSG_INTERNAL_ERROR ) ; do_stats ( c , ( fmt_fn ) fmt_job_stats , j ) ; break ; case OP_STATS_TUBE : name = c -> cmd + CMD_STATS_TUBE_LEN ; if ( ! name_is_ok ( name , 200 ) ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; t = tube_find ( name ) ; if ( ! t ) return reply_msg ( c , MSG_NOTFOUND ) ; do_stats ( c , ( fmt_fn ) fmt_stats_tube , t ) ; t = NULL ; break ; case OP_LIST_TUBES : if ( c -> cmd_len != CMD_LIST_TUBES_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; do_list_tubes ( c , & tubes ) ; break ; case OP_LIST_TUBE_USED : if ( c -> cmd_len != CMD_LIST_TUBE_USED_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; reply_line ( c , STATE_SENDWORD , ""USING<S2SV_blank>%s\\r\\n"" , c -> use -> name ) ; break ; case OP_LIST_TUBES_WATCHED : if ( c -> cmd_len != CMD_LIST_TUBES_WATCHED_LEN + 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } op_ct [ type ] ++ ; do_list_tubes ( c , & c -> watch ) ; break ; case OP_USE : name = c -> cmd + CMD_USE_LEN ; if ( ! name_is_ok ( name , 200 ) ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; TUBE_ASSIGN ( t , tube_find_or_make ( name ) ) ; if ( ! t ) return reply_serr ( c , MSG_OUT_OF_MEMORY ) ; c -> use -> using_ct -- ; TUBE_ASSIGN ( c -> use , t ) ; TUBE_ASSIGN ( t , NULL ) ; c -> use -> using_ct ++ ; reply_line ( c , STATE_SENDWORD , ""USING<S2SV_blank>%s\\r\\n"" , c -> use -> name ) ; break ; case OP_WATCH : name = c -> cmd + CMD_WATCH_LEN ; if ( ! name_is_ok ( name , 200 ) ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; TUBE_ASSIGN ( t , tube_find_or_make ( name ) ) ; if ( ! t ) return reply_serr ( c , MSG_OUT_OF_MEMORY ) ; r = 1 ; if ( ! ms_contains ( & c -> watch , t ) ) r = ms_append ( & c -> watch , t ) ; TUBE_ASSIGN ( t , NULL ) ; if ( ! r ) return reply_serr ( c , MSG_OUT_OF_MEMORY ) ; reply_line ( c , STATE_SENDWORD , ""WATCHING<S2SV_blank>%d\\r\\n"" , c -> watch . used ) ; break ; case OP_IGNORE : name = c -> cmd + CMD_IGNORE_LEN ; if ( ! name_is_ok ( name , 200 ) ) return reply_msg ( c , MSG_BAD_FORMAT ) ; op_ct [ type ] ++ ; t = NULL ; for ( i = 0 ; i < c -> watch . used ; i ++ ) { t = c -> watch . items [ i ] ; if ( strncmp ( t -> name , name , MAX_TUBE_NAME_LEN ) == 0 ) break ; t = NULL ; } if ( t && c -> watch . used < 2 ) return reply_msg ( c , MSG_NOT_IGNORED ) ; if ( t ) ms_remove ( & c -> watch , t ) ; t = NULL ; reply_line ( c , STATE_SENDWORD , ""WATCHING<S2SV_blank>%d\\r\\n"" , c -> watch . used ) ; break ; case OP_QUIT : conn_close ( c ) ; break ; case OP_PAUSE_TUBE : op_ct [ type ] ++ ; r = read_tube_name ( & name , c -> cmd + CMD_PAUSE_TUBE_LEN , & delay_buf ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_delay ( & delay , delay_buf , NULL ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; * delay_buf = '\\0' ; t = tube_find ( name ) ; if ( ! t ) return reply_msg ( c , MSG_NOTFOUND ) ; t -> deadline_at = now_usec ( ) + delay ; t -> pause = delay ; t -> stat . pause_ct ++ ; set_main_delay_timeout ( ) ; reply_line ( c , STATE_SENDWORD , ""PAUSED\\r\\n"" ) ; break ; default : return reply_msg ( c , MSG_UNKNOWN_COMMAND ) ; } }
","<S2SV_ModStart> ) { return skip ( c , body_size + 2 <S2SV_ModEnd> , MSG_JOB_TOO_BIG )
"
62,"CWE-200 long dgnc_mgmt_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { unsigned long flags ; void __user * uarg = ( void __user * ) arg ; switch ( cmd ) { case DIGI_GETDD : { struct digi_dinfo ddi ; spin_lock_irqsave ( & dgnc_global_lock , flags ) ; <S2SV_StartBug> ddi . dinfo_nboards = dgnc_NumBoards ; <S2SV_EndBug> sprintf ( ddi . dinfo_version , ""%s"" , DG_PART ) ; spin_unlock_irqrestore ( & dgnc_global_lock , flags ) ; if ( copy_to_user ( uarg , & ddi , sizeof ( ddi ) ) ) return - EFAULT ; break ; } case DIGI_GETBD : { int brd ; struct digi_info di ; if ( copy_from_user ( & brd , uarg , sizeof ( int ) ) ) return - EFAULT ; if ( brd < 0 || brd >= dgnc_NumBoards ) return - ENODEV ; memset ( & di , 0 , sizeof ( di ) ) ; di . info_bdnum = brd ; spin_lock_irqsave ( & dgnc_Board [ brd ] -> bd_lock , flags ) ; di . info_bdtype = dgnc_Board [ brd ] -> dpatype ; di . info_bdstate = dgnc_Board [ brd ] -> dpastatus ; di . info_ioport = 0 ; di . info_physaddr = ( ulong ) dgnc_Board [ brd ] -> membase ; di . info_physsize = ( ulong ) dgnc_Board [ brd ] -> membase - dgnc_Board [ brd ] -> membase_end ; if ( dgnc_Board [ brd ] -> state != BOARD_FAILED ) di . info_nports = dgnc_Board [ brd ] -> nasync ; else di . info_nports = 0 ; spin_unlock_irqrestore ( & dgnc_Board [ brd ] -> bd_lock , flags ) ; if ( copy_to_user ( uarg , & di , sizeof ( di ) ) ) return - EFAULT ; break ; } case DIGI_GET_NI_INFO : { struct channel_t * ch ; struct ni_info ni ; unsigned char mstat = 0 ; uint board = 0 ; uint channel = 0 ; if ( copy_from_user ( & ni , uarg , sizeof ( ni ) ) ) return - EFAULT ; board = ni . board ; channel = ni . channel ; if ( board >= dgnc_NumBoards ) return - ENODEV ; if ( channel >= dgnc_Board [ board ] -> nasync ) return - ENODEV ; ch = dgnc_Board [ board ] -> channels [ channel ] ; if ( ! ch || ch -> magic != DGNC_CHANNEL_MAGIC ) return - ENODEV ; memset ( & ni , 0 , sizeof ( ni ) ) ; ni . board = board ; ni . channel = channel ; spin_lock_irqsave ( & ch -> ch_lock , flags ) ; mstat = ( ch -> ch_mostat | ch -> ch_mistat ) ; if ( mstat & UART_MCR_DTR ) { ni . mstat |= TIOCM_DTR ; ni . dtr = TIOCM_DTR ; } if ( mstat & UART_MCR_RTS ) { ni . mstat |= TIOCM_RTS ; ni . rts = TIOCM_RTS ; } if ( mstat & UART_MSR_CTS ) { ni . mstat |= TIOCM_CTS ; ni . cts = TIOCM_CTS ; } if ( mstat & UART_MSR_RI ) { ni . mstat |= TIOCM_RI ; ni . ri = TIOCM_RI ; } if ( mstat & UART_MSR_DCD ) { ni . mstat |= TIOCM_CD ; ni . dcd = TIOCM_CD ; } if ( mstat & UART_MSR_DSR ) ni . mstat |= TIOCM_DSR ; ni . iflag = ch -> ch_c_iflag ; ni . oflag = ch -> ch_c_oflag ; ni . cflag = ch -> ch_c_cflag ; ni . lflag = ch -> ch_c_lflag ; if ( ch -> ch_digi . digi_flags & CTSPACE || ch -> ch_c_cflag & CRTSCTS ) ni . hflow = 1 ; else ni . hflow = 0 ; if ( ( ch -> ch_flags & CH_STOPI ) || ( ch -> ch_flags & CH_FORCED_STOPI ) ) ni . recv_stopped = 1 ; else ni . recv_stopped = 0 ; if ( ( ch -> ch_flags & CH_STOP ) || ( ch -> ch_flags & CH_FORCED_STOP ) ) ni . xmit_stopped = 1 ; else ni . xmit_stopped = 0 ; ni . curtx = ch -> ch_txcount ; ni . currx = ch -> ch_rxcount ; ni . baud = ch -> ch_old_baud ; spin_unlock_irqrestore ( & ch -> ch_lock , flags ) ; if ( copy_to_user ( uarg , & ni , sizeof ( ni ) ) ) return - EFAULT ; break ; } } return 0 ; }
","<S2SV_ModStart> flags ) ; memset ( & ddi , 0 , sizeof ( ddi ) ) ;
"
63,"CWE-125 static int mp_capable_print ( netdissect_options * ndo , const u_char * opt , u_int opt_len , u_char flags ) { const struct mp_capable * mpc = ( const struct mp_capable * ) opt ; <S2SV_StartBug> if ( ! ( opt_len == 12 && flags & TH_SYN ) && <S2SV_EndBug> ! ( opt_len == 20 && ( flags & ( TH_SYN | TH_ACK ) ) == TH_ACK ) ) return 0 ; if ( MP_CAPABLE_OPT_VERSION ( mpc -> sub_ver ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>Unknown<S2SV_blank>Version<S2SV_blank>(%d)"" , MP_CAPABLE_OPT_VERSION ( mpc -> sub_ver ) ) ) ; return 1 ; } if ( mpc -> flags & MP_CAPABLE_C ) ND_PRINT ( ( ndo , ""<S2SV_blank>csum"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>{0x%"" PRIx64 , EXTRACT_64BITS ( mpc -> sender_key ) ) ) ; if ( opt_len == 20 ) ND_PRINT ( ( ndo , "",0x%"" PRIx64 , EXTRACT_64BITS ( mpc -> receiver_key ) ) ) ; ND_PRINT ( ( ndo , ""}"" ) ) ; return 1 ; }
","<S2SV_ModStart> == 12 && ( <S2SV_ModStart> flags & TH_SYN )
"
64,"CWE-264 static int attach_child_main ( void * data ) { struct attach_clone_payload * payload = ( struct attach_clone_payload * ) data ; int ipc_socket = payload -> ipc_socket ; <S2SV_StartBug> int procfd = payload -> procfd ; <S2SV_EndBug> lxc_attach_options_t * options = payload -> options ; struct lxc_proc_context_info * init_ctx = payload -> init_ctx ; # if HAVE_SYS_PERSONALITY_H long new_personality ; # endif int ret ; int status ; int expected ; long flags ; int fd ; <S2SV_StartBug> uid_t new_uid ; <S2SV_EndBug> gid_t new_gid ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0)"" ) ; <S2SV_EndBug> shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ! ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS ) ) { ret = lxc_attach_remount_sys_proc ( ) ; if ( ret < 0 ) { shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # if HAVE_SYS_PERSONALITY_H if ( options -> personality < 0 ) new_personality = init_ctx -> personality ; else new_personality = options -> personality ; if ( options -> attach_flags & LXC_ATTACH_SET_PERSONALITY ) { ret = personality ( new_personality ) ; if ( ret < 0 ) { SYSERROR ( ""could<S2SV_blank>not<S2SV_blank>ensure<S2SV_blank>correct<S2SV_blank>architecture"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # endif if ( options -> attach_flags & LXC_ATTACH_DROP_CAPABILITIES ) { ret = lxc_attach_drop_privs ( init_ctx ) ; if ( ret < 0 ) { ERROR ( ""could<S2SV_blank>not<S2SV_blank>drop<S2SV_blank>privileges"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } ret = lxc_attach_set_environment ( options -> env_policy , options -> extra_env_vars , options -> extra_keep_env ) ; if ( ret < 0 ) { ERROR ( ""could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>initial<S2SV_blank>environment<S2SV_blank>for<S2SV_blank>attached<S2SV_blank>process"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } new_uid = 0 ; new_gid = 0 ; if ( options -> namespaces & CLONE_NEWUSER ) lxc_attach_get_init_uidgid ( & new_uid , & new_gid ) ; if ( options -> uid != ( uid_t ) - 1 ) new_uid = options -> uid ; if ( options -> gid != ( gid_t ) - 1 ) new_gid = options -> gid ; if ( options -> stdin_fd && isatty ( options -> stdin_fd ) ) { if ( setsid ( ) < 0 ) { SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>setsid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ioctl ( options -> stdin_fd , TIOCSCTTY , ( char * ) NULL ) < 0 ) { SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>TIOCSTTY"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( ( new_gid != 0 || options -> namespaces & CLONE_NEWUSER ) ) { if ( setgid ( new_gid ) || setgroups ( 0 , NULL ) ) { SYSERROR ( ""switching<S2SV_blank>to<S2SV_blank>container<S2SV_blank>gid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( ( new_uid != 0 || options -> namespaces & CLONE_NEWUSER ) && setuid ( new_uid ) ) { SYSERROR ( ""switching<S2SV_blank>to<S2SV_blank>container<S2SV_blank>uid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } status = 1 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret != sizeof ( status ) ) { <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1)"" ) ; <S2SV_EndBug> shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } expected = 2 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>final<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(2)"" ) ; <S2SV_EndBug> shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ; if ( ( init_ctx -> container && init_ctx -> container -> lxc_conf && init_ctx -> container -> lxc_conf -> no_new_privs ) || ( options -> attach_flags & LXC_ATTACH_NO_NEW_PRIVS ) ) { if ( prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) < 0 ) { SYSERROR ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set.<S2SV_blank>"" ""Process<S2SV_blank>can<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>gainable<S2SV_blank>"" ""privileges."" ) ; <S2SV_StartBug> rexit ( - 1 ) ; <S2SV_EndBug> } INFO ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set.<S2SV_blank>Process<S2SV_blank>cannot<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>"" <S2SV_StartBug> ""gainable<S2SV_blank>privileges."" ) ; <S2SV_EndBug> } if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec ; <S2SV_StartBug> on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( lsm_set_label_at ( procfd , on_exec , init_ctx -> lsm_label ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> rexit ( - 1 ) ; <S2SV_EndBug> } } if ( init_ctx -> container && init_ctx -> container -> lxc_conf && init_ctx -> container -> lxc_conf -> seccomp && ( lxc_seccomp_load ( init_ctx -> container -> lxc_conf ) != 0 ) ) { ERROR ( ""Loading<S2SV_blank>seccomp<S2SV_blank>policy"" ) ; <S2SV_StartBug> rexit ( - 1 ) ; <S2SV_EndBug> } lxc_proc_put_context_info ( init_ctx ) ; if ( options -> stdin_fd >= 0 && options -> stdin_fd != 0 ) dup2 ( options -> stdin_fd , 0 ) ; if ( options -> stdout_fd >= 0 && options -> stdout_fd != 1 ) dup2 ( options -> stdout_fd , 1 ) ; if ( options -> stderr_fd >= 0 && options -> stderr_fd != 2 ) dup2 ( options -> stderr_fd , 2 ) ; if ( options -> stdin_fd > 2 ) close ( options -> stdin_fd ) ; if ( options -> stdout_fd > 2 ) close ( options -> stdout_fd ) ; if ( options -> stderr_fd > 2 ) close ( options -> stderr_fd ) ; for ( fd = 0 ; fd <= 2 ; fd ++ ) { flags = fcntl ( fd , F_GETFL ) ; if ( flags < 0 ) continue ; if ( flags & FD_CLOEXEC ) if ( fcntl ( fd , F_SETFL , flags & ~ FD_CLOEXEC ) < 0 ) SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>CLOEXEC<S2SV_blank>from<S2SV_blank>fd"" ) ; } <S2SV_StartBug> close ( procfd ) ; <S2SV_EndBug> rexit ( payload -> exec_function ( payload -> exec_payload ) ) ; }
","<S2SV_ModStart> -> ipc_socket ; <S2SV_ModEnd> lxc_attach_options_t * options <S2SV_ModStart> int fd ; int lsm_labelfd ; <S2SV_ModStart> { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0):<S2SV_blank>%s."" , strerror ( errno ) <S2SV_ModEnd> ) ; shutdown <S2SV_ModStart> { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1):<S2SV_blank>%s."" , strerror ( errno ) <S2SV_ModEnd> ) ; shutdown <S2SV_ModStart> { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>message<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>"" ""that<S2SV_blank>it<S2SV_blank>is<S2SV_blank>done<S2SV_blank>pre-initializing<S2SV_blank>(2):<S2SV_blank>%s"" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModEnd> if ( ( <S2SV_ModStart> ""privileges."" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; <S2SV_ModStart> ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set.<S2SV_blank>Process<S2SV_blank>cannot<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>"" ""gainable<S2SV_blank>privileges."" ) ; } status = 3 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>set<S2SV_blank>up<S2SV_blank>LSM<S2SV_blank>labels<S2SV_blank>(3):<S2SV_blank>%s."" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 <S2SV_ModStart> int on_exec ; ret = lxc_abstract_unix_recv_fd ( ipc_socket , & lsm_labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s."" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> ( lsm_set_label_at ( lsm_labelfd <S2SV_ModEnd> , on_exec , <S2SV_ModStart> 0 ) { SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label."" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; close ( lsm_labelfd ) ; rexit ( - 1 ) ; } close ( lsm_labelfd ) ; <S2SV_ModEnd> } if ( <S2SV_ModStart> ""Loading<S2SV_blank>seccomp<S2SV_blank>policy"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ; <S2SV_ModEnd> lxc_proc_put_context_info ( init_ctx <S2SV_ModStart> ) ; } <S2SV_ModEnd> rexit ( payload
"
65,"CWE-125 static int ng_pkt ( git_pkt * * out , const char * line , size_t len ) { git_pkt_ng * pkt ; const char * ptr ; size_t alloclen ; pkt = git__malloc ( sizeof ( * pkt ) ) ; GITERR_CHECK_ALLOC ( pkt ) ; pkt -> ref = NULL ; pkt -> type = GIT_PKT_NG ; <S2SV_StartBug> line += 3 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = strchr ( line , '<S2SV_blank>' ) ) ) <S2SV_EndBug> goto out_err ; len = ptr - line ; GITERR_CHECK_ALLOC_ADD ( & alloclen , len , 1 ) ; pkt -> ref = git__malloc ( alloclen ) ; GITERR_CHECK_ALLOC ( pkt -> ref ) ; memcpy ( pkt -> ref , line , len ) ; pkt -> ref [ len ] = '\\0' ; <S2SV_StartBug> line = ptr + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = strchr ( line , '\\n' ) ) ) <S2SV_EndBug> goto out_err ; len = ptr - line ; GITERR_CHECK_ALLOC_ADD ( & alloclen , len , 1 ) ; pkt -> msg = git__malloc ( alloclen ) ; GITERR_CHECK_ALLOC ( pkt -> msg ) ; memcpy ( pkt -> msg , line , len ) ; pkt -> msg [ len ] = '\\0' ; * out = ( git_pkt * ) pkt ; return 0 ; out_err : giterr_set ( GITERR_NET , ""invalid<S2SV_blank>packet<S2SV_blank>line"" ) ; git__free ( pkt -> ref ) ; git__free ( pkt ) ; return - 1 ; }
","<S2SV_ModStart> = GIT_PKT_NG ; if ( len < 3 ) goto out_err ; <S2SV_ModStart> += 3 ; len -= 3 ; <S2SV_ModStart> ( ptr = memchr <S2SV_ModEnd> ( line , <S2SV_ModStart> line , '<S2SV_blank>' , len <S2SV_ModStart> = '\\0' ; if ( len < 1 ) goto out_err ; <S2SV_ModStart> + 1 ; len -= 1 ; <S2SV_ModStart> ( ptr = memchr <S2SV_ModEnd> ( line , <S2SV_ModStart> line , '\\n' , len
"
66,"CWE-119 static OPJ_BOOL bmp_read_info_header ( FILE * IN , OPJ_BITMAPINFOHEADER * header ) { memset ( header , 0 , sizeof ( * header ) ) ; header -> biSize = ( OPJ_UINT32 ) getc ( IN ) ; header -> biSize |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biSize |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biSize |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; switch ( header -> biSize ) { case 12U : case 40U : case 52U : case 56U : case 108U : case 124U : break ; default : fprintf ( stderr , ""Error,<S2SV_blank>unknown<S2SV_blank>BMP<S2SV_blank>header<S2SV_blank>size<S2SV_blank>%d\\n"" , header -> biSize ) ; return OPJ_FALSE ; } header -> biWidth = ( OPJ_UINT32 ) getc ( IN ) ; header -> biWidth |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biWidth |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biWidth |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biHeight = ( OPJ_UINT32 ) getc ( IN ) ; header -> biHeight |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biHeight |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biHeight |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biPlanes = ( OPJ_UINT16 ) getc ( IN ) ; header -> biPlanes |= ( OPJ_UINT16 ) ( ( OPJ_UINT32 ) getc ( IN ) << 8 ) ; header -> biBitCount = ( OPJ_UINT16 ) getc ( IN ) ; header -> biBitCount |= ( OPJ_UINT16 ) ( ( OPJ_UINT32 ) getc ( IN ) << 8 ) ; <S2SV_StartBug> if ( header -> biSize >= 40U ) { <S2SV_EndBug> header -> biCompression = ( OPJ_UINT32 ) getc ( IN ) ; header -> biCompression |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biCompression |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biCompression |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biSizeImage = ( OPJ_UINT32 ) getc ( IN ) ; header -> biSizeImage |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biSizeImage |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biSizeImage |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biXpelsPerMeter = ( OPJ_UINT32 ) getc ( IN ) ; header -> biXpelsPerMeter |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biXpelsPerMeter |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biXpelsPerMeter |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biYpelsPerMeter = ( OPJ_UINT32 ) getc ( IN ) ; header -> biYpelsPerMeter |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biYpelsPerMeter |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biYpelsPerMeter |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biClrUsed = ( OPJ_UINT32 ) getc ( IN ) ; header -> biClrUsed |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biClrUsed |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biClrUsed |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biClrImportant = ( OPJ_UINT32 ) getc ( IN ) ; header -> biClrImportant |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biClrImportant |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biClrImportant |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; } if ( header -> biSize >= 56U ) { header -> biRedMask = ( OPJ_UINT32 ) getc ( IN ) ; header -> biRedMask |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biRedMask |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biRedMask |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biGreenMask = ( OPJ_UINT32 ) getc ( IN ) ; header -> biGreenMask |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biGreenMask |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biGreenMask |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biBlueMask = ( OPJ_UINT32 ) getc ( IN ) ; header -> biBlueMask |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biBlueMask |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biBlueMask |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biAlphaMask = ( OPJ_UINT32 ) getc ( IN ) ; header -> biAlphaMask |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biAlphaMask |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biAlphaMask |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; } if ( header -> biSize >= 108U ) { header -> biColorSpaceType = ( OPJ_UINT32 ) getc ( IN ) ; header -> biColorSpaceType |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biColorSpaceType |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biColorSpaceType |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; if ( fread ( & ( header -> biColorSpaceEP ) , 1U , sizeof ( header -> biColorSpaceEP ) , IN ) != sizeof ( header -> biColorSpaceEP ) ) { fprintf ( stderr , ""Error,<S2SV_blank>can\'t<S2SV_blank><S2SV_blank>read<S2SV_blank>BMP<S2SV_blank>header\\n"" ) ; return OPJ_FALSE ; } header -> biRedGamma = ( OPJ_UINT32 ) getc ( IN ) ; header -> biRedGamma |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biRedGamma |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biRedGamma |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biGreenGamma = ( OPJ_UINT32 ) getc ( IN ) ; header -> biGreenGamma |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biGreenGamma |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biGreenGamma |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biBlueGamma = ( OPJ_UINT32 ) getc ( IN ) ; header -> biBlueGamma |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biBlueGamma |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biBlueGamma |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; } if ( header -> biSize >= 124U ) { header -> biIntent = ( OPJ_UINT32 ) getc ( IN ) ; header -> biIntent |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biIntent |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biIntent |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biIccProfileData = ( OPJ_UINT32 ) getc ( IN ) ; header -> biIccProfileData |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biIccProfileData |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biIccProfileData |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biIccProfileSize = ( OPJ_UINT32 ) getc ( IN ) ; header -> biIccProfileSize |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biIccProfileSize |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biIccProfileSize |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biReserved = ( OPJ_UINT32 ) getc ( IN ) ; header -> biReserved |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biReserved |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biReserved |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; } return OPJ_TRUE ; }
","<S2SV_ModStart> ( header -> biBitCount == 0 ) { fprintf ( stderr , ""Error,<S2SV_blank>invalid<S2SV_blank>biBitCount<S2SV_blank>%d\\n"" , 0 ) ; return OPJ_FALSE ; } if ( header ->
"
67,"CWE-000 static void sas_discover_domain ( struct work_struct * work ) { struct domain_device * dev ; int error = 0 ; struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ; struct asd_sas_port * port = ev -> port ; clear_bit ( DISCE_DISCOVER_DOMAIN , & port -> disc . pending ) ; if ( port -> port_dev ) return ; error = sas_get_port_device ( port ) ; if ( error ) return ; dev = port -> port_dev ; SAS_DPRINTK ( ""DOING<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d\\n"" , port -> id , task_pid_nr ( current ) ) ; switch ( dev -> dev_type ) { case SAS_END_DEVICE : error = sas_discover_end_dev ( dev ) ; break ; case SAS_EDGE_EXPANDER_DEVICE : case SAS_FANOUT_EXPANDER_DEVICE : error = sas_discover_root_expander ( dev ) ; break ; case SAS_SATA_DEV : case SAS_SATA_PM : # ifdef CONFIG_SCSI_SAS_ATA error = sas_discover_sata ( dev ) ; break ; # else SAS_DPRINTK ( ""ATA<S2SV_blank>device<S2SV_blank>seen<S2SV_blank>but<S2SV_blank>CONFIG_SCSI_SAS_ATA=N<S2SV_blank>so<S2SV_blank>cannot<S2SV_blank>attach\\n"" ) ; # endif default : error = - ENXIO ; SAS_DPRINTK ( ""unhandled<S2SV_blank>device<S2SV_blank>%d\\n"" , dev -> dev_type ) ; break ; } if ( error ) { sas_rphy_free ( dev -> rphy ) ; list_del_init ( & dev -> disco_list_node ) ; spin_lock_irq ( & port -> dev_list_lock ) ; list_del_init ( & dev -> dev_list_node ) ; spin_unlock_irq ( & port -> dev_list_lock ) ; sas_put_device ( dev ) ; port -> port_dev = NULL ; } <S2SV_StartBug> SAS_DPRINTK ( ""DONE<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>result:%d\\n"" , port -> id , <S2SV_EndBug> task_pid_nr ( current ) , error ) ; }
","<S2SV_ModStart> NULL ; } sas_probe_devices ( port ) ;
"
68,"CWE-415 static Image * ReadTGAImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; PixelInfo pixel ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t base , flag , offset , real , skip ; ssize_t count , y ; TGAInfo tga_info ; unsigned char j , k , pixels [ 4 ] , runlength ; unsigned int alpha_bits ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 1 , & tga_info . id_length ) ; tga_info . colormap_type = ( unsigned char ) ReadBlobByte ( image ) ; tga_info . image_type = ( TGAImageType ) ReadBlobByte ( image ) ; if ( ( count != 1 ) || ( ( tga_info . image_type != TGAColormap ) && ( tga_info . image_type != TGARGB ) && ( tga_info . image_type != TGAMonochrome ) && ( tga_info . image_type != TGARLEColormap ) && ( tga_info . image_type != TGARLERGB ) && ( tga_info . image_type != TGARLEMonochrome ) ) || ( ( ( tga_info . image_type == TGAColormap ) || ( tga_info . image_type == TGARLEColormap ) ) && ( tga_info . colormap_type == 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; tga_info . colormap_index = ReadBlobLSBShort ( image ) ; tga_info . colormap_length = ReadBlobLSBShort ( image ) ; tga_info . colormap_size = ( unsigned char ) ReadBlobByte ( image ) ; tga_info . x_origin = ReadBlobLSBShort ( image ) ; tga_info . y_origin = ReadBlobLSBShort ( image ) ; tga_info . width = ( unsigned short ) ReadBlobLSBShort ( image ) ; tga_info . height = ( unsigned short ) ReadBlobLSBShort ( image ) ; tga_info . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; tga_info . attributes = ( unsigned char ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; if ( ( ( ( tga_info . bits_per_pixel <= 1 ) || ( tga_info . bits_per_pixel >= 17 ) ) && ( tga_info . bits_per_pixel != 24 ) && ( tga_info . bits_per_pixel != 32 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = tga_info . width ; image -> rows = tga_info . height ; alpha_bits = ( tga_info . attributes & 0x0FU ) ; image -> alpha_trait = ( alpha_bits > 0 ) || ( tga_info . bits_per_pixel == 32 ) || ( tga_info . colormap_size == 32 ) ? BlendPixelTrait : UndefinedPixelTrait ; if ( ( tga_info . image_type != TGAColormap ) && ( tga_info . image_type != TGARLEColormap ) ) image -> depth = ( size_t ) ( ( tga_info . bits_per_pixel <= 8 ) ? 8 : ( tga_info . bits_per_pixel <= 16 ) ? 5 : ( tga_info . bits_per_pixel == 24 ) ? 8 : ( tga_info . bits_per_pixel == 32 ) ? 8 : 8 ) ; else image -> depth = ( size_t ) ( ( tga_info . colormap_size <= 8 ) ? 8 : ( tga_info . colormap_size <= 16 ) ? 5 : ( tga_info . colormap_size == 24 ) ? 8 : ( tga_info . colormap_size == 32 ) ? 8 : 8 ) ; if ( ( tga_info . image_type == TGAColormap ) || ( tga_info . image_type == TGAMonochrome ) || ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLEMonochrome ) ) image -> storage_class = PseudoClass ; image -> compression = NoCompression ; if ( ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLEMonochrome ) || ( tga_info . image_type == TGARLERGB ) ) image -> compression = RLECompression ; if ( image -> storage_class == PseudoClass ) { if ( tga_info . colormap_type != 0 ) image -> colors = tga_info . colormap_index + tga_info . colormap_length ; else { size_t one ; one = 1 ; image -> colors = one << tga_info . bits_per_pixel ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } } if ( tga_info . id_length != 0 ) { char * comment ; size_t length ; length = ( size_t ) tga_info . id_length ; comment = ( char * ) NULL ; if ( ~ length >= ( MagickPathExtent - 1 ) ) comment = ( char * ) AcquireQuantumMemory ( length + MagickPathExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , tga_info . id_length , ( unsigned char * ) comment ) ; comment [ tga_info . id_length ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; } if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; pixel . alpha = ( MagickRealType ) OpaqueAlpha ; if ( tga_info . colormap_type != 0 ) <S2SV_StartBug> { <S2SV_EndBug> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) tga_info . colormap_index ; i ++ ) image -> colormap [ i ] = pixel ; for ( ; i < ( ssize_t ) image -> colors ; i ++ ) { switch ( tga_info . colormap_size ) { case 8 : default : { pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . green = pixel . red ; pixel . blue = pixel . red ; break ; } case 15 : case 16 : { QuantumAny range ; j = ( unsigned char ) ReadBlobByte ( image ) ; k = ( unsigned char ) ReadBlobByte ( image ) ; range = GetQuantumRange ( 5UL ) ; pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( k & 0x7c ) >> 2 , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( 1UL * ( k & 0x03 ) << 3 ) + ( 1UL * ( j & 0xe0 ) >> 5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( j & 0x1f ) , range ) ; break ; } case 24 : { pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; break ; } case 32 : { pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; pixel . alpha = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; break ; } } image -> colormap [ i ] = pixel ; } } base = 0 ; flag = 0 ; skip = MagickFalse ; real = 0 ; index = 0 ; runlength = 0 ; offset = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { real = offset ; if ( ( ( unsigned char ) ( tga_info . attributes & 0x20 ) >> 5 ) == 0 ) real = image -> rows - real - 1 ; q = QueueAuthenticPixels ( image , 0 , ( ssize_t ) real , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLERGB ) || ( tga_info . image_type == TGARLEMonochrome ) ) { if ( runlength != 0 ) { runlength -- ; skip = flag != 0 ; } else { count = ReadBlob ( image , 1 , & runlength ) ; if ( count != 1 ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; flag = runlength & 0x80 ; if ( flag != 0 ) runlength -= 128 ; skip = MagickFalse ; } } if ( skip == MagickFalse ) switch ( tga_info . bits_per_pixel ) { case 8 : default : { index = ( Quantum ) ReadBlobByte ( image ) ; if ( tga_info . colormap_type != 0 ) pixel = image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , ( ssize_t ) index , exception ) ] ; else { pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) index ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) index ) ; pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) index ) ; } break ; } case 15 : case 16 : { QuantumAny range ; if ( ReadBlob ( image , 2 , pixels ) != 2 ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; j = pixels [ 0 ] ; k = pixels [ 1 ] ; range = GetQuantumRange ( 5UL ) ; pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( k & 0x7c ) >> 2 , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( 1UL * ( k & 0x03 ) << 3 ) + ( 1UL * ( j & 0xe0 ) >> 5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( j & 0x1f ) , range ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) pixel . alpha = ( MagickRealType ) ( ( k & 0x80 ) == 0 ? ( Quantum ) TransparentAlpha : ( Quantum ) OpaqueAlpha ) ; if ( image -> storage_class == PseudoClass ) index = ( Quantum ) ConstrainColormapIndex ( image , ( ( ssize_t ) ( k << 8 ) ) + j , exception ) ; break ; } case 24 : { if ( ReadBlob ( image , 3 , pixels ) != 3 ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 0 ] ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 1 ] ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 2 ] ) ; break ; } case 32 : { if ( ReadBlob ( image , 4 , pixels ) != 4 ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 0 ] ) ; pixel . green = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 1 ] ) ; pixel . red = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 2 ] ) ; pixel . alpha = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 3 ] ) ; break ; } } if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , index , q ) ; SetPixelRed ( image , ClampToQuantum ( pixel . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( pixel . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( pixel . blue ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ClampToQuantum ( pixel . alpha ) , q ) ; q += GetPixelChannels ( image ) ; } if ( ( ( unsigned char ) ( tga_info . attributes & 0xc0 ) >> 6 ) == 2 ) offset += 2 ; else offset ++ ; if ( offset >= image -> rows ) { base ++ ; offset = base ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> 0 ) { if ( image -> colors < tga_info . colormap_index ) image -> colors = tga_info . colormap_index ;
"
69,"CWE-190 static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
","<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if
"
70,"CWE-399 static int wanxl_ioctl ( struct net_device * dev , struct ifreq * ifr , int cmd ) { const size_t size = sizeof ( sync_serial_settings ) ; sync_serial_settings line ; port_t * port = dev_to_port ( dev ) ; if ( cmd != SIOCWANDEV ) return hdlc_ioctl ( dev , ifr , cmd ) ; switch ( ifr -> ifr_settings . type ) { case IF_GET_IFACE : ifr -> ifr_settings . type = IF_IFACE_SYNC_SERIAL ; if ( ifr -> ifr_settings . size < size ) { ifr -> ifr_settings . size = size ; return - ENOBUFS ; <S2SV_StartBug> } <S2SV_EndBug> line . clock_type = get_status ( port ) -> clocking ; line . clock_rate = 0 ; line . loopback = 0 ; if ( copy_to_user ( ifr -> ifr_settings . ifs_ifsu . sync , & line , size ) ) return - EFAULT ; return 0 ; case IF_IFACE_SYNC_SERIAL : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( dev -> flags & IFF_UP ) return - EBUSY ; if ( copy_from_user ( & line , ifr -> ifr_settings . ifs_ifsu . sync , size ) ) return - EFAULT ; if ( line . clock_type != CLOCK_EXT && line . clock_type != CLOCK_TXFROMRX ) return - EINVAL ; if ( line . loopback != 0 ) return - EINVAL ; get_status ( port ) -> clocking = line . clock_type ; return 0 ; default : return hdlc_ioctl ( dev , ifr , cmd ) ; } }
","<S2SV_ModStart> ENOBUFS ; } memset ( & line , 0 , sizeof ( line ) ) ;
"
71,"CWE-264 int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) { <S2SV_StartBug> return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ; <S2SV_EndBug> }
","<S2SV_ModStart> arg ) { int ret ; ret = scsi_verify_blk_ioctl ( bd , cmd ) ; if ( ret < 0 ) return ret ;
"
72,"CWE-125 <S2SV_StartBug> void nego_process_negotiation_request ( rdpNego * nego , wStream * s ) <S2SV_EndBug> { BYTE flags ; <S2SV_StartBug> UINT16 length ; <S2SV_EndBug> Stream_Read_UINT8 ( s , flags ) ; Stream_Read_UINT16 ( s , length ) ; Stream_Read_UINT32 ( s , nego -> RequestedProtocols ) ; WLog_DBG ( TAG , ""RDP_NEG_REQ:<S2SV_blank>RequestedProtocol:<S2SV_blank>0x%08"" PRIX32 """" , nego -> RequestedProtocols ) ; nego -> state = NEGO_STATE_FINAL ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nego_process_negotiation_request ( rdpNego <S2SV_ModStart> ; UINT16 length ; if ( Stream_GetRemainingLength ( s ) < 7 ) return FALSE <S2SV_ModStart> = NEGO_STATE_FINAL ; return TRUE ;
"
73,"CWE-119 int qeth_snmp_command ( struct qeth_card * card , char __user * udata ) { struct qeth_cmd_buffer * iob ; struct qeth_ipa_cmd * cmd ; struct qeth_snmp_ureq * ureq ; <S2SV_StartBug> int req_len ; <S2SV_EndBug> struct qeth_arp_query_info qinfo = { 0 , } ; int rc = 0 ; QETH_CARD_TEXT ( card , 3 , ""snmpcmd"" ) ; if ( card -> info . guestlan ) return - EOPNOTSUPP ; if ( ( ! qeth_adp_supported ( card , IPA_SETADP_SET_SNMP_CONTROL ) ) && ( ! card -> options . layer2 ) ) { return - EOPNOTSUPP ; } if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) ) <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ) ; if ( IS_ERR ( ureq ) ) { QETH_CARD_TEXT ( card , 2 , ""snmpnome"" ) ; return PTR_ERR ( ureq ) ; } qinfo . udata_len = ureq -> hdr . data_len ; qinfo . udata = kzalloc ( qinfo . udata_len , GFP_KERNEL ) ; if ( ! qinfo . udata ) { kfree ( ureq ) ; return - ENOMEM ; } qinfo . udata_offset = sizeof ( struct qeth_snmp_ureq_hdr ) ; iob = qeth_get_adapter_cmd ( card , IPA_SETADP_SET_SNMP_CONTROL , QETH_SNMP_SETADP_CMDLENGTH + req_len ) ; cmd = ( struct qeth_ipa_cmd * ) ( iob -> data + IPA_PDU_HEADER_SIZE ) ; memcpy ( & cmd -> data . setadapterparms . data . snmp , & ureq -> cmd , req_len ) ; rc = qeth_send_ipa_snmp_cmd ( card , iob , QETH_SETADP_BASE_LEN + req_len , qeth_snmp_command_cb , ( void * ) & qinfo ) ; if ( rc ) QETH_DBF_MESSAGE ( 2 , ""SNMP<S2SV_blank>command<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>(0x%x)\\n"" , QETH_CARD_IFNAME ( card ) , rc ) ; else { if ( copy_to_user ( udata , qinfo . udata , qinfo . udata_len ) ) rc = - EFAULT ; } kfree ( ureq ) ; kfree ( qinfo . udata ) ; return rc ; }
","<S2SV_ModStart> * ureq ; unsigned <S2SV_ModStart> return - EFAULT ; if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) ) return - EINVAL
"
74,"CWE-190 int jas_stream_pad ( jas_stream_t * stream , int n , int c ) { <S2SV_StartBug> int m ; <S2SV_EndBug> m = n ; for ( m = n ; m > 0 ; -- m ) { if ( jas_stream_putc ( stream , c ) == EOF ) return n - m ; } return n ; }
","<S2SV_ModStart> int m ; if ( n < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_pad"" ) ; }
"
75,"CWE-787 static int track_header ( VividasDemuxContext * viv , AVFormatContext * s , uint8_t * buf , int size ) { int i , j , ret ; int64_t off ; int val_1 ; int num_video ; AVIOContext pb0 , * pb = & pb0 ; ffio_init_context ( pb , buf , size , 0 , NULL , NULL , NULL , NULL ) ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; val_1 = ffio_read_varlen ( pb ) ; for ( i = 0 ; i < val_1 ; i ++ ) { int c = avio_r8 ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_EOF ; for ( j = 0 ; j < c ; j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; } } avio_r8 ( pb ) ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; num_video = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( num_video != 1 ) { av_log ( s , AV_LOG_ERROR , ""number<S2SV_blank>of<S2SV_blank>video<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , num_video ) ; return AVERROR_PATCHWELCOME ; } for ( i = 0 ; i < num_video ; i ++ ) { AVStream * st = avformat_new_stream ( s , NULL ) ; int num , den ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_VP6 ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; num = avio_rl32 ( pb ) ; den = avio_rl32 ( pb ) ; avpriv_set_pts_info ( st , 64 , num , den ) ; st -> nb_frames = avio_rl32 ( pb ) ; st -> codecpar -> width = avio_rl16 ( pb ) ; st -> codecpar -> height = avio_rl16 ( pb ) ; avio_r8 ( pb ) ; avio_rl32 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; } off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; viv -> num_audio = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( viv -> num_audio != 1 ) av_log ( s , AV_LOG_WARNING , ""number<S2SV_blank>of<S2SV_blank>audio<S2SV_blank>tracks<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>1\\n"" , viv -> num_audio ) ; for ( i = 0 ; i < viv -> num_audio ; i ++ ) { int q ; AVStream * st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = num_video + i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; st -> codecpar -> codec_id = AV_CODEC_ID_VORBIS ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; avio_rl16 ( pb ) ; st -> codecpar -> channels = avio_rl16 ( pb ) ; st -> codecpar -> sample_rate = avio_rl32 ( pb ) ; avio_seek ( pb , 10 , SEEK_CUR ) ; q = avio_r8 ( pb ) ; avio_seek ( pb , q , SEEK_CUR ) ; avio_r8 ( pb ) ; if ( avio_tell ( pb ) < off ) { int num_data ; <S2SV_StartBug> int xd_size = 0 ; <S2SV_EndBug> int data_len [ 256 ] ; int offset = 1 ; uint8_t * p ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; ffio_read_varlen ( pb ) ; num_data = avio_r8 ( pb ) ; for ( j = 0 ; j < num_data ; j ++ ) { uint64_t len = ffio_read_varlen ( pb ) ; if ( len > INT_MAX / 2 - xd_size ) { return AVERROR_INVALIDDATA ; } data_len [ j ] = len ; <S2SV_StartBug> xd_size += len ; <S2SV_EndBug> } ret = ff_alloc_extradata ( st -> codecpar , 64 + xd_size + xd_size / 255 ) ; if ( ret < 0 ) return ret ; p = st -> codecpar -> extradata ; p [ 0 ] = 2 ; for ( j = 0 ; j < num_data - 1 ; j ++ ) { unsigned delta = av_xiphlacing ( & p [ offset ] , data_len [ j ] ) ; <S2SV_StartBug> if ( delta > data_len [ j ] ) { <S2SV_EndBug> return AVERROR_INVALIDDATA ; } offset += delta ; } for ( j = 0 ; j < num_data ; j ++ ) { int ret = avio_read ( pb , & p [ offset ] , data_len [ j ] ) ; if ( ret < data_len [ j ] ) { st -> codecpar -> extradata_size = 0 ; av_freep ( & st -> codecpar -> extradata ) ; break ; } <S2SV_StartBug> offset += data_len [ j ] ; <S2SV_EndBug> } if ( offset < st -> codecpar -> extradata_size ) st -> codecpar -> extradata_size = offset ; } } return 0 ; }
","<S2SV_ModStart> int xd_size = 1 <S2SV_ModEnd> ; int data_len <S2SV_ModStart> xd_size += len + 1 + len / 255 ; } ret = ff_alloc_extradata ( st -> codecpar , xd_size <S2SV_ModEnd> ) ; if <S2SV_ModStart> ] ) ; av_assert0 ( delta <= xd_size - offset ) ; <S2SV_ModEnd> offset += delta <S2SV_ModStart> break ; } av_assert0 ( data_len [ j ] <= xd_size - offset ) ;
"
76,"CWE-125 static int mxf_parse_structural_metadata ( MXFContext * mxf ) { MXFPackage * material_package = NULL ; int i , j , k , ret ; av_log ( mxf -> fc , AV_LOG_TRACE , ""metadata<S2SV_blank>sets<S2SV_blank>count<S2SV_blank>%d\\n"" , mxf -> metadata_sets_count ) ; for ( i = 0 ; i < mxf -> packages_count ; i ++ ) { material_package = mxf_resolve_strong_ref ( mxf , & mxf -> packages_refs [ i ] , MaterialPackage ) ; if ( material_package ) break ; } if ( ! material_package ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""no<S2SV_blank>material<S2SV_blank>package<S2SV_blank>found\\n"" ) ; return AVERROR_INVALIDDATA ; } mxf_add_umid_metadata ( & mxf -> fc -> metadata , ""material_package_umid"" , material_package ) ; if ( material_package -> name && material_package -> name [ 0 ] ) av_dict_set ( & mxf -> fc -> metadata , ""material_package_name"" , material_package -> name , 0 ) ; mxf_parse_package_comments ( mxf , & mxf -> fc -> metadata , material_package ) ; for ( i = 0 ; i < material_package -> tracks_count ; i ++ ) { MXFPackage * source_package = NULL ; MXFTrack * material_track = NULL ; MXFTrack * source_track = NULL ; MXFTrack * temp_track = NULL ; MXFDescriptor * descriptor = NULL ; MXFStructuralComponent * component = NULL ; MXFTimecodeComponent * mxf_tc = NULL ; UID * essence_container_ul = NULL ; const MXFCodecUL * codec_ul = NULL ; const MXFCodecUL * container_ul = NULL ; const MXFCodecUL * pix_fmt_ul = NULL ; AVStream * st ; AVTimecode tc ; int flags ; if ( ! ( material_track = mxf_resolve_strong_ref ( mxf , & material_package -> tracks_refs [ i ] , Track ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>material<S2SV_blank>track<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; continue ; } if ( ( component = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , TimecodeComponent ) ) ) { mxf_tc = ( MXFTimecodeComponent * ) component ; flags = mxf_tc -> drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0 ; if ( av_timecode_init ( & tc , mxf_tc -> rate , flags , mxf_tc -> start_frame , mxf -> fc ) == 0 ) { mxf_add_timecode_metadata ( & mxf -> fc -> metadata , ""timecode"" , & tc ) ; } } if ( ! ( material_track -> sequence = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , Sequence ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>material<S2SV_blank>track<S2SV_blank>sequence<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; continue ; } for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { component = mxf_resolve_strong_ref ( mxf , & material_track -> sequence -> structural_components_refs [ j ] , TimecodeComponent ) ; if ( ! component ) continue ; mxf_tc = ( MXFTimecodeComponent * ) component ; flags = mxf_tc -> drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0 ; if ( av_timecode_init ( & tc , mxf_tc -> rate , flags , mxf_tc -> start_frame , mxf -> fc ) == 0 ) { mxf_add_timecode_metadata ( & mxf -> fc -> metadata , ""timecode"" , & tc ) ; break ; } } if ( material_track -> sequence -> structural_components_count > 1 ) av_log ( mxf -> fc , AV_LOG_WARNING , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>components\\n"" , material_track -> track_id , material_track -> sequence -> structural_components_count ) ; for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { component = mxf_resolve_sourceclip ( mxf , & material_track -> sequence -> structural_components_refs [ j ] ) ; if ( ! component ) continue ; source_package = mxf_resolve_source_package ( mxf , component -> source_package_ul , component -> source_package_uid ) ; if ( ! source_package ) { av_log ( mxf -> fc , AV_LOG_TRACE , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>source<S2SV_blank>package<S2SV_blank>found\\n"" , material_track -> track_id ) ; continue ; } for ( k = 0 ; k < source_package -> tracks_count ; k ++ ) { if ( ! ( temp_track = mxf_resolve_strong_ref ( mxf , & source_package -> tracks_refs [ k ] , Track ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>source<S2SV_blank>track<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail_and_free ; } if ( temp_track -> track_id == component -> source_track_id ) { source_track = temp_track ; break ; } } if ( ! source_track ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>source<S2SV_blank>track<S2SV_blank>found\\n"" , material_track -> track_id ) ; break ; } for ( k = 0 ; k < mxf -> essence_container_data_count ; k ++ ) { MXFEssenceContainerData * essence_data ; if ( ! ( essence_data = mxf_resolve_strong_ref ( mxf , & mxf -> essence_container_data_refs [ k ] , EssenceContainerData ) ) ) { <S2SV_StartBug> av_log ( mxf , AV_LOG_TRACE , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; <S2SV_EndBug> continue ; } if ( ! memcmp ( component -> source_package_ul , essence_data -> package_ul , sizeof ( UID ) ) && ! memcmp ( component -> source_package_uid , essence_data -> package_uid , sizeof ( UID ) ) ) { source_track -> body_sid = essence_data -> body_sid ; source_track -> index_sid = essence_data -> index_sid ; break ; } } if ( source_track && component ) break ; } if ( ! source_track || ! component || ! source_package ) { if ( ( ret = mxf_add_metadata_stream ( mxf , material_track ) ) ) goto fail_and_free ; continue ; } if ( ! ( source_track -> sequence = mxf_resolve_strong_ref ( mxf , & source_track -> sequence_ref , Sequence ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>source<S2SV_blank>track<S2SV_blank>sequence<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail_and_free ; } if ( memcmp ( material_track -> sequence -> data_definition_ul , source_track -> sequence -> data_definition_ul , 16 ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>DataDefinition<S2SV_blank>mismatch\\n"" , material_track -> track_id ) ; continue ; } st = avformat_new_stream ( mxf -> fc , NULL ) ; if ( ! st ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>stream\\n"" ) ; ret = AVERROR ( ENOMEM ) ; goto fail_and_free ; } st -> id = material_track -> track_id ; st -> priv_data = source_track ; source_package -> descriptor = mxf_resolve_strong_ref ( mxf , & source_package -> descriptor_ref , AnyType ) ; descriptor = mxf_resolve_multidescriptor ( mxf , source_package -> descriptor , source_track -> track_id ) ; if ( descriptor && descriptor -> duration != AV_NOPTS_VALUE ) source_track -> original_duration = st -> duration = FFMIN ( descriptor -> duration , component -> duration ) ; else source_track -> original_duration = st -> duration = component -> duration ; if ( st -> duration == - 1 ) st -> duration = AV_NOPTS_VALUE ; st -> start_time = component -> start_position ; if ( material_track -> edit_rate . num <= 0 || material_track -> edit_rate . den <= 0 ) { av_log ( mxf -> fc , AV_LOG_WARNING , ""Invalid<S2SV_blank>edit<S2SV_blank>rate<S2SV_blank>(%d/%d)<S2SV_blank>found<S2SV_blank>on<S2SV_blank>stream<S2SV_blank>#%d,<S2SV_blank>"" ""defaulting<S2SV_blank>to<S2SV_blank>25/1\\n"" , material_track -> edit_rate . num , material_track -> edit_rate . den , st -> index ) ; material_track -> edit_rate = ( AVRational ) { 25 , 1 } ; } avpriv_set_pts_info ( st , 64 , material_track -> edit_rate . den , material_track -> edit_rate . num ) ; source_track -> edit_rate = material_track -> edit_rate ; PRINT_KEY ( mxf -> fc , ""data<S2SV_blank>definition<S2SV_blank><S2SV_blank><S2SV_blank>ul"" , source_track -> sequence -> data_definition_ul ) ; codec_ul = mxf_get_codec_ul ( ff_mxf_data_definition_uls , & source_track -> sequence -> data_definition_ul ) ; st -> codecpar -> codec_type = codec_ul -> id ; if ( ! descriptor ) { av_log ( mxf -> fc , AV_LOG_INFO , ""source<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>stream<S2SV_blank>%d,<S2SV_blank>no<S2SV_blank>descriptor<S2SV_blank>found\\n"" , source_track -> track_id , st -> index ) ; continue ; } PRINT_KEY ( mxf -> fc , ""essence<S2SV_blank>codec<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ul"" , descriptor -> essence_codec_ul ) ; PRINT_KEY ( mxf -> fc , ""essence<S2SV_blank>container<S2SV_blank>ul"" , descriptor -> essence_container_ul ) ; essence_container_ul = & descriptor -> essence_container_ul ; source_track -> wrapping = ( mxf -> op == OPAtom ) ? ClipWrapped : mxf_get_wrapping_kind ( essence_container_ul ) ; if ( source_track -> wrapping == UnknownWrapped ) av_log ( mxf -> fc , AV_LOG_INFO , ""wrapping<S2SV_blank>of<S2SV_blank>stream<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>unknown\\n"" , st -> index ) ; if ( IS_KLV_KEY ( essence_container_ul , mxf_encrypted_essence_container ) ) { av_log ( mxf -> fc , AV_LOG_INFO , ""broken<S2SV_blank>encrypted<S2SV_blank>mxf<S2SV_blank>file\\n"" ) ; for ( k = 0 ; k < mxf -> metadata_sets_count ; k ++ ) { MXFMetadataSet * metadata = mxf -> metadata_sets [ k ] ; if ( metadata -> type == CryptoContext ) { essence_container_ul = & ( ( MXFCryptoContext * ) metadata ) -> source_container_ul ; break ; } } } codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptor -> essence_codec_ul ) ; st -> codecpar -> codec_id = ( enum AVCodecID ) codec_ul -> id ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) { codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptor -> codec_ul ) ; st -> codecpar -> codec_id = ( enum AVCodecID ) codec_ul -> id ; } av_log ( mxf -> fc , AV_LOG_VERBOSE , ""%s:<S2SV_blank>Universal<S2SV_blank>Label:<S2SV_blank>"" , avcodec_get_name ( st -> codecpar -> codec_id ) ) ; for ( k = 0 ; k < 16 ; k ++ ) { av_log ( mxf -> fc , AV_LOG_VERBOSE , ""%.2x"" , descriptor -> essence_codec_ul [ k ] ) ; if ( ! ( k + 1 & 19 ) || k == 5 ) av_log ( mxf -> fc , AV_LOG_VERBOSE , ""."" ) ; } av_log ( mxf -> fc , AV_LOG_VERBOSE , ""\\n"" ) ; mxf_add_umid_metadata ( & st -> metadata , ""file_package_umid"" , source_package ) ; if ( source_package -> name && source_package -> name [ 0 ] ) av_dict_set ( & st -> metadata , ""file_package_name"" , source_package -> name , 0 ) ; if ( material_track -> name && material_track -> name [ 0 ] ) av_dict_set ( & st -> metadata , ""track_name"" , material_track -> name , 0 ) ; mxf_parse_physical_source_package ( mxf , source_track , st ) ; if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { source_track -> intra_only = mxf_is_intra_only ( descriptor ) ; container_ul = mxf_get_codec_ul ( mxf_picture_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) st -> codecpar -> codec_id = container_ul -> id ; st -> codecpar -> width = descriptor -> width ; st -> codecpar -> height = descriptor -> height ; switch ( descriptor -> frame_layout ) { case FullFrame : st -> codecpar -> field_order = AV_FIELD_PROGRESSIVE ; break ; case OneField : av_log ( mxf -> fc , AV_LOG_INFO , ""OneField<S2SV_blank>frame<S2SV_blank>layout<S2SV_blank>isn\'t<S2SV_blank>currently<S2SV_blank>supported\\n"" ) ; break ; case MixedFields : break ; case SegmentedFrame : st -> codecpar -> field_order = AV_FIELD_PROGRESSIVE ; case SeparateFields : av_log ( mxf -> fc , AV_LOG_DEBUG , ""video_line_map:<S2SV_blank>(%d,<S2SV_blank>%d),<S2SV_blank>field_dominance:<S2SV_blank>%d\\n"" , descriptor -> video_line_map [ 0 ] , descriptor -> video_line_map [ 1 ] , descriptor -> field_dominance ) ; if ( ( descriptor -> video_line_map [ 0 ] > 0 ) && ( descriptor -> video_line_map [ 1 ] > 0 ) ) { if ( ( descriptor -> video_line_map [ 0 ] + descriptor -> video_line_map [ 1 ] ) % 2 ) { switch ( descriptor -> field_dominance ) { case MXF_FIELD_DOMINANCE_DEFAULT : case MXF_FIELD_DOMINANCE_FF : st -> codecpar -> field_order = AV_FIELD_TT ; break ; case MXF_FIELD_DOMINANCE_FL : st -> codecpar -> field_order = AV_FIELD_TB ; break ; default : avpriv_request_sample ( mxf -> fc , ""Field<S2SV_blank>dominance<S2SV_blank>%d<S2SV_blank>support"" , descriptor -> field_dominance ) ; } } else { switch ( descriptor -> field_dominance ) { case MXF_FIELD_DOMINANCE_DEFAULT : case MXF_FIELD_DOMINANCE_FF : st -> codecpar -> field_order = AV_FIELD_BB ; break ; case MXF_FIELD_DOMINANCE_FL : st -> codecpar -> field_order = AV_FIELD_BT ; break ; default : avpriv_request_sample ( mxf -> fc , ""Field<S2SV_blank>dominance<S2SV_blank>%d<S2SV_blank>support"" , descriptor -> field_dominance ) ; } } } st -> codecpar -> height *= 2 ; break ; default : av_log ( mxf -> fc , AV_LOG_INFO , ""Unknown<S2SV_blank>frame<S2SV_blank>layout<S2SV_blank>type:<S2SV_blank>%d\\n"" , descriptor -> frame_layout ) ; } if ( st -> codecpar -> codec_id == AV_CODEC_ID_RAWVIDEO ) { st -> codecpar -> format = descriptor -> pix_fmt ; if ( st -> codecpar -> format == AV_PIX_FMT_NONE ) { pix_fmt_ul = mxf_get_codec_ul ( ff_mxf_pixel_format_uls , & descriptor -> essence_codec_ul ) ; st -> codecpar -> format = ( enum AVPixelFormat ) pix_fmt_ul -> id ; if ( st -> codecpar -> format == AV_PIX_FMT_NONE ) { st -> codecpar -> codec_tag = mxf_get_codec_ul ( ff_mxf_codec_tag_uls , & descriptor -> essence_codec_ul ) -> id ; if ( ! st -> codecpar -> codec_tag ) { if ( descriptor -> horiz_subsampling == 2 && descriptor -> vert_subsampling == 1 && descriptor -> component_depth == 8 ) { st -> codecpar -> format = AV_PIX_FMT_UYVY422 ; } } } } } st -> need_parsing = AVSTREAM_PARSE_HEADERS ; if ( material_track -> sequence -> origin ) { av_dict_set_int ( & st -> metadata , ""material_track_origin"" , material_track -> sequence -> origin , 0 ) ; } if ( source_track -> sequence -> origin ) { av_dict_set_int ( & st -> metadata , ""source_track_origin"" , source_track -> sequence -> origin , 0 ) ; } if ( descriptor -> aspect_ratio . num && descriptor -> aspect_ratio . den ) st -> display_aspect_ratio = descriptor -> aspect_ratio ; } else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) { container_ul = mxf_get_codec_ul ( mxf_sound_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE || ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_ALAW && ( enum AVCodecID ) container_ul -> id != AV_CODEC_ID_NONE ) ) st -> codecpar -> codec_id = ( enum AVCodecID ) container_ul -> id ; st -> codecpar -> channels = descriptor -> channels ; st -> codecpar -> bits_per_coded_sample = descriptor -> bits_per_sample ; if ( descriptor -> sample_rate . den > 0 ) { st -> codecpar -> sample_rate = descriptor -> sample_rate . num / descriptor -> sample_rate . den ; avpriv_set_pts_info ( st , 64 , descriptor -> sample_rate . den , descriptor -> sample_rate . num ) ; } else { av_log ( mxf -> fc , AV_LOG_WARNING , ""invalid<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>(%d/%d)<S2SV_blank>"" ""found<S2SV_blank>for<S2SV_blank>stream<S2SV_blank>#%d,<S2SV_blank>time<S2SV_blank>base<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1/48000\\n"" , descriptor -> sample_rate . num , descriptor -> sample_rate . den , st -> index ) ; avpriv_set_pts_info ( st , 64 , 1 , 48000 ) ; } if ( st -> duration != AV_NOPTS_VALUE ) st -> duration = av_rescale_q ( st -> duration , av_inv_q ( material_track -> edit_rate ) , st -> time_base ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16LE ) { if ( descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S24LE ; else if ( descriptor -> bits_per_sample == 32 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S32LE ; } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16BE ) { if ( descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S24BE ; else if ( descriptor -> bits_per_sample == 32 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S32BE ; } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_MP2 ) { st -> need_parsing = AVSTREAM_PARSE_FULL ; } } else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA ) { enum AVMediaType type ; container_ul = mxf_get_codec_ul ( mxf_data_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) st -> codecpar -> codec_id = container_ul -> id ; type = avcodec_get_type ( st -> codecpar -> codec_id ) ; if ( type == AVMEDIA_TYPE_SUBTITLE ) st -> codecpar -> codec_type = type ; if ( container_ul -> desc ) av_dict_set ( & st -> metadata , ""data_type"" , container_ul -> desc , 0 ) ; } if ( descriptor -> extradata ) { if ( ! ff_alloc_extradata ( st -> codecpar , descriptor -> extradata_size ) ) { memcpy ( st -> codecpar -> extradata , descriptor -> extradata , descriptor -> extradata_size ) ; } } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_H264 ) { int coded_width = mxf_get_codec_ul ( mxf_intra_only_picture_coded_width , & descriptor -> essence_codec_ul ) -> id ; if ( coded_width ) st -> codecpar -> width = coded_width ; ret = ff_generate_avci_extradata ( st ) ; if ( ret < 0 ) return ret ; } if ( st -> codecpar -> codec_type != AVMEDIA_TYPE_DATA && source_track -> wrapping != FrameWrapped ) { st -> need_parsing = AVSTREAM_PARSE_TIMESTAMPS ; } } ret = 0 ; fail_and_free : return ret ; }
","<S2SV_ModStart> av_log ( mxf -> fc
"
77,"CWE-59 static int mount_entry_on_relative_rootfs ( struct mntent * mntent , const char * rootfs ) { char path [ MAXPATHLEN ] ; int ret ; ret = snprintf ( path , sizeof ( path ) , ""%s/%s"" , rootfs , mntent -> mnt_dir ) ; if ( ret >= sizeof ( path ) ) { ERROR ( ""path<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long"" ) ; return - 1 ; } <S2SV_StartBug> return mount_entry_on_generic ( mntent , path ) ; <S2SV_EndBug> }
","<S2SV_ModStart> mntent , path , rootfs
"
78,"CWE-119 int id3_skip ( SF_PRIVATE * psf ) { unsigned char buf [ 10 ] ; memset ( buf , 0 , sizeof ( buf ) ) ; psf_binheader_readf ( psf , ""pb"" , 0 , buf , 10 ) ; if ( buf [ 0 ] == 'I' && buf [ 1 ] == 'D' && buf [ 2 ] == '3' ) { int offset = buf [ 6 ] & 0x7f ; offset = ( offset << 7 ) | ( buf [ 7 ] & 0x7f ) ; offset = ( offset << 7 ) | ( buf [ 8 ] & 0x7f ) ; offset = ( offset << 7 ) | ( buf [ 9 ] & 0x7f ) ; psf_log_printf ( psf , ""ID3<S2SV_blank>length<S2SV_blank>:<S2SV_blank>%d\\n--------------------\\n"" , offset ) ; if ( offset < 0 ) return 0 ; psf -> fileoffset += offset + 10 ; <S2SV_StartBug> psf_binheader_readf ( psf , ""p"" , psf -> fileoffset ) ; <S2SV_EndBug> return 1 ; } ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> + 10 ; if ( psf -> fileoffset < psf -> filelength ) { <S2SV_ModStart> ; } ; } ;
"
79,"CWE-125 static int juniper_parse_header ( netdissect_options * ndo , const u_char * p , const struct pcap_pkthdr * h , struct juniper_l2info_t * l2info ) { const struct juniper_cookie_table_t * lp = juniper_cookie_table ; u_int idx , jnx_ext_len , jnx_header_len = 0 ; uint8_t tlv_type , tlv_len ; uint32_t control_word ; int tlv_value ; const u_char * tptr ; l2info -> header_len = 0 ; l2info -> cookie_len = 0 ; l2info -> proto = 0 ; l2info -> length = h -> len ; l2info -> caplen = h -> caplen ; ND_TCHECK2 ( p [ 0 ] , 4 ) ; l2info -> flags = p [ 3 ] ; l2info -> direction = p [ 3 ] & JUNIPER_BPF_PKT_IN ; if ( EXTRACT_24BITS ( p ) != JUNIPER_MGC_NUMBER ) { ND_PRINT ( ( ndo , ""no<S2SV_blank>magic-number<S2SV_blank>found!"" ) ) ; return 0 ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%3s<S2SV_blank>"" , tok2str ( juniper_direction_values , ""---"" , l2info -> direction ) ) ) ; jnx_header_len = 4 ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\tJuniper<S2SV_blank>PCAP<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( jnx_flag_values , ""none"" , l2info -> flags ) ) ) ; if ( ( l2info -> flags & JUNIPER_BPF_EXT ) == JUNIPER_BPF_EXT ) { tptr = p + jnx_header_len ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; jnx_ext_len = EXTRACT_16BITS ( tptr ) ; jnx_header_len += 2 ; tptr += 2 ; jnx_header_len += jnx_ext_len ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , "",<S2SV_blank>PCAP<S2SV_blank>Extension(s)<S2SV_blank>total<S2SV_blank>length<S2SV_blank>%u"" , jnx_ext_len ) ) ; ND_TCHECK2 ( tptr [ 0 ] , jnx_ext_len ) ; while ( jnx_ext_len > JUNIPER_EXT_TLV_OVERHEAD ) { tlv_type = * ( tptr ++ ) ; tlv_len = * ( tptr ++ ) ; tlv_value = 0 ; if ( tlv_type == 0 || tlv_len == 0 ) break ; if ( tlv_len + JUNIPER_EXT_TLV_OVERHEAD > jnx_ext_len ) goto trunc ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Extension<S2SV_blank>TLV<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>value<S2SV_blank>"" , tok2str ( jnx_ext_tlv_values , ""Unknown"" , tlv_type ) , tlv_type , tlv_len ) ) ; tlv_value = juniper_read_tlv_value ( tptr , tlv_type , tlv_len ) ; switch ( tlv_type ) { case JUNIPER_EXT_TLV_IFD_NAME : break ; case JUNIPER_EXT_TLV_IFD_MEDIATYPE : case JUNIPER_EXT_TLV_TTP_IFD_MEDIATYPE : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)"" , tok2str ( juniper_ifmt_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; } break ; case JUNIPER_EXT_TLV_IFL_ENCAPS : case JUNIPER_EXT_TLV_TTP_IFL_ENCAPS : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)"" , tok2str ( juniper_ifle_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; } break ; case JUNIPER_EXT_TLV_IFL_IDX : case JUNIPER_EXT_TLV_IFL_UNIT : case JUNIPER_EXT_TLV_IFD_IDX : default : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%u"" , tlv_value ) ) ; } break ; } tptr += tlv_len ; jnx_ext_len -= tlv_len + JUNIPER_EXT_TLV_OVERHEAD ; } if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t-----original<S2SV_blank>packet-----\\n\\t"" ) ) ; } if ( ( l2info -> flags & JUNIPER_BPF_NO_L2 ) == JUNIPER_BPF_NO_L2 ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""no-L2-hdr,<S2SV_blank>"" ) ) ; ND_TCHECK2 ( p [ jnx_header_len + 4 ] , 1 ) ; if ( ip_heuristic_guess ( ndo , p + jnx_header_len + 4 , l2info -> length - ( jnx_header_len + 4 ) ) == 0 ) ND_PRINT ( ( ndo , ""no<S2SV_blank>IP-hdr<S2SV_blank>found!"" ) ) ; l2info -> header_len = jnx_header_len + 4 ; return 0 ; } l2info -> header_len = jnx_header_len ; p += l2info -> header_len ; l2info -> length -= l2info -> header_len ; l2info -> caplen -= l2info -> header_len ; ND_TCHECK ( p [ 0 ] ) ; while ( lp -> s != NULL ) { if ( lp -> pictype == l2info -> pictype ) { l2info -> cookie_len += lp -> cookie_len ; switch ( p [ 0 ] ) { case LS_COOKIE_ID : l2info -> cookie_type = LS_COOKIE_ID ; l2info -> cookie_len += 2 ; break ; case AS_COOKIE_ID : l2info -> cookie_type = AS_COOKIE_ID ; l2info -> cookie_len = 8 ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } # ifdef DLT_JUNIPER_MFR if ( l2info -> pictype == DLT_JUNIPER_MFR && ( p [ 0 ] & MFR_BE_MASK ) == MFR_BE_MASK ) { l2info -> cookie_len = 0 ; } # endif l2info -> header_len += l2info -> cookie_len ; l2info -> length -= l2info -> cookie_len ; l2info -> caplen -= l2info -> cookie_len ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%s-PIC,<S2SV_blank>cookie-len<S2SV_blank>%u"" , lp -> s , l2info -> cookie_len ) ) ; if ( l2info -> cookie_len > 0 ) { ND_TCHECK2 ( p [ 0 ] , l2info -> cookie_len ) ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>cookie<S2SV_blank>0x"" ) ) ; for ( idx = 0 ; idx < l2info -> cookie_len ; idx ++ ) { l2info -> cookie [ idx ] = p [ idx ] ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%02x"" , p [ idx ] ) ) ; } } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; <S2SV_StartBug> l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ; <S2SV_EndBug> break ; } ++ lp ; } p += l2info -> cookie_len ; switch ( l2info -> pictype ) { # ifdef DLT_JUNIPER_MLPPP case DLT_JUNIPER_MLPPP : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : l2info -> bundle = l2info -> cookie [ 1 ] ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } break ; # endif # ifdef DLT_JUNIPER_MLFR case DLT_JUNIPER_MLFR : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ; l2info -> bundle = l2info -> cookie [ 1 ] ; l2info -> proto = EXTRACT_16BITS ( p ) ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; } break ; # endif # ifdef DLT_JUNIPER_MFR case DLT_JUNIPER_MFR : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ; l2info -> bundle = l2info -> cookie [ 1 ] ; l2info -> proto = EXTRACT_16BITS ( p ) ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } break ; # endif # ifdef DLT_JUNIPER_ATM2 case DLT_JUNIPER_ATM2 : ND_TCHECK2 ( p [ 0 ] , 4 ) ; if ( l2info -> cookie [ 7 ] & ATM2_PKT_TYPE_MASK ) { control_word = EXTRACT_32BITS ( p ) ; switch ( control_word ) { case 0 : case 0x08000000 : case 0x08380000 : l2info -> header_len += 4 ; break ; default : break ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""control-word<S2SV_blank>0x%08x<S2SV_blank>"" , control_word ) ) ; } break ; # endif # ifdef DLT_JUNIPER_GGSN case DLT_JUNIPER_GGSN : break ; # endif # ifdef DLT_JUNIPER_ATM1 case DLT_JUNIPER_ATM1 : break ; # endif # ifdef DLT_JUNIPER_PPP case DLT_JUNIPER_PPP : break ; # endif # ifdef DLT_JUNIPER_CHDLC case DLT_JUNIPER_CHDLC : break ; # endif # ifdef DLT_JUNIPER_ETHER case DLT_JUNIPER_ETHER : break ; # endif # ifdef DLT_JUNIPER_FRELAY case DLT_JUNIPER_FRELAY : break ; # endif default : ND_PRINT ( ( ndo , ""Unknown<S2SV_blank>Juniper<S2SV_blank>DLT_<S2SV_blank>type<S2SV_blank>%u:<S2SV_blank>"" , l2info -> pictype ) ) ; break ; } if ( ndo -> ndo_eflag > 1 ) ND_PRINT ( ( ndo , ""hlen<S2SV_blank>%u,<S2SV_blank>proto<S2SV_blank>0x%04x,<S2SV_blank>"" , l2info -> header_len , l2info -> proto ) ) ; return 1 ; trunc : ND_PRINT ( ( ndo , ""[|juniper_hdr],<S2SV_blank>length<S2SV_blank>%u"" , h -> len ) ) ; return 0 ; }
","<S2SV_ModStart> ) ) ; ND_TCHECK_16BITS ( p + l2info -> cookie_len ) ;
"
80,"CWE-787 static unsigned int ipv6_defrag ( void * priv , struct sk_buff * skb , const struct nf_hook_state * state ) { int err ; # if IS_ENABLED ( CONFIG_NF_CONNTRACK ) if ( skb -> nfct && ! nf_ct_is_template ( ( struct nf_conn * ) skb -> nfct ) ) return NF_ACCEPT ; # endif err = nf_ct_frag6_gather ( state -> net , skb , nf_ct6_defrag_user ( state -> hook , skb ) ) ; if ( err == - EINPROGRESS ) return NF_STOLEN ; <S2SV_StartBug> return NF_ACCEPT ; <S2SV_EndBug> }
","<S2SV_ModStart> NF_STOLEN ; return err == 0 ? NF_ACCEPT : NF_DROP <S2SV_ModEnd> ; } <S2SV_null>
"
81,"CWE-200 static int xfrm_alloc_replay_state_esn ( struct xfrm_replay_state_esn * * replay_esn , struct xfrm_replay_state_esn * * preplay_esn , struct nlattr * rta ) { struct xfrm_replay_state_esn * p , * pp , * up ; <S2SV_StartBug> if ( ! rta ) <S2SV_EndBug> return 0 ; up = nla_data ( rta ) ; <S2SV_StartBug> p = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! p ) return - ENOMEM ; <S2SV_StartBug> pp = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! pp ) { kfree ( p ) ; return - ENOMEM ; } <S2SV_StartBug> * replay_esn = p ; <S2SV_EndBug> * preplay_esn = pp ; return 0 ; }
","<S2SV_ModStart> * up ; int klen , ulen ; <S2SV_ModStart> rta ) ; klen = <S2SV_ModEnd> xfrm_replay_state_esn_len ( up <S2SV_ModStart> ( up ) ; ulen = nla_len ( rta ) >= klen ? klen : sizeof ( * up ) ; p = kzalloc ( klen <S2SV_ModStart> ; pp = kzalloc ( klen <S2SV_ModEnd> , GFP_KERNEL ) <S2SV_ModStart> ENOMEM ; } memcpy ( p , up , ulen ) ; memcpy ( pp , up , ulen ) ;
"
82,"CWE-416 int ipmi_si_mem_setup ( struct si_sm_io * io ) { unsigned long addr = io -> addr_data ; int mapsize , idx ; if ( ! addr ) return - ENODEV ; <S2SV_StartBug> io -> io_cleanup = mem_cleanup ; <S2SV_EndBug> switch ( io -> regsize ) { case 1 : io -> inputb = intf_mem_inb ; io -> outputb = intf_mem_outb ; break ; case 2 : io -> inputb = intf_mem_inw ; io -> outputb = intf_mem_outw ; break ; case 4 : io -> inputb = intf_mem_inl ; io -> outputb = intf_mem_outl ; break ; # ifdef readq case 8 : io -> inputb = mem_inq ; io -> outputb = mem_outq ; break ; # endif default : dev_warn ( io -> dev , ""Invalid<S2SV_blank>register<S2SV_blank>size:<S2SV_blank>%d\\n"" , io -> regsize ) ; return - EINVAL ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_mem_region ( addr + idx * io -> regspacing , io -> regsize , DEVICE_NAME ) == NULL ) { mem_region_cleanup ( io , idx ) ; return - EIO ; } } mapsize = ( ( io -> io_size * io -> regspacing ) - ( io -> regspacing - io -> regsize ) ) ; io -> addr = ioremap ( addr , mapsize ) ; if ( io -> addr == NULL ) { mem_region_cleanup ( io , io -> io_size ) ; return - EIO ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> - ENODEV ; <S2SV_ModEnd> switch ( io <S2SV_ModStart> EIO ; } io -> io_cleanup = mem_cleanup ;
"
83,"CWE-190 static MagickRealType ApplyEvaluateOperator ( RandomInfo * random_info , const Quantum pixel , const MagickEvaluateOperator op , const MagickRealType value ) { MagickRealType result ; result = 0.0 ; switch ( op ) { case UndefinedEvaluateOperator : break ; case AbsEvaluateOperator : { result = ( MagickRealType ) fabs ( ( double ) ( pixel + value ) ) ; break ; } case AddEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case AddModulusEvaluateOperator : { result = pixel + value ; result -= ( QuantumRange + 1.0 ) * floor ( ( double ) result / ( QuantumRange + 1.0 ) ) ; break ; } case AndEvaluateOperator : { <S2SV_StartBug> result = ( MagickRealType ) ( ( size_t ) pixel & ( size_t ) ( value + 0.5 ) ) ; <S2SV_EndBug> break ; } case CosineEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * ( 0.5 * cos ( ( double ) ( 2.0 * MagickPI * QuantumScale * pixel * value ) ) + 0.5 ) ) ; break ; } case DivideEvaluateOperator : { result = pixel / ( value == 0.0 ? 1.0 : value ) ; break ; } case ExponentialEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * exp ( ( double ) ( value * QuantumScale * pixel ) ) ) ; break ; } case GaussianNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , GaussianNoise , value ) ; break ; } case ImpulseNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , ImpulseNoise , value ) ; break ; } case LaplacianNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , LaplacianNoise , value ) ; break ; } case LeftShiftEvaluateOperator : { <S2SV_StartBug> result = ( MagickRealType ) ( ( size_t ) pixel << ( size_t ) ( value + 0.5 ) ) ; <S2SV_EndBug> break ; } case LogEvaluateOperator : { if ( ( QuantumScale * pixel ) >= MagickEpsilon ) result = ( MagickRealType ) ( QuantumRange * log ( ( double ) ( QuantumScale * value * pixel + 1.0 ) ) / log ( ( double ) ( value + 1.0 ) ) ) ; break ; } case MaxEvaluateOperator : { result = ( MagickRealType ) EvaluateMax ( ( double ) pixel , value ) ; break ; } case MeanEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case MedianEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case MinEvaluateOperator : { result = ( MagickRealType ) MagickMin ( ( double ) pixel , value ) ; break ; } case MultiplicativeNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , MultiplicativeGaussianNoise , value ) ; break ; } case MultiplyEvaluateOperator : { result = ( MagickRealType ) ( value * pixel ) ; break ; } case OrEvaluateOperator : { <S2SV_StartBug> result = ( MagickRealType ) ( ( size_t ) pixel | ( size_t ) ( value + 0.5 ) ) ; <S2SV_EndBug> break ; } case PoissonNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , PoissonNoise , value ) ; break ; } case PowEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * pow ( ( double ) ( QuantumScale * pixel ) , ( double ) value ) ) ; break ; } case RightShiftEvaluateOperator : { <S2SV_StartBug> result = ( MagickRealType ) ( ( size_t ) pixel >> ( size_t ) ( value + 0.5 ) ) ; <S2SV_EndBug> break ; } case RootMeanSquareEvaluateOperator : { result = ( MagickRealType ) ( pixel * pixel + value ) ; break ; } case SetEvaluateOperator : { result = value ; break ; } case SineEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * ( 0.5 * sin ( ( double ) ( 2.0 * MagickPI * QuantumScale * pixel * value ) ) + 0.5 ) ) ; break ; } case SubtractEvaluateOperator : { result = ( MagickRealType ) ( pixel - value ) ; break ; } case SumEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case ThresholdEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel <= value ) ? 0 : QuantumRange ) ; break ; } case ThresholdBlackEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel <= value ) ? 0 : pixel ) ; break ; } case ThresholdWhiteEvaluateOperator : { result = ( MagickRealType ) ( ( ( MagickRealType ) pixel > value ) ? QuantumRange : pixel ) ; break ; } case UniformNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , UniformNoise , value ) ; break ; } case XorEvaluateOperator : { <S2SV_StartBug> result = ( MagickRealType ) ( ( size_t ) pixel ^ ( size_t ) ( value + 0.5 ) ) ; <S2SV_EndBug> break ; } } return ( result ) ; }
","<S2SV_ModStart> ) ( ( ssize_t <S2SV_ModEnd> ) pixel & <S2SV_ModStart> pixel & ( ssize_t <S2SV_ModEnd> ) ( value <S2SV_ModStart> ) ( ( ssize_t <S2SV_ModEnd> ) pixel << <S2SV_ModStart> pixel << ( ssize_t <S2SV_ModEnd> ) ( value <S2SV_ModStart> ) ( ( ssize_t <S2SV_ModEnd> ) pixel | <S2SV_ModStart> pixel | ( ssize_t <S2SV_ModEnd> ) ( value <S2SV_ModStart> ) ( ( ssize_t <S2SV_ModEnd> ) pixel >> <S2SV_ModStart> pixel >> ( ssize_t <S2SV_ModEnd> ) ( value <S2SV_ModStart> ) ( ( ssize_t <S2SV_ModEnd> ) pixel ^ <S2SV_ModStart> pixel ^ ( ssize_t <S2SV_ModEnd> ) ( value
"
84,"CWE-20 bt_status_t btif_storage_add_bonded_device ( bt_bdaddr_t * remote_bd_addr , LINK_KEY link_key , uint8_t key_type , uint8_t pin_length ) { bdstr_t bdstr ; bdaddr_to_string ( remote_bd_addr , bdstr , sizeof ( bdstr ) ) ; int ret = btif_config_set_int ( bdstr , ""LinkKeyType"" , ( int ) key_type ) ; ret &= btif_config_set_int ( bdstr , ""PinLength"" , ( int ) pin_length ) ; ret &= btif_config_set_bin ( bdstr , ""LinkKey"" , link_key , sizeof ( LINK_KEY ) ) ; <S2SV_StartBug> btif_config_flush ( ) ; <S2SV_EndBug> return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL ; }
","<S2SV_ModStart> ) ) ; if ( is_restricted_mode ( ) ) { BTIF_TRACE_WARNING ( ""%s:<S2SV_blank>\'%s\'<S2SV_blank>pairing<S2SV_blank>will<S2SV_blank>be<S2SV_blank>removed<S2SV_blank>if<S2SV_blank>unrestricted"" , __func__ , bdstr ) ; btif_config_set_int ( bdstr , ""Restricted"" , 1 ) ; }
"
85,"CWE-119 void jpc_qmfb_split_colres ( jpc_fix_t * a , int numrows , int numcols , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = splitbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int m ; int hstartcol ; if ( bufsize > QMFB_SPLITBUFSIZE ) { <S2SV_StartBug> if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { <S2SV_EndBug> abort ( ) ; } } if ( numrows >= 2 ) { hstartcol = ( numrows + 1 - parity ) >> 1 ; m = numrows - hstartcol ; n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < numcols ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += numcols ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < numcols ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += stride << 1 ; } dstptr = & a [ hstartcol * stride ] ; srcptr = buf ; n = m ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < numcols ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += numcols ; } } if ( buf != splitbuf ) { jas_free ( buf ) ; } }
","<S2SV_ModStart> ( buf = jas_alloc3 ( bufsize , numcols <S2SV_ModEnd> , sizeof (
"
86,"CWE-119 vpx_codec_err_t vpx_codec_enc_config_default ( vpx_codec_iface_t * iface , vpx_codec_enc_cfg_t * cfg , unsigned int usage ) { vpx_codec_err_t res ; <S2SV_StartBug> vpx_codec_enc_cfg_map_t * map ; <S2SV_EndBug> if ( ! iface || ! cfg || usage > INT_MAX ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; else { res = VPX_CODEC_INVALID_PARAM ; <S2SV_StartBug> for ( map = iface -> enc . cfg_maps ; map -> usage >= 0 ; map ++ ) { <S2SV_EndBug> if ( map -> usage == ( int ) usage ) { * cfg = map -> cfg ; cfg -> g_usage = usage ; res = VPX_CODEC_OK ; break ; } } } return res ; }
","<S2SV_ModStart> vpx_codec_enc_cfg_map_t * map ; int i <S2SV_ModStart> ; for ( i = 0 ; i < iface -> enc . cfg_map_count ; ++ i ) { <S2SV_ModStart> enc . cfg_maps + i ; <S2SV_ModEnd> if ( map
"
87,"CWE-20 static int netbk_set_skb_gso ( struct xenvif * vif , struct sk_buff * skb , struct xen_netif_extra_info * gso ) { if ( ! gso -> u . gso . size ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , ""GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\n"" ) ; <S2SV_EndBug> return - EINVAL ; } if ( gso -> u . gso . type != XEN_NETIF_GSO_TYPE_TCPV4 ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\n"" , gso -> u . gso . type ) ; <S2SV_EndBug> return - EINVAL ; } skb_shinfo ( skb ) -> gso_size = gso -> u . gso . size ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_TCPV4 ; skb_shinfo ( skb ) -> gso_type |= SKB_GSO_DODGY ; skb_shinfo ( skb ) -> gso_segs = 0 ; return 0 ; }
","<S2SV_ModStart> size ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev , ""GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> XEN_NETIF_GSO_TYPE_TCPV4 ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> gso . type ) ; netbk_fatal_tx_err ( vif
"
88,"CWE-119 <S2SV_StartBug> static void show_object ( struct object * object , struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , void * data ) <S2SV_EndBug> { struct bitmap * base = data ; int bitmap_pos ; bitmap_pos = bitmap_position ( object -> oid . hash ) ; <S2SV_StartBug> if ( bitmap_pos < 0 ) { <S2SV_EndBug> char * name = path_name ( path , last ) ; bitmap_pos = ext_index_add_object ( object , name ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> } bitmap_set ( base , bitmap_pos ) ; }
","<S2SV_ModStart> * object , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name <S2SV_ModEnd> , void * <S2SV_ModStart> < 0 ) <S2SV_ModEnd> bitmap_pos = ext_index_add_object <S2SV_ModStart> name ) ; <S2SV_ModEnd> bitmap_set ( base
"
89,"CWE-77 int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n***<S2SV_blank>pulse<S2SV_blank>DTR<S2SV_blank>***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""***<S2SV_blank>FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n***<S2SV_blank>DTR:<S2SV_blank>%s<S2SV_blank>***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n***<S2SV_blank>baud:<S2SV_blank>%d<S2SV_blank>(%d)<S2SV_blank>***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf ( STO , ""\\r\\n***<S2SV_blank>baud:<S2SV_blank>%d<S2SV_blank>***\\r\\n"" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , ""\\r\\n***<S2SV_blank>flow:<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>***\\r\\n"" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , ""\\r\\n***<S2SV_blank>flow:<S2SV_blank>%s<S2SV_blank>***\\r\\n"" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , ""\\r\\n***<S2SV_blank>parity:<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>***\\r\\n"" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , ""\\r\\n***<S2SV_blank>parity:<S2SV_blank>%s<S2SV_blank>***\\r\\n"" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , ""\\r\\n***<S2SV_blank>databits:<S2SV_blank>%d<S2SV_blank>(%d)<S2SV_blank>***\\r\\n"" , opts . databits , newbits ) ; } else { fd_printf ( STO , ""\\r\\n***<S2SV_blank>databits:<S2SV_blank>%d<S2SV_blank>***\\r\\n"" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , ""\\r\\n***<S2SV_blank>local<S2SV_blank>echo:<S2SV_blank>%s<S2SV_blank>***\\r\\n"" , opts . lecho ? ""yes"" : ""no"" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , ""\\r\\n***<S2SV_blank>command<S2SV_blank>disabled<S2SV_blank>***\\r\\n"" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , ""***<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>filename<S2SV_blank>***\\r\\n"" ) ; break ; } <S2SV_StartBug> run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; <S2SV_EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , ""\\r\\n***<S2SV_blank>break<S2SV_blank>sent<S2SV_blank>***\\r\\n"" ) ; break ; default : break ; } return 0 ; }
","<S2SV_ModStart> xfr_cmd , fname <S2SV_ModEnd> ) ; free
"
90,"CWE-416 static void snd_usb_mixer_free ( struct usb_mixer_interface * mixer ) <S2SV_StartBug> { <S2SV_EndBug> kfree ( mixer -> id_elems ) ; if ( mixer -> urb ) { kfree ( mixer -> urb -> transfer_buffer ) ; usb_free_urb ( mixer -> urb ) ; } usb_free_urb ( mixer -> rc_urb ) ; kfree ( mixer -> rc_setup_packet ) ; kfree ( mixer ) ; }
","<S2SV_ModStart> mixer ) { snd_usb_mixer_disconnect ( mixer ) ;
"
91,"CWE-416 static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <S2SV_StartBug> struct packet_sock * po = pkt_sk ( sk ) ; <S2SV_EndBug> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <S2SV_StartBug> if ( ! po -> running ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> if ( po -> fanout ) <S2SV_StartBug> return - EALREADY ; <S2SV_EndBug> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <S2SV_StartBug> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! po -> rollover ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; atomic_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; dev_add_pack ( & match -> prot_hook ) ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; atomic_inc ( & match -> sk_ref ) ; __fanout_link ( sk , po ) ; err = 0 ; } } out : <S2SV_StartBug> mutex_unlock ( & fanout_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> if ( err ) { <S2SV_EndBug> kfree ( po -> rollover ) ; po -> rollover = NULL ; } return err ; }
","<S2SV_ModStart> ) { struct packet_rollover * rollover = NULL ; struct <S2SV_ModStart> EINVAL ; } mutex_lock ( & fanout_mutex ) ; err = - EINVAL ; <S2SV_ModStart> -> running ) goto out ; err = - EALREADY <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> fanout ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { err = - ENOMEM ; <S2SV_ModEnd> rollover = kzalloc <S2SV_ModStart> sizeof ( * <S2SV_ModEnd> rollover ) , <S2SV_ModStart> if ( ! rollover ) goto out <S2SV_ModEnd> ; atomic_long_set ( <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_huge <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_failed <S2SV_ModStart> 0 ) ; po -> rollover = rollover ; } <S2SV_ModEnd> match = NULL <S2SV_ModStart> } out : if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } <S2SV_ModStart> fanout_mutex ) ; <S2SV_ModEnd> return err ;
"
92,"CWE-000 static struct sock * sctp_v6_create_accept_sk ( struct sock * sk , struct sctp_association * asoc , bool kern ) { struct sock * newsk ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct sctp6_sock * newsctp6sk ; struct ipv6_txoptions * opt ; newsk = sk_alloc ( sock_net ( sk ) , PF_INET6 , GFP_KERNEL , sk -> sk_prot , kern ) ; if ( ! newsk ) goto out ; sock_init_data ( NULL , newsk ) ; sctp_copy_sock ( newsk , sk , asoc ) ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; newsctp6sk = ( struct sctp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newsctp6sk -> inet6 ; sctp_sk ( newsk ) -> v4mapped = sctp_sk ( sk ) -> v4mapped ; newnp = inet6_sk ( newsk ) ; <S2SV_StartBug> memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; <S2SV_EndBug> rcu_read_lock ( ) ; opt = rcu_dereference ( np -> opt ) ; if ( opt ) opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; rcu_read_unlock ( ) ; sctp_v6_to_sk_daddr ( & asoc -> peer . primary_addr , newsk ) ; newsk -> sk_v6_rcv_saddr = sk -> sk_v6_rcv_saddr ; sk_refcnt_debug_inc ( newsk ) ; if ( newsk -> sk_prot -> init ( newsk ) ) { sk_common_release ( newsk ) ; newsk = NULL ; } out : return newsk ; }
","<S2SV_ModStart> ipv6_pinfo ) ) ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL
"
93,"CWE-401 static struct scatterlist * alloc_sgtable ( int size ) { int alloc_size , nents , i ; struct page * new_page ; struct scatterlist * iter ; struct scatterlist * table ; nents = DIV_ROUND_UP ( size , PAGE_SIZE ) ; table = kcalloc ( nents , sizeof ( * table ) , GFP_KERNEL ) ; if ( ! table ) return NULL ; sg_init_table ( table , nents ) ; iter = table ; for_each_sg ( table , iter , sg_nents ( table ) , i ) { new_page = alloc_page ( GFP_KERNEL ) ; if ( ! new_page ) { iter = table ; for_each_sg ( table , iter , sg_nents ( table ) , i ) { new_page = sg_page ( iter ) ; if ( new_page ) __free_page ( new_page ) ; } <S2SV_StartBug> return NULL ; <S2SV_EndBug> } alloc_size = min_t ( int , size , PAGE_SIZE ) ; size -= PAGE_SIZE ; sg_set_page ( iter , new_page , alloc_size , 0 ) ; } return table ; }
","<S2SV_ModStart> ) ; } kfree ( table ) ;
"
94,"CWE-119 <S2SV_StartBug> void show_progress ( int frame_in , int frame_out , uint64_t dx_time ) { <S2SV_EndBug> fprintf ( stderr , ""%d<S2SV_blank>decoded<S2SV_blank>frames/%d<S2SV_blank>showed<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>%"" PRId64 ""<S2SV_blank>us<S2SV_blank>(%.2f<S2SV_blank>fps)\\r"" , frame_in , frame_out , dx_time , ( double ) frame_out * 1000000.0 / ( double ) dx_time ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
"
95,"CWE-416 AV * dbd_st_fetch ( SV * sth , imp_sth_t * imp_sth ) { dTHX ; int num_fields , ChopBlanks , i , rc ; unsigned long * lengths ; AV * av ; int av_length , av_readonly ; MYSQL_ROW cols ; D_imp_dbh_from_sth ; MYSQL * svsock = imp_dbh -> pmysql ; imp_sth_fbh_t * fbh ; D_imp_xxh ( sth ) ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION MYSQL_BIND * buffer ; # endif MYSQL_FIELD * fields ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t-><S2SV_blank>dbd_st_fetch\\n"" ) ; # if MYSQL_ASYNC if ( imp_dbh -> async_query_in_flight ) { if ( mysql_db_async_result ( sth , & imp_sth -> result ) <= 0 ) { return Nullav ; } } # endif # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( imp_sth -> use_server_side_prepare ) { if ( ! DBIc_ACTIVE ( imp_sth ) ) { do_error ( sth , JW_ERR_SEQUENCE , ""no<S2SV_blank>statement<S2SV_blank>executing\\n"" , NULL ) ; return Nullav ; } if ( imp_sth -> fetch_done ) { do_error ( sth , JW_ERR_SEQUENCE , ""fetch()<S2SV_blank>but<S2SV_blank>fetch<S2SV_blank>already<S2SV_blank>done"" , NULL ) ; return Nullav ; } if ( ! imp_sth -> done_desc ) { if ( ! dbd_describe ( sth , imp_sth ) ) { do_error ( sth , JW_ERR_SEQUENCE , ""Error<S2SV_blank>while<S2SV_blank>describe<S2SV_blank>result<S2SV_blank>set."" , NULL ) ; return Nullav ; } } } # endif ChopBlanks = DBIc_is ( imp_sth , DBIcf_ChopBlanks ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tdbd_st_fetch<S2SV_blank>for<S2SV_blank>%p,<S2SV_blank>chopblanks<S2SV_blank>%d\\n"" , sth , ChopBlanks ) ; if ( ! imp_sth -> result ) { do_error ( sth , JW_ERR_SEQUENCE , ""fetch()<S2SV_blank>without<S2SV_blank>execute()"" , NULL ) ; return Nullav ; } imp_dbh -> pmysql -> net . last_errno = 0 ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( imp_sth -> use_server_side_prepare ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tdbd_st_fetch<S2SV_blank>calling<S2SV_blank>mysql_fetch\\n"" ) ; if ( ( rc = mysql_stmt_fetch ( imp_sth -> stmt ) ) ) { if ( rc == 1 ) do_error ( sth , mysql_stmt_errno ( imp_sth -> stmt ) , mysql_stmt_error ( imp_sth -> stmt ) , mysql_stmt_sqlstate ( imp_sth -> stmt ) ) ; # if MYSQL_VERSION_ID >= MYSQL_VERSION_5_0 if ( rc == MYSQL_DATA_TRUNCATED ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tdbd_st_fetch<S2SV_blank>data<S2SV_blank>truncated\\n"" ) ; goto process ; } # endif if ( rc == MYSQL_NO_DATA ) { imp_sth -> row_num = mysql_stmt_affected_rows ( imp_sth -> stmt ) ; imp_sth -> fetch_done = 1 ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tdbd_st_fetch<S2SV_blank>no<S2SV_blank>data\\n"" ) ; } dbd_st_finish ( sth , imp_sth ) ; return Nullav ; } process : imp_sth -> currow ++ ; av = DBIc_DBISTATE ( imp_sth ) -> get_fbav ( imp_sth ) ; num_fields = mysql_stmt_field_count ( imp_sth -> stmt ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tdbd_st_fetch<S2SV_blank>called<S2SV_blank>mysql_fetch,<S2SV_blank>rc<S2SV_blank>%d<S2SV_blank>num_fields<S2SV_blank>%d\\n"" , rc , num_fields ) ; for ( buffer = imp_sth -> buffer , fbh = imp_sth -> fbh , i = 0 ; i < num_fields ; i ++ , fbh ++ , buffer ++ ) { SV * sv = AvARRAY ( av ) [ i ] ; STRLEN len ; if ( fbh -> is_null ) ( void ) SvOK_off ( sv ) ; else { if ( fbh -> length > buffer -> buffer_length || fbh -> error ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tRefetch<S2SV_blank>BLOB/TEXT<S2SV_blank>column:<S2SV_blank>%d,<S2SV_blank>length:<S2SV_blank>%lu,<S2SV_blank>error:<S2SV_blank>%d\\n"" , i , fbh -> length , fbh -> error ) ; Renew ( fbh -> data , fbh -> length , char ) ; buffer -> buffer_length = fbh -> length ; <S2SV_StartBug> buffer -> buffer = ( char * ) fbh -> data ; <S2SV_EndBug> if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) { int j ; int m = MIN ( * buffer -> length , buffer -> buffer_length ) ; char * ptr = ( char * ) buffer -> buffer ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tbefore<S2SV_blank>buffer->buffer:<S2SV_blank>"" ) ; for ( j = 0 ; j < m ; j ++ ) { PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""%c"" , * ptr ++ ) ; } PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\n"" ) ; } if ( mysql_stmt_fetch_column ( imp_sth -> stmt , buffer , i , 0 ) ) do_error ( sth , mysql_stmt_errno ( imp_sth -> stmt ) , mysql_stmt_error ( imp_sth -> stmt ) , mysql_stmt_sqlstate ( imp_sth -> stmt ) ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) { int j ; int m = MIN ( * buffer -> length , buffer -> buffer_length ) ; char * ptr = ( char * ) buffer -> buffer ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tafter<S2SV_blank>buffer->buffer:<S2SV_blank>"" ) ; for ( j = 0 ; j < m ; j ++ ) { PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""%c"" , * ptr ++ ) ; } PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\n"" ) ; } } switch ( buffer -> buffer_type ) { case MYSQL_TYPE_DOUBLE : if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tst_fetch<S2SV_blank>double<S2SV_blank>data<S2SV_blank>%f\\n"" , fbh -> ddata ) ; sv_setnv ( sv , fbh -> ddata ) ; break ; case MYSQL_TYPE_LONG : case MYSQL_TYPE_LONGLONG : if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tst_fetch<S2SV_blank>int<S2SV_blank>data<S2SV_blank>%"" IVdf "",<S2SV_blank>unsigned?<S2SV_blank>%d\\n"" , fbh -> ldata , buffer -> is_unsigned ) ; if ( buffer -> is_unsigned ) sv_setuv ( sv , fbh -> ldata ) ; else sv_setiv ( sv , fbh -> ldata ) ; break ; case MYSQL_TYPE_BIT : sv_setpvn ( sv , fbh -> data , fbh -> length ) ; break ; default : if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t\\tERROR<S2SV_blank>IN<S2SV_blank>st_fetch_string"" ) ; len = fbh -> length ; if ( ChopBlanks ) { if ( fbh -> charsetnr != 63 ) while ( len && fbh -> data [ len - 1 ] == '<S2SV_blank>' ) { -- len ; } } sv_setpvn ( sv , fbh -> data , len ) ; # if defined ( sv_utf8_decode ) && MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION # if MYSQL_VERSION_ID >= FIELD_CHARSETNR_VERSION if ( ( imp_dbh -> enable_utf8 || imp_dbh -> enable_utf8mb4 ) && fbh -> charsetnr != 63 ) # else if ( ( imp_dbh -> enable_utf8 || imp_dbh -> enable_utf8mb4 ) && ! ( fbh -> flags & BINARY_FLAG ) ) # endif sv_utf8_decode ( sv ) ; # endif break ; } } } if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t<-<S2SV_blank>dbd_st_fetch,<S2SV_blank>%d<S2SV_blank>cols\\n"" , num_fields ) ; return av ; } else { # endif imp_sth -> currow ++ ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) { PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tdbd_st_fetch<S2SV_blank>result<S2SV_blank>set<S2SV_blank>details\\n"" ) ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\timp_sth->result=%p\\n"" , imp_sth -> result ) ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tmysql_num_fields=%u\\n"" , mysql_num_fields ( imp_sth -> result ) ) ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tmysql_num_rows=%llu\\n"" , mysql_num_rows ( imp_sth -> result ) ) ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tmysql_affected_rows=%llu\\n"" , mysql_affected_rows ( imp_dbh -> pmysql ) ) ; PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tdbd_st_fetch<S2SV_blank>for<S2SV_blank>%p,<S2SV_blank>currow=<S2SV_blank>%d\\n"" , sth , imp_sth -> currow ) ; } if ( ! ( cols = mysql_fetch_row ( imp_sth -> result ) ) ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) { PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\tdbd_st_fetch,<S2SV_blank>no<S2SV_blank>more<S2SV_blank>rows<S2SV_blank>to<S2SV_blank>fetch"" ) ; } if ( mysql_errno ( imp_dbh -> pmysql ) ) do_error ( sth , mysql_errno ( imp_dbh -> pmysql ) , mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; # if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION if ( ! mysql_more_results ( svsock ) ) # endif dbd_st_finish ( sth , imp_sth ) ; return Nullav ; } num_fields = mysql_num_fields ( imp_sth -> result ) ; fields = mysql_fetch_fields ( imp_sth -> result ) ; lengths = mysql_fetch_lengths ( imp_sth -> result ) ; if ( ( av = DBIc_FIELDS_AV ( imp_sth ) ) != Nullav ) { av_length = av_len ( av ) + 1 ; if ( av_length != num_fields ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t<-<S2SV_blank>dbd_st_fetch,<S2SV_blank>size<S2SV_blank>of<S2SV_blank>results<S2SV_blank>array(%d)<S2SV_blank>!=<S2SV_blank>num_fields(%d)\\n"" , av_length , num_fields ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t<-<S2SV_blank>dbd_st_fetch,<S2SV_blank>result<S2SV_blank>fields(%d)\\n"" , DBIc_NUM_FIELDS ( imp_sth ) ) ; av_readonly = SvREADONLY ( av ) ; if ( av_readonly ) SvREADONLY_off ( av ) ; while ( av_length < num_fields ) { av_store ( av , av_length ++ , newSV ( 0 ) ) ; } while ( av_length > num_fields ) { SvREFCNT_dec ( av_pop ( av ) ) ; av_length -- ; } if ( av_readonly ) SvREADONLY_on ( av ) ; } } av = DBIc_DBISTATE ( imp_sth ) -> get_fbav ( imp_sth ) ; for ( i = 0 ; i < num_fields ; ++ i ) { char * col = cols [ i ] ; SV * sv = AvARRAY ( av ) [ i ] ; if ( col ) { STRLEN len = lengths [ i ] ; if ( ChopBlanks ) { while ( len && col [ len - 1 ] == '<S2SV_blank>' ) { -- len ; } } sv_setpvn ( sv , col , len ) ; switch ( mysql_to_perl_type ( fields [ i ] . type ) ) { case MYSQL_TYPE_DOUBLE : ( void ) SvNV ( sv ) ; SvNOK_only ( sv ) ; break ; case MYSQL_TYPE_LONG : case MYSQL_TYPE_LONGLONG : if ( fields [ i ] . flags & UNSIGNED_FLAG ) { ( void ) SvUV ( sv ) ; SvIOK_only_UV ( sv ) ; } else { ( void ) SvIV ( sv ) ; SvIOK_only ( sv ) ; } break ; # if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION case MYSQL_TYPE_BIT : break ; # endif default : # if defined ( sv_utf8_decode ) && MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( ( imp_dbh -> enable_utf8 || imp_dbh -> enable_utf8mb4 ) && fields [ i ] . charsetnr != 63 ) sv_utf8_decode ( sv ) ; # endif break ; } } else ( void ) SvOK_off ( sv ) ; } if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t<-<S2SV_blank>dbd_st_fetch,<S2SV_blank>%d<S2SV_blank>cols\\n"" , num_fields ) ; return av ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION } # endif }
","<S2SV_ModStart> ; buffer -> buffer = ( char * ) fbh -> data ; imp_sth -> stmt -> bind [ i ] . buffer_length = fbh -> length ; imp_sth -> stmt -> bind [ i ] .
"
96,"CWE-20 error_t enc28j60SendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { size_t length ; length = netBufferGetLength ( buffer ) - offset ; if ( length > 1536 ) { osSetEvent ( & interface -> nicTxEvent ) ; return ERROR_INVALID_LENGTH ; } if ( ! interface -> linkState ) { osSetEvent ( & interface -> nicTxEvent ) ; return NO_ERROR ; } <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_TXIF | EIR_TXERIF ) ; <S2SV_EndBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXSTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXSTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ; <S2SV_EndBug> enc28j60WriteBuffer ( interface , buffer , offset ) ; <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDL , LSB ( ENC28J60_TX_BUFFER_START + length ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDH , MSB ( ENC28J60_TX_BUFFER_START + length ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRTS ) ; <S2SV_EndBug> return NO_ERROR ; }
","<S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRST <S2SV_ModEnd> ) ; enc28j60ClearBit <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRST <S2SV_ModEnd> ) ; enc28j60ClearBit <S2SV_ModStart> ( interface , ENC28J60_EIR , ENC28J60_EIR_TXIF | ENC28J60_EIR_TXERIF ) ; enc28j60WriteReg ( interface , ENC28J60_ETXSTL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ETXSTH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_EWRPTL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_EWRPTH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_ETXNDL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ETXNDH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRTS <S2SV_ModEnd> ) ; return
"
97,"CWE-125 PyObject * ast2obj_arg ( void * _o ) { arg_ty o = ( arg_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { Py_RETURN_NONE ; } result = PyType_GenericNew ( arg_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> arg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_arg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> annotation ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_annotation , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> value = ast2obj_int ( o -> lineno ) ; <S2SV_EndBug> if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> ; value = ast2obj_string ( o -> type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value =
"
98,"CWE-22 void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { <S2SV_StartBug> file_write ( page , wikitext ) ; <S2SV_EndBug> http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( unlink ( page ) > 0 ) ) <S2SV_EndBug> { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""pages"" ) || ! strcmp ( func , ""search"" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , ""expr"" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , ""%Y-%m-%d<S2SV_blank>%H:%M"" , pTm ) ; http_response_printf ( res , ""%s\\t%s\\n"" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , ""Error"" ) ; http_response_printf ( res , ""<html><body>Failed</body></html>\\n"" ) ; http_response_send ( res ) ; return ; }
","<S2SV_ModStart> ( page && page_name_is_good ( page ) && <S2SV_ModStart> ) ) { if ( page_name_is_good ( page ) ) { <S2SV_ModStart> ; return ; } <S2SV_ModStart> ( page && page_name_is_good ( page ) && <S2SV_ModStart> if ( page && page_name_is_good ( page )
"
99,"CWE-000 static int ext4_ext_handle_uninitialized_extents ( handle_t * handle , struct inode * inode , ext4_lblk_t iblock , unsigned int max_blocks , struct ext4_ext_path * path , int flags , unsigned int allocated , struct buffer_head * bh_result , ext4_fsblk_t newblock ) { int ret = 0 ; int err = 0 ; ext4_io_end_t * io = EXT4_I ( inode ) -> cur_aio_dio ; ext_debug ( ""ext4_ext_handle_uninitialized_extents:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>%d,<S2SV_blank>allocated<S2SV_blank>%u"" , inode -> i_ino , ( unsigned long long ) iblock , max_blocks , flags , allocated ) ; ext4_ext_show_leaf ( inode , path ) ; <S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_PRE_IO ) { <S2SV_EndBug> ret = ext4_split_unwritten_extents ( handle , inode , path , iblock , max_blocks , flags ) ; if ( io ) io -> flag = EXT4_IO_UNWRITTEN ; else <S2SV_StartBug> ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; <S2SV_EndBug> goto out ; } <S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_CONVERT ) { <S2SV_EndBug> ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; goto out2 ; } if ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) goto map_out ; if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) { set_buffer_unwritten ( bh_result ) ; goto out1 ; } ret = ext4_ext_convert_to_initialized ( handle , inode , path , iblock , max_blocks ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; out : if ( ret <= 0 ) { err = ret ; goto out2 ; } else allocated = ret ; set_buffer_new ( bh_result ) ; if ( allocated > max_blocks ) { unmap_underlying_metadata_blocks ( inode -> i_sb -> s_bdev , newblock + max_blocks , allocated - max_blocks ) ; allocated = max_blocks ; } if ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) ext4_da_update_reserve_space ( inode , allocated , 0 ) ; map_out : set_buffer_mapped ( bh_result ) ; out1 : if ( allocated > max_blocks ) allocated = max_blocks ; ext4_ext_show_leaf ( inode , path ) ; bh_result -> b_bdev = inode -> i_sb -> s_bdev ; bh_result -> b_blocknr = newblock ; out2 : if ( path ) { ext4_ext_drop_refs ( path ) ; kfree ( path ) ; } return err ? err : allocated ; }
","<S2SV_ModStart> ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) <S2SV_ModEnd> { ret = <S2SV_ModStart> inode , EXT4_STATE_DIO_UNWRITTEN ) ; if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result <S2SV_ModStart> } if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) <S2SV_ModEnd> ) { ret
"
100,"CWE-125 static int print_ipcp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; u_int compproto , ipcomp_subopttotallen , ipcomp_subopt , ipcomp_suboptlen ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)"" , tok2str ( ipcpopt_values , ""unknown"" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( ipcpopt_values , ""unknown"" , opt ) , opt , len ) ) ; switch ( opt ) { case IPCPOPT_2ADDR : if ( len != 10 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>10)"" ) ) ; return len ; } ND_TCHECK2 ( * ( p + 6 ) , 4 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>src<S2SV_blank>%s,<S2SV_blank>dst<S2SV_blank>%s"" , ipaddr_string ( ndo , p + 2 ) , ipaddr_string ( ndo , p + 6 ) ) ) ; break ; case IPCPOPT_IPCOMP : if ( len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return 0 ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> compproto = EXTRACT_16BITS ( p + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>(0x%02x):"" , tok2str ( ipcpopt_compproto_values , ""Unknown"" , compproto ) , compproto ) ) ; switch ( compproto ) { case PPP_VJC : break ; case IPCPOPT_IPCOMP_HDRCOMP : if ( len < IPCPOPT_IPCOMP_MINLEN ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%u)"" , IPCPOPT_IPCOMP_MINLEN ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 2 ) , IPCPOPT_IPCOMP_MINLEN ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TCP<S2SV_blank>Space<S2SV_blank>%u,<S2SV_blank>non-TCP<S2SV_blank>Space<S2SV_blank>%u"" "",<S2SV_blank>maxPeriod<S2SV_blank>%u,<S2SV_blank>maxTime<S2SV_blank>%u,<S2SV_blank>maxHdr<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 4 ) , EXTRACT_16BITS ( p + 6 ) , EXTRACT_16BITS ( p + 8 ) , EXTRACT_16BITS ( p + 10 ) , EXTRACT_16BITS ( p + 12 ) ) ) ; if ( len > IPCPOPT_IPCOMP_MINLEN ) { ipcomp_subopttotallen = len - IPCPOPT_IPCOMP_MINLEN ; p += IPCPOPT_IPCOMP_MINLEN ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Suboptions,<S2SV_blank>length<S2SV_blank>%u"" , ipcomp_subopttotallen ) ) ; while ( ipcomp_subopttotallen >= 2 ) { ND_TCHECK2 ( * p , 2 ) ; ipcomp_subopt = * p ; ipcomp_suboptlen = * ( p + 1 ) ; if ( ipcomp_subopt == 0 || ipcomp_suboptlen == 0 ) break ; ND_PRINT ( ( ndo , ""\\n\\t\\t%s<S2SV_blank>Suboption<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( ipcpopt_compproto_subopt_values , ""Unknown"" , ipcomp_subopt ) , ipcomp_subopt , ipcomp_suboptlen ) ) ; ipcomp_subopttotallen -= ipcomp_suboptlen ; p += ipcomp_suboptlen ; } } break ; default : break ; } break ; case IPCPOPT_ADDR : case IPCPOPT_MOBILE4 : case IPCPOPT_PRIDNS : case IPCPOPT_PRINBNS : case IPCPOPT_SECDNS : case IPCPOPT_SECNBNS : if ( len != 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)"" ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>%s"" , ipaddr_string ( ndo , p + 2 ) ) ) ; break ; default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , ""[|ipcp]"" ) ) ; return 0 ; }
","<S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ;
"
101,"CWE-264 static int cg_getattr ( const char * path , struct stat * sb ) { struct timespec now ; struct fuse_context * fc = fuse_get_context ( ) ; char * cgdir = NULL ; char * fpath = NULL , * path1 , * path2 ; struct cgfs_files * k = NULL ; const char * cgroup ; const char * controller = NULL ; int ret = - ENOENT ; if ( ! fc ) return - EIO ; memset ( sb , 0 , sizeof ( struct stat ) ) ; if ( clock_gettime ( CLOCK_REALTIME , & now ) < 0 ) return - EINVAL ; sb -> st_uid = sb -> st_gid = 0 ; sb -> st_atim = sb -> st_mtim = sb -> st_ctim = now ; sb -> st_size = 0 ; if ( strcmp ( path , ""/cgroup"" ) == 0 ) { sb -> st_mode = S_IFDIR | 00755 ; sb -> st_nlink = 2 ; return 0 ; } controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EIO ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) { sb -> st_mode = S_IFDIR | 00755 ; sb -> st_nlink = 2 ; return 0 ; } get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) { path1 = ""/"" ; path2 = cgdir ; } else { path1 = cgdir ; path2 = fpath ; } if ( is_child_cgroup ( controller , path1 , path2 ) ) { <S2SV_StartBug> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { <S2SV_EndBug> sb -> st_mode = S_IFDIR | 00555 ; sb -> st_nlink = 2 ; ret = 0 ; goto out ; } if ( ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) { ret = - EACCES ; goto out ; } sb -> st_mode = S_IFDIR | 00755 ; k = cgfs_get_key ( controller , cgroup , ""tasks"" ) ; if ( ! k ) { sb -> st_uid = sb -> st_gid = 0 ; } else { sb -> st_uid = k -> uid ; sb -> st_gid = k -> gid ; } free_key ( k ) ; sb -> st_nlink = 2 ; ret = 0 ; goto out ; } if ( ( k = cgfs_get_key ( controller , path1 , path2 ) ) != NULL ) { sb -> st_mode = S_IFREG | k -> mode ; sb -> st_nlink = 1 ; sb -> st_uid = k -> uid ; sb -> st_gid = k -> gid ; sb -> st_size = 0 ; free_key ( k ) ; if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) { ret = - ENOENT ; goto out ; } if ( ! fc_may_access ( fc , controller , path1 , path2 , O_RDONLY ) ) { ret = - EACCES ; goto out ; } ret = 0 ; } out : free ( cgdir ) ; return ret ; }
","<S2SV_ModStart> if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) { ret = - ENOENT ; goto out ; } if ( !
"
102,"CWE-119 void vp8_de_noise ( VP8_COMMON * cm , YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * post , int q , int low_var_thresh , <S2SV_StartBug> int flag ) <S2SV_EndBug> { double level = 6.0e-05 * q * q * q - .0067 * q * q + .306 * q + .0065 ; int ppl = ( int ) ( level + .5 ) ; <S2SV_StartBug> int mb_rows = source -> y_width >> 4 ; <S2SV_EndBug> <S2SV_StartBug> int mb_cols = source -> y_height >> 4 ; <S2SV_EndBug> unsigned char * limits = cm -> pp_limits_buffer ; ; <S2SV_StartBug> int mbr , mbc ; <S2SV_EndBug> ( void ) post ; ( void ) low_var_thresh ; ( void ) flag ; <S2SV_StartBug> vpx_memset ( limits , ( unsigned char ) ppl , 16 * mb_cols ) ; <S2SV_EndBug> for ( mbr = 0 ; mbr < mb_rows ; mbr ++ ) { vp8_post_proc_down_and_across_mb_row ( source -> y_buffer + 16 * mbr * source -> y_stride , source -> y_buffer + 16 * mbr * source -> y_stride , source -> y_stride , source -> y_stride , source -> y_width , limits , 16 ) ; <S2SV_StartBug> vp8_post_proc_down_and_across_mb_row ( <S2SV_EndBug> source -> u_buffer + 8 * mbr * source -> uv_stride , source -> u_buffer + 8 * mbr * source -> uv_stride , source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ; vp8_post_proc_down_and_across_mb_row ( source -> v_buffer + 8 * mbr * source -> uv_stride , source -> v_buffer + 8 * mbr * source -> uv_stride , <S2SV_StartBug> source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> , int flag , int uvfilter ) { int mbr ; <S2SV_ModEnd> double level = <S2SV_ModStart> int mb_rows = cm -> mb_rows <S2SV_ModEnd> ; int mb_cols <S2SV_ModStart> int mb_cols = cm -> mb_cols <S2SV_ModEnd> ; unsigned char <S2SV_ModStart> pp_limits_buffer ; ; <S2SV_ModEnd> ( void ) <S2SV_ModStart> ) flag ; memset <S2SV_ModEnd> ( limits , <S2SV_ModStart> 16 ) ; if ( uvfilter == 1 ) { <S2SV_ModStart> , limits , 8 ) ; } <S2SV_ModEnd> } } <S2SV_null>
"
103,"CWE-264 static int raw_cmd_copyout ( int cmd , void __user * param , struct floppy_raw_cmd * ptr ) { int ret ; while ( ptr ) { <S2SV_StartBug> ret = copy_to_user ( param , ptr , sizeof ( * ptr ) ) ; <S2SV_EndBug> if ( ret ) return - EFAULT ; param += sizeof ( struct floppy_raw_cmd ) ; if ( ( ptr -> flags & FD_RAW_READ ) && ptr -> buffer_length ) { if ( ptr -> length >= 0 && ptr -> length <= ptr -> buffer_length ) { long length = ptr -> buffer_length - ptr -> length ; ret = fd_copyout ( ptr -> data , ptr -> kernel_data , length ) ; if ( ret ) return ret ; } } ptr = ptr -> next ; } return 0 ; }
","<S2SV_ModStart> ptr ) { struct floppy_raw_cmd cmd = * ptr ; cmd . next = NULL ; cmd . kernel_data = NULL ; <S2SV_ModStart> ( param , & cmd <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( cmd <S2SV_ModEnd> ) ) ;
"
104,"CWE-264 int cap_bprm_set_creds ( struct linux_binprm * bprm ) { const struct cred * old = current_cred ( ) ; struct cred * new = bprm -> cred ; bool effective , has_cap = false ; int ret ; effective = false ; ret = get_file_caps ( bprm , & effective , & has_cap ) ; if ( ret < 0 ) return ret ; if ( ! issecure ( SECURE_NOROOT ) ) { if ( has_cap && new -> uid != 0 && new -> euid == 0 ) { warn_setuid_and_fcaps_mixed ( bprm -> filename ) ; goto skip ; } if ( new -> euid == 0 || new -> uid == 0 ) { new -> cap_permitted = cap_combine ( old -> cap_bset , old -> cap_inheritable ) ; } if ( new -> euid == 0 ) effective = true ; } skip : <S2SV_StartBug> if ( ( new -> euid != old -> uid || <S2SV_EndBug> new -> egid != old -> gid || ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) && bprm -> unsafe & ~ LSM_UNSAFE_PTRACE_CAP ) { if ( ! capable ( CAP_SETUID ) ) { new -> euid = new -> uid ; new -> egid = new -> gid ; } new -> cap_permitted = cap_intersect ( new -> cap_permitted , old -> cap_permitted ) ; } new -> suid = new -> fsuid = new -> euid ; new -> sgid = new -> fsgid = new -> egid ; if ( effective ) new -> cap_effective = new -> cap_permitted ; else cap_clear ( new -> cap_effective ) ; bprm -> cap_effective = effective ; if ( ! cap_isclear ( new -> cap_effective ) ) { if ( ! cap_issubset ( CAP_FULL_SET , new -> cap_effective ) || new -> euid != 0 || new -> uid != 0 || issecure ( SECURE_NOROOT ) ) { ret = audit_log_bprm_fcaps ( bprm , new , old ) ; if ( ret < 0 ) return ret ; } } new -> securebits &= ~ issecure_mask ( SECURE_KEEP_CAPS ) ; return 0 ; }
","<S2SV_ModStart> : if ( ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) bprm -> per_clear |= PER_CLEAR_ON_SETID ; if (
"
105,"CWE-19 static void <S2SV_StartBug> ext4_xattr_cache_insert ( struct mb_cache * ext4_mb_cache , struct buffer_head * bh ) <S2SV_EndBug> { __u32 hash = le32_to_cpu ( BHDR ( bh ) -> h_hash ) ; <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> int error ; <S2SV_StartBug> ce = mb_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ; <S2SV_EndBug> if ( ! ce ) { ea_bdebug ( bh , ""out<S2SV_blank>of<S2SV_blank>memory"" ) ; return ; } <S2SV_StartBug> error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ; <S2SV_EndBug> if ( error ) { <S2SV_StartBug> mb_cache_entry_free ( ce ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error == - EBUSY ) { <S2SV_EndBug> ea_bdebug ( bh , ""already<S2SV_blank>in<S2SV_blank>cache"" ) ; <S2SV_StartBug> error = 0 ; <S2SV_EndBug> } } else { ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]"" , ( int ) hash ) ; <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> ext4_xattr_cache_insert ( struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache , <S2SV_ModStart> h_hash ) ; <S2SV_ModEnd> int error ; <S2SV_ModStart> int error ; error = mb2_cache_entry_create <S2SV_ModEnd> ( ext4_mb_cache , <S2SV_ModStart> ext4_mb_cache , GFP_NOFS , hash , <S2SV_ModEnd> bh -> b_blocknr <S2SV_ModStart> bh -> b_blocknr <S2SV_ModEnd> ) ; if <S2SV_ModStart> error ) { <S2SV_ModEnd> if ( error <S2SV_ModStart> - EBUSY ) <S2SV_ModEnd> ea_bdebug ( bh <S2SV_ModStart> ""already<S2SV_blank>in<S2SV_blank>cache"" ) ; } else <S2SV_ModEnd> ea_bdebug ( bh <S2SV_ModStart> hash ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
106,"CWE-78 R_API char * r_socket_http_post ( const char * url , const char * data , int * code , int * rlen ) { RSocket * s ; bool ssl = r_str_startswith ( url , ""https://"" ) ; char * uri = strdup ( url ) ; if ( ! uri ) { return NULL ; } char * host = strstr ( uri , ""://"" ) ; if ( ! host ) { free ( uri ) ; printf ( ""Invalid<S2SV_blank>URI"" ) ; return NULL ; } host += 3 ; char * port = strchr ( host , ':' ) ; if ( ! port ) { port = ( ssl ) ? ""443"" : ""80"" ; } else { * port ++ = 0 ; } char * path = strchr ( host , '/' ) ; if ( ! path ) { path = """" ; } else { * path ++ = 0 ; } s = r_socket_new ( ssl ) ; if ( ! s ) { printf ( ""Cannot<S2SV_blank>create<S2SV_blank>socket\\n"" ) ; free ( uri ) ; return NULL ; } if ( ! r_socket_connect_tcp ( s , host , port , 0 ) ) { eprintf ( ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>%s:%s\\n"" , host , port ) ; free ( uri ) ; return NULL ; } r_socket_printf ( s , ""POST<S2SV_blank>/%s<S2SV_blank>HTTP/1.0\\r\\n"" ""User-Agent:<S2SV_blank>radare2<S2SV_blank>"" R2_VERSION ""\\r\\n"" ""Accept:<S2SV_blank>*/*\\r\\n"" ""Host:<S2SV_blank>%s\\r\\n"" ""Content-Length:<S2SV_blank>%i\\r\\n"" ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n"" ""\\r\\n"" , path , host , ( int ) strlen ( data ) ) ; free ( uri ) ; r_socket_write ( s , ( void * ) data , strlen ( data ) ) ; <S2SV_StartBug> return r_socket_http_answer ( s , code , rlen ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; return socket_http_answer <S2SV_ModEnd> ( s , <S2SV_ModStart> code , rlen , 0
"
107,"CWE-17 static void f_parser ( lua_State * L , void * ud ) { int i ; Proto * tf ; Closure * cl ; struct SParser * p = cast ( struct SParser * , ud ) ; int c = luaZ_lookahead ( p -> z ) ; luaC_checkGC ( L ) ; <S2SV_StartBug> tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p -> z , <S2SV_EndBug> & p -> buff , p -> name ) ; cl = luaF_newLclosure ( L , tf -> nups , hvalue ( gt ( L ) ) ) ; cl -> l . p = tf ; for ( i = 0 ; i < tf -> nups ; i ++ ) cl -> l . upvals [ i ] = luaF_newupval ( L ) ; setclvalue ( L , L -> top , cl ) ; incr_top ( L ) ; }
","<S2SV_ModStart> tf = ( <S2SV_ModEnd> luaY_parser ) (
"
108,"CWE-000 static int inet_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct sock * sk ; struct inet_protosw * answer ; struct inet_sock * inet ; struct proto * answer_prot ; unsigned char answer_flags ; int try_loading_module = 0 ; <S2SV_StartBug> int err ; <S2SV_EndBug> sock -> state = SS_UNCONNECTED ; lookup_protocol : err = - ESOCKTNOSUPPORT ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( answer , & inetsw [ sock -> type ] , list ) { err = 0 ; if ( protocol == answer -> protocol ) { if ( protocol != IPPROTO_IP ) break ; } else { if ( IPPROTO_IP == protocol ) { protocol = answer -> protocol ; break ; } if ( IPPROTO_IP == answer -> protocol ) break ; } err = - EPROTONOSUPPORT ; } if ( unlikely ( err ) ) { if ( try_loading_module < 2 ) { rcu_read_unlock ( ) ; if ( ++ try_loading_module == 1 ) request_module ( ""net-pf-%d-proto-%d-type-%d"" , PF_INET , protocol , sock -> type ) ; else request_module ( ""net-pf-%d-proto-%d"" , PF_INET , protocol ) ; goto lookup_protocol ; } else goto out_rcu_unlock ; } err = - EPERM ; if ( sock -> type == SOCK_RAW && ! kern && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) goto out_rcu_unlock ; sock -> ops = answer -> ops ; answer_prot = answer -> prot ; answer_flags = answer -> flags ; rcu_read_unlock ( ) ; WARN_ON ( ! answer_prot -> slab ) ; err = - ENOBUFS ; sk = sk_alloc ( net , PF_INET , GFP_KERNEL , answer_prot , kern ) ; if ( ! sk ) goto out ; err = 0 ; if ( INET_PROTOSW_REUSE & answer_flags ) sk -> sk_reuse = SK_CAN_REUSE ; inet = inet_sk ( sk ) ; inet -> is_icsk = ( INET_PROTOSW_ICSK & answer_flags ) != 0 ; inet -> nodefrag = 0 ; if ( SOCK_RAW == sock -> type ) { inet -> inet_num = protocol ; if ( IPPROTO_RAW == protocol ) inet -> hdrincl = 1 ; } if ( net -> ipv4 . sysctl_ip_no_pmtu_disc ) inet -> pmtudisc = IP_PMTUDISC_DONT ; else inet -> pmtudisc = IP_PMTUDISC_WANT ; inet -> inet_id = 0 ; sock_init_data ( sock , sk ) ; sk -> sk_destruct = inet_sock_destruct ; sk -> sk_protocol = protocol ; sk -> sk_backlog_rcv = sk -> sk_prot -> backlog_rcv ; inet -> uc_ttl = - 1 ; inet -> mc_loop = 1 ; inet -> mc_ttl = 1 ; inet -> mc_all = 1 ; inet -> mc_index = 0 ; inet -> mc_list = NULL ; inet -> rcv_tos = 0 ; sk_refcnt_debug_inc ( sk ) ; if ( inet -> inet_num ) { inet -> inet_sport = htons ( inet -> inet_num ) ; sk -> sk_prot -> hash ( sk ) ; } if ( sk -> sk_prot -> init ) { err = sk -> sk_prot -> init ( sk ) ; if ( err ) sk_common_release ( sk ) ; } out : return err ; out_rcu_unlock : rcu_read_unlock ( ) ; goto out ; }
","<S2SV_ModStart> ; int err ; if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL
"
109,"CWE-362 <S2SV_StartBug> int ip_options_get_from_user ( struct net * net , struct ip_options * * optp , <S2SV_EndBug> unsigned char __user * data , int optlen ) { <S2SV_StartBug> struct ip_options * opt = ip_options_get_alloc ( optlen ) ; <S2SV_EndBug> if ( ! opt ) return - ENOMEM ; <S2SV_StartBug> if ( optlen && copy_from_user ( opt -> __data , data , optlen ) ) { <S2SV_EndBug> kfree ( opt ) ; return - EFAULT ; } return ip_options_get_finish ( net , optp , opt , optlen ) ; }
","<S2SV_ModStart> net , struct ip_options_rcu <S2SV_ModEnd> * * optp <S2SV_ModStart> ) { struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> ( opt -> opt .
"
110,"CWE-200 static int rfcomm_get_dev_list ( void __user * arg ) { struct rfcomm_dev * dev ; struct rfcomm_dev_list_req * dl ; struct rfcomm_dev_info * di ; int n = 0 , size , err ; u16 dev_num ; BT_DBG ( """" ) ; if ( get_user ( dev_num , ( u16 __user * ) arg ) ) return - EFAULT ; if ( ! dev_num || dev_num > ( PAGE_SIZE * 4 ) / sizeof ( * di ) ) return - EINVAL ; size = sizeof ( * dl ) + dev_num * sizeof ( * di ) ; <S2SV_StartBug> dl = kmalloc ( size , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! dl ) return - ENOMEM ; di = dl -> dev_info ; spin_lock ( & rfcomm_dev_lock ) ; list_for_each_entry ( dev , & rfcomm_dev_list , list ) { if ( test_bit ( RFCOMM_TTY_RELEASED , & dev -> flags ) ) continue ; ( di + n ) -> id = dev -> id ; ( di + n ) -> flags = dev -> flags ; ( di + n ) -> state = dev -> dlc -> state ; ( di + n ) -> channel = dev -> channel ; bacpy ( & ( di + n ) -> src , & dev -> src ) ; bacpy ( & ( di + n ) -> dst , & dev -> dst ) ; if ( ++ n >= dev_num ) break ; } spin_unlock ( & rfcomm_dev_lock ) ; dl -> dev_num = n ; size = sizeof ( * dl ) + n * sizeof ( * di ) ; err = copy_to_user ( arg , dl , size ) ; kfree ( dl ) ; return err ? - EFAULT : 0 ; }
","<S2SV_ModStart> ; dl = kzalloc <S2SV_ModEnd> ( size ,
"
111,"CWE-125 static void rpl_dio_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_dio * dio = ( const struct nd_rpl_dio * ) bp ; const char * dagid_str ; ND_TCHECK ( * dio ) ; dagid_str = ip6addr_string ( ndo , dio -> rpl_dagid ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]"" , dagid_str , dio -> rpl_dtsn , dio -> rpl_instanceid , EXTRACT_16BITS ( & dio -> rpl_dagrank ) , RPL_DIO_GROUNDED ( dio -> rpl_mopprf ) ? ""grounded,"" : """" , tok2str ( rpl_mop_values , ""mop%u"" , RPL_DIO_MOP ( dio -> rpl_mopprf ) ) , RPL_DIO_PRF ( dio -> rpl_mopprf ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) & dio [ 1 ] ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug> return ; }
","<S2SV_ModStart> ( ndo , ""%s"" , rpl_tstr <S2SV_ModEnd> ) ) ;
"
112,"CWE-125 <S2SV_StartBug> static int <S2SV_EndBug> <S2SV_StartBug> rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , u_int indent ) <S2SV_EndBug> { const rpki_rtr_pdu * pdu_header ; u_int pdu_type , pdu_len , hexdump ; const u_char * msg ; <S2SV_StartBug> pdu_header = ( const rpki_rtr_pdu * ) tptr ; <S2SV_EndBug> pdu_type = pdu_header -> pdu_type ; pdu_len = EXTRACT_32BITS ( pdu_header -> length ) ; <S2SV_StartBug> ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_EndBug> hexdump = FALSE ; ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u,<S2SV_blank>%s<S2SV_blank>PDU<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , indent_string ( 8 ) , pdu_header -> version , tok2str ( rpki_rtr_pdu_values , ""Unknown"" , pdu_type ) , <S2SV_StartBug> pdu_type , pdu_len ) ) ; <S2SV_EndBug> switch ( pdu_type ) { case RPKI_RTR_SERIAL_NOTIFY_PDU : case RPKI_RTR_SERIAL_QUERY_PDU : <S2SV_StartBug> case RPKI_RTR_END_OF_DATA_PDU : <S2SV_EndBug> msg = ( const u_char * ) ( pdu_header + 1 ) ; ND_PRINT ( ( ndo , ""%sSession<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Serial:<S2SV_blank>%u"" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) , EXTRACT_32BITS ( msg ) ) ) ; break ; case RPKI_RTR_RESET_QUERY_PDU : case RPKI_RTR_CACHE_RESET_PDU : <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case RPKI_RTR_CACHE_RESPONSE_PDU : <S2SV_EndBug> ND_PRINT ( ( ndo , ""%sSession<S2SV_blank>ID:<S2SV_blank>0x%04x"" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) ) ) ; break ; case RPKI_RTR_IPV4_PREFIX_PDU : { const rpki_rtr_pdu_ipv4_prefix * pdu ; <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_ipv4_prefix * ) tptr ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%sIPv4<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ipaddr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ; } break ; case RPKI_RTR_IPV6_PREFIX_PDU : { const rpki_rtr_pdu_ipv6_prefix * pdu ; <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_ipv6_prefix * ) tptr ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%sIPv6<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ip6addr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ; } break ; case RPKI_RTR_ERROR_REPORT_PDU : { const rpki_rtr_pdu_error_report * pdu ; u_int encapsulated_pdu_length , text_length , tlen , error_code ; <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_error_report * ) tptr ; <S2SV_EndBug> encapsulated_pdu_length = EXTRACT_32BITS ( pdu -> encapsulated_pdu_length ) ; <S2SV_StartBug> ND_TCHECK2 ( * tptr , encapsulated_pdu_length ) ; <S2SV_EndBug> tlen = pdu_len ; error_code = EXTRACT_16BITS ( pdu -> pdu_header . u . error_code ) ; ND_PRINT ( ( ndo , ""%sError<S2SV_blank>code:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Encapsulated<S2SV_blank>PDU<S2SV_blank>length:<S2SV_blank>%u"" , indent_string ( indent + 2 ) , tok2str ( rpki_rtr_error_codes , ""Unknown"" , error_code ) , error_code , encapsulated_pdu_length ) ) ; <S2SV_StartBug> tptr += sizeof ( * pdu ) ; <S2SV_EndBug> tlen -= sizeof ( * pdu ) ; <S2SV_StartBug> if ( encapsulated_pdu_length && <S2SV_EndBug> ( encapsulated_pdu_length <= tlen ) ) { ND_PRINT ( ( ndo , ""%s-----encapsulated<S2SV_blank>PDU-----"" , indent_string ( indent + 4 ) ) ) ; <S2SV_StartBug> if ( rpki_rtr_pdu_print ( ndo , tptr , indent + 2 ) ) <S2SV_EndBug> goto trunc ; } tptr += encapsulated_pdu_length ; <S2SV_StartBug> tlen -= encapsulated_pdu_length ; <S2SV_EndBug> <S2SV_StartBug> text_length = 0 ; <S2SV_EndBug> if ( tlen > 4 ) { <S2SV_StartBug> text_length = EXTRACT_32BITS ( tptr ) ; <S2SV_EndBug> tptr += 4 ; <S2SV_StartBug> tlen -= 4 ; <S2SV_EndBug> } <S2SV_StartBug> ND_TCHECK2 ( * tptr , text_length ) ; <S2SV_EndBug> if ( text_length && ( text_length <= tlen ) ) { ND_PRINT ( ( ndo , ""%sError<S2SV_blank>text:<S2SV_blank>"" , indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo , tptr , text_length , ndo -> ndo_snapend ) ) goto trunc ; } } break ; default : hexdump = TRUE ; } if ( ndo -> ndo_vflag > 1 || ( ndo -> ndo_vflag && hexdump ) ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , pdu_len ) ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> trunc : <S2SV_StartBug> return 1 ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static u_int <S2SV_ModEnd> rpki_rtr_pdu_print ( netdissect_options <S2SV_ModStart> * tptr , const u_int len , const u_char recurse , const <S2SV_ModStart> * msg ; ND_TCHECK_8BITS ( tptr ) ; if ( * tptr != 0 ) { ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u<S2SV_blank>(unknown)"" , indent_string ( 8 ) , * tptr ) ) ; return len ; } if ( len < sizeof ( rpki_rtr_pdu ) ) { ND_PRINT ( ( ndo , ""(%u<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>few<S2SV_blank>to<S2SV_blank>decode)"" , len ) ) ; goto invalid ; } ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ; <S2SV_ModStart> length ) ; <S2SV_ModEnd> hexdump = FALSE <S2SV_ModStart> pdu_len ) ) ; if ( pdu_len < sizeof ( rpki_rtr_pdu ) || pdu_len > len ) goto invalid <S2SV_ModStart> case RPKI_RTR_END_OF_DATA_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> case RPKI_RTR_CACHE_RESET_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModStart> case RPKI_RTR_CACHE_RESPONSE_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModStart> * pdu ; if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 12 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> * pdu ; if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 24 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> , error_code ; tlen = sizeof ( rpki_rtr_pdu ) ; if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) ; <S2SV_ModStart> encapsulated_pdu_length ) ; tlen += 4 <S2SV_ModEnd> ; error_code = <S2SV_ModStart> ) ) ; <S2SV_ModEnd> if ( encapsulated_pdu_length <S2SV_ModStart> if ( encapsulated_pdu_length ) { if ( pdu_len < tlen + encapsulated_pdu_length ) goto invalid ; if ( ! recurse ) { ND_TCHECK2 ( * tptr , tlen + encapsulated_pdu_length ) ; } else <S2SV_ModEnd> { ND_PRINT ( <S2SV_ModStart> ) ) ; <S2SV_ModEnd> rpki_rtr_pdu_print ( ndo <S2SV_ModStart> ndo , tptr + tlen , encapsulated_pdu_length , 0 <S2SV_ModStart> + 2 ) ; } tlen <S2SV_ModEnd> += encapsulated_pdu_length ; <S2SV_ModStart> += encapsulated_pdu_length ; } if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) <S2SV_ModEnd> ; text_length = <S2SV_ModStart> ; text_length = <S2SV_ModEnd> EXTRACT_32BITS ( tptr <S2SV_ModStart> EXTRACT_32BITS ( tptr + tlen ) ; tlen <S2SV_ModEnd> += 4 ; <S2SV_ModStart> += 4 ; if ( text_length ) { if ( pdu_len < tlen + text_length ) goto invalid ; ND_PRINT ( ( ndo , ""%sError<S2SV_blank>text:<S2SV_blank>"" , indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo , tptr + tlen , text_length , ndo -> ndo_snapend ) ) goto trunc ; } } break ; default : <S2SV_ModEnd> ND_TCHECK2 ( * <S2SV_ModStart> * tptr , pdu_len ) ; <S2SV_ModEnd> hexdump = TRUE <S2SV_ModStart> ; } return pdu_len ; invalid : ND_PRINT ( ( ndo , ""%s"" , istr ) ) ; ND_TCHECK2 ( * tptr , len ) ; return len <S2SV_ModEnd> ; trunc : <S2SV_ModStart> ; trunc : ND_PRINT ( ( ndo , ""\\n\\t%s"" , tstr ) ) ; return len <S2SV_ModEnd> ; } <S2SV_null>
"
113,"CWE-20 int rose_rx_call_request ( struct sk_buff * skb , struct net_device * dev , struct rose_neigh * neigh , unsigned int lci ) { struct sock * sk ; struct sock * make ; struct rose_sock * make_rose ; struct rose_facilities_struct facilities ; <S2SV_StartBug> int n , len ; <S2SV_EndBug> skb -> sk = NULL ; <S2SV_StartBug> memset ( & facilities , 0x00 , sizeof ( struct rose_facilities_struct ) ) ; <S2SV_EndBug> len = ( ( ( skb -> data [ 3 ] >> 4 ) & 0x0F ) + 1 ) >> 1 ; len += ( ( ( skb -> data [ 3 ] >> 0 ) & 0x0F ) + 1 ) >> 1 ; <S2SV_StartBug> if ( ! rose_parse_facilities ( skb -> data + len + 4 , & facilities ) ) { <S2SV_EndBug> rose_transmit_clear_request ( neigh , lci , ROSE_INVALID_FACILITY , 76 ) ; return 0 ; } sk = rose_find_listener ( & facilities . source_addr , & facilities . source_call ) ; if ( sk == NULL || sk_acceptq_is_full ( sk ) || ( make = rose_make_new ( sk ) ) == NULL ) { rose_transmit_clear_request ( neigh , lci , ROSE_NETWORK_CONGESTION , 120 ) ; return 0 ; } skb -> sk = make ; make -> sk_state = TCP_ESTABLISHED ; make_rose = rose_sk ( make ) ; make_rose -> lci = lci ; make_rose -> dest_addr = facilities . dest_addr ; make_rose -> dest_call = facilities . dest_call ; make_rose -> dest_ndigis = facilities . dest_ndigis ; for ( n = 0 ; n < facilities . dest_ndigis ; n ++ ) make_rose -> dest_digis [ n ] = facilities . dest_digis [ n ] ; make_rose -> source_addr = facilities . source_addr ; make_rose -> source_call = facilities . source_call ; make_rose -> source_ndigis = facilities . source_ndigis ; for ( n = 0 ; n < facilities . source_ndigis ; n ++ ) make_rose -> source_digis [ n ] = facilities . source_digis [ n ] ; make_rose -> neighbour = neigh ; make_rose -> device = dev ; make_rose -> facilities = facilities ; make_rose -> neighbour -> use ++ ; if ( rose_sk ( sk ) -> defer ) { make_rose -> state = ROSE_STATE_5 ; } else { rose_write_internal ( make , ROSE_CALL_ACCEPTED ) ; make_rose -> state = ROSE_STATE_3 ; rose_start_idletimer ( make ) ; } make_rose -> condition = 0x00 ; make_rose -> vs = 0 ; make_rose -> va = 0 ; make_rose -> vr = 0 ; make_rose -> vl = 0 ; sk -> sk_ack_backlog ++ ; rose_insert_socket ( make ) ; skb_queue_head ( & sk -> sk_receive_queue , skb ) ; rose_start_heartbeat ( make ) ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_data_ready ( sk , skb -> len ) ; return 1 ; }
","<S2SV_ModStart> ; int n <S2SV_ModEnd> ; skb -> <S2SV_ModStart> rose_facilities_struct ) ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> data + ROSE_CALL_REQ_FACILITIES_OFF , skb -> len - ROSE_CALL_REQ_FACILITIES_OFF , <S2SV_ModEnd> & facilities )
"
114,"CWE-284 int socket_accept ( int fd , uint16_t port ) { # ifdef WIN32 int addr_len ; # else socklen_t addr_len ; # endif int result ; struct sockaddr_in addr ; memset ( & addr , 0 , sizeof ( addr ) ) ; addr . sin_family = AF_INET ; <S2SV_StartBug> addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> addr . sin_port = htons ( port ) ; addr_len = sizeof ( addr ) ; result = accept ( fd , ( struct sockaddr * ) & addr , & addr_len ) ; return result ; }
","<S2SV_ModStart> = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; addr
"
115,"CWE-20 static char_u * did_set_string_option ( int opt_idx , char_u * * varp , int new_value_alloced , char_u * oldval , char_u * errbuf , int opt_flags ) { char_u * errmsg = NULL ; char_u * s , * p ; int did_chartab = FALSE ; char_u * * gvarp ; long_u free_oldval = ( options [ opt_idx ] . flags & P_ALLOCED ) ; # ifdef FEAT_GUI int redraw_gui_only = FALSE ; # endif gvarp = ( char_u * * ) get_varp_scope ( & ( options [ opt_idx ] ) , OPT_GLOBAL ) ; if ( ( secure # ifdef HAVE_SANDBOX || sandbox != 0 # endif ) && ( options [ opt_idx ] . flags & P_SECURE ) ) { errmsg = e_secure ; } else if ( ( options [ opt_idx ] . flags & P_NFNAME ) && vim_strpbrk ( * varp , ( char_u * ) ""/\\\\*?[|<>"" ) != NULL ) { errmsg = e_invarg ; } else if ( varp == & T_NAME ) { if ( T_NAME [ 0 ] == NUL ) errmsg = ( char_u * ) N_ ( ""E529:<S2SV_blank>Cannot<S2SV_blank>set<S2SV_blank>\'term\'<S2SV_blank>to<S2SV_blank>empty<S2SV_blank>string"" ) ; # ifdef FEAT_GUI if ( gui . in_use ) errmsg = ( char_u * ) N_ ( ""E530:<S2SV_blank>Cannot<S2SV_blank>change<S2SV_blank>term<S2SV_blank>in<S2SV_blank>GUI"" ) ; else if ( term_is_gui ( T_NAME ) ) errmsg = ( char_u * ) N_ ( ""E531:<S2SV_blank>Use<S2SV_blank>\\"":gui\\""<S2SV_blank>to<S2SV_blank>start<S2SV_blank>the<S2SV_blank>GUI"" ) ; # endif else if ( set_termname ( T_NAME ) == FAIL ) errmsg = ( char_u * ) N_ ( ""E522:<S2SV_blank>Not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>termcap"" ) ; else redraw_later_clear ( ) ; } else if ( gvarp == & p_bkc ) { char_u * bkc = p_bkc ; unsigned int * flags = & bkc_flags ; if ( opt_flags & OPT_LOCAL ) { bkc = curbuf -> b_p_bkc ; flags = & curbuf -> b_bkc_flags ; } if ( ( opt_flags & OPT_LOCAL ) && * bkc == NUL ) * flags = 0 ; else { if ( opt_strings_flags ( bkc , p_bkc_values , flags , TRUE ) != OK ) errmsg = e_invarg ; if ( ( ( ( int ) * flags & BKC_AUTO ) != 0 ) + ( ( ( int ) * flags & BKC_YES ) != 0 ) + ( ( ( int ) * flags & BKC_NO ) != 0 ) != 1 ) { ( void ) opt_strings_flags ( oldval , p_bkc_values , flags , TRUE ) ; errmsg = e_invarg ; } } } else if ( varp == & p_bex || varp == & p_pm ) { if ( STRCMP ( * p_bex == '.' ? p_bex + 1 : p_bex , * p_pm == '.' ? p_pm + 1 : p_pm ) == 0 ) errmsg = ( char_u * ) N_ ( ""E589:<S2SV_blank>\'backupext\'<S2SV_blank>and<S2SV_blank>\'patchmode\'<S2SV_blank>are<S2SV_blank>equal"" ) ; } # ifdef FEAT_LINEBREAK else if ( varp == & curwin -> w_p_briopt ) { if ( briopt_check ( curwin ) == FAIL ) errmsg = e_invarg ; } # endif else if ( varp == & p_isi || varp == & ( curbuf -> b_p_isk ) || varp == & p_isp || varp == & p_isf ) { if ( init_chartab ( ) == FAIL ) { did_chartab = TRUE ; errmsg = e_invarg ; } } else if ( varp == & p_hf ) { if ( didset_vim ) { vim_setenv ( ( char_u * ) ""VIM"" , ( char_u * ) """" ) ; didset_vim = FALSE ; } if ( didset_vimruntime ) { vim_setenv ( ( char_u * ) ""VIMRUNTIME"" , ( char_u * ) """" ) ; didset_vimruntime = FALSE ; } } # ifdef FEAT_SYN_HL else if ( varp == & curwin -> w_p_cc ) errmsg = check_colorcolumn ( curwin ) ; # endif # ifdef FEAT_MULTI_LANG else if ( varp == & p_hlg ) { for ( s = p_hlg ; * s != NUL ; s += 3 ) { if ( s [ 1 ] == NUL || ( ( s [ 2 ] != ',' || s [ 3 ] == NUL ) && s [ 2 ] != NUL ) ) { errmsg = e_invarg ; break ; } if ( s [ 2 ] == NUL ) break ; } } # endif else if ( varp == & p_hl ) { if ( highlight_changed ( ) == FAIL ) errmsg = e_invarg ; } else if ( gvarp == & p_nf ) { if ( check_opt_strings ( * varp , p_nf_values , TRUE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_SESSION else if ( varp == & p_ssop ) { if ( opt_strings_flags ( p_ssop , p_ssop_values , & ssop_flags , TRUE ) != OK ) errmsg = e_invarg ; if ( ( ssop_flags & SSOP_CURDIR ) && ( ssop_flags & SSOP_SESDIR ) ) { ( void ) opt_strings_flags ( oldval , p_ssop_values , & ssop_flags , TRUE ) ; errmsg = e_invarg ; } } else if ( varp == & p_vop ) { if ( opt_strings_flags ( p_vop , p_ssop_values , & vop_flags , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_SCROLLBIND else if ( varp == & p_sbo ) { if ( check_opt_strings ( p_sbo , p_scbopt_values , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_ambw || varp == & p_emoji ) { if ( check_opt_strings ( p_ambw , p_ambw_values , FALSE ) != OK ) errmsg = e_invarg ; else if ( set_chars_option ( & p_lcs ) != NULL ) errmsg = ( char_u * ) _ ( ""E834:<S2SV_blank>Conflicts<S2SV_blank>with<S2SV_blank>value<S2SV_blank>of<S2SV_blank>\'listchars\'"" ) ; # if defined ( FEAT_WINDOWS ) || defined ( FEAT_FOLDING ) else if ( set_chars_option ( & p_fcs ) != NULL ) errmsg = ( char_u * ) _ ( ""E835:<S2SV_blank>Conflicts<S2SV_blank>with<S2SV_blank>value<S2SV_blank>of<S2SV_blank>\'fillchars\'"" ) ; # endif } # endif else if ( varp == & p_bg ) { if ( check_opt_strings ( p_bg , p_bg_values , FALSE ) == OK ) { # ifdef FEAT_EVAL int dark = ( * p_bg == 'd' ) ; # endif init_highlight ( FALSE , FALSE ) ; # ifdef FEAT_EVAL if ( dark != ( * p_bg == 'd' ) && get_var_value ( ( char_u * ) ""g:colors_name"" ) != NULL ) { do_unlet ( ( char_u * ) ""g:colors_name"" , TRUE ) ; free_string_option ( p_bg ) ; p_bg = vim_strsave ( ( char_u * ) ( dark ? ""dark"" : ""light"" ) ) ; check_string_option ( & p_bg ) ; init_highlight ( FALSE , FALSE ) ; } # endif } else errmsg = e_invarg ; } else if ( varp == & p_wim ) { if ( check_opt_wim ( ) == FAIL ) errmsg = e_invarg ; } # ifdef FEAT_CMDL_COMPL else if ( varp == & p_wop ) { if ( check_opt_strings ( p_wop , p_wop_values , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_WAK else if ( varp == & p_wak ) { if ( * p_wak == NUL || check_opt_strings ( p_wak , p_wak_values , FALSE ) != OK ) errmsg = e_invarg ; # ifdef FEAT_MENU # ifdef FEAT_GUI_MOTIF else if ( gui . in_use ) gui_motif_set_mnemonics ( p_wak [ 0 ] == 'y' || p_wak [ 0 ] == 'm' ) ; # else # ifdef FEAT_GUI_GTK else if ( gui . in_use ) gui_gtk_set_mnemonics ( p_wak [ 0 ] == 'y' || p_wak [ 0 ] == 'm' ) ; # endif # endif # endif } # endif # ifdef FEAT_AUTOCMD else if ( varp == & p_ei ) { if ( check_ei ( ) == FAIL ) errmsg = e_invarg ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_enc || gvarp == & p_fenc || varp == & p_tenc ) { if ( gvarp == & p_fenc ) { if ( ! curbuf -> b_p_ma && opt_flags != OPT_GLOBAL ) errmsg = e_modifiable ; else if ( vim_strchr ( * varp , ',' ) != NULL ) errmsg = e_invarg ; else { # ifdef FEAT_TITLE redraw_titles ( ) ; # endif ml_setflags ( curbuf ) ; } } if ( errmsg == NULL ) { p = enc_canonize ( * varp ) ; if ( p != NULL ) { vim_free ( * varp ) ; * varp = p ; } if ( varp == & p_enc ) { errmsg = mb_init ( ) ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif } } # if defined ( FEAT_GUI_GTK ) if ( errmsg == NULL && varp == & p_tenc && gui . in_use ) { if ( STRCMP ( p_tenc , ""utf-8"" ) != 0 ) errmsg = ( char_u * ) N_ ( ""E617:<S2SV_blank>Cannot<S2SV_blank>be<S2SV_blank>changed<S2SV_blank>in<S2SV_blank>the<S2SV_blank>GTK+<S2SV_blank>2<S2SV_blank>GUI"" ) ; } # endif if ( errmsg == NULL ) { # ifdef FEAT_KEYMAP if ( varp == & p_enc && * curbuf -> b_p_keymap != NUL ) ( void ) keymap_init ( ) ; # endif if ( ( ( varp == & p_enc && * p_tenc != NUL ) || varp == & p_tenc ) ) { convert_setup ( & input_conv , p_tenc , p_enc ) ; convert_setup ( & output_conv , p_enc , p_tenc ) ; } # if defined ( WIN3264 ) && defined ( FEAT_MBYTE ) if ( varp == & p_enc ) init_homedir ( ) ; # endif } } # endif # if defined ( FEAT_POSTSCRIPT ) else if ( varp == & p_penc ) { p = enc_canonize ( p_penc ) ; if ( p != NULL ) { vim_free ( p_penc ) ; p_penc = p ; } else { for ( s = p_penc ; * s != NUL ; s ++ ) { if ( * s == '_' ) * s = '-' ; else * s = TOLOWER_ASC ( * s ) ; } } } # endif # if defined ( FEAT_XIM ) && defined ( FEAT_GUI_GTK ) else if ( varp == & p_imak ) { if ( gui . in_use && ! im_xim_isvalid_imactivate ( ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_KEYMAP else if ( varp == & curbuf -> b_p_keymap ) <S2SV_StartBug> { <S2SV_EndBug> errmsg = keymap_init ( ) ; if ( errmsg == NULL ) { if ( * curbuf -> b_p_keymap != NUL ) { curbuf -> b_p_iminsert = B_IMODE_LMAP ; if ( curbuf -> b_p_imsearch != B_IMODE_USE_INSERT ) curbuf -> b_p_imsearch = B_IMODE_LMAP ; } else { if ( curbuf -> b_p_iminsert == B_IMODE_LMAP ) curbuf -> b_p_iminsert = B_IMODE_NONE ; if ( curbuf -> b_p_imsearch == B_IMODE_LMAP ) curbuf -> b_p_imsearch = B_IMODE_USE_INSERT ; } if ( ( opt_flags & OPT_LOCAL ) == 0 ) { set_iminsert_global ( ) ; set_imsearch_global ( ) ; } # ifdef FEAT_WINDOWS status_redraw_curbuf ( ) ; # endif } } # endif else if ( gvarp == & p_ff ) { if ( ! curbuf -> b_p_ma && ! ( opt_flags & OPT_GLOBAL ) ) errmsg = e_modifiable ; else if ( check_opt_strings ( * varp , p_ff_values , FALSE ) != OK ) errmsg = e_invarg ; else { if ( get_fileformat ( curbuf ) == EOL_DOS ) curbuf -> b_p_tx = TRUE ; else curbuf -> b_p_tx = FALSE ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif ml_setflags ( curbuf ) ; if ( get_fileformat ( curbuf ) == EOL_MAC || * oldval == 'm' ) redraw_curbuf_later ( NOT_VALID ) ; } } else if ( varp == & p_ffs ) { if ( check_opt_strings ( p_ffs , p_ff_values , TRUE ) != OK ) errmsg = e_invarg ; else { if ( * p_ffs == NUL ) p_ta = FALSE ; else p_ta = TRUE ; } } # if defined ( FEAT_CRYPT ) else if ( gvarp == & p_key ) { # if defined ( FEAT_CMDHIST ) remove_key_from_history ( ) ; # endif if ( STRCMP ( curbuf -> b_p_key , oldval ) != 0 ) ml_set_crypt_key ( curbuf , oldval , * curbuf -> b_p_cm == NUL ? p_cm : curbuf -> b_p_cm ) ; } else if ( gvarp == & p_cm ) { if ( opt_flags & OPT_LOCAL ) p = curbuf -> b_p_cm ; else p = p_cm ; if ( check_opt_strings ( p , p_cm_values , TRUE ) != OK ) errmsg = e_invarg ; else if ( crypt_self_test ( ) == FAIL ) errmsg = e_invarg ; else { if ( * p_cm == NUL ) { if ( new_value_alloced ) free_string_option ( p_cm ) ; p_cm = vim_strsave ( ( char_u * ) ""zip"" ) ; new_value_alloced = TRUE ; } if ( ( opt_flags & ( OPT_LOCAL | OPT_GLOBAL ) ) == 0 ) { free_string_option ( curbuf -> b_p_cm ) ; curbuf -> b_p_cm = empty_option ; } if ( ( opt_flags & OPT_LOCAL ) && * oldval == NUL ) s = p_cm ; else s = oldval ; if ( * curbuf -> b_p_cm == NUL ) p = p_cm ; else p = curbuf -> b_p_cm ; if ( STRCMP ( s , p ) != 0 ) ml_set_crypt_key ( curbuf , curbuf -> b_p_key , s ) ; if ( ( opt_flags & OPT_GLOBAL ) && STRCMP ( p_cm , oldval ) != 0 ) { buf_T * buf ; FOR_ALL_BUFFERS ( buf ) if ( buf != curbuf && * buf -> b_p_cm == NUL ) ml_set_crypt_key ( buf , buf -> b_p_key , oldval ) ; } } } # endif else if ( gvarp == & p_mps ) { # ifdef FEAT_MBYTE if ( has_mbyte ) { for ( p = * varp ; * p != NUL ; ++ p ) { int x2 = - 1 ; int x3 = - 1 ; if ( * p != NUL ) p += mb_ptr2len ( p ) ; if ( * p != NUL ) x2 = * p ++ ; if ( * p != NUL ) { x3 = mb_ptr2char ( p ) ; p += mb_ptr2len ( p ) ; } if ( x2 != ':' || x3 == - 1 || ( * p != NUL && * p != ',' ) ) { errmsg = e_invarg ; break ; } if ( * p == NUL ) break ; } } else # endif { for ( p = * varp ; * p != NUL ; p += 4 ) { if ( p [ 1 ] != ':' || p [ 2 ] == NUL || ( p [ 3 ] != NUL && p [ 3 ] != ',' ) ) { errmsg = e_invarg ; break ; } if ( p [ 3 ] == NUL ) break ; } } } # ifdef FEAT_COMMENTS else if ( gvarp == & p_com ) { for ( s = * varp ; * s ; ) { while ( * s && * s != ':' ) { if ( vim_strchr ( ( char_u * ) COM_ALL , * s ) == NULL && ! VIM_ISDIGIT ( * s ) && * s != '-' ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } ++ s ; } if ( * s ++ == NUL ) errmsg = ( char_u * ) N_ ( ""E524:<S2SV_blank>Missing<S2SV_blank>colon"" ) ; else if ( * s == ',' || * s == NUL ) errmsg = ( char_u * ) N_ ( ""E525:<S2SV_blank>Zero<S2SV_blank>length<S2SV_blank>string"" ) ; if ( errmsg != NULL ) break ; while ( * s && * s != ',' ) { if ( * s == '\\\\' && s [ 1 ] != NUL ) ++ s ; ++ s ; } s = skip_to_option_part ( s ) ; } } # endif else if ( varp == & p_lcs ) { errmsg = set_chars_option ( varp ) ; } # if defined ( FEAT_WINDOWS ) || defined ( FEAT_FOLDING ) else if ( varp == & p_fcs ) { errmsg = set_chars_option ( varp ) ; } # endif # ifdef FEAT_CMDWIN else if ( varp == & p_cedit ) { errmsg = check_cedit ( ) ; } # endif else if ( varp == & p_vfile ) { verbose_stop ( ) ; if ( * p_vfile != NUL && verbose_open ( ) == FAIL ) errmsg = e_invarg ; } # ifdef FEAT_VIMINFO else if ( varp == & p_viminfo ) { for ( s = p_viminfo ; * s ; ) { if ( vim_strchr ( ( char_u * ) ""!\\""%\'/:<@cfhnrs"" , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } if ( * s == 'n' ) { break ; } else if ( * s == 'r' ) { while ( * ++ s && * s != ',' ) ; } else if ( * s == '%' ) { while ( vim_isdigit ( * ++ s ) ) ; } else if ( * s == '!' || * s == 'h' || * s == 'c' ) ++ s ; else { while ( vim_isdigit ( * ++ s ) ) ; if ( ! VIM_ISDIGIT ( * ( s - 1 ) ) ) { if ( errbuf != NULL ) { sprintf ( ( char * ) errbuf , _ ( ""E526:<S2SV_blank>Missing<S2SV_blank>number<S2SV_blank>after<S2SV_blank><%s>"" ) , transchar_byte ( * ( s - 1 ) ) ) ; errmsg = errbuf ; } else errmsg = ( char_u * ) """" ; break ; } } if ( * s == ',' ) ++ s ; else if ( * s ) { if ( errbuf != NULL ) errmsg = ( char_u * ) N_ ( ""E527:<S2SV_blank>Missing<S2SV_blank>comma"" ) ; else errmsg = ( char_u * ) """" ; break ; } } if ( * p_viminfo && errmsg == NULL && get_viminfo_parameter ( '\\'' ) < 0 ) errmsg = ( char_u * ) N_ ( ""E528:<S2SV_blank>Must<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>\'<S2SV_blank>value"" ) ; } # endif else if ( istermoption ( & options [ opt_idx ] ) && full_screen ) { if ( varp == & T_CCO ) { int colors = atoi ( ( char * ) T_CCO ) ; if ( colors != t_colors ) { t_colors = colors ; if ( t_colors <= 1 ) { if ( new_value_alloced ) vim_free ( T_CCO ) ; T_CCO = empty_option ; } init_highlight ( TRUE , FALSE ) ; } } ttest ( FALSE ) ; if ( varp == & T_ME ) { out_str ( T_ME ) ; redraw_later ( CLEAR ) ; # if defined ( WIN3264 ) && ! defined ( FEAT_GUI_W32 ) mch_set_normal_colors ( ) ; # endif } } # ifdef FEAT_LINEBREAK else if ( varp == & p_sbr ) { for ( s = p_sbr ; * s ; ) { if ( ptr2cells ( s ) != 1 ) errmsg = ( char_u * ) N_ ( ""E595:<S2SV_blank>contains<S2SV_blank>unprintable<S2SV_blank>or<S2SV_blank>wide<S2SV_blank>character"" ) ; mb_ptr_adv ( s ) ; } } # endif # ifdef FEAT_GUI else if ( varp == & p_guifont ) { if ( gui . in_use ) { p = p_guifont ; # if defined ( FEAT_GUI_GTK ) if ( STRCMP ( p , ""*"" ) == 0 ) { p = gui_mch_font_dialog ( oldval ) ; if ( new_value_alloced ) free_string_option ( p_guifont ) ; p_guifont = ( p != NULL ) ? p : vim_strsave ( oldval ) ; new_value_alloced = TRUE ; } # endif if ( p != NULL && gui_init_font ( p_guifont , FALSE ) != OK ) { # if defined ( FEAT_GUI_MSWIN ) || defined ( FEAT_GUI_PHOTON ) if ( STRCMP ( p_guifont , ""*"" ) == 0 ) { if ( new_value_alloced ) free_string_option ( p_guifont ) ; p_guifont = vim_strsave ( oldval ) ; new_value_alloced = TRUE ; } else # endif errmsg = ( char_u * ) N_ ( ""E596:<S2SV_blank>Invalid<S2SV_blank>font(s)"" ) ; } } redraw_gui_only = TRUE ; } # ifdef FEAT_XFONTSET else if ( varp == & p_guifontset ) { if ( STRCMP ( p_guifontset , ""*"" ) == 0 ) errmsg = ( char_u * ) N_ ( ""E597:<S2SV_blank>can\'t<S2SV_blank>select<S2SV_blank>fontset"" ) ; else if ( gui . in_use && gui_init_font ( p_guifontset , TRUE ) != OK ) errmsg = ( char_u * ) N_ ( ""E598:<S2SV_blank>Invalid<S2SV_blank>fontset"" ) ; redraw_gui_only = TRUE ; } # endif # ifdef FEAT_MBYTE else if ( varp == & p_guifontwide ) { if ( STRCMP ( p_guifontwide , ""*"" ) == 0 ) errmsg = ( char_u * ) N_ ( ""E533:<S2SV_blank>can\'t<S2SV_blank>select<S2SV_blank>wide<S2SV_blank>font"" ) ; else if ( gui_get_wide_font ( ) == FAIL ) errmsg = ( char_u * ) N_ ( ""E534:<S2SV_blank>Invalid<S2SV_blank>wide<S2SV_blank>font"" ) ; redraw_gui_only = TRUE ; } # endif # endif # ifdef CURSOR_SHAPE else if ( varp == & p_guicursor ) errmsg = parse_shape_opt ( SHAPE_CURSOR ) ; # endif # ifdef FEAT_MOUSESHAPE else if ( varp == & p_mouseshape ) { errmsg = parse_shape_opt ( SHAPE_MOUSE ) ; update_mouseshape ( - 1 ) ; } # endif # ifdef FEAT_PRINTER else if ( varp == & p_popt ) errmsg = parse_printoptions ( ) ; # if defined ( FEAT_MBYTE ) && defined ( FEAT_POSTSCRIPT ) else if ( varp == & p_pmfn ) errmsg = parse_printmbfont ( ) ; # endif # endif # ifdef FEAT_LANGMAP else if ( varp == & p_langmap ) langmap_set ( ) ; # endif # ifdef FEAT_LINEBREAK else if ( varp == & p_breakat ) fill_breakat_flags ( ) ; # endif # ifdef FEAT_TITLE else if ( varp == & p_titlestring || varp == & p_iconstring ) { # ifdef FEAT_STL_OPT int flagval = ( varp == & p_titlestring ) ? STL_IN_TITLE : STL_IN_ICON ; if ( vim_strchr ( * varp , '%' ) && check_stl_option ( * varp ) == NULL ) stl_syntax |= flagval ; else stl_syntax &= ~ flagval ; # endif did_set_title ( varp == & p_iconstring ) ; } # endif # ifdef FEAT_GUI else if ( varp == & p_go ) { gui_init_which_components ( oldval ) ; redraw_gui_only = TRUE ; } # endif # if defined ( FEAT_GUI_TABLINE ) else if ( varp == & p_gtl ) { redraw_tabline = TRUE ; redraw_gui_only = TRUE ; } else if ( varp == & p_gtt ) { redraw_gui_only = TRUE ; } # endif # if defined ( FEAT_MOUSE_TTY ) && ( defined ( UNIX ) || defined ( VMS ) ) else if ( varp == & p_ttym ) { mch_setmouse ( FALSE ) ; if ( opt_strings_flags ( p_ttym , p_ttym_values , & ttym_flags , FALSE ) != OK ) errmsg = e_invarg ; else check_mouse_termcode ( ) ; if ( termcap_active ) setmouse ( ) ; } # endif else if ( varp == & p_sel ) { if ( * p_sel == NUL || check_opt_strings ( p_sel , p_sel_values , FALSE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_slm ) { if ( check_opt_strings ( p_slm , p_slm_values , TRUE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_BROWSE else if ( varp == & p_bsdir ) { if ( check_opt_strings ( p_bsdir , p_bsdir_values , FALSE ) != OK && ! mch_isdir ( p_bsdir ) ) errmsg = e_invarg ; } # endif else if ( varp == & p_km ) { if ( check_opt_strings ( p_km , p_km_values , TRUE ) != OK ) errmsg = e_invarg ; else { km_stopsel = ( vim_strchr ( p_km , 'o' ) != NULL ) ; km_startsel = ( vim_strchr ( p_km , 'a' ) != NULL ) ; } } else if ( varp == & p_mousem ) { if ( check_opt_strings ( p_mousem , p_mousem_values , FALSE ) != OK ) errmsg = e_invarg ; # if defined ( FEAT_GUI_MOTIF ) && defined ( FEAT_MENU ) && ( XmVersion <= 1002 ) else if ( * p_mousem != * oldval ) gui_motif_update_mousemodel ( root_menu ) ; # endif } else if ( varp == & p_swb ) { if ( opt_strings_flags ( p_swb , p_swb_values , & swb_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_debug ) { if ( check_opt_strings ( p_debug , p_debug_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_dy ) { if ( opt_strings_flags ( p_dy , p_dy_values , & dy_flags , TRUE ) != OK ) errmsg = e_invarg ; else ( void ) init_chartab ( ) ; } # ifdef FEAT_WINDOWS else if ( varp == & p_ead ) { if ( check_opt_strings ( p_ead , p_ead_values , FALSE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_CLIPBOARD else if ( varp == & p_cb ) errmsg = check_clipboard_option ( ) ; # endif # ifdef FEAT_SPELL else if ( varp == & ( curwin -> w_s -> b_p_spl ) || varp == & ( curwin -> w_s -> b_p_spf ) ) { errmsg = did_set_spell_option ( varp == & ( curwin -> w_s -> b_p_spf ) ) ; } else if ( varp == & ( curwin -> w_s -> b_p_spc ) ) { errmsg = compile_cap_prog ( curwin -> w_s ) ; } else if ( varp == & p_sps ) { if ( spell_check_sps ( ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_msm ) { if ( spell_check_msm ( ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_QUICKFIX else if ( gvarp == & p_bh ) { if ( check_opt_strings ( curbuf -> b_p_bh , p_bufhidden_values , FALSE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & p_bt ) { if ( check_opt_strings ( curbuf -> b_p_bt , p_buftype_values , FALSE ) != OK ) errmsg = e_invarg ; else { # ifdef FEAT_WINDOWS if ( curwin -> w_status_height ) { curwin -> w_redr_status = TRUE ; redraw_later ( VALID ) ; } # endif curbuf -> b_help = ( curbuf -> b_p_bt [ 0 ] == 'h' ) ; # ifdef FEAT_TITLE redraw_titles ( ) ; # endif } } # endif # ifdef FEAT_STL_OPT else if ( gvarp == & p_stl || varp == & p_ruf ) { int wid ; if ( varp == & p_ruf ) ru_wid = 0 ; s = * varp ; if ( varp == & p_ruf && * s == '%' ) { if ( * ++ s == '-' ) s ++ ; wid = getdigits ( & s ) ; if ( wid && * s == '(' && ( errmsg = check_stl_option ( p_ruf ) ) == NULL ) ru_wid = wid ; else errmsg = check_stl_option ( p_ruf ) ; } else if ( varp == & p_ruf || s [ 0 ] != '%' || s [ 1 ] != '!' ) errmsg = check_stl_option ( s ) ; if ( varp == & p_ruf && errmsg == NULL ) comp_col ( ) ; } # endif # ifdef FEAT_INS_EXPAND else if ( gvarp == & p_cpt ) { for ( s = * varp ; * s ; ) { while ( * s == ',' || * s == '<S2SV_blank>' ) s ++ ; if ( ! * s ) break ; if ( vim_strchr ( ( char_u * ) "".wbuksid]tU"" , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } if ( * ++ s != NUL && * s != ',' && * s != '<S2SV_blank>' ) { if ( s [ - 1 ] == 'k' || s [ - 1 ] == 's' ) { while ( * s && * s != ',' && * s != '<S2SV_blank>' ) { if ( * s == '\\\\' ) ++ s ; ++ s ; } } else { if ( errbuf != NULL ) { sprintf ( ( char * ) errbuf , _ ( ""E535:<S2SV_blank>Illegal<S2SV_blank>character<S2SV_blank>after<S2SV_blank><%c>"" ) , * -- s ) ; errmsg = errbuf ; } else errmsg = ( char_u * ) """" ; break ; } } } } else if ( varp == & p_cot ) { if ( check_opt_strings ( p_cot , p_cot_values , TRUE ) != OK ) errmsg = e_invarg ; else completeopt_was_set ( ) ; } # endif # ifdef FEAT_SIGNS else if ( varp == & curwin -> w_p_scl ) { if ( check_opt_strings ( * varp , p_scl_values , FALSE ) != OK ) errmsg = e_invarg ; } # endif # if defined ( FEAT_TOOLBAR ) && ! defined ( FEAT_GUI_W32 ) else if ( varp == & p_toolbar ) { if ( opt_strings_flags ( p_toolbar , p_toolbar_values , & toolbar_flags , TRUE ) != OK ) errmsg = e_invarg ; else { out_flush ( ) ; gui_mch_show_toolbar ( ( toolbar_flags & ( TOOLBAR_TEXT | TOOLBAR_ICONS ) ) != 0 ) ; } } # endif # if defined ( FEAT_TOOLBAR ) && defined ( FEAT_GUI_GTK ) else if ( varp == & p_tbis ) { if ( opt_strings_flags ( p_tbis , p_tbis_values , & tbis_flags , FALSE ) != OK ) errmsg = e_invarg ; else { out_flush ( ) ; gui_mch_show_toolbar ( ( toolbar_flags & ( TOOLBAR_TEXT | TOOLBAR_ICONS ) ) != 0 ) ; } } # endif else if ( varp == & p_pt ) { if ( * p_pt ) { ( void ) replace_termcodes ( p_pt , & p , TRUE , TRUE , FALSE ) ; if ( p != NULL ) { if ( new_value_alloced ) free_string_option ( p_pt ) ; p_pt = p ; new_value_alloced = TRUE ; } } } else if ( varp == & p_bs ) { if ( VIM_ISDIGIT ( * p_bs ) ) { if ( * p_bs > '2' || p_bs [ 1 ] != NUL ) errmsg = e_invarg ; } else if ( check_opt_strings ( p_bs , p_bs_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_bo ) { if ( opt_strings_flags ( p_bo , p_bo_values , & bo_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & p_tc ) { unsigned int * flags ; if ( opt_flags & OPT_LOCAL ) { p = curbuf -> b_p_tc ; flags = & curbuf -> b_tc_flags ; } else { p = p_tc ; flags = & tc_flags ; } if ( ( opt_flags & OPT_LOCAL ) && * p == NUL ) * flags = 0 ; else if ( * p == NUL || opt_strings_flags ( p , p_tc_values , flags , FALSE ) != OK ) errmsg = e_invarg ; } # ifdef FEAT_MBYTE else if ( varp == & p_cmp ) { if ( opt_strings_flags ( p_cmp , p_cmp_values , & cmp_flags , TRUE ) != OK ) errmsg = e_invarg ; } # endif # ifdef FEAT_DIFF else if ( varp == & p_dip ) { if ( diffopt_changed ( ) == FAIL ) errmsg = e_invarg ; } # endif # ifdef FEAT_FOLDING else if ( gvarp == & curwin -> w_allbuf_opt . wo_fdm ) { if ( check_opt_strings ( * varp , p_fdm_values , FALSE ) != OK || * curwin -> w_p_fdm == NUL ) errmsg = e_invarg ; else { foldUpdateAll ( curwin ) ; if ( foldmethodIsDiff ( curwin ) ) newFoldLevel ( ) ; } } # ifdef FEAT_EVAL else if ( varp == & curwin -> w_p_fde ) { if ( foldmethodIsExpr ( curwin ) ) foldUpdateAll ( curwin ) ; } # endif else if ( gvarp == & curwin -> w_allbuf_opt . wo_fmr ) { p = vim_strchr ( * varp , ',' ) ; if ( p == NULL ) errmsg = ( char_u * ) N_ ( ""E536:<S2SV_blank>comma<S2SV_blank>required"" ) ; else if ( p == * varp || p [ 1 ] == NUL ) errmsg = e_invarg ; else if ( foldmethodIsMarker ( curwin ) ) foldUpdateAll ( curwin ) ; } else if ( gvarp == & p_cms ) { if ( * * varp != NUL && strstr ( ( char * ) * varp , ""%s"" ) == NULL ) errmsg = ( char_u * ) N_ ( ""E537:<S2SV_blank>\'commentstring\'<S2SV_blank>must<S2SV_blank>be<S2SV_blank>empty<S2SV_blank>or<S2SV_blank>contain<S2SV_blank>%s"" ) ; } else if ( varp == & p_fdo ) { if ( opt_strings_flags ( p_fdo , p_fdo_values , & fdo_flags , TRUE ) != OK ) errmsg = e_invarg ; } else if ( varp == & p_fcl ) { if ( check_opt_strings ( p_fcl , p_fcl_values , TRUE ) != OK ) errmsg = e_invarg ; } else if ( gvarp == & curwin -> w_allbuf_opt . wo_fdi ) { if ( foldmethodIsIndent ( curwin ) ) foldUpdateAll ( curwin ) ; } # endif # ifdef FEAT_VIRTUALEDIT else if ( varp == & p_ve ) { if ( opt_strings_flags ( p_ve , p_ve_values , & ve_flags , TRUE ) != OK ) errmsg = e_invarg ; else if ( STRCMP ( p_ve , oldval ) != 0 ) { validate_virtcol ( ) ; coladvance ( curwin -> w_virtcol ) ; } } # endif # if defined ( FEAT_CSCOPE ) && defined ( FEAT_QUICKFIX ) else if ( varp == & p_csqf ) { if ( p_csqf != NULL ) { p = p_csqf ; while ( * p != NUL ) { if ( vim_strchr ( ( char_u * ) CSQF_CMDS , * p ) == NULL || p [ 1 ] == NUL || vim_strchr ( ( char_u * ) CSQF_FLAGS , p [ 1 ] ) == NULL || ( p [ 2 ] != NUL && p [ 2 ] != ',' ) ) { errmsg = e_invarg ; break ; } else if ( p [ 2 ] == NUL ) break ; else p += 3 ; } } } # endif # ifdef FEAT_CINDENT else if ( gvarp == & p_cino ) { parse_cino ( curbuf ) ; } # endif # if defined ( FEAT_RENDER_OPTIONS ) else if ( varp == & p_rop && gui . in_use ) { <S2SV_StartBug> if ( ! gui_mch_set_rendering_options ( p_rop ) ) <S2SV_EndBug> errmsg = e_invarg ; } # endif else { p = NULL ; if ( varp == & p_ww ) p = ( char_u * ) WW_ALL ; if ( varp == & p_shm ) p = ( char_u * ) SHM_ALL ; else if ( varp == & ( p_cpo ) ) p = ( char_u * ) CPO_ALL ; else if ( varp == & ( curbuf -> b_p_fo ) ) p = ( char_u * ) FO_ALL ; # ifdef FEAT_CONCEAL else if ( varp == & curwin -> w_p_cocu ) p = ( char_u * ) COCU_ALL ; # endif else if ( varp == & p_mouse ) { # ifdef FEAT_MOUSE p = ( char_u * ) MOUSE_ALL ; # else if ( * p_mouse != NUL ) errmsg = ( char_u * ) N_ ( ""E538:<S2SV_blank>No<S2SV_blank>mouse<S2SV_blank>support"" ) ; # endif } # if defined ( FEAT_GUI ) else if ( varp == & p_go ) p = ( char_u * ) GO_ALL ; # endif if ( p != NULL ) { for ( s = * varp ; * s ; ++ s ) if ( vim_strchr ( p , * s ) == NULL ) { errmsg = illegal_char ( errbuf , * s ) ; break ; } } } if ( errmsg != NULL ) { if ( new_value_alloced ) free_string_option ( * varp ) ; * varp = oldval ; if ( did_chartab ) ( void ) init_chartab ( ) ; if ( varp == & p_hl ) ( void ) highlight_changed ( ) ; } else { # ifdef FEAT_EVAL set_option_scriptID_idx ( opt_idx , opt_flags , current_SID ) ; # endif if ( free_oldval ) free_string_option ( oldval ) ; if ( new_value_alloced ) options [ opt_idx ] . flags |= P_ALLOCED ; else options [ opt_idx ] . flags &= ~ P_ALLOCED ; if ( ( opt_flags & ( OPT_LOCAL | OPT_GLOBAL ) ) == 0 && ( ( int ) options [ opt_idx ] . indir & PV_BOTH ) ) { p = get_varp_scope ( & ( options [ opt_idx ] ) , OPT_LOCAL ) ; free_string_option ( * ( char_u * * ) p ) ; * ( char_u * * ) p = empty_option ; } else if ( ! ( opt_flags & OPT_LOCAL ) && opt_flags != OPT_GLOBAL ) set_string_option_global ( opt_idx , varp ) ; # ifdef FEAT_AUTOCMD # ifdef FEAT_SYN_HL if ( varp == & ( curbuf -> b_p_syn ) ) { apply_autocmds ( EVENT_SYNTAX , curbuf -> b_p_syn , curbuf -> b_fname , TRUE , curbuf ) ; } # endif else if ( varp == & ( curbuf -> b_p_ft ) ) { did_filetype = TRUE ; apply_autocmds ( EVENT_FILETYPE , curbuf -> b_p_ft , curbuf -> b_fname , TRUE , curbuf ) ; } # endif # ifdef FEAT_SPELL if ( varp == & ( curwin -> w_s -> b_p_spl ) ) { char_u fname [ 200 ] ; char_u * q = curwin -> w_s -> b_p_spl ; if ( STRNCMP ( q , ""cjk,"" , 4 ) == 0 ) q += 4 ; for ( p = q ; * p != NUL ; ++ p ) if ( vim_strchr ( ( char_u * ) ""_.,"" , * p ) != NULL ) break ; vim_snprintf ( ( char * ) fname , 200 , ""spell/%.*s.vim"" , ( int ) ( p - q ) , q ) ; source_runtime ( fname , DIP_ALL ) ; } # endif } # ifdef FEAT_MOUSE if ( varp == & p_mouse ) { # ifdef FEAT_MOUSE_TTY if ( * p_mouse == NUL ) mch_setmouse ( FALSE ) ; else # endif setmouse ( ) ; } # endif if ( curwin -> w_curswant != MAXCOL && ( options [ opt_idx ] . flags & ( P_CURSWANT | P_RALL ) ) != 0 ) curwin -> w_set_curswant = TRUE ; # ifdef FEAT_GUI if ( ! redraw_gui_only || gui . in_use ) # endif check_redraw ( options [ opt_idx ] . flags ) ; return errmsg ; }
","<S2SV_ModStart> b_p_keymap ) { if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ; else <S2SV_ModStart> gui_mch_set_rendering_options ( p_rop ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_AUTOCMD else if ( gvarp == & p_ft ) { if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_SYN_HL else if ( gvarp == & p_syn ) { if ( ! valid_filetype ( * varp
"
116,"CWE-285 int ceph_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int ret = 0 , size = 0 ; const char * name = NULL ; char * value = NULL ; struct iattr newattrs ; umode_t new_mode = inode -> i_mode , old_mode = inode -> i_mode ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & new_mode ) ; <S2SV_EndBug> if ( ret < 0 ) goto out ; if ( ret == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) { ret = acl ? - EINVAL : 0 ; goto out ; } name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : ret = - EINVAL ; goto out ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_NOFS ) ; if ( ! value ) { ret = - ENOMEM ; goto out ; } ret = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( ret < 0 ) goto out_free ; } if ( new_mode != old_mode ) { newattrs . ia_mode = new_mode ; newattrs . ia_valid = ATTR_MODE ; ret = __ceph_setattr ( inode , & newattrs ) ; if ( ret ) goto out_free ; } ret = __ceph_setxattr ( inode , name , value , size , 0 ) ; if ( ret ) { if ( new_mode != old_mode ) { newattrs . ia_mode = old_mode ; newattrs . ia_valid = ATTR_MODE ; __ceph_setattr ( inode , & newattrs ) ; } goto out_free ; } ceph_set_cached_acl ( inode , type , acl ) ; out_free : kfree ( value ) ; out : return ret ; }
","<S2SV_ModStart> { ret = posix_acl_update_mode ( inode , & new_mode , & acl ) ; if ( ret ) goto out <S2SV_ModEnd> ; } break
"
117,"CWE-476 static ssize_t o2nm_node_ipv4_address_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; <S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> int ret , i ; struct rb_node * * p , * parent ; unsigned int octets [ 4 ] ; __be32 ipv4_addr = 0 ; ret = sscanf ( page , ""%3u.%3u.%3u.%3u"" , & octets [ 3 ] , & octets [ 2 ] , & octets [ 1 ] , & octets [ 0 ] ) ; if ( ret != 4 ) return - EINVAL ; for ( i = 0 ; i < ARRAY_SIZE ( octets ) ; i ++ ) { if ( octets [ i ] > 255 ) return - ERANGE ; be32_add_cpu ( & ipv4_addr , octets [ i ] << ( i * 8 ) ) ; } <S2SV_StartBug> ret = 0 ; <S2SV_EndBug> write_lock ( & cluster -> cl_nodes_lock ) ; if ( o2nm_node_ip_tree_lookup ( cluster , ipv4_addr , & p , & parent ) ) ret = - EEXIST ; else if ( test_and_set_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) ) ret = - EBUSY ; else { rb_link_node ( & node -> nd_ip_node , parent , p ) ; rb_insert_color ( & node -> nd_ip_node , & cluster -> cl_node_ip_tree ) ; } write_unlock ( & cluster -> cl_nodes_lock ) ; <S2SV_StartBug> if ( ret ) <S2SV_EndBug> return ret ; memcpy ( & node -> nd_ipv4_address , & ipv4_addr , sizeof ( ipv4_addr ) ) ; return count ; }
","<S2SV_ModStart> o2nm_cluster * cluster <S2SV_ModEnd> ; int ret <S2SV_ModStart> ) ; } o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ;
"
118,"CWE-125 u_int null_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int length = h -> len ; u_int caplen = h -> caplen ; u_int family ; if ( caplen < NULL_HDRLEN ) { ND_PRINT ( ( ndo , ""[|null]"" ) ) ; return ( NULL_HDRLEN ) ; } memcpy ( ( char * ) & family , ( const char * ) p , sizeof ( family ) ) ; if ( ( family & 0xFFFF0000 ) != 0 ) family = SWAPLONG ( family ) ; if ( ndo -> ndo_eflag ) null_hdr_print ( ndo , family , length ) ; length -= NULL_HDRLEN ; caplen -= NULL_HDRLEN ; p += NULL_HDRLEN ; switch ( family ) { case BSD_AFNUM_INET : ip_print ( ndo , p , length ) ; break ; case BSD_AFNUM_INET6_BSD : case BSD_AFNUM_INET6_FREEBSD : case BSD_AFNUM_INET6_DARWIN : ip6_print ( ndo , p , length ) ; break ; case BSD_AFNUM_ISO : <S2SV_StartBug> isoclns_print ( ndo , p , length , caplen ) ; <S2SV_EndBug> break ; case BSD_AFNUM_APPLETALK : atalk_print ( ndo , p , length ) ; break ; case BSD_AFNUM_IPX : ipx_print ( ndo , p , length ) ; break ; default : if ( ! ndo -> ndo_eflag ) null_hdr_print ( ndo , family , length + NULL_HDRLEN ) ; if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; } return ( NULL_HDRLEN ) ; }
","<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break
"
119,"CWE-22 static int cleanup_pathname ( struct archive_write_disk * a ) { char * dest , * src ; char separator = '\\0' ; dest = src = a -> name ; if ( * src == '\\0' ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Invalid<S2SV_blank>empty<S2SV_blank>pathname"" ) ; return ( ARCHIVE_FAILED ) ; } # if defined ( __CYGWIN__ ) cleanup_pathname_win ( a ) ; # endif if ( * src == '/' ) <S2SV_StartBug> separator = * src ++ ; <S2SV_EndBug> for ( ; ; ) { if ( src [ 0 ] == '\\0' ) { break ; } else if ( src [ 0 ] == '/' ) { src ++ ; continue ; } else if ( src [ 0 ] == '.' ) { if ( src [ 1 ] == '\\0' ) { break ; } else if ( src [ 1 ] == '/' ) { src += 2 ; continue ; } else if ( src [ 1 ] == '.' ) { if ( src [ 2 ] == '/' || src [ 2 ] == '\\0' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>contains<S2SV_blank>\'..\'"" ) ; return ( ARCHIVE_FAILED ) ; } } } } if ( separator ) * dest ++ = '/' ; while ( * src != '\\0' && * src != '/' ) { * dest ++ = * src ++ ; } if ( * src == '\\0' ) break ; separator = * src ++ ; } if ( dest == a -> name ) { if ( separator ) * dest ++ = '/' ; else * dest ++ = '.' ; } * dest = '\\0' ; return ( ARCHIVE_OK ) ; }
","<S2SV_ModStart> == '/' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>is<S2SV_blank>absolute"" ) ; return ( ARCHIVE_FAILED ) ; } separator = * src ++ ; } <S2SV_ModEnd> for ( ;
"
120,"CWE-522 <S2SV_StartBug> TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , <S2SV_EndBug> TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <S2SV_StartBug> TPM2B_DIGEST tmpResult ; <S2SV_EndBug> TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <S2SV_StartBug> TPM_RC rval ; <S2SV_EndBug> int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; <S2SV_StartBug> while ( resultKey -> t . size < bytes ) <S2SV_EndBug> { <S2SV_StartBug> i_Swizzled = string_bytes_endian_convert_32 ( i ) ; <S2SV_EndBug> * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <S2SV_StartBug> bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; <S2SV_EndBug> <S2SV_StartBug> rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rval != TPM_RC_SUCCESS ) <S2SV_EndBug> { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <S2SV_StartBug> return TSS2_SYS_RC_BAD_VALUE ; <S2SV_EndBug> } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }
","<S2SV_ModStart> TPM_RC tpm_kdfa ( <S2SV_ModEnd> TPMI_ALG_HASH hashAlg , <S2SV_ModStart> ) { TPM2B_DIGEST <S2SV_ModEnd> tpm2bLabel , tpm2bBits <S2SV_ModStart> ; TPM_RC rval = TPM_RC_SUCCESS <S2SV_ModStart> = 1 ; const EVP_MD * md = tpm_algorithm_to_openssl_digest ( hashAlg ) ; if ( ! md ) { LOG_ERR ( ""Algorithm<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>hmac:<S2SV_blank>%x"" , hashAlg ) ; return TPM_RC_HASH ; } HMAC_CTX ctx ; HMAC_CTX_init ( & ctx ) ; int rc = HMAC_Init_ex ( & ctx , key -> buffer , key -> size , md , NULL ) ; if ( ! rc ) { LOG_ERR ( ""HMAC<S2SV_blank>Init<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ; return TPM_RC_MEMORY ; } <S2SV_ModStart> bytes ) { TPM2B_DIGEST tmpResult ; <S2SV_ModStart> bufferList [ j ] = ( TPM2B_DIGEST * ) 0 ; int c ; for ( c = 0 ; c < j ; c ++ ) { TPM2B_DIGEST * digest = bufferList [ c ] ; int rc = HMAC_Update ( & ctx , digest -> b . buffer , digest -> b . size ) ; if ( ! rc ) { LOG_ERR ( ""HMAC<S2SV_blank>Update<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) <S2SV_ModEnd> ; rval = <S2SV_ModStart> ; rval = TPM_RC_MEMORY ; goto err ; } } unsigned size = sizeof ( tmpResult . t . buffer ) ; int rc = HMAC_Final ( & ctx , tmpResult . t . buffer , & size <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( ! rc ) { LOG_ERR ( ""HMAC<S2SV_blank>Final<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ; rval = TPM_RC_MEMORY ; goto err ; } tmpResult . t . size = size ; <S2SV_ModEnd> bool res = <S2SV_ModStart> res ) { rval = TSS2_SYS_RC_BAD_VALUE ; goto err ; } } resultKey -> t . size = bytes ; err : HMAC_CTX_cleanup ( & ctx ) ; return rval <S2SV_ModEnd> ; } <S2SV_null>
"
121,"CWE-190 static jas_image_cmpt_t * jas_image_cmpt_create ( int_fast32_t tlx , int_fast32_t tly , int_fast32_t hstep , int_fast32_t vstep , int_fast32_t width , int_fast32_t height , uint_fast16_t depth , bool sgnd , uint_fast32_t inmem ) { jas_image_cmpt_t * cmpt ; size_t size ; <S2SV_StartBug> cmpt = 0 ; <S2SV_EndBug> if ( width < 0 || height < 0 || hstep <= 0 || vstep <= 0 ) { goto error ; } if ( ! jas_safe_intfast32_add ( tlx , width , 0 ) || <S2SV_StartBug> ! jas_safe_intfast32_add ( tly , height , 0 ) ) { <S2SV_EndBug> goto error ; } if ( ! ( cmpt = jas_malloc ( sizeof ( jas_image_cmpt_t ) ) ) ) { goto error ; } cmpt -> type_ = JAS_IMAGE_CT_UNKNOWN ; cmpt -> tlx_ = tlx ; cmpt -> tly_ = tly ; cmpt -> hstep_ = hstep ; cmpt -> vstep_ = vstep ; cmpt -> width_ = width ; cmpt -> height_ = height ; cmpt -> prec_ = depth ; cmpt -> sgnd_ = sgnd ; cmpt -> stream_ = 0 ; cmpt -> cps_ = ( depth + 7 ) / 8 ; <S2SV_StartBug> if ( ! jas_safe_size_mul ( cmpt -> width_ , cmpt -> height_ , & size ) || <S2SV_EndBug> ! jas_safe_size_mul ( size , cmpt -> cps_ , & size ) ) { goto error ; } cmpt -> stream_ = ( inmem ) ? jas_stream_memopen2 ( 0 , size ) : jas_stream_tmpfile ( ) ; if ( ! cmpt -> stream_ ) { goto error ; } if ( size > 0 ) { if ( size - 1 > LONG_MAX ) { goto error ; } if ( jas_stream_seek ( cmpt -> stream_ , size - 1 , SEEK_SET ) < 0 || jas_stream_putc ( cmpt -> stream_ , 0 ) == EOF || jas_stream_seek ( cmpt -> stream_ , 0 , SEEK_SET ) < 0 ) { goto error ; } } return cmpt ; error : if ( cmpt ) { jas_image_cmpt_destroy ( cmpt ) ; } return 0 ; }
","<S2SV_ModStart> size_t size ; JAS_DBGLOG ( 100 , ( ""jas_image_cmpt_create(%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%d,<S2SV_blank>%d,<S2SV_blank>%d)\\n"" , JAS_CAST ( long , tlx ) , JAS_CAST ( long , tly ) , JAS_CAST ( long , hstep ) , JAS_CAST ( long , vstep ) , JAS_CAST ( long , width ) , JAS_CAST ( long , height ) , JAS_CAST ( int , depth ) , sgnd , inmem ) ) ; <S2SV_ModStart> tly , height , 0 ) ) { goto error ; } if ( ! jas_safe_intfast32_mul3 ( width , height , depth <S2SV_ModStart> if ( ! jas_safe_size_mul3 <S2SV_ModEnd> ( cmpt -> <S2SV_ModStart> cmpt -> height_ <S2SV_ModEnd> , cmpt ->
"
122,"CWE-369 tdata_t _TIFFmalloc ( tsize_t s ) <S2SV_StartBug> { <S2SV_EndBug> return ( malloc ( ( size_t ) s ) ) ; }
","<S2SV_ModStart> s ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
"
123,"CWE-264 static ssize_t qib_write ( struct file * fp , const char __user * data , size_t count , loff_t * off ) { const struct qib_cmd __user * ucmd ; struct qib_ctxtdata * rcd ; const void __user * src ; size_t consumed , copy = 0 ; struct qib_cmd cmd ; ssize_t ret = 0 ; void * dest ; <S2SV_StartBug> if ( count < sizeof ( cmd . type ) ) { <S2SV_EndBug> ret = - EINVAL ; goto bail ; } ucmd = ( const struct qib_cmd __user * ) data ; if ( copy_from_user ( & cmd . type , & ucmd -> type , sizeof ( cmd . type ) ) ) { ret = - EFAULT ; goto bail ; } consumed = sizeof ( cmd . type ) ; switch ( cmd . type ) { case QIB_CMD_ASSIGN_CTXT : case QIB_CMD_USER_INIT : copy = sizeof ( cmd . cmd . user_info ) ; dest = & cmd . cmd . user_info ; src = & ucmd -> cmd . user_info ; break ; case QIB_CMD_RECV_CTRL : copy = sizeof ( cmd . cmd . recv_ctrl ) ; dest = & cmd . cmd . recv_ctrl ; src = & ucmd -> cmd . recv_ctrl ; break ; case QIB_CMD_CTXT_INFO : copy = sizeof ( cmd . cmd . ctxt_info ) ; dest = & cmd . cmd . ctxt_info ; src = & ucmd -> cmd . ctxt_info ; break ; case QIB_CMD_TID_UPDATE : case QIB_CMD_TID_FREE : copy = sizeof ( cmd . cmd . tid_info ) ; dest = & cmd . cmd . tid_info ; src = & ucmd -> cmd . tid_info ; break ; case QIB_CMD_SET_PART_KEY : copy = sizeof ( cmd . cmd . part_key ) ; dest = & cmd . cmd . part_key ; src = & ucmd -> cmd . part_key ; break ; case QIB_CMD_DISARM_BUFS : case QIB_CMD_PIOAVAILUPD : copy = 0 ; src = NULL ; dest = NULL ; break ; case QIB_CMD_POLL_TYPE : copy = sizeof ( cmd . cmd . poll_type ) ; dest = & cmd . cmd . poll_type ; src = & ucmd -> cmd . poll_type ; break ; case QIB_CMD_ARMLAUNCH_CTRL : copy = sizeof ( cmd . cmd . armlaunch_ctrl ) ; dest = & cmd . cmd . armlaunch_ctrl ; src = & ucmd -> cmd . armlaunch_ctrl ; break ; case QIB_CMD_SDMA_INFLIGHT : copy = sizeof ( cmd . cmd . sdma_inflight ) ; dest = & cmd . cmd . sdma_inflight ; src = & ucmd -> cmd . sdma_inflight ; break ; case QIB_CMD_SDMA_COMPLETE : copy = sizeof ( cmd . cmd . sdma_complete ) ; dest = & cmd . cmd . sdma_complete ; src = & ucmd -> cmd . sdma_complete ; break ; case QIB_CMD_ACK_EVENT : copy = sizeof ( cmd . cmd . event_mask ) ; dest = & cmd . cmd . event_mask ; src = & ucmd -> cmd . event_mask ; break ; default : ret = - EINVAL ; goto bail ; } if ( copy ) { if ( ( count - consumed ) < copy ) { ret = - EINVAL ; goto bail ; } if ( copy_from_user ( dest , src , copy ) ) { ret = - EFAULT ; goto bail ; } consumed += copy ; } rcd = ctxt_fp ( fp ) ; if ( ! rcd && cmd . type != QIB_CMD_ASSIGN_CTXT ) { ret = - EINVAL ; goto bail ; } switch ( cmd . type ) { case QIB_CMD_ASSIGN_CTXT : ret = qib_assign_ctxt ( fp , & cmd . cmd . user_info ) ; if ( ret ) goto bail ; break ; case QIB_CMD_USER_INIT : ret = qib_do_user_init ( fp , & cmd . cmd . user_info ) ; if ( ret ) goto bail ; ret = qib_get_base_info ( fp , ( void __user * ) ( unsigned long ) cmd . cmd . user_info . spu_base_info , cmd . cmd . user_info . spu_base_info_size ) ; break ; case QIB_CMD_RECV_CTRL : ret = qib_manage_rcvq ( rcd , subctxt_fp ( fp ) , cmd . cmd . recv_ctrl ) ; break ; case QIB_CMD_CTXT_INFO : ret = qib_ctxt_info ( fp , ( struct qib_ctxt_info __user * ) ( unsigned long ) cmd . cmd . ctxt_info ) ; break ; case QIB_CMD_TID_UPDATE : ret = qib_tid_update ( rcd , fp , & cmd . cmd . tid_info ) ; break ; case QIB_CMD_TID_FREE : ret = qib_tid_free ( rcd , subctxt_fp ( fp ) , & cmd . cmd . tid_info ) ; break ; case QIB_CMD_SET_PART_KEY : ret = qib_set_part_key ( rcd , cmd . cmd . part_key ) ; break ; case QIB_CMD_DISARM_BUFS : ( void ) qib_disarm_piobufs_ifneeded ( rcd ) ; ret = disarm_req_delay ( rcd ) ; break ; case QIB_CMD_PIOAVAILUPD : qib_force_pio_avail_update ( rcd -> dd ) ; break ; case QIB_CMD_POLL_TYPE : rcd -> poll_type = cmd . cmd . poll_type ; break ; case QIB_CMD_ARMLAUNCH_CTRL : rcd -> dd -> f_set_armlaunch ( rcd -> dd , cmd . cmd . armlaunch_ctrl ) ; break ; case QIB_CMD_SDMA_INFLIGHT : ret = qib_sdma_get_inflight ( user_sdma_queue_fp ( fp ) , ( u32 __user * ) ( unsigned long ) cmd . cmd . sdma_inflight ) ; break ; case QIB_CMD_SDMA_COMPLETE : ret = qib_sdma_get_complete ( rcd -> ppd , user_sdma_queue_fp ( fp ) , ( u32 __user * ) ( unsigned long ) cmd . cmd . sdma_complete ) ; break ; case QIB_CMD_ACK_EVENT : ret = qib_user_event_ack ( rcd , subctxt_fp ( fp ) , cmd . cmd . event_mask ) ; break ; } if ( ret >= 0 ) ret = consumed ; bail : return ret ; }
","<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if (
"
124,"CWE-200 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_StartBug> MinVal = 0 ; <S2SV_EndBug> MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ;
"
125,"CWE-416 struct net * get_net_ns_by_id ( struct net * net , int id ) { struct net * peer ; if ( id < 0 ) return NULL ; rcu_read_lock ( ) ; spin_lock_bh ( & net -> nsid_lock ) ; peer = idr_find ( & net -> netns_ids , id ) ; if ( peer ) <S2SV_StartBug> get_net ( peer ) ; <S2SV_EndBug> spin_unlock_bh ( & net -> nsid_lock ) ; rcu_read_unlock ( ) ; return peer ; }
","<S2SV_ModStart> ( peer ) peer = maybe_get_net <S2SV_ModEnd> ( peer )
"
126,"CWE-000 void * getHTTPResponse ( int s , int * size ) { char buf [ 2048 ] ; int n ; int endofheaders = 0 ; int chunked = 0 ; int content_length = - 1 ; unsigned int chunksize = 0 ; unsigned int bytestocopy = 0 ; char * header_buf ; unsigned int header_buf_len = 2048 ; unsigned int header_buf_used = 0 ; char * content_buf ; unsigned int content_buf_len = 2048 ; unsigned int content_buf_used = 0 ; char chunksize_buf [ 32 ] ; unsigned int chunksize_buf_index ; header_buf = malloc ( header_buf_len ) ; content_buf = malloc ( content_buf_len ) ; chunksize_buf [ 0 ] = '\\0' ; chunksize_buf_index = 0 ; while ( ( n = receivedata ( s , buf , 2048 , 5000 , NULL ) ) > 0 ) { if ( endofheaders == 0 ) { int i ; int linestart = 0 ; int colon = 0 ; int valuestart = 0 ; if ( header_buf_used + n > header_buf_len ) { header_buf = realloc ( header_buf , header_buf_used + n ) ; header_buf_len = header_buf_used + n ; } memcpy ( header_buf + header_buf_used , buf , n ) ; header_buf_used += n ; i = 0 ; while ( i < ( ( int ) header_buf_used - 1 ) && ( endofheaders == 0 ) ) { if ( header_buf [ i ] == '\\r' ) { i ++ ; if ( header_buf [ i ] == '\\n' ) { i ++ ; if ( i < ( int ) header_buf_used && header_buf [ i ] == '\\r' ) { i ++ ; if ( i < ( int ) header_buf_used && header_buf [ i ] == '\\n' ) { endofheaders = i + 1 ; } } } } else if ( header_buf [ i ] == '\\n' ) { i ++ ; if ( header_buf [ i ] == '\\n' ) { endofheaders = i + 1 ; } } i ++ ; } if ( endofheaders == 0 ) continue ; for ( i = 0 ; i < endofheaders - 1 ; i ++ ) { if ( colon <= linestart && header_buf [ i ] == ':' ) { colon = i ; while ( i < ( endofheaders - 1 ) && ( header_buf [ i + 1 ] == '<S2SV_blank>' || header_buf [ i + 1 ] == '\\t' ) ) i ++ ; valuestart = i + 1 ; } else if ( header_buf [ i ] == '\\r' || header_buf [ i ] == '\\n' ) { if ( colon > linestart && valuestart > colon ) { # ifdef DEBUG printf ( ""header=\'%.*s\',<S2SV_blank>value=\'%.*s\'\\n"" , colon - linestart , header_buf + linestart , i - valuestart , header_buf + valuestart ) ; # endif if ( 0 == strncasecmp ( header_buf + linestart , ""content-length"" , colon - linestart ) ) { content_length = atoi ( header_buf + valuestart ) ; # ifdef DEBUG printf ( ""Content-Length:<S2SV_blank>%d\\n"" , content_length ) ; # endif } else if ( 0 == strncasecmp ( header_buf + linestart , ""transfer-encoding"" , colon - linestart ) && 0 == strncasecmp ( header_buf + valuestart , ""chunked"" , 7 ) ) { # ifdef DEBUG printf ( ""chunked<S2SV_blank>transfer-encoding!\\n"" ) ; # endif chunked = 1 ; } } <S2SV_StartBug> while ( header_buf [ i ] == '\\r' || header_buf [ i ] == '\\n' ) <S2SV_EndBug> i ++ ; linestart = i ; colon = linestart ; valuestart = 0 ; } } n = header_buf_used - endofheaders ; memcpy ( buf , header_buf + endofheaders , n ) ; } if ( endofheaders ) { if ( chunked ) { int i = 0 ; while ( i < n ) { if ( chunksize == 0 ) { if ( chunksize_buf_index == 0 ) { if ( i < n && buf [ i ] == '\\r' ) i ++ ; if ( i < n && buf [ i ] == '\\n' ) i ++ ; } while ( i < n && isxdigit ( buf [ i ] ) && chunksize_buf_index < ( sizeof ( chunksize_buf ) - 1 ) ) { chunksize_buf [ chunksize_buf_index ++ ] = buf [ i ] ; chunksize_buf [ chunksize_buf_index ] = '\\0' ; i ++ ; } while ( i < n && buf [ i ] != '\\r' && buf [ i ] != '\\n' ) i ++ ; if ( i < n && buf [ i ] == '\\r' ) i ++ ; if ( i < n && buf [ i ] == '\\n' ) { unsigned int j ; for ( j = 0 ; j < chunksize_buf_index ; j ++ ) { if ( chunksize_buf [ j ] >= '0' && chunksize_buf [ j ] <= '9' ) chunksize = ( chunksize << 4 ) + ( chunksize_buf [ j ] - '0' ) ; else chunksize = ( chunksize << 4 ) + ( ( chunksize_buf [ j ] | 32 ) - 'a' + 10 ) ; } chunksize_buf [ 0 ] = '\\0' ; chunksize_buf_index = 0 ; i ++ ; } else { continue ; } # ifdef DEBUG printf ( ""chunksize<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(%x)\\n"" , chunksize , chunksize ) ; # endif if ( chunksize == 0 ) { # ifdef DEBUG printf ( ""end<S2SV_blank>of<S2SV_blank>HTTP<S2SV_blank>content<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>%d\\n"" , i , n ) ; # endif goto end_of_stream ; } } bytestocopy = ( ( int ) chunksize < ( n - i ) ) ? chunksize : ( unsigned int ) ( n - i ) ; if ( ( content_buf_used + bytestocopy ) > content_buf_len ) { if ( content_length >= ( int ) ( content_buf_used + bytestocopy ) ) { content_buf_len = content_length ; } else { content_buf_len = content_buf_used + bytestocopy ; } content_buf = ( char * ) realloc ( ( void * ) content_buf , content_buf_len ) ; } memcpy ( content_buf + content_buf_used , buf + i , bytestocopy ) ; content_buf_used += bytestocopy ; i += bytestocopy ; chunksize -= bytestocopy ; } } else { if ( content_length > 0 && ( int ) ( content_buf_used + n ) > content_length ) { n = content_length - content_buf_used ; } if ( content_buf_used + n > content_buf_len ) { if ( content_length >= ( int ) ( content_buf_used + n ) ) { content_buf_len = content_length ; } else { content_buf_len = content_buf_used + n ; } content_buf = ( char * ) realloc ( ( void * ) content_buf , content_buf_len ) ; } memcpy ( content_buf + content_buf_used , buf , n ) ; content_buf_used += n ; } } if ( content_length > 0 && ( int ) content_buf_used >= content_length ) { # ifdef DEBUG printf ( ""End<S2SV_blank>of<S2SV_blank>HTTP<S2SV_blank>content\\n"" ) ; # endif break ; } } end_of_stream : free ( header_buf ) ; header_buf = NULL ; * size = content_buf_used ; if ( content_buf_used == 0 ) { free ( content_buf ) ; content_buf = NULL ; } return content_buf ; }
","<S2SV_ModStart> } while ( ( i < ( int ) header_buf_used ) && ( <S2SV_ModStart> ] == '\\n' )
"
127,"CWE-617 static int _lldp_send ( struct lldpd * global , struct lldpd_hardware * hardware , u_int8_t c_id_subtype , char * c_id , int c_id_len , u_int8_t p_id_subtype , char * p_id , int p_id_len , int shutdown ) { struct lldpd_port * port ; struct lldpd_chassis * chassis ; struct lldpd_frame * frame ; int length ; u_int8_t * packet , * pos , * tlv ; struct lldpd_mgmt * mgmt ; int proto ; u_int8_t mcastaddr [ ] = LLDP_MULTICAST_ADDR ; # ifdef ENABLE_DOT1 const u_int8_t dot1 [ ] = LLDP_TLV_ORG_DOT1 ; struct lldpd_vlan * vlan ; struct lldpd_ppvid * ppvid ; struct lldpd_pi * pi ; # endif # ifdef ENABLE_DOT3 const u_int8_t dot3 [ ] = LLDP_TLV_ORG_DOT3 ; # endif # ifdef ENABLE_LLDPMED int i ; const u_int8_t med [ ] = LLDP_TLV_ORG_MED ; # endif # ifdef ENABLE_CUSTOM struct lldpd_custom * custom ; # endif port = & hardware -> h_lport ; chassis = port -> p_chassis ; length = hardware -> h_mtu ; if ( ( packet = ( u_int8_t * ) calloc ( 1 , length ) ) == NULL ) return ENOMEM ; pos = packet ; if ( ! ( POKE_BYTES ( mcastaddr , sizeof ( mcastaddr ) ) && POKE_BYTES ( & hardware -> h_lladdr , ETHER_ADDR_LEN ) && POKE_UINT16 ( ETHERTYPE_LLDP ) ) ) goto toobig ; if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_CHASSIS_ID ) && POKE_UINT8 ( c_id_subtype ) && POKE_BYTES ( c_id , c_id_len ) && POKE_END_LLDP_TLV ) ) goto toobig ; if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_PORT_ID ) && POKE_UINT8 ( p_id_subtype ) && POKE_BYTES ( p_id , p_id_len ) && POKE_END_LLDP_TLV ) ) goto toobig ; if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_TTL ) && POKE_UINT16 ( shutdown ? 0 : chassis -> c_ttl ) && POKE_END_LLDP_TLV ) ) goto toobig ; if ( shutdown ) goto end ; if ( chassis -> c_name && * chassis -> c_name != '\\0' ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_SYSTEM_NAME ) && POKE_BYTES ( chassis -> c_name , strlen ( chassis -> c_name ) ) && POKE_END_LLDP_TLV ) ) goto toobig ; } if ( chassis -> c_descr && * chassis -> c_descr != '\\0' ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_SYSTEM_DESCR ) && POKE_BYTES ( chassis -> c_descr , strlen ( chassis -> c_descr ) ) && POKE_END_LLDP_TLV ) ) goto toobig ; } if ( global -> g_config . c_cap_advertise && chassis -> c_cap_available ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_SYSTEM_CAP ) && POKE_UINT16 ( chassis -> c_cap_available ) && POKE_UINT16 ( chassis -> c_cap_enabled ) && POKE_END_LLDP_TLV ) ) goto toobig ; } TAILQ_FOREACH ( mgmt , & chassis -> c_mgmt , m_entries ) { proto = lldpd_af_to_lldp_proto ( mgmt -> m_family ) ; <S2SV_StartBug> assert ( proto != LLDP_MGMT_ADDR_NONE ) ; <S2SV_EndBug> if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_MGMT_ADDR ) && POKE_UINT8 ( mgmt -> m_addrsize + 1 ) && POKE_UINT8 ( proto ) && POKE_BYTES ( & mgmt -> m_addr , mgmt -> m_addrsize ) ) ) goto toobig ; if ( mgmt -> m_iface == 0 ) { if ( ! ( POKE_UINT8 ( LLDP_MGMT_IFACE_UNKNOWN ) && POKE_UINT32 ( 0 ) ) ) goto toobig ; } else { if ( ! ( POKE_UINT8 ( LLDP_MGMT_IFACE_IFINDEX ) && POKE_UINT32 ( mgmt -> m_iface ) ) ) goto toobig ; } if ( ! ( POKE_UINT8 ( 0 ) && POKE_END_LLDP_TLV ) ) goto toobig ; } if ( port -> p_descr && * port -> p_descr != '\\0' ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_PORT_DESCR ) && POKE_BYTES ( port -> p_descr , strlen ( port -> p_descr ) ) && POKE_END_LLDP_TLV ) ) goto toobig ; } # ifdef ENABLE_DOT1 if ( port -> p_pvid != 0 ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot1 , sizeof ( dot1 ) ) && POKE_UINT8 ( LLDP_TLV_DOT1_PVID ) && POKE_UINT16 ( port -> p_pvid ) && POKE_END_LLDP_TLV ) ) { goto toobig ; } } TAILQ_FOREACH ( ppvid , & port -> p_ppvids , p_entries ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot1 , sizeof ( dot1 ) ) && POKE_UINT8 ( LLDP_TLV_DOT1_PPVID ) && POKE_UINT8 ( ppvid -> p_cap_status ) && POKE_UINT16 ( ppvid -> p_ppvid ) && POKE_END_LLDP_TLV ) ) { goto toobig ; } } TAILQ_FOREACH ( vlan , & port -> p_vlans , v_entries ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot1 , sizeof ( dot1 ) ) && POKE_UINT8 ( LLDP_TLV_DOT1_VLANNAME ) && POKE_UINT16 ( vlan -> v_vid ) && POKE_UINT8 ( strlen ( vlan -> v_name ) ) && POKE_BYTES ( vlan -> v_name , strlen ( vlan -> v_name ) ) && POKE_END_LLDP_TLV ) ) goto toobig ; } TAILQ_FOREACH ( pi , & port -> p_pids , p_entries ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot1 , sizeof ( dot1 ) ) && POKE_UINT8 ( LLDP_TLV_DOT1_PI ) && POKE_UINT8 ( pi -> p_pi_len ) && POKE_BYTES ( pi -> p_pi , pi -> p_pi_len ) && POKE_END_LLDP_TLV ) ) goto toobig ; } # endif # ifdef ENABLE_DOT3 if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot3 , sizeof ( dot3 ) ) && POKE_UINT8 ( LLDP_TLV_DOT3_LA ) && POKE_UINT8 ( ( port -> p_aggregid ) ? 3 : 1 ) && POKE_UINT32 ( port -> p_aggregid ) && POKE_END_LLDP_TLV ) ) goto toobig ; if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot3 , sizeof ( dot3 ) ) && POKE_UINT8 ( LLDP_TLV_DOT3_MAC ) && POKE_UINT8 ( port -> p_macphy . autoneg_support | ( port -> p_macphy . autoneg_enabled << 1 ) ) && POKE_UINT16 ( port -> p_macphy . autoneg_advertised ) && POKE_UINT16 ( port -> p_macphy . mau_type ) && POKE_END_LLDP_TLV ) ) goto toobig ; if ( port -> p_mfs ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot3 , sizeof ( dot3 ) ) && POKE_UINT8 ( LLDP_TLV_DOT3_MFS ) && POKE_UINT16 ( port -> p_mfs ) && POKE_END_LLDP_TLV ) ) goto toobig ; } if ( port -> p_power . devicetype ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( dot3 , sizeof ( dot3 ) ) && POKE_UINT8 ( LLDP_TLV_DOT3_POWER ) && POKE_UINT8 ( ( ( ( ( 2 - port -> p_power . devicetype ) % ( 1 << 1 ) ) << 0 ) | ( ( port -> p_power . supported % ( 1 << 1 ) ) << 1 ) | ( ( port -> p_power . enabled % ( 1 << 1 ) ) << 2 ) | ( ( port -> p_power . paircontrol % ( 1 << 1 ) ) << 3 ) ) ) && POKE_UINT8 ( port -> p_power . pairs ) && POKE_UINT8 ( port -> p_power . class ) ) ) goto toobig ; if ( port -> p_power . powertype != LLDP_DOT3_POWER_8023AT_OFF ) { if ( ! ( POKE_UINT8 ( ( ( ( ( port -> p_power . powertype == LLDP_DOT3_POWER_8023AT_TYPE1 ) ? 1 : 0 ) << 7 ) | ( ( ( port -> p_power . devicetype == LLDP_DOT3_POWER_PSE ) ? 0 : 1 ) << 6 ) | ( ( port -> p_power . source % ( 1 << 2 ) ) << 4 ) | ( ( port -> p_power . priority % ( 1 << 2 ) ) << 0 ) ) ) && POKE_UINT16 ( port -> p_power . requested ) && POKE_UINT16 ( port -> p_power . allocated ) ) ) goto toobig ; } if ( ! ( POKE_END_LLDP_TLV ) ) goto toobig ; } # endif # ifdef ENABLE_LLDPMED if ( port -> p_med_cap_enabled ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( med , sizeof ( med ) ) && POKE_UINT8 ( LLDP_TLV_MED_CAP ) && POKE_UINT16 ( chassis -> c_med_cap_available ) && POKE_UINT8 ( chassis -> c_med_type ) && POKE_END_LLDP_TLV ) ) goto toobig ; # define LLDP_INVENTORY ( value , subtype ) if ( value ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( med , sizeof ( med ) ) && POKE_UINT8 ( subtype ) && POKE_BYTES ( value , ( strlen ( value ) > 32 ) ? 32 : strlen ( value ) ) && POKE_END_LLDP_TLV ) ) goto toobig ; } if ( port -> p_med_cap_enabled & LLDP_MED_CAP_IV ) { LLDP_INVENTORY ( chassis -> c_med_hw , LLDP_TLV_MED_IV_HW ) ; LLDP_INVENTORY ( chassis -> c_med_fw , LLDP_TLV_MED_IV_FW ) ; LLDP_INVENTORY ( chassis -> c_med_sw , LLDP_TLV_MED_IV_SW ) ; LLDP_INVENTORY ( chassis -> c_med_sn , LLDP_TLV_MED_IV_SN ) ; LLDP_INVENTORY ( chassis -> c_med_manuf , LLDP_TLV_MED_IV_MANUF ) ; LLDP_INVENTORY ( chassis -> c_med_model , LLDP_TLV_MED_IV_MODEL ) ; LLDP_INVENTORY ( chassis -> c_med_asset , LLDP_TLV_MED_IV_ASSET ) ; } for ( i = 0 ; i < LLDP_MED_LOCFORMAT_LAST ; i ++ ) { if ( port -> p_med_location [ i ] . format == i + 1 ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( med , sizeof ( med ) ) && POKE_UINT8 ( LLDP_TLV_MED_LOCATION ) && POKE_UINT8 ( port -> p_med_location [ i ] . format ) && POKE_BYTES ( port -> p_med_location [ i ] . data , port -> p_med_location [ i ] . data_len ) && POKE_END_LLDP_TLV ) ) goto toobig ; } } for ( i = 0 ; i < LLDP_MED_APPTYPE_LAST ; i ++ ) { if ( port -> p_med_policy [ i ] . type == i + 1 ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( med , sizeof ( med ) ) && POKE_UINT8 ( LLDP_TLV_MED_POLICY ) && POKE_UINT32 ( ( ( ( port -> p_med_policy [ i ] . type % ( 1 << 8 ) ) << 24 ) | ( ( port -> p_med_policy [ i ] . unknown % ( 1 << 1 ) ) << 23 ) | ( ( port -> p_med_policy [ i ] . tagged % ( 1 << 1 ) ) << 22 ) | ( ( port -> p_med_policy [ i ] . vid % ( 1 << 12 ) ) << 9 ) | ( ( port -> p_med_policy [ i ] . priority % ( 1 << 3 ) ) << 6 ) | ( ( port -> p_med_policy [ i ] . dscp % ( 1 << 6 ) ) << 0 ) ) ) && POKE_END_LLDP_TLV ) ) goto toobig ; } } if ( ( port -> p_med_power . devicetype == LLDP_MED_POW_TYPE_PSE ) || ( port -> p_med_power . devicetype == LLDP_MED_POW_TYPE_PD ) ) { int devicetype = 0 , source = 0 ; if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( med , sizeof ( med ) ) && POKE_UINT8 ( LLDP_TLV_MED_MDI ) ) ) goto toobig ; switch ( port -> p_med_power . devicetype ) { case LLDP_MED_POW_TYPE_PSE : devicetype = 0 ; switch ( port -> p_med_power . source ) { case LLDP_MED_POW_SOURCE_PRIMARY : source = 1 ; break ; case LLDP_MED_POW_SOURCE_BACKUP : source = 2 ; break ; case LLDP_MED_POW_SOURCE_RESERVED : source = 3 ; break ; default : source = 0 ; break ; } break ; case LLDP_MED_POW_TYPE_PD : devicetype = 1 ; switch ( port -> p_med_power . source ) { case LLDP_MED_POW_SOURCE_PSE : source = 1 ; break ; case LLDP_MED_POW_SOURCE_LOCAL : source = 2 ; break ; case LLDP_MED_POW_SOURCE_BOTH : source = 3 ; break ; default : source = 0 ; break ; } break ; } if ( ! ( POKE_UINT8 ( ( ( ( devicetype % ( 1 << 2 ) ) << 6 ) | ( ( source % ( 1 << 2 ) ) << 4 ) | ( ( port -> p_med_power . priority % ( 1 << 4 ) ) << 0 ) ) ) && POKE_UINT16 ( port -> p_med_power . val ) && POKE_END_LLDP_TLV ) ) goto toobig ; } } # endif # ifdef ENABLE_CUSTOM TAILQ_FOREACH ( custom , & port -> p_custom_list , next ) { if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_ORG ) && POKE_BYTES ( custom -> oui , sizeof ( custom -> oui ) ) && POKE_UINT8 ( custom -> subtype ) && POKE_BYTES ( custom -> oui_info , custom -> oui_info_len ) && POKE_END_LLDP_TLV ) ) goto toobig ; } # endif end : if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_END ) && POKE_END_LLDP_TLV ) ) goto toobig ; if ( interfaces_send_helper ( global , hardware , ( char * ) packet , pos - packet ) == - 1 ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>send<S2SV_blank>packet<S2SV_blank>on<S2SV_blank>real<S2SV_blank>device<S2SV_blank>for<S2SV_blank>%s"" , hardware -> h_ifname ) ; free ( packet ) ; return ENETDOWN ; } hardware -> h_tx_cnt ++ ; if ( ! shutdown && ( frame = ( struct lldpd_frame * ) malloc ( sizeof ( int ) + pos - packet ) ) != NULL ) { frame -> size = pos - packet ; memcpy ( & frame -> frame , packet , frame -> size ) ; if ( ( hardware -> h_lport . p_lastframe == NULL ) || ( hardware -> h_lport . p_lastframe -> size != frame -> size ) || ( memcmp ( hardware -> h_lport . p_lastframe -> frame , frame -> frame , frame -> size ) != 0 ) ) { free ( hardware -> h_lport . p_lastframe ) ; hardware -> h_lport . p_lastframe = frame ; hardware -> h_lport . p_lastchange = time ( NULL ) ; } else free ( frame ) ; } free ( packet ) ; return 0 ; toobig : free ( packet ) ; return E2BIG ; }
","<S2SV_ModStart> m_family ) ; if ( proto == LLDP_MGMT_ADDR_NONE ) continue <S2SV_ModEnd> ; if (
"
128,"CWE-310 int asn1_ber_decoder ( const struct asn1_decoder * decoder , void * context , const unsigned char * data , size_t datalen ) { const unsigned char * machine = decoder -> machine ; const asn1_action_t * actions = decoder -> actions ; size_t machlen = decoder -> machlen ; enum asn1_opcode op ; unsigned char tag = 0 , csp = 0 , jsp = 0 , optag = 0 , hdr = 0 ; const char * errmsg ; size_t pc = 0 , dp = 0 , tdp = 0 , len = 0 ; int ret ; unsigned char flags = 0 ; # define FLAG_INDEFINITE_LENGTH 0x01 # define FLAG_MATCHED 0x02 # define FLAG_LAST_MATCHED 0x04 # define FLAG_CONS 0x20 # define NR_CONS_STACK 10 unsigned short cons_dp_stack [ NR_CONS_STACK ] ; unsigned short cons_datalen_stack [ NR_CONS_STACK ] ; unsigned char cons_hdrlen_stack [ NR_CONS_STACK ] ; # define NR_JUMP_STACK 10 unsigned char jump_stack [ NR_JUMP_STACK ] ; if ( datalen > 65535 ) return - EMSGSIZE ; next_op : pr_debug ( ""next_op:<S2SV_blank>pc=\\e[32m%zu\\e[m/%zu<S2SV_blank>dp=\\e[33m%zu\\e[m/%zu<S2SV_blank>C=%d<S2SV_blank>J=%d\\n"" , pc , machlen , dp , datalen , csp , jsp ) ; if ( unlikely ( pc >= machlen ) ) goto machine_overrun_error ; op = machine [ pc ] ; if ( unlikely ( pc + asn1_op_lengths [ op ] > machlen ) ) goto machine_overrun_error ; if ( op <= ASN1_OP__MATCHES_TAG ) { unsigned char tmp ; if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) || <S2SV_StartBug> dp == datalen ) { <S2SV_EndBug> flags &= ~ FLAG_LAST_MATCHED ; pc += asn1_op_lengths [ op ] ; goto next_op ; } flags = 0 ; hdr = 2 ; if ( unlikely ( dp >= datalen - 1 ) ) goto data_overrun_error ; tag = data [ dp ++ ] ; if ( unlikely ( ( tag & 0x1f ) == ASN1_LONG_TAG ) ) goto long_tag_not_supported ; if ( op & ASN1_OP_MATCH__ANY ) { pr_debug ( ""-<S2SV_blank>any<S2SV_blank>%02x\\n"" , tag ) ; } else { optag = machine [ pc + 1 ] ; flags |= optag & FLAG_CONS ; tmp = optag ^ tag ; tmp &= ~ ( optag & ASN1_CONS_BIT ) ; pr_debug ( ""-<S2SV_blank>match?<S2SV_blank>%02x<S2SV_blank>%02x<S2SV_blank>%02x\\n"" , tag , optag , tmp ) ; if ( tmp != 0 ) { if ( op & ASN1_OP_MATCH__SKIP ) { pc += asn1_op_lengths [ op ] ; dp -- ; goto next_op ; } goto tag_mismatch ; } } flags |= FLAG_MATCHED ; len = data [ dp ++ ] ; if ( len > 0x7f ) { if ( unlikely ( len == ASN1_INDEFINITE_LENGTH ) ) { if ( unlikely ( ! ( tag & ASN1_CONS_BIT ) ) ) goto indefinite_len_primitive ; flags |= FLAG_INDEFINITE_LENGTH ; if ( unlikely ( 2 > datalen - dp ) ) goto data_overrun_error ; } else { int n = len - 0x80 ; if ( unlikely ( n > 2 ) ) goto length_too_long ; if ( unlikely ( dp >= datalen - n ) ) goto data_overrun_error ; hdr += n ; for ( len = 0 ; n > 0 ; n -- ) { len <<= 8 ; len |= data [ dp ++ ] ; } if ( unlikely ( len > datalen - dp ) ) goto data_overrun_error ; } } if ( flags & FLAG_CONS ) { if ( unlikely ( csp >= NR_CONS_STACK ) ) goto cons_stack_overflow ; cons_dp_stack [ csp ] = dp ; cons_hdrlen_stack [ csp ] = hdr ; if ( ! ( flags & FLAG_INDEFINITE_LENGTH ) ) { cons_datalen_stack [ csp ] = datalen ; datalen = dp + len ; } else { cons_datalen_stack [ csp ] = 0 ; } csp ++ ; } pr_debug ( ""-<S2SV_blank>TAG:<S2SV_blank>%02x<S2SV_blank>%zu%s\\n"" , tag , len , flags & FLAG_CONS ? ""<S2SV_blank>CONS"" : """" ) ; tdp = dp ; } switch ( op ) { case ASN1_OP_MATCH_ANY_ACT : case ASN1_OP_COND_MATCH_ANY_ACT : ret = actions [ machine [ pc + 1 ] ] ( context , hdr , tag , data + dp , len ) ; if ( ret < 0 ) return ret ; goto skip_data ; case ASN1_OP_MATCH_ACT : case ASN1_OP_MATCH_ACT_OR_SKIP : case ASN1_OP_COND_MATCH_ACT_OR_SKIP : ret = actions [ machine [ pc + 2 ] ] ( context , hdr , tag , data + dp , len ) ; if ( ret < 0 ) return ret ; goto skip_data ; case ASN1_OP_MATCH : case ASN1_OP_MATCH_OR_SKIP : case ASN1_OP_MATCH_ANY : case ASN1_OP_COND_MATCH_OR_SKIP : case ASN1_OP_COND_MATCH_ANY : skip_data : if ( ! ( flags & FLAG_CONS ) ) { if ( flags & FLAG_INDEFINITE_LENGTH ) { ret = asn1_find_indefinite_length ( data , datalen , & dp , & len , & errmsg ) ; if ( ret < 0 ) goto error ; } else { dp += len ; } pr_debug ( ""-<S2SV_blank>LEAF:<S2SV_blank>%zu\\n"" , len ) ; } pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_MATCH_JUMP : case ASN1_OP_MATCH_JUMP_OR_SKIP : case ASN1_OP_COND_MATCH_JUMP_OR_SKIP : pr_debug ( ""-<S2SV_blank>MATCH_JUMP\\n"" ) ; if ( unlikely ( jsp == NR_JUMP_STACK ) ) goto jump_stack_overflow ; jump_stack [ jsp ++ ] = pc + asn1_op_lengths [ op ] ; pc = machine [ pc + 2 ] ; goto next_op ; case ASN1_OP_COND_FAIL : if ( unlikely ( ! ( flags & FLAG_MATCHED ) ) ) goto tag_mismatch ; pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_COMPLETE : if ( unlikely ( jsp != 0 || csp != 0 ) ) { pr_err ( ""ASN.1<S2SV_blank>decoder<S2SV_blank>error:<S2SV_blank>Stacks<S2SV_blank>not<S2SV_blank>empty<S2SV_blank>at<S2SV_blank>completion<S2SV_blank>(%u,<S2SV_blank>%u)\\n"" , jsp , csp ) ; return - EBADMSG ; } return 0 ; case ASN1_OP_END_SET : case ASN1_OP_END_SET_ACT : if ( unlikely ( ! ( flags & FLAG_MATCHED ) ) ) goto tag_mismatch ; case ASN1_OP_END_SEQ : case ASN1_OP_END_SET_OF : case ASN1_OP_END_SEQ_OF : case ASN1_OP_END_SEQ_ACT : case ASN1_OP_END_SET_OF_ACT : case ASN1_OP_END_SEQ_OF_ACT : if ( unlikely ( csp <= 0 ) ) goto cons_stack_underflow ; csp -- ; tdp = cons_dp_stack [ csp ] ; hdr = cons_hdrlen_stack [ csp ] ; len = datalen ; datalen = cons_datalen_stack [ csp ] ; pr_debug ( ""-<S2SV_blank>end<S2SV_blank>cons<S2SV_blank>t=%zu<S2SV_blank>dp=%zu<S2SV_blank>l=%zu/%zu\\n"" , tdp , dp , len , datalen ) ; if ( datalen == 0 ) { datalen = len ; if ( unlikely ( datalen - dp < 2 ) ) goto data_overrun_error ; if ( data [ dp ++ ] != 0 ) { if ( op & ASN1_OP_END__OF ) { dp -- ; csp ++ ; pc = machine [ pc + 1 ] ; pr_debug ( ""-<S2SV_blank>continue\\n"" ) ; goto next_op ; } goto missing_eoc ; } if ( data [ dp ++ ] != 0 ) goto invalid_eoc ; len = dp - tdp - 2 ; } else { if ( dp < len && ( op & ASN1_OP_END__OF ) ) { datalen = len ; csp ++ ; pc = machine [ pc + 1 ] ; pr_debug ( ""-<S2SV_blank>continue\\n"" ) ; goto next_op ; } if ( dp != len ) goto cons_length_error ; len -= tdp ; pr_debug ( ""-<S2SV_blank>cons<S2SV_blank>len<S2SV_blank>l=%zu<S2SV_blank>d=%zu\\n"" , len , dp - tdp ) ; } if ( op & ASN1_OP_END__ACT ) { unsigned char act ; if ( op & ASN1_OP_END__OF ) act = machine [ pc + 2 ] ; else act = machine [ pc + 1 ] ; ret = actions [ act ] ( context , hdr , 0 , data + tdp , len ) ; } pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_MAYBE_ACT : if ( ! ( flags & FLAG_LAST_MATCHED ) ) { pc += asn1_op_lengths [ op ] ; goto next_op ; } case ASN1_OP_ACT : ret = actions [ machine [ pc + 1 ] ] ( context , hdr , tag , data + tdp , len ) ; if ( ret < 0 ) return ret ; pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_RETURN : if ( unlikely ( jsp <= 0 ) ) goto jump_stack_underflow ; pc = jump_stack [ -- jsp ] ; flags |= FLAG_MATCHED | FLAG_LAST_MATCHED ; goto next_op ; default : break ; } pr_err ( ""ASN.1<S2SV_blank>decoder<S2SV_blank>error:<S2SV_blank>Found<S2SV_blank>reserved<S2SV_blank>opcode<S2SV_blank>(%u)<S2SV_blank>pc=%zu\\n"" , op , pc ) ; return - EBADMSG ; data_overrun_error : errmsg = ""Data<S2SV_blank>overrun<S2SV_blank>error"" ; goto error ; machine_overrun_error : errmsg = ""Machine<S2SV_blank>overrun<S2SV_blank>error"" ; goto error ; jump_stack_underflow : errmsg = ""Jump<S2SV_blank>stack<S2SV_blank>underflow"" ; goto error ; jump_stack_overflow : errmsg = ""Jump<S2SV_blank>stack<S2SV_blank>overflow"" ; goto error ; cons_stack_underflow : errmsg = ""Cons<S2SV_blank>stack<S2SV_blank>underflow"" ; goto error ; cons_stack_overflow : errmsg = ""Cons<S2SV_blank>stack<S2SV_blank>overflow"" ; goto error ; cons_length_error : errmsg = ""Cons<S2SV_blank>length<S2SV_blank>error"" ; goto error ; missing_eoc : errmsg = ""Missing<S2SV_blank>EOC<S2SV_blank>in<S2SV_blank>indefinite<S2SV_blank>len<S2SV_blank>cons"" ; goto error ; invalid_eoc : errmsg = ""Invalid<S2SV_blank>length<S2SV_blank>EOC"" ; goto error ; length_too_long : errmsg = ""Unsupported<S2SV_blank>length"" ; goto error ; indefinite_len_primitive : errmsg = ""Indefinite<S2SV_blank>len<S2SV_blank>primitive<S2SV_blank>not<S2SV_blank>permitted"" ; goto error ; tag_mismatch : errmsg = ""Unexpected<S2SV_blank>tag"" ; goto error ; long_tag_not_supported : errmsg = ""Long<S2SV_blank>tag<S2SV_blank>not<S2SV_blank>supported"" ; error : pr_debug ( ""\\nASN1:<S2SV_blank>%s<S2SV_blank>[m=%zu<S2SV_blank>d=%zu<S2SV_blank>ot=%02x<S2SV_blank>t=%02x<S2SV_blank>l=%zu]\\n"" , errmsg , pc , dp , optag , tag , len ) ; return - EBADMSG ; }
","<S2SV_ModStart> FLAG_MATCHED ) || ( op & ASN1_OP_MATCH__SKIP && <S2SV_ModStart> dp == datalen )
"
129,"CWE-362 static int sctp_init_sock ( struct sock * sk ) { struct net * net = sock_net ( sk ) ; struct sctp_sock * sp ; pr_debug ( ""%s:<S2SV_blank>sk:%p\\n"" , __func__ , sk ) ; sp = sctp_sk ( sk ) ; switch ( sk -> sk_type ) { case SOCK_SEQPACKET : sp -> type = SCTP_SOCKET_UDP ; break ; case SOCK_STREAM : sp -> type = SCTP_SOCKET_TCP ; break ; default : return - ESOCKTNOSUPPORT ; } sp -> default_stream = 0 ; sp -> default_ppid = 0 ; sp -> default_flags = 0 ; sp -> default_context = 0 ; sp -> default_timetolive = 0 ; sp -> default_rcv_context = 0 ; sp -> max_burst = net -> sctp . max_burst ; sp -> sctp_hmac_alg = net -> sctp . sctp_hmac_alg ; sp -> initmsg . sinit_num_ostreams = sctp_max_outstreams ; sp -> initmsg . sinit_max_instreams = sctp_max_instreams ; sp -> initmsg . sinit_max_attempts = net -> sctp . max_retrans_init ; sp -> initmsg . sinit_max_init_timeo = net -> sctp . rto_max ; sp -> rtoinfo . srto_initial = net -> sctp . rto_initial ; sp -> rtoinfo . srto_max = net -> sctp . rto_max ; sp -> rtoinfo . srto_min = net -> sctp . rto_min ; sp -> assocparams . sasoc_asocmaxrxt = net -> sctp . max_retrans_association ; sp -> assocparams . sasoc_number_peer_destinations = 0 ; sp -> assocparams . sasoc_peer_rwnd = 0 ; sp -> assocparams . sasoc_local_rwnd = 0 ; sp -> assocparams . sasoc_cookie_life = net -> sctp . valid_cookie_life ; memset ( & sp -> subscribe , 0 , sizeof ( struct sctp_event_subscribe ) ) ; sp -> hbinterval = net -> sctp . hb_interval ; sp -> pathmaxrxt = net -> sctp . max_retrans_path ; sp -> pathmtu = 0 ; sp -> sackdelay = net -> sctp . sack_timeout ; sp -> sackfreq = 2 ; sp -> param_flags = SPP_HB_ENABLE | SPP_PMTUD_ENABLE | SPP_SACKDELAY_ENABLE ; sp -> disable_fragments = 0 ; sp -> nodelay = 0 ; sp -> recvrcvinfo = 0 ; sp -> recvnxtinfo = 0 ; sp -> v4mapped = 1 ; sp -> autoclose = 0 ; sp -> user_frag = 0 ; sp -> adaptation_ind = 0 ; sp -> pf = sctp_get_pf_specific ( sk -> sk_family ) ; atomic_set ( & sp -> pd_mode , 0 ) ; skb_queue_head_init ( & sp -> pd_lobby ) ; sp -> frag_interleave = 0 ; sp -> ep = sctp_endpoint_new ( sk , GFP_KERNEL ) ; if ( ! sp -> ep ) return - ENOMEM ; sp -> hmac = NULL ; sk -> sk_destruct = sctp_destruct_sock ; SCTP_DBG_OBJCNT_INC ( sock ) ; local_bh_disable ( ) ; percpu_counter_inc ( & sctp_sockets_allocated ) ; sock_prot_inuse_add ( net , sk -> sk_prot , 1 ) ; if ( net -> sctp . default_auto_asconf ) { <S2SV_StartBug> list_add_tail ( & sp -> auto_asconf_list , <S2SV_EndBug> & net -> sctp . auto_asconf_splist ) ; <S2SV_StartBug> sp -> do_auto_asconf = 1 ; <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> sp -> do_auto_asconf = 0 ; <S2SV_EndBug> local_bh_enable ( ) ; return 0 ; }
","<S2SV_ModStart> default_auto_asconf ) { spin_lock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; <S2SV_ModStart> do_auto_asconf = 1 ; spin_unlock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) <S2SV_ModStart> ; } else { <S2SV_ModStart> = 0 ; }
"
130,"CWE-476 <S2SV_StartBug> static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb ) <S2SV_EndBug> { s -> avctx -> profile = get_bits ( gb , 4 ) ; <S2SV_StartBug> s -> avctx -> level = get_bits ( gb , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( s -> avctx -> profile == 0 && s -> avctx -> level == 8 ) { <S2SV_EndBug> <S2SV_StartBug> s -> avctx -> level = 0 ; <S2SV_EndBug> } return 0 ; }
","<S2SV_ModStart> GetBitContext * gb , int * profile , int * level ) { * <S2SV_ModEnd> profile = get_bits <S2SV_ModStart> 4 ) ; * <S2SV_ModEnd> level = get_bits <S2SV_ModStart> ; if ( * <S2SV_ModEnd> profile == 0 <S2SV_ModStart> == 0 && * <S2SV_ModEnd> level == 8 <S2SV_ModStart> 8 ) { * <S2SV_ModEnd> level = 0
"
131,"CWE-125 void snd_msndmidi_input_read ( void * mpuv ) { unsigned long flags ; struct snd_msndmidi * mpu = mpuv ; void * pwMIDQData = mpu -> dev -> mappedbase + MIDQ_DATA_BUFF ; <S2SV_StartBug> spin_lock_irqsave ( & mpu -> input_lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> while ( readw ( mpu -> dev -> MIDQ + JQS_wTail ) != <S2SV_EndBug> readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) { u16 wTmp , val ; val = readw ( pwMIDQData + 2 * readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , ( unsigned char * ) & val , 1 ) ; <S2SV_StartBug> wTmp = readw ( mpu -> dev -> MIDQ + JQS_wHead ) + 1 ; <S2SV_EndBug> if ( wTmp > readw ( mpu -> dev -> MIDQ + JQS_wSize ) ) writew ( 0 , mpu -> dev -> MIDQ + JQS_wHead ) ; else writew ( wTmp , mpu -> dev -> MIDQ + JQS_wHead ) ; } spin_unlock_irqrestore ( & mpu -> input_lock , flags ) ; }
","<S2SV_ModStart> + MIDQ_DATA_BUFF ; u16 head , tail , size ; <S2SV_ModStart> flags ) ; head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ; tail = readw ( mpu -> dev -> MIDQ + JQS_wTail ) ; size = readw ( mpu -> dev -> MIDQ + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { unsigned char val = readw ( pwMIDQData + 2 * head ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , & val <S2SV_ModEnd> , 1 ) <S2SV_ModStart> 1 ) ; if ( ++ head > size ) head = 0 ; writew ( head , <S2SV_ModEnd> mpu -> dev <S2SV_ModStart> + JQS_wHead ) ; } out : <S2SV_ModEnd> spin_unlock_irqrestore ( &
"
132,"CWE-264 static int ima_lsm_rule_init ( struct ima_measure_rule_entry * entry , char * args , int lsm_rule , int audit_type ) { int result ; if ( entry -> lsm [ lsm_rule ] . rule ) return - EINVAL ; entry -> lsm [ lsm_rule ] . type = audit_type ; result = security_filter_rule_init ( entry -> lsm [ lsm_rule ] . type , Audit_equal , args , & entry -> lsm [ lsm_rule ] . rule ) ; <S2SV_StartBug> return result ; <S2SV_EndBug> }
","<S2SV_ModStart> rule ) ; if ( ! entry -> lsm [ lsm_rule ] . rule ) return - EINVAL ;
"
133,"CWE-17 void put_filp ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { security_file_free ( file ) ; <S2SV_StartBug> file_sb_list_del ( file ) ; <S2SV_EndBug> file_free ( file ) ; } }
","<S2SV_ModStart> file ) ; <S2SV_ModEnd> file_free ( file
"
134,"CWE-20 static void ikev2_parent_inI1outR1_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct ke_continuation * ke = ( struct ke_continuation * ) pcrc ; struct msg_digest * md = ke -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( ""ikev2<S2SV_blank>parent<S2SV_blank>inI1outR1:<S2SV_blank>calculated<S2SV_blank>ke+nonce,<S2SV_blank>sending<S2SV_blank>R1"" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , ""%s:<S2SV_blank>Request<S2SV_blank>was<S2SV_blank>disconnected<S2SV_blank>from<S2SV_blank>state"" , __FUNCTION__ ) ; if ( ke -> md ) release_md ( ke -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == ke -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_inI1outR1_tail ( pcrc , r ) ; if ( ke -> md != NULL ) { complete_v2_state_transition ( & ke -> md , e ) ; if ( ke -> md ) release_md ( ke -> md ) ; } reset_globals ( ) ; <S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
135,"CWE-79 static int oidc_handle_session_management_iframe_rp ( request_rec * r , oidc_cfg * c , oidc_session_t * session , const char * client_id , const char * check_session_iframe ) { oidc_debug ( r , ""enter"" ) ; const char * java_script = ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><script<S2SV_blank>type=\\""text/javascript\\"">\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>targetOrigin<S2SV_blank><S2SV_blank>=<S2SV_blank>\'%s\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>message<S2SV_blank>=<S2SV_blank>\'%s\'<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>\'%s\';\\n"" ""\t<S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>timerID;\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>checkSession()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'checkSession:<S2SV_blank>posting<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>message<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>to<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>targetOrigin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>win<S2SV_blank>=<S2SV_blank>window.parent.document.getElementById(\'%s\').contentWindow;\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>win.postMessage(<S2SV_blank>message,<S2SV_blank>targetOrigin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n"" <S2SV_StartBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%s);\\n"" <S2SV_EndBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.data<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>from<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.origin);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.origin<S2SV_blank>!==<S2SV_blank>targetOrigin<S2SV_blank>)<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>cross-site<S2SV_blank>scripting<S2SV_blank>attack?\');\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>return;\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>!=<S2SV_blank>\'unchanged\')<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>clearInterval(timerID);\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>==<S2SV_blank>\'changed\')<S2SV_blank>{\\n"" ""\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=check\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}<S2SV_blank>else<S2SV_blank>{\\n"" ""\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=logout\';\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.addEventListener(\'message\',<S2SV_blank>receiveMessage,<S2SV_blank>false);\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank></script>\\n"" ; char * origin = apr_pstrdup ( r -> pool , check_session_iframe ) ; apr_uri_t uri ; apr_uri_parse ( r -> pool , check_session_iframe , & uri ) ; char * p = strstr ( origin , uri . path ) ; * p = '\\0' ; const char * op_iframe_id = ""openidc-op"" ; const char * session_state = oidc_session_get_session_state ( r , session ) ; if ( session_state == NULL ) { oidc_warn ( r , ""no<S2SV_blank>session_state<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>session;<S2SV_blank>the<S2SV_blank>OP<S2SV_blank>does<S2SV_blank>probably<S2SV_blank>not<S2SV_blank>support<S2SV_blank>session<S2SV_blank>management!?"" ) ; return DONE ; } char * s_poll_interval = NULL ; oidc_util_get_request_parameter ( r , ""poll"" , & s_poll_interval ) ; <S2SV_StartBug> if ( s_poll_interval == NULL ) <S2SV_EndBug> s_poll_interval = ""3000"" ; const char * redirect_uri = oidc_get_redirect_uri ( r , c ) ; java_script = apr_psprintf ( r -> pool , java_script , origin , client_id , <S2SV_StartBug> session_state , op_iframe_id , s_poll_interval , redirect_uri , <S2SV_EndBug> redirect_uri ) ; return oidc_util_html_send ( r , NULL , java_script , ""setTimer"" , NULL , DONE ) ; }
","<S2SV_ModStart> ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%d);\\n"" <S2SV_ModEnd> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n"" ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n"" <S2SV_ModStart> s_poll_interval ) ; int poll_interval = s_poll_interval ? strtol ( s_poll_interval , NULL , 10 ) : 0 ; if ( ( poll_interval <= 0 ) || ( poll_interval > 3600 * 24 ) ) poll_interval = 3000 <S2SV_ModEnd> ; const char <S2SV_ModStart> , op_iframe_id , poll_interval <S2SV_ModEnd> , redirect_uri ,
"
136,"CWE-189 static int decode_getacl ( struct xdr_stream * xdr , struct rpc_rqst * req , <S2SV_StartBug> size_t * acl_len ) <S2SV_EndBug> { <S2SV_StartBug> __be32 * savep ; <S2SV_EndBug> uint32_t attrlen , bitmap [ 3 ] = { 0 } ; struct kvec * iov = req -> rq_rcv_buf . head ; int status ; <S2SV_StartBug> * acl_len = 0 ; <S2SV_EndBug> if ( ( status = decode_op_hdr ( xdr , OP_GETATTR ) ) != 0 ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( ( status = decode_attr_bitmap ( xdr , bitmap ) ) != 0 ) goto out ; if ( ( status = decode_attr_length ( xdr , & attrlen , & savep ) ) != 0 ) goto out ; if ( unlikely ( bitmap [ 0 ] & ( FATTR4_WORD0_ACL - 1U ) ) ) return - EIO ; if ( likely ( bitmap [ 0 ] & FATTR4_WORD0_ACL ) ) { size_t hdrlen ; u32 recvd ; <S2SV_StartBug> hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ; <S2SV_EndBug> recvd = req -> rq_rcv_buf . len - hdrlen ; if ( attrlen > recvd ) { <S2SV_StartBug> dprintk ( ""NFS:<S2SV_blank>server<S2SV_blank>cheating<S2SV_blank>in<S2SV_blank>getattr"" <S2SV_EndBug> ""<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\n"" , attrlen , recvd ) ; return - EINVAL ; } xdr_read_pages ( xdr , attrlen ) ; <S2SV_StartBug> * acl_len = attrlen ; <S2SV_EndBug> } else status = - EOPNOTSUPP ; out : return status ; }
","<S2SV_ModStart> * req , struct nfs_getaclres * res <S2SV_ModEnd> ) { __be32 <S2SV_ModStart> __be32 * savep , * bm_p <S2SV_ModStart> int status ; res -> <S2SV_ModEnd> acl_len = 0 <S2SV_ModStart> ) goto out ; bm_p = xdr -> p <S2SV_ModStart> u32 recvd ; xdr -> p = bm_p ; res -> acl_data_offset = be32_to_cpup ( bm_p ) + 2 ; res -> acl_data_offset <<= 2 ; <S2SV_ModStart> iov -> iov_base ; attrlen += res -> acl_data_offset <S2SV_ModStart> recvd ) { if ( res -> acl_flags & NFS4_ACL_LEN_REQUEST ) { res -> acl_len = attrlen ; goto out ; } dprintk ( ""NFS:<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\n"" <S2SV_ModEnd> , attrlen , <S2SV_ModStart> attrlen ) ; res -> <S2SV_ModEnd> acl_len = attrlen
"
137,"CWE-125 static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; segs = NULL ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & ( SKB_GSO_UDP_TUNNEL | SKB_GSO_UDP_TUNNEL_CSUM ) ) segs = skb_udp_tunnel_segment ( skb , features , true ) ; else { const struct ipv6hdr * ipv6h ; struct udphdr * uh ; if ( ! pskb_may_pull ( skb , sizeof ( struct udphdr ) ) ) goto out ; uh = udp_hdr ( skb ) ; ipv6h = ipv6_hdr ( skb ) ; uh -> check = 0 ; csum = skb_checksum ( skb , 0 , skb -> len , 0 ) ; uh -> check = udp_v6_check ( skb -> len , & ipv6h -> saddr , & ipv6h -> daddr , csum ) ; if ( uh -> check == 0 ) uh -> check = CSUM_MANGLED_0 ; skb -> ip_summed = CHECKSUM_NONE ; if ( ! skb -> encap_hdr_csum ) features |= NETIF_F_HW_CSUM ; tnl_hlen = skb_tnl_header_len ( skb ) ; if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) ) { if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ; } unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_StartBug> nexthdr = * prevhdr ; <S2SV_EndBug> * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen ; packet_start = ( u8 * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset ; memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ) ; SKB_GSO_CB ( skb ) -> mac_offset -= frag_hdr_sz ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; fptr -> identification = skb_shinfo ( skb ) -> ip6_frag_id ; segs = skb_segment ( skb , features ) ; } out : return segs ; }
","<S2SV_ModStart> prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;
"
138,"CWE-125 GF_Err urn_Read ( GF_Box * s , GF_BitStream * bs ) { u32 i , to_read ; char * tmpName ; GF_DataEntryURNBox * ptr = ( GF_DataEntryURNBox * ) s ; if ( ! ptr -> size ) return GF_OK ; to_read = ( u32 ) ptr -> size ; tmpName = ( char * ) gf_malloc ( sizeof ( char ) * to_read ) ; if ( ! tmpName ) return GF_OUT_OF_MEM ; gf_bs_read_data ( bs , tmpName , to_read ) ; i = 0 ; <S2SV_StartBug> while ( ( tmpName [ i ] != 0 ) && ( i < to_read ) ) { <S2SV_EndBug> i ++ ; } if ( i == to_read ) { gf_free ( tmpName ) ; return GF_ISOM_INVALID_FILE ; } if ( i == to_read - 1 ) { ptr -> nameURN = tmpName ; ptr -> location = NULL ; return GF_OK ; } ptr -> nameURN = ( char * ) gf_malloc ( sizeof ( char ) * ( i + 1 ) ) ; if ( ! ptr -> nameURN ) { gf_free ( tmpName ) ; return GF_OUT_OF_MEM ; } ptr -> location = ( char * ) gf_malloc ( sizeof ( char ) * ( to_read - i - 1 ) ) ; if ( ! ptr -> location ) { gf_free ( tmpName ) ; gf_free ( ptr -> nameURN ) ; ptr -> nameURN = NULL ; return GF_OUT_OF_MEM ; } memcpy ( ptr -> nameURN , tmpName , i + 1 ) ; memcpy ( ptr -> location , tmpName + i + 1 , ( to_read - i - 1 ) ) ; gf_free ( tmpName ) ; return GF_OK ; }
","<S2SV_ModStart> ; while ( ( i < to_read ) && <S2SV_ModStart> != 0 ) <S2SV_ModEnd> ) { i
"
139,"CWE-189 static inline void jiffies_to_compat_timeval ( unsigned long jiffies , struct compat_timeval * value ) { u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_StartBug> long rem ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> value -> tv_usec = rem / NSEC_PER_USEC ; }
","<S2SV_ModStart> * TICK_NSEC ; u32 <S2SV_ModEnd> rem ; value <S2SV_ModStart> -> tv_sec = div_u64_rem <S2SV_ModEnd> ( nsec ,
"
140,"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { AVFilterContext * ctx = inlink -> dst ; FlipContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; AVFrame * out ; uint8_t * inrow , * outrow ; int i , j , plane , step ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; if ( av_pix_fmt_desc_get ( inlink -> format ) -> flags & AV_PIX_FMT_FLAG_PAL ) memcpy ( out -> data [ 1 ] , in -> data [ 1 ] , AVPALETTE_SIZE ) ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> const int width = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> w , s -> hsub ) : inlink -> w ; const int height = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> h , s -> vsub ) : inlink -> h ; step = s -> max_step [ plane ] ; outrow = out -> data [ plane ] ; inrow = in -> data [ plane ] + ( width - 1 ) * step ; for ( i = 0 ; i < height ; i ++ ) { switch ( step ) { case 1 : for ( j = 0 ; j < width ; j ++ ) outrow [ j ] = inrow [ - j ] ; break ; case 2 : { uint16_t * outrow16 = ( uint16_t * ) outrow ; uint16_t * inrow16 = ( uint16_t * ) inrow ; for ( j = 0 ; j < width ; j ++ ) outrow16 [ j ] = inrow16 [ - j ] ; } break ; case 3 : { uint8_t * in = inrow ; uint8_t * out = outrow ; for ( j = 0 ; j < width ; j ++ , out += 3 , in -= 3 ) { int32_t v = AV_RB24 ( in ) ; AV_WB24 ( out , v ) ; } } break ; case 4 : { uint32_t * outrow32 = ( uint32_t * ) outrow ; uint32_t * inrow32 = ( uint32_t * ) inrow ; for ( j = 0 ; j < width ; j ++ ) outrow32 [ j ] = inrow32 [ - j ] ; } break ; default : for ( j = 0 ; j < width ; j ++ ) memcpy ( outrow + j * step , inrow - j * step , step ) ; } inrow += in -> linesize [ plane ] ; outrow += out -> linesize [ plane ] ; } } av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; }
","<S2SV_ModStart> [ plane ] && in -> linesize [ plane ]
"
141,"CWE-119 BOOL SQLWriteFileDSN ( LPCSTR pszFileName , LPCSTR pszAppName , LPCSTR pszKeyName , LPCSTR pszString ) { HINI hIni ; char szFileName [ ODBC_FILENAME_MAX + 1 ] ; if ( pszFileName [ 0 ] == '/' ) { <S2SV_StartBug> strncpy ( szFileName , sizeof ( szFileName ) - 5 , pszFileName ) ; <S2SV_EndBug> } else { char szPath [ ODBC_FILENAME_MAX + 1 ] ; * szPath = '\\0' ; _odbcinst_FileINI ( szPath ) ; snprintf ( szFileName , sizeof ( szFileName ) - 5 , ""%s/%s"" , szPath , pszFileName ) ; } if ( strlen ( szFileName ) < 4 || strcmp ( szFileName + strlen ( szFileName ) - 4 , "".dsn"" ) ) { strcat ( szFileName , "".dsn"" ) ; } # ifdef __OS2__ if ( iniOpen ( & hIni , szFileName , ""#;"" , '[' , ']' , '=' , TRUE , 0L ) != INI_SUCCESS ) # else if ( iniOpen ( & hIni , szFileName , ""#;"" , '[' , ']' , '=' , TRUE ) != INI_SUCCESS ) # endif { inst_logPushMsg ( __FILE__ , __FILE__ , __LINE__ , LOG_CRITICAL , ODBC_ERROR_INVALID_PATH , """" ) ; return FALSE ; } if ( pszString == NULL && pszKeyName == NULL ) { if ( iniObjectSeek ( hIni , ( char * ) pszAppName ) == INI_SUCCESS ) { iniObjectDelete ( hIni ) ; } } else if ( pszString == NULL ) { if ( iniPropertySeek ( hIni , ( char * ) pszAppName , ( char * ) pszKeyName , """" ) == INI_SUCCESS ) { iniPropertyDelete ( hIni ) ; } } else { if ( iniObjectSeek ( hIni , ( char * ) pszAppName ) != INI_SUCCESS ) { iniObjectInsert ( hIni , ( char * ) pszAppName ) ; } if ( iniPropertySeek ( hIni , ( char * ) pszAppName , ( char * ) pszKeyName , """" ) == INI_SUCCESS ) { iniObjectSeek ( hIni , ( char * ) pszAppName ) ; iniPropertyUpdate ( hIni , ( char * ) pszKeyName , ( char * ) pszString ) ; } else { iniObjectSeek ( hIni , ( char * ) pszAppName ) ; iniPropertyInsert ( hIni , ( char * ) pszKeyName , ( char * ) pszString ) ; } } if ( iniCommit ( hIni ) != INI_SUCCESS ) { iniClose ( hIni ) ; inst_logPushMsg ( __FILE__ , __FILE__ , __LINE__ , LOG_CRITICAL , ODBC_ERROR_REQUEST_FAILED , """" ) ; return FALSE ; } iniClose ( hIni ) ; return TRUE ; }
","<S2SV_ModStart> ( szFileName , pszFileName , <S2SV_ModStart> ) - 5 <S2SV_ModEnd> ) ; }
"
142,"CWE-000 static int makeDirDirective ( MaState * state , cchar * key , cchar * value ) { MprPath info ; char * auth , * dirs , * path , * perms , * tok ; cchar * dir , * group , * owner ; int gid , mode , uid ; if ( ! maTokenize ( state , value , ""%S<S2SV_blank>?*"" , & auth , & dirs ) ) { return MPR_ERR_BAD_SYNTAX ; } uid = gid = 0 ; mode = 0750 ; if ( schr ( auth , ':' ) ) { <S2SV_StartBug> owner = stok ( auth , "":"" , & tok ) ; <S2SV_EndBug> if ( owner && * owner ) { if ( snumber ( owner ) ) { uid = ( int ) stoi ( owner ) ; } else if ( smatch ( owner , ""APPWEB"" ) ) { uid = HTTP -> uid ; } else { uid = userToID ( owner ) ; } } <S2SV_StartBug> group = stok ( tok , "":"" , & perms ) ; <S2SV_EndBug> if ( group && * group ) { if ( snumber ( group ) ) { gid = ( int ) stoi ( group ) ; } else if ( smatch ( owner , ""APPWEB"" ) ) { gid = HTTP -> gid ; } else { gid = groupToID ( group ) ; } } if ( perms && snumber ( perms ) ) { mode = ( int ) stoiradix ( perms , - 1 , NULL ) ; } else { mode = 0 ; } if ( gid < 0 || uid < 0 ) { return MPR_ERR_BAD_SYNTAX ; } } else { dirs = auth ; auth = 0 ; } tok = dirs ; for ( tok = sclone ( dirs ) ; ( dir = stok ( tok , "","" , & tok ) ) != 0 ; ) { path = httpMakePath ( state -> route , state -> configDir , dir ) ; if ( mprGetPathInfo ( path , & info ) == 0 && info . isDir ) { continue ; } if ( mprMakeDir ( path , mode , uid , gid , 1 ) < 0 ) { return MPR_ERR_BAD_SYNTAX ; } } return 0 ; }
","<S2SV_ModStart> { owner = ssplit <S2SV_ModEnd> ( auth , <S2SV_ModStart> } group = ssplit <S2SV_ModEnd> ( tok ,
"
143,"CWE-119 int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { <S2SV_StartBug> q = ( const uint8_t * ) ( const void * ) <S2SV_EndBug> ( ( const char * ) ( const void * ) p + <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ; <S2SV_EndBug> if ( q > e ) { DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; <S2SV_StartBug> DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , <S2SV_EndBug> inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) ) ; <S2SV_EndBug> if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ; o = 2 ; } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements ) ) ; for ( j = 0 ; j < nelements ; j ++ , i ++ ) { uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }
","<S2SV_ModStart> ++ ) { size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <S2SV_ModStart> ) p + ofs <S2SV_ModEnd> - 2 * <S2SV_ModStart> sizeof ( uint32_t ) <S2SV_ModStart> SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , <S2SV_ModEnd> inp [ i <S2SV_ModStart> - p , offs <S2SV_ModEnd> ) ) ;
"
144,"CWE-362 static int inet_sk_reselect_saddr ( struct sock * sk ) { struct inet_sock * inet = inet_sk ( sk ) ; __be32 old_saddr = inet -> inet_saddr ; __be32 daddr = inet -> inet_daddr ; struct flowi4 fl4 ; struct rtable * rt ; __be32 new_saddr ; <S2SV_StartBug> if ( inet -> opt && inet -> opt -> srr ) <S2SV_EndBug> daddr = inet -> opt -> faddr ; rt = ip_route_connect ( & fl4 , daddr , 0 , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if , sk -> sk_protocol , inet -> inet_sport , inet -> inet_dport , sk , false ) ; if ( IS_ERR ( rt ) ) return PTR_ERR ( rt ) ; sk_setup_caps ( sk , & rt -> dst ) ; new_saddr = rt -> rt_src ; if ( new_saddr == old_saddr ) return 0 ; if ( sysctl_ip_dynaddr > 1 ) { printk ( KERN_INFO ""%s():<S2SV_blank>shifting<S2SV_blank>inet->saddr<S2SV_blank>from<S2SV_blank>%pI4<S2SV_blank>to<S2SV_blank>%pI4\\n"" , __func__ , & old_saddr , & new_saddr ) ; } inet -> inet_saddr = inet -> inet_rcv_saddr = new_saddr ; __sk_prot_rehash ( sk ) ; return 0 ; }
","<S2SV_ModStart> __be32 new_saddr ; struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . <S2SV_ModEnd> faddr ; rt
"
145,"CWE-119 static int check_entry_size_and_hooks ( struct ipt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ipt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { <S2SV_StartBug> pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" <S2SV_EndBug> ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
","<S2SV_ModStart> ) ) { pr_debug <S2SV_ModEnd> ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>""
"
146,"CWE-125 void eigrp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct eigrp_common_header * eigrp_com_header ; const struct eigrp_tlv_header * eigrp_tlv_header ; const u_char * tptr , * tlv_tptr ; u_int tlen , eigrp_tlv_len , eigrp_tlv_type , tlv_tlen , byte_length , bit_length ; uint8_t prefix [ 4 ] ; union { const struct eigrp_tlv_general_parm_t * eigrp_tlv_general_parm ; const struct eigrp_tlv_sw_version_t * eigrp_tlv_sw_version ; const struct eigrp_tlv_ip_int_t * eigrp_tlv_ip_int ; const struct eigrp_tlv_ip_ext_t * eigrp_tlv_ip_ext ; const struct eigrp_tlv_at_cable_setup_t * eigrp_tlv_at_cable_setup ; const struct eigrp_tlv_at_int_t * eigrp_tlv_at_int ; const struct eigrp_tlv_at_ext_t * eigrp_tlv_at_ext ; } tlv_ptr ; tptr = pptr ; eigrp_com_header = ( const struct eigrp_common_header * ) pptr ; ND_TCHECK ( * eigrp_com_header ) ; if ( eigrp_com_header -> version != EIGRP_VERSION ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , eigrp_com_header -> version ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( eigrp_opcode_values , ""unknown<S2SV_blank>(%u)"" , eigrp_com_header -> opcode ) , len ) ) ; return ; } <S2SV_StartBug> tlen = len - sizeof ( struct eigrp_common_header ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\tEIGRP<S2SV_blank>v%u,<S2SV_blank>opcode:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>chksum:<S2SV_blank>0x%04x,<S2SV_blank>Flags:<S2SV_blank>[%s]\\n\\tseq:<S2SV_blank>0x%08x,<S2SV_blank>ack:<S2SV_blank>0x%08x,<S2SV_blank>AS:<S2SV_blank>%u,<S2SV_blank>length:<S2SV_blank>%u"" , eigrp_com_header -> version , tok2str ( eigrp_opcode_values , ""unknown,<S2SV_blank>type:<S2SV_blank>%u"" , eigrp_com_header -> opcode ) , eigrp_com_header -> opcode , EXTRACT_16BITS ( & eigrp_com_header -> checksum ) , tok2str ( eigrp_common_header_flag_values , ""none"" , EXTRACT_32BITS ( & eigrp_com_header -> flags ) ) , EXTRACT_32BITS ( & eigrp_com_header -> seq ) , EXTRACT_32BITS ( & eigrp_com_header -> ack ) , EXTRACT_32BITS ( & eigrp_com_header -> asn ) , tlen ) ) ; tptr += sizeof ( const struct eigrp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct eigrp_tlv_header ) ) ; eigrp_tlv_header = ( const struct eigrp_tlv_header * ) tptr ; eigrp_tlv_len = EXTRACT_16BITS ( & eigrp_tlv_header -> length ) ; eigrp_tlv_type = EXTRACT_16BITS ( & eigrp_tlv_header -> type ) ; if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) || eigrp_tlv_len > tlen ) { print_unknown_data ( ndo , tptr + sizeof ( struct eigrp_tlv_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( eigrp_tlv_values , ""Unknown"" , eigrp_tlv_type ) , eigrp_tlv_type , eigrp_tlv_len ) ) ; <S2SV_StartBug> tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ; <S2SV_EndBug> tlv_tlen = eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ; ND_TCHECK2 ( * tptr , eigrp_tlv_len ) ; switch ( eigrp_tlv_type ) { case EIGRP_TLV_GENERAL_PARM : tlv_ptr . eigrp_tlv_general_parm = ( const struct eigrp_tlv_general_parm_t * ) tlv_tptr ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>holdtime:<S2SV_blank>%us,<S2SV_blank>k1<S2SV_blank>%u,<S2SV_blank>k2<S2SV_blank>%u,<S2SV_blank>k3<S2SV_blank>%u,<S2SV_blank>k4<S2SV_blank>%u,<S2SV_blank>k5<S2SV_blank>%u"" , <S2SV_EndBug> EXTRACT_16BITS ( tlv_ptr . eigrp_tlv_general_parm -> holdtime ) , tlv_ptr . eigrp_tlv_general_parm -> k1 , tlv_ptr . eigrp_tlv_general_parm -> k2 , tlv_ptr . eigrp_tlv_general_parm -> k3 , tlv_ptr . eigrp_tlv_general_parm -> k4 , tlv_ptr . eigrp_tlv_general_parm -> k5 ) ) ; break ; case EIGRP_TLV_SW_VERSION : tlv_ptr . eigrp_tlv_sw_version = ( const struct eigrp_tlv_sw_version_t * ) tlv_tptr ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IOS<S2SV_blank>version:<S2SV_blank>%u.%u,<S2SV_blank>EIGRP<S2SV_blank>version<S2SV_blank>%u.%u"" , <S2SV_EndBug> tlv_ptr . eigrp_tlv_sw_version -> ios_major , tlv_ptr . eigrp_tlv_sw_version -> ios_minor , tlv_ptr . eigrp_tlv_sw_version -> eigrp_major , tlv_ptr . eigrp_tlv_sw_version -> eigrp_minor ) ) ; break ; case EIGRP_TLV_IP_INT : tlv_ptr . eigrp_tlv_ip_int = ( const struct eigrp_tlv_ip_int_t * ) tlv_tptr ; <S2SV_StartBug> bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ; <S2SV_EndBug> if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>illegal<S2SV_blank>prefix<S2SV_blank>length<S2SV_blank>%u"" , bit_length ) ) ; break ; } byte_length = ( bit_length + 7 ) / 8 ; memset ( prefix , 0 , 4 ) ; memcpy ( prefix , & tlv_ptr . eigrp_tlv_ip_int -> destination , byte_length ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u,<S2SV_blank>nexthop:<S2SV_blank>"" , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , & tlv_ptr . eigrp_tlv_ip_int -> nexthop ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_ip_int -> mtu ) , tlv_ptr . eigrp_tlv_ip_int -> hopcount , tlv_ptr . eigrp_tlv_ip_int -> reliability , tlv_ptr . eigrp_tlv_ip_int -> load ) ) ; break ; case EIGRP_TLV_IP_EXT : tlv_ptr . eigrp_tlv_ip_ext = ( const struct eigrp_tlv_ip_ext_t * ) tlv_tptr ; <S2SV_StartBug> bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ; <S2SV_EndBug> if ( bit_length > 32 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>illegal<S2SV_blank>prefix<S2SV_blank>length<S2SV_blank>%u"" , bit_length ) ) ; break ; } byte_length = ( bit_length + 7 ) / 8 ; memset ( prefix , 0 , 4 ) ; memcpy ( prefix , & tlv_ptr . eigrp_tlv_ip_ext -> destination , byte_length ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u,<S2SV_blank>nexthop:<S2SV_blank>"" , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , & tlv_ptr . eigrp_tlv_ip_ext -> nexthop ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>origin-router<S2SV_blank>%s,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>origin-proto<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>[0x%02x],<S2SV_blank>tag<S2SV_blank>0x%08x,<S2SV_blank>metric<S2SV_blank>%u"" , ipaddr_string ( ndo , tlv_ptr . eigrp_tlv_ip_ext -> origin_router ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> origin_as ) , tok2str ( eigrp_ext_proto_id_values , ""unknown"" , tlv_ptr . eigrp_tlv_ip_ext -> proto_id ) , tlv_ptr . eigrp_tlv_ip_ext -> flags , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> tag ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> metric ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> mtu ) , tlv_ptr . eigrp_tlv_ip_ext -> hopcount , tlv_ptr . eigrp_tlv_ip_ext -> reliability , tlv_ptr . eigrp_tlv_ip_ext -> load ) ) ; break ; case EIGRP_TLV_AT_CABLE_SETUP : tlv_ptr . eigrp_tlv_at_cable_setup = ( const struct eigrp_tlv_at_cable_setup_t * ) tlv_tptr ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-range:<S2SV_blank>%u-%u,<S2SV_blank>Router-ID<S2SV_blank>%u"" , <S2SV_EndBug> EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> cable_end ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> router_id ) ) ) ; break ; case EIGRP_TLV_AT_INT : <S2SV_StartBug> tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> cable_end ) ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%u.%u"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop [ 2 ] ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_at_int -> mtu ) , tlv_ptr . eigrp_tlv_at_int -> hopcount , tlv_ptr . eigrp_tlv_at_int -> reliability , tlv_ptr . eigrp_tlv_at_int -> load ) ) ; break ; case EIGRP_TLV_AT_EXT : tlv_ptr . eigrp_tlv_at_ext = ( const struct eigrp_tlv_at_ext_t * ) tlv_tptr ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" , <S2SV_EndBug> EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> cable_start ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> cable_end ) ) ) ; if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop ) == 0 ) ND_PRINT ( ( ndo , ""self"" ) ) ; else ND_PRINT ( ( ndo , ""%u.%u"" , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop ) , EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop [ 2 ] ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>origin-router<S2SV_blank>%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>origin-proto<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>[0x%02x],<S2SV_blank>tag<S2SV_blank>0x%08x,<S2SV_blank>metric<S2SV_blank>%u"" , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> origin_router ) , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> origin_as ) , tok2str ( eigrp_ext_proto_id_values , ""unknown"" , tlv_ptr . eigrp_tlv_at_ext -> proto_id ) , tlv_ptr . eigrp_tlv_at_ext -> flags , EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> tag ) , EXTRACT_16BITS ( tlv_ptr . eigrp_tlv_at_ext -> metric ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u"" , ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> delay ) / 100 ) , EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> bandwidth ) , EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_at_ext -> mtu ) , tlv_ptr . eigrp_tlv_at_ext -> hopcount , tlv_ptr . eigrp_tlv_at_ext -> reliability , tlv_ptr . eigrp_tlv_at_ext -> load ) ) ; break ; case EIGRP_TLV_AUTH : case EIGRP_TLV_SEQ : case EIGRP_TLV_MCAST_SEQ : case EIGRP_TLV_IPX_INT : case EIGRP_TLV_IPX_EXT : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tlv_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlv_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , tptr + sizeof ( struct eigrp_tlv_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ) ; tptr += eigrp_tlv_len ; tlen -= eigrp_tlv_len ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; }
","<S2SV_ModStart> return ; } if ( len < sizeof ( struct eigrp_common_header ) ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , tok2str ( eigrp_opcode_values , ""unknown<S2SV_blank>(%u)"" , eigrp_com_header -> opcode ) , len , ( u_int ) sizeof ( struct eigrp_common_header ) ) ) ; return ; } <S2SV_ModStart> ) ) ; if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) sizeof ( struct eigrp_tlv_header ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) ) ) ; break ; }
"
147,"CWE-119 void * vpx_memalign ( size_t align , size_t size ) { void * addr , * x = NULL ; <S2SV_StartBug> # if CONFIG_MEM_MANAGER <S2SV_EndBug> int number_aau ; if ( vpx_mm_create_heap_memory ( ) < 0 ) { _P ( printf ( ""[vpx][mm]<S2SV_blank>ERROR<S2SV_blank>vpx_memalign()<S2SV_blank>Couldn\'t<S2SV_blank>create<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Heap.\\n"" ) ; ) } number_aau = ( ( size + align - 1 + ADDRESS_STORAGE_SIZE ) >> SHIFT_HMM_ADDR_ALIGN_UNIT ) + 1 ; addr = hmm_alloc ( & hmm_d , number_aau ) ; # else addr = VPX_MALLOC_L ( size + align - 1 + ADDRESS_STORAGE_SIZE ) ; <S2SV_StartBug> # endif <S2SV_EndBug> if ( addr ) { x = align_addr ( ( unsigned char * ) addr + ADDRESS_STORAGE_SIZE , ( int ) align ) ; ( ( size_t * ) x ) [ - 1 ] = ( size_t ) addr ; } return x ; }
","<S2SV_ModStart> = NULL ; addr = malloc <S2SV_ModEnd> ( size + <S2SV_ModStart> ADDRESS_STORAGE_SIZE ) ; <S2SV_ModEnd> if ( addr
"
148,"CWE-20 static int parse_exports_table ( long long * table_start ) { int res ; <S2SV_StartBug> int indexes = SQUASHFS_LOOKUP_BLOCKS ( sBlk . s . inodes ) ; <S2SV_EndBug> <S2SV_StartBug> long long export_index_table [ indexes ] ; <S2SV_EndBug> <S2SV_StartBug> res = read_fs_bytes ( fd , sBlk . s . lookup_table_start , <S2SV_EndBug> SQUASHFS_LOOKUP_BLOCK_BYTES ( sBlk . s . inodes ) , export_index_table ) ; if ( res == FALSE ) { ERROR ( ""parse_exports_table:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>export<S2SV_blank>index<S2SV_blank>table\\n"" ) ; return FALSE ; } SQUASHFS_INSWAP_LOOKUP_BLOCKS ( export_index_table , indexes ) ; * table_start = export_index_table [ 0 ] ; return TRUE ; }
","<S2SV_ModStart> = SQUASHFS_LOOKUP_BLOCKS ( ( long long ) sBlk . s . inodes ) ; int length = SQUASHFS_LOOKUP_BLOCK_BYTES ( ( long long ) <S2SV_ModStart> ; long long * export_index_table ; if ( length != ( * table_start - sBlk . s . lookup_table_start ) ) { ERROR ( ""parse_exports_table:<S2SV_blank>Bad<S2SV_blank>inode<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; return FALSE ; } export_index_table = alloc_index_table ( indexes ) <S2SV_ModEnd> ; res = <S2SV_ModStart> . lookup_table_start , length , <S2SV_ModEnd> export_index_table ) ;
"
149,"CWE-000 static int devzvol_readdir ( struct vnode * dvp , struct uio * uiop , struct cred * cred , int * eofp , caller_context_t * ct_unused , int flags_unused ) { struct sdev_node * sdvp = VTOSDEV ( dvp ) ; char * ptr ; sdcmn_err13 ( ( ""zv<S2SV_blank>readdir<S2SV_blank>of<S2SV_blank>\'%s\'<S2SV_blank>%s\'"" , sdvp -> sdev_path , sdvp -> sdev_name ) ) ; if ( strcmp ( sdvp -> sdev_path , ZVOL_DIR ) == 0 ) { struct vnode * vp ; rw_exit ( & sdvp -> sdev_contents ) ; ( void ) devname_lookup_func ( sdvp , ""dsk"" , & vp , cred , devzvol_create_dir , SDEV_VATTR ) ; VN_RELE ( vp ) ; ( void ) devname_lookup_func ( sdvp , ""rdsk"" , & vp , cred , devzvol_create_dir , SDEV_VATTR ) ; VN_RELE ( vp ) ; rw_enter ( & sdvp -> sdev_contents , RW_READER ) ; return ( devname_readdir_func ( dvp , uiop , cred , eofp , 0 ) ) ; } if ( uiop -> uio_offset == 0 ) devzvol_prunedir ( sdvp ) ; ptr = sdvp -> sdev_path + strlen ( ZVOL_DIR ) ; if ( ( strcmp ( ptr , ""/dsk"" ) == 0 ) || ( strcmp ( ptr , ""/rdsk"" ) == 0 ) ) { rw_exit ( & sdvp -> sdev_contents ) ; devzvol_create_pool_dirs ( dvp ) ; rw_enter ( & sdvp -> sdev_contents , RW_READER ) ; return ( devname_readdir_func ( dvp , uiop , cred , eofp , 0 ) ) ; } <S2SV_StartBug> ptr = strchr ( ptr + 1 , '/' ) + 1 ; <S2SV_EndBug> rw_exit ( & sdvp -> sdev_contents ) ; sdev_iter_datasets ( dvp , ZFS_IOC_DATASET_LIST_NEXT , ptr ) ; rw_enter ( & sdvp -> sdev_contents , RW_READER ) ; return ( devname_readdir_func ( dvp , uiop , cred , eofp , 0 ) ) ; }
","<S2SV_ModStart> , '/' ) ; if ( ptr == NULL ) return ( ENOENT ) ; ptr ++ <S2SV_ModEnd> ; rw_exit (
"
150,"CWE-362 static int ext4_split_unwritten_extents ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path , int flags ) { ext4_lblk_t eof_block ; ext4_lblk_t ee_block ; struct ext4_extent * ex ; unsigned int ee_len ; int split_flag = 0 , depth ; ext_debug ( ""ext4_split_unwritten_extents:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u\\n"" , inode -> i_ino , ( unsigned long long ) map -> m_lblk , map -> m_len ) ; eof_block = ( inode -> i_size + inode -> i_sb -> s_blocksize - 1 ) >> inode -> i_sb -> s_blocksize_bits ; if ( eof_block < map -> m_lblk + map -> m_len ) eof_block = map -> m_lblk + map -> m_len ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; split_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0 ; split_flag |= EXT4_EXT_MARK_UNINIT2 ; <S2SV_StartBug> flags |= EXT4_GET_BLOCKS_PRE_IO ; <S2SV_EndBug> return ext4_split_extent ( handle , inode , path , map , split_flag , flags ) ; }
","<S2SV_ModStart> |= EXT4_EXT_MARK_UNINIT2 ; if ( flags & EXT4_GET_BLOCKS_CONVERT ) split_flag |= EXT4_EXT_DATA_VALID2 ;
"
151,"CWE-285 int ceph_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int ret = 0 , size = 0 ; const char * name = NULL ; char * value = NULL ; struct iattr newattrs ; umode_t new_mode = inode -> i_mode , old_mode = inode -> i_mode ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & new_mode ) ; <S2SV_EndBug> if ( ret < 0 ) goto out ; if ( ret == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) { ret = acl ? - EINVAL : 0 ; goto out ; } name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : ret = - EINVAL ; goto out ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_NOFS ) ; if ( ! value ) { ret = - ENOMEM ; goto out ; } ret = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( ret < 0 ) goto out_free ; } if ( new_mode != old_mode ) { newattrs . ia_mode = new_mode ; newattrs . ia_valid = ATTR_MODE ; ret = __ceph_setattr ( inode , & newattrs ) ; if ( ret ) goto out_free ; } ret = __ceph_setxattr ( inode , name , value , size , 0 ) ; if ( ret ) { if ( new_mode != old_mode ) { newattrs . ia_mode = old_mode ; newattrs . ia_valid = ATTR_MODE ; __ceph_setattr ( inode , & newattrs ) ; } goto out_free ; } ceph_set_cached_acl ( inode , type , acl ) ; out_free : kfree ( value ) ; out : return ret ; }
","<S2SV_ModStart> { ret = posix_acl_update_mode ( inode , & new_mode , & acl ) ; if ( ret ) goto out <S2SV_ModEnd> ; } break
"
152,"CWE-611 static const char * cmd_hash_engine ( cmd_parms * cmd , void * _dcfg , const char * p1 ) { directory_config * dcfg = ( directory_config * ) _dcfg ; if ( dcfg == NULL ) return NULL ; if ( strcasecmp ( p1 , ""on"" ) == 0 ) { dcfg -> hash_is_enabled = HASH_ENABLED ; dcfg -> hash_enforcement = HASH_ENABLED ; } else if ( strcasecmp ( p1 , ""off"" ) == 0 ) { dcfg -> hash_is_enabled = HASH_DISABLED ; dcfg -> hash_enforcement = HASH_DISABLED ; } <S2SV_StartBug> else return apr_psprintf ( cmd -> pool , ""ModSecurity:<S2SV_blank>Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>SecRuleEngine:<S2SV_blank>%s"" , p1 ) ; <S2SV_EndBug> return NULL ; }
","<S2SV_ModStart> -> pool , ""ModSecurity:<S2SV_blank>Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>SexHashEngine:<S2SV_blank>%s"" <S2SV_ModEnd> , p1 )
"
153,"CWE-416 int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
","<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) , & final ) ; rcu_read_unlock ( <S2SV_ModEnd> ) ; dst
"
154,"CWE-119 static int loadImage ( TIFF * in , struct image_data * image , struct dump_opts * dump , unsigned char * * read_ptr ) { uint32 i ; float xres = 0.0 , yres = 0.0 ; <S2SV_StartBug> uint16 nstrips = 0 , ntiles = 0 , planar = 0 ; <S2SV_EndBug> uint16 bps = 0 , spp = 0 , res_unit = 0 ; uint16 orientation = 0 ; uint16 input_compression = 0 , input_photometric = 0 ; uint16 subsampling_horiz , subsampling_vert ; uint32 width = 0 , length = 0 ; uint32 stsize = 0 , tlsize = 0 , buffsize = 0 , scanlinesize = 0 ; uint32 tw = 0 , tl = 0 ; uint32 tile_rowsize = 0 ; unsigned char * read_buff = NULL ; unsigned char * new_buff = NULL ; int readunit = 0 ; static uint32 prev_readsize = 0 ; TIFFGetFieldDefaulted ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_SAMPLESPERPIXEL , & spp ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PLANARCONFIG , & planar ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_ORIENTATION , & orientation ) ; if ( ! TIFFGetFieldDefaulted ( in , TIFFTAG_PHOTOMETRIC , & input_photometric ) ) TIFFError ( ""loadImage"" , ""Image<S2SV_blank>lacks<S2SV_blank>Photometric<S2SV_blank>interpreation<S2SV_blank>tag"" ) ; if ( ! TIFFGetField ( in , TIFFTAG_IMAGEWIDTH , & width ) ) TIFFError ( ""loadimage"" , ""Image<S2SV_blank>lacks<S2SV_blank>image<S2SV_blank>width<S2SV_blank>tag"" ) ; if ( ! TIFFGetField ( in , TIFFTAG_IMAGELENGTH , & length ) ) TIFFError ( ""loadimage"" , ""Image<S2SV_blank>lacks<S2SV_blank>image<S2SV_blank>length<S2SV_blank>tag"" ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_XRESOLUTION , & xres ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_YRESOLUTION , & yres ) ; if ( ! TIFFGetFieldDefaulted ( in , TIFFTAG_RESOLUTIONUNIT , & res_unit ) ) res_unit = RESUNIT_INCH ; if ( ! TIFFGetField ( in , TIFFTAG_COMPRESSION , & input_compression ) ) input_compression = COMPRESSION_NONE ; # ifdef DEBUG2 char compressionid [ 16 ] ; switch ( input_compression ) { case COMPRESSION_NONE : strcpy ( compressionid , ""None/dump"" ) ; break ; case COMPRESSION_CCITTRLE : strcpy ( compressionid , ""Huffman<S2SV_blank>RLE"" ) ; break ; case COMPRESSION_CCITTFAX3 : strcpy ( compressionid , ""Group3<S2SV_blank>Fax"" ) ; break ; case COMPRESSION_CCITTFAX4 : strcpy ( compressionid , ""Group4<S2SV_blank>Fax"" ) ; break ; case COMPRESSION_LZW : strcpy ( compressionid , ""LZW"" ) ; break ; case COMPRESSION_OJPEG : strcpy ( compressionid , ""Old<S2SV_blank>Jpeg"" ) ; break ; case COMPRESSION_JPEG : strcpy ( compressionid , ""New<S2SV_blank>Jpeg"" ) ; break ; case COMPRESSION_NEXT : strcpy ( compressionid , ""Next<S2SV_blank>RLE"" ) ; break ; case COMPRESSION_CCITTRLEW : strcpy ( compressionid , ""CITTRLEW"" ) ; break ; case COMPRESSION_PACKBITS : strcpy ( compressionid , ""Mac<S2SV_blank>Packbits"" ) ; break ; case COMPRESSION_THUNDERSCAN : strcpy ( compressionid , ""Thunderscan"" ) ; break ; case COMPRESSION_IT8CTPAD : strcpy ( compressionid , ""IT8<S2SV_blank>padded"" ) ; break ; case COMPRESSION_IT8LW : strcpy ( compressionid , ""IT8<S2SV_blank>RLE"" ) ; break ; case COMPRESSION_IT8MP : strcpy ( compressionid , ""IT8<S2SV_blank>mono"" ) ; break ; case COMPRESSION_IT8BL : strcpy ( compressionid , ""IT8<S2SV_blank>lineart"" ) ; break ; case COMPRESSION_PIXARFILM : strcpy ( compressionid , ""Pixar<S2SV_blank>10<S2SV_blank>bit"" ) ; break ; case COMPRESSION_PIXARLOG : strcpy ( compressionid , ""Pixar<S2SV_blank>11bit"" ) ; break ; case COMPRESSION_DEFLATE : strcpy ( compressionid , ""Deflate"" ) ; break ; case COMPRESSION_ADOBE_DEFLATE : strcpy ( compressionid , ""Adobe<S2SV_blank>deflate"" ) ; break ; default : strcpy ( compressionid , ""None/unknown"" ) ; break ; } TIFFError ( ""loadImage"" , ""Input<S2SV_blank>compression<S2SV_blank>%s"" , compressionid ) ; # endif scanlinesize = TIFFScanlineSize ( in ) ; image -> bps = bps ; image -> spp = spp ; image -> planar = planar ; image -> width = width ; image -> length = length ; image -> xres = xres ; image -> yres = yres ; image -> res_unit = res_unit ; image -> compression = input_compression ; image -> photometric = input_photometric ; # ifdef DEBUG2 char photometricid [ 12 ] ; switch ( input_photometric ) { case PHOTOMETRIC_MINISWHITE : strcpy ( photometricid , ""MinIsWhite"" ) ; break ; case PHOTOMETRIC_MINISBLACK : strcpy ( photometricid , ""MinIsBlack"" ) ; break ; case PHOTOMETRIC_RGB : strcpy ( photometricid , ""RGB"" ) ; break ; case PHOTOMETRIC_PALETTE : strcpy ( photometricid , ""Palette"" ) ; break ; case PHOTOMETRIC_MASK : strcpy ( photometricid , ""Mask"" ) ; break ; case PHOTOMETRIC_SEPARATED : strcpy ( photometricid , ""Separated"" ) ; break ; case PHOTOMETRIC_YCBCR : strcpy ( photometricid , ""YCBCR"" ) ; break ; case PHOTOMETRIC_CIELAB : strcpy ( photometricid , ""CIELab"" ) ; break ; case PHOTOMETRIC_ICCLAB : strcpy ( photometricid , ""ICCLab"" ) ; break ; case PHOTOMETRIC_ITULAB : strcpy ( photometricid , ""ITULab"" ) ; break ; case PHOTOMETRIC_LOGL : strcpy ( photometricid , ""LogL"" ) ; break ; case PHOTOMETRIC_LOGLUV : strcpy ( photometricid , ""LOGLuv"" ) ; break ; default : strcpy ( photometricid , ""Unknown"" ) ; break ; } TIFFError ( ""loadImage"" , ""Input<S2SV_blank>photometric<S2SV_blank>interpretation<S2SV_blank>%s"" , photometricid ) ; # endif image -> orientation = orientation ; switch ( orientation ) { case 0 : case ORIENTATION_TOPLEFT : image -> adjustments = 0 ; break ; case ORIENTATION_TOPRIGHT : image -> adjustments = MIRROR_HORIZ ; break ; case ORIENTATION_BOTRIGHT : image -> adjustments = ROTATECW_180 ; break ; case ORIENTATION_BOTLEFT : image -> adjustments = MIRROR_VERT ; break ; case ORIENTATION_LEFTTOP : image -> adjustments = MIRROR_VERT | ROTATECW_90 ; break ; case ORIENTATION_RIGHTTOP : image -> adjustments = ROTATECW_90 ; break ; case ORIENTATION_RIGHTBOT : image -> adjustments = MIRROR_VERT | ROTATECW_270 ; break ; case ORIENTATION_LEFTBOT : image -> adjustments = ROTATECW_270 ; break ; default : image -> adjustments = 0 ; image -> orientation = ORIENTATION_TOPLEFT ; } if ( ( bps == 0 ) || ( spp == 0 ) ) { TIFFError ( ""loadImage"" , ""Invalid<S2SV_blank>samples<S2SV_blank>per<S2SV_blank>pixel<S2SV_blank>(%d)<S2SV_blank>or<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>sample<S2SV_blank>(%d)"" , spp , bps ) ; return ( - 1 ) ; } if ( TIFFIsTiled ( in ) ) { readunit = TILE ; tlsize = TIFFTileSize ( in ) ; ntiles = TIFFNumberOfTiles ( in ) ; TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; tile_rowsize = TIFFTileRowSize ( in ) ; if ( ntiles == 0 || tlsize == 0 || tile_rowsize == 0 ) { TIFFError ( ""loadImage"" , ""File<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>tiled,<S2SV_blank>but<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>tiles,<S2SV_blank>tile<S2SV_blank>size,<S2SV_blank>or<S2SV_blank>tile<S2SV_blank>rowsize<S2SV_blank>is<S2SV_blank>zero."" ) ; exit ( - 1 ) ; } buffsize = tlsize * ntiles ; if ( tlsize != ( buffsize / ntiles ) ) { TIFFError ( ""loadImage"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size"" ) ; exit ( - 1 ) ; } if ( buffsize < ( uint32 ) ( ntiles * tl * tile_rowsize ) ) { buffsize = ntiles * tl * tile_rowsize ; if ( ntiles != ( buffsize / tl / tile_rowsize ) ) { TIFFError ( ""loadImage"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size"" ) ; exit ( - 1 ) ; } # ifdef DEBUG2 TIFFError ( ""loadImage"" , ""Tilesize<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small,<S2SV_blank>using<S2SV_blank>ntiles<S2SV_blank>*<S2SV_blank>tilelength<S2SV_blank>*<S2SV_blank>tilerowsize<S2SV_blank>%lu"" , tlsize , ( unsigned long ) buffsize ) ; # endif } if ( dump -> infile != NULL ) dump_info ( dump -> infile , dump -> format , """" , ""Tilesize:<S2SV_blank>%u,<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>Tiles:<S2SV_blank>%u,<S2SV_blank>Tile<S2SV_blank>row<S2SV_blank>size:<S2SV_blank>%u"" , tlsize , ntiles , tile_rowsize ) ; } else { uint32 buffsize_check ; readunit = STRIP ; TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ; stsize = TIFFStripSize ( in ) ; nstrips = TIFFNumberOfStrips ( in ) ; if ( nstrips == 0 || stsize == 0 ) { TIFFError ( ""loadImage"" , ""File<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>striped,<S2SV_blank>but<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>stipes<S2SV_blank>or<S2SV_blank>stripe<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero."" ) ; exit ( - 1 ) ; } buffsize = stsize * nstrips ; if ( stsize != ( buffsize / nstrips ) ) { TIFFError ( ""loadImage"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size"" ) ; exit ( - 1 ) ; } buffsize_check = ( ( length * width * spp * bps ) + 7 ) ; if ( length != ( ( buffsize_check - 7 ) / width / spp / bps ) ) { TIFFError ( ""loadImage"" , ""Integer<S2SV_blank>overflow<S2SV_blank>detected."" ) ; exit ( - 1 ) ; } if ( buffsize < ( uint32 ) ( ( ( length * width * spp * bps ) + 7 ) / 8 ) ) { buffsize = ( ( length * width * spp * bps ) + 7 ) / 8 ; # ifdef DEBUG2 TIFFError ( ""loadImage"" , ""Stripsize<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small,<S2SV_blank>using<S2SV_blank>imagelength<S2SV_blank>*<S2SV_blank>width<S2SV_blank>*<S2SV_blank>spp<S2SV_blank>*<S2SV_blank>bps<S2SV_blank>/<S2SV_blank>8<S2SV_blank>=<S2SV_blank>%lu"" , stsize , ( unsigned long ) buffsize ) ; # endif } if ( dump -> infile != NULL ) dump_info ( dump -> infile , dump -> format , """" , ""Stripsize:<S2SV_blank>%u,<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>Strips:<S2SV_blank>%u,<S2SV_blank>Rows<S2SV_blank>per<S2SV_blank>Strip:<S2SV_blank>%u,<S2SV_blank>Scanline<S2SV_blank>size:<S2SV_blank>%u"" , stsize , nstrips , rowsperstrip , scanlinesize ) ; } if ( input_compression == COMPRESSION_JPEG ) { jpegcolormode = JPEGCOLORMODE_RGB ; TIFFSetField ( in , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else { if ( input_photometric == PHOTOMETRIC_YCBCR ) { TIFFGetFieldDefaulted ( in , TIFFTAG_YCBCRSUBSAMPLING , & subsampling_horiz , & subsampling_vert ) ; if ( subsampling_horiz != 1 || subsampling_vert != 1 ) { TIFFError ( ""loadImage"" , ""Can\'t<S2SV_blank>copy/convert<S2SV_blank>subsampled<S2SV_blank>image<S2SV_blank>with<S2SV_blank>subsampling<S2SV_blank>%d<S2SV_blank>horiz<S2SV_blank>%d<S2SV_blank>vert"" , subsampling_horiz , subsampling_vert ) ; return ( - 1 ) ; } } } read_buff = * read_ptr ; if ( ! read_buff ) <S2SV_StartBug> read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> { if ( prev_readsize < buffsize ) <S2SV_StartBug> { <S2SV_EndBug> new_buff = _TIFFrealloc ( read_buff , buffsize + 3 ) ; if ( ! new_buff ) { free ( read_buff ) ; read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ; } else read_buff = new_buff ; } } if ( ! read_buff ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } read_buff [ buffsize ] = 0 ; read_buff [ buffsize + 1 ] = 0 ; read_buff [ buffsize + 2 ] = 0 ; prev_readsize = buffsize ; * read_ptr = read_buff ; switch ( readunit ) { case STRIP : if ( planar == PLANARCONFIG_CONTIG ) { if ( ! ( readContigStripsIntoBuffer ( in , read_buff ) ) ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>contiguous<S2SV_blank>strips<S2SV_blank>into<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } } else { if ( ! ( readSeparateStripsIntoBuffer ( in , read_buff , length , width , spp , dump ) ) ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>separate<S2SV_blank>strips<S2SV_blank>into<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } } break ; case TILE : if ( planar == PLANARCONFIG_CONTIG ) { if ( ! ( readContigTilesIntoBuffer ( in , read_buff , length , width , tw , tl , spp , bps ) ) ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>contiguous<S2SV_blank>tiles<S2SV_blank>into<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } } else { if ( ! ( readSeparateTilesIntoBuffer ( in , read_buff , length , width , tw , tl , spp , bps ) ) ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>separate<S2SV_blank>tiles<S2SV_blank>into<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } } break ; default : TIFFError ( ""loadImage"" , ""Unsupported<S2SV_blank>image<S2SV_blank>file<S2SV_blank>format"" ) ; return ( - 1 ) ; break ; } if ( ( dump -> infile != NULL ) && ( dump -> level == 2 ) ) { dump_info ( dump -> infile , dump -> format , ""loadImage"" , ""Image<S2SV_blank>width<S2SV_blank>%d,<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>Raw<S2SV_blank>image<S2SV_blank>data,<S2SV_blank>%4d<S2SV_blank>bytes"" , width , length , buffsize ) ; dump_info ( dump -> infile , dump -> format , """" , ""Bits<S2SV_blank>per<S2SV_blank>sample<S2SV_blank>%d,<S2SV_blank>Samples<S2SV_blank>per<S2SV_blank>pixel<S2SV_blank>%d"" , bps , spp ) ; for ( i = 0 ; i < length ; i ++ ) dump_buffer ( dump -> infile , dump -> format , 1 , scanlinesize , i , read_buff + ( i * scanlinesize ) ) ; } return ( 0 ) ; }
","<S2SV_ModStart> = 0.0 ; uint32 nstrips = 0 , ntiles = 0 ; uint16 <S2SV_ModEnd> planar = 0 <S2SV_ModStart> ! read_buff ) { if ( buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } <S2SV_ModStart> 3 ) ; } <S2SV_ModStart> buffsize ) { if ( buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ; return ( - 1 ) ; }
"
155,"CWE-119 static int parse_stream_params ( struct VpxEncoderConfig * global , struct stream_state * stream , char * * argv ) { char * * argi , * * argj ; struct arg arg ; static const arg_def_t * * ctrl_args = no_args ; static const int * ctrl_args_map = NULL ; struct stream_config * config = & stream -> config ; int eos_mark_found = 0 ; <S2SV_StartBug> if ( 0 ) { <S2SV_EndBug> # if CONFIG_VP8_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp8"" ) == 0 ) { ctrl_args = vp8_args ; ctrl_args_map = vp8_arg_ctrl_map ; # endif # if CONFIG_VP9_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 ) { ctrl_args = vp9_args ; ctrl_args_map = vp9_arg_ctrl_map ; # endif <S2SV_StartBug> } <S2SV_EndBug> for ( argi = argj = argv ; ( * argj = * argi ) ; argi += arg . argv_step ) { arg . argv_step = 1 ; if ( eos_mark_found ) { argj ++ ; continue ; } else if ( ! strcmp ( * argj , ""--"" ) ) { eos_mark_found = 1 ; continue ; } <S2SV_StartBug> if ( 0 ) { <S2SV_EndBug> } else if ( arg_match ( & arg , & outputfile , argi ) ) { config -> out_fn = arg . val ; } else if ( arg_match ( & arg , & fpf_name , argi ) ) { config -> stats_fn = arg . val ; } else if ( arg_match ( & arg , & use_ivf , argi ) ) { config -> write_webm = 0 ; } else if ( arg_match ( & arg , & threads , argi ) ) { config -> cfg . g_threads = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & profile , argi ) ) { config -> cfg . g_profile = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & width , argi ) ) { config -> cfg . g_w = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & height , argi ) ) { config -> cfg . g_h = arg_parse_uint ( & arg ) ; <S2SV_StartBug> } else if ( arg_match ( & arg , & stereo_mode , argi ) ) { <S2SV_EndBug> <S2SV_StartBug> config -> stereo_fmt = arg_parse_enum_or_int ( & arg ) ; <S2SV_EndBug> } else if ( arg_match ( & arg , & timebase , argi ) ) { config -> cfg . g_timebase = arg_parse_rational ( & arg ) ; validate_positive_rational ( arg . name , & config -> cfg . g_timebase ) ; } else if ( arg_match ( & arg , & error_resilient , argi ) ) { config -> cfg . g_error_resilient = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & lag_in_frames , argi ) ) { config -> cfg . g_lag_in_frames = arg_parse_uint ( & arg ) ; if ( global -> deadline == VPX_DL_REALTIME && config -> cfg . g_lag_in_frames != 0 ) { warn ( ""non-zero<S2SV_blank>%s<S2SV_blank>option<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>realtime<S2SV_blank>mode.\\n"" , arg . name ) ; config -> cfg . g_lag_in_frames = 0 ; } } else if ( arg_match ( & arg , & dropframe_thresh , argi ) ) { config -> cfg . rc_dropframe_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & resize_allowed , argi ) ) { config -> cfg . rc_resize_allowed = arg_parse_uint ( & arg ) ; <S2SV_StartBug> } else if ( arg_match ( & arg , & resize_up_thresh , argi ) ) { <S2SV_EndBug> config -> cfg . rc_resize_up_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & resize_down_thresh , argi ) ) { config -> cfg . rc_resize_down_thresh = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & end_usage , argi ) ) { config -> cfg . rc_end_usage = arg_parse_enum_or_int ( & arg ) ; } else if ( arg_match ( & arg , & target_bitrate , argi ) ) { config -> cfg . rc_target_bitrate = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & min_quantizer , argi ) ) { config -> cfg . rc_min_quantizer = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & max_quantizer , argi ) ) { config -> cfg . rc_max_quantizer = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & undershoot_pct , argi ) ) { config -> cfg . rc_undershoot_pct = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & overshoot_pct , argi ) ) { config -> cfg . rc_overshoot_pct = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_sz , argi ) ) { config -> cfg . rc_buf_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_initial_sz , argi ) ) { config -> cfg . rc_buf_initial_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & buf_optimal_sz , argi ) ) { config -> cfg . rc_buf_optimal_sz = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & bias_pct , argi ) ) { config -> cfg . rc_2pass_vbr_bias_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & minsection_pct , argi ) ) { config -> cfg . rc_2pass_vbr_minsection_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & maxsection_pct , argi ) ) { config -> cfg . rc_2pass_vbr_maxsection_pct = arg_parse_uint ( & arg ) ; if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n"" , arg . name ) ; } else if ( arg_match ( & arg , & kf_min_dist , argi ) ) { config -> cfg . kf_min_dist = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & kf_max_dist , argi ) ) { config -> cfg . kf_max_dist = arg_parse_uint ( & arg ) ; config -> have_kf_max_dist = 1 ; } else if ( arg_match ( & arg , & kf_disabled , argi ) ) { <S2SV_StartBug> config -> cfg . kf_mode = VPX_KF_DISABLED ; <S2SV_EndBug> } else { int i , match = 0 ; for ( i = 0 ; ctrl_args [ i ] ; i ++ ) { if ( arg_match ( & arg , ctrl_args [ i ] , argi ) ) { int j ; match = 1 ; for ( j = 0 ; j < config -> arg_ctrl_cnt ; j ++ ) <S2SV_StartBug> if ( config -> arg_ctrls [ j ] [ 0 ] == ctrl_args_map [ i ] ) <S2SV_EndBug> break ; <S2SV_StartBug> assert ( j < ARG_CTRL_CNT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> if ( j < ARG_CTRL_CNT_MAX ) { <S2SV_EndBug> config -> arg_ctrls [ j ] [ 0 ] = ctrl_args_map [ i ] ; config -> arg_ctrls [ j ] [ 1 ] = arg_parse_enum_or_int ( & arg ) ; if ( j == config -> arg_ctrl_cnt ) config -> arg_ctrl_cnt ++ ; } } } if ( ! match ) argj ++ ; } } <S2SV_StartBug> return eos_mark_found ; <S2SV_EndBug> }
","<S2SV_ModStart> = 0 ; # if CONFIG_VP9_HIGHBITDEPTH int test_16bit_internal = 0 ; # endif <S2SV_ModStart> ; # endif # if CONFIG_VP10_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp10"" ) == 0 ) { ctrl_args = vp10_args ; ctrl_args_map = vp10_arg_ctrl_map ; # endif <S2SV_ModStart> } if ( arg_match ( & arg , & outputfile , argi ) ) { config -> out_fn = arg . val ; } else if ( arg_match ( & arg , & fpf_name , argi ) ) { config -> stats_fn = arg . val ; # if CONFIG_FP_MB_STATS } else if ( arg_match ( & arg , & fpmbf_name , argi ) ) { config -> fpmb_stats_fn = arg . val ; # endif } else if ( arg_match ( & arg , & use_webm , argi ) ) { # if CONFIG_WEBM_IO config -> write_webm = 1 ; # else die ( ""Error:<S2SV_blank>--webm<S2SV_blank>specified<S2SV_blank>but<S2SV_blank>webm<S2SV_blank>is<S2SV_blank>disabled."" ) ; # endif } else if ( arg_match ( & arg , & use_ivf , argi ) ) { config -> write_webm = 0 <S2SV_ModEnd> ; } else <S2SV_ModStart> arg ) ; # if CONFIG_VP9_HIGHBITDEPTH } else if ( arg_match ( & arg , & bitdeptharg , argi ) ) { config -> cfg . g_bit_depth = arg_parse_enum_or_int ( & arg ) ; } else if ( arg_match ( & arg , & inbitdeptharg , argi ) ) { config -> cfg . g_input_bit_depth = arg_parse_uint ( & arg ) ; # endif # if CONFIG_WEBM_IO <S2SV_ModStart> arg ) ; # endif <S2SV_ModStart> arg , & resize_width , argi ) ) { config -> cfg . rc_scaled_width = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & resize_height , argi ) ) { config -> cfg . rc_scaled_height = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & <S2SV_ModStart> = VPX_KF_DISABLED ; # if CONFIG_VP9_HIGHBITDEPTH } else if ( arg_match ( & arg , & test16bitinternalarg , argi ) ) { if ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 || strcmp ( global -> codec -> name , ""vp10"" ) == 0 ) { test_16bit_internal = 1 ; } # endif <S2SV_ModStart> ) if ( ctrl_args_map != NULL && <S2SV_ModStart> ( j < ( int ) <S2SV_ModStart> ; if ( ctrl_args_map != NULL && j < ( int ) <S2SV_ModEnd> ARG_CTRL_CNT_MAX ) { <S2SV_ModStart> ; } } # if CONFIG_VP9_HIGHBITDEPTH if ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 || strcmp ( global -> codec -> name , ""vp10"" ) == 0 ) { config -> use_16bit_internal = test_16bit_internal | ( config -> cfg . g_profile > 1 ) ; } # endif
"
156,"CWE-264 static int server_input_global_request ( int type , u_int32_t seq , void * ctxt ) { char * rtype ; int want_reply ; int r , success = 0 , allocated_listen_port = 0 ; struct sshbuf * resp = NULL ; rtype = packet_get_string ( NULL ) ; want_reply = packet_get_char ( ) ; debug ( ""server_input_global_request:<S2SV_blank>rtype<S2SV_blank>%s<S2SV_blank>want_reply<S2SV_blank>%d"" , rtype , want_reply ) ; if ( strcmp ( rtype , ""tcpip-forward"" ) == 0 ) { struct passwd * pw ; struct Forward fwd ; pw = the_authctxt -> pw ; if ( pw == NULL || ! the_authctxt -> valid ) fatal ( ""server_input_global_request:<S2SV_blank>no/invalid<S2SV_blank>user"" ) ; memset ( & fwd , 0 , sizeof ( fwd ) ) ; fwd . listen_host = packet_get_string ( NULL ) ; fwd . listen_port = ( u_short ) packet_get_int ( ) ; debug ( ""server_input_global_request:<S2SV_blank>tcpip-forward<S2SV_blank>listen<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d"" , fwd . listen_host , fwd . listen_port ) ; if ( ( options . allow_tcp_forwarding & FORWARD_REMOTE ) == 0 || no_port_forwarding_flag || options . disable_forwarding || ( ! want_reply && fwd . listen_port == 0 ) || ( fwd . listen_port != 0 && ! bind_permitted ( fwd . listen_port , pw -> pw_uid ) ) ) { success = 0 ; packet_send_debug ( ""Server<S2SV_blank>has<S2SV_blank>disabled<S2SV_blank>port<S2SV_blank>forwarding."" ) ; } else { success = channel_setup_remote_fwd_listener ( & fwd , & allocated_listen_port , & options . fwd_opts ) ; } free ( fwd . listen_host ) ; if ( ( resp = sshbuf_new ( ) ) == NULL ) fatal ( ""%s:<S2SV_blank>sshbuf_new"" , __func__ ) ; if ( allocated_listen_port != 0 && ( r = sshbuf_put_u32 ( resp , allocated_listen_port ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put_u32:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; } else if ( strcmp ( rtype , ""cancel-tcpip-forward"" ) == 0 ) { struct Forward fwd ; memset ( & fwd , 0 , sizeof ( fwd ) ) ; fwd . listen_host = packet_get_string ( NULL ) ; fwd . listen_port = ( u_short ) packet_get_int ( ) ; debug ( ""%s:<S2SV_blank>cancel-tcpip-forward<S2SV_blank>addr<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d"" , __func__ , fwd . listen_host , fwd . listen_port ) ; success = channel_cancel_rport_listener ( & fwd ) ; free ( fwd . listen_host ) ; } else if ( strcmp ( rtype , ""streamlocal-forward@openssh.com"" ) == 0 ) { struct Forward fwd ; memset ( & fwd , 0 , sizeof ( fwd ) ) ; fwd . listen_path = packet_get_string ( NULL ) ; debug ( ""server_input_global_request:<S2SV_blank>streamlocal-forward<S2SV_blank>listen<S2SV_blank>path<S2SV_blank>%s"" , fwd . listen_path ) ; if ( ( options . allow_streamlocal_forwarding & FORWARD_REMOTE ) == 0 <S2SV_StartBug> || no_port_forwarding_flag || options . disable_forwarding ) { <S2SV_EndBug> success = 0 ; packet_send_debug ( ""Server<S2SV_blank>has<S2SV_blank>disabled<S2SV_blank>port<S2SV_blank>forwarding."" ) ; } else { success = channel_setup_remote_fwd_listener ( & fwd , NULL , & options . fwd_opts ) ; } free ( fwd . listen_path ) ; } else if ( strcmp ( rtype , ""cancel-streamlocal-forward@openssh.com"" ) == 0 ) { struct Forward fwd ; memset ( & fwd , 0 , sizeof ( fwd ) ) ; fwd . listen_path = packet_get_string ( NULL ) ; debug ( ""%s:<S2SV_blank>cancel-streamlocal-forward<S2SV_blank>path<S2SV_blank>%s"" , __func__ , fwd . listen_path ) ; success = channel_cancel_rport_listener ( & fwd ) ; free ( fwd . listen_path ) ; } else if ( strcmp ( rtype , ""no-more-sessions@openssh.com"" ) == 0 ) { no_more_sessions = 1 ; success = 1 ; } else if ( strcmp ( rtype , ""hostkeys-prove-00@openssh.com"" ) == 0 ) { success = server_input_hostkeys_prove ( & resp ) ; } if ( want_reply ) { packet_start ( success ? SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE ) ; if ( success && resp != NULL ) ssh_packet_put_raw ( active_state , sshbuf_ptr ( resp ) , sshbuf_len ( resp ) ) ; packet_send ( ) ; packet_write_wait ( ) ; } free ( rtype ) ; sshbuf_free ( resp ) ; return 0 ; }
","<S2SV_ModStart> options . disable_forwarding || ! use_privsep
"
157,"CWE-264 static void l2tp_eth_dev_setup ( struct net_device * dev ) { ether_setup ( dev ) ; <S2SV_StartBug> dev -> netdev_ops = & l2tp_eth_netdev_ops ; <S2SV_EndBug> dev -> destructor = free_netdev ; }
","<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
"
158,"CWE-400 static Image * ReadCINImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define MonoColorType 1 # define RGBColorType 3 char property [ MagickPathExtent ] ; CINInfo cin ; const unsigned char * pixels ; Image * image ; MagickBooleanType status ; MagickOffsetType offset ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; register Quantum * q ; size_t length ; ssize_t count , y ; unsigned char magick [ 4 ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } offset = 0 ; count = ReadBlob ( image , 4 , magick ) ; offset += count ; if ( ( count != 4 ) || ( ( LocaleNCompare ( ( char * ) magick , ""\\200\\052\\137\\327"" , 4 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; memset ( & cin , 0 , sizeof ( cin ) ) ; image -> endian = ( magick [ 0 ] == 0x80 ) && ( magick [ 1 ] == 0x2a ) && ( magick [ 2 ] == 0x5f ) && ( magick [ 3 ] == 0xd7 ) ? MSBEndian : LSBEndian ; cin . file . image_offset = ReadBlobLong ( image ) ; offset += 4 ; cin . file . generic_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . industry_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . user_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . file_size = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . file . version ) , ( unsigned char * ) cin . file . version ) ; ( void ) CopyMagickString ( property , cin . file . version , sizeof ( cin . file . version ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.version"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . filename ) , ( unsigned char * ) cin . file . filename ) ; ( void ) CopyMagickString ( property , cin . file . filename , sizeof ( cin . file . filename ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.filename"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_date ) , ( unsigned char * ) cin . file . create_date ) ; ( void ) CopyMagickString ( property , cin . file . create_date , sizeof ( cin . file . create_date ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.create_date"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_time ) , ( unsigned char * ) cin . file . create_time ) ; ( void ) CopyMagickString ( property , cin . file . create_time , sizeof ( cin . file . create_time ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.create_time"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . reserve ) , ( unsigned char * ) cin . file . reserve ) ; cin . image . orientation = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; if ( cin . image . orientation != ( unsigned char ) ( ~ 0 ) ) ( void ) FormatImageProperty ( image , ""dpx:image.orientation"" , ""%d"" , cin . image . orientation ) ; switch ( cin . image . orientation ) { default : case 0 : image -> orientation = TopLeftOrientation ; break ; case 1 : image -> orientation = TopRightOrientation ; break ; case 2 : image -> orientation = BottomLeftOrientation ; break ; case 3 : image -> orientation = BottomRightOrientation ; break ; case 4 : image -> orientation = LeftTopOrientation ; break ; case 5 : image -> orientation = RightTopOrientation ; break ; case 6 : image -> orientation = LeftBottomOrientation ; break ; case 7 : image -> orientation = RightBottomOrientation ; break ; } cin . image . number_channels = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; offset += ReadBlob ( image , sizeof ( cin . image . reserve1 ) , ( unsigned char * ) cin . image . reserve1 ) ; for ( i = 0 ; i < 8 ; i ++ ) { cin . image . channel [ i ] . designator [ 0 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . designator [ 1 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . reserve = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . pixels_per_line = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . lines_per_image = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_quantity = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_quantity = ReadBlobFloat ( image ) ; offset += 4 ; } cin . image . white_point [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 0 ] ) != MagickFalse ) image -> chromaticity . white_point . x = cin . image . white_point [ 0 ] ; cin . image . white_point [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 1 ] ) != MagickFalse ) image -> chromaticity . white_point . y = cin . image . white_point [ 1 ] ; cin . image . red_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . red_primary_chromaticity [ 0 ] ; cin . image . red_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . red_primary . y = cin . image . red_primary_chromaticity [ 1 ] ; cin . image . green_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . green_primary_chromaticity [ 0 ] ; cin . image . green_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . green_primary . y = cin . image . green_primary_chromaticity [ 1 ] ; cin . image . blue_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . blue_primary . x = cin . image . blue_primary_chromaticity [ 0 ] ; cin . image . blue_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . blue_primary . y = cin . image . blue_primary_chromaticity [ 1 ] ; offset += ReadBlob ( image , sizeof ( cin . image . label ) , ( unsigned char * ) cin . image . label ) ; ( void ) CopyMagickString ( property , cin . image . label , sizeof ( cin . image . label ) ) ; ( void ) SetImageProperty ( image , ""dpx:image.label"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . image . reserve ) , ( unsigned char * ) cin . image . reserve ) ; cin . data_format . interleave = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . packing = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sign = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sense = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . line_pad = ReadBlobLong ( image ) ; offset += 4 ; cin . data_format . channel_pad = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . data_format . reserve ) , ( unsigned char * ) cin . data_format . reserve ) ; cin . origination . x_offset = ReadBlobSignedLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . x_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:origination.x_offset"" , ""%.20g"" , ( double ) cin . origination . x_offset ) ; cin . origination . y_offset = ( ssize_t ) ReadBlobLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . y_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:origination.y_offset"" , ""%.20g"" , ( double ) cin . origination . y_offset ) ; offset += ReadBlob ( image , sizeof ( cin . origination . filename ) , ( unsigned char * ) cin . origination . filename ) ; ( void ) CopyMagickString ( property , cin . origination . filename , sizeof ( cin . origination . filename ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.filename"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_date ) , ( unsigned char * ) cin . origination . create_date ) ; ( void ) CopyMagickString ( property , cin . origination . create_date , sizeof ( cin . origination . create_date ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.create_date"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_time ) , ( unsigned char * ) cin . origination . create_time ) ; ( void ) CopyMagickString ( property , cin . origination . create_time , sizeof ( cin . origination . create_time ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.create_time"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . device ) , ( unsigned char * ) cin . origination . device ) ; ( void ) CopyMagickString ( property , cin . origination . device , sizeof ( cin . origination . device ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.device"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . model ) , ( unsigned char * ) cin . origination . model ) ; ( void ) CopyMagickString ( property , cin . origination . model , sizeof ( cin . origination . model ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.model"" , property , exception ) ; ( void ) memset ( cin . origination . serial , 0 , sizeof ( cin . origination . serial ) ) ; offset += ReadBlob ( image , sizeof ( cin . origination . serial ) , ( unsigned char * ) cin . origination . serial ) ; ( void ) CopyMagickString ( property , cin . origination . serial , sizeof ( cin . origination . serial ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.serial"" , property , exception ) ; cin . origination . x_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . y_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . gamma = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . origination . gamma ) != MagickFalse ) image -> gamma = cin . origination . gamma ; offset += ReadBlob ( image , sizeof ( cin . origination . reserve ) , ( unsigned char * ) cin . origination . reserve ) ; if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { int c ; cin . film . id = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . id ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.id"" , ""%d"" , cin . film . id ) ; cin . film . type = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . type ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.type"" , ""%d"" , cin . film . type ) ; cin . film . offset = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . offset ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.offset"" , ""%d"" , cin . film . offset ) ; cin . film . reserve1 = ReadBlobByte ( image ) ; offset ++ ; cin . film . prefix = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . prefix != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:film.prefix"" , ""%.20g"" , ( double ) cin . film . prefix ) ; cin . film . count = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . film . format ) , ( unsigned char * ) cin . film . format ) ; ( void ) CopyMagickString ( property , cin . film . format , sizeof ( cin . film . format ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.format"" , property , exception ) ; cin . film . frame_position = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . frame_position != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_position"" , ""%.20g"" , ( double ) cin . film . frame_position ) ; cin . film . frame_rate = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . film . frame_rate ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_rate"" , ""%g"" , cin . film . frame_rate ) ; offset += ReadBlob ( image , sizeof ( cin . film . frame_id ) , ( unsigned char * ) cin . film . frame_id ) ; ( void ) CopyMagickString ( property , cin . film . frame_id , sizeof ( cin . film . frame_id ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.frame_id"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . film . slate_info ) , ( unsigned char * ) cin . film . slate_info ) ; ( void ) CopyMagickString ( property , cin . film . slate_info , sizeof ( cin . film . slate_info ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.slate_info"" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . film . reserve ) , ( unsigned char * ) cin . film . reserve ) ; } if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { StringInfo * profile ; if ( cin . file . user_length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; profile = BlobToStringInfo ( ( const unsigned char * ) NULL , cin . file . user_length ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; offset += ReadBlob ( image , GetStringInfoLength ( profile ) , GetStringInfoDatum ( profile ) ) ; ( void ) SetImageProfile ( image , ""dpx:user.data"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; } image -> depth = cin . image . channel [ 0 ] . bits_per_pixel ; image -> columns = cin . image . channel [ 0 ] . pixels_per_line ; image -> rows = cin . image . channel [ 0 ] . lines_per_image ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; } <S2SV_StartBug> for ( ; offset < ( MagickOffsetType ) cin . file . image_offset ; offset ++ ) <S2SV_EndBug> { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } if ( offset < ( MagickOffsetType ) cin . file . image_offset ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; quantum_info -> quantum = 32 ; quantum_info -> pack = MagickFalse ; quantum_type = RGBQuantum ; length = GetQuantumExtent ( image , quantum_info , quantum_type ) ; length = GetBytesPerRow ( image -> columns , 3 , image -> depth , MagickTrue ) ; if ( cin . image . number_channels == 1 ) { quantum_type = GrayQuantum ; length = GetBytesPerRow ( image -> columns , 1 , image -> depth , MagickTrue ) ; } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( ( size_t ) count != length ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } SetQuantumImageType ( image , quantum_type ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; SetImageColorspace ( image , LogColorspace , exception ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) ; } if ( ( ( MagickSizeType ) image -> columns * image -> rows ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;
"
159,"CWE-200 static bool_t svcauth_gss_accept_sec_context ( struct svc_req * rqst , struct rpc_gss_init_res * gr ) { struct svc_rpc_gss_data * gd ; struct rpc_gss_cred * gc ; gss_buffer_desc recv_tok , seqbuf ; gss_OID mech ; OM_uint32 maj_stat = 0 , min_stat = 0 , ret_flags , seq ; log_debug ( ""in<S2SV_blank>svcauth_gss_accept_context()"" ) ; gd = SVCAUTH_PRIVATE ( rqst -> rq_xprt -> xp_auth ) ; gc = ( struct rpc_gss_cred * ) rqst -> rq_clntcred ; memset ( gr , 0 , sizeof ( * gr ) ) ; memset ( & recv_tok , 0 , sizeof ( recv_tok ) ) ; if ( ! svc_getargs ( rqst -> rq_xprt , xdr_rpc_gss_init_args , ( caddr_t ) & recv_tok ) ) return ( FALSE ) ; gr -> gr_major = gss_accept_sec_context ( & gr -> gr_minor , & gd -> ctx , svcauth_gss_creds , & recv_tok , GSS_C_NO_CHANNEL_BINDINGS , & gd -> client_name , & mech , & gr -> gr_token , & ret_flags , NULL , NULL ) ; svc_freeargs ( rqst -> rq_xprt , xdr_rpc_gss_init_args , ( caddr_t ) & recv_tok ) ; log_status ( ""accept_sec_context"" , gr -> gr_major , gr -> gr_minor ) ; if ( gr -> gr_major != GSS_S_COMPLETE && gr -> gr_major != GSS_S_CONTINUE_NEEDED ) { badauth ( gr -> gr_major , gr -> gr_minor , rqst -> rq_xprt ) ; gd -> ctx = GSS_C_NO_CONTEXT ; goto errout ; } <S2SV_StartBug> if ( ( gr -> gr_ctx . value = mem_alloc ( sizeof ( gss_union_ctx_id_desc ) ) ) == NULL ) { <S2SV_EndBug> fprintf ( stderr , ""svcauth_gss_accept_context:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" ) ; goto errout ; } <S2SV_StartBug> memcpy ( gr -> gr_ctx . value , gd -> ctx , sizeof ( gss_union_ctx_id_desc ) ) ; <S2SV_EndBug> gr -> gr_ctx . length = sizeof ( gss_union_ctx_id_desc ) ; gr -> gr_win = sizeof ( gd -> seqmask ) * 8 ; gd -> sec . mech = mech ; gd -> sec . qop = GSS_C_QOP_DEFAULT ; gd -> sec . svc = gc -> gc_svc ; gd -> seq = gc -> gc_seq ; gd -> win = gr -> gr_win ; if ( gr -> gr_major == GSS_S_COMPLETE ) { # ifdef SPKM if ( ! g_OID_equal ( gss_mech_spkm3 , mech ) ) { # endif maj_stat = gss_display_name ( & min_stat , gd -> client_name , & gd -> cname , & gd -> sec . mech ) ; # ifdef SPKM } # endif if ( maj_stat != GSS_S_COMPLETE ) { log_status ( ""display_name"" , maj_stat , min_stat ) ; goto errout ; } # ifdef DEBUG # ifdef HAVE_HEIMDAL log_debug ( ""accepted<S2SV_blank>context<S2SV_blank>for<S2SV_blank>%.*s<S2SV_blank>with<S2SV_blank>"" ""<mech<S2SV_blank>{},<S2SV_blank>qop<S2SV_blank>%d,<S2SV_blank>svc<S2SV_blank>%d>"" , gd -> cname . length , ( char * ) gd -> cname . value , gd -> sec . qop , gd -> sec . svc ) ; # else { gss_buffer_desc mechname ; gss_oid_to_str ( & min_stat , mech , & mechname ) ; log_debug ( ""accepted<S2SV_blank>context<S2SV_blank>for<S2SV_blank>%.*s<S2SV_blank>with<S2SV_blank>"" ""<mech<S2SV_blank>%.*s,<S2SV_blank>qop<S2SV_blank>%d,<S2SV_blank>svc<S2SV_blank>%d>"" , gd -> cname . length , ( char * ) gd -> cname . value , mechname . length , ( char * ) mechname . value , gd -> sec . qop , gd -> sec . svc ) ; gss_release_buffer ( & min_stat , & mechname ) ; } # endif # endif seq = htonl ( gr -> gr_win ) ; seqbuf . value = & seq ; seqbuf . length = sizeof ( seq ) ; gss_release_buffer ( & min_stat , & gd -> checksum ) ; maj_stat = gss_sign ( & min_stat , gd -> ctx , GSS_C_QOP_DEFAULT , & seqbuf , & gd -> checksum ) ; if ( maj_stat != GSS_S_COMPLETE ) { goto errout ; } rqst -> rq_xprt -> xp_verf . oa_flavor = RPCSEC_GSS ; rqst -> rq_xprt -> xp_verf . oa_base = gd -> checksum . value ; rqst -> rq_xprt -> xp_verf . oa_length = gd -> checksum . length ; } return ( TRUE ) ; errout : gss_release_buffer ( & min_stat , & gr -> gr_token ) ; return ( FALSE ) ; }
","<S2SV_ModStart> errout ; } <S2SV_ModEnd> gr -> gr_ctx <S2SV_ModStart> . value = ""xxxx"" ; <S2SV_ModEnd> gr -> gr_ctx <S2SV_ModStart> -> gr_ctx . length = 4 <S2SV_ModEnd> ; gr ->
"
160,"CWE-200 static int ext4_ext_grow_indepth ( handle_t * handle , struct inode * inode , unsigned int flags ) { struct ext4_extent_header * neh ; struct buffer_head * bh ; ext4_fsblk_t newblock , goal = 0 ; struct ext4_super_block * es = EXT4_SB ( inode -> i_sb ) -> s_es ; int err = 0 ; <S2SV_StartBug> if ( ext_depth ( inode ) ) <S2SV_EndBug> goal = ext4_idx_pblock ( EXT_FIRST_INDEX ( ext_inode_hdr ( inode ) ) ) ; if ( goal > le32_to_cpu ( es -> s_first_data_block ) ) { flags |= EXT4_MB_HINT_TRY_GOAL ; goal -- ; } else goal = ext4_inode_to_goal_block ( inode ) ; newblock = ext4_new_meta_blocks ( handle , inode , goal , flags , NULL , & err ) ; if ( newblock == 0 ) return err ; bh = sb_getblk_gfp ( inode -> i_sb , newblock , __GFP_MOVABLE | GFP_NOFS ) ; if ( unlikely ( ! bh ) ) return - ENOMEM ; lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) { unlock_buffer ( bh ) ; goto out ; } <S2SV_StartBug> memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data , <S2SV_EndBug> <S2SV_StartBug> sizeof ( EXT4_I ( inode ) -> i_data ) ) ; <S2SV_EndBug> neh = ext_block_hdr ( bh ) ; if ( ext_depth ( inode ) ) neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block_idx ( inode , 0 ) ) ; else neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block ( inode , 0 ) ) ; neh -> eh_magic = EXT4_EXT_MAGIC ; ext4_extent_block_csum_set ( inode , neh ) ; set_buffer_uptodate ( bh ) ; unlock_buffer ( bh ) ; err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; if ( err ) goto out ; neh = ext_inode_hdr ( inode ) ; neh -> eh_entries = cpu_to_le16 ( 1 ) ; ext4_idx_store_pblock ( EXT_FIRST_INDEX ( neh ) , newblock ) ; if ( neh -> eh_depth == 0 ) { neh -> eh_max = cpu_to_le16 ( ext4_ext_space_root_idx ( inode , 0 ) ) ; EXT_FIRST_INDEX ( neh ) -> ei_block = EXT_FIRST_EXTENT ( neh ) -> ee_block ; } ext_debug ( ""new<S2SV_blank>root:<S2SV_blank>num<S2SV_blank>%d(%d),<S2SV_blank>lblock<S2SV_blank>%d,<S2SV_blank>ptr<S2SV_blank>%llu\\n"" , le16_to_cpu ( neh -> eh_entries ) , le16_to_cpu ( neh -> eh_max ) , le32_to_cpu ( EXT_FIRST_INDEX ( neh ) -> ei_block ) , ext4_idx_pblock ( EXT_FIRST_INDEX ( neh ) ) ) ; le16_add_cpu ( & neh -> eh_depth , 1 ) ; ext4_mark_inode_dirty ( handle , inode ) ; out : brelse ( bh ) ; return err ; }
","<S2SV_ModStart> = 0 ; size_t ext_size = 0 ; <S2SV_ModStart> out ; } ext_size = sizeof ( EXT4_I ( inode ) -> i_data ) ; <S2SV_ModStart> -> i_data , ext_size ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size <S2SV_ModEnd> ) ; neh
"
161,"CWE-295 NOEXPORT int verify_callback ( int preverify_ok , X509_STORE_CTX * callback_ctx ) { SSL * ssl ; CLI * c ; ssl = X509_STORE_CTX_get_ex_data ( callback_ctx , SSL_get_ex_data_X509_STORE_CTX_idx ( ) ) ; c = SSL_get_ex_data ( ssl , index_ssl_cli ) ; if ( ! c -> opt -> option . verify_chain && ! c -> opt -> option . verify_peer ) { s_log ( LOG_INFO , ""Certificate<S2SV_blank>verification<S2SV_blank>disabled"" ) ; return 1 ; } <S2SV_StartBug> if ( verify_checks ( c , preverify_ok , callback_ctx ) ) { <S2SV_EndBug> SSL_SESSION * sess = SSL_get1_session ( c -> ssl ) ; if ( sess ) { int ok = SSL_SESSION_set_ex_data ( sess , index_session_authenticated , <S2SV_StartBug> ( void * ) ( - 1 ) ) ; <S2SV_EndBug> SSL_SESSION_free ( sess ) ; if ( ! ok ) { sslerror ( ""SSL_SESSION_set_ex_data"" ) ; return 0 ; } } return 1 ; } <S2SV_StartBug> if ( c -> opt -> option . client || c -> opt -> protocol ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> if ( c -> opt -> redirect_addr . names ) <S2SV_EndBug> return 1 ; return 0 ; }
","<S2SV_ModStart> callback_ctx ) ) return 1 ; if ( c -> opt -> option . client || c -> opt -> protocol ) return 0 ; if ( c -> opt -> redirect_addr . names ) <S2SV_ModStart> , index_session_authenticated , NULL <S2SV_ModEnd> ) ; SSL_SESSION_free <S2SV_ModStart> 1 ; } <S2SV_ModEnd> return 0 ; <S2SV_ModStart> return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
162,"CWE-264 int create_user_ns ( struct cred * new ) { struct user_namespace * ns , * parent_ns = new -> user_ns ; kuid_t owner = new -> euid ; kgid_t group = new -> egid ; <S2SV_StartBug> int ret ; <S2SV_EndBug> if ( ! kuid_has_mapping ( parent_ns , owner ) || ! kgid_has_mapping ( parent_ns , group ) ) return - EPERM ; ns = kmem_cache_zalloc ( user_ns_cachep , GFP_KERNEL ) ; if ( ! ns ) return - ENOMEM ; ret = proc_alloc_inum ( & ns -> proc_inum ) ; if ( ret ) { kmem_cache_free ( user_ns_cachep , ns ) ; return ret ; } atomic_set ( & ns -> count , 1 ) ; ns -> parent = parent_ns ; ns -> owner = owner ; ns -> group = group ; set_cred_user_ns ( new , ns ) ; return 0 ; }
","<S2SV_ModStart> ; int ret ; if ( current_chrooted ( ) ) return - EPERM
"
163,"CWE-203 int secure_decrypt ( void * data , unsigned int data_length , int is_signed ) { at91_aes_key_size_t key_size ; unsigned int cmac_key [ 8 ] , cipher_key [ 8 ] ; unsigned int iv [ AT91_AES_IV_SIZE_WORD ] ; unsigned int computed_cmac [ AT91_AES_BLOCK_SIZE_WORD ] ; unsigned int fixed_length ; const unsigned int * cmac ; int rc = - 1 ; init_keys ( & key_size , cipher_key , cmac_key , iv ) ; at91_aes_init ( ) ; if ( is_signed ) { if ( at91_aes_cmac ( data_length , data , computed_cmac , key_size , cmac_key ) ) goto exit ; fixed_length = at91_aes_roundup ( data_length ) ; cmac = ( const unsigned int * ) ( ( char * ) data + fixed_length ) ; <S2SV_StartBug> if ( memcmp ( cmac , computed_cmac , AT91_AES_BLOCK_SIZE_BYTE ) ) <S2SV_EndBug> goto exit ; } if ( at91_aes_cbc ( data_length , data , data , 0 , key_size , cipher_key , iv ) ) goto exit ; rc = 0 ; exit : at91_aes_cleanup ( ) ; memset ( cmac_key , 0 , sizeof ( cmac_key ) ) ; memset ( cipher_key , 0 , sizeof ( cipher_key ) ) ; memset ( iv , 0 , sizeof ( iv ) ) ; return rc ; }
","<S2SV_ModStart> ; if ( ! consttime_memequal <S2SV_ModEnd> ( cmac ,
"
164,"CWE-20 static int get_cox ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c ) { uint8_t byte ; if ( bytestream2_get_bytes_left ( & s -> g ) < 5 ) return AVERROR_INVALIDDATA ; c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ; if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) { av_log ( s -> avctx , AV_LOG_ERROR , ""nreslevels<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\n"" , c -> nreslevels ) ; return AVERROR_INVALIDDATA ; } <S2SV_StartBug> if ( c -> nreslevels < s -> reduction_factor ) <S2SV_EndBug> <S2SV_StartBug> c -> nreslevels2decode = 1 ; <S2SV_EndBug> else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ; c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""cblk<S2SV_blank>size<S2SV_blank>invalid\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , ""cblk<S2SV_blank>size<S2SV_blank>><S2SV_blank>64"" ) ; return AVERROR_PATCHWELCOME ; } c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ; if ( c -> cblk_style != 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , ""extra<S2SV_blank>cblk<S2SV_blank>styles<S2SV_blank>%X\\n"" , c -> cblk_style ) ; } c -> transform = bytestream2_get_byteu ( & s -> g ) ; if ( ( s -> avctx -> flags & CODEC_FLAG_BITEXACT ) && ( c -> transform == FF_DWT97 ) ) c -> transform = FF_DWT97_INT ; if ( c -> csty & JPEG2000_CSTY_PREC ) { int i ; for ( i = 0 ; i < c -> nreslevels ; i ++ ) { byte = bytestream2_get_byte ( & s -> g ) ; c -> log2_prec_widths [ i ] = byte & 0x0F ; c -> log2_prec_heights [ i ] = ( byte >> 4 ) & 0x0F ; } } else { memset ( c -> log2_prec_widths , 15 , sizeof ( c -> log2_prec_widths ) ) ; memset ( c -> log2_prec_heights , 15 , sizeof ( c -> log2_prec_heights ) ) ; } return 0 ; }
","<S2SV_ModStart> c -> nreslevels <= <S2SV_ModEnd> s -> reduction_factor <S2SV_ModStart> -> reduction_factor ) { av_log ( s -> avctx , AV_LOG_ERROR , ""reduction_factor<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>this<S2SV_blank>bitstream,<S2SV_blank>max<S2SV_blank>is<S2SV_blank>%d\\n"" , c -> nreslevels - 1 ) ; s -> reduction_factor = c -> nreslevels - 1 ; return AVERROR ( EINVAL ) ; } <S2SV_ModEnd> c -> nreslevels2decode
"
165,"CWE-000 qboolean S_AL_Init ( soundInterface_t * si ) { # ifdef USE_OPENAL const char * device = NULL ; const char * inputdevice = NULL ; int i ; if ( ! si ) { return qfalse ; } for ( i = 0 ; i < MAX_RAW_STREAMS ; i ++ ) { streamSourceHandles [ i ] = - 1 ; streamPlaying [ i ] = qfalse ; streamSources [ i ] = 0 ; streamNumBuffers [ i ] = 0 ; streamBufIndex [ i ] = 0 ; } s_alPrecache = Cvar_Get ( ""s_alPrecache"" , ""1"" , CVAR_ARCHIVE ) ; s_alGain = Cvar_Get ( ""s_alGain"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alSources = Cvar_Get ( ""s_alSources"" , ""128"" , CVAR_ARCHIVE ) ; s_alDopplerFactor = Cvar_Get ( ""s_alDopplerFactor"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alDopplerSpeed = Cvar_Get ( ""s_alDopplerSpeed"" , ""9000"" , CVAR_ARCHIVE ) ; s_alMinDistance = Cvar_Get ( ""s_alMinDistance"" , ""120"" , CVAR_CHEAT ) ; s_alMaxDistance = Cvar_Get ( ""s_alMaxDistance"" , ""1024"" , CVAR_CHEAT ) ; s_alRolloff = Cvar_Get ( ""s_alRolloff"" , ""2"" , CVAR_CHEAT ) ; s_alGraceDistance = Cvar_Get ( ""s_alGraceDistance"" , ""512"" , CVAR_CHEAT ) ; <S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> if ( ! QAL_Init ( s_alDriver -> string ) ) { # if defined ( _WIN32 ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""OpenAL64.dll"" ) ) { # elif defined ( __APPLE__ ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""/System/Library/Frameworks/OpenAL.framework/OpenAL"" ) ) { # else if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) || ! QAL_Init ( ALDRIVER_DEFAULT ) ) { # endif return qfalse ; } } device = s_alDevice -> string ; if ( device && ! * device ) device = NULL ; inputdevice = s_alInputDevice -> string ; if ( inputdevice && ! * inputdevice ) inputdevice = NULL ; enumeration_all_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATE_ALL_EXT"" ) ; enumeration_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATION_EXT"" ) ; if ( enumeration_ext || enumeration_all_ext ) { char devicenames [ 16384 ] = """" ; const char * devicelist ; # ifdef _WIN32 const char * defaultdevice ; # endif int curlen ; if ( enumeration_all_ext ) { devicelist = qalcGetString ( NULL , ALC_ALL_DEVICES_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_ALL_DEVICES_SPECIFIER ) ; # endif } else { devicelist = qalcGetString ( NULL , ALC_DEVICE_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_DEVICE_SPECIFIER ) ; # endif enumeration_ext = qtrue ; } # ifdef _WIN32 if ( ! device && defaultdevice && ! strcmp ( defaultdevice , ""Generic<S2SV_blank>Hardware"" ) ) device = ""Generic<S2SV_blank>Software"" ; # endif if ( devicelist ) { while ( ( curlen = strlen ( devicelist ) ) ) { Q_strcat ( devicenames , sizeof ( devicenames ) , devicelist ) ; Q_strcat ( devicenames , sizeof ( devicenames ) , ""\\n"" ) ; devicelist += curlen + 1 ; } } s_alAvailableDevices = Cvar_Get ( ""s_alAvailableDevices"" , devicenames , CVAR_ROM | CVAR_NORESTART ) ; } alDevice = qalcOpenDevice ( device ) ; if ( ! alDevice && device ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , device ) ; alDevice = qalcOpenDevice ( NULL ) ; } if ( ! alDevice ) { QAL_Shutdown ( ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device.\\n"" ) ; return qfalse ; } alContext = qalcCreateContext ( alDevice , NULL ) ; if ( ! alContext ) { QAL_Shutdown ( ) ; qalcCloseDevice ( alDevice ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>OpenAL<S2SV_blank>context.\\n"" ) ; return qfalse ; } qalcMakeContextCurrent ( alContext ) ; S_AL_BufferInit ( ) ; S_AL_SrcInit ( ) ; Com_Printf ( ""Allocated<S2SV_blank>%d<S2SV_blank>sources.\\n"" , srcCount ) ; qalDistanceModel ( AL_INVERSE_DISTANCE_CLAMPED ) ; qalDopplerFactor ( s_alDopplerFactor -> value ) ; qalSpeedOfSound ( s_alDopplerSpeed -> value ) ; # ifdef USE_VOIP s_alCapture = Cvar_Get ( ""s_alCapture"" , ""1"" , CVAR_ARCHIVE | CVAR_LATCH ) ; if ( ! s_alCapture -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>by<S2SV_blank>user<S2SV_blank>(\'+set<S2SV_blank>s_alCapture<S2SV_blank>1\'<S2SV_blank>to<S2SV_blank>enable)\\n"" ) ; } # if USE_MUMBLE else if ( cl_useMumble -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>for<S2SV_blank>Mumble<S2SV_blank>support\\n"" ) ; } # endif else { # ifdef __APPLE__ if ( qalcCaptureOpenDevice == NULL ) # else if ( ! qalcIsExtensionPresent ( NULL , ""ALC_EXT_capture"" ) ) # endif { Com_Printf ( ""No<S2SV_blank>ALC_EXT_capture<S2SV_blank>support,<S2SV_blank>can\'t<S2SV_blank>record<S2SV_blank>audio.\\n"" ) ; } else { char inputdevicenames [ 16384 ] = """" ; const char * inputdevicelist ; const char * defaultinputdevice ; int curlen ; capture_ext = qtrue ; inputdevicelist = qalcGetString ( NULL , ALC_CAPTURE_DEVICE_SPECIFIER ) ; defaultinputdevice = qalcGetString ( NULL , ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER ) ; if ( inputdevicelist ) { while ( ( curlen = strlen ( inputdevicelist ) ) ) { Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , inputdevicelist ) ; Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , ""\\n"" ) ; inputdevicelist += curlen + 1 ; } } s_alAvailableInputDevices = Cvar_Get ( ""s_alAvailableInputDevices"" , inputdevicenames , CVAR_ROM | CVAR_NORESTART ) ; Com_Printf ( ""OpenAL<S2SV_blank>default<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>is<S2SV_blank>\'%s\'\\n"" , defaultinputdevice ? defaultinputdevice : ""none"" ) ; alCaptureDevice = qalcCaptureOpenDevice ( inputdevice , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; if ( ! alCaptureDevice && inputdevice ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>Input<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , inputdevice ) ; alCaptureDevice = qalcCaptureOpenDevice ( NULL , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; } Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>%s.\\n"" , ( alCaptureDevice == NULL ) ? ""failed<S2SV_blank>to<S2SV_blank>open"" : ""opened"" ) ; } } # endif si -> Shutdown = S_AL_Shutdown ; si -> StartSound = S_AL_StartSound ; si -> StartSoundEx = S_AL_StartSoundEx ; si -> StartLocalSound = S_AL_StartLocalSound ; si -> StartBackgroundTrack = S_AL_StartBackgroundTrack ; si -> StopBackgroundTrack = S_AL_StopBackgroundTrack ; si -> StartStreamingSound = S_AL_StartStreamingSound ; si -> GetVoiceAmplitude = S_AL_GetVoiceAmplitude ; si -> RawSamples = S_AL_RawSamples ; si -> StopAllSounds = S_AL_StopAllSounds ; si -> ClearLoopingSounds = S_AL_ClearLoopingSounds ; si -> AddLoopingSound = S_AL_AddLoopingSound ; si -> AddRealLoopingSound = S_AL_AddRealLoopingSound ; si -> StopLoopingSound = S_AL_StopLoopingSound ; si -> Respatialize = S_AL_Respatialize ; si -> UpdateEntityPosition = S_AL_UpdateEntityPosition ; si -> Update = S_AL_Update ; si -> DisableSounds = S_AL_DisableSounds ; si -> BeginRegistration = S_AL_BeginRegistration ; si -> RegisterSound = S_AL_RegisterSound ; si -> ClearSoundBuffer = S_AL_ClearSoundBuffer ; si -> SoundInfo = S_AL_SoundInfo ; si -> SoundList = S_AL_SoundList ; # ifdef USE_VOIP si -> StartCapture = S_AL_StartCapture ; si -> AvailableCaptureSamples = S_AL_AvailableCaptureSamples ; si -> Capture = S_AL_Capture ; si -> StopCapture = S_AL_StopCapture ; si -> MasterGain = S_AL_MasterGain ; # endif return qtrue ; # else return qfalse ; # endif }
","<S2SV_ModStart> CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; }
"
166,"CWE-119 static int tpacket_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) { struct sock * sk ; struct packet_sock * po ; struct sockaddr_ll * sll ; union tpacket_uhdr h ; u8 * skb_head = skb -> data ; int skb_len = skb -> len ; unsigned int snaplen , res ; unsigned long status = TP_STATUS_USER ; unsigned short macoff , netoff , hdrlen ; struct sk_buff * copy_skb = NULL ; struct timespec ts ; __u32 ts_status ; <S2SV_StartBug> bool is_drop_n_account = false ; <S2SV_EndBug> BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h2 ) ) != 32 ) ; BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h3 ) ) != 48 ) ; if ( skb -> pkt_type == PACKET_LOOPBACK ) goto drop ; sk = pt -> af_packet_priv ; po = pkt_sk ( sk ) ; if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) goto drop ; if ( dev -> header_ops ) { if ( sk -> sk_type != SOCK_DGRAM ) skb_push ( skb , skb -> data - skb_mac_header ( skb ) ) ; else if ( skb -> pkt_type == PACKET_OUTGOING ) { skb_pull ( skb , skb_network_offset ( skb ) ) ; } } snaplen = skb -> len ; res = run_filter ( skb , sk , snaplen ) ; if ( ! res ) goto drop_n_restore ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) status |= TP_STATUS_CSUMNOTREADY ; else if ( skb -> pkt_type != PACKET_OUTGOING && ( skb -> ip_summed == CHECKSUM_COMPLETE || skb_csum_unnecessary ( skb ) ) ) status |= TP_STATUS_CSUM_VALID ; if ( snaplen > res ) snaplen = res ; if ( sk -> sk_type == SOCK_DGRAM ) { macoff = netoff = TPACKET_ALIGN ( po -> tp_hdrlen ) + 16 + po -> tp_reserve ; } else { unsigned int maclen = skb_network_offset ( skb ) ; netoff = TPACKET_ALIGN ( po -> tp_hdrlen + ( maclen < 16 ? 16 : maclen ) ) + po -> tp_reserve ; <S2SV_StartBug> if ( po -> has_vnet_hdr ) <S2SV_EndBug> netoff += sizeof ( struct virtio_net_hdr ) ; <S2SV_StartBug> macoff = netoff - maclen ; <S2SV_EndBug> } if ( po -> tp_version <= TPACKET_V2 ) { if ( macoff + snaplen > po -> rx_ring . frame_size ) { if ( po -> copy_thresh && atomic_read ( & sk -> sk_rmem_alloc ) < sk -> sk_rcvbuf ) { if ( skb_shared ( skb ) ) { copy_skb = skb_clone ( skb , GFP_ATOMIC ) ; } else { copy_skb = skb_get ( skb ) ; skb_head = skb -> data ; } if ( copy_skb ) skb_set_owner_r ( copy_skb , sk ) ; } snaplen = po -> rx_ring . frame_size - macoff ; <S2SV_StartBug> if ( ( int ) snaplen < 0 ) <S2SV_EndBug> <S2SV_StartBug> snaplen = 0 ; <S2SV_EndBug> } } else if ( unlikely ( macoff + snaplen > GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len ) ) { u32 nval ; nval = GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len - macoff ; pr_err_once ( ""tpacket_rcv:<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>big,<S2SV_blank>clamped<S2SV_blank>from<S2SV_blank>%u<S2SV_blank>to<S2SV_blank>%u.<S2SV_blank>macoff=%u\\n"" , snaplen , nval , macoff ) ; snaplen = nval ; if ( unlikely ( ( int ) snaplen < 0 ) ) { snaplen = 0 ; macoff = GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len ; <S2SV_StartBug> } <S2SV_EndBug> } spin_lock ( & sk -> sk_receive_queue . lock ) ; h . raw = packet_current_rx_frame ( po , skb , TP_STATUS_KERNEL , ( macoff + snaplen ) ) ; if ( ! h . raw ) goto drop_n_account ; if ( po -> tp_version <= TPACKET_V2 ) { packet_increment_rx_head ( po , & po -> rx_ring ) ; if ( po -> stats . stats1 . tp_drops ) status |= TP_STATUS_LOSING ; } po -> stats . stats1 . tp_packets ++ ; if ( copy_skb ) { status |= TP_STATUS_COPY ; __skb_queue_tail ( & sk -> sk_receive_queue , copy_skb ) ; } spin_unlock ( & sk -> sk_receive_queue . lock ) ; <S2SV_StartBug> if ( po -> has_vnet_hdr ) { <S2SV_EndBug> if ( virtio_net_hdr_from_skb ( skb , h . raw + macoff - sizeof ( struct virtio_net_hdr ) , vio_le ( ) , true ) ) { spin_lock ( & sk -> sk_receive_queue . lock ) ; goto drop_n_account ; } } skb_copy_bits ( skb , 0 , h . raw + macoff , snaplen ) ; if ( ! ( ts_status = tpacket_get_timestamp ( skb , & ts , po -> tp_tstamp ) ) ) getnstimeofday ( & ts ) ; status |= ts_status ; switch ( po -> tp_version ) { case TPACKET_V1 : h . h1 -> tp_len = skb -> len ; h . h1 -> tp_snaplen = snaplen ; h . h1 -> tp_mac = macoff ; h . h1 -> tp_net = netoff ; h . h1 -> tp_sec = ts . tv_sec ; h . h1 -> tp_usec = ts . tv_nsec / NSEC_PER_USEC ; hdrlen = sizeof ( * h . h1 ) ; break ; case TPACKET_V2 : h . h2 -> tp_len = skb -> len ; h . h2 -> tp_snaplen = snaplen ; h . h2 -> tp_mac = macoff ; h . h2 -> tp_net = netoff ; h . h2 -> tp_sec = ts . tv_sec ; h . h2 -> tp_nsec = ts . tv_nsec ; if ( skb_vlan_tag_present ( skb ) ) { h . h2 -> tp_vlan_tci = skb_vlan_tag_get ( skb ) ; h . h2 -> tp_vlan_tpid = ntohs ( skb -> vlan_proto ) ; status |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID ; } else { h . h2 -> tp_vlan_tci = 0 ; h . h2 -> tp_vlan_tpid = 0 ; } memset ( h . h2 -> tp_padding , 0 , sizeof ( h . h2 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h2 ) ; break ; case TPACKET_V3 : h . h3 -> tp_status |= status ; h . h3 -> tp_len = skb -> len ; h . h3 -> tp_snaplen = snaplen ; h . h3 -> tp_mac = macoff ; h . h3 -> tp_net = netoff ; h . h3 -> tp_sec = ts . tv_sec ; h . h3 -> tp_nsec = ts . tv_nsec ; memset ( h . h3 -> tp_padding , 0 , sizeof ( h . h3 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h3 ) ; break ; default : BUG ( ) ; } sll = h . raw + TPACKET_ALIGN ( hdrlen ) ; sll -> sll_halen = dev_parse_header ( skb , sll -> sll_addr ) ; sll -> sll_family = AF_PACKET ; sll -> sll_hatype = dev -> type ; sll -> sll_protocol = skb -> protocol ; sll -> sll_pkttype = skb -> pkt_type ; if ( unlikely ( po -> origdev ) ) sll -> sll_ifindex = orig_dev -> ifindex ; else sll -> sll_ifindex = dev -> ifindex ; smp_mb ( ) ; # if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1 if ( po -> tp_version <= TPACKET_V2 ) { u8 * start , * end ; end = ( u8 * ) PAGE_ALIGN ( ( unsigned long ) h . raw + macoff + snaplen ) ; for ( start = h . raw ; start < end ; start += PAGE_SIZE ) flush_dcache_page ( pgv_to_page ( start ) ) ; } smp_wmb ( ) ; # endif if ( po -> tp_version <= TPACKET_V2 ) { __packet_set_status ( po , h . raw , status ) ; sk -> sk_data_ready ( sk ) ; } else { prb_clear_blk_fill_status ( & po -> rx_ring ) ; } drop_n_restore : if ( skb_head != skb -> data && skb_shared ( skb ) ) { skb -> data = skb_head ; skb -> len = skb_len ; } drop : if ( ! is_drop_n_account ) consume_skb ( skb ) ; else kfree_skb ( skb ) ; return 0 ; drop_n_account : is_drop_n_account = true ; po -> stats . stats1 . tp_drops ++ ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; sk -> sk_data_ready ( sk ) ; kfree_skb ( copy_skb ) ; goto drop_n_restore ; }
","<S2SV_ModStart> ; bool is_drop_n_account = false ; bool do_vnet <S2SV_ModStart> -> has_vnet_hdr ) { <S2SV_ModStart> virtio_net_hdr ) ; do_vnet = true ; } <S2SV_ModStart> < 0 ) { <S2SV_ModStart> = 0 ; do_vnet = false ; } <S2SV_ModStart> -> max_frame_len ; do_vnet = false ; <S2SV_ModStart> ; if ( do_vnet <S2SV_ModEnd> ) { if
"
167,"CWE-000 void sctp_assoc_update ( struct sctp_association * asoc , struct sctp_association * new ) { struct sctp_transport * trans ; struct list_head * pos , * temp ; asoc -> c = new -> c ; asoc -> peer . rwnd = new -> peer . rwnd ; asoc -> peer . sack_needed = new -> peer . sack_needed ; asoc -> peer . auth_capable = new -> peer . auth_capable ; asoc -> peer . i = new -> peer . i ; sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ; list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { trans = list_entry ( pos , struct sctp_transport , transports ) ; if ( ! sctp_assoc_lookup_paddr ( new , & trans -> ipaddr ) ) { sctp_assoc_rm_peer ( asoc , trans ) ; continue ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) sctp_transport_reset ( trans ) ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) { asoc -> next_tsn = new -> next_tsn ; asoc -> ctsn_ack_point = new -> ctsn_ack_point ; asoc -> adv_peer_ack_point = new -> adv_peer_ack_point ; sctp_ssnmap_clear ( asoc -> ssnmap ) ; sctp_ulpq_flush ( & asoc -> ulpq ) ; asoc -> overall_error_count = 0 ; } else { list_for_each_entry ( trans , & new -> peer . transport_addr_list , transports ) { if ( ! sctp_assoc_lookup_paddr ( asoc , & trans -> ipaddr ) ) sctp_assoc_add_peer ( asoc , & trans -> ipaddr , GFP_ATOMIC , trans -> state ) ; } asoc -> ctsn_ack_point = asoc -> next_tsn - 1 ; asoc -> adv_peer_ack_point = asoc -> ctsn_ack_point ; if ( ! asoc -> ssnmap ) { asoc -> ssnmap = new -> ssnmap ; new -> ssnmap = NULL ; } if ( ! asoc -> assoc_id ) { sctp_assoc_set_id ( asoc , GFP_ATOMIC ) ; } } kfree ( asoc -> peer . peer_random ) ; asoc -> peer . peer_random = new -> peer . peer_random ; new -> peer . peer_random = NULL ; kfree ( asoc -> peer . peer_chunks ) ; asoc -> peer . peer_chunks = new -> peer . peer_chunks ; new -> peer . peer_chunks = NULL ; kfree ( asoc -> peer . peer_hmacs ) ; asoc -> peer . peer_hmacs = new -> peer . peer_hmacs ; new -> peer . peer_hmacs = NULL ; <S2SV_StartBug> sctp_auth_key_put ( asoc -> asoc_shared_key ) ; <S2SV_EndBug> sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ; }
","<S2SV_ModStart> = NULL ; <S2SV_ModEnd> sctp_auth_asoc_init_active_key ( asoc
"
168,"CWE-284 static bool ndp_msg_check_valid ( struct ndp_msg * msg ) { size_t len = ndp_msg_payload_len ( msg ) ; enum ndp_msg_type msg_type = ndp_msg_type ( msg ) ; if ( len < ndp_msg_type_info ( msg_type ) -> raw_struct_size ) return false ; <S2SV_StartBug> return true ; <S2SV_EndBug> }
","<S2SV_ModStart> return false ; if ( ndp_msg_type_info ( msg_type ) -> addrto_validate ) return ndp_msg_type_info ( msg_type ) -> addrto_validate ( & msg -> addrto ) ; else
"
169,"CWE-264 <S2SV_StartBug> int lsm_set_label_at ( int procfd , int on_exec , char * lsm_label ) { <S2SV_EndBug> <S2SV_StartBug> int labelfd = - 1 ; <S2SV_EndBug> int ret = 0 ; const char * name ; char * command = NULL ; name = lsm_name ( ) ; if ( strcmp ( name , ""nop"" ) == 0 ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( strcmp ( name , ""none"" ) == 0 ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( strcmp ( name , ""AppArmor"" ) == 0 ) on_exec = 0 ; <S2SV_StartBug> if ( on_exec ) { <S2SV_EndBug> labelfd = openat ( procfd , ""self/attr/exec"" , O_RDWR ) ; } else { labelfd = openat ( procfd , ""self/attr/current"" , O_RDWR ) ; } if ( labelfd < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>LSM<S2SV_blank>label"" ) ; ret = - 1 ; goto out ; } if ( strcmp ( name , ""AppArmor"" ) == 0 ) { int size ; command = malloc ( strlen ( lsm_label ) + strlen ( ""changeprofile<S2SV_blank>"" ) + 1 ) ; if ( ! command ) { SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>apparmor<S2SV_blank>profile"" ) ; <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> goto out ; } size = sprintf ( command , ""changeprofile<S2SV_blank>%s"" , lsm_label ) ; if ( size < 0 ) { SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>apparmor<S2SV_blank>profile"" ) ; <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> goto out ; } <S2SV_StartBug> if ( write ( labelfd , command , size + 1 ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label"" ) ; <S2SV_EndBug> <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> goto out ; } } else if ( strcmp ( name , ""SELinux"" ) == 0 ) { if ( write ( labelfd , lsm_label , strlen ( lsm_label ) + 1 ) < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label"" ) ; ret = - 1 ; goto out ; } } else { ERROR ( ""Unable<S2SV_blank>to<S2SV_blank>restore<S2SV_blank>label<S2SV_blank>for<S2SV_blank>unknown<S2SV_blank>LSM:<S2SV_blank>%s"" , name ) ; <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> goto out ; } out : free ( command ) ; <S2SV_StartBug> if ( labelfd != - 1 ) <S2SV_EndBug> <S2SV_StartBug> close ( labelfd ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> lsm_set_label_at ( int lsm_labelfd <S2SV_ModEnd> , int on_exec <S2SV_ModStart> * lsm_label ) { int fret <S2SV_ModEnd> = - 1 <S2SV_ModStart> = - 1 <S2SV_ModEnd> ; const char <S2SV_ModStart> == 0 ) return 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> == 0 ) return 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( strcmp <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>apparmor<S2SV_blank>profile"" ) ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>apparmor<S2SV_blank>profile"" ) ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> ( write ( lsm_labelfd <S2SV_ModEnd> , command , <S2SV_ModStart> { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label:<S2SV_blank>%s."" , command ) ; goto out ; } INFO ( ""Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s."" , command ) ; } else if ( strcmp ( name , ""SELinux"" ) == 0 ) { if ( write ( lsm_labelfd , lsm_label , strlen ( lsm_label ) + 1 ) < 0 ) { SYSERROR ( <S2SV_ModStart> ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label"" ) ; goto out ; } INFO ( ""Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s."" , lsm_label ) ; } else <S2SV_ModEnd> { ERROR ( <S2SV_ModStart> name ) ; goto out ; } fret = 0 ; <S2SV_ModEnd> out : free <S2SV_ModStart> ; if ( lsm_labelfd <S2SV_ModEnd> != - 1 <S2SV_ModStart> ) close ( lsm_labelfd <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return fret <S2SV_ModEnd> ; } <S2SV_null>
"
170,"CWE-369 static OPJ_BOOL opj_pi_next_cprl ( opj_pi_iterator_t * pi ) { opj_pi_comp_t * comp = NULL ; opj_pi_resolution_t * res = NULL ; OPJ_UINT32 index = 0 ; if ( ! pi -> first ) { comp = & pi -> comps [ pi -> compno ] ; goto LABEL_SKIP ; } else { pi -> first = 0 ; } for ( pi -> compno = pi -> poc . compno0 ; pi -> compno < pi -> poc . compno1 ; pi -> compno ++ ) { OPJ_UINT32 resno ; comp = & pi -> comps [ pi -> compno ] ; pi -> dx = 0 ; pi -> dy = 0 ; for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { OPJ_UINT32 dx , dy ; res = & comp -> resolutions [ resno ] ; dx = comp -> dx * ( 1u << ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; dy = comp -> dy * ( 1u << ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; } if ( ! pi -> tp_on ) { pi -> poc . ty0 = pi -> ty0 ; pi -> poc . tx0 = pi -> tx0 ; pi -> poc . ty1 = pi -> ty1 ; pi -> poc . tx1 = pi -> tx1 ; } for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32 ) ( pi -> x % ( OPJ_INT32 ) pi -> dx ) ) ) { for ( pi -> resno = pi -> poc . resno0 ; pi -> resno < opj_uint_min ( pi -> poc . resno1 , comp -> numresolutions ) ; pi -> resno ++ ) { OPJ_UINT32 levelno ; OPJ_INT32 trx0 , try0 ; OPJ_INT32 trx1 , try1 ; OPJ_UINT32 rpx , rpy ; OPJ_INT32 prci , prcj ; res = & comp -> resolutions [ pi -> resno ] ; levelno = comp -> numresolutions - 1 - pi -> resno ; trx0 = opj_int_ceildiv ( pi -> tx0 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try0 = opj_int_ceildiv ( pi -> ty0 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; trx1 = opj_int_ceildiv ( pi -> tx1 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try1 = opj_int_ceildiv ( pi -> ty1 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; rpx = res -> pdx + levelno ; rpy = res -> pdy + levelno ; <S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) { continue ; } if ( ! ( ( pi -> x % ( OPJ_INT32 ) ( comp -> dx << rpx ) == 0 ) || ( ( pi -> x == pi -> tx0 ) && ( ( trx0 << levelno ) % ( 1 << rpx ) ) ) ) ) { continue ; } if ( ( res -> pw == 0 ) || ( res -> ph == 0 ) ) { continue ; } if ( ( trx0 == trx1 ) || ( try0 == try1 ) ) { continue ; } prci = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> x , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) , ( OPJ_INT32 ) res -> pdx ) - opj_int_floordivpow2 ( trx0 , ( OPJ_INT32 ) res -> pdx ) ; prcj = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> y , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) , ( OPJ_INT32 ) res -> pdy ) - opj_int_floordivpow2 ( try0 , ( OPJ_INT32 ) res -> pdy ) ; pi -> precno = ( OPJ_UINT32 ) ( prci + prcj * ( OPJ_INT32 ) res -> pw ) ; for ( pi -> layno = pi -> poc . layno0 ; pi -> layno < pi -> poc . layno1 ; pi -> layno ++ ) { index = pi -> layno * pi -> step_l + pi -> resno * pi -> step_r + pi -> compno * pi -> step_c + pi -> precno * pi -> step_p ; if ( ! pi -> include [ index ] ) { pi -> include [ index ] = 1 ; return OPJ_TRUE ; } LABEL_SKIP : ; } } } } } return OPJ_FALSE ; }
","<S2SV_ModStart> ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
"
171,"CWE-399 static void record_and_restart ( struct perf_event * event , unsigned long val , <S2SV_StartBug> struct pt_regs * regs , int nmi ) <S2SV_EndBug> { u64 period = event -> hw . sample_period ; s64 prev , delta , left ; int record = 0 ; if ( event -> hw . state & PERF_HES_STOPPED ) { write_pmc ( event -> hw . idx , 0 ) ; return ; } prev = local64_read ( & event -> hw . prev_count ) ; delta = check_and_compute_delta ( prev , val ) ; local64_add ( delta , & event -> count ) ; val = 0 ; left = local64_read ( & event -> hw . period_left ) - delta ; if ( period ) { if ( left <= 0 ) { left += period ; if ( left <= 0 ) left = period ; record = 1 ; event -> hw . last_period = event -> hw . sample_period ; } if ( left < 0x80000000LL ) val = 0x80000000LL - left ; } write_pmc ( event -> hw . idx , val ) ; local64_set ( & event -> hw . prev_count , val ) ; local64_set ( & event -> hw . period_left , left ) ; perf_event_update_userpage ( event ) ; if ( record ) { struct perf_sample_data data ; perf_sample_data_init ( & data , ~ 0ULL ) ; data . period = event -> hw . last_period ; if ( event -> attr . sample_type & PERF_SAMPLE_ADDR ) perf_get_data_addr ( regs , & data . addr ) ; <S2SV_StartBug> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <S2SV_EndBug> power_pmu_stop ( event , 0 ) ; } }
","<S2SV_ModStart> pt_regs * regs <S2SV_ModEnd> ) { u64 <S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,
"
172,"CWE-119 void vp9_twopass_postencode_update ( VP9_COMP * cpi ) { <S2SV_StartBug> # ifdef DISABLE_RC_LONG_TERM_MEM <S2SV_EndBug> const uint64_t bits_used = cpi -> rc . this_frame_target ; # else const uint64_t bits_used = cpi -> rc . projected_frame_size ; # endif cpi -> twopass . bits_left -= bits_used ; cpi -> twopass . bits_left = MAX ( cpi -> twopass . bits_left , 0 ) ; <S2SV_StartBug> if ( cpi -> common . frame_type == KEY_FRAME ) { <S2SV_EndBug> cpi -> twopass . kf_group_bits += cpi -> rc . this_frame_target - bits_used ; } else { cpi -> twopass . kf_group_bits -= bits_used ; <S2SV_StartBug> cpi -> twopass . gf_group_bits -= bits_used ; <S2SV_EndBug> <S2SV_StartBug> cpi -> twopass . gf_group_bits = MAX ( cpi -> twopass . gf_group_bits , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> cpi -> twopass . kf_group_bits = MAX ( cpi -> twopass . kf_group_bits , 0 ) ; }
","<S2SV_ModStart> cpi ) { TWO_PASS * const twopass = & cpi -> twopass ; RATE_CONTROL * const rc = & cpi -> rc ; const int bits_used = rc -> base_frame_target ; rc -> vbr_bits_off_target += rc -> base_frame_target - rc -> projected_frame_size ; twopass -> bits_left = MAX ( twopass -> bits_left - bits_used , 0 ) ; if ( rc -> total_actual_bits ) { rc -> rate_error_estimate = ( int ) ( ( rc -> vbr_bits_off_target * 100 ) / rc -> total_actual_bits ) ; rc -> rate_error_estimate = clamp ( rc -> rate_error_estimate , - 100 , 100 ) ; } else { rc -> rate_error_estimate = 0 ; } <S2SV_ModEnd> if ( cpi <S2SV_ModStart> common . frame_type != KEY_FRAME && ! vp9_is_upper_layer_key_frame ( cpi ) ) { twopass -> <S2SV_ModEnd> kf_group_bits -= bits_used <S2SV_ModStart> -= bits_used ; twopass -> last_kfgroup_zeromotion_pct = twopass -> kf_zeromotion_pct ; } twopass -> kf_group_bits <S2SV_ModEnd> = MAX ( <S2SV_ModStart> = MAX ( twopass -> kf_group_bits <S2SV_ModEnd> , 0 ) <S2SV_ModStart> 0 ) ; ++ twopass -> gf_group . index ; if ( ( cpi -> oxcf . rc_mode != VPX_Q ) && ( cpi -> twopass . gf_zeromotion_pct < VLOW_MOTION_THRESHOLD ) && ! cpi -> rc . is_src_frame_alt_ref ) { const int maxq_adj_limit = rc -> worst_quality - twopass -> active_worst_quality ; const int minq_adj_limit = ( cpi -> oxcf . rc_mode == VPX_CQ ? MINQ_ADJ_LIMIT_CQ : MINQ_ADJ_LIMIT ) ; if ( rc -> rate_error_estimate > cpi -> oxcf . under_shoot_pct ) { -- twopass -> extend_maxq ; if ( rc -> rolling_target_bits >= rc -> rolling_actual_bits ) ++ twopass -> extend_minq ; } else if ( rc -> rate_error_estimate < - cpi -> oxcf . over_shoot_pct ) { -- twopass -> extend_minq ; if ( rc -> rolling_target_bits < rc -> rolling_actual_bits ) ++ twopass -> extend_maxq ; } else { if ( rc -> projected_frame_size > ( 2 * rc -> base_frame_target ) && rc -> projected_frame_size > ( 2 * rc -> avg_frame_bandwidth ) ) ++ twopass -> extend_maxq ; if ( rc -> rolling_target_bits < rc -> rolling_actual_bits ) -- twopass -> extend_minq ; else if ( rc -> rolling_target_bits > rc -> rolling_actual_bits ) -- twopass -> extend_maxq ; } twopass -> extend_minq = clamp ( twopass -> extend_minq , 0 , minq_adj_limit ) ; twopass -> extend_maxq = clamp ( twopass -> extend_maxq , 0 , maxq_adj_limit ) ; if ( ! frame_is_kf_gf_arf ( cpi ) && ! cpi -> rc . is_src_frame_alt_ref ) { int fast_extra_thresh = rc -> base_frame_target / HIGH_UNDERSHOOT_RATIO ; if ( rc -> projected_frame_size < fast_extra_thresh ) { rc -> vbr_bits_off_target_fast += fast_extra_thresh - rc -> projected_frame_size ; rc -> vbr_bits_off_target_fast = MIN ( rc -> vbr_bits_off_target_fast , ( 4 * rc -> avg_frame_bandwidth ) ) ; if ( rc -> avg_frame_bandwidth ) { twopass -> extend_minq_fast = ( int ) ( rc -> vbr_bits_off_target_fast * 8 / rc -> avg_frame_bandwidth ) ; } twopass -> extend_minq_fast = MIN ( twopass -> extend_minq_fast , minq_adj_limit - twopass -> extend_minq ) ; } else if ( rc -> vbr_bits_off_target_fast ) { twopass -> extend_minq_fast = MIN ( twopass -> extend_minq_fast , minq_adj_limit - twopass -> extend_minq ) ; } else { twopass -> extend_minq_fast = 0 ; } } } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
173,"CWE-189 Datum lquery_in ( PG_FUNCTION_ARGS ) { char * buf = ( char * ) PG_GETARG_POINTER ( 0 ) ; char * ptr ; int num = 0 , totallen = 0 , numOR = 0 ; int state = LQPRS_WAITLEVEL ; lquery * result ; nodeitem * lptr = NULL ; lquery_level * cur , * curqlevel , * tmpql ; lquery_variant * lrptr = NULL ; bool hasnot = false ; bool wasbad = false ; int charlen ; int pos = 0 ; ptr = buf ; while ( * ptr ) { charlen = pg_mblen ( ptr ) ; if ( charlen == 1 ) { if ( t_iseq ( ptr , '.' ) ) num ++ ; else if ( t_iseq ( ptr , '|' ) ) numOR ++ ; } ptr += charlen ; } <S2SV_StartBug> num ++ ; <S2SV_EndBug> curqlevel = tmpql = ( lquery_level * ) palloc0 ( ITEMSIZE * num ) ; ptr = buf ; while ( * ptr ) { charlen = pg_mblen ( ptr ) ; if ( state == LQPRS_WAITLEVEL ) { if ( ISALNUM ( ptr ) ) { GETVAR ( curqlevel ) = lptr = ( nodeitem * ) palloc0 ( sizeof ( nodeitem ) * ( numOR + 1 ) ) ; lptr -> start = ptr ; state = LQPRS_WAITDELIM ; curqlevel -> numvar = 1 ; } else if ( charlen == 1 && t_iseq ( ptr , '!' ) ) { GETVAR ( curqlevel ) = lptr = ( nodeitem * ) palloc0 ( sizeof ( nodeitem ) * ( numOR + 1 ) ) ; lptr -> start = ptr + 1 ; state = LQPRS_WAITDELIM ; curqlevel -> numvar = 1 ; curqlevel -> flag |= LQL_NOT ; hasnot = true ; } else if ( charlen == 1 && t_iseq ( ptr , '*' ) ) state = LQPRS_WAITOPEN ; else UNCHAR ; } else if ( state == LQPRS_WAITVAR ) { if ( ISALNUM ( ptr ) ) { lptr ++ ; lptr -> start = ptr ; state = LQPRS_WAITDELIM ; curqlevel -> numvar ++ ; } else UNCHAR ; } else if ( state == LQPRS_WAITDELIM ) { if ( charlen == 1 && t_iseq ( ptr , '@' ) ) { if ( lptr -> start == ptr ) UNCHAR ; lptr -> flag |= LVAR_INCASE ; curqlevel -> flag |= LVAR_INCASE ; } else if ( charlen == 1 && t_iseq ( ptr , '*' ) ) { if ( lptr -> start == ptr ) UNCHAR ; lptr -> flag |= LVAR_ANYEND ; curqlevel -> flag |= LVAR_ANYEND ; } else if ( charlen == 1 && t_iseq ( ptr , '%' ) ) { if ( lptr -> start == ptr ) UNCHAR ; lptr -> flag |= LVAR_SUBLEXEME ; curqlevel -> flag |= LVAR_SUBLEXEME ; } else if ( charlen == 1 && t_iseq ( ptr , '|' ) ) { lptr -> len = ptr - lptr -> start - ( ( lptr -> flag & LVAR_SUBLEXEME ) ? 1 : 0 ) - ( ( lptr -> flag & LVAR_INCASE ) ? 1 : 0 ) - ( ( lptr -> flag & LVAR_ANYEND ) ? 1 : 0 ) ; if ( lptr -> wlen > 255 ) ereport ( ERROR , ( errcode ( ERRCODE_NAME_TOO_LONG ) , errmsg ( ""name<S2SV_blank>of<S2SV_blank>level<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long"" ) , errdetail ( ""Name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>"" ""be<S2SV_blank><<S2SV_blank>256,<S2SV_blank>in<S2SV_blank>position<S2SV_blank>%d."" , lptr -> wlen , pos ) ) ) ; state = LQPRS_WAITVAR ; } else if ( charlen == 1 && t_iseq ( ptr , '.' ) ) { lptr -> len = ptr - lptr -> start - ( ( lptr -> flag & LVAR_SUBLEXEME ) ? 1 : 0 ) - ( ( lptr -> flag & LVAR_INCASE ) ? 1 : 0 ) - ( ( lptr -> flag & LVAR_ANYEND ) ? 1 : 0 ) ; if ( lptr -> wlen > 255 ) ereport ( ERROR , ( errcode ( ERRCODE_NAME_TOO_LONG ) , errmsg ( ""name<S2SV_blank>of<S2SV_blank>level<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long"" ) , errdetail ( ""Name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>"" ""be<S2SV_blank><<S2SV_blank>256,<S2SV_blank>in<S2SV_blank>position<S2SV_blank>%d."" , lptr -> wlen , pos ) ) ) ; state = LQPRS_WAITLEVEL ; curqlevel = NEXTLEV ( curqlevel ) ; } else if ( ISALNUM ( ptr ) ) { if ( lptr -> flag ) UNCHAR ; } else UNCHAR ; } else if ( state == LQPRS_WAITOPEN ) { if ( charlen == 1 && t_iseq ( ptr , '{' ) ) state = LQPRS_WAITFNUM ; else if ( charlen == 1 && t_iseq ( ptr , '.' ) ) { curqlevel -> low = 0 ; curqlevel -> high = 0xffff ; curqlevel = NEXTLEV ( curqlevel ) ; state = LQPRS_WAITLEVEL ; } else UNCHAR ; } else if ( state == LQPRS_WAITFNUM ) { if ( charlen == 1 && t_iseq ( ptr , ',' ) ) state = LQPRS_WAITSNUM ; else if ( t_isdigit ( ptr ) ) { curqlevel -> low = atoi ( ptr ) ; state = LQPRS_WAITND ; } else UNCHAR ; } else if ( state == LQPRS_WAITSNUM ) { if ( t_isdigit ( ptr ) ) { curqlevel -> high = atoi ( ptr ) ; state = LQPRS_WAITCLOSE ; } else if ( charlen == 1 && t_iseq ( ptr , '}' ) ) { curqlevel -> high = 0xffff ; state = LQPRS_WAITEND ; } else UNCHAR ; } else if ( state == LQPRS_WAITCLOSE ) { if ( charlen == 1 && t_iseq ( ptr , '}' ) ) state = LQPRS_WAITEND ; else if ( ! t_isdigit ( ptr ) ) UNCHAR ; } else if ( state == LQPRS_WAITND ) { if ( charlen == 1 && t_iseq ( ptr , '}' ) ) { curqlevel -> high = curqlevel -> low ; state = LQPRS_WAITEND ; } else if ( charlen == 1 && t_iseq ( ptr , ',' ) ) state = LQPRS_WAITSNUM ; else if ( ! t_isdigit ( ptr ) ) UNCHAR ; } else if ( state == LQPRS_WAITEND ) { if ( charlen == 1 && t_iseq ( ptr , '.' ) ) { state = LQPRS_WAITLEVEL ; curqlevel = NEXTLEV ( curqlevel ) ; } else UNCHAR ; } else elog ( ERROR , ""internal<S2SV_blank>error<S2SV_blank>in<S2SV_blank>parser"" ) ; ptr += charlen ; if ( state == LQPRS_WAITDELIM ) lptr -> wlen ++ ; pos ++ ; } if ( state == LQPRS_WAITDELIM ) { if ( lptr -> start == ptr ) ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntax<S2SV_blank>error"" ) , errdetail ( ""Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>line."" ) ) ) ; lptr -> len = ptr - lptr -> start - ( ( lptr -> flag & LVAR_SUBLEXEME ) ? 1 : 0 ) - ( ( lptr -> flag & LVAR_INCASE ) ? 1 : 0 ) - ( ( lptr -> flag & LVAR_ANYEND ) ? 1 : 0 ) ; if ( lptr -> len == 0 ) ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntax<S2SV_blank>error"" ) , errdetail ( ""Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>line."" ) ) ) ; if ( lptr -> wlen > 255 ) ereport ( ERROR , ( errcode ( ERRCODE_NAME_TOO_LONG ) , errmsg ( ""name<S2SV_blank>of<S2SV_blank>level<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long"" ) , errdetail ( ""Name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>"" ""be<S2SV_blank><<S2SV_blank>256,<S2SV_blank>in<S2SV_blank>position<S2SV_blank>%d."" , lptr -> wlen , pos ) ) ) ; } else if ( state == LQPRS_WAITOPEN ) curqlevel -> high = 0xffff ; else if ( state != LQPRS_WAITEND ) ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntax<S2SV_blank>error"" ) , errdetail ( ""Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>line."" ) ) ) ; curqlevel = tmpql ; totallen = LQUERY_HDRSIZE ; while ( ( char * ) curqlevel - ( char * ) tmpql < num * ITEMSIZE ) { totallen += LQL_HDRSIZE ; if ( curqlevel -> numvar ) { lptr = GETVAR ( curqlevel ) ; while ( lptr - GETVAR ( curqlevel ) < curqlevel -> numvar ) { totallen += MAXALIGN ( LVAR_HDRSIZE + lptr -> len ) ; lptr ++ ; } } else if ( curqlevel -> low > curqlevel -> high ) ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntax<S2SV_blank>error"" ) , errdetail ( ""Low<S2SV_blank>limit(%d)<S2SV_blank>is<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>upper(%d)."" , curqlevel -> low , curqlevel -> high ) ) ) ; curqlevel = NEXTLEV ( curqlevel ) ; } result = ( lquery * ) palloc0 ( totallen ) ; SET_VARSIZE ( result , totallen ) ; result -> numlevel = num ; result -> firstgood = 0 ; result -> flag = 0 ; if ( hasnot ) result -> flag |= LQUERY_HASNOT ; cur = LQUERY_FIRST ( result ) ; curqlevel = tmpql ; while ( ( char * ) curqlevel - ( char * ) tmpql < num * ITEMSIZE ) { memcpy ( cur , curqlevel , LQL_HDRSIZE ) ; cur -> totallen = LQL_HDRSIZE ; if ( curqlevel -> numvar ) { lrptr = LQL_FIRST ( cur ) ; lptr = GETVAR ( curqlevel ) ; while ( lptr - GETVAR ( curqlevel ) < curqlevel -> numvar ) { cur -> totallen += MAXALIGN ( LVAR_HDRSIZE + lptr -> len ) ; lrptr -> len = lptr -> len ; lrptr -> flag = lptr -> flag ; lrptr -> val = ltree_crc32_sz ( lptr -> start , lptr -> len ) ; memcpy ( lrptr -> name , lptr -> start , lptr -> len ) ; lptr ++ ; lrptr = LVAR_NEXT ( lrptr ) ; } pfree ( GETVAR ( curqlevel ) ) ; if ( cur -> numvar > 1 || cur -> flag != 0 ) wasbad = true ; else if ( wasbad == false ) ( result -> firstgood ) ++ ; } else wasbad = true ; curqlevel = NEXTLEV ( curqlevel ) ; cur = LQL_NEXT ( cur ) ; } pfree ( tmpql ) ; PG_RETURN_POINTER ( result ) ; }
","<S2SV_ModStart> } num ++ ; if ( num > MaxAllocSize / ITEMSIZE ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , num , ( int ) ( MaxAllocSize / ITEMSIZE ) ) ) )
"
174,"CWE-19 static struct buffer_head * ext4_xattr_cache_find ( struct inode * inode , struct ext4_xattr_header * header , <S2SV_StartBug> struct mb_cache_entry * * pce ) <S2SV_EndBug> { __u32 hash = le32_to_cpu ( header -> h_hash ) ; <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; if ( ! header -> h_hash ) return NULL ; ea_idebug ( inode , ""looking<S2SV_blank>for<S2SV_blank>cached<S2SV_blank>blocks<S2SV_blank>[%x]"" , ( int ) hash ) ; <S2SV_StartBug> again : <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev , <S2SV_EndBug> hash ) ; while ( ce ) { struct buffer_head * bh ; <S2SV_StartBug> if ( IS_ERR ( ce ) ) { <S2SV_EndBug> if ( PTR_ERR ( ce ) == - EAGAIN ) goto again ; break ; } bh = sb_bread ( inode -> i_sb , ce -> e_block ) ; if ( ! bh ) { EXT4_ERROR_INODE ( inode , ""block<S2SV_blank>%lu<S2SV_blank>read<S2SV_blank>error"" , ( unsigned long ) ce -> e_block ) ; } else if ( le32_to_cpu ( BHDR ( bh ) -> h_refcount ) >= EXT4_XATTR_REFCOUNT_MAX ) { ea_idebug ( inode , ""block<S2SV_blank>%lu<S2SV_blank>refcount<S2SV_blank>%d>=%d"" , ( unsigned long ) ce -> e_block , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) , EXT4_XATTR_REFCOUNT_MAX ) ; } else if ( ext4_xattr_cmp ( header , BHDR ( bh ) ) == 0 ) { * pce = ce ; return bh ; } brelse ( bh ) ; <S2SV_StartBug> ce = mb_cache_entry_find_next ( ce , inode -> i_sb -> s_bdev , hash ) ; <S2SV_EndBug> } return NULL ; }
","<S2SV_ModStart> header , struct mb2_cache_entry <S2SV_ModEnd> * * pce <S2SV_ModStart> ) ; struct mb2_cache_entry * ce ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache = <S2SV_ModStart> hash ) ; ce = mb2_cache_entry_find_first <S2SV_ModEnd> ( ext4_mb_cache , <S2SV_ModStart> ( ext4_mb_cache , <S2SV_ModEnd> hash ) ; <S2SV_ModStart> * bh ; <S2SV_ModEnd> bh = sb_bread <S2SV_ModStart> ; ce = mb2_cache_entry_find_next ( ext4_mb_cache , ce <S2SV_ModEnd> ) ; }
"
175,"CWE-119 static gboolean cosine_read ( wtap * wth , int * err , gchar * * err_info , gint64 * data_offset ) { <S2SV_StartBug> gint64 offset ; <S2SV_EndBug> int pkt_len ; char line [ COSINE_LINE_LENGTH ] ; offset = cosine_seek_next_packet ( wth , err , err_info , line ) ; if ( offset < 0 ) return FALSE ; * data_offset = offset ; <S2SV_StartBug> pkt_len = parse_cosine_rec_hdr ( & wth -> phdr , line , err , err_info ) ; <S2SV_EndBug> if ( pkt_len == - 1 ) return FALSE ; <S2SV_StartBug> return parse_cosine_hex_dump ( wth -> fh , & wth -> phdr , pkt_len , <S2SV_EndBug> <S2SV_StartBug> wth -> frame_buffer , err , err_info ) ; <S2SV_EndBug> }
","<S2SV_ModStart> { gint64 offset <S2SV_ModEnd> ; char line <S2SV_ModStart> = offset ; return parse_cosine_packet <S2SV_ModEnd> ( wth -> <S2SV_ModStart> -> phdr , <S2SV_ModEnd> wth -> frame_buffer <S2SV_ModStart> wth -> frame_buffer , line
"
176,"CWE-476 static int add_push_report_sideband_pkt ( git_push * push , git_pkt_data * data_pkt , git_buf * data_pkt_buf ) { git_pkt * pkt ; const char * line , * line_end = NULL ; size_t line_len ; int error ; int reading_from_buf = data_pkt_buf -> size > 0 ; if ( reading_from_buf ) { git_buf_put ( data_pkt_buf , data_pkt -> data , data_pkt -> len ) ; line = data_pkt_buf -> ptr ; line_len = data_pkt_buf -> size ; } else { line = data_pkt -> data ; line_len = data_pkt -> len ; } while ( line_len > 0 ) { error = git_pkt_parse_line ( & pkt , line , & line_end , line_len ) ; if ( error == GIT_EBUFS ) { if ( ! reading_from_buf ) git_buf_put ( data_pkt_buf , line , line_len ) ; error = 0 ; goto done ; } else if ( error < 0 ) goto done ; line_len -= ( line_end - line ) ; line = line_end ; <S2SV_StartBug> if ( pkt == NULL ) <S2SV_EndBug> continue ; error = add_push_report_pkt ( push , pkt ) ; git_pkt_free ( pkt ) ; if ( error < 0 && error != GIT_ITEROVER ) goto done ; } error = 0 ; done : if ( reading_from_buf ) git_buf_consume ( data_pkt_buf , line_end ) ; return error ; }
","<S2SV_ModStart> = line_end ; <S2SV_ModEnd> error = add_push_report_pkt
"
177,"CWE-000 int ssl3_read_n ( SSL * s , int n , int max , int extend ) { int i , len , left ; long align = 0 ; unsigned char * pkt ; SSL3_BUFFER * rb ; if ( n <= 0 ) return n ; rb = & ( s -> s3 -> rbuf ) ; if ( rb -> buf == NULL ) if ( ! ssl3_setup_read_buffer ( s ) ) return - 1 ; left = rb -> left ; # if defined ( SSL3_ALIGN_PAYLOAD ) && SSL3_ALIGN_PAYLOAD != 0 align = ( long ) rb -> buf + SSL3_RT_HEADER_LENGTH ; align = ( - align ) & ( SSL3_ALIGN_PAYLOAD - 1 ) ; # endif if ( ! extend ) { if ( left == 0 ) rb -> offset = align ; else if ( align != 0 && left >= SSL3_RT_HEADER_LENGTH ) { pkt = rb -> buf + rb -> offset ; if ( pkt [ 0 ] == SSL3_RT_APPLICATION_DATA && ( pkt [ 3 ] << 8 | pkt [ 4 ] ) >= 128 ) { memmove ( rb -> buf + align , pkt , left ) ; rb -> offset = align ; } } s -> packet = rb -> buf + rb -> offset ; s -> packet_length = 0 ; } if ( SSL_IS_DTLS ( s ) ) { <S2SV_StartBug> if ( left > 0 && n > left ) <S2SV_EndBug> n = left ; } if ( left >= n ) { s -> packet_length += n ; rb -> left = left - n ; rb -> offset += n ; return ( n ) ; } len = s -> packet_length ; pkt = rb -> buf + align ; if ( s -> packet != pkt ) { memmove ( pkt , s -> packet , len + left ) ; s -> packet = pkt ; rb -> offset = len + align ; } if ( n > ( int ) ( rb -> len - rb -> offset ) ) { SSLerr ( SSL_F_SSL3_READ_N , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( ! s -> read_ahead ) max = n ; else { if ( max < n ) max = n ; if ( max > ( int ) ( rb -> len - rb -> offset ) ) max = rb -> len - rb -> offset ; } while ( left < n ) { clear_sys_error ( ) ; if ( s -> rbio != NULL ) { s -> rwstate = SSL_READING ; i = BIO_read ( s -> rbio , pkt + len + left , max - left ) ; } else { SSLerr ( SSL_F_SSL3_READ_N , SSL_R_READ_BIO_NOT_SET ) ; i = - 1 ; } if ( i <= 0 ) { rb -> left = left ; if ( s -> mode & SSL_MODE_RELEASE_BUFFERS && ! SSL_IS_DTLS ( s ) ) if ( len + left == 0 ) ssl3_release_read_buffer ( s ) ; return ( i ) ; } left += i ; if ( SSL_IS_DTLS ( s ) ) { if ( n > left ) n = left ; } } rb -> offset += n ; rb -> left = left - n ; s -> packet_length += n ; s -> rwstate = SSL_NOTHING ; return ( n ) ; }
","<S2SV_ModStart> if ( left == 0 && extend ) return 0 ; if ( left
"
178,"CWE-119 static grub_disk_addr_t grub_ext2_read_block ( grub_fshelp_node_t node , grub_disk_addr_t fileblock ) { struct grub_ext2_data * data = node -> data ; struct grub_ext2_inode * inode = & node -> inode ; int blknr = - 1 ; unsigned int blksz = EXT2_BLOCK_SIZE ( data ) ; int log2_blksz = LOG2_EXT2_BLOCK_SIZE ( data ) ; if ( grub_le_to_cpu32 ( inode -> flags ) & EXT4_EXTENTS_FLAG ) { <S2SV_StartBug> # ifndef _MSC_VER <S2SV_EndBug> <S2SV_StartBug> char buf [ EXT2_BLOCK_SIZE ( data ) ] ; <S2SV_EndBug> # else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; # endif struct grub_ext4_extent_header * leaf ; struct grub_ext4_extent * ext ; int i ; leaf = grub_ext4_find_leaf ( data , buf , ( struct grub_ext4_extent_header * ) inode -> blocks . dir_blocks , fileblock ) ; if ( ! leaf ) { <S2SV_StartBug> grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ; <S2SV_EndBug> return - 1 ; } ext = ( struct grub_ext4_extent * ) ( leaf + 1 ) ; for ( i = 0 ; i < grub_le_to_cpu16 ( leaf -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( ext [ i ] . block ) ) break ; } if ( -- i >= 0 ) { fileblock -= grub_le_to_cpu32 ( ext [ i ] . block ) ; <S2SV_StartBug> if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> else <S2SV_EndBug> { grub_disk_addr_t start ; start = grub_le_to_cpu16 ( ext [ i ] . start_hi ) ; start = ( start << 32 ) + grub_le_to_cpu32 ( ext [ i ] . start ) ; <S2SV_StartBug> return fileblock + start ; <S2SV_EndBug> } } else { grub_error ( GRUB_ERR_BAD_FS , ""something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent"" ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> } if ( fileblock < INDIRECT_BLOCKS ) { blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ; } else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) { grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ; <S2SV_StartBug> if ( ! indir ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz , <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ; grub_free ( indir ) ; } else if ( fileblock < ( grub_disk_addr_t ) ( INDIRECT_BLOCKS + blksz / 4 ) * ( grub_disk_addr_t ) ( blksz / 4 + 1 ) ) { unsigned int perblock = blksz / 4 ; unsigned int rblock = fileblock - ( INDIRECT_BLOCKS + blksz / 4 ) ; grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ; <S2SV_StartBug> if ( ! indir ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz , <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz , <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ; grub_free ( indir ) ; } else { grub_error ( GRUB_ERR_NOT_IMPLEMENTED_YET , ""ext2fs<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>triple<S2SV_blank>indirect<S2SV_blank>blocks"" ) ; } return blknr ; }
","<S2SV_ModStart> EXT4_EXTENTS_FLAG ) { char * buf = grub_malloc ( <S2SV_ModEnd> EXT2_BLOCK_SIZE ( data <S2SV_ModStart> ( data ) ) ; if ( ! buf ) { return - 1 ; } <S2SV_ModEnd> struct grub_ext4_extent_header * <S2SV_ModStart> GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ; free ( buf <S2SV_ModStart> len ) ) { free ( buf ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModStart> start ) ; free ( buf ) ; <S2SV_ModStart> ""something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent"" ) ; free ( buf ) ; <S2SV_ModStart> 1 ; } free ( buf ) ; <S2SV_ModStart> ! indir ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> ! indir ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; }
"
179,"CWE-119 static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; one = 1 ; image = AcquireImage ( image_info , exception ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , ""EncryptedWPGImageFileNotSupported"" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> resolution . x = BitmapHeader1 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> resolution . x = BitmapHeader2 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; <S2SV_StartBug> UnpackRaster : <S2SV_EndBug> if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; <S2SV_StartBug> image -> rows = Bitmap2Header1 . Height ; <S2SV_EndBug> if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { size_t one ; one = 1 ; image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( image , BImgBuff , i , bpp , exception ) ; } if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; } } <S2SV_StartBug> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; <S2SV_EndBug> if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , ""ImageFileDoesNotContainAnyImageData"" ) ; return ( image ) ; }
","<S2SV_ModStart> ; UnpackRaster : status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; <S2SV_ModStart> Bitmap2Header1 . Height ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break <S2SV_ModStart> ; } } <S2SV_ModEnd> Finish : (
"
180,"CWE-362 static long vbg_misc_device_ioctl ( struct file * filp , unsigned int req , unsigned long arg ) { struct vbg_session * session = filp -> private_data ; size_t returned_size , size ; struct vbg_ioctl_hdr hdr ; bool is_vmmdev_req ; int ret = 0 ; void * buf ; if ( copy_from_user ( & hdr , ( void * ) arg , sizeof ( hdr ) ) ) return - EFAULT ; if ( hdr . version != VBG_IOCTL_HDR_VERSION ) return - EINVAL ; if ( hdr . size_in < sizeof ( hdr ) || ( hdr . size_out && hdr . size_out < sizeof ( hdr ) ) ) return - EINVAL ; size = max ( hdr . size_in , hdr . size_out ) ; if ( _IOC_SIZE ( req ) && _IOC_SIZE ( req ) != size ) return - EINVAL ; if ( size > SZ_16M ) return - E2BIG ; is_vmmdev_req = ( req & ~ IOCSIZE_MASK ) == VBG_IOCTL_VMMDEV_REQUEST ( 0 ) || req == VBG_IOCTL_VMMDEV_REQUEST_BIG ; if ( is_vmmdev_req ) buf = vbg_req_alloc ( size , VBG_IOCTL_HDR_TYPE_DEFAULT ) ; else buf = kmalloc ( size , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; <S2SV_StartBug> if ( copy_from_user ( buf , ( void * ) arg , hdr . size_in ) ) { <S2SV_EndBug> ret = - EFAULT ; goto out ; } if ( hdr . size_in < size ) memset ( buf + hdr . size_in , 0 , size - hdr . size_in ) ; ret = vbg_core_ioctl ( session , req , buf ) ; if ( ret ) goto out ; returned_size = ( ( struct vbg_ioctl_hdr * ) buf ) -> size_out ; if ( returned_size > size ) { vbg_debug ( ""%s:<S2SV_blank>too<S2SV_blank>much<S2SV_blank>output<S2SV_blank>data<S2SV_blank>%zu<S2SV_blank>><S2SV_blank>%zu\\n"" , __func__ , returned_size , size ) ; returned_size = size ; } if ( copy_to_user ( ( void * ) arg , buf , returned_size ) != 0 ) ret = - EFAULT ; out : if ( is_vmmdev_req ) vbg_req_free ( buf , size ) ; else kfree ( buf ) ; return ret ; }
","<S2SV_ModStart> - ENOMEM ; * ( ( struct vbg_ioctl_hdr * ) buf ) = hdr ; <S2SV_ModStart> copy_from_user ( buf + sizeof ( hdr ) <S2SV_ModStart> * ) arg + sizeof ( hdr ) , hdr . size_in - sizeof ( hdr ) <S2SV_ModEnd> ) ) {
"
181,"CWE-119 void jpc_qmfb_split_colgrp ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = splitbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int m ; <S2SV_StartBug> int hstartcol ; <S2SV_EndBug> if ( bufsize > QMFB_SPLITBUFSIZE ) { <S2SV_StartBug> if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { <S2SV_EndBug> abort ( ) ; } } if ( numrows >= 2 ) { <S2SV_StartBug> hstartcol = ( numrows + 1 - parity ) >> 1 ; <S2SV_EndBug> <S2SV_StartBug> m = numrows - hstartcol ; <S2SV_EndBug> n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += JPC_QMFB_COLGRPSIZE ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += stride << 1 ; } <S2SV_StartBug> dstptr = & a [ hstartcol * stride ] ; <S2SV_EndBug> srcptr = buf ; n = m ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += JPC_QMFB_COLGRPSIZE ; } } if ( buf != splitbuf ) { jas_free ( buf ) ; } }
","<S2SV_ModStart> m ; int hstartrow <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( buf = jas_alloc3 <S2SV_ModEnd> ( bufsize , <S2SV_ModStart> ( bufsize , JPC_QMFB_COLGRPSIZE , <S2SV_ModStart> 2 ) { hstartrow <S2SV_ModEnd> = ( numrows <S2SV_ModStart> = numrows - hstartrow <S2SV_ModEnd> ; n = <S2SV_ModStart> & a [ hstartrow <S2SV_ModEnd> * stride ]
"
182,"CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , height , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth ) > ( 8 * sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * <S2SV_StartBug> height ) ; <S2SV_EndBug> sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ( ResourceLimitError , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; number_pixels <S2SV_ModStart> ( ResourceLimitError , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; bytes_per_line <S2SV_ModStart> ( ResourceLimitError , ""ImproperImageHeader"" <S2SV_ModEnd> ) ; bytes_per_line <S2SV_ModStart> height ) ; else { if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; }
"
183,"CWE-20 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 <S2SV_StartBug> char <S2SV_EndBug> magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; <S2SV_StartBug> count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; <S2SV_EndBug> if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { <S2SV_StartBug> image -> page . x = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> image -> page . y = ReadBlobLSBShort ( image ) ; <S2SV_EndBug> image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_StartBug> one = 1 ; <S2SV_EndBug> map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> image -> filename ) ; break ; } <S2SV_StartBug> colormap = ( unsigned char * ) NULL ; <S2SV_EndBug> if ( number_colormaps != 0 ) { <S2SV_StartBug> colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , <S2SV_EndBug> 3 * map_length * sizeof ( * colormap ) ) ; <S2SV_StartBug> if ( colormap == ( unsigned char * ) NULL ) <S2SV_EndBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum ( <S2SV_StartBug> ReadBlobLSBShort ( image ) ) ) ; <S2SV_EndBug> } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , <S2SV_EndBug> image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; <S2SV_StartBug> do <S2SV_EndBug> { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> plane = ( unsigned char ) operand ; <S2SV_EndBug> if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> operand ++ ; if ( ( offset < 0 ) || <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; <S2SV_StartBug> if ( opcode & 0x40 ) <S2SV_EndBug> <S2SV_StartBug> operand = ReadBlobLSBSignedShort ( image ) ; <S2SV_EndBug> pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; <S2SV_StartBug> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * <S2SV_EndBug> <S2SV_StartBug> number_planes + plane ; <S2SV_EndBug> operand ++ ; if ( ( offset < 0 ) || <S2SV_StartBug> ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; <S2SV_StartBug> } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; <S2SV_EndBug> if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { <S2SV_StartBug> ValidateColormapValue ( image , * p & mask , & index , exception ) ; <S2SV_EndBug> * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { <S2SV_StartBug> ValidateColormapValue ( image , ( size_t ) ( x * map_length + <S2SV_EndBug> ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> SetPixelIndex ( image , * p ++ , q ) ; <S2SV_EndBug> q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> define EOFOp 0x07 # define ThrowRLEException ( exception , message ) \\\n{ if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; \\\n} <S2SV_ModStart> ) ) ; colormap = ( unsigned char * ) NULL ; pixel_info = ( MemoryInfo * ) NULL ; <S2SV_ModStart> . x = ( ssize_t ) <S2SV_ModStart> . y = ( ssize_t ) <S2SV_ModStart> ""ImproperImageHeader"" ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> != MagickFalse ) ThrowRLEException ( <S2SV_ModEnd> CorruptImageError , ""UnexpectedEndOfFile"" <S2SV_ModStart> CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( number_colormaps != 0 ) { <S2SV_ModEnd> colormap = ( <S2SV_ModStart> char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == <S2SV_ModEnd> ( unsigned char <S2SV_ModStart> char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) { * p ++ = <S2SV_ModEnd> ( unsigned char <S2SV_ModStart> ( unsigned char <S2SV_ModEnd> ) ScaleQuantumToChar ( <S2SV_ModStart> ) ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> != MagickFalse ) ThrowRLEException ( <S2SV_ModEnd> CorruptImageError , ""UnexpectedEndOfFile"" <S2SV_ModStart> CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } offset = ( ssize_t ) ( <S2SV_ModEnd> ( ( image <S2SV_ModStart> number_planes + plane ) <S2SV_ModStart> ) || ( ( offset + <S2SV_ModEnd> operand * number_planes <S2SV_ModStart> number_planes ) > ( ssize_t ) <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } <S2SV_ModStart> ; offset = ( ssize_t ) ( <S2SV_ModStart> number_planes + plane ) <S2SV_ModStart> ) || ( ( offset + <S2SV_ModEnd> operand * number_planes <S2SV_ModStart> number_planes ) > ( ssize_t ) <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; <S2SV_ModStart> ( image , ( ssize_t ) ( <S2SV_ModStart> p & mask ) <S2SV_ModStart> image , ( ssize_t <S2SV_ModEnd> ) ( x <S2SV_ModStart> ( image , ( Quantum )
"
184,"CWE-19 static void ext2_put_super ( struct super_block * sb ) { int db_count ; int i ; struct ext2_sb_info * sbi = EXT2_SB ( sb ) ; dquot_disable ( sb , - 1 , DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED ) ; <S2SV_StartBug> ext2_xattr_put_super ( sb ) ; <S2SV_EndBug> if ( ! ( sb -> s_flags & MS_RDONLY ) ) { struct ext2_super_block * es = sbi -> s_es ; spin_lock ( & sbi -> s_lock ) ; es -> s_state = cpu_to_le16 ( sbi -> s_mount_state ) ; spin_unlock ( & sbi -> s_lock ) ; ext2_sync_super ( sb , es , 1 ) ; } db_count = sbi -> s_gdb_count ; for ( i = 0 ; i < db_count ; i ++ ) if ( sbi -> s_group_desc [ i ] ) brelse ( sbi -> s_group_desc [ i ] ) ; kfree ( sbi -> s_group_desc ) ; kfree ( sbi -> s_debts ) ; percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ; percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; brelse ( sbi -> s_sbh ) ; sb -> s_fs_info = NULL ; kfree ( sbi -> s_blockgroup_lock ) ; kfree ( sbi ) ; }
","<S2SV_ModStart> DQUOT_LIMITS_ENABLED ) ; if ( sbi -> s_mb_cache ) { ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } <S2SV_ModEnd> if ( !
"
185,"CWE-000 static int gtco_probe ( struct usb_interface * usbinterface , const struct usb_device_id * id ) { struct gtco * gtco ; struct input_dev * input_dev ; struct hid_descriptor * hid_desc ; char * report ; int result = 0 , retry ; int error ; struct usb_endpoint_descriptor * endpoint ; gtco = kzalloc ( sizeof ( struct gtco ) , GFP_KERNEL ) ; input_dev = input_allocate_device ( ) ; if ( ! gtco || ! input_dev ) { dev_err ( & usbinterface -> dev , ""No<S2SV_blank>more<S2SV_blank>memory\\n"" ) ; error = - ENOMEM ; goto err_free_devs ; } gtco -> inputdevice = input_dev ; gtco -> usbdev = interface_to_usbdev ( usbinterface ) ; gtco -> intf = usbinterface ; gtco -> buffer = usb_alloc_coherent ( gtco -> usbdev , REPORT_MAX_SIZE , GFP_KERNEL , & gtco -> buf_dma ) ; if ( ! gtco -> buffer ) { dev_err ( & usbinterface -> dev , ""No<S2SV_blank>more<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>us<S2SV_blank>buffers\\n"" ) ; error = - ENOMEM ; goto err_free_devs ; } gtco -> urbinfo = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! gtco -> urbinfo ) { dev_err ( & usbinterface -> dev , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>URB\\n"" ) ; error = - ENOMEM ; goto err_free_buf ; } <S2SV_StartBug> endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; <S2SV_EndBug> dev_dbg ( & usbinterface -> dev , ""gtco<S2SV_blank>#<S2SV_blank>interfaces:<S2SV_blank>%d\\n"" , usbinterface -> num_altsetting ) ; dev_dbg ( & usbinterface -> dev , ""num<S2SV_blank>endpoints:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , usbinterface -> cur_altsetting -> desc . bNumEndpoints ) ; dev_dbg ( & usbinterface -> dev , ""interface<S2SV_blank>class:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , usbinterface -> cur_altsetting -> desc . bInterfaceClass ) ; dev_dbg ( & usbinterface -> dev , ""endpoint:<S2SV_blank>attribute:0x%x<S2SV_blank>type:0x%x\\n"" , endpoint -> bmAttributes , endpoint -> bDescriptorType ) ; if ( usb_endpoint_xfer_int ( endpoint ) ) dev_dbg ( & usbinterface -> dev , ""endpoint:<S2SV_blank>we<S2SV_blank>have<S2SV_blank>interrupt<S2SV_blank>endpoint\\n"" ) ; dev_dbg ( & usbinterface -> dev , ""endpoint<S2SV_blank>extra<S2SV_blank>len:%d\\n"" , usbinterface -> altsetting [ 0 ] . extralen ) ; if ( usb_get_extra_descriptor ( usbinterface -> cur_altsetting , HID_DEVICE_TYPE , & hid_desc ) != 0 ) { dev_err ( & usbinterface -> dev , ""Can\'t<S2SV_blank>retrieve<S2SV_blank>exta<S2SV_blank>USB<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>get<S2SV_blank>hid<S2SV_blank>report<S2SV_blank>descriptor<S2SV_blank>length\\n"" ) ; error = - EIO ; goto err_free_urb ; } dev_dbg ( & usbinterface -> dev , ""Extra<S2SV_blank>descriptor<S2SV_blank>success:<S2SV_blank>type:%d<S2SV_blank><S2SV_blank>len:%d\\n"" , hid_desc -> bDescriptorType , hid_desc -> wDescriptorLength ) ; report = kzalloc ( le16_to_cpu ( hid_desc -> wDescriptorLength ) , GFP_KERNEL ) ; if ( ! report ) { dev_err ( & usbinterface -> dev , ""No<S2SV_blank>more<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>report\\n"" ) ; error = - ENOMEM ; goto err_free_urb ; } for ( retry = 0 ; retry < 3 ; retry ++ ) { result = usb_control_msg ( gtco -> usbdev , usb_rcvctrlpipe ( gtco -> usbdev , 0 ) , USB_REQ_GET_DESCRIPTOR , USB_RECIP_INTERFACE | USB_DIR_IN , REPORT_DEVICE_TYPE << 8 , 0 , report , le16_to_cpu ( hid_desc -> wDescriptorLength ) , 5000 ) ; dev_dbg ( & usbinterface -> dev , ""usb_control_msg<S2SV_blank>result:<S2SV_blank>%d\\n"" , result ) ; if ( result == le16_to_cpu ( hid_desc -> wDescriptorLength ) ) { parse_hid_report_descriptor ( gtco , report , result ) ; break ; } } kfree ( report ) ; if ( result != le16_to_cpu ( hid_desc -> wDescriptorLength ) ) { dev_err ( & usbinterface -> dev , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>HID<S2SV_blank>Report<S2SV_blank>Descriptor<S2SV_blank>of<S2SV_blank>size:<S2SV_blank>%d\\n"" , hid_desc -> wDescriptorLength ) ; error = - EIO ; goto err_free_urb ; } usb_make_path ( gtco -> usbdev , gtco -> usbpath , sizeof ( gtco -> usbpath ) ) ; strlcat ( gtco -> usbpath , ""/input0"" , sizeof ( gtco -> usbpath ) ) ; input_dev -> open = gtco_input_open ; input_dev -> close = gtco_input_close ; input_dev -> name = ""GTCO_CalComp"" ; input_dev -> phys = gtco -> usbpath ; input_set_drvdata ( input_dev , gtco ) ; gtco_setup_caps ( input_dev ) ; usb_to_input_id ( gtco -> usbdev , & input_dev -> id ) ; input_dev -> dev . parent = & usbinterface -> dev ; endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; usb_fill_int_urb ( gtco -> urbinfo , gtco -> usbdev , usb_rcvintpipe ( gtco -> usbdev , endpoint -> bEndpointAddress ) , gtco -> buffer , REPORT_MAX_SIZE , gtco_urb_callback , gtco , endpoint -> bInterval ) ; gtco -> urbinfo -> transfer_dma = gtco -> buf_dma ; gtco -> urbinfo -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; usb_set_intfdata ( usbinterface , gtco ) ; error = input_register_device ( input_dev ) ; if ( error ) goto err_free_urb ; return 0 ; err_free_urb : usb_free_urb ( gtco -> urbinfo ) ; err_free_buf : usb_free_coherent ( gtco -> usbdev , REPORT_MAX_SIZE , gtco -> buffer , gtco -> buf_dma ) ; err_free_devs : input_free_device ( input_dev ) ; kfree ( gtco ) ; return error ; }
","<S2SV_ModStart> err_free_buf ; } if ( usbinterface -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & usbinterface -> dev , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n"" ) ; error = - EINVAL ; goto err_free_urb ; }
"
186,"CWE-269 void bandwidth_pid ( pid_t pid , const char * command , const char * dev , int down , int up ) { EUID_ASSERT ( ) ; EUID_ROOT ( ) ; char * comm = pid_proc_comm ( pid ) ; EUID_USER ( ) ; if ( ! comm ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>find<S2SV_blank>sandbox\\n"" ) ; exit ( 1 ) ; } if ( strcmp ( comm , ""firejail"" ) != 0 ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>find<S2SV_blank>sandbox\\n"" ) ; exit ( 1 ) ; } free ( comm ) ; char * name ; if ( asprintf ( & name , ""/run/firejail/network/%d-netmap"" , pid ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( name , & s ) == - 1 ) { fprintf ( stderr , ""Error:<S2SV_blank>the<S2SV_blank>sandbox<S2SV_blank>doesn\'t<S2SV_blank>use<S2SV_blank>a<S2SV_blank>new<S2SV_blank>network<S2SV_blank>namespace\\n"" ) ; exit ( 1 ) ; } pid_t child ; if ( find_child ( pid , & child ) == - 1 ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>join<S2SV_blank>the<S2SV_blank>network<S2SV_blank>namespace\\n"" ) ; exit ( 1 ) ; } EUID_ROOT ( ) ; if ( join_namespace ( child , ""net"" ) ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>join<S2SV_blank>the<S2SV_blank>network<S2SV_blank>namespace\\n"" ) ; exit ( 1 ) ; } if ( strcmp ( command , ""set"" ) == 0 ) bandwidth_set ( pid , dev , down , up ) ; else if ( strcmp ( command , ""clear"" ) == 0 ) bandwidth_remove ( pid , dev ) ; char * devname = NULL ; if ( dev ) { char * fname ; if ( asprintf ( & fname , ""%s/%d-netmap"" , RUN_FIREJAIL_NETWORK_DIR , ( int ) pid ) == - 1 ) errExit ( ""asprintf"" ) ; FILE * fp = fopen ( fname , ""r"" ) ; if ( ! fp ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>network<S2SV_blank>map<S2SV_blank>file<S2SV_blank>%s\\n"" , fname ) ; exit ( 1 ) ; } char buf [ 1024 ] ; int len = strlen ( dev ) ; while ( fgets ( buf , 1024 , fp ) ) { char * ptr = strchr ( buf , '\\n' ) ; if ( ptr ) * ptr = '\\0' ; if ( * buf == '\\0' ) break ; if ( strncmp ( buf , dev , len ) == 0 && buf [ len ] == ':' ) { devname = strdup ( buf + len + 1 ) ; if ( ! devname ) errExit ( ""strdup"" ) ; if ( if_nametoindex ( devname ) == 0 ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>find<S2SV_blank>network<S2SV_blank>device<S2SV_blank>%s\\n"" , devname ) ; exit ( 1 ) ; } break ; } } free ( fname ) ; fclose ( fp ) ; } char * cmd = NULL ; if ( devname ) { if ( strcmp ( command , ""set"" ) == 0 ) { if ( asprintf ( & cmd , ""%s/firejail/fshaper.sh<S2SV_blank>--%s<S2SV_blank>%s<S2SV_blank>%d<S2SV_blank>%d"" , LIBDIR , command , devname , down , up ) == - 1 ) errExit ( ""asprintf"" ) ; } else { if ( asprintf ( & cmd , ""%s/firejail/fshaper.sh<S2SV_blank>--%s<S2SV_blank>%s"" , LIBDIR , command , devname ) == - 1 ) errExit ( ""asprintf"" ) ; } } else { if ( asprintf ( & cmd , ""%s/firejail/fshaper.sh<S2SV_blank>--%s"" , LIBDIR , command ) == - 1 ) errExit ( ""asprintf"" ) ; } assert ( cmd ) ; environ = NULL ; if ( setreuid ( 0 , 0 ) ) errExit ( ""setreuid"" ) ; if ( setregid ( 0 , 0 ) ) errExit ( ""setregid"" ) ; <S2SV_StartBug> if ( ! cfg . shell ) <S2SV_EndBug> cfg . shell = guess_shell ( ) ; if ( ! cfg . shell ) { fprintf ( stderr , ""Error:<S2SV_blank>no<S2SV_blank>POSIX<S2SV_blank>shell<S2SV_blank>found,<S2SV_blank>please<S2SV_blank>use<S2SV_blank>--shell<S2SV_blank>command<S2SV_blank>line<S2SV_blank>option\\n"" ) ; exit ( 1 ) ; } char * arg [ 4 ] ; <S2SV_StartBug> arg [ 0 ] = cfg . shell ; <S2SV_EndBug> arg [ 1 ] = ""-c"" ; arg [ 2 ] = cmd ; arg [ 3 ] = NULL ; clearenv ( ) ; execvp ( arg [ 0 ] , arg ) ; errExit ( ""execvp"" ) ; }
","<S2SV_ModStart> ""setregid"" ) ; <S2SV_ModEnd> char * arg <S2SV_ModStart> 0 ] = ""/bin/sh"" <S2SV_ModEnd> ; arg [
"
187,"CWE-476 static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) { <S2SV_StartBug> return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> node ) { if ( node -> nd_item . ci_parent ) <S2SV_ModStart> ci_parent ) ; else return NULL ;
"
188,"CWE-000 <S2SV_StartBug> static void nfs_set_open_stateid ( struct nfs4_state * state , nfs4_stateid * stateid , int open_flags ) <S2SV_EndBug> { write_seqlock ( & state -> seqlock ) ; <S2SV_StartBug> nfs_set_open_stateid_locked ( state , stateid , open_flags ) ; <S2SV_EndBug> write_sequnlock ( & state -> seqlock ) ; }
","<S2SV_ModStart> * stateid , fmode_t fmode <S2SV_ModEnd> ) { write_seqlock <S2SV_ModStart> , stateid , fmode <S2SV_ModEnd> ) ; write_sequnlock
"
189,"CWE-834 static int mv_read_header ( AVFormatContext * avctx ) { MvContext * mv = avctx -> priv_data ; AVIOContext * pb = avctx -> pb ; AVStream * ast = NULL , * vst = NULL ; int version , i ; int ret ; avio_skip ( pb , 4 ) ; version = avio_rb16 ( pb ) ; if ( version == 2 ) { uint64_t timestamp ; int v ; avio_skip ( pb , 22 ) ; ast = avformat_new_stream ( avctx , NULL ) ; if ( ! ast ) return AVERROR ( ENOMEM ) ; vst = avformat_new_stream ( avctx , NULL ) ; if ( ! vst ) return AVERROR ( ENOMEM ) ; avpriv_set_pts_info ( vst , 64 , 1 , 15 ) ; vst -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; vst -> avg_frame_rate = av_inv_q ( vst -> time_base ) ; vst -> nb_frames = avio_rb32 ( pb ) ; v = avio_rb32 ( pb ) ; switch ( v ) { case 1 : vst -> codecpar -> codec_id = AV_CODEC_ID_MVC1 ; break ; case 2 : vst -> codecpar -> format = AV_PIX_FMT_ARGB ; vst -> codecpar -> codec_id = AV_CODEC_ID_RAWVIDEO ; break ; default : avpriv_request_sample ( avctx , ""Video<S2SV_blank>compression<S2SV_blank>%i"" , v ) ; break ; } vst -> codecpar -> codec_tag = 0 ; vst -> codecpar -> width = avio_rb32 ( pb ) ; vst -> codecpar -> height = avio_rb32 ( pb ) ; avio_skip ( pb , 12 ) ; ast -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; ast -> nb_frames = vst -> nb_frames ; ast -> codecpar -> sample_rate = avio_rb32 ( pb ) ; if ( ast -> codecpar -> sample_rate <= 0 ) { av_log ( avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>%d\\n"" , ast -> codecpar -> sample_rate ) ; return AVERROR_INVALIDDATA ; } avpriv_set_pts_info ( ast , 33 , 1 , ast -> codecpar -> sample_rate ) ; if ( set_channels ( avctx , ast , avio_rb32 ( pb ) ) < 0 ) return AVERROR_INVALIDDATA ; v = avio_rb32 ( pb ) ; if ( v == AUDIO_FORMAT_SIGNED ) { ast -> codecpar -> codec_id = AV_CODEC_ID_PCM_S16BE ; } else { avpriv_request_sample ( avctx , ""Audio<S2SV_blank>compression<S2SV_blank>(format<S2SV_blank>%i)"" , v ) ; } avio_skip ( pb , 12 ) ; var_read_metadata ( avctx , ""title"" , 0x80 ) ; var_read_metadata ( avctx , ""comment"" , 0x100 ) ; avio_skip ( pb , 0x80 ) ; timestamp = 0 ; for ( i = 0 ; i < vst -> nb_frames ; i ++ ) { uint32_t pos = avio_rb32 ( pb ) ; uint32_t asize = avio_rb32 ( pb ) ; <S2SV_StartBug> uint32_t vsize = avio_rb32 ( pb ) ; <S2SV_EndBug> avio_skip ( pb , 8 ) ; av_add_index_entry ( ast , pos , timestamp , asize , 0 , AVINDEX_KEYFRAME ) ; av_add_index_entry ( vst , pos + asize , i , vsize , 0 , AVINDEX_KEYFRAME ) ; timestamp += asize / ( ast -> codecpar -> channels * 2 ) ; } } else if ( ! version && avio_rb16 ( pb ) == 3 ) { avio_skip ( pb , 4 ) ; if ( ( ret = read_table ( avctx , NULL , parse_global_var ) ) < 0 ) return ret ; if ( mv -> nb_audio_tracks > 1 ) { avpriv_request_sample ( avctx , ""Multiple<S2SV_blank>audio<S2SV_blank>streams<S2SV_blank>support"" ) ; return AVERROR_PATCHWELCOME ; } else if ( mv -> nb_audio_tracks ) { ast = avformat_new_stream ( avctx , NULL ) ; if ( ! ast ) return AVERROR ( ENOMEM ) ; ast -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; if ( ( read_table ( avctx , ast , parse_audio_var ) ) < 0 ) return ret ; if ( mv -> acompression == 100 && mv -> aformat == AUDIO_FORMAT_SIGNED && ast -> codecpar -> bits_per_coded_sample == 16 ) { ast -> codecpar -> codec_id = AV_CODEC_ID_PCM_S16BE ; } else { avpriv_request_sample ( avctx , ""Audio<S2SV_blank>compression<S2SV_blank>%i<S2SV_blank>(format<S2SV_blank>%i,<S2SV_blank>sr<S2SV_blank>%i)"" , mv -> acompression , mv -> aformat , ast -> codecpar -> bits_per_coded_sample ) ; ast -> codecpar -> codec_id = AV_CODEC_ID_NONE ; } if ( ast -> codecpar -> channels <= 0 ) { av_log ( avctx , AV_LOG_ERROR , ""No<S2SV_blank>valid<S2SV_blank>channel<S2SV_blank>count<S2SV_blank>found.\\n"" ) ; return AVERROR_INVALIDDATA ; } } if ( mv -> nb_video_tracks > 1 ) { avpriv_request_sample ( avctx , ""Multiple<S2SV_blank>video<S2SV_blank>streams<S2SV_blank>support"" ) ; return AVERROR_PATCHWELCOME ; } else if ( mv -> nb_video_tracks ) { vst = avformat_new_stream ( avctx , NULL ) ; if ( ! vst ) return AVERROR ( ENOMEM ) ; vst -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; if ( ( ret = read_table ( avctx , vst , parse_video_var ) ) < 0 ) return ret ; } if ( mv -> nb_audio_tracks ) read_index ( pb , ast ) ; if ( mv -> nb_video_tracks ) read_index ( pb , vst ) ; } else { avpriv_request_sample ( avctx , ""Version<S2SV_blank>%i"" , version ) ; return AVERROR_PATCHWELCOME ; } return 0 ; }
","<S2SV_ModStart> ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA
"
190,"CWE-189 int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { size_t ofs , tail = ( i << 1 ) + 1 ; if ( cdf_check_stream_offset ( sst , h , p , tail * sizeof ( uint32_t ) , __LINE__ ) == - 1 ) goto out ; ofs = CDF_GETUINT32 ( p , tail ) ; q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ; <S2SV_StartBug> if ( q > e ) { <S2SV_EndBug> DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , offs ) ) ; if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ; if ( nelements == 0 ) { DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\n"" ) ) ; goto out ; } o = 2 ; } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements ) ) ; for ( j = 0 ; j < nelements && i < sh . sh_properties ; j ++ , i ++ ) { uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }
","<S2SV_ModStart> if ( q < p || q
"
191,"CWE-20 void init_util ( void ) { filegen_register ( statsdir , ""peerstats"" , & peerstats ) ; filegen_register ( statsdir , ""loopstats"" , & loopstats ) ; filegen_register ( statsdir , ""clockstats"" , & clockstats ) ; filegen_register ( statsdir , ""rawstats"" , & rawstats ) ; filegen_register ( statsdir , ""sysstats"" , & sysstats ) ; filegen_register ( statsdir , ""protostats"" , & protostats ) ; <S2SV_StartBug> # ifdef AUTOKEY <S2SV_EndBug> filegen_register ( statsdir , ""cryptostats"" , & cryptostats ) ; <S2SV_StartBug> # endif <S2SV_EndBug> # ifdef DEBUG_TIMING filegen_register ( statsdir , ""timingstats"" , & timingstats ) ; <S2SV_StartBug> # endif <S2SV_EndBug> step_callback = & ntpd_time_stepped ; # ifdef DEBUG atexit ( & uninit_util ) ; # endif }
","<S2SV_ModStart> protostats ) ; <S2SV_ModEnd> filegen_register ( statsdir <S2SV_ModStart> cryptostats ) ; <S2SV_ModEnd> filegen_register ( statsdir <S2SV_ModStart> timingstats ) ; <S2SV_ModEnd> step_callback = &
"
192,"CWE-264 static FILE * pw_tmpfile ( int lockfd ) { FILE * fd ; char * tmpname = NULL ; <S2SV_StartBug> char * dir = ""/etc"" ; <S2SV_EndBug> <S2SV_StartBug> if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) { <S2SV_EndBug> ulckpwdf ( ) ; err ( EXIT_FAILURE , _ ( ""can\'t<S2SV_blank>open<S2SV_blank>temporary<S2SV_blank>file"" ) ) ; } copyfile ( lockfd , fileno ( fd ) ) ; tmp_file = tmpname ; return fd ; }
","<S2SV_ModStart> = NULL ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> & tmpname , ""/etc"" , "".vipw"" <S2SV_ModEnd> ) ) ==
"
193,"CWE-400 static void commit_tree ( struct mount * mnt , struct mount * shadows ) { struct mount * parent = mnt -> mnt_parent ; struct mount * m ; LIST_HEAD ( head ) ; struct mnt_namespace * n = parent -> mnt_ns ; BUG_ON ( parent == mnt ) ; list_add_tail ( & head , & mnt -> mnt_list ) ; list_for_each_entry ( m , & head , mnt_list ) m -> mnt_ns = n ; list_splice ( & head , n -> list . prev ) ; <S2SV_StartBug> attach_shadowed ( mnt , parent , shadows ) ; <S2SV_EndBug> touch_mnt_namespace ( n ) ; }
","<S2SV_ModStart> prev ) ; n -> mounts += n -> pending_mounts ; n -> pending_mounts = 0 ;
"
194,"CWE-200 __visible __notrace_funcgraph struct task_struct * __switch_to ( struct task_struct * prev_p , struct task_struct * next_p ) { struct thread_struct * prev = & prev_p -> thread ; struct thread_struct * next = & next_p -> thread ; int cpu = smp_processor_id ( ) ; struct tss_struct * tss = & per_cpu ( init_tss , cpu ) ; unsigned fsindex , gsindex ; fpu_switch_t fpu ; fpu = switch_fpu_prepare ( prev_p , next_p , cpu ) ; load_sp0 ( tss , next ) ; <S2SV_StartBug> savesegment ( es , prev -> es ) ; <S2SV_EndBug> if ( unlikely ( next -> es | prev -> es ) ) loadsegment ( es , next -> es ) ; savesegment ( ds , prev -> ds ) ; if ( unlikely ( next -> ds | prev -> ds ) ) <S2SV_StartBug> loadsegment ( ds , next -> ds ) ; <S2SV_EndBug> savesegment ( fs , fsindex ) ; savesegment ( gs , gsindex ) ; load_TLS ( next , cpu ) ; arch_end_context_switch ( next_p ) ; if ( unlikely ( fsindex | next -> fsindex | prev -> fs ) ) { loadsegment ( fs , next -> fsindex ) ; if ( fsindex ) prev -> fs = 0 ; } if ( next -> fs ) wrmsrl ( MSR_FS_BASE , next -> fs ) ; prev -> fsindex = fsindex ; if ( unlikely ( gsindex | next -> gsindex | prev -> gs ) ) { load_gs_index ( next -> gsindex ) ; if ( gsindex ) prev -> gs = 0 ; } if ( next -> gs ) wrmsrl ( MSR_KERNEL_GS_BASE , next -> gs ) ; prev -> gsindex = gsindex ; switch_fpu_finish ( next_p , fpu ) ; prev -> usersp = this_cpu_read ( old_rsp ) ; this_cpu_write ( old_rsp , next -> usersp ) ; this_cpu_write ( current_task , next_p ) ; task_thread_info ( prev_p ) -> saved_preempt_count = this_cpu_read ( __preempt_count ) ; this_cpu_write ( __preempt_count , task_thread_info ( next_p ) -> saved_preempt_count ) ; this_cpu_write ( kernel_stack , ( unsigned long ) task_stack_page ( next_p ) + THREAD_SIZE - KERNEL_STACK_OFFSET ) ; if ( unlikely ( task_thread_info ( next_p ) -> flags & _TIF_WORK_CTXSW_NEXT || task_thread_info ( prev_p ) -> flags & _TIF_WORK_CTXSW_PREV ) ) __switch_to_xtra ( prev_p , next_p , tss ) ; return prev_p ; }
","<S2SV_ModStart> ; savesegment ( fs , fsindex ) ; savesegment ( gs , gsindex ) ; load_TLS ( next , cpu ) ; arch_end_context_switch ( next_p ) ; savesegment ( <S2SV_ModStart> next -> ds <S2SV_ModEnd> ) ; if
"
195,"CWE-200 static void save_text_if_changed ( const char * name , const char * new_value ) { if ( ! g_hash_table_lookup ( g_loaded_texts , name ) ) return ; const char * old_value = g_cd ? problem_data_get_content_or_NULL ( g_cd , name ) : """" ; if ( ! old_value ) old_value = """" ; if ( strcmp ( new_value , old_value ) != 0 ) { struct dump_dir * dd = wizard_open_directory_for_writing ( g_dump_dir_name ) ; if ( dd ) dd_save_text ( dd , name , new_value ) ; dd_close ( dd ) ; <S2SV_StartBug> problem_data_reload_from_dump_dir ( ) ; <S2SV_EndBug> update_gui_state_from_problem_data ( 0 ) ; } }
","<S2SV_ModStart> dd ) ; <S2SV_ModEnd> } } <S2SV_null>
"
196,"CWE-000 IHEVCD_ERROR_T ihevcd_parse_pps ( codec_t * ps_codec ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; WORD32 pps_id ; pps_t * ps_pps ; sps_t * ps_sps ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; if ( 0 == ps_codec -> i4_sps_done ) return IHEVCD_INVALID_HEADER ; UEV_PARSE ( ""pic_parameter_set_id"" , value , ps_bitstrm ) ; pps_id = value ; if ( ( pps_id >= MAX_PPS_CNT ) || ( pps_id < 0 ) ) { if ( ps_codec -> i4_pps_done ) return IHEVCD_UNSUPPORTED_PPS_ID ; else pps_id = 0 ; } ps_pps = ( ps_codec -> s_parse . ps_pps_base + MAX_PPS_CNT - 1 ) ; ps_pps -> i1_pps_id = pps_id ; UEV_PARSE ( ""seq_parameter_set_id"" , value , ps_bitstrm ) ; ps_pps -> i1_sps_id = value ; ps_pps -> i1_sps_id = CLIP3 ( ps_pps -> i1_sps_id , 0 , MAX_SPS_CNT - 2 ) ; ps_sps = ( ps_codec -> s_parse . ps_sps_base + ps_pps -> i1_sps_id ) ; if ( 0 == ps_sps -> i1_sps_valid ) { return IHEVCD_INVALID_HEADER ; } BITS_PARSE ( ""dependent_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_dependent_slice_enabled_flag = value ; BITS_PARSE ( ""output_flag_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_output_flag_present_flag = value ; BITS_PARSE ( ""num_extra_slice_header_bits"" , value , ps_bitstrm , 3 ) ; ps_pps -> i1_num_extra_slice_header_bits = value ; BITS_PARSE ( ""sign_data_hiding_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_sign_data_hiding_flag = value ; BITS_PARSE ( ""cabac_init_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_cabac_init_present_flag = value ; UEV_PARSE ( ""num_ref_idx_l0_default_active_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_ref_idx_l0_default_active = value + 1 ; UEV_PARSE ( ""num_ref_idx_l1_default_active_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_ref_idx_l1_default_active = value + 1 ; SEV_PARSE ( ""pic_init_qp_minus26"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_init_qp = value + 26 ; BITS_PARSE ( ""constrained_intra_pred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_constrained_intra_pred_flag = value ; BITS_PARSE ( ""transform_skip_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_transform_skip_enabled_flag = value ; BITS_PARSE ( ""cu_qp_delta_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_cu_qp_delta_enabled_flag = value ; if ( ps_pps -> i1_cu_qp_delta_enabled_flag ) { UEV_PARSE ( ""diff_cu_qp_delta_depth"" , value , ps_bitstrm ) ; ps_pps -> i1_diff_cu_qp_delta_depth = value ; } else { ps_pps -> i1_diff_cu_qp_delta_depth = 0 ; } ps_pps -> i1_log2_min_cu_qp_delta_size = ps_sps -> i1_log2_ctb_size - ps_pps -> i1_diff_cu_qp_delta_depth ; SEV_PARSE ( ""cb_qp_offset"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_cb_qp_offset = value ; SEV_PARSE ( ""cr_qp_offset"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_cr_qp_offset = value ; BITS_PARSE ( ""slicelevel_chroma_qp_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pic_slice_level_chroma_qp_offsets_present_flag = value ; BITS_PARSE ( ""weighted_pred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_weighted_pred_flag = value ; BITS_PARSE ( ""weighted_bipred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_weighted_bipred_flag = value ; BITS_PARSE ( ""transquant_bypass_enable_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_transquant_bypass_enable_flag = value ; BITS_PARSE ( ""tiles_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_tiles_enabled_flag = value ; <S2SV_StartBug> BITS_PARSE ( ""entropy_coding_sync_enabled_flag"" , value , ps_bitstrm , 1 ) ; <S2SV_EndBug> ps_pps -> i1_entropy_coding_sync_enabled_flag = value ; ps_pps -> i1_loop_filter_across_tiles_enabled_flag = 0 ; if ( ps_pps -> i1_tiles_enabled_flag ) { WORD32 wd = ALIGN64 ( ps_codec -> i4_wd ) ; WORD32 ht = ALIGN64 ( ps_codec -> i4_ht ) ; WORD32 max_tile_cols = ( wd + MIN_TILE_WD - 1 ) / MIN_TILE_WD ; WORD32 max_tile_rows = ( ht + MIN_TILE_HT - 1 ) / MIN_TILE_HT ; UEV_PARSE ( ""num_tile_columns_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_tile_columns = value + 1 ; UEV_PARSE ( ""num_tile_rows_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_tile_rows = value + 1 ; if ( ( ps_pps -> i1_num_tile_columns < 1 ) || ( ps_pps -> i1_num_tile_columns > max_tile_cols ) || ( ps_pps -> i1_num_tile_rows < 1 ) || ( ps_pps -> i1_num_tile_rows > max_tile_rows ) ) return IHEVCD_INVALID_HEADER ; BITS_PARSE ( ""uniform_spacing_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_uniform_spacing_flag = value ; { WORD32 start ; WORD32 i , j ; start = 0 ; for ( i = 0 ; i < ps_pps -> i1_num_tile_columns ; i ++ ) { tile_t * ps_tile ; if ( ! ps_pps -> i1_uniform_spacing_flag ) { if ( i < ( ps_pps -> i1_num_tile_columns - 1 ) ) { UEV_PARSE ( ""column_width_minus1[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm ) ; value += 1 ; } else { value = ps_sps -> i2_pic_wd_in_ctb - start ; } } else { value = ( ( i + 1 ) * ps_sps -> i2_pic_wd_in_ctb ) / ps_pps -> i1_num_tile_columns - ( i * ps_sps -> i2_pic_wd_in_ctb ) / ps_pps -> i1_num_tile_columns ; } for ( j = 0 ; j < ps_pps -> i1_num_tile_rows ; j ++ ) { ps_tile = ps_pps -> ps_tile + j * ps_pps -> i1_num_tile_columns + i ; ps_tile -> u1_pos_x = start ; ps_tile -> u2_wd = value ; } start += value ; if ( ( start > ps_sps -> i2_pic_wd_in_ctb ) || ( value <= 0 ) ) return IHEVCD_INVALID_HEADER ; } start = 0 ; for ( i = 0 ; i < ( ps_pps -> i1_num_tile_rows ) ; i ++ ) { tile_t * ps_tile ; if ( ! ps_pps -> i1_uniform_spacing_flag ) { if ( i < ( ps_pps -> i1_num_tile_rows - 1 ) ) { UEV_PARSE ( ""row_height_minus1[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm ) ; value += 1 ; } else { value = ps_sps -> i2_pic_ht_in_ctb - start ; } } else { value = ( ( i + 1 ) * ps_sps -> i2_pic_ht_in_ctb ) / ps_pps -> i1_num_tile_rows - ( i * ps_sps -> i2_pic_ht_in_ctb ) / ps_pps -> i1_num_tile_rows ; } for ( j = 0 ; j < ps_pps -> i1_num_tile_columns ; j ++ ) { ps_tile = ps_pps -> ps_tile + i * ps_pps -> i1_num_tile_columns + j ; ps_tile -> u1_pos_y = start ; ps_tile -> u2_ht = value ; } start += value ; if ( ( start > ps_sps -> i2_pic_ht_in_ctb ) || ( value <= 0 ) ) return IHEVCD_INVALID_HEADER ; } } BITS_PARSE ( ""loop_filter_across_tiles_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_loop_filter_across_tiles_enabled_flag = value ; } else { ps_pps -> i1_num_tile_columns = 1 ; ps_pps -> i1_num_tile_rows = 1 ; ps_pps -> i1_uniform_spacing_flag = 1 ; ps_pps -> ps_tile -> u1_pos_x = 0 ; ps_pps -> ps_tile -> u1_pos_y = 0 ; ps_pps -> ps_tile -> u2_wd = ps_sps -> i2_pic_wd_in_ctb ; ps_pps -> ps_tile -> u2_ht = ps_sps -> i2_pic_ht_in_ctb ; } BITS_PARSE ( ""loop_filter_across_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_loop_filter_across_slices_enabled_flag = value ; BITS_PARSE ( ""deblocking_filter_control_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_deblocking_filter_control_present_flag = value ; ps_pps -> i1_pic_disable_deblocking_filter_flag = 0 ; ps_pps -> i1_deblocking_filter_override_enabled_flag = 0 ; ps_pps -> i1_beta_offset_div2 = 0 ; ps_pps -> i1_tc_offset_div2 = 0 ; if ( ps_pps -> i1_deblocking_filter_control_present_flag ) { BITS_PARSE ( ""deblocking_filter_override_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_deblocking_filter_override_enabled_flag = value ; BITS_PARSE ( ""pic_disable_deblocking_filter_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pic_disable_deblocking_filter_flag = value ; if ( ! ps_pps -> i1_pic_disable_deblocking_filter_flag ) { SEV_PARSE ( ""pps_beta_offset_div2"" , value , ps_bitstrm ) ; ps_pps -> i1_beta_offset_div2 = value ; SEV_PARSE ( ""pps_tc_offset_div2"" , value , ps_bitstrm ) ; ps_pps -> i1_tc_offset_div2 = value ; } } BITS_PARSE ( ""pps_scaling_list_data_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pps_scaling_list_data_present_flag = value ; if ( ps_pps -> i1_pps_scaling_list_data_present_flag ) { COPY_DEFAULT_SCALING_LIST ( ps_pps -> pi2_scaling_mat ) ; ihevcd_scaling_list_data ( ps_codec , ps_pps -> pi2_scaling_mat ) ; } BITS_PARSE ( ""lists_modification_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_lists_modification_present_flag = value ; UEV_PARSE ( ""log2_parallel_merge_level_minus2"" , value , ps_bitstrm ) ; ps_pps -> i1_log2_parallel_merge_level = value + 2 ; BITS_PARSE ( ""slice_header_extension_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_slice_header_extension_present_flag = value ; BITS_PARSE ( ""pps_extension_flag"" , value , ps_bitstrm , 1 ) ; if ( ( UWORD8 * ) ps_bitstrm -> pu4_buf > ps_bitstrm -> pu1_buf_max ) return IHEVCD_INVALID_PARAMETER ; ps_codec -> i4_pps_done = 1 ; return ret ; }
","<S2SV_ModStart> = value ; if ( ( ps_pps -> i1_tiles_enabled_flag ) && ( ps_sps -> i1_log2_ctb_size == 4 ) && ( ( ps_sps -> i2_pic_width_in_luma_samples >= 4096 ) || ( ps_sps -> i2_pic_height_in_luma_samples >= 4096 ) ) ) { return IHEVCD_INVALID_HEADER ; }
"
197,"CWE-399 static void update_exception_bitmap ( struct kvm_vcpu * vcpu ) { u32 eb ; eb = ( 1u << PF_VECTOR ) | ( 1u << UD_VECTOR ) | ( 1u << MC_VECTOR ) | <S2SV_StartBug> ( 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) ; <S2SV_EndBug> if ( ( vcpu -> guest_debug & ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) == ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) eb |= 1u << BP_VECTOR ; if ( to_vmx ( vcpu ) -> rmode . vm86_active ) eb = ~ 0 ; if ( enable_ept ) eb &= ~ ( 1u << PF_VECTOR ) ; if ( vcpu -> fpu_active ) eb &= ~ ( 1u << NM_VECTOR ) ; if ( is_guest_mode ( vcpu ) ) eb |= get_vmcs12 ( vcpu ) -> exception_bitmap ; vmcs_write32 ( EXCEPTION_BITMAP , eb ) ; }
","<S2SV_ModStart> 1u << DB_VECTOR ) | ( 1u << AC_VECTOR
"
198,"CWE-125 static void nfs_printfh ( netdissect_options * ndo , register const uint32_t * dp , const u_int len ) { my_fsid fsid ; uint32_t ino ; const char * sfsname = NULL ; char * spacep ; if ( ndo -> ndo_uflag ) { u_int i ; char const * sep = """" ; ND_PRINT ( ( ndo , ""<S2SV_blank>fh["" ) ) ; for ( i = 0 ; i < len ; i ++ ) { ND_PRINT ( ( ndo , ""%s%x"" , sep , dp [ i ] ) ) ; sep = "":"" ; } ND_PRINT ( ( ndo , ""]"" ) ) ; return ; } Parse_fh ( ( const u_char * ) dp , len , & fsid , & ino , NULL , & sfsname , 0 ) ; if ( sfsname ) { <S2SV_StartBug> static char temp [ NFSX_V3FHMAX + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( temp , sfsname , NFSX_V3FHMAX ) ; <S2SV_EndBug> <S2SV_StartBug> temp [ sizeof ( temp ) - 1 ] = '\\0' ; <S2SV_EndBug> spacep = strchr ( temp , '<S2SV_blank>' ) ; if ( spacep ) * spacep = '\\0' ; ND_PRINT ( ( ndo , ""<S2SV_blank>fh<S2SV_blank>%s/"" , temp ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>fh<S2SV_blank>%d,%d/"" , fsid . Fsid_dev . Major , fsid . Fsid_dev . Minor ) ) ; } if ( fsid . Fsid_dev . Minor == 257 ) ND_PRINT ( ( ndo , ""%s"" , fsid . Opaque_Handle ) ) ; else ND_PRINT ( ( ndo , ""%ld"" , ( long ) ino ) ) ; }
","<S2SV_ModStart> sfsname ) { <S2SV_ModEnd> char temp [ <S2SV_ModStart> 1 ] ; u_int stringlen ; stringlen = len ; if ( stringlen > NFSX_V3FHMAX ) stringlen = NFSX_V3FHMAX ; <S2SV_ModStart> , sfsname , stringlen <S2SV_ModEnd> ) ; temp <S2SV_ModStart> ; temp [ stringlen <S2SV_ModEnd> ] = '\\0'
"
199,"CWE-000 static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , <S2SV_StartBug> int transhdrlen , int mtu , unsigned int flags ) <S2SV_EndBug> { struct sk_buff * skb ; int err ; if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) { skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ; if ( skb == NULL ) return - ENOMEM ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ; skb -> ip_summed = CHECKSUM_PARTIAL ; skb -> csum = 0 ; } err = skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; if ( ! err ) { struct frag_hdr fhdr ; skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~ 7 ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ; <S2SV_StartBug> ipv6_select_ident ( & fhdr ) ; <S2SV_EndBug> skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; return 0 ; } kfree_skb ( skb ) ; return err ; }
","<S2SV_ModStart> unsigned int flags , struct rt6_info * rt <S2SV_ModStart> ( & fhdr , rt
"
200,"CWE-772 int hsr_dev_finalize ( struct net_device * hsr_dev , struct net_device * slave [ 2 ] , unsigned char multicast_spec , u8 protocol_version ) { struct hsr_priv * hsr ; struct hsr_port * port ; int res ; hsr = netdev_priv ( hsr_dev ) ; INIT_LIST_HEAD ( & hsr -> ports ) ; INIT_LIST_HEAD ( & hsr -> node_db ) ; INIT_LIST_HEAD ( & hsr -> self_node_db ) ; ether_addr_copy ( hsr_dev -> dev_addr , slave [ 0 ] -> dev_addr ) ; res = hsr_create_self_node ( & hsr -> self_node_db , hsr_dev -> dev_addr , slave [ 1 ] -> dev_addr ) ; if ( res < 0 ) return res ; spin_lock_init ( & hsr -> seqnr_lock ) ; hsr -> sequence_nr = HSR_SEQNR_START ; hsr -> sup_sequence_nr = HSR_SUP_SEQNR_START ; timer_setup ( & hsr -> announce_timer , hsr_announce , 0 ) ; timer_setup ( & hsr -> prune_timer , hsr_prune_nodes , 0 ) ; ether_addr_copy ( hsr -> sup_multicast_addr , def_multicast_addr ) ; hsr -> sup_multicast_addr [ ETH_ALEN - 1 ] = multicast_spec ; hsr -> protVersion = protocol_version ; netif_carrier_off ( hsr_dev ) ; res = hsr_add_port ( hsr , hsr_dev , HSR_PT_MASTER ) ; if ( res ) <S2SV_StartBug> return res ; <S2SV_EndBug> res = register_netdevice ( hsr_dev ) ; if ( res ) goto fail ; res = hsr_add_port ( hsr , slave [ 0 ] , HSR_PT_SLAVE_A ) ; if ( res ) goto fail ; res = hsr_add_port ( hsr , slave [ 1 ] , HSR_PT_SLAVE_B ) ; if ( res ) goto fail ; mod_timer ( & hsr -> prune_timer , jiffies + msecs_to_jiffies ( PRUNE_PERIOD ) ) ; return 0 ; fail : hsr_for_each_port ( hsr , port ) hsr_del_port ( port ) ; <S2SV_StartBug> return res ; <S2SV_EndBug> }
","<S2SV_ModStart> ( res ) goto err_add_port <S2SV_ModEnd> ; res = <S2SV_ModStart> port ) ; err_add_port : hsr_del_node ( & hsr -> self_node_db ) ;
"
201,"CWE-399 void parser ( void ) { char * arg ; # ifndef MINIMAL char * sitearg ; # endif # ifdef WITH_RFC2640 char * narg = NULL ; # endif size_t n ; # ifdef IMPLICIT_TLS ( void ) tls_init_new_session ( ) ; data_protection_level = CPL_PRIVATE ; # endif for ( ; ; ) { xferfd = - 1 ; if ( state_needs_update != 0 ) { state_needs_update = 0 ; setprocessname ( ""pure-ftpd<S2SV_blank>(IDLE)"" ) ; # ifdef FTPWHO if ( shm_data_cur != NULL ) { ftpwho_lock ( ) ; shm_data_cur -> state = FTPWHO_STATE_IDLE ; * shm_data_cur -> filename = 0 ; ftpwho_unlock ( ) ; } # endif } doreply ( ) ; alarm ( idletime * 2 ) ; switch ( sfgets ( ) ) { case - 1 : # ifdef BORING_MODE die ( 421 , LOG_INFO , MSG_TIMEOUT ) ; # else die ( 421 , LOG_INFO , MSG_TIMEOUT_PARSER ) ; # endif case - 2 : return ; } # ifdef DEBUG if ( debug != 0 ) { addreply ( 0 , ""%s"" , cmd ) ; } # endif n = ( size_t ) 0U ; while ( ( isalpha ( ( unsigned char ) cmd [ n ] ) || cmd [ n ] == '@' ) && n < cmdsize ) { cmd [ n ] = ( char ) tolower ( ( unsigned char ) cmd [ n ] ) ; n ++ ; } if ( n >= cmdsize ) { die ( 421 , LOG_WARNING , MSG_LINE_TOO_LONG ) ; } if ( n == ( size_t ) 0U ) { nop : addreply_noformat ( 500 , ""?"" ) ; continue ; } # ifdef SKIP_COMMAND_TRAILING_SPACES while ( isspace ( ( unsigned char ) cmd [ n ] ) && n < cmdsize ) { cmd [ n ++ ] = 0 ; } arg = cmd + n ; while ( cmd [ n ] != 0 && n < cmdsize ) { n ++ ; } n -- ; while ( isspace ( ( unsigned char ) cmd [ n ] ) ) { cmd [ n -- ] = 0 ; } # else if ( cmd [ n ] == 0 ) { arg = cmd + n ; } else if ( isspace ( ( unsigned char ) cmd [ n ] ) ) { cmd [ n ] = 0 ; arg = cmd + n + 1 ; } else { goto nop ; } # endif if ( logging != 0 ) { # ifdef DEBUG logfile ( LOG_DEBUG , MSG_DEBUG_COMMAND ""<S2SV_blank>[%s]<S2SV_blank>[%s]"" , cmd , arg ) ; # else logfile ( LOG_DEBUG , MSG_DEBUG_COMMAND ""<S2SV_blank>[%s]<S2SV_blank>[%s]"" , cmd , strcmp ( cmd , ""pass"" ) ? arg : ""<*>"" ) ; # endif } # ifdef WITH_RFC2640 narg = charset_client2fs ( arg ) ; arg = narg ; # endif # ifndef MINIMAL if ( ! strcmp ( cmd , ""noop"" ) ) { antiidle ( ) ; donoop ( ) ; goto wayout ; } # endif if ( ! strcmp ( cmd , ""user"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth > 1 && tls_cnx == NULL ) { die ( 421 , LOG_WARNING , MSG_TLS_NEEDED ) ; } # endif douser ( arg ) ; } else if ( ! strcmp ( cmd , ""acct"" ) ) { addreply ( 202 , MSG_WHOAREYOU ) ; } else if ( ! strcmp ( cmd , ""pass"" ) ) { if ( guest == 0 ) { randomdelay ( ) ; } dopass ( arg ) ; } else if ( ! strcmp ( cmd , ""quit"" ) ) { addreply ( 221 , MSG_GOODBYE , ( unsigned long long ) ( ( uploaded + 1023ULL ) / 1024ULL ) , ( unsigned long long ) ( ( downloaded + 1023ULL ) / 1024ULL ) ) ; return ; } else if ( ! strcmp ( cmd , ""syst"" ) ) { antiidle ( ) ; addreply_noformat ( 215 , ""UNIX<S2SV_blank>Type:<S2SV_blank>L8"" ) ; goto wayout ; # ifdef WITH_TLS } else if ( enforce_tls_auth > 0 && ! strcmp ( cmd , ""auth"" ) && ! strcasecmp ( arg , ""tls"" ) ) { addreply_noformat ( 234 , ""AUTH<S2SV_blank>TLS<S2SV_blank>OK."" ) ; doreply ( ) ; if ( tls_cnx == NULL ) { <S2SV_StartBug> ( void ) tls_init_new_session ( ) ; <S2SV_EndBug> } goto wayout ; } else if ( ! strcmp ( cmd , ""pbsz"" ) ) { addreply_noformat ( tls_cnx == NULL ? 503 : 200 , ""PBSZ=0"" ) ; } else if ( ! strcmp ( cmd , ""prot"" ) ) { if ( tls_cnx == NULL ) { addreply_noformat ( 503 , MSG_PROT_BEFORE_PBSZ ) ; goto wayout ; } switch ( * arg ) { case 0 : addreply_noformat ( 503 , MSG_MISSING_ARG ) ; data_protection_level = CPL_NONE ; break ; case 'C' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_OK , ""clear"" ) ; data_protection_level = CPL_CLEAR ; break ; } case 'S' : case 'E' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_UNKNOWN_LEVEL , arg , ""private"" ) ; data_protection_level = CPL_PRIVATE ; break ; } case 'P' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_OK , ""private"" ) ; data_protection_level = CPL_PRIVATE ; break ; } default : addreply_noformat ( 534 , ""Fallback<S2SV_blank>to<S2SV_blank>[C]"" ) ; data_protection_level = CPL_CLEAR ; break ; } # endif } else if ( ! strcmp ( cmd , ""auth"" ) || ! strcmp ( cmd , ""adat"" ) ) { addreply_noformat ( 500 , MSG_AUTH_UNIMPLEMENTED ) ; } else if ( ! strcmp ( cmd , ""type"" ) ) { antiidle ( ) ; dotype ( arg ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""mode"" ) ) { antiidle ( ) ; domode ( arg ) ; goto wayout ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""feat"" ) ) { dofeat ( ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""opts"" ) ) { doopts ( arg ) ; goto wayout ; # endif } else if ( ! strcmp ( cmd , ""stru"" ) ) { dostru ( arg ) ; goto wayout ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""help"" ) ) { goto help_site ; # endif # ifdef DEBUG } else if ( ! strcmp ( cmd , ""xdbg"" ) ) { debug ++ ; addreply ( 200 , MSG_XDBG_OK , debug ) ; goto wayout ; # endif } else if ( loggedin == 0 ) { addreply_noformat ( 530 , MSG_NOT_LOGGED_IN ) ; goto wayout ; } else { if ( ! strcmp ( cmd , ""cwd"" ) || ! strcmp ( cmd , ""xcwd"" ) ) { antiidle ( ) ; docwd ( arg ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""port"" ) ) { doport ( arg ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""eprt"" ) ) { doeprt ( arg ) ; } else if ( ! strcmp ( cmd , ""esta"" ) && disallow_passive == 0 && STORAGE_FAMILY ( force_passive_ip ) == 0 ) { doesta ( ) ; } else if ( ! strcmp ( cmd , ""estp"" ) ) { doestp ( ) ; # endif } else if ( disallow_passive == 0 && ( ! strcmp ( cmd , ""pasv"" ) || ! strcmp ( cmd , ""p@sw"" ) ) ) { dopasv ( 0 ) ; } else if ( disallow_passive == 0 && ( ! strcmp ( cmd , ""epsv"" ) && ( broken_client_compat == 0 || STORAGE_FAMILY ( ctrlconn ) == AF_INET6 ) ) ) { if ( ! strcasecmp ( arg , ""all"" ) ) { epsv_all = 1 ; addreply_noformat ( 220 , MSG_ACTIVE_DISABLED ) ; } else if ( ! strcmp ( arg , ""2"" ) && ! v6ready ) { addreply_noformat ( 522 , MSG_ONLY_IPV4 ) ; } else { dopasv ( 1 ) ; } # ifndef MINIMAL } else if ( disallow_passive == 0 && ! strcmp ( cmd , ""spsv"" ) ) { dopasv ( 2 ) ; } else if ( ! strcmp ( cmd , ""allo"" ) ) { if ( * arg == 0 ) { addreply_noformat ( 501 , MSG_STAT_FAILURE ) ; } else { const off_t size = ( off_t ) strtoull ( arg , NULL , 10 ) ; if ( size < ( off_t ) 0 ) { addreply_noformat ( 501 , MSG_STAT_FAILURE ) ; } else { doallo ( size ) ; } } # endif } else if ( ! strcmp ( cmd , ""pwd"" ) || ! strcmp ( cmd , ""xpwd"" ) ) { # ifdef WITH_RFC2640 char * nwd ; # endif antiidle ( ) ; # ifdef WITH_RFC2640 nwd = charset_fs2client ( wd ) ; addreply ( 257 , ""\\""%s\\""<S2SV_blank>"" MSG_IS_YOUR_CURRENT_LOCATION , nwd ) ; free ( nwd ) ; # else addreply ( 257 , ""\\""%s\\""<S2SV_blank>"" MSG_IS_YOUR_CURRENT_LOCATION , wd ) ; # endif goto wayout ; } else if ( ! strcmp ( cmd , ""cdup"" ) || ! strcmp ( cmd , ""xcup"" ) ) { docwd ( "".."" ) ; } else if ( ! strcmp ( cmd , ""retr"" ) ) { if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { doretr ( arg ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""rest"" ) ) { antiidle ( ) ; if ( * arg != 0 ) { dorest ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_RESTART_POINT ) ; restartat = ( off_t ) 0 ; } goto wayout ; } else if ( ! strcmp ( cmd , ""dele"" ) ) { if ( * arg != 0 ) { dodele ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""stor"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostor ( arg , 0 , autorename ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""appe"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostor ( arg , 1 , 0 ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""stou"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostou ( ) ; } # endif # ifndef DISABLE_MKD_RMD } else if ( ! strcmp ( cmd , ""mkd"" ) || ! strcmp ( cmd , ""xmkd"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { domkd ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_DIRECTORY_NAME ) ; } } else if ( ! strcmp ( cmd , ""rmd"" ) || ! strcmp ( cmd , ""xrmd"" ) ) { if ( * arg != 0 ) { dormd ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_DIRECTORY_NAME ) ; } # endif # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""stat"" ) ) { if ( * arg != 0 ) { modern_listings = 0 ; donlist ( arg , 1 , 1 , 1 , 1 ) ; } else { addreply_noformat ( 211 , ""http://www.pureftpd.org/"" ) ; } # endif } else if ( ! strcmp ( cmd , ""list"" ) ) { # ifndef MINIMAL modern_listings = 0 ; # endif # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 1 , 0 , 1 ) ; } } else if ( ! strcmp ( cmd , ""nlst"" ) ) { # ifndef MINIMAL modern_listings = 0 ; # endif # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 0 , 0 , broken_client_compat ) ; } # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""mlst"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { domlst ( * arg != 0 ? arg : ""."" ) ; } } else if ( ! strcmp ( cmd , ""mlsd"" ) ) { modern_listings = 1 ; # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 1 , 1 , 0 ) ; } # endif } else if ( ! strcmp ( cmd , ""abor"" ) ) { addreply_noformat ( 226 , MSG_ABOR_SUCCESS ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""site"" ) ) { if ( ( sitearg = arg ) != NULL ) { while ( * sitearg != 0 && ! isspace ( ( unsigned char ) * sitearg ) ) { sitearg ++ ; } if ( * sitearg != 0 ) { * sitearg ++ = 0 ; } } if ( ! strcasecmp ( arg , ""idle"" ) ) { if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , ""SITE<S2SV_blank>IDLE:<S2SV_blank>"" MSG_MISSING_ARG ) ; } else { unsigned long int i = 0 ; i = strtoul ( sitearg , & sitearg , 10 ) ; if ( sitearg && * sitearg ) addreply ( 501 , MSG_GARBAGE_FOUND ""<S2SV_blank>:<S2SV_blank>%s"" , sitearg ) ; else if ( i > MAX_SITE_IDLE ) addreply_noformat ( 501 , MSG_VALUE_TOO_LARGE ) ; else { idletime = i ; addreply ( 200 , MSG_IDLE_TIME , idletime ) ; idletime_noop = ( double ) idletime * 2.0 ; } } } else if ( ! strcasecmp ( arg , ""time"" ) ) { dositetime ( ) ; } else if ( ! strcasecmp ( arg , ""help"" ) ) { help_site : addreply_noformat ( 214 , MSG_SITE_HELP CRLF # ifdef WITH_DIRALIASES ""<S2SV_blank>ALIAS"" CRLF # endif ""<S2SV_blank>CHMOD"" CRLF ""<S2SV_blank>IDLE"" CRLF ""<S2SV_blank>UTIME"" ) ; addreply_noformat ( 214 , ""Pure-FTPd<S2SV_blank>-<S2SV_blank>http://pureftpd.org/"" ) ; } else if ( ! strcasecmp ( arg , ""chmod"" ) ) { char * sitearg2 ; mode_t mode ; parsechmod : if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto chmod_wayout ; } sitearg2 = sitearg ; while ( * sitearg2 != 0 && ! isspace ( ( unsigned char ) * sitearg2 ) ) { sitearg2 ++ ; } while ( * sitearg2 != 0 && isspace ( ( unsigned char ) * sitearg2 ) ) { sitearg2 ++ ; } if ( * sitearg2 == 0 ) { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; goto chmod_wayout ; } mode = ( mode_t ) strtoul ( sitearg , NULL , 8 ) ; if ( mode > ( mode_t ) 07777 ) { addreply_noformat ( 501 , MSG_BAD_CHMOD ) ; goto chmod_wayout ; } dochmod ( sitearg2 , mode ) ; chmod_wayout : ( void ) 0 ; } else if ( ! strcasecmp ( arg , ""utime"" ) ) { char * sitearg2 ; if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; goto utime_wayout ; } if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto utime_wayout ; } if ( strcasecmp ( sitearg2 , ""<S2SV_blank>UTC"" ) != 0 ) { addreply_noformat ( 500 , ""UTC<S2SV_blank>Only"" ) ; goto utime_wayout ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { utime_no_arg : addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto utime_wayout ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { goto utime_no_arg ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { goto utime_no_arg ; } * sitearg2 ++ = 0 ; if ( * sitearg2 == 0 ) { goto utime_no_arg ; } doutime ( sitearg , sitearg2 ) ; utime_wayout : ( void ) 0 ; # ifdef WITH_DIRALIASES } else if ( ! strcasecmp ( arg , ""alias"" ) ) { if ( sitearg == NULL || * sitearg == 0 ) { print_aliases ( ) ; } else { const char * alias ; if ( ( alias = lookup_alias ( sitearg ) ) != NULL ) { addreply ( 214 , MSG_ALIASES_ALIAS , sitearg , alias ) ; } else { addreply ( 502 , MSG_ALIASES_UNKNOWN , sitearg ) ; } } # endif } else if ( * arg != 0 ) { addreply ( 500 , ""SITE<S2SV_blank>%s<S2SV_blank>"" MSG_UNKNOWN_EXTENSION , arg ) ; } else { addreply_noformat ( 500 , ""SITE:<S2SV_blank>"" MSG_MISSING_ARG ) ; } # endif } else if ( ! strcmp ( cmd , ""mdtm"" ) ) { domdtm ( arg ) ; } else if ( ! strcmp ( cmd , ""size"" ) ) { dosize ( arg ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""chmod"" ) ) { sitearg = arg ; goto parsechmod ; # endif } else if ( ! strcmp ( cmd , ""rnfr"" ) ) { if ( * arg != 0 ) { dornfr ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""rnto"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { dornto ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; } } else { addreply_noformat ( 500 , MSG_UNKNOWN_COMMAND ) ; } } noopidle = ( time_t ) - 1 ; wayout : # ifdef WITH_RFC2640 free ( narg ) ; narg = NULL ; # endif # ifdef THROTTLING if ( throttling_delay != 0UL ) { usleep2 ( throttling_delay ) ; } # else ( void ) 0 ; # endif } }
","<S2SV_ModStart> NULL ) { flush_cmd ( ) ;
"
202,"CWE-119 <S2SV_StartBug> void vp9_setup_dst_planes ( MACROBLOCKD * xd , <S2SV_EndBug> const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col ) { <S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> src -> alpha_buffer } ; <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> src -> alpha_stride } ; int i ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { <S2SV_StartBug> struct macroblockd_plane * const pd = & xd -> plane [ i ] ; <S2SV_EndBug> setup_pred_plane ( & pd -> dst , buffers [ i ] , strides [ i ] , mi_row , mi_col , NULL , pd -> subsampling_x , pd -> subsampling_y ) ; } }
","<S2SV_ModStart> void vp9_setup_dst_planes ( struct macroblockd_plane planes [ MAX_MB_PLANE ] <S2SV_ModEnd> , const YV12_BUFFER_CONFIG <S2SV_ModStart> const buffers [ MAX_MB_PLANE <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> v_buffer <S2SV_ModEnd> } ; const <S2SV_ModStart> int strides [ MAX_MB_PLANE <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> uv_stride <S2SV_ModEnd> } ; int <S2SV_ModStart> pd = & planes <S2SV_ModEnd> [ i ]
"
203,"CWE-119 int nfs3svc_decode_writeargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_writeargs * args ) { unsigned int len , v , hdr , dlen ; u32 max_blocksize = svc_max_payload ( rqstp ) ; struct kvec * head = rqstp -> rq_arg . head ; struct kvec * tail = rqstp -> rq_arg . tail ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> offset ) ; args -> count = ntohl ( * p ++ ) ; args -> stable = ntohl ( * p ++ ) ; <S2SV_StartBug> len = args -> len = ntohl ( * p ++ ) ; <S2SV_EndBug> if ( args -> count != args -> len ) return 0 ; hdr = ( void * ) p - head -> iov_base ; dlen = head -> iov_len + rqstp -> rq_arg . page_len + tail -> iov_len - hdr ; if ( dlen < XDR_QUADLEN ( len ) * 4 ) return 0 ; if ( args -> count > max_blocksize ) { args -> count = max_blocksize ; len = args -> len = max_blocksize ; } rqstp -> rq_vec [ 0 ] . iov_base = ( void * ) p ; rqstp -> rq_vec [ 0 ] . iov_len = head -> iov_len - hdr ; v = 0 ; while ( len > rqstp -> rq_vec [ v ] . iov_len ) { len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; rqstp -> rq_vec [ v ] . iov_base = page_address ( rqstp -> rq_pages [ v ] ) ; rqstp -> rq_vec [ v ] . iov_len = PAGE_SIZE ; } rqstp -> rq_vec [ v ] . iov_len = len ; args -> vlen = v + 1 ; return 1 ; }
","<S2SV_ModStart> p ++ ) ; if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0
"
204,"CWE-000 <S2SV_StartBug> static inline void assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst ) <S2SV_EndBug> { <S2SV_StartBug> switch ( ctxt -> op_bytes ) { <S2SV_EndBug> case 2 : ctxt -> _eip = ( u16 ) dst ; break ; case 4 : ctxt -> _eip = ( u32 ) dst ; break ; case 8 : ctxt -> _eip = dst ; break ; default : WARN ( 1 , ""unsupported<S2SV_blank>eip<S2SV_blank>assignment<S2SV_blank>size\\n"" ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> static inline int <S2SV_ModEnd> assign_eip_near ( struct <S2SV_ModStart> dst ) { return assign_eip_far ( ctxt , dst , ctxt -> mode == X86EMUL_MODE_PROT64 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
"
205,"CWE-119 static vpx_codec_err_t ctrl_set_invert_tile_order ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ctx -> invert_tile_order = va_arg ( args , int ) ; return VPX_CODEC_OK ; }
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args )
"
206,"CWE-399 static int dissect_spoolss_uint16uni ( tvbuff_t * tvb , int offset , packet_info * pinfo _U_ , proto_tree * tree , guint8 * drep _U_ , char * * data , int hf_name ) { gint len , remaining ; char * text ; if ( offset % 2 ) offset += 2 - ( offset % 2 ) ; <S2SV_StartBug> remaining = tvb_captured_length_remaining ( tvb , offset ) ; <S2SV_EndBug> if ( remaining <= 0 ) { if ( data ) * data = g_strdup ( """" ) ; return offset ; } text = tvb_get_string_enc ( NULL , tvb , offset , remaining , ENC_UTF_16 | ENC_LITTLE_ENDIAN ) ; len = ( int ) strlen ( text ) ; proto_tree_add_string ( tree , hf_name , tvb , offset , len * 2 , text ) ; if ( data ) * data = text ; else g_free ( text ) ; return offset + ( len + 1 ) * 2 ; }
","<S2SV_ModStart> ; remaining = tvb_reported_length_remaining <S2SV_ModEnd> ( tvb ,
"
207,"CWE-362 static ssize_t ocfs2_direct_IO ( struct kiocb * iocb , struct iov_iter * iter ) { struct file * file = iocb -> ki_filp ; struct inode * inode = file -> f_mapping -> host ; struct ocfs2_super * osb = OCFS2_SB ( inode -> i_sb ) ; get_block_t * get_block ; if ( OCFS2_I ( inode ) -> ip_dyn_features & OCFS2_INLINE_DATA_FL ) return 0 ; if ( iocb -> ki_pos + iter -> count > i_size_read ( inode ) && ! ocfs2_supports_append_dio ( osb ) ) return 0 ; if ( iov_iter_rw ( iter ) == READ ) <S2SV_StartBug> get_block = ocfs2_get_block ; <S2SV_EndBug> else <S2SV_StartBug> get_block = ocfs2_dio_get_block ; <S2SV_EndBug> return __blockdev_direct_IO ( iocb , inode , inode -> i_sb -> s_bdev , iter , get_block , ocfs2_dio_end_io , NULL , 0 ) ; }
","<S2SV_ModStart> ) get_block = ocfs2_lock_get_block <S2SV_ModEnd> ; else get_block <S2SV_ModStart> else get_block = ocfs2_dio_wr_get_block <S2SV_ModEnd> ; return __blockdev_direct_IO
"
208,"CWE-20 static int rawsock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct sk_buff * skb ; int copied ; int rc ; pr_debug ( ""sock=%p<S2SV_blank>sk=%p<S2SV_blank>len=%zu<S2SV_blank>flags=%d\\n"" , sock , sk , len , flags ) ; skb = skb_recv_datagram ( sk , flags , noblock , & rc ) ; if ( ! skb ) return rc ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } rc = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; skb_free_datagram ( sk , skb ) ; return rc ? : copied ; }
","<S2SV_ModStart> return rc ; <S2SV_ModEnd> copied = skb
"
209,"CWE-120 void M_LoadDefaults ( void ) { int i ; int len ; FILE * f ; char def [ 80 ] ; char strparm [ 100 ] ; char * newstring ; int parm ; boolean isstring ; numdefaults = sizeof ( defaults ) / sizeof ( defaults [ 0 ] ) ; for ( i = 0 ; i < numdefaults ; i ++ ) * defaults [ i ] . location = defaults [ i ] . defaultvalue ; i = M_CheckParm ( ""-config"" ) ; if ( i && i < myargc - 1 ) { defaultfile = myargv [ i + 1 ] ; printf ( ""\tdefault<S2SV_blank>file:<S2SV_blank>%s\\n"" , defaultfile ) ; } else defaultfile = basedefault ; f = fopen ( defaultfile , ""r"" ) ; if ( f ) { while ( ! feof ( f ) ) { isstring = false ; <S2SV_StartBug> if ( fscanf ( f , ""%79s<S2SV_blank>%[^\\n]\\n"" , def , strparm ) == 2 ) <S2SV_EndBug> { if ( strparm [ 0 ] == \'""\' ) { isstring = true ; len = strlen ( strparm ) ; newstring = ( char * ) malloc ( len ) ; strparm [ len - 1 ] = 0 ; strcpy ( newstring , strparm + 1 ) ; } else if ( strparm [ 0 ] == '0' && strparm [ 1 ] == 'x' ) sscanf ( strparm + 2 , ""%x"" , & parm ) ; else sscanf ( strparm , ""%i"" , & parm ) ; for ( i = 0 ; i < numdefaults ; i ++ ) if ( ! strcmp ( def , defaults [ i ] . name ) ) { if ( ! isstring ) * defaults [ i ] . location = parm ; else * defaults [ i ] . location = ( int ) newstring ; break ; } } } fclose ( f ) ; } for ( i = 0 ; i < numdefaults ; i ++ ) { if ( defaults [ i ] . scantranslate ) { parm = * defaults [ i ] . location ; defaults [ i ] . untranslated = parm ; * defaults [ i ] . location = scantokey [ parm ] ; } } }
","<S2SV_ModStart> ( f , ""%79s<S2SV_blank>%99[^\\n]\\n"" <S2SV_ModEnd> , def ,
"
210,"CWE-189 static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; if ( cpuhw -> n_limited ) freeze_limited_counters ( cpuhw , mfspr ( SPRN_PMC5 ) , mfspr ( SPRN_PMC6 ) ) ; perf_read_regs ( regs ) ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < cpuhw -> n_events ; ++ i ) { event = cpuhw -> event [ i ] ; if ( ! event -> hw . idx || is_limited_pmc ( event -> hw . idx ) ) continue ; val = read_pmc ( event -> hw . idx ) ; if ( ( int ) val < 0 ) { found = 1 ; record_and_restart ( event , val , regs , nmi ) ; } } if ( ! found ) { for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { if ( is_limited_pmc ( i + 1 ) ) continue ; val = read_pmc ( i + 1 ) ; <S2SV_StartBug> if ( ( int ) val < 0 ) <S2SV_EndBug> write_pmc ( i + 1 , 0 ) ; } } write_mmcr0 ( cpuhw , cpuhw -> mmcr [ 0 ] ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }
","<S2SV_ModStart> ; if ( pmc_overflow ( val ) <S2SV_ModEnd> ) write_pmc (
"
211,"CWE-125 static ssize_t next_line ( struct archive_read * a , const char * * b , ssize_t * avail , ssize_t * ravail , ssize_t * nl ) { ssize_t len ; int quit ; quit = 0 ; if ( * avail == 0 ) { * nl = 0 ; len = 0 ; } else len = get_line_size ( * b , * avail , nl ) ; while ( * nl == 0 && len == * avail && ! quit ) { ssize_t diff = * ravail - * avail ; size_t nbytes_req = ( * ravail + 1023 ) & ~ 1023U ; ssize_t tested ; if ( nbytes_req < ( size_t ) * ravail + 160 ) nbytes_req <<= 1 ; * b = __archive_read_ahead ( a , nbytes_req , avail ) ; if ( * b == NULL ) { if ( * ravail >= * avail ) return ( 0 ) ; * b = __archive_read_ahead ( a , * avail , avail ) ; quit = 1 ; } * ravail = * avail ; * b += diff ; * avail -= diff ; tested = len ; <S2SV_StartBug> len = get_line_size ( * b , * avail , nl ) ; <S2SV_EndBug> if ( len >= 0 ) len += tested ; } return ( len ) ; }
","<S2SV_ModStart> ( * b + len , * avail - len <S2SV_ModEnd> , nl )
"
212,"CWE-125 static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { <S2SV_StartBug> int all_whitespace = 1 ; <S2SV_EndBug> int kind ; void * data ; PyCompilerFlags cf ; <S2SV_StartBug> mod_ty mod ; <S2SV_EndBug> char * str ; <S2SV_StartBug> PyObject * o , * fstring_name ; <S2SV_EndBug> Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; <S2SV_StartBug> o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; <S2SV_EndBug> if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string:<S2SV_blank>empty<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) <S2SV_StartBug> return NULL ; <S2SV_EndBug> str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; <S2SV_StartBug> fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; <S2SV_EndBug> mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; <S2SV_StartBug> PyMem_RawFree ( str ) ; <S2SV_EndBug> if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
","<S2SV_ModStart> n ) { <S2SV_ModEnd> PyCompilerFlags cf ; <S2SV_ModStart> PyCompilerFlags cf ; node * mod_n ; <S2SV_ModStart> * str ; Py_ssize_t len ; const char * s ; PyObject * fstring_name <S2SV_ModEnd> ; assert ( <S2SV_ModStart> ':' ) ; for ( s = expr_start ; s != expr_end ; s ++ ) { char c = * s ; if ( ! ( c == '<S2SV_blank>' || c == '\\t' || c == '\\n' || c == '\\f' ) ) { break ; } } if ( s == expr_end ) { ast_error ( c , n , ""f-string:<S2SV_blank>empty<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>allowed"" ) ; return NULL ; } len = <S2SV_ModEnd> expr_end - expr_start <S2SV_ModStart> expr_end - expr_start <S2SV_ModEnd> ; str = <S2SV_ModStart> == NULL ) { PyErr_NoMemory ( ) ; return NULL ; } <S2SV_ModEnd> str [ 0 <S2SV_ModStart> = PyCF_ONLY_AST ; mod_n = PyParser_SimpleParseStringFlagsFilename ( str , ""<fstring>"" , Py_eval_input , 0 ) ; if ( ! mod_n ) { PyMem_RawFree ( str ) ; return NULL ; } str [ 0 ] = '{' ; str [ len + 1 ] = '}' ; fstring_fix_node_location ( n , mod_n , str ) ; <S2SV_ModStart> PyMem_RawFree ( str ) ; Ta3Node_Free ( mod_n
"
213,"CWE-125 <S2SV_StartBug> void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name ) <S2SV_EndBug> { WLog_DBG ( TAG , ""%s<S2SV_blank>(Len:<S2SV_blank>%"" PRIu16 ""<S2SV_blank>MaxLen:<S2SV_blank>%"" PRIu16 ""<S2SV_blank>BufferOffset:<S2SV_blank>%"" PRIu32 "")"" , name , fields -> Len , fields -> MaxLen , fields -> BufferOffset ) ; if ( fields -> Len > 0 ) winpr_HexDump ( TAG , WLOG_DEBUG , fields -> Buffer , fields -> Len ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
"
214,"CWE-119 cJSON * cJSON_GetObjectItem ( cJSON * object , const char * string ) { <S2SV_StartBug> cJSON * c = object -> child ; <S2SV_EndBug> while ( c && cJSON_strcasecmp ( c -> string , string ) ) c = c -> next ; return c ; }
","<S2SV_ModStart> c = object ? object -> child : 0 <S2SV_ModEnd> ; while (
"
215,"CWE-20 static inline key_ref_t __key_update ( key_ref_t key_ref , struct key_preparsed_payload * prep ) { struct key * key = key_ref_to_ptr ( key_ref ) ; int ret ; ret = key_permission ( key_ref , KEY_NEED_WRITE ) ; if ( ret < 0 ) goto error ; ret = - EEXIST ; if ( ! key -> type -> update ) goto error ; down_write ( & key -> sem ) ; ret = key -> type -> update ( key , prep ) ; if ( ret == 0 ) <S2SV_StartBug> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <S2SV_EndBug> up_write ( & key -> sem ) ; if ( ret < 0 ) goto error ; out : return key_ref ; error : key_put ( key ) ; key_ref = ERR_PTR ( ret ) ; goto out ; }
","<S2SV_ModStart> == 0 ) mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; up_write
"
216,"CWE-20 int net_get ( int s , void * arg , int * len ) { struct net_hdr nh ; int plen ; if ( net_read_exact ( s , & nh , sizeof ( nh ) ) == - 1 ) { return - 1 ; } plen = ntohl ( nh . nh_len ) ; if ( ! ( plen <= * len ) ) printf ( ""PLEN<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>len<S2SV_blank>%d\\n"" , plen , nh . nh_type , * len ) ; <S2SV_StartBug> assert ( plen <= * len ) ; <S2SV_EndBug> * len = plen ; if ( ( * len ) && ( net_read_exact ( s , arg , * len ) == - 1 ) ) { return - 1 ; } return nh . nh_type ; }
","<S2SV_ModStart> <= * len && plen > 0
"
217,"CWE-19 int xfs_attr3_leaf_list_int ( struct xfs_buf * bp , struct xfs_attr_list_context * context ) { struct attrlist_cursor_kern * cursor ; struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_entry * entry ; int retval ; int i ; trace_xfs_attr_list_leaf ( context ) ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; entries = xfs_attr3_leaf_entryp ( leaf ) ; cursor = context -> cursor ; cursor -> initted = 1 ; if ( context -> resynch ) { entry = & entries [ 0 ] ; for ( i = 0 ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval ) { if ( cursor -> offset == context -> dupcnt ) { context -> dupcnt = 0 ; break ; } context -> dupcnt ++ ; } else if ( be32_to_cpu ( entry -> hashval ) > cursor -> hashval ) { context -> dupcnt = 0 ; break ; } } if ( i == ichdr . count ) { trace_xfs_attr_list_notfound ( context ) ; return 0 ; } } else { entry = & entries [ 0 ] ; i = 0 ; } context -> resynch = 0 ; retval = 0 ; for ( ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) != cursor -> hashval ) { cursor -> hashval = be32_to_cpu ( entry -> hashval ) ; cursor -> offset = 0 ; } if ( entry -> flags & XFS_ATTR_INCOMPLETE ) continue ; if ( entry -> flags & XFS_ATTR_LOCAL ) { xfs_attr_leaf_name_local_t * name_loc = xfs_attr3_leaf_name_local ( leaf , i ) ; retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ; if ( retval ) return retval ; } else { xfs_attr_leaf_name_remote_t * name_rmt = xfs_attr3_leaf_name_remote ( leaf , i ) ; int valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; if ( context -> put_value ) { xfs_da_args_t args ; memset ( ( char * ) & args , 0 , sizeof ( args ) ) ; args . dp = context -> dp ; args . whichfork = XFS_ATTR_FORK ; args . valuelen = valuelen ; <S2SV_StartBug> args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ; <S2SV_EndBug> args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args . rmtblkcnt = xfs_attr3_rmt_blocks ( args . dp -> i_mount , valuelen ) ; retval = xfs_attr_rmtval_get ( & args ) ; if ( retval ) return retval ; retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , args . value ) ; kmem_free ( args . value ) ; } else { retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , NULL ) ; } if ( retval ) return retval ; } if ( context -> seen_enough ) break ; cursor -> offset ++ ; } trace_xfs_attr_list_leaf_end ( context ) ; return retval ; }
","<S2SV_ModStart> ; args . rmtvaluelen = valuelen ; args .
"
218,"CWE-20 asmlinkage long compat_sys_recvmmsg ( int fd , struct compat_mmsghdr __user * mmsg , unsigned int vlen , unsigned int flags , struct compat_timespec __user * timeout ) { int datagrams ; struct timespec ktspec ; if ( flags & MSG_CMSG_COMPAT ) return - EINVAL ; <S2SV_StartBug> if ( COMPAT_USE_64BIT_TIME ) <S2SV_EndBug> return __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , ( struct timespec * ) timeout ) ; if ( timeout == NULL ) return __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , NULL ) ; <S2SV_StartBug> if ( get_compat_timespec ( & ktspec , timeout ) ) <S2SV_EndBug> return - EFAULT ; datagrams = __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , & ktspec ) ; <S2SV_StartBug> if ( datagrams > 0 && put_compat_timespec ( & ktspec , timeout ) ) <S2SV_EndBug> datagrams = - EFAULT ; return datagrams ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> timeout == NULL <S2SV_ModStart> ; if ( compat_get_timespec <S2SV_ModEnd> ( & ktspec <S2SV_ModStart> > 0 && compat_put_timespec <S2SV_ModEnd> ( & ktspec
"
219,"CWE-119 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; <S2SV_StartBug> image -> storage_class = PseudoClass ; <S2SV_EndBug> image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; <S2SV_StartBug> } <S2SV_EndBug> switch ( sun_info . maptype ) { <S2SV_StartBug> case RMT_NONE : <S2SV_EndBug> { if ( sun_info . depth < 24 ) { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case RMT_EQUAL_RGB : { unsigned char <S2SV_StartBug> * sun_colormap ; <S2SV_EndBug> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; sun_pixels = sun_data ; bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; } p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ; image -> <S2SV_ModEnd> colors = sun_info <S2SV_ModStart> / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_ModStart> maptype ) { <S2SV_ModEnd> case RMT_EQUAL_RGB : <S2SV_ModStart> char * sun_colormap <S2SV_ModEnd> ; sun_colormap =
"
220,"CWE-416 static netdev_tx_t hns_nic_net_xmit ( struct sk_buff * skb , struct net_device * ndev ) { struct hns_nic_priv * priv = netdev_priv ( ndev ) ; <S2SV_StartBug> int ret ; <S2SV_EndBug> assert ( skb -> queue_mapping < ndev -> ae_handle -> q_num ) ; <S2SV_StartBug> ret = hns_nic_net_xmit_hw ( ndev , skb , <S2SV_EndBug> & tx_ring_data ( priv , skb -> queue_mapping ) ) ; <S2SV_StartBug> if ( ret == NETDEV_TX_OK ) { <S2SV_EndBug> netif_trans_update ( ndev ) ; ndev -> stats . tx_bytes += skb -> len ; ndev -> stats . tx_packets ++ ; } return ( netdev_tx_t ) ret ; }
","<S2SV_ModStart> ndev ) ; <S2SV_ModEnd> assert ( skb <S2SV_ModStart> q_num ) ; return <S2SV_ModEnd> hns_nic_net_xmit_hw ( ndev <S2SV_ModStart> ) ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
221,"CWE-20 static int hash_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; unsigned ds = crypto_ahash_digestsize ( crypto_ahash_reqtfm ( & ctx -> req ) ) ; int err ; if ( len > ds ) len = ds ; else if ( len < ds ) msg -> msg_flags |= MSG_TRUNC ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> lock_sock ( sk ) ; if ( ctx -> more ) { ctx -> more = 0 ; ahash_request_set_crypt ( & ctx -> req , NULL , ctx -> result , 0 ) ; err = af_alg_wait_for_completion ( crypto_ahash_final ( & ctx -> req ) , & ctx -> completion ) ; if ( err ) goto unlock ; } err = memcpy_toiovec ( msg -> msg_iov , ctx -> result , len ) ; unlock : release_sock ( sk ) ; return err ? : len ; }
","<S2SV_ModStart> |= MSG_TRUNC ; <S2SV_ModEnd> lock_sock ( sk
"
222,"CWE-400 int main ( int argc , char * * argv ) { int c ; bool lock_memory = false ; bool do_daemonize = false ; bool preallocate = false ; int maxcore = 0 ; char * username = NULL ; char * pid_file = NULL ; struct passwd * pw ; struct rlimit rlim ; char * buf ; char unit = '\\0' ; int size_max = 0 ; int retval = EXIT_SUCCESS ; static int * l_socket = NULL ; static int * u_socket = NULL ; bool protocol_specified = false ; bool tcp_specified = false ; bool udp_specified = false ; bool start_lru_maintainer = true ; bool start_lru_crawler = true ; bool start_assoc_maint = true ; enum hashfunc_type hash_type = MURMUR3_HASH ; uint32_t tocrawl ; uint32_t slab_sizes [ MAX_NUMBER_OF_SLAB_CLASSES ] ; bool use_slab_sizes = false ; char * slab_sizes_unparsed = NULL ; bool slab_chunk_size_changed = false ; # ifdef EXTSTORE void * storage = NULL ; char * storage_file = NULL ; struct extstore_conf ext_cf ; # endif char * subopts , * subopts_orig ; char * subopts_value ; enum { MAXCONNS_FAST = 0 , HASHPOWER_INIT , NO_HASHEXPAND , SLAB_REASSIGN , SLAB_AUTOMOVE , SLAB_AUTOMOVE_RATIO , SLAB_AUTOMOVE_WINDOW , TAIL_REPAIR_TIME , HASH_ALGORITHM , LRU_CRAWLER , LRU_CRAWLER_SLEEP , LRU_CRAWLER_TOCRAWL , LRU_MAINTAINER , HOT_LRU_PCT , WARM_LRU_PCT , HOT_MAX_FACTOR , WARM_MAX_FACTOR , TEMPORARY_TTL , IDLE_TIMEOUT , WATCHER_LOGBUF_SIZE , WORKER_LOGBUF_SIZE , SLAB_SIZES , SLAB_CHUNK_MAX , TRACK_SIZES , NO_INLINE_ASCII_RESP , MODERN , NO_MODERN , NO_CHUNKED_ITEMS , NO_SLAB_REASSIGN , NO_SLAB_AUTOMOVE , NO_MAXCONNS_FAST , INLINE_ASCII_RESP , NO_LRU_CRAWLER , NO_LRU_MAINTAINER , NO_DROP_PRIVILEGES , # ifdef MEMCACHED_DEBUG RELAXED_PRIVILEGES , # endif # ifdef EXTSTORE EXT_PAGE_SIZE , EXT_PAGE_COUNT , EXT_WBUF_SIZE , EXT_THREADS , EXT_IO_DEPTH , EXT_PATH , EXT_ITEM_SIZE , EXT_ITEM_AGE , EXT_LOW_TTL , EXT_RECACHE_RATE , EXT_COMPACT_UNDER , EXT_DROP_UNDER , EXT_MAX_FRAG , EXT_DROP_UNREAD , SLAB_AUTOMOVE_FREERATIO , # endif } ; char * const subopts_tokens [ ] = { [ MAXCONNS_FAST ] = ""maxconns_fast"" , [ HASHPOWER_INIT ] = ""hashpower"" , [ NO_HASHEXPAND ] = ""no_hashexpand"" , [ SLAB_REASSIGN ] = ""slab_reassign"" , [ SLAB_AUTOMOVE ] = ""slab_automove"" , [ SLAB_AUTOMOVE_RATIO ] = ""slab_automove_ratio"" , [ SLAB_AUTOMOVE_WINDOW ] = ""slab_automove_window"" , [ TAIL_REPAIR_TIME ] = ""tail_repair_time"" , [ HASH_ALGORITHM ] = ""hash_algorithm"" , [ LRU_CRAWLER ] = ""lru_crawler"" , [ LRU_CRAWLER_SLEEP ] = ""lru_crawler_sleep"" , [ LRU_CRAWLER_TOCRAWL ] = ""lru_crawler_tocrawl"" , [ LRU_MAINTAINER ] = ""lru_maintainer"" , [ HOT_LRU_PCT ] = ""hot_lru_pct"" , [ WARM_LRU_PCT ] = ""warm_lru_pct"" , [ HOT_MAX_FACTOR ] = ""hot_max_factor"" , [ WARM_MAX_FACTOR ] = ""warm_max_factor"" , [ TEMPORARY_TTL ] = ""temporary_ttl"" , [ IDLE_TIMEOUT ] = ""idle_timeout"" , [ WATCHER_LOGBUF_SIZE ] = ""watcher_logbuf_size"" , [ WORKER_LOGBUF_SIZE ] = ""worker_logbuf_size"" , [ SLAB_SIZES ] = ""slab_sizes"" , [ SLAB_CHUNK_MAX ] = ""slab_chunk_max"" , [ TRACK_SIZES ] = ""track_sizes"" , [ NO_INLINE_ASCII_RESP ] = ""no_inline_ascii_resp"" , [ MODERN ] = ""modern"" , [ NO_MODERN ] = ""no_modern"" , [ NO_CHUNKED_ITEMS ] = ""no_chunked_items"" , [ NO_SLAB_REASSIGN ] = ""no_slab_reassign"" , [ NO_SLAB_AUTOMOVE ] = ""no_slab_automove"" , [ NO_MAXCONNS_FAST ] = ""no_maxconns_fast"" , [ INLINE_ASCII_RESP ] = ""inline_ascii_resp"" , [ NO_LRU_CRAWLER ] = ""no_lru_crawler"" , [ NO_LRU_MAINTAINER ] = ""no_lru_maintainer"" , [ NO_DROP_PRIVILEGES ] = ""no_drop_privileges"" , # ifdef MEMCACHED_DEBUG [ RELAXED_PRIVILEGES ] = ""relaxed_privileges"" , # endif # ifdef EXTSTORE [ EXT_PAGE_SIZE ] = ""ext_page_size"" , [ EXT_PAGE_COUNT ] = ""ext_page_count"" , [ EXT_WBUF_SIZE ] = ""ext_wbuf_size"" , [ EXT_THREADS ] = ""ext_threads"" , [ EXT_IO_DEPTH ] = ""ext_io_depth"" , [ EXT_PATH ] = ""ext_path"" , [ EXT_ITEM_SIZE ] = ""ext_item_size"" , [ EXT_ITEM_AGE ] = ""ext_item_age"" , [ EXT_LOW_TTL ] = ""ext_low_ttl"" , [ EXT_RECACHE_RATE ] = ""ext_recache_rate"" , [ EXT_COMPACT_UNDER ] = ""ext_compact_under"" , [ EXT_DROP_UNDER ] = ""ext_drop_under"" , [ EXT_MAX_FRAG ] = ""ext_max_frag"" , [ EXT_DROP_UNREAD ] = ""ext_drop_unread"" , [ SLAB_AUTOMOVE_FREERATIO ] = ""slab_automove_freeratio"" , # endif NULL } ; if ( ! sanitycheck ( ) ) { return EX_OSERR ; } signal ( SIGINT , sig_handler ) ; signal ( SIGTERM , sig_handler ) ; settings_init ( ) ; # ifdef EXTSTORE settings . ext_item_size = 512 ; settings . ext_item_age = UINT_MAX ; settings . ext_low_ttl = 0 ; settings . ext_recache_rate = 2000 ; settings . ext_max_frag = 0.8 ; settings . ext_drop_unread = false ; settings . ext_wbuf_size = 1024 * 1024 * 4 ; settings . ext_compact_under = 0 ; settings . ext_drop_under = 0 ; settings . slab_automove_freeratio = 0.01 ; ext_cf . page_size = 1024 * 1024 * 64 ; ext_cf . page_count = 64 ; ext_cf . wbuf_size = settings . ext_wbuf_size ; ext_cf . io_threadcount = 1 ; ext_cf . io_depth = 1 ; ext_cf . page_buckets = 4 ; ext_cf . wbuf_count = ext_cf . page_buckets ; # endif init_lru_maintainer ( ) ; setbuf ( stderr , NULL ) ; char * shortopts = ""a:"" ""A"" ""p:"" ""s:"" ""U:"" ""m:"" ""M"" ""c:"" ""k"" ""hiV"" ""r"" ""v"" ""d"" ""l:"" ""u:"" ""P:"" ""f:"" ""n:"" ""t:"" ""D:"" ""L"" ""R:"" ""C"" ""b:"" ""B:"" ""I:"" ""S"" ""F"" ""X"" ""o:"" ; # ifdef HAVE_GETOPT_LONG const struct option longopts [ ] = { { ""unix-mask"" , required_argument , 0 , 'a' } , { ""enable-shutdown"" , no_argument , 0 , 'A' } , { ""port"" , required_argument , 0 , 'p' } , { ""unix-socket"" , required_argument , 0 , 's' } , { ""udp-port"" , required_argument , 0 , 'U' } , { ""memory-limit"" , required_argument , 0 , 'm' } , { ""disable-evictions"" , no_argument , 0 , 'M' } , { ""conn-limit"" , required_argument , 0 , 'c' } , { ""lock-memory"" , no_argument , 0 , 'k' } , { ""help"" , no_argument , 0 , 'h' } , { ""license"" , no_argument , 0 , 'i' } , { ""version"" , no_argument , 0 , 'V' } , { ""enable-coredumps"" , no_argument , 0 , 'r' } , { ""verbose"" , optional_argument , 0 , 'v' } , { ""daemon"" , no_argument , 0 , 'd' } , { ""listen"" , required_argument , 0 , 'l' } , { ""user"" , required_argument , 0 , 'u' } , { ""pidfile"" , required_argument , 0 , 'P' } , { ""slab-growth-factor"" , required_argument , 0 , 'f' } , { ""slab-min-size"" , required_argument , 0 , 'n' } , { ""threads"" , required_argument , 0 , 't' } , { ""enable-largepages"" , no_argument , 0 , 'L' } , { ""max-reqs-per-event"" , required_argument , 0 , 'R' } , { ""disable-cas"" , no_argument , 0 , 'C' } , { ""listen-backlog"" , required_argument , 0 , 'b' } , { ""protocol"" , required_argument , 0 , 'B' } , { ""max-item-size"" , required_argument , 0 , 'I' } , { ""enable-sasl"" , no_argument , 0 , 'S' } , { ""disable-flush-all"" , no_argument , 0 , 'F' } , { ""disable-dumping"" , no_argument , 0 , 'X' } , { ""extended"" , required_argument , 0 , 'o' } , { 0 , 0 , 0 , 0 } } ; int optindex ; while ( - 1 != ( c = getopt_long ( argc , argv , shortopts , longopts , & optindex ) ) ) { # else while ( - 1 != ( c = getopt ( argc , argv , shortopts ) ) ) { # endif switch ( c ) { case 'A' : settings . shutdown_command = true ; break ; case 'a' : settings . access = strtol ( optarg , NULL , 8 ) ; break ; case 'U' : settings . udpport = atoi ( optarg ) ; udp_specified = true ; break ; case 'p' : settings . port = atoi ( optarg ) ; tcp_specified = true ; break ; case 's' : settings . socketpath = optarg ; break ; case 'm' : settings . maxbytes = ( ( size_t ) atoi ( optarg ) ) * 1024 * 1024 ; break ; case 'M' : settings . evict_to_free = 0 ; break ; case 'c' : settings . maxconns = atoi ( optarg ) ; if ( settings . maxconns <= 0 ) { fprintf ( stderr , ""Maximum<S2SV_blank>connections<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n"" ) ; return 1 ; } break ; case 'h' : usage ( ) ; exit ( EXIT_SUCCESS ) ; case 'i' : usage_license ( ) ; exit ( EXIT_SUCCESS ) ; case 'V' : printf ( PACKAGE ""<S2SV_blank>"" VERSION ""\\n"" ) ; exit ( EXIT_SUCCESS ) ; case 'k' : lock_memory = true ; break ; case 'v' : settings . verbose ++ ; break ; case 'l' : if ( settings . inter != NULL ) { if ( strstr ( settings . inter , optarg ) != NULL ) { break ; } size_t len = strlen ( settings . inter ) + strlen ( optarg ) + 2 ; char * p = malloc ( len ) ; if ( p == NULL ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory\\n"" ) ; return 1 ; } snprintf ( p , len , ""%s,%s"" , settings . inter , optarg ) ; free ( settings . inter ) ; settings . inter = p ; } else { settings . inter = strdup ( optarg ) ; } break ; case 'd' : do_daemonize = true ; break ; case 'r' : maxcore = 1 ; break ; case 'R' : settings . reqs_per_event = atoi ( optarg ) ; if ( settings . reqs_per_event == 0 ) { fprintf ( stderr , ""Number<S2SV_blank>of<S2SV_blank>requests<S2SV_blank>per<S2SV_blank>event<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n"" ) ; return 1 ; } break ; case 'u' : username = optarg ; break ; case 'P' : pid_file = optarg ; break ; case 'f' : settings . factor = atof ( optarg ) ; if ( settings . factor <= 1.0 ) { fprintf ( stderr , ""Factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>1\\n"" ) ; return 1 ; } break ; case 'n' : settings . chunk_size = atoi ( optarg ) ; if ( settings . chunk_size == 0 ) { fprintf ( stderr , ""Chunk<S2SV_blank>size<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n"" ) ; return 1 ; } break ; case 't' : settings . num_threads = atoi ( optarg ) ; if ( settings . num_threads <= 0 ) { fprintf ( stderr , ""Number<S2SV_blank>of<S2SV_blank>threads<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n"" ) ; return 1 ; } if ( settings . num_threads > 64 ) { fprintf ( stderr , ""WARNING:<S2SV_blank>Setting<S2SV_blank>a<S2SV_blank>high<S2SV_blank>number<S2SV_blank>of<S2SV_blank>worker"" ""threads<S2SV_blank>is<S2SV_blank>not<S2SV_blank>recommended.\\n"" ""<S2SV_blank>Set<S2SV_blank>this<S2SV_blank>value<S2SV_blank>to<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>cores<S2SV_blank>in"" ""<S2SV_blank>your<S2SV_blank>machine<S2SV_blank>or<S2SV_blank>less.\\n"" ) ; } break ; case 'D' : if ( ! optarg || ! optarg [ 0 ] ) { fprintf ( stderr , ""No<S2SV_blank>delimiter<S2SV_blank>specified\\n"" ) ; return 1 ; } settings . prefix_delimiter = optarg [ 0 ] ; settings . detail_enabled = 1 ; break ; case 'L' : if ( enable_large_pages ( ) == 0 ) { preallocate = true ; } else { fprintf ( stderr , ""Cannot<S2SV_blank>enable<S2SV_blank>large<S2SV_blank>pages<S2SV_blank>on<S2SV_blank>this<S2SV_blank>system\\n"" ""(There<S2SV_blank>is<S2SV_blank>no<S2SV_blank>Linux<S2SV_blank>support<S2SV_blank>as<S2SV_blank>of<S2SV_blank>this<S2SV_blank>version)\\n"" ) ; return 1 ; } break ; case 'C' : settings . use_cas = false ; break ; case 'b' : settings . backlog = atoi ( optarg ) ; break ; case 'B' : protocol_specified = true ; if ( strcmp ( optarg , ""auto"" ) == 0 ) { settings . binding_protocol = negotiating_prot ; } else if ( strcmp ( optarg , ""binary"" ) == 0 ) { settings . binding_protocol = binary_prot ; } else if ( strcmp ( optarg , ""ascii"" ) == 0 ) { settings . binding_protocol = ascii_prot ; } else { fprintf ( stderr , ""Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>binding<S2SV_blank>protocol:<S2SV_blank>%s\\n"" ""<S2SV_blank>--<S2SV_blank>should<S2SV_blank>be<S2SV_blank>one<S2SV_blank>of<S2SV_blank>auto,<S2SV_blank>binary,<S2SV_blank>or<S2SV_blank>ascii\\n"" , optarg ) ; exit ( EX_USAGE ) ; } break ; case 'I' : buf = strdup ( optarg ) ; unit = buf [ strlen ( buf ) - 1 ] ; if ( unit == 'k' || unit == 'm' || unit == 'K' || unit == 'M' ) { buf [ strlen ( buf ) - 1 ] = '\\0' ; size_max = atoi ( buf ) ; if ( unit == 'k' || unit == 'K' ) size_max *= 1024 ; if ( unit == 'm' || unit == 'M' ) size_max *= 1024 * 1024 ; settings . item_size_max = size_max ; } else { settings . item_size_max = atoi ( buf ) ; } free ( buf ) ; break ; case 'S' : # ifndef ENABLE_SASL fprintf ( stderr , ""This<S2SV_blank>server<S2SV_blank>is<S2SV_blank>not<S2SV_blank>built<S2SV_blank>with<S2SV_blank>SASL<S2SV_blank>support.\\n"" ) ; exit ( EX_USAGE ) ; # endif settings . sasl = true ; break ; case 'F' : settings . flush_enabled = false ; break ; case 'X' : settings . dump_enabled = false ; break ; case 'o' : subopts_orig = subopts = strdup ( optarg ) ; while ( * subopts != '\\0' ) { switch ( getsubopt ( & subopts , subopts_tokens , & subopts_value ) ) { case MAXCONNS_FAST : settings . maxconns_fast = true ; break ; case HASHPOWER_INIT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>hashpower\\n"" ) ; return 1 ; } settings . hashpower_init = atoi ( subopts_value ) ; if ( settings . hashpower_init < 12 ) { fprintf ( stderr , ""Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low\\n"" , settings . hashpower_init ) ; return 1 ; } else if ( settings . hashpower_init > 32 ) { fprintf ( stderr , ""Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>high\\n"" ""Choose<S2SV_blank>a<S2SV_blank>value<S2SV_blank>based<S2SV_blank>on<S2SV_blank>\\""STAT<S2SV_blank>hash_power_level\\""<S2SV_blank>from<S2SV_blank>a<S2SV_blank>running<S2SV_blank>instance\\n"" , settings . hashpower_init ) ; return 1 ; } break ; case NO_HASHEXPAND : start_assoc_maint = false ; break ; case SLAB_REASSIGN : settings . slab_reassign = true ; break ; case SLAB_AUTOMOVE : if ( subopts_value == NULL ) { settings . slab_automove = 1 ; break ; } settings . slab_automove = atoi ( subopts_value ) ; if ( settings . slab_automove < 0 || settings . slab_automove > 2 ) { fprintf ( stderr , ""slab_automove<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>2\\n"" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_RATIO : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_ratio<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . slab_automove_ratio = atof ( subopts_value ) ; if ( settings . slab_automove_ratio <= 0 || settings . slab_automove_ratio > 1 ) { fprintf ( stderr , ""slab_automove_ratio<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0<S2SV_blank>and<S2SV_blank><<S2SV_blank>1\\n"" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_WINDOW : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_window<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . slab_automove_window = atoi ( subopts_value ) ; if ( settings . slab_automove_window < 3 ) { fprintf ( stderr , ""slab_automove_window<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>2\\n"" ) ; return 1 ; } break ; case TAIL_REPAIR_TIME : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>tail_repair_time\\n"" ) ; return 1 ; } settings . tail_repair_time = atoi ( subopts_value ) ; if ( settings . tail_repair_time < 10 ) { fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>tail_repair_time<S2SV_blank>to<S2SV_blank>less<S2SV_blank>than<S2SV_blank>10<S2SV_blank>seconds\\n"" ) ; return 1 ; } break ; case HASH_ALGORITHM : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>hash_algorithm<S2SV_blank>argument\\n"" ) ; return 1 ; } ; if ( strcmp ( subopts_value , ""jenkins"" ) == 0 ) { hash_type = JENKINS_HASH ; } else if ( strcmp ( subopts_value , ""murmur3"" ) == 0 ) { hash_type = MURMUR3_HASH ; } else { fprintf ( stderr , ""Unknown<S2SV_blank>hash_algorithm<S2SV_blank>option<S2SV_blank>(jenkins,<S2SV_blank>murmur3)\\n"" ) ; return 1 ; } break ; case LRU_CRAWLER : start_lru_crawler = true ; break ; case LRU_CRAWLER_SLEEP : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>lru_crawler_sleep<S2SV_blank>value\\n"" ) ; return 1 ; } settings . lru_crawler_sleep = atoi ( subopts_value ) ; if ( settings . lru_crawler_sleep > 1000000 || settings . lru_crawler_sleep < 0 ) { fprintf ( stderr , ""LRU<S2SV_blank>crawler<S2SV_blank>sleep<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>1<S2SV_blank>second\\n"" ) ; return 1 ; } break ; case LRU_CRAWLER_TOCRAWL : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>lru_crawler_tocrawl<S2SV_blank>value\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & tocrawl ) ) { fprintf ( stderr , ""lru_crawler_tocrawl<S2SV_blank>takes<S2SV_blank>a<S2SV_blank>numeric<S2SV_blank>32bit<S2SV_blank>value\\n"" ) ; return 1 ; } settings . lru_crawler_tocrawl = tocrawl ; break ; case LRU_MAINTAINER : start_lru_maintainer = true ; settings . lru_segmented = true ; break ; case HOT_LRU_PCT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>hot_lru_pct<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . hot_lru_pct = atoi ( subopts_value ) ; if ( settings . hot_lru_pct < 1 || settings . hot_lru_pct >= 80 ) { fprintf ( stderr , ""hot_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\n"" ) ; return 1 ; } break ; case WARM_LRU_PCT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>warm_lru_pct<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . warm_lru_pct = atoi ( subopts_value ) ; if ( settings . warm_lru_pct < 1 || settings . warm_lru_pct >= 80 ) { fprintf ( stderr , ""warm_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\n"" ) ; return 1 ; } break ; case HOT_MAX_FACTOR : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>hot_max_factor<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . hot_max_factor = atof ( subopts_value ) ; if ( settings . hot_max_factor <= 0 ) { fprintf ( stderr , ""hot_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\n"" ) ; return 1 ; } break ; case WARM_MAX_FACTOR : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>warm_max_factor<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . warm_max_factor = atof ( subopts_value ) ; if ( settings . warm_max_factor <= 0 ) { fprintf ( stderr , ""warm_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\n"" ) ; return 1 ; } break ; case TEMPORARY_TTL : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>temporary_ttl<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . temp_lru = true ; settings . temporary_ttl = atoi ( subopts_value ) ; break ; case IDLE_TIMEOUT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>idle_timeout\\n"" ) ; return 1 ; } settings . idle_timeout = atoi ( subopts_value ) ; break ; case WATCHER_LOGBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>watcher_logbuf_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . logger_watcher_buf_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>watcher_logbuf_size\\n"" ) ; return 1 ; } settings . logger_watcher_buf_size *= 1024 ; break ; case WORKER_LOGBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>worker_logbuf_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . logger_buf_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>worker_logbuf_size\\n"" ) ; return 1 ; } settings . logger_buf_size *= 1024 ; case SLAB_SIZES : slab_sizes_unparsed = subopts_value ; break ; case SLAB_CHUNK_MAX : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>slab_chunk_max<S2SV_blank>argument\\n"" ) ; } if ( ! safe_strtol ( subopts_value , & settings . slab_chunk_size_max ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_chunk_max\\n"" ) ; } slab_chunk_size_changed = true ; break ; case TRACK_SIZES : item_stats_sizes_init ( ) ; break ; case NO_INLINE_ASCII_RESP : settings . inline_ascii_response = false ; break ; case INLINE_ASCII_RESP : settings . inline_ascii_response = true ; break ; case NO_CHUNKED_ITEMS : settings . slab_chunk_size_max = settings . slab_page_size ; break ; case NO_SLAB_REASSIGN : settings . slab_reassign = false ; break ; case NO_SLAB_AUTOMOVE : settings . slab_automove = 0 ; break ; case NO_MAXCONNS_FAST : settings . maxconns_fast = false ; break ; case NO_LRU_CRAWLER : settings . lru_crawler = false ; start_lru_crawler = false ; break ; case NO_LRU_MAINTAINER : start_lru_maintainer = false ; settings . lru_segmented = false ; break ; # ifdef EXTSTORE case EXT_PAGE_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_page_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . page_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_size\\n"" ) ; return 1 ; } ext_cf . page_size *= 1024 * 1024 ; break ; case EXT_PAGE_COUNT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_page_count<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . page_count ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_count\\n"" ) ; return 1 ; } break ; case EXT_WBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_wbuf_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . wbuf_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_wbuf_size\\n"" ) ; return 1 ; } ext_cf . wbuf_size *= 1024 * 1024 ; settings . ext_wbuf_size = ext_cf . wbuf_size ; break ; case EXT_THREADS : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_threads<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . io_threadcount ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_threads\\n"" ) ; return 1 ; } break ; case EXT_IO_DEPTH : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_io_depth<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . io_depth ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_io_depth\\n"" ) ; return 1 ; } break ; case EXT_ITEM_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_item_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_item_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_size\\n"" ) ; return 1 ; } break ; case EXT_ITEM_AGE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_item_age<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_item_age ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_age\\n"" ) ; return 1 ; } break ; case EXT_LOW_TTL : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_low_ttl<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_low_ttl ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_low_ttl\\n"" ) ; return 1 ; } break ; case EXT_RECACHE_RATE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_recache_rate<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_recache_rate ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_recache_rate\\n"" ) ; return 1 ; } break ; case EXT_COMPACT_UNDER : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_compact_under<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_compact_under ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_compact_under\\n"" ) ; return 1 ; } break ; case EXT_DROP_UNDER : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_drop_under<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_drop_under ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_drop_under\\n"" ) ; return 1 ; } break ; case EXT_MAX_FRAG : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_max_frag<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtod ( subopts_value , & settings . ext_max_frag ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_max_frag\\n"" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_FREERATIO : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_freeratio<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtod ( subopts_value , & settings . slab_automove_freeratio ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_automove_freeratio\\n"" ) ; return 1 ; } break ; case EXT_DROP_UNREAD : settings . ext_drop_unread = true ; break ; case EXT_PATH : storage_file = strdup ( subopts_value ) ; break ; # endif case MODERN : break ; case NO_MODERN : if ( ! slab_chunk_size_changed ) { settings . slab_chunk_size_max = settings . slab_page_size ; } settings . slab_reassign = false ; settings . slab_automove = 0 ; settings . maxconns_fast = false ; settings . inline_ascii_response = true ; settings . lru_segmented = false ; hash_type = JENKINS_HASH ; start_lru_crawler = false ; start_lru_maintainer = false ; break ; case NO_DROP_PRIVILEGES : settings . drop_privileges = false ; break ; # ifdef MEMCACHED_DEBUG case RELAXED_PRIVILEGES : settings . relaxed_privileges = true ; break ; # endif default : printf ( ""Illegal<S2SV_blank>suboption<S2SV_blank>\\""%s\\""\\n"" , subopts_value ) ; return 1 ; } } free ( subopts_orig ) ; break ; default : fprintf ( stderr , ""Illegal<S2SV_blank>argument<S2SV_blank>\\""%c\\""\\n"" , c ) ; return 1 ; } } if ( settings . item_size_max < 1024 ) { fprintf ( stderr , ""Item<S2SV_blank>max<S2SV_blank>size<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>1024<S2SV_blank>bytes.\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > ( settings . maxbytes / 2 ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>1/2<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>max.\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > ( 1024 * 1024 * 1024 ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>a<S2SV_blank>gigabyte.\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > 1024 * 1024 ) { if ( ! slab_chunk_size_changed ) { settings . slab_chunk_size_max = settings . slab_page_size / 2 ; } } if ( settings . slab_chunk_size_max > settings . item_size_max ) { fprintf ( stderr , ""slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>-I<S2SV_blank>(item_size_max<S2SV_blank>%d)\\n"" , settings . slab_chunk_size_max , settings . item_size_max ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max % settings . slab_chunk_size_max != 0 ) { fprintf ( stderr , ""-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>be<S2SV_blank>evenly<S2SV_blank>divisible<S2SV_blank>by<S2SV_blank>slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)\\n"" , settings . item_size_max , settings . slab_chunk_size_max ) ; exit ( EX_USAGE ) ; } if ( settings . slab_page_size % settings . slab_chunk_size_max != 0 ) { fprintf ( stderr , ""slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>divide<S2SV_blank>evenly<S2SV_blank>into<S2SV_blank>%d<S2SV_blank>(slab_page_size)\\n"" , settings . slab_chunk_size_max , settings . slab_page_size ) ; exit ( EX_USAGE ) ; } # ifdef EXTSTORE if ( storage_file ) { if ( settings . item_size_max > ext_cf . wbuf_size ) { fprintf ( stderr , ""-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>ext_wbuf_size:<S2SV_blank>%d\\n"" , settings . item_size_max , ext_cf . wbuf_size ) ; exit ( EX_USAGE ) ; } if ( settings . inline_ascii_response ) { fprintf ( stderr , ""Cannot<S2SV_blank>use<S2SV_blank>inline_ascii_response<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . udpport ) { fprintf ( stderr , ""Cannot<S2SV_blank>use<S2SV_blank>UDP<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled<S2SV_blank>(-U<S2SV_blank>0<S2SV_blank>to<S2SV_blank>disable)\\n"" ) ; exit ( EX_USAGE ) ; } } # endif if ( slab_sizes_unparsed != NULL ) { if ( _parse_slab_sizes ( slab_sizes_unparsed , slab_sizes ) ) { use_slab_sizes = true ; } else { exit ( EX_USAGE ) ; } } if ( settings . hot_lru_pct + settings . warm_lru_pct > 80 ) { fprintf ( stderr , ""hot_lru_pct<S2SV_blank>+<S2SV_blank>warm_lru_pct<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>more<S2SV_blank>than<S2SV_blank>80%%<S2SV_blank>combined\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . temp_lru && ! start_lru_maintainer ) { fprintf ( stderr , ""temporary_ttl<S2SV_blank>requires<S2SV_blank>lru_maintainer<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled\\n"" ) ; exit ( EX_USAGE ) ; } if ( hash_init ( hash_type ) != 0 ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>hash_algorithm!\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . inter != NULL && strchr ( settings . inter , ',' ) ) { settings . num_threads_per_udp = 1 ; } else { settings . num_threads_per_udp = settings . num_threads ; } if ( settings . sasl ) { if ( ! protocol_specified ) { settings . binding_protocol = binary_prot ; } else { if ( settings . binding_protocol != binary_prot ) { fprintf ( stderr , ""ERROR:<S2SV_blank>You<S2SV_blank>cannot<S2SV_blank>allow<S2SV_blank>the<S2SV_blank>ASCII<S2SV_blank>protocol<S2SV_blank>while<S2SV_blank>using<S2SV_blank>SASL.\\n"" ) ; exit ( EX_USAGE ) ; } } } <S2SV_StartBug> if ( tcp_specified && settings . port != 0 && ! udp_specified ) { <S2SV_EndBug> settings . udpport = settings . port ; } else if ( udp_specified && settings . udpport != 0 && ! tcp_specified ) { settings . port = settings . udpport ; } if ( maxcore != 0 ) { struct rlimit rlim_new ; if ( getrlimit ( RLIMIT_CORE , & rlim ) == 0 ) { rlim_new . rlim_cur = rlim_new . rlim_max = RLIM_INFINITY ; if ( setrlimit ( RLIMIT_CORE , & rlim_new ) != 0 ) { rlim_new . rlim_cur = rlim_new . rlim_max = rlim . rlim_max ; ( void ) setrlimit ( RLIMIT_CORE , & rlim_new ) ; } } if ( ( getrlimit ( RLIMIT_CORE , & rlim ) != 0 ) || rlim . rlim_cur == 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>ensure<S2SV_blank>corefile<S2SV_blank>creation\\n"" ) ; exit ( EX_OSERR ) ; } } if ( getrlimit ( RLIMIT_NOFILE , & rlim ) != 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>getrlimit<S2SV_blank>number<S2SV_blank>of<S2SV_blank>files\\n"" ) ; exit ( EX_OSERR ) ; } else { rlim . rlim_cur = settings . maxconns ; rlim . rlim_max = settings . maxconns ; if ( setrlimit ( RLIMIT_NOFILE , & rlim ) != 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>rlimit<S2SV_blank>for<S2SV_blank>open<S2SV_blank>files.<S2SV_blank>Try<S2SV_blank>starting<S2SV_blank>as<S2SV_blank>root<S2SV_blank>or<S2SV_blank>requesting<S2SV_blank>smaller<S2SV_blank>maxconns<S2SV_blank>value.\\n"" ) ; exit ( EX_OSERR ) ; } } if ( getuid ( ) == 0 || geteuid ( ) == 0 ) { if ( username == 0 || * username == '\\0' ) { fprintf ( stderr , ""can\'t<S2SV_blank>run<S2SV_blank>as<S2SV_blank>root<S2SV_blank>without<S2SV_blank>the<S2SV_blank>-u<S2SV_blank>switch\\n"" ) ; exit ( EX_USAGE ) ; } if ( ( pw = getpwnam ( username ) ) == 0 ) { fprintf ( stderr , ""can\'t<S2SV_blank>find<S2SV_blank>the<S2SV_blank>user<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>to\\n"" , username ) ; exit ( EX_NOUSER ) ; } if ( setgid ( pw -> pw_gid ) < 0 || setuid ( pw -> pw_uid ) < 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>assume<S2SV_blank>identity<S2SV_blank>of<S2SV_blank>user<S2SV_blank>%s\\n"" , username ) ; exit ( EX_OSERR ) ; } } if ( settings . sasl ) { init_sasl ( ) ; } if ( do_daemonize ) { if ( sigignore ( SIGHUP ) == - 1 ) { perror ( ""Failed<S2SV_blank>to<S2SV_blank>ignore<S2SV_blank>SIGHUP"" ) ; } if ( daemonize ( maxcore , settings . verbose ) == - 1 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>daemon()<S2SV_blank>in<S2SV_blank>order<S2SV_blank>to<S2SV_blank>daemonize\\n"" ) ; exit ( EXIT_FAILURE ) ; } } if ( lock_memory ) { # ifdef HAVE_MLOCKALL int res = mlockall ( MCL_CURRENT | MCL_FUTURE ) ; if ( res != 0 ) { fprintf ( stderr , ""warning:<S2SV_blank>-k<S2SV_blank>invalid,<S2SV_blank>mlockall()<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; } # else fprintf ( stderr , ""warning:<S2SV_blank>-k<S2SV_blank>invalid,<S2SV_blank>mlockall()<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>on<S2SV_blank>this<S2SV_blank>platform.<S2SV_blank><S2SV_blank>proceeding<S2SV_blank>without.\\n"" ) ; # endif } # if defined ( LIBEVENT_VERSION_NUMBER ) && LIBEVENT_VERSION_NUMBER >= 0x02000101 struct event_config * ev_config ; ev_config = event_config_new ( ) ; event_config_set_flag ( ev_config , EVENT_BASE_FLAG_NOLOCK ) ; main_base = event_base_new_with_config ( ev_config ) ; event_config_free ( ev_config ) ; # else main_base = event_init ( ) ; # endif logger_init ( ) ; stats_init ( ) ; assoc_init ( settings . hashpower_init ) ; conn_init ( ) ; slabs_init ( settings . maxbytes , settings . factor , preallocate , use_slab_sizes ? slab_sizes : NULL ) ; # ifdef EXTSTORE if ( storage_file ) { enum extstore_res eres ; if ( settings . ext_compact_under == 0 ) { settings . ext_compact_under = ext_cf . page_count / 4 ; settings . ext_drop_under = ext_cf . page_count / 4 ; } crc32c_init ( ) ; for ( int x = 0 ; x < MAX_NUMBER_OF_SLAB_CLASSES ; x ++ ) { settings . ext_free_memchunks [ x ] = 0 ; } storage = extstore_init ( storage_file , & ext_cf , & eres ) ; if ( storage == NULL ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>external<S2SV_blank>storage:<S2SV_blank>%s\\n"" , extstore_err ( eres ) ) ; if ( eres == EXTSTORE_INIT_OPEN_FAIL ) { perror ( ""extstore<S2SV_blank>open"" ) ; } exit ( EXIT_FAILURE ) ; } ext_storage = storage ; slabs_prefill_global ( ) ; } # endif if ( sigignore ( SIGPIPE ) == - 1 ) { perror ( ""failed<S2SV_blank>to<S2SV_blank>ignore<S2SV_blank>SIGPIPE;<S2SV_blank>sigaction"" ) ; exit ( EX_OSERR ) ; } # ifdef EXTSTORE slabs_set_storage ( storage ) ; memcached_thread_init ( settings . num_threads , storage ) ; init_lru_crawler ( storage ) ; # else memcached_thread_init ( settings . num_threads , NULL ) ; init_lru_crawler ( NULL ) ; # endif if ( start_assoc_maint && start_assoc_maintenance_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } if ( start_lru_crawler && start_item_crawler_thread ( ) != 0 ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>LRU<S2SV_blank>crawler<S2SV_blank>thread\\n"" ) ; exit ( EXIT_FAILURE ) ; } # ifdef EXTSTORE if ( storage && start_storage_compact_thread ( storage ) != 0 ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>start<S2SV_blank>storage<S2SV_blank>compaction<S2SV_blank>thread\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( start_lru_maintainer && start_lru_maintainer_thread ( storage ) != 0 ) { # else if ( start_lru_maintainer && start_lru_maintainer_thread ( NULL ) != 0 ) { # endif fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>LRU<S2SV_blank>maintainer<S2SV_blank>thread\\n"" ) ; return 1 ; } if ( settings . slab_reassign && start_slab_maintenance_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } if ( settings . idle_timeout && start_conn_timeout_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } clock_handler ( 0 , 0 , 0 ) ; if ( settings . socketpath != NULL ) { errno = 0 ; if ( server_socket_unix ( settings . socketpath , settings . access ) ) { vperror ( ""failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>UNIX<S2SV_blank>socket:<S2SV_blank>%s"" , settings . socketpath ) ; exit ( EX_OSERR ) ; } } if ( settings . socketpath == NULL ) { const char * portnumber_filename = getenv ( ""MEMCACHED_PORT_FILENAME"" ) ; char * temp_portnumber_filename = NULL ; size_t len ; FILE * portnumber_file = NULL ; if ( portnumber_filename != NULL ) { len = strlen ( portnumber_filename ) + 4 + 1 ; temp_portnumber_filename = malloc ( len ) ; snprintf ( temp_portnumber_filename , len , ""%s.lck"" , portnumber_filename ) ; portnumber_file = fopen ( temp_portnumber_filename , ""a"" ) ; if ( portnumber_file == NULL ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>\\""%s\\"":<S2SV_blank>%s\\n"" , temp_portnumber_filename , strerror ( errno ) ) ; } } errno = 0 ; if ( settings . port && server_sockets ( settings . port , tcp_transport , portnumber_file ) ) { vperror ( ""failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>TCP<S2SV_blank>port<S2SV_blank>%d"" , settings . port ) ; exit ( EX_OSERR ) ; } errno = 0 ; if ( settings . udpport && server_sockets ( settings . udpport , udp_transport , portnumber_file ) ) { vperror ( ""failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>UDP<S2SV_blank>port<S2SV_blank>%d"" , settings . udpport ) ; exit ( EX_OSERR ) ; } if ( portnumber_file ) { fclose ( portnumber_file ) ; rename ( temp_portnumber_filename , portnumber_filename ) ; } if ( temp_portnumber_filename ) free ( temp_portnumber_filename ) ; } usleep ( 1000 ) ; if ( stats_state . curr_conns + stats_state . reserved_fds >= settings . maxconns - 1 ) { fprintf ( stderr , ""Maxconns<S2SV_blank>setting<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low,<S2SV_blank>use<S2SV_blank>-c<S2SV_blank>to<S2SV_blank>increase.\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( pid_file != NULL ) { save_pid ( pid_file ) ; } if ( settings . drop_privileges ) { drop_privileges ( ) ; } uriencode_init ( ) ; if ( event_base_loop ( main_base , 0 ) != 0 ) { retval = EXIT_FAILURE ; } stop_assoc_maintenance_thread ( ) ; if ( do_daemonize ) remove_pidfile ( pid_file ) ; if ( settings . inter ) free ( settings . inter ) ; if ( l_socket ) free ( l_socket ) ; if ( u_socket ) free ( u_socket ) ; event_base_free ( main_base ) ; return retval ; }
","<S2SV_ModStart> } if ( <S2SV_ModEnd> udp_specified && settings
"
223,"CWE-125 INST_HANDLER ( sbrx ) { int b = buf [ 0 ] & 0x7 ; int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x01 ) << 4 ) ; <S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( ""%d,1,<<,r%d,&,"" , b , r ) ; ESIL_A ( ( buf [ 1 ] & 0xe ) == 0xc ? ""!,"" : ""!,!,"" ) ; ESIL_A ( ""?{,%"" PFMT64d "",pc,=,},"" , op -> jump ) ; }
","<S2SV_ModStart> ; RAnalOp next_op = { 0 }
"
224,"CWE-476 static gboolean prplcb_xfer_new_send_cb ( gpointer data , gint fd , b_input_condition cond ) { PurpleXfer * xfer = data ; struct im_connection * ic = purple_ic_by_pa ( xfer -> account ) ; struct prpl_xfer_data * px = xfer -> ui_data ; PurpleBuddy * buddy ; const char * who ; buddy = purple_find_buddy ( xfer -> account , xfer -> who ) ; who = buddy ? purple_buddy_get_name ( buddy ) : xfer -> who ; px -> ft = imcb_file_send_start ( ic , ( char * ) who , xfer -> filename , xfer -> size ) ; <S2SV_StartBug> px -> ft -> data = px ; <S2SV_EndBug> px -> ft -> accept = prpl_xfer_accept ; px -> ft -> canceled = prpl_xfer_canceled ; px -> ft -> free = prpl_xfer_free ; px -> ft -> write_request = prpl_xfer_write_request ; return FALSE ; }
","<S2SV_ModStart> size ) ; if ( ! px -> ft ) { return FALSE ; }
"
225,"CWE-000 int perf_config ( config_fn_t fn , void * data ) { <S2SV_StartBug> int ret = 0 , found = 0 ; <S2SV_EndBug> char * repo_config = NULL ; const char * home = NULL ; if ( config_exclusive_filename ) return perf_config_from_file ( fn , config_exclusive_filename , data ) ; if ( perf_config_system ( ) && ! access ( perf_etc_perfconfig ( ) , R_OK ) ) { ret += perf_config_from_file ( fn , perf_etc_perfconfig ( ) , data ) ; found += 1 ; } home = getenv ( ""HOME"" ) ; if ( perf_config_global ( ) && home ) { char * user_config = strdup ( mkpath ( ""%s/.perfconfig"" , home ) ) ; if ( ! access ( user_config , R_OK ) ) { ret += perf_config_from_file ( fn , user_config , data ) ; found += 1 ; } free ( user_config ) ; } <S2SV_StartBug> repo_config = perf_pathdup ( ""config"" ) ; <S2SV_EndBug> if ( ! access ( repo_config , R_OK ) ) { ret += perf_config_from_file ( fn , repo_config , data ) ; found += 1 ; } free ( repo_config ) ; if ( found == 0 ) return - 1 ; return ret ; }
","<S2SV_ModStart> found = 0 <S2SV_ModEnd> ; const char <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( found
"
226,"CWE-264 static int <S2SV_StartBug> validate_event ( struct pmu_hw_events * hw_events , <S2SV_EndBug> struct perf_event * event ) { <S2SV_StartBug> struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ; <S2SV_EndBug> struct hw_perf_event fake_event = event -> hw ; struct pmu * leader_pmu = event -> group_leader -> pmu ; if ( is_software_event ( event ) ) return 1 ; <S2SV_StartBug> if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) <S2SV_EndBug> return 1 ; if ( event -> state == PERF_EVENT_STATE_OFF && ! event -> attr . enable_on_exec ) return 1 ; <S2SV_StartBug> return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> int validate_event ( struct pmu * pmu , <S2SV_ModStart> arm_pmu * armpmu <S2SV_ModEnd> ; struct hw_perf_event <S2SV_ModStart> -> pmu != pmu ) return 0 ; if ( event -> pmu != <S2SV_ModStart> return 1 ; armpmu = to_arm_pmu ( event -> pmu ) ;
"
227,"CWE-264 <S2SV_StartBug> static bool new_idmap_permitted ( struct user_namespace * ns , int cap_setid , <S2SV_EndBug> struct uid_gid_map * new_map ) { if ( ( new_map -> nr_extents == 1 ) && ( new_map -> extent [ 0 ] . count == 1 ) ) { u32 id = new_map -> extent [ 0 ] . lower_first ; if ( cap_setid == CAP_SETUID ) { kuid_t uid = make_kuid ( ns -> parent , id ) ; if ( uid_eq ( uid , current_fsuid ( ) ) ) return true ; } else if ( cap_setid == CAP_SETGID ) { kgid_t gid = make_kgid ( ns -> parent , id ) ; if ( gid_eq ( gid , current_fsgid ( ) ) ) return true ; } } if ( ! cap_valid ( cap_setid ) ) return true ; <S2SV_StartBug> if ( ns_capable ( ns -> parent , cap_setid ) ) <S2SV_EndBug> return true ; return false ; }
","<S2SV_ModStart> bool new_idmap_permitted ( const struct file * file , <S2SV_ModStart> , cap_setid ) && file_ns_capable ( file , ns -> parent , cap_setid )
"
228,"CWE-125 static VarLenData * * get_html_data ( MAPI_Attr * a ) { VarLenData * * body = XCALLOC ( VarLenData * , a -> num_values + 1 ) ; int j ; for ( j = 0 ; j < a -> num_values ; j ++ ) <S2SV_StartBug> { <S2SV_EndBug> body [ j ] = XMALLOC ( VarLenData , 1 ) ; body [ j ] -> len = a -> values [ j ] . len ; body [ j ] -> data = CHECKED_XCALLOC ( unsigned char , a -> values [ j ] . len ) ; memmove ( body [ j ] -> data , a -> values [ j ] . data . buf , body [ j ] -> len ) ; } <S2SV_StartBug> return body ; <S2SV_EndBug> }
","<S2SV_ModStart> j ++ ) { if ( a -> type == szMAPI_BINARY ) <S2SV_ModStart> ) ; } }
"
229,"CWE-119 int usb_cypress_load_firmware ( struct usb_device * udev , const struct firmware * fw , int type ) { struct hexline * hx ; <S2SV_StartBug> u8 reset ; <S2SV_EndBug> int ret , pos = 0 ; <S2SV_StartBug> hx = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! hx ) return - ENOMEM ; reset = 1 ; <S2SV_StartBug> if ( ( ret = usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) ) != 1 ) <S2SV_EndBug> err ( ""could<S2SV_blank>not<S2SV_blank>stop<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ; while ( ( ret = dvb_usb_get_hexline ( fw , hx , & pos ) ) > 0 ) { deb_fw ( ""writing<S2SV_blank>to<S2SV_blank>address<S2SV_blank>0x%04x<S2SV_blank>(buffer:<S2SV_blank>0x%02x<S2SV_blank>%02x)\\n"" , hx -> addr , hx -> len , hx -> chk ) ; ret = usb_cypress_writemem ( udev , hx -> addr , hx -> data , hx -> len ) ; if ( ret != hx -> len ) { err ( ""error<S2SV_blank>while<S2SV_blank>transferring<S2SV_blank>firmware<S2SV_blank>(transferred<S2SV_blank>size:<S2SV_blank>%d,<S2SV_blank>block<S2SV_blank>size:<S2SV_blank>%d)"" , ret , hx -> len ) ; ret = - EINVAL ; break ; } } if ( ret < 0 ) { err ( ""firmware<S2SV_blank>download<S2SV_blank>failed<S2SV_blank>at<S2SV_blank>%d<S2SV_blank>with<S2SV_blank>%d"" , pos , ret ) ; <S2SV_StartBug> kfree ( hx ) ; <S2SV_EndBug> return ret ; } if ( ret == 0 ) { <S2SV_StartBug> reset = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ret || usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) != 1 ) { <S2SV_EndBug> err ( ""could<S2SV_blank>not<S2SV_blank>restart<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ; ret = - EINVAL ; } } else ret = - EIO ; <S2SV_StartBug> kfree ( hx ) ; <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> hx ; u8 * buf <S2SV_ModEnd> ; int ret <S2SV_ModStart> = 0 ; u16 cpu_cs_register = <S2SV_ModEnd> cypress [ type <S2SV_ModStart> ] . cpu_cs_register ; buf = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; hx = ( struct hexline * ) buf ; buf [ 0 ] = 1 ; if ( usb_cypress_writemem ( udev , cpu_cs_register , buf , 1 <S2SV_ModEnd> ) != 1 <S2SV_ModStart> ; kfree ( buf <S2SV_ModEnd> ) ; return <S2SV_ModStart> 0 ) { buf [ 0 ] = 0 ; if ( <S2SV_ModEnd> usb_cypress_writemem ( udev <S2SV_ModStart> ( udev , cpu_cs_register , buf <S2SV_ModEnd> , 1 ) <S2SV_ModStart> ; kfree ( buf <S2SV_ModEnd> ) ; return
"
230,"CWE-125 static void <S2SV_StartBug> l2tp_call_errors_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { const uint16_t * ptr = ( const uint16_t * ) dat ; uint16_t val_h , val_l ; <S2SV_StartBug> ptr ++ ; <S2SV_EndBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""CRCErr=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""FrameErr=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""HardOver=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""BufOver=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""Timeout=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""AlignErr=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; }
","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> , val_l ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } ptr ++ ; length -= 2 ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }
"
231,"CWE-284 static int check_rpcsec_auth ( struct svc_req * rqstp ) { gss_ctx_id_t ctx ; krb5_context kctx ; OM_uint32 maj_stat , min_stat ; gss_name_t name ; krb5_principal princ ; int ret , success ; krb5_data * c1 , * c2 , * realm ; gss_buffer_desc gss_str ; kadm5_server_handle_t handle ; size_t slen ; char * sdots ; success = 0 ; handle = ( kadm5_server_handle_t ) global_server_handle ; if ( rqstp -> rq_cred . oa_flavor != RPCSEC_GSS ) return 0 ; ctx = rqstp -> rq_svccred ; maj_stat = gss_inquire_context ( & min_stat , ctx , NULL , & name , NULL , NULL , NULL , NULL , NULL ) ; if ( maj_stat != GSS_S_COMPLETE ) { krb5_klog_syslog ( LOG_ERR , _ ( ""check_rpcsec_auth:<S2SV_blank>failed<S2SV_blank>"" ""inquire_context,<S2SV_blank>stat=%u"" ) , maj_stat ) ; log_badauth ( maj_stat , min_stat , rqstp -> rq_xprt , NULL ) ; goto fail_name ; } kctx = handle -> context ; ret = gss_to_krb5_name_1 ( rqstp , kctx , name , & princ , & gss_str ) ; if ( ret == 0 ) goto fail_name ; slen = gss_str . length ; trunc_name ( & slen , & sdots ) ; if ( krb5_princ_size ( kctx , princ ) != 2 ) goto fail_princ ; c1 = krb5_princ_component ( kctx , princ , 0 ) ; c2 = krb5_princ_component ( kctx , princ , 1 ) ; realm = krb5_princ_realm ( kctx , princ ) ; <S2SV_StartBug> if ( strncmp ( handle -> params . realm , realm -> data , realm -> length ) == 0 <S2SV_EndBug> && strncmp ( ""kadmin"" , c1 -> data , c1 -> length ) == 0 ) { if ( strncmp ( ""history"" , c2 -> data , c2 -> length ) == 0 ) goto fail_princ ; else success = 1 ; } fail_princ : if ( ! success ) { krb5_klog_syslog ( LOG_ERR , _ ( ""bad<S2SV_blank>service<S2SV_blank>principal<S2SV_blank>%.*s%s"" ) , ( int ) slen , ( char * ) gss_str . value , sdots ) ; } gss_release_buffer ( & min_stat , & gss_str ) ; krb5_free_principal ( kctx , princ ) ; fail_name : gss_release_name ( & min_stat , & name ) ; return success ; }
","<S2SV_ModStart> princ ) ; success = data_eq_string ( * realm , <S2SV_ModEnd> handle -> params <S2SV_ModStart> params . realm ) && data_eq_string ( * c1 , ""kadmin"" ) && ! data_eq_string ( * c2 , ""history"" ) ; <S2SV_ModEnd> fail_princ : if
"
232,"CWE-190 static int vc4_get_bcl ( struct drm_device * dev , struct vc4_exec_info * exec ) { struct drm_vc4_submit_cl * args = exec -> args ; void * temp = NULL ; void * bin ; int ret = 0 ; uint32_t bin_offset = 0 ; uint32_t shader_rec_offset = roundup ( bin_offset + args -> bin_cl_size , 16 ) ; uint32_t uniforms_offset = shader_rec_offset + args -> shader_rec_size ; uint32_t exec_size = uniforms_offset + args -> uniforms_size ; uint32_t temp_size = exec_size + ( sizeof ( struct vc4_shader_state ) * args -> shader_rec_count ) ; struct vc4_bo * bo ; <S2SV_StartBug> if ( uniforms_offset < shader_rec_offset || <S2SV_EndBug> exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) { DRM_ERROR ( ""overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\n"" ) ; goto fail ; } temp = drm_malloc_ab ( temp_size , 1 ) ; if ( ! temp ) { DRM_ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>storage<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>"" ""in<S2SV_blank>bin/render<S2SV_blank>CLs.\\n"" ) ; ret = - ENOMEM ; goto fail ; } bin = temp + bin_offset ; exec -> shader_rec_u = temp + shader_rec_offset ; exec -> uniforms_u = temp + uniforms_offset ; exec -> shader_state = temp + exec_size ; exec -> shader_state_size = args -> shader_rec_count ; if ( copy_from_user ( bin , ( void __user * ) ( uintptr_t ) args -> bin_cl , args -> bin_cl_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> shader_rec_u , ( void __user * ) ( uintptr_t ) args -> shader_rec , args -> shader_rec_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> uniforms_u , ( void __user * ) ( uintptr_t ) args -> uniforms , args -> uniforms_size ) ) { ret = - EFAULT ; goto fail ; } bo = vc4_bo_create ( dev , exec_size , true ) ; if ( IS_ERR ( bo ) ) { DRM_ERROR ( ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>BO<S2SV_blank>for<S2SV_blank>binning\\n"" ) ; ret = PTR_ERR ( bo ) ; goto fail ; } exec -> exec_bo = & bo -> base ; list_add_tail ( & to_vc4_bo ( & exec -> exec_bo -> base ) -> unref_head , & exec -> unref_list ) ; exec -> ct0ca = exec -> exec_bo -> paddr + bin_offset ; exec -> bin_u = bin ; exec -> shader_rec_v = exec -> exec_bo -> vaddr + shader_rec_offset ; exec -> shader_rec_p = exec -> exec_bo -> paddr + shader_rec_offset ; exec -> shader_rec_size = args -> shader_rec_size ; exec -> uniforms_v = exec -> exec_bo -> vaddr + uniforms_offset ; exec -> uniforms_p = exec -> exec_bo -> paddr + uniforms_offset ; exec -> uniforms_size = args -> uniforms_size ; ret = vc4_validate_bin_cl ( dev , exec -> exec_bo -> vaddr + bin_offset , bin , exec ) ; if ( ret ) goto fail ; ret = vc4_validate_shader_recs ( dev , exec ) ; if ( ret ) goto fail ; ret = vc4_wait_for_seqno ( dev , exec -> bin_dep_seqno , ~ 0ull , true ) ; fail : drm_free_large ( temp ) ; return ret ; }
","<S2SV_ModStart> ; if ( shader_rec_offset < args -> bin_cl_size ||
"
233,"CWE-401 static int archive_read_format_zip_cleanup ( struct archive_read * a ) { struct zip * zip ; struct zip_entry * zip_entry , * next_zip_entry ; zip = ( struct zip * ) ( a -> format -> data ) ; # ifdef HAVE_ZLIB_H if ( zip -> stream_valid ) inflateEnd ( & zip -> stream ) ; # endif <S2SV_StartBug> # if HAVA_LZMA_H && HAVE_LIBLZMA <S2SV_EndBug> if ( zip -> zipx_lzma_valid ) { lzma_end ( & zip -> zipx_lzma_stream ) ; } # endif # ifdef HAVE_BZLIB_H if ( zip -> bzstream_valid ) { BZ2_bzDecompressEnd ( & zip -> bzstream ) ; } # endif free ( zip -> uncompressed_buffer ) ; if ( zip -> ppmd8_valid ) __archive_ppmd8_functions . Ppmd8_Free ( & zip -> ppmd8 ) ; if ( zip -> zip_entries ) { zip_entry = zip -> zip_entries ; while ( zip_entry != NULL ) { next_zip_entry = zip_entry -> next ; archive_string_free ( & zip_entry -> rsrcname ) ; free ( zip_entry ) ; zip_entry = next_zip_entry ; } } free ( zip -> decrypted_buffer ) ; if ( zip -> cctx_valid ) archive_decrypto_aes_ctr_release ( & zip -> cctx ) ; if ( zip -> hctx_valid ) archive_hmac_sha1_cleanup ( & zip -> hctx ) ; free ( zip -> iv ) ; free ( zip -> erd ) ; free ( zip -> v_data ) ; archive_string_free ( & zip -> format_name ) ; free ( zip ) ; ( a -> format -> data ) = NULL ; return ( ARCHIVE_OK ) ; }
","<S2SV_ModStart> endif # if HAVE_LZMA_H <S2SV_ModEnd> && HAVE_LIBLZMA if
"
234,"CWE-362 int ext4_page_mkwrite ( struct vm_area_struct * vma , struct vm_fault * vmf ) { struct page * page = vmf -> page ; loff_t size ; unsigned long len ; int ret ; struct file * file = vma -> vm_file ; struct inode * inode = file_inode ( file ) ; struct address_space * mapping = inode -> i_mapping ; handle_t * handle ; get_block_t * get_block ; int retries = 0 ; sb_start_pagefault ( inode -> i_sb ) ; <S2SV_StartBug> file_update_time ( vma -> vm_file ) ; <S2SV_EndBug> if ( test_opt ( inode -> i_sb , DELALLOC ) && ! ext4_should_journal_data ( inode ) && ! ext4_nonda_switch ( inode -> i_sb ) ) { do { ret = block_page_mkwrite ( vma , vmf , ext4_da_get_block_prep ) ; } while ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) ; goto out_ret ; } lock_page ( page ) ; size = i_size_read ( inode ) ; if ( page -> mapping != mapping || page_offset ( page ) > size ) { unlock_page ( page ) ; ret = VM_FAULT_NOPAGE ; goto out ; } if ( page -> index == size >> PAGE_CACHE_SHIFT ) len = size & ~ PAGE_CACHE_MASK ; else len = PAGE_CACHE_SIZE ; if ( page_has_buffers ( page ) ) { if ( ! ext4_walk_page_buffers ( NULL , page_buffers ( page ) , 0 , len , NULL , ext4_bh_unmapped ) ) { wait_for_stable_page ( page ) ; ret = VM_FAULT_LOCKED ; goto out ; } } unlock_page ( page ) ; if ( ext4_should_dioread_nolock ( inode ) ) get_block = ext4_get_block_write ; else get_block = ext4_get_block ; retry_alloc : handle = ext4_journal_start ( inode , EXT4_HT_WRITE_PAGE , ext4_writepage_trans_blocks ( inode ) ) ; if ( IS_ERR ( handle ) ) { ret = VM_FAULT_SIGBUS ; goto out ; } ret = block_page_mkwrite ( vma , vmf , get_block ) ; if ( ! ret && ext4_should_journal_data ( inode ) ) { if ( ext4_walk_page_buffers ( handle , page_buffers ( page ) , 0 , PAGE_CACHE_SIZE , NULL , do_journal_get_write_access ) ) { unlock_page ( page ) ; ret = VM_FAULT_SIGBUS ; ext4_journal_stop ( handle ) ; goto out ; } ext4_set_inode_state ( inode , EXT4_STATE_JDATA ) ; } ext4_journal_stop ( handle ) ; if ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) goto retry_alloc ; out_ret : ret = block_page_mkwrite_return ( ret ) ; out : <S2SV_StartBug> sb_end_pagefault ( inode -> i_sb ) ; <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> vma -> vm_file ) ; down_read ( & EXT4_I ( inode ) -> i_mmap_sem <S2SV_ModStart> ; out : up_read ( & EXT4_I ( inode ) -> i_mmap_sem ) ;
"
235,"CWE-190 static int jas_iccgetuint64 ( jas_stream_t * in , jas_iccuint64_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 8 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
","<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if
"
236,"CWE-78 static char * __filterShell ( const char * arg ) { r_return_val_if_fail ( arg , NULL ) ; char * a = malloc ( strlen ( arg ) + 1 ) ; if ( ! a ) { return NULL ; } char * b = a ; while ( * arg ) { <S2SV_StartBug> switch ( * arg ) { <S2SV_EndBug> case '@' : case '`' : case '|' : case ';' : <S2SV_StartBug> case '\\n' : <S2SV_EndBug> break ; default : <S2SV_StartBug> * b ++ = * arg ; <S2SV_EndBug> break ; } arg ++ ; } * b = 0 ; return a ; }
","<S2SV_ModStart> arg ) { char ch = * arg ; switch ( ch <S2SV_ModEnd> ) { case <S2SV_ModStart> ';' : case '=' : case <S2SV_ModStart> b ++ = ch <S2SV_ModEnd> ; break ;
"
237,"CWE-125 static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , ""<S2SV_blank>#%d<S2SV_blank>id=%s<S2SV_blank>"" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>#%d<S2SV_blank>id=%d<S2SV_blank>"" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { <S2SV_StartBug> if ( map && nmap ) { <S2SV_EndBug> <S2SV_StartBug> cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , <S2SV_EndBug> map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
","<S2SV_ModStart> && nmap ) <S2SV_ModEnd> cp = ikev1_attrmap_print <S2SV_ModStart> , cp , ep2 , map , nmap ) ; else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart> < ep2 ) <S2SV_ModEnd> ND_PRINT ( (
"
238,"CWE-835 G_DEFINE_TYPE ( GsmXsmpServer , gsm_xsmp_server , G_TYPE_OBJECT ) typedef struct { GsmXsmpServer * server ; IceListenObj listener ; } GsmIceConnectionData ; <S2SV_StartBug> static gboolean <S2SV_EndBug> accept_ice_connection ( GIOChannel * source , GIOCondition condition , GsmIceConnectionData * data ) { IceListenObj listener ; IceConn ice_conn ; IceAcceptStatus status ; GsmClient * client ; GsmXsmpServer * server ; listener = data -> listener ; server = data -> server ; g_debug ( ""GsmXsmpServer:<S2SV_blank>accept_ice_connection()"" ) ; ice_conn = IceAcceptConnection ( listener , & status ) ; if ( status != IceAcceptSuccess ) { g_debug ( ""GsmXsmpServer:<S2SV_blank>IceAcceptConnection<S2SV_blank>returned<S2SV_blank>%d"" , status ) ; return TRUE ; } client = gsm_xsmp_client_new ( ice_conn ) ; <S2SV_StartBug> ice_conn -> context = client ; <S2SV_EndBug> gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ; g_object_unref ( client ) ; return TRUE ; }
","<S2SV_ModStart> } GsmIceConnectionData ; typedef struct { guint watch_id ; guint protocol_timeout ; } GsmIceConnectionWatch ; static void disconnect_ice_connection ( IceConn ice_conn ) { IceSetShutdownNegotiation ( ice_conn , FALSE ) ; IceCloseConnection <S2SV_ModEnd> ( ice_conn ) <S2SV_ModStart> ice_conn ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
239,"CWE-399 static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , u32 features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * mac_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } offset = skb -> csum_start - skb_headroom ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; <S2SV_StartBug> if ( ( skb_headroom ( skb ) < frag_hdr_sz ) && <S2SV_EndBug> pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ; unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = skb_network_header ( skb ) - skb_mac_header ( skb ) + unfrag_ip6hlen ; mac_start = skb_mac_header ( skb ) ; memmove ( mac_start - frag_hdr_sz , mac_start , unfrag_len ) ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; ipv6_select_ident ( fptr ) ; segs = skb_segment ( skb , features ) ; out : return segs ; }
","<S2SV_ModStart> if ( ( skb_mac_header <S2SV_ModEnd> ( skb ) <S2SV_ModStart> skb ) < skb -> head +
"
240,"CWE-20 void test_checkout_nasty__git_tilde1 ( void ) { <S2SV_StartBug> # ifdef GIT_WIN32 <S2SV_EndBug> test_checkout_fails ( ""refs/heads/git_tilde1"" , "".git/foobar"" ) ; <S2SV_StartBug> # endif <S2SV_EndBug> }
","<S2SV_ModStart> void ) { <S2SV_ModEnd> test_checkout_fails ( ""refs/heads/git_tilde1"" <S2SV_ModStart> "".git/foobar"" ) ; test_checkout_fails ( ""refs/heads/git_tilde1"" , ""git~1/foobar"" ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
241,"CWE-119 int sock_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; union { int val ; struct linger ling ; struct timeval tm ; } v ; int lv = sizeof ( int ) ; int len ; if ( get_user ( len , optlen ) ) return - EFAULT ; if ( len < 0 ) return - EINVAL ; memset ( & v , 0 , sizeof ( v ) ) ; switch ( optname ) { case SO_DEBUG : v . val = sock_flag ( sk , SOCK_DBG ) ; break ; case SO_DONTROUTE : v . val = sock_flag ( sk , SOCK_LOCALROUTE ) ; break ; case SO_BROADCAST : v . val = ! ! sock_flag ( sk , SOCK_BROADCAST ) ; break ; case SO_SNDBUF : v . val = sk -> sk_sndbuf ; break ; case SO_RCVBUF : v . val = sk -> sk_rcvbuf ; break ; case SO_REUSEADDR : v . val = sk -> sk_reuse ; break ; case SO_KEEPALIVE : v . val = ! ! sock_flag ( sk , SOCK_KEEPOPEN ) ; break ; case SO_TYPE : v . val = sk -> sk_type ; break ; case SO_PROTOCOL : v . val = sk -> sk_protocol ; break ; case SO_DOMAIN : v . val = sk -> sk_family ; break ; case SO_ERROR : v . val = - sock_error ( sk ) ; if ( v . val == 0 ) v . val = xchg ( & sk -> sk_err_soft , 0 ) ; break ; case SO_OOBINLINE : v . val = ! ! sock_flag ( sk , SOCK_URGINLINE ) ; break ; case SO_NO_CHECK : v . val = sk -> sk_no_check ; break ; case SO_PRIORITY : v . val = sk -> sk_priority ; break ; case SO_LINGER : lv = sizeof ( v . ling ) ; v . ling . l_onoff = ! ! sock_flag ( sk , SOCK_LINGER ) ; v . ling . l_linger = sk -> sk_lingertime / HZ ; break ; case SO_BSDCOMPAT : sock_warn_obsolete_bsdism ( ""getsockopt"" ) ; break ; case SO_TIMESTAMP : v . val = sock_flag ( sk , SOCK_RCVTSTAMP ) && ! sock_flag ( sk , SOCK_RCVTSTAMPNS ) ; break ; case SO_TIMESTAMPNS : v . val = sock_flag ( sk , SOCK_RCVTSTAMPNS ) ; break ; case SO_TIMESTAMPING : v . val = 0 ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_TX_HARDWARE ) ) v . val |= SOF_TIMESTAMPING_TX_HARDWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_TX_SOFTWARE ) ) v . val |= SOF_TIMESTAMPING_TX_SOFTWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_RX_HARDWARE ) ) v . val |= SOF_TIMESTAMPING_RX_HARDWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_RX_SOFTWARE ) ) v . val |= SOF_TIMESTAMPING_RX_SOFTWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_SOFTWARE ) ) v . val |= SOF_TIMESTAMPING_SOFTWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_SYS_HARDWARE ) ) v . val |= SOF_TIMESTAMPING_SYS_HARDWARE ; if ( sock_flag ( sk , SOCK_TIMESTAMPING_RAW_HARDWARE ) ) v . val |= SOF_TIMESTAMPING_RAW_HARDWARE ; break ; case SO_RCVTIMEO : lv = sizeof ( struct timeval ) ; if ( sk -> sk_rcvtimeo == MAX_SCHEDULE_TIMEOUT ) { v . tm . tv_sec = 0 ; v . tm . tv_usec = 0 ; } else { v . tm . tv_sec = sk -> sk_rcvtimeo / HZ ; v . tm . tv_usec = ( ( sk -> sk_rcvtimeo % HZ ) * 1000000 ) / HZ ; } break ; case SO_SNDTIMEO : lv = sizeof ( struct timeval ) ; if ( sk -> sk_sndtimeo == MAX_SCHEDULE_TIMEOUT ) { v . tm . tv_sec = 0 ; v . tm . tv_usec = 0 ; } else { v . tm . tv_sec = sk -> sk_sndtimeo / HZ ; v . tm . tv_usec = ( ( sk -> sk_sndtimeo % HZ ) * 1000000 ) / HZ ; } break ; case SO_RCVLOWAT : v . val = sk -> sk_rcvlowat ; break ; case SO_SNDLOWAT : v . val = 1 ; break ; case SO_PASSCRED : <S2SV_StartBug> v . val = test_bit ( SOCK_PASSCRED , & sock -> flags ) ? 1 : 0 ; <S2SV_EndBug> break ; case SO_PEERCRED : { struct ucred peercred ; if ( len > sizeof ( peercred ) ) len = sizeof ( peercred ) ; cred_to_ucred ( sk -> sk_peer_pid , sk -> sk_peer_cred , & peercred ) ; if ( copy_to_user ( optval , & peercred , len ) ) return - EFAULT ; goto lenout ; } case SO_PEERNAME : { char address [ 128 ] ; if ( sock -> ops -> getname ( sock , ( struct sockaddr * ) address , & lv , 2 ) ) return - ENOTCONN ; if ( lv < len ) return - EINVAL ; if ( copy_to_user ( optval , address , len ) ) return - EFAULT ; goto lenout ; } case SO_ACCEPTCONN : v . val = sk -> sk_state == TCP_LISTEN ; break ; case SO_PASSSEC : <S2SV_StartBug> v . val = test_bit ( SOCK_PASSSEC , & sock -> flags ) ? 1 : 0 ; <S2SV_EndBug> break ; case SO_PEERSEC : return security_socket_getpeersec_stream ( sock , optval , optlen , len ) ; case SO_MARK : v . val = sk -> sk_mark ; break ; case SO_RXQ_OVFL : v . val = ! ! sock_flag ( sk , SOCK_RXQ_OVFL ) ; break ; case SO_WIFI_STATUS : v . val = ! ! sock_flag ( sk , SOCK_WIFI_STATUS ) ; break ; case SO_PEEK_OFF : if ( ! sock -> ops -> set_peek_off ) return - EOPNOTSUPP ; v . val = sk -> sk_peek_off ; break ; case SO_NOFCS : v . val = ! ! sock_flag ( sk , SOCK_NOFCS ) ; break ; default : return - ENOPROTOOPT ; } if ( len > lv ) len = lv ; if ( copy_to_user ( optval , & v , len ) ) return - EFAULT ; lenout : if ( put_user ( len , optlen ) ) return - EFAULT ; return 0 ; }
","<S2SV_ModStart> . val = ! ! <S2SV_ModStart> -> flags ) <S2SV_ModEnd> ; break ; <S2SV_ModStart> . val = ! ! <S2SV_ModStart> -> flags ) <S2SV_ModEnd> ; break ;
"
242,"CWE-20 int bt_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct sk_buff * skb ; size_t copied ; int err ; BT_DBG ( ""sock<S2SV_blank>%p<S2SV_blank>sk<S2SV_blank>%p<S2SV_blank>len<S2SV_blank>%zu"" , sock , sk , len ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { <S2SV_StartBug> if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { <S2SV_EndBug> msg -> msg_namelen = 0 ; return 0 ; } return err ; } copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( skb ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err == 0 ) { sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( bt_sk ( sk ) -> skb_msg_name ) bt_sk ( sk ) -> skb_msg_name ( skb , msg -> msg_name , & msg -> msg_namelen ) ; <S2SV_StartBug> else <S2SV_EndBug> msg -> msg_namelen = 0 ; } skb_free_datagram ( sk , skb ) ; return err ? : copied ; }
","<S2SV_ModStart> & RCV_SHUTDOWN ) return 0 ; <S2SV_ModEnd> return err ; <S2SV_ModStart> msg_namelen ) ; <S2SV_ModEnd> } skb_free_datagram (
"
243,"CWE-119 SQLWCHAR * _multi_string_alloc_and_expand ( LPCSTR in ) { SQLWCHAR * chr ; int len = 0 ; if ( ! in ) { <S2SV_StartBug> return in ; <S2SV_EndBug> } while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { len ++ ; } chr = malloc ( sizeof ( SQLWCHAR ) * ( len + 2 ) ) ; len = 0 ; while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { chr [ len ] = in [ len ] ; len ++ ; } chr [ len ++ ] = 0 ; chr [ len ++ ] = 0 ; return chr ; }
","<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
"
244,"CWE-119 void vp9_setup_pre_planes ( MACROBLOCKD * xd , int idx , const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col , const struct scale_factors * sf ) { if ( src != NULL ) { int i ; <S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> src -> alpha_buffer } ; <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> src -> alpha_stride } ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { struct macroblockd_plane * const pd = & xd -> plane [ i ] ; setup_pred_plane ( & pd -> pre [ idx ] , buffers [ i ] , strides [ i ] , mi_row , mi_col , sf , pd -> subsampling_x , pd -> subsampling_y ) ; } } }
","<S2SV_ModStart> const buffers [ MAX_MB_PLANE <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> v_buffer <S2SV_ModEnd> } ; const <S2SV_ModStart> int strides [ MAX_MB_PLANE <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> uv_stride <S2SV_ModEnd> } ; for
"
245,"CWE-119 static krb5_error_code get_matching_data ( krb5_context context , pkinit_plg_crypto_context plg_cryptoctx , pkinit_req_crypto_context req_cryptoctx , X509 * cert , pkinit_cert_matching_data * * md_out ) { krb5_error_code ret = ENOMEM ; pkinit_cert_matching_data * md = NULL ; krb5_principal * pkinit_sans = NULL , * upn_sans = NULL ; size_t i , j ; <S2SV_StartBug> char buf [ DN_BUF_LEN ] ; <S2SV_EndBug> unsigned int bufsize = sizeof ( buf ) ; * md_out = NULL ; md = calloc ( 1 , sizeof ( * md ) ) ; if ( md == NULL ) goto cleanup ; <S2SV_StartBug> X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , buf , & bufsize , <S2SV_EndBug> XN_FLAG_SEP_COMMA_PLUS ) ; <S2SV_StartBug> md -> subject_dn = strdup ( buf ) ; <S2SV_EndBug> if ( md -> subject_dn == NULL ) { ret = ENOMEM ; goto cleanup ; } <S2SV_StartBug> X509_NAME_oneline_ex ( X509_get_issuer_name ( cert ) , buf , & bufsize , <S2SV_EndBug> XN_FLAG_SEP_COMMA_PLUS ) ; <S2SV_StartBug> md -> issuer_dn = strdup ( buf ) ; <S2SV_EndBug> if ( md -> issuer_dn == NULL ) { ret = ENOMEM ; goto cleanup ; } ret = crypto_retrieve_X509_sans ( context , plg_cryptoctx , req_cryptoctx , cert , & pkinit_sans , & upn_sans , NULL ) ; if ( ret ) goto cleanup ; j = 0 ; if ( pkinit_sans != NULL ) { for ( i = 0 ; pkinit_sans [ i ] != NULL ; i ++ ) j ++ ; } if ( upn_sans != NULL ) { for ( i = 0 ; upn_sans [ i ] != NULL ; i ++ ) j ++ ; } if ( j != 0 ) { md -> sans = calloc ( ( size_t ) j + 1 , sizeof ( * md -> sans ) ) ; if ( md -> sans == NULL ) { ret = ENOMEM ; goto cleanup ; } j = 0 ; if ( pkinit_sans != NULL ) { for ( i = 0 ; pkinit_sans [ i ] != NULL ; i ++ ) md -> sans [ j ++ ] = pkinit_sans [ i ] ; free ( pkinit_sans ) ; } if ( upn_sans != NULL ) { for ( i = 0 ; upn_sans [ i ] != NULL ; i ++ ) md -> sans [ j ++ ] = upn_sans [ i ] ; free ( upn_sans ) ; } md -> sans [ j ] = NULL ; } else md -> sans = NULL ; ret = crypto_retrieve_X509_key_usage ( context , plg_cryptoctx , req_cryptoctx , cert , & md -> ku_bits , & md -> eku_bits ) ; if ( ret ) goto cleanup ; * md_out = md ; md = NULL ; cleanup : crypto_cert_free_matching_data ( context , md ) ; return ret ; }
","<S2SV_ModStart> , j ; * md_out = NULL ; md = calloc ( 1 , sizeof ( <S2SV_ModEnd> * md ) <S2SV_ModStart> goto cleanup ; ret = rfc2253_name <S2SV_ModEnd> ( X509_get_subject_name ( <S2SV_ModStart> cert ) , & <S2SV_ModEnd> md -> subject_dn <S2SV_ModStart> md -> subject_dn ) ; if ( ret ) goto cleanup ; ret = rfc2253_name <S2SV_ModEnd> ( X509_get_issuer_name ( <S2SV_ModStart> cert ) , & <S2SV_ModEnd> md -> issuer_dn <S2SV_ModStart> md -> issuer_dn ) ; if ( ret ) goto cleanup ; <S2SV_ModEnd> ret = crypto_retrieve_X509_sans
"
246,"CWE-399 int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; unsigned long i ; struct kvm_memory_slot * memslot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; r = - EEXIST ; for ( i = 0 ; i < KVM_MEMORY_SLOTS ; ++ i ) { struct kvm_memory_slot * s = & kvm -> memslots -> memslots [ i ] ; if ( s == memslot || ! s -> npages ) continue ; if ( ! ( ( base_gfn + npages <= s -> base_gfn ) || ( base_gfn >= s -> base_gfn + s -> npages ) ) ) goto out_free ; } if ( ! ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) ) new . dirty_bitmap = NULL ; r = - ENOMEM ; if ( npages && ! old . npages ) { new . user_alloc = user_alloc ; new . userspace_addr = mem -> userspace_addr ; if ( kvm_arch_create_memslot ( & new , npages ) ) goto out_free ; } if ( ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) && ! new . dirty_bitmap ) { if ( kvm_create_dirty_bitmap ( & new ) < 0 ) goto out_free ; } <S2SV_StartBug> if ( ! npages ) { <S2SV_EndBug> struct kvm_memory_slot * slot ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; slot = id_to_memslot ( slots , mem -> slot ) ; slot -> flags |= KVM_MEMSLOT_INVALID ; update_memslots ( slots , NULL ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_flush_shadow_memslot ( kvm , slot ) ; kfree ( old_memslots ) ; } r = kvm_arch_prepare_memory_region ( kvm , & new , old , mem , user_alloc ) ; if ( r ) goto out_free ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; if ( ! npages ) { new . dirty_bitmap = NULL ; memset ( & new . arch , 0 , sizeof ( new . arch ) ) ; } update_memslots ( slots , & new ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_commit_memory_region ( kvm , mem , old , user_alloc ) ; if ( npages && old . base_gfn != mem -> guest_phys_addr >> PAGE_SHIFT ) kvm_arch_flush_shadow_all ( kvm ) ; kvm_free_physmem_slot ( & old , & new ) ; kfree ( old_memslots ) ; return 0 ; out_free : kvm_free_physmem_slot ( & new , & old ) ; out : return r ; }
","<S2SV_ModStart> ( ! npages || base_gfn != old . base_gfn
"
247,"CWE-200 SYSCALL_DEFINE5 ( waitid , int , which , pid_t , upid , struct siginfo __user * , infop , int , options , struct rusage __user * , ru ) { struct rusage r ; struct waitid_info info = { . status = 0 } ; long err = kernel_waitid ( which , upid , & info , options , ru ? & r : NULL ) ; int signo = 0 ; if ( err > 0 ) { signo = SIGCHLD ; err = 0 ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! err ) { if ( ru && copy_to_user ( ru , & r , sizeof ( struct rusage ) ) ) return - EFAULT ; } if ( ! infop ) return err ; user_access_begin ( ) ; unsafe_put_user ( signo , & infop -> si_signo , Efault ) ; unsafe_put_user ( 0 , & infop -> si_errno , Efault ) ; unsafe_put_user ( info . cause , & infop -> si_code , Efault ) ; unsafe_put_user ( info . pid , & infop -> si_pid , Efault ) ; unsafe_put_user ( info . uid , & infop -> si_uid , Efault ) ; unsafe_put_user ( info . status , & infop -> si_status , Efault ) ; user_access_end ( ) ; return err ; Efault : user_access_end ( ) ; return - EFAULT ; }
","<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( ru
"
248,"CWE-20 static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
","<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; for (
"
249,"CWE-125 void ripng_print ( netdissect_options * ndo , const u_char * dat , unsigned int length ) { register const struct rip6 * rp = ( const struct rip6 * ) dat ; register const struct netinfo6 * ni ; <S2SV_StartBug> register u_int amt ; <S2SV_EndBug> register u_int i ; int j ; int trunc ; if ( ndo -> ndo_snapend < dat ) return ; amt = ndo -> ndo_snapend - dat ; i = min ( length , amt ) ; if ( i < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) return ; i -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; switch ( rp -> rip6_cmd ) { case RIP6_REQUEST : <S2SV_StartBug> j = length / sizeof ( * ni ) ; <S2SV_EndBug> if ( j == 1 <S2SV_StartBug> && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6 <S2SV_EndBug> && IN6_IS_ADDR_UNSPECIFIED ( & rp -> rip6_nets -> rip6_dest ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>dump"" ) ) ; break ; } <S2SV_StartBug> if ( j * sizeof ( * ni ) != length - 4 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d[%u]:"" , j , length ) ) ; else <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d:"" , j ) ) ; <S2SV_EndBug> trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ; <S2SV_StartBug> for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> i -= sizeof ( * ni ) , ++ ni ) { <S2SV_EndBug> if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; rip6_entry_print ( ndo , ni , 0 ) ; } <S2SV_StartBug> break ; <S2SV_EndBug> case RIP6_RESPONSE : <S2SV_StartBug> j = length / sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> if ( j * sizeof ( * ni ) != length - 4 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d:"" , j ) ) ; <S2SV_StartBug> trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ; <S2SV_EndBug> <S2SV_StartBug> for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> i -= sizeof ( * ni ) , ++ ni ) { <S2SV_EndBug> if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; rip6_entry_print ( ndo , ni , ni -> rip6_metric ) ; } <S2SV_StartBug> if ( trunc ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-%d<S2SV_blank>??<S2SV_blank>%u"" , rp -> rip6_cmd , length ) ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> if ( rp -> rip6_vers != RIP6_VERSION ) ND_PRINT ( ( ndo , ""<S2SV_blank>[vers<S2SV_blank>%d]"" , rp -> rip6_vers ) ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> * ni ; unsigned int length_left ; u_int j ; ND_TCHECK ( rp -> rip6_cmd <S2SV_ModEnd> ) ; switch <S2SV_ModStart> case RIP6_REQUEST : length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> / sizeof ( <S2SV_ModStart> j == 1 ) { ND_TCHECK ( rp -> rip6_nets ) ; if ( <S2SV_ModEnd> rp -> rip6_nets <S2SV_ModStart> break ; } } <S2SV_ModStart> ni ) != length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u[%u]:"" , j , length <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u:"" , j ) <S2SV_ModEnd> ) ; for <S2SV_ModStart> -> rip6_nets ; length_left <S2SV_ModEnd> >= sizeof ( <S2SV_ModStart> ni ) ; length_left <S2SV_ModEnd> -= sizeof ( <S2SV_ModStart> ni ) { ND_TCHECK ( * ni ) ; <S2SV_ModStart> ) ; } if ( length_left != 0 ) goto trunc ; <S2SV_ModStart> case RIP6_RESPONSE : length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> / sizeof ( <S2SV_ModStart> ni ) != length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> for ( ni <S2SV_ModStart> -> rip6_nets ; length_left <S2SV_ModEnd> >= sizeof ( <S2SV_ModStart> ni ) ; length_left <S2SV_ModEnd> -= sizeof ( <S2SV_ModStart> ni ) { ND_TCHECK ( * ni ) ; <S2SV_ModStart> } if ( length_left != 0 ) goto trunc <S2SV_ModEnd> ; break ; <S2SV_ModStart> break ; } ND_TCHECK ( rp -> rip6_vers ) ; <S2SV_ModStart> ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ; return ;
"
250,"CWE-404 long keyctl_set_reqkey_keyring ( int reqkey_defl ) { struct cred * new ; int ret , old_setting ; old_setting = current_cred_xxx ( jit_keyring ) ; if ( reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE ) return old_setting ; new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; switch ( reqkey_defl ) { case KEY_REQKEY_DEFL_THREAD_KEYRING : ret = install_thread_keyring_to_cred ( new ) ; if ( ret < 0 ) goto error ; goto set ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : ret = install_process_keyring_to_cred ( new ) ; <S2SV_StartBug> if ( ret < 0 ) { <S2SV_EndBug> if ( ret != - EEXIST ) goto error ; ret = 0 ; } goto set ; case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_SESSION_KEYRING : case KEY_REQKEY_DEFL_USER_KEYRING : case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : goto set ; case KEY_REQKEY_DEFL_NO_CHANGE : case KEY_REQKEY_DEFL_GROUP_KEYRING : default : ret = - EINVAL ; goto error ; } set : new -> jit_keyring = reqkey_defl ; commit_creds ( new ) ; return old_setting ; error : abort_creds ( new ) ; return ret ; }
","<S2SV_ModStart> < 0 ) goto error ; <S2SV_ModEnd> goto set ;
"
251,"CWE-119 static void calc_av_activity ( VP8_COMP * cpi , int64_t activity_sum ) { # if ACT_MEDIAN { unsigned int median ; unsigned int i , j ; unsigned int * sortlist ; unsigned int tmp ; CHECK_MEM_ERROR ( sortlist , vpx_calloc ( sizeof ( unsigned int ) , cpi -> common . MBs ) ) ; <S2SV_StartBug> vpx_memcpy ( sortlist , cpi -> mb_activity_map , <S2SV_EndBug> sizeof ( unsigned int ) * cpi -> common . MBs ) ; for ( i = 1 ; i < cpi -> common . MBs ; i ++ ) { for ( j = i ; j > 0 ; j -- ) { if ( sortlist [ j ] < sortlist [ j - 1 ] ) { tmp = sortlist [ j - 1 ] ; sortlist [ j - 1 ] = sortlist [ j ] ; sortlist [ j ] = tmp ; } else break ; } } median = ( 1 + sortlist [ cpi -> common . MBs >> 1 ] + sortlist [ ( cpi -> common . MBs >> 1 ) + 1 ] ) >> 1 ; cpi -> activity_avg = median ; vpx_free ( sortlist ) ; } # else cpi -> activity_avg = ( unsigned int ) ( activity_sum / cpi -> common . MBs ) ; # endif if ( cpi -> activity_avg < VP8_ACTIVITY_AVG_MIN ) cpi -> activity_avg = VP8_ACTIVITY_AVG_MIN ; if ( ALT_ACT_MEASURE ) cpi -> activity_avg = 100000 ; }
","<S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( sortlist ,
"
252,"CWE-200 static int load_misc_binary ( struct linux_binprm * bprm ) { Node * fmt ; struct file * interp_file = NULL ; char iname [ BINPRM_BUF_SIZE ] ; const char * iname_addr = iname ; int retval ; int fd_binary = - 1 ; retval = - ENOEXEC ; if ( ! enabled ) goto _ret ; read_lock ( & entries_lock ) ; fmt = check_file ( bprm ) ; if ( fmt ) strlcpy ( iname , fmt -> interpreter , BINPRM_BUF_SIZE ) ; read_unlock ( & entries_lock ) ; if ( ! fmt ) goto _ret ; if ( ! ( fmt -> flags & MISC_FMT_PRESERVE_ARGV0 ) ) { retval = remove_arg_zero ( bprm ) ; if ( retval ) goto _ret ; } if ( fmt -> flags & MISC_FMT_OPEN_BINARY ) { fd_binary = get_unused_fd ( ) ; if ( fd_binary < 0 ) { retval = fd_binary ; goto _ret ; } fd_install ( fd_binary , bprm -> file ) ; would_dump ( bprm , bprm -> file ) ; allow_write_access ( bprm -> file ) ; bprm -> file = NULL ; bprm -> interp_flags |= BINPRM_FLAGS_EXECFD ; bprm -> interp_data = fd_binary ; } else { allow_write_access ( bprm -> file ) ; fput ( bprm -> file ) ; bprm -> file = NULL ; } retval = copy_strings_kernel ( 1 , & bprm -> interp , bprm ) ; if ( retval < 0 ) goto _error ; bprm -> argc ++ ; retval = copy_strings_kernel ( 1 , & iname_addr , bprm ) ; if ( retval < 0 ) goto _error ; bprm -> argc ++ ; <S2SV_StartBug> bprm -> interp = iname ; <S2SV_EndBug> interp_file = open_exec ( iname ) ; retval = PTR_ERR ( interp_file ) ; if ( IS_ERR ( interp_file ) ) goto _error ; bprm -> file = interp_file ; if ( fmt -> flags & MISC_FMT_CREDENTIALS ) { memset ( bprm -> buf , 0 , BINPRM_BUF_SIZE ) ; retval = kernel_read ( bprm -> file , 0 , bprm -> buf , BINPRM_BUF_SIZE ) ; } else retval = prepare_binprm ( bprm ) ; if ( retval < 0 ) goto _error ; retval = search_binary_handler ( bprm ) ; if ( retval < 0 ) goto _error ; _ret : return retval ; _error : if ( fd_binary > 0 ) sys_close ( fd_binary ) ; bprm -> interp_flags = 0 ; bprm -> interp_data = 0 ; goto _ret ; }
","<S2SV_ModStart> argc ++ ; retval = bprm_change_interp ( iname , bprm ) ; if ( retval < 0 ) goto _error <S2SV_ModEnd> ; interp_file =
"
253,"CWE-125 static inline LineContribType * _gdContributionsCalc ( unsigned int line_size , unsigned int src_size , double scale_d , const interpolation_method pFilter ) { double width_d ; double scale_f_d = 1.0 ; const double filter_width_d = DEFAULT_BOX_RADIUS ; int windows_size ; unsigned int u ; LineContribType * res ; if ( scale_d < 1.0 ) { width_d = filter_width_d / scale_d ; scale_f_d = scale_d ; } else { width_d = filter_width_d ; } windows_size = 2 * ( int ) ceil ( width_d ) + 1 ; res = _gdContributionsAlloc ( line_size , windows_size ) ; for ( u = 0 ; u < line_size ; u ++ ) { const double dCenter = ( double ) u / scale_d ; register int iLeft = MAX ( 0 , ( int ) floor ( dCenter - width_d ) ) ; int iRight = MIN ( ( int ) ceil ( dCenter + width_d ) , ( int ) src_size - 1 ) ; double dTotalWeight = 0.0 ; <S2SV_StartBug> int iSrc ; <S2SV_EndBug> res -> ContribRow [ u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; if ( iRight - iLeft + 1 > windows_size ) { if ( iLeft < ( ( int ) src_size - 1 / 2 ) ) { iLeft ++ ; } else { iRight -- ; } } <S2SV_StartBug> for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { <S2SV_EndBug> <S2SV_StartBug> dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ; <S2SV_EndBug> } if ( dTotalWeight < 0.0 ) { _gdContributionsFree ( res ) ; return NULL ; } if ( dTotalWeight > 0.0 ) { for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] /= dTotalWeight ; } } } return res ; }
","<S2SV_ModStart> ; int iSrc <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; } } <S2SV_ModEnd> res -> ContribRow <S2SV_ModStart> u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ] .
"
254,"CWE-416 int ipmi_destroy_user ( struct ipmi_user * user ) { <S2SV_StartBug> _ipmi_destroy_user ( user ) ; <S2SV_EndBug> cleanup_srcu_struct ( & user -> release_barrier ) ; kref_put ( & user -> refcount , free_user ) ; return 0 ; }
","<S2SV_ModStart> _ipmi_destroy_user ( user <S2SV_ModEnd> ) ; kref_put
"
255,"CWE-269 void Com_WriteConfig_f ( void ) { char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { <S2SV_StartBug> Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; <S2SV_EndBug> return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; COM_DefaultExtension ( filename , sizeof ( filename ) , "".cfg"" ) ; Com_Printf ( ""Writing<S2SV_blank>%s.\\n"" , filename ) ; Com_WriteConfigToFile ( filename ) ; }
","<S2SV_ModStart> Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; return ; } if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) { Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".cfg\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n""
"
256,"CWE-190 static int mongo_cursor_get_more ( mongo_cursor * cursor ) { int res ; if ( cursor -> limit > 0 && cursor -> seen >= cursor -> limit ) { cursor -> err = MONGO_CURSOR_EXHAUSTED ; return MONGO_ERROR ; } else if ( ! cursor -> reply ) { cursor -> err = MONGO_CURSOR_INVALID ; return MONGO_ERROR ; } else if ( ! cursor -> reply -> fields . cursorID ) { cursor -> err = MONGO_CURSOR_EXHAUSTED ; return MONGO_ERROR ; } else { char * data ; <S2SV_StartBug> int sl = strlen ( cursor -> ns ) + 1 ; <S2SV_EndBug> int limit = 0 ; mongo_message * mm ; if ( cursor -> limit > 0 ) limit = cursor -> limit - cursor -> seen ; mm = mongo_message_create ( 16 + 4 + sl + 4 + 8 , 0 , 0 , MONGO_OP_GET_MORE ) ; data = & mm -> data ; data = mongo_data_append32 ( data , & ZERO ) ; data = mongo_data_append ( data , cursor -> ns , sl ) ; data = mongo_data_append32 ( data , & limit ) ; mongo_data_append64 ( data , & cursor -> reply -> fields . cursorID ) ; bson_free ( cursor -> reply ) ; res = mongo_message_send ( cursor -> conn , mm ) ; if ( res != MONGO_OK ) { mongo_cursor_destroy ( cursor ) ; return MONGO_ERROR ; } res = mongo_read_response ( cursor -> conn , & ( cursor -> reply ) ) ; if ( res != MONGO_OK ) { mongo_cursor_destroy ( cursor ) ; return MONGO_ERROR ; } cursor -> current . data = NULL ; cursor -> seen += cursor -> reply -> fields . num ; return MONGO_OK ; } }
","<S2SV_ModStart> * data ; size_t <S2SV_ModEnd> sl = strlen
"
257,"CWE-189 static struct mobj * alloc_ta_mem ( size_t size ) { # ifdef CFG_PAGED_USER_TA return mobj_paged_alloc ( size ) ; # else struct mobj * mobj = mobj_mm_alloc ( mobj_sec_ddr , size , & tee_mm_sec_ddr ) ; <S2SV_StartBug> if ( mobj ) <S2SV_EndBug> <S2SV_StartBug> memset ( mobj_get_va ( mobj , 0 ) , 0 , size ) ; <S2SV_EndBug> return mobj ; # endif }
","<S2SV_ModStart> ( mobj ) { size_t granularity = BIT ( tee_mm_sec_ddr . shift ) ; <S2SV_ModStart> , 0 , ROUNDUP ( size , granularity ) ) ; } <S2SV_ModEnd> return mobj ;
"
258,"CWE-190 static void bump_cpu_timer ( struct k_itimer * timer , u64 now ) { int i ; u64 delta , incr ; if ( timer -> it . cpu . incr == 0 ) return ; if ( now < timer -> it . cpu . expires ) return ; incr = timer -> it . cpu . incr ; delta = now + incr - timer -> it . cpu . expires ; for ( i = 0 ; incr < delta - incr ; i ++ ) incr = incr << 1 ; for ( ; i >= 0 ; incr >>= 1 , i -- ) { if ( delta < incr ) continue ; timer -> it . cpu . expires += incr ; <S2SV_StartBug> timer -> it_overrun += 1 << i ; <S2SV_EndBug> delta -= incr ; } }
","<S2SV_ModStart> -> it_overrun += 1LL <S2SV_ModEnd> << i ;
"
259,"CWE-125 static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { comprehension_ty comp ; asdl_seq * t ; expr_ty expression , first ; node * for_ch ; <S2SV_StartBug> int is_async = 0 ; <S2SV_EndBug> REQ ( n , comp_for ) ; <S2SV_StartBug> if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) { <S2SV_EndBug> is_async = 1 ; <S2SV_StartBug> } <S2SV_EndBug> if ( is_async && c -> c_feature_version < 6 ) { ast_error ( c , n , ""Async<S2SV_blank>comprehensions<S2SV_blank>are<S2SV_blank>only<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>Python<S2SV_blank>3.6<S2SV_blank>and<S2SV_blank>greater"" ) ; return NULL ; } <S2SV_StartBug> for_ch = CHILD ( n , 1 + is_async ) ; <S2SV_EndBug> t = ast_for_exprlist ( c , for_ch , Store ) ; if ( ! t ) return NULL ; <S2SV_StartBug> expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ; <S2SV_EndBug> if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; <S2SV_StartBug> if ( NCH ( n ) == ( 5 + is_async ) ) { <S2SV_EndBug> int j , n_ifs ; asdl_seq * ifs ; <S2SV_StartBug> n = CHILD ( n , 4 + is_async ) ; <S2SV_EndBug> n_ifs = count_comp_ifs ( c , n ) ; if ( n_ifs == - 1 ) return NULL ; ifs = _Ta3_asdl_seq_new ( n_ifs , c -> c_arena ) ; if ( ! ifs ) return NULL ; for ( j = 0 ; j < n_ifs ; j ++ ) { REQ ( n , comp_iter ) ; n = CHILD ( n , 0 ) ; REQ ( n , comp_if ) ; expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ; if ( ! expression ) return NULL ; asdl_seq_SET ( ifs , j , expression ) ; if ( NCH ( n ) == 3 ) n = CHILD ( n , 2 ) ; } if ( TYPE ( n ) == comp_iter ) n = CHILD ( n , 0 ) ; comp -> ifs = ifs ; } asdl_seq_SET ( comps , i , comp ) ; } return comps ; }
","<S2SV_ModStart> * for_ch ; node * sync_n ; <S2SV_ModStart> ; if ( NCH ( n ) == 2 <S2SV_ModEnd> ) { is_async <S2SV_ModStart> = 1 ; REQ ( CHILD ( n , 0 ) , NAME ) ; assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , ""async"" ) == 0 ) ; sync_n = CHILD ( n , 1 ) ; } else { sync_n = CHILD ( n , 0 ) ; } REQ ( sync_n , sync_comp_for ) ; <S2SV_ModEnd> if ( is_async <S2SV_ModStart> = CHILD ( sync_n , 1 <S2SV_ModEnd> ) ; t <S2SV_ModStart> , CHILD ( sync_n , 3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( NCH ( sync_n ) == 5 <S2SV_ModEnd> ) { int <S2SV_ModStart> = CHILD ( sync_n , 4 <S2SV_ModEnd> ) ; n_ifs
"
260,"CWE-189 static int copy_verifier_state ( struct bpf_verifier_state * dst_state , const struct bpf_verifier_state * src ) { struct bpf_func_state * dst ; int i , err ; for ( i = src -> curframe + 1 ; i <= dst_state -> curframe ; i ++ ) { free_func_state ( dst_state -> frame [ i ] ) ; dst_state -> frame [ i ] = NULL ; <S2SV_StartBug> } <S2SV_EndBug> dst_state -> curframe = src -> curframe ; for ( i = 0 ; i <= src -> curframe ; i ++ ) { dst = dst_state -> frame [ i ] ; if ( ! dst ) { dst = kzalloc ( sizeof ( * dst ) , GFP_KERNEL ) ; if ( ! dst ) return - ENOMEM ; dst_state -> frame [ i ] = dst ; } err = copy_func_state ( dst , src -> frame [ i ] ) ; if ( err ) return err ; } return 0 ; }
","<S2SV_ModStart> NULL ; } dst_state -> speculative = src -> speculative ;
"
261,"CWE-119 <S2SV_StartBug> static void write_mb_modes_kf ( const VP9_COMP * cpi , MODE_INFO * * mi_8x8 , <S2SV_EndBug> <S2SV_StartBug> vp9_writer * w ) { <S2SV_EndBug> const VP9_COMMON * const cm = & cpi -> common ; const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; const struct segmentation * const seg = & cm -> seg ; const MODE_INFO * const mi = mi_8x8 [ 0 ] ; <S2SV_StartBug> const MODE_INFO * const above_mi = mi_8x8 [ - xd -> mi_stride ] ; <S2SV_EndBug> <S2SV_StartBug> const MODE_INFO * const left_mi = xd -> left_available ? mi_8x8 [ - 1 ] : NULL ; <S2SV_EndBug> const MB_MODE_INFO * const mbmi = & mi -> mbmi ; const BLOCK_SIZE bsize = mbmi -> sb_type ; if ( seg -> update_map ) write_segment_id ( w , seg , mbmi -> segment_id ) ; <S2SV_StartBug> write_skip ( cpi , mbmi -> segment_id , mi , w ) ; <S2SV_EndBug> if ( bsize >= BLOCK_8X8 && cm -> tx_mode == TX_MODE_SELECT ) <S2SV_StartBug> write_selected_tx_size ( cpi , mbmi -> tx_size , bsize , w ) ; <S2SV_EndBug> if ( bsize >= BLOCK_8X8 ) { write_intra_mode ( w , mbmi -> mode , get_y_mode_probs ( mi , above_mi , left_mi , 0 ) ) ; } else { const int num_4x4_w = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ bsize ] ; int idx , idy ; for ( idy = 0 ; idy < 2 ; idy += num_4x4_h ) { for ( idx = 0 ; idx < 2 ; idx += num_4x4_w ) { const int block = idy * 2 + idx ; write_intra_mode ( w , mi -> bmi [ block ] . as_mode , get_y_mode_probs ( mi , above_mi , left_mi , block ) ) ; } } } write_intra_mode ( w , mbmi -> uv_mode , vp9_kf_uv_mode_prob [ mbmi -> mode ] ) ; }
","<S2SV_ModStart> write_mb_modes_kf ( const VP9_COMMON * cm , const MACROBLOCKD * xd , <S2SV_ModEnd> MODE_INFO * * <S2SV_ModStart> * mi_8x8 , vpx_writer * w ) { <S2SV_ModEnd> const struct segmentation <S2SV_ModStart> const above_mi = xd -> above_mi <S2SV_ModEnd> ; const MODE_INFO <S2SV_ModStart> = xd -> left_mi <S2SV_ModEnd> ; const MB_MODE_INFO <S2SV_ModStart> ; write_skip ( cm , xd <S2SV_ModEnd> , mbmi -> <S2SV_ModStart> ) write_selected_tx_size ( cm , xd <S2SV_ModEnd> , w )
"
262,"CWE-284 int socket_create ( uint16_t port ) { int sfd = - 1 ; int yes = 1 ; # ifdef WIN32 WSADATA wsa_data ; if ( ! wsa_init ) { if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsa_data ) != ERROR_SUCCESS ) { fprintf ( stderr , ""WSAStartup<S2SV_blank>failed!\\n"" ) ; ExitProcess ( - 1 ) ; } wsa_init = 1 ; } # endif struct sockaddr_in saddr ; if ( 0 > ( sfd = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ) ) { perror ( ""socket()"" ) ; return - 1 ; } if ( setsockopt ( sfd , SOL_SOCKET , SO_REUSEADDR , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( ""setsockopt()"" ) ; socket_close ( sfd ) ; return - 1 ; } memset ( ( void * ) & saddr , 0 , sizeof ( saddr ) ) ; saddr . sin_family = AF_INET ; <S2SV_StartBug> saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> saddr . sin_port = htons ( port ) ; if ( 0 > bind ( sfd , ( struct sockaddr * ) & saddr , sizeof ( saddr ) ) ) { perror ( ""bind()"" ) ; socket_close ( sfd ) ; return - 1 ; } if ( listen ( sfd , 1 ) == - 1 ) { perror ( ""listen()"" ) ; socket_close ( sfd ) ; return - 1 ; } return sfd ; }
","<S2SV_ModStart> = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; saddr
"
263,"CWE-119 static void scsi_read_complete ( void * opaque , int ret ) { SCSIDiskReq * r = ( SCSIDiskReq * ) opaque ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; int n ; if ( r -> req . aiocb != NULL ) { r -> req . aiocb = NULL ; bdrv_acct_done ( s -> bs , & r -> acct ) ; } if ( ret ) { if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_READ ) ) { return ; } } <S2SV_StartBug> DPRINTF ( ""Data<S2SV_blank>ready<S2SV_blank>tag=0x%x<S2SV_blank>len=%zd\\n"" , r -> req . tag , r -> iov . iov_len ) ; <S2SV_EndBug> <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> r -> sector += n ; r -> sector_count -= n ; <S2SV_StartBug> scsi_req_data ( & r -> req , r -> iov . iov_len ) ; <S2SV_EndBug> }
","<S2SV_ModStart> , r -> qiov . size <S2SV_ModEnd> ) ; n <S2SV_ModStart> = r -> qiov . size <S2SV_ModEnd> / 512 ; <S2SV_ModStart> , r -> qiov . size <S2SV_ModEnd> ) ; }
"
264,"CWE-119 static int cqspi_setup_flash ( struct cqspi_st * cqspi , struct device_node * np ) { struct platform_device * pdev = cqspi -> pdev ; struct device * dev = & pdev -> dev ; struct cqspi_flash_pdata * f_pdata ; struct spi_nor * nor ; struct mtd_info * mtd ; unsigned int cs ; int i , ret ; for_each_available_child_of_node ( dev -> of_node , np ) { if ( of_property_read_u32 ( np , ""reg"" , & cs ) ) { dev_err ( dev , ""Couldn\'t<S2SV_blank>determine<S2SV_blank>chip<S2SV_blank>select.\\n"" ) ; goto err ; } <S2SV_StartBug> if ( cs > CQSPI_MAX_CHIPSELECT ) { <S2SV_EndBug> dev_err ( dev , ""Chip<S2SV_blank>select<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range.\\n"" , cs ) ; goto err ; } f_pdata = & cqspi -> f_pdata [ cs ] ; f_pdata -> cqspi = cqspi ; f_pdata -> cs = cs ; ret = cqspi_of_get_flash_pdata ( pdev , f_pdata , np ) ; if ( ret ) goto err ; nor = & f_pdata -> nor ; mtd = & nor -> mtd ; mtd -> priv = nor ; nor -> dev = dev ; spi_nor_set_flash_node ( nor , np ) ; nor -> priv = f_pdata ; nor -> read_reg = cqspi_read_reg ; nor -> write_reg = cqspi_write_reg ; nor -> read = cqspi_read ; nor -> write = cqspi_write ; nor -> erase = cqspi_erase ; nor -> prepare = cqspi_prep ; nor -> unprepare = cqspi_unprep ; mtd -> name = devm_kasprintf ( dev , GFP_KERNEL , ""%s.%d"" , dev_name ( dev ) , cs ) ; if ( ! mtd -> name ) { ret = - ENOMEM ; goto err ; } ret = spi_nor_scan ( nor , NULL , SPI_NOR_QUAD ) ; if ( ret ) goto err ; ret = mtd_device_register ( mtd , NULL , 0 ) ; if ( ret ) goto err ; f_pdata -> registered = true ; } return 0 ; err : for ( i = 0 ; i < CQSPI_MAX_CHIPSELECT ; i ++ ) if ( cqspi -> f_pdata [ i ] . registered ) mtd_device_unregister ( & cqspi -> f_pdata [ i ] . nor . mtd ) ; return ret ; }
","<S2SV_ModStart> if ( cs >= <S2SV_ModEnd> CQSPI_MAX_CHIPSELECT ) {
"
265,"CWE-119 int decompileAction ( int n , SWF_ACTION * actions , int maxn ) { <S2SV_StartBug> if ( n > maxn ) SWF_error ( ""Action<S2SV_blank>overflow!!"" ) ; <S2SV_EndBug> # ifdef DEBUG fprintf ( stderr , ""%d:\\tACTION[%3.3d]:<S2SV_blank>%s\\n"" , actions [ n ] . SWF_ACTIONRECORD . Offset , n , actionName ( actions [ n ] . SWF_ACTIONRECORD . ActionCode ) ) ; # endif <S2SV_StartBug> switch ( actions [ n ] . SWF_ACTIONRECORD . ActionCode ) <S2SV_EndBug> { case SWFACTION_END : return 0 ; case SWFACTION_CONSTANTPOOL : decompileCONSTANTPOOL ( & actions [ n ] ) ; return 0 ; case SWFACTION_GOTOLABEL : return decompileGOTOFRAME ( n , actions , maxn , 1 ) ; case SWFACTION_GOTOFRAME : return decompileGOTOFRAME ( n , actions , maxn , 0 ) ; case SWFACTION_GOTOFRAME2 : return decompileGOTOFRAME2 ( n , actions , maxn ) ; case SWFACTION_WAITFORFRAME : decompileWAITFORFRAME ( & actions [ n ] ) ; return 0 ; case SWFACTION_GETURL2 : decompileGETURL2 ( & actions [ n ] ) ; return 0 ; case SWFACTION_GETURL : decompileGETURL ( & actions [ n ] ) ; return 0 ; case SWFACTION_PUSH : decompilePUSH ( & actions [ n ] ) ; return 0 ; case SWFACTION_PUSHDUP : decompilePUSHDUP ( & actions [ n ] ) ; return 0 ; case SWFACTION_STACKSWAP : decompileSTACKSWAP ( & actions [ n ] ) ; return 0 ; case SWFACTION_SETPROPERTY : decompileSETPROPERTY ( n , actions , maxn ) ; return 0 ; case SWFACTION_GETPROPERTY : decompileGETPROPERTY ( n , actions , maxn ) ; return 0 ; case SWFACTION_GETTIME : return decompileGETTIME ( n , actions , maxn ) ; case SWFACTION_TRACE : decompileTRACE ( n , actions , maxn ) ; return 0 ; case SWFACTION_CALLFRAME : decompileCALLFRAME ( n , actions , maxn ) ; return 0 ; case SWFACTION_EXTENDS : decompileEXTENDS ( n , actions , maxn ) ; return 0 ; case SWFACTION_INITOBJECT : decompileINITOBJECT ( n , actions , maxn ) ; return 0 ; case SWFACTION_NEWOBJECT : decompileNEWOBJECT ( n , actions , maxn ) ; return 0 ; case SWFACTION_NEWMETHOD : decompileNEWMETHOD ( n , actions , maxn ) ; return 0 ; case SWFACTION_GETMEMBER : decompileGETMEMBER ( n , actions , maxn ) ; return 0 ; case SWFACTION_SETMEMBER : decompileSETMEMBER ( n , actions , maxn ) ; return 0 ; case SWFACTION_GETVARIABLE : decompileGETVARIABLE ( n , actions , maxn ) ; return 0 ; case SWFACTION_SETVARIABLE : decompileSETVARIABLE ( n , actions , maxn , 0 ) ; return 0 ; case SWFACTION_DEFINELOCAL : decompileSETVARIABLE ( n , actions , maxn , 1 ) ; return 0 ; case SWFACTION_DEFINELOCAL2 : decompileDEFINELOCAL2 ( n , actions , maxn ) ; return 0 ; case SWFACTION_DECREMENT : return decompileINCR_DECR ( n , actions , maxn , 0 ) ; case SWFACTION_INCREMENT : return decompileINCR_DECR ( n , actions , maxn , 1 ) ; case SWFACTION_STOREREGISTER : decompileSTOREREGISTER ( n , actions , maxn ) ; return 0 ; case SWFACTION_JUMP : return decompileJUMP ( n , actions , maxn ) ; case SWFACTION_RETURN : decompileRETURN ( n , actions , maxn ) ; return 0 ; case SWFACTION_LOGICALNOT : return decompileLogicalNot ( n , actions , maxn ) ; case SWFACTION_IF : return decompileIF ( n , actions , maxn ) ; case SWFACTION_WITH : decompileWITH ( n , actions , maxn ) ; return 0 ; case SWFACTION_ENUMERATE : return decompileENUMERATE ( n , actions , maxn , 0 ) ; case SWFACTION_ENUMERATE2 : return decompileENUMERATE ( n , actions , maxn , 1 ) ; case SWFACTION_INITARRAY : return decompileINITARRAY ( n , actions , maxn ) ; case SWFACTION_DEFINEFUNCTION : return decompileDEFINEFUNCTION ( n , actions , maxn , 0 ) ; case SWFACTION_DEFINEFUNCTION2 : return decompileDEFINEFUNCTION ( n , actions , maxn , 1 ) ; case SWFACTION_CALLFUNCTION : return decompileCALLFUNCTION ( n , actions , maxn ) ; case SWFACTION_CALLMETHOD : return decompileCALLMETHOD ( n , actions , maxn ) ; case SWFACTION_INSTANCEOF : case SWFACTION_SHIFTLEFT : case SWFACTION_SHIFTRIGHT : case SWFACTION_SHIFTRIGHT2 : case SWFACTION_ADD : case SWFACTION_ADD2 : case SWFACTION_SUBTRACT : case SWFACTION_MULTIPLY : case SWFACTION_DIVIDE : case SWFACTION_MODULO : case SWFACTION_BITWISEAND : case SWFACTION_BITWISEOR : case SWFACTION_BITWISEXOR : case SWFACTION_EQUAL : case SWFACTION_EQUALS2 : case SWFACTION_LESS2 : case SWFACTION_LOGICALAND : case SWFACTION_LOGICALOR : case SWFACTION_GREATER : case SWFACTION_LESSTHAN : case SWFACTION_STRINGEQ : case SWFACTION_STRINGCOMPARE : case SWFACTION_STRICTEQUALS : return decompileArithmeticOp ( n , actions , maxn ) ; case SWFACTION_POP : pop ( ) ; return 0 ; case SWFACTION_STARTDRAG : return decompileSTARTDRAG ( n , actions , maxn ) ; case SWFACTION_DELETE : return decompileDELETE ( n , actions , maxn , 0 ) ; case SWFACTION_DELETE2 : return decompileDELETE ( n , actions , maxn , 1 ) ; case SWFACTION_TARGETPATH : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""targetPath"" ) ; case SWFACTION_TYPEOF : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""typeof"" ) ; case SWFACTION_ORD : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""ord"" ) ; case SWFACTION_CHR : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""chr"" ) ; case SWFACTION_INT : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""int"" ) ; case SWFACTION_TOSTRING : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""String"" ) ; case SWFACTION_TONUMBER : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""Number"" ) ; case SWFACTION_RANDOMNUMBER : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""random"" ) ; case SWFACTION_STRINGLENGTH : return decompileSingleArgBuiltInFunctionCall ( n , actions , maxn , ""length"" ) ; case SWFACTION_PLAY : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""play"" ) ; case SWFACTION_STOP : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""stop"" ) ; case SWFACTION_NEXTFRAME : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""nextFrame"" ) ; case SWFACTION_PREVFRAME : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""prevFrame"" ) ; case SWFACTION_ENDDRAG : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""stopDrag"" ) ; case SWFACTION_STOPSOUNDS : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""stopAllSounds"" ) ; case SWFACTION_TOGGLEQUALITY : return decompile_Null_ArgBuiltInFunctionCall ( n , actions , maxn , ""toggleHighQuality"" ) ; case SWFACTION_MBSUBSTRING : case SWFACTION_SUBSTRING : return decompileSUBSTRING ( n , actions , maxn ) ; case SWFACTION_STRINGCONCAT : return decompileSTRINGCONCAT ( n , actions , maxn ) ; case SWFACTION_REMOVECLIP : return decompileREMOVECLIP ( n , actions , maxn ) ; case SWFACTION_DUPLICATECLIP : return decompileDUPLICATECLIP ( n , actions , maxn ) ; case SWFACTION_SETTARGET : return decompileSETTARGET ( n , actions , maxn , 0 ) ; case SWFACTION_SETTARGET2 : return decompileSETTARGET ( n , actions , maxn , 1 ) ; case SWFACTION_IMPLEMENTSOP : return decompileIMPLEMENTS ( n , actions , maxn ) ; case SWFACTION_CASTOP : return decompileCAST ( n , actions , maxn ) ; case SWFACTION_THROW : return decompileTHROW ( n , actions , maxn ) ; case SWFACTION_TRY : return decompileTRY ( n , actions , maxn ) ; default : outputSWF_ACTION ( n , & actions [ n ] ) ; return 0 ; } }
","<S2SV_ModStart> maxn ) { <S2SV_ModEnd> # ifdef DEBUG <S2SV_ModStart> endif switch ( OpCode ( actions , n , maxn ) <S2SV_ModEnd> ) { case
"
266,"CWE-119 static enum fetch_step vbf_stp_error ( struct worker * wrk , struct busyobj * bo ) { ssize_t l , ll , o ; double now ; uint8_t * ptr ; struct vsb * synth_body ; CHECK_OBJ_NOTNULL ( wrk , WORKER_MAGIC ) ; CHECK_OBJ_NOTNULL ( bo , BUSYOBJ_MAGIC ) ; CHECK_OBJ_NOTNULL ( bo -> fetch_objcore , OBJCORE_MAGIC ) ; AN ( bo -> fetch_objcore -> flags & OC_F_BUSY ) ; assert ( bo -> director_state == DIR_S_NULL ) ; wrk -> stats -> fetch_failed ++ ; now = W_TIM_real ( wrk ) ; VSLb_ts_busyobj ( bo , ""Error"" , now ) ; if ( bo -> fetch_objcore -> stobj -> stevedore != NULL ) ObjFreeObj ( bo -> wrk , bo -> fetch_objcore ) ; HTTP_Setup ( bo -> beresp , bo -> ws , bo -> vsl , SLT_BerespMethod ) ; http_PutResponse ( bo -> beresp , ""HTTP/1.1"" , 503 , ""Backend<S2SV_blank>fetch<S2SV_blank>failed"" ) ; http_TimeHeader ( bo -> beresp , ""Date:<S2SV_blank>"" , now ) ; http_SetHeader ( bo -> beresp , ""Server:<S2SV_blank>Varnish"" ) ; bo -> fetch_objcore -> t_origin = now ; if ( ! VTAILQ_EMPTY ( & bo -> fetch_objcore -> objhead -> waitinglist ) ) { bo -> fetch_objcore -> ttl = 1 ; bo -> fetch_objcore -> grace = 5 ; bo -> fetch_objcore -> keep = 5 ; } else { bo -> fetch_objcore -> ttl = 0 ; bo -> fetch_objcore -> grace = 0 ; bo -> fetch_objcore -> keep = 0 ; } synth_body = VSB_new_auto ( ) ; AN ( synth_body ) ; VCL_backend_error_method ( bo -> vcl , wrk , NULL , bo , synth_body ) ; AZ ( VSB_finish ( synth_body ) ) ; if ( wrk -> handling == VCL_RET_ABANDON || wrk -> handling == VCL_RET_FAIL ) { VSB_destroy ( & synth_body ) ; return ( F_STP_FAIL ) ; } if ( wrk -> handling == VCL_RET_RETRY ) { VSB_destroy ( & synth_body ) ; if ( bo -> retries ++ < cache_param -> max_retries ) return ( F_STP_RETRY ) ; VSLb ( bo -> vsl , SLT_VCL_Error , ""Too<S2SV_blank>many<S2SV_blank>retries,<S2SV_blank>failing"" ) ; return ( F_STP_FAIL ) ; } assert ( wrk -> handling == VCL_RET_DELIVER ) ; bo -> vfc -> bo = bo ; bo -> vfc -> wrk = bo -> wrk ; bo -> vfc -> oc = bo -> fetch_objcore ; bo -> vfc -> http = bo -> beresp ; bo -> vfc -> esi_req = bo -> bereq ; if ( vbf_beresp2obj ( bo ) ) { ( void ) VFP_Error ( bo -> vfc , ""Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>storage"" ) ; VSB_destroy ( & synth_body ) ; return ( F_STP_FAIL ) ; } ll = VSB_len ( synth_body ) ; o = 0 ; while ( ll > 0 ) { l = ll ; if ( VFP_GetStorage ( bo -> vfc , & l , & ptr ) != VFP_OK ) break ; <S2SV_StartBug> memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ; <S2SV_EndBug> VFP_Extend ( bo -> vfc , l ) ; ll -= l ; o += l ; } AZ ( ObjSetU64 ( wrk , bo -> fetch_objcore , OA_LEN , o ) ) ; VSB_destroy ( & synth_body ) ; HSH_Unbusy ( wrk , bo -> fetch_objcore ) ; ObjSetState ( wrk , bo -> fetch_objcore , BOS_FINISHED ) ; return ( F_STP_DONE ) ; }
","<S2SV_ModStart> ) break ; if ( l > ll ) l = ll ;
"
267,"CWE-119 int mlx4_register_vlan ( struct mlx4_dev * dev , u8 port , u16 vlan , int * index ) { struct mlx4_vlan_table * table = & mlx4_priv ( dev ) -> port [ port ] . vlan_table ; int i , err = 0 ; int free = - 1 ; mutex_lock ( & table -> mutex ) ; for ( i = MLX4_VLAN_REGULAR ; i < MLX4_MAX_VLAN_NUM ; i ++ ) { if ( free < 0 && ( table -> refs [ i ] == 0 ) ) { free = i ; continue ; } if ( table -> refs [ i ] && ( vlan == ( MLX4_VLAN_MASK & be32_to_cpu ( table -> entries [ i ] ) ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; <S2SV_StartBug> } <S2SV_EndBug> } if ( table -> total == table -> max ) { err = - ENOSPC ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be32 ( vlan | MLX4_VLAN_VALID ) ; err = mlx4_set_port_vlan_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_warn ( dev , ""Failed<S2SV_blank>adding<S2SV_blank>vlan:<S2SV_blank>%u\\n"" , vlan ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }
","<S2SV_ModStart> out ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ;
"
268,"CWE-125 static int wb_prep ( netdissect_options * ndo , const struct pkt_prep * prep , u_int len ) { int n ; const struct pgstate * ps ; const u_char * ep = ndo -> ndo_snapend ; ND_PRINT ( ( ndo , ""<S2SV_blank>wb-prep:"" ) ) ; <S2SV_StartBug> if ( len < sizeof ( * prep ) ) { <S2SV_EndBug> return ( - 1 ) ; <S2SV_StartBug> } <S2SV_EndBug> n = EXTRACT_32BITS ( & prep -> pp_n ) ; ps = ( const struct pgstate * ) ( prep + 1 ) ; while ( -- n >= 0 && ND_TTEST ( * ps ) ) { const struct id_off * io , * ie ; char c = '<' ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u"" , EXTRACT_32BITS ( & ps -> slot ) , ipaddr_string ( ndo , & ps -> page . p_sid ) , EXTRACT_32BITS ( & ps -> page . p_uid ) ) ) ; io = ( const struct id_off * ) ( ps + 1 ) ; for ( ie = io + ps -> nid ; io < ie && ND_TTEST ( * io ) ; ++ io ) { ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } ND_PRINT ( ( ndo , "">"" ) ) ; ps = ( const struct pgstate * ) io ; } return ( ( const u_char * ) ps <= ep ? 0 : - 1 ) ; }
","<S2SV_ModStart> * prep ) || ! ND_TTEST ( * prep ) ) <S2SV_ModEnd> return ( - <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> n = EXTRACT_32BITS
"
269,"CWE-835 static void put_prev_task ( struct rq * rq , struct task_struct * prev ) { if ( prev -> se . on_rq ) update_rq_clock ( rq ) ; <S2SV_StartBug> rq -> skip_clock_update = 0 ; <S2SV_EndBug> prev -> sched_class -> put_prev_task ( rq , prev ) ; }
","<S2SV_ModStart> rq ) ; <S2SV_ModEnd> prev -> sched_class
"
270,"CWE-119 static int atusb_read_reg ( struct atusb * atusb , uint8_t reg ) { struct usb_device * usb_dev = atusb -> usb_dev ; int ret ; <S2SV_StartBug> uint8_t value ; <S2SV_EndBug> dev_dbg ( & usb_dev -> dev , ""atusb:<S2SV_blank>reg<S2SV_blank>=<S2SV_blank>0x%x\\n"" , reg ) ; ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_REG_READ , ATUSB_REQ_FROM_DEV , <S2SV_StartBug> 0 , reg , & value , 1 , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> return ret >= 0 ? value : ret ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ret ; uint8_t * buffer ; uint8_t value ; buffer = kmalloc ( 1 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> ; dev_dbg ( <S2SV_ModStart> , reg , buffer <S2SV_ModEnd> , 1 , <S2SV_ModStart> 1000 ) ; if ( <S2SV_ModEnd> ret >= 0 <S2SV_ModStart> ret >= 0 ) { value = buffer [ 0 ] ; kfree ( buffer ) ; return value ; } else { kfree ( buffer ) ; return <S2SV_ModEnd> ret ; } <S2SV_ModStart> ret ; } }
"
271,"CWE-190 <S2SV_StartBug> static void addModuleArgument ( sqlite3 * db , Table * pTable , char * zArg ) { <S2SV_EndBug> <S2SV_StartBug> int nBytes = sizeof ( char * ) * ( 2 + pTable -> nModuleArg ) ; <S2SV_EndBug> <S2SV_StartBug> char * * azModuleArg ; <S2SV_EndBug> azModuleArg = sqlite3DbRealloc ( db , pTable -> azModuleArg , nBytes ) ; if ( azModuleArg == 0 ) { sqlite3DbFree ( db , zArg ) ; } else { int i = pTable -> nModuleArg ++ ; azModuleArg [ i ] = zArg ; azModuleArg [ i + 1 ] = 0 ; pTable -> azModuleArg = azModuleArg ; } }
","<S2SV_ModStart> void addModuleArgument ( Parse * pParse <S2SV_ModEnd> , Table * <S2SV_ModStart> zArg ) { sqlite3_int64 <S2SV_ModEnd> nBytes = sizeof <S2SV_ModStart> * azModuleArg ; sqlite3 * db = pParse -> db ; if ( pTable -> nModuleArg + 3 >= db -> aLimit [ SQLITE_LIMIT_COLUMN ] ) { sqlite3ErrorMsg ( pParse , ""too<S2SV_blank>many<S2SV_blank>columns<S2SV_blank>on<S2SV_blank>%s"" , pTable -> zName ) ; }
"
272,"CWE-119 void xmlrpc_char_encode ( char * outbuffer , const char * s1 ) { long unsigned int i ; unsigned char c ; char buf2 [ 15 ] ; mowgli_string_t * s = mowgli_string_create ( ) ; * buf2 = '\\0' ; * outbuffer = '\\0' ; if ( ( ! ( s1 ) || ( * ( s1 ) == '\\0' ) ) ) { return ; } for ( i = 0 ; s1 [ i ] != '\\0' ; i ++ ) { c = s1 [ i ] ; if ( c > 127 ) { snprintf ( buf2 , sizeof buf2 , ""&#%d;"" , c ) ; s -> append ( s , buf2 , strlen ( buf2 ) ) ; } else if ( c == '&' ) { s -> append ( s , ""&amp;"" , 5 ) ; } else if ( c == '<' ) { s -> append ( s , ""&lt;"" , 4 ) ; } else if ( c == '>' ) { s -> append ( s , ""&gt;"" , 4 ) ; } else if ( c == \'""\' ) { s -> append ( s , ""&quot;"" , 6 ) ; } else { s -> append_char ( s , c ) ; } } <S2SV_StartBug> memcpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ; } } s -> append_char ( s , 0 ) ; strncpy <S2SV_ModEnd> ( outbuffer ,
"
273,"CWE-000 static cmsPipeline * DefaultICCintents ( cmsContext ContextID , cmsUInt32Number nProfiles , cmsUInt32Number TheIntents [ ] , cmsHPROFILE hProfiles [ ] , cmsBool BPC [ ] , cmsFloat64Number AdaptationStates [ ] , cmsUInt32Number dwFlags ) { cmsPipeline * Lut = NULL ; cmsPipeline * Result ; cmsHPROFILE hProfile ; cmsMAT3 m ; cmsVEC3 off ; cmsColorSpaceSignature ColorSpaceIn , ColorSpaceOut , CurrentColorSpace ; cmsProfileClassSignature ClassSig ; cmsUInt32Number i , Intent ; if ( nProfiles == 0 ) return NULL ; Result = cmsPipelineAlloc ( ContextID , 0 , 0 ) ; if ( Result == NULL ) return NULL ; CurrentColorSpace = cmsGetColorSpace ( hProfiles [ 0 ] ) ; for ( i = 0 ; i < nProfiles ; i ++ ) { cmsBool lIsDeviceLink , lIsInput ; hProfile = hProfiles [ i ] ; ClassSig = cmsGetDeviceClass ( hProfile ) ; lIsDeviceLink = ( ClassSig == cmsSigLinkClass || ClassSig == cmsSigAbstractClass ) ; if ( ( i == 0 ) && ! lIsDeviceLink ) { lIsInput = TRUE ; } else { lIsInput = ( CurrentColorSpace != cmsSigXYZData ) && ( CurrentColorSpace != cmsSigLabData ) ; } Intent = TheIntents [ i ] ; if ( lIsInput || lIsDeviceLink ) { ColorSpaceIn = cmsGetColorSpace ( hProfile ) ; ColorSpaceOut = cmsGetPCS ( hProfile ) ; } else { ColorSpaceIn = cmsGetPCS ( hProfile ) ; ColorSpaceOut = cmsGetColorSpace ( hProfile ) ; } if ( ! ColorSpaceIsCompatible ( ColorSpaceIn , CurrentColorSpace ) ) { cmsSignalError ( ContextID , cmsERROR_COLORSPACE_CHECK , ""ColorSpace<S2SV_blank>mismatch"" ) ; goto Error ; } if ( lIsDeviceLink || ( ( ClassSig == cmsSigNamedColorClass ) && ( nProfiles == 1 ) ) ) { Lut = _cmsReadDevicelinkLUT ( hProfile , Intent ) ; if ( Lut == NULL ) goto Error ; if ( ClassSig == cmsSigAbstractClass && i > 0 ) { if ( ! ComputeConversion ( i , hProfiles , Intent , BPC [ i ] , AdaptationStates [ i ] , & m , & off ) ) goto Error ; } else { _cmsMAT3identity ( & m ) ; _cmsVEC3init ( & off , 0 , 0 , 0 ) ; } if ( ! AddConversion ( Result , CurrentColorSpace , ColorSpaceIn , & m , & off ) ) goto Error ; } else { if ( lIsInput ) { Lut = _cmsReadInputLUT ( hProfile , Intent ) ; if ( Lut == NULL ) goto Error ; } else { Lut = _cmsReadOutputLUT ( hProfile , Intent ) ; if ( Lut == NULL ) goto Error ; if ( ! ComputeConversion ( i , hProfiles , Intent , BPC [ i ] , AdaptationStates [ i ] , & m , & off ) ) goto Error ; if ( ! AddConversion ( Result , CurrentColorSpace , ColorSpaceIn , & m , & off ) ) goto Error ; } } if ( ! cmsPipelineCat ( Result , Lut ) ) goto Error ; cmsPipelineFree ( Lut ) ; <S2SV_StartBug> CurrentColorSpace = ColorSpaceOut ; <S2SV_EndBug> } return Result ; Error : <S2SV_StartBug> cmsPipelineFree ( Lut ) ; <S2SV_EndBug> if ( Result != NULL ) cmsPipelineFree ( Result ) ; return NULL ; cmsUNUSED_PARAMETER ( dwFlags ) ; }
","<S2SV_ModStart> Lut ) ; Lut = NULL ; <S2SV_ModStart> ; Error : if ( Lut != NULL )
"
274,"CWE-125 static void process_constructors ( RBinFile * bf , RList * ret , int bits ) { RList * secs = sections ( bf ) ; RListIter * iter ; RBinSection * sec ; int i , type ; r_list_foreach ( secs , iter , sec ) { type = - 1 ; if ( ! strcmp ( sec -> name , "".fini_array"" ) ) { type = R_BIN_ENTRY_TYPE_FINI ; } else if ( ! strcmp ( sec -> name , "".init_array"" ) ) { type = R_BIN_ENTRY_TYPE_INIT ; } else if ( ! strcmp ( sec -> name , "".preinit_array"" ) ) { type = R_BIN_ENTRY_TYPE_PREINIT ; } if ( type != - 1 ) { ut8 * buf = calloc ( sec -> size , 1 ) ; if ( ! buf ) { continue ; } ( void ) r_buf_read_at ( bf -> buf , sec -> paddr , buf , sec -> size ) ; if ( bits == 32 ) { <S2SV_StartBug> for ( i = 0 ; i < sec -> size ; i += 4 ) { <S2SV_EndBug> ut32 addr32 = r_read_le32 ( buf + i ) ; if ( addr32 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , ( ut64 ) addr32 , type , bits ) ; r_list_append ( ret , ba ) ; } } } else { <S2SV_StartBug> for ( i = 0 ; i < sec -> size ; i += 8 ) { <S2SV_EndBug> ut64 addr64 = r_read_le64 ( buf + i ) ; if ( addr64 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , addr64 , type , bits ) ; r_list_append ( ret , ba ) ; } } } free ( buf ) ; } } r_list_free ( secs ) ; }
","<S2SV_ModStart> = 0 ; ( i + 3 ) <S2SV_ModEnd> < sec -> <S2SV_ModStart> = 0 ; ( i + 7 ) <S2SV_ModEnd> < sec ->
"
275,"CWE-125 static int isis_print_is_reach_subtlv ( netdissect_options * ndo , const uint8_t * tptr , u_int subt , u_int subl , const char * ident ) { u_int te_class , priority_level , gmpls_switch_cap ; union { float f ; uint32_t i ; } bw ; ND_PRINT ( ( ndo , ""%s%s<S2SV_blank>subTLV<S2SV_blank>#%u,<S2SV_blank>length:<S2SV_blank>%u"" , ident , tok2str ( isis_ext_is_reach_subtlv_values , ""unknown"" , subt ) , subt , subl ) ) ; ND_TCHECK2 ( * tptr , subl ) ; switch ( subt ) { case ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUP : case ISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_ID : case ISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID : if ( subl >= 4 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; if ( subl == 8 ) ND_PRINT ( ( ndo , "",<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr + 4 ) ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR : case ISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR : if ( subl >= sizeof ( struct in_addr ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case ISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BW : case ISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW : if ( subl >= 4 ) { bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW : if ( subl >= 32 ) { for ( te_class = 0 ; te_class < 8 ; te_class ++ ) { bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>TE-Class<S2SV_blank>%u:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , te_class , bw . f * 8 / 1000000 ) ) ; tptr += 4 ; } } break ; case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS : case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD : <S2SV_StartBug> ND_PRINT ( ( ndo , ""%sBandwidth<S2SV_blank>Constraints<S2SV_blank>Model<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(%u)"" , <S2SV_EndBug> ident , tok2str ( diffserv_te_bc_values , ""unknown"" , * tptr ) , * tptr ) ) ; tptr ++ ; for ( te_class = 0 ; te_class < ( subl - 1 ) / 4 ; te_class ++ ) { <S2SV_StartBug> ND_TCHECK2 ( * tptr , 4 ) ; <S2SV_EndBug> bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Bandwidth<S2SV_blank>constraint<S2SV_blank>CT%u:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , te_class , bw . f * 8 / 1000000 ) ) ; tptr += 4 ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_TE_METRIC : if ( subl >= 3 ) ND_PRINT ( ( ndo , "",<S2SV_blank>%u"" , EXTRACT_24BITS ( tptr ) ) ) ; break ; case ISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE : if ( subl == 2 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>[<S2SV_blank>%s<S2SV_blank>]<S2SV_blank>(0x%04x)"" , bittok2str ( isis_subtlv_link_attribute_values , ""Unknown"" , EXTRACT_16BITS ( tptr ) ) , EXTRACT_16BITS ( tptr ) ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE : if ( subl >= 2 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>%s,<S2SV_blank>Priority<S2SV_blank>%u"" , bittok2str ( gmpls_link_prot_values , ""none"" , * tptr ) , * ( tptr + 1 ) ) ) ; } break ; case ISIS_SUBTLV_SPB_METRIC : if ( subl >= 6 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>LM:<S2SV_blank>%u"" , EXTRACT_24BITS ( tptr ) ) ) ; tptr = tptr + 3 ; ND_PRINT ( ( ndo , "",<S2SV_blank>P:<S2SV_blank>%u"" , * ( tptr ) ) ) ; tptr ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>P-ID:<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr ) ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR : if ( subl >= 36 ) { gmpls_switch_cap = * tptr ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Interface<S2SV_blank>Switching<S2SV_blank>Capability:%s"" , ident , tok2str ( gmpls_switch_cap_values , ""Unknown"" , gmpls_switch_cap ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>LSP<S2SV_blank>Encoding:<S2SV_blank>%s"" , tok2str ( gmpls_encoding_values , ""Unknown"" , * ( tptr + 1 ) ) ) ) ; tptr += 4 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Max<S2SV_blank>LSP<S2SV_blank>Bandwidth:"" , ident ) ) ; for ( priority_level = 0 ; priority_level < 8 ; priority_level ++ ) { bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>priority<S2SV_blank>level<S2SV_blank>%d:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , priority_level , bw . f * 8 / 1000000 ) ) ; tptr += 4 ; } subl -= 36 ; switch ( gmpls_switch_cap ) { case GMPLS_PSC1 : case GMPLS_PSC2 : case GMPLS_PSC3 : case GMPLS_PSC4 : ND_TCHECK2 ( * tptr , 6 ) ; bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Min<S2SV_blank>LSP<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Interface<S2SV_blank>MTU:<S2SV_blank>%u"" , ident , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case GMPLS_TSC : ND_TCHECK2 ( * tptr , 8 ) ; bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Min<S2SV_blank>LSP<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Indication<S2SV_blank>%s"" , ident , tok2str ( gmpls_switch_cap_tsc_indication_values , ""Unknown<S2SV_blank>(%u)"" , * ( tptr + 4 ) ) ) ) ; break ; default : if ( subl > 0 ) { if ( ! print_unknown_data ( ndo , tptr , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , subl ) ) return ( 0 ) ; } } } break ; default : if ( ! print_unknown_data ( ndo , tptr , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , subl ) ) return ( 0 ) ; break ; } return ( 1 ) ; trunc : return ( 0 ) ; }
","<S2SV_ModStart> case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD : if ( subl == 0 ) break ; <S2SV_ModStart> ++ ) { <S2SV_ModEnd> bw . i
"
276,"CWE-787 WORD32 ixheaacd_complex_anal_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer ) { WORD32 idx ; WORD32 anal_size = 2 * ptr_hbe_txposer -> synth_size ; WORD32 N = ( 10 * anal_size ) ; for ( idx = 0 ; idx < ( ptr_hbe_txposer -> no_bins >> 1 ) ; idx ++ ) { WORD32 i , j , k , l ; FLOAT32 window_output [ 640 ] ; FLOAT32 u [ 128 ] , u_in [ 256 ] , u_out [ 256 ] ; FLOAT32 accu_r , accu_i ; const FLOAT32 * inp_signal ; FLOAT32 * anal_buf ; FLOAT32 * analy_cos_sin_tab = ptr_hbe_txposer -> analy_cos_sin_tab ; const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> analy_wind_coeff ; FLOAT32 * x = ptr_hbe_txposer -> analy_buf ; memset ( ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] , 0 , TWICE_QMF_SYNTH_CHANNELS_NUM * sizeof ( FLOAT32 ) ) ; inp_signal = ptr_hbe_txposer -> ptr_input_buf + idx * 2 * ptr_hbe_txposer -> synth_size + 1 ; anal_buf = & ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] [ 4 * ptr_hbe_txposer -> k_start ] ; for ( i = N - 1 ; i >= anal_size ; i -- ) { x [ i ] = x [ i - anal_size ] ; } for ( i = anal_size - 1 ; i >= 0 ; i -- ) { x [ i ] = inp_signal [ anal_size - 1 - i ] ; } for ( i = 0 ; i < N ; i ++ ) { window_output [ i ] = x [ i ] * interp_window_coeff [ i ] ; } for ( i = 0 ; i < 2 * anal_size ; i ++ ) { accu_r = 0.0 ; for ( j = 0 ; j < 5 ; j ++ ) { accu_r = accu_r + window_output [ i + j * 2 * anal_size ] ; } u [ i ] = accu_r ; } if ( anal_size == 40 ) { for ( i = 1 ; i < anal_size ; i ++ ) { FLOAT32 temp1 = u [ i ] + u [ 2 * anal_size - i ] ; FLOAT32 temp2 = u [ i ] - u [ 2 * anal_size - i ] ; u [ i ] = temp1 ; u [ 2 * anal_size - i ] = temp2 ; } for ( k = 0 ; k < anal_size ; k ++ ) { accu_r = u [ anal_size ] ; if ( k & 1 ) accu_i = u [ 0 ] ; else accu_i = - u [ 0 ] ; for ( l = 1 ; l < anal_size ; l ++ ) { accu_r = accu_r + u [ 0 + l ] * analy_cos_sin_tab [ 2 * l + 0 ] ; accu_i = accu_i + u [ 2 * anal_size - l ] * analy_cos_sin_tab [ 2 * l + 1 ] ; } analy_cos_sin_tab += ( 2 * anal_size ) ; * anal_buf ++ = ( FLOAT32 ) accu_r ; * anal_buf ++ = ( FLOAT32 ) accu_i ; } } else { FLOAT32 * ptr_u = u_in ; FLOAT32 * ptr_v = u_out ; for ( k = 0 ; k < anal_size * 2 ; k ++ ) { * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; } <S2SV_StartBug> if ( ixheaacd_cmplx_anal_fft != NULL ) <S2SV_EndBug> <S2SV_StartBug> ( * ixheaacd_cmplx_anal_fft ) ( u_in , u_out , anal_size * 2 ) ; <S2SV_EndBug> else return - 1 ; for ( k = 0 ; k < anal_size / 2 ; k ++ ) { * ( anal_buf + 1 ) = - * ptr_v ++ ; * anal_buf = * ptr_v ++ ; anal_buf += 2 ; * ( anal_buf + 1 ) = * ptr_v ++ ; * anal_buf = - * ptr_v ++ ; anal_buf += 2 ; } } } return 0 ; }
","<S2SV_ModStart> } if ( ptr_hbe_txposer -> <S2SV_ModStart> ) ( * ( ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft ) ) <S2SV_ModEnd> ( u_in ,
"
277,"CWE-125 static int forward_search_range ( regex_t * reg , const UChar * str , const UChar * end , UChar * s , UChar * range , UChar * * low , UChar * * high , UChar * * low_prev ) { UChar * p , * pprev = ( UChar * ) NULL ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range:<S2SV_blank>str:<S2SV_blank>%d,<S2SV_blank>end:<S2SV_blank>%d,<S2SV_blank>s:<S2SV_blank>%d,<S2SV_blank>range:<S2SV_blank>%d\\n"" , ( int ) str , ( int ) end , ( int ) s , ( int ) range ) ; # endif p = s ; if ( reg -> dmin > 0 ) { if ( ONIGENC_IS_SINGLEBYTE ( reg -> enc ) ) { p += reg -> dmin ; } else { UChar * q = p + reg -> dmin ; <S2SV_StartBug> while ( p < q ) p += enclen ( reg -> enc , p ) ; <S2SV_EndBug> } } retry : switch ( reg -> optimize ) { case ONIG_OPTIMIZE_EXACT : p = slow_search ( reg -> enc , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_IC : p = slow_search_ic ( reg -> enc , reg -> case_fold_flag , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM : p = bm_search ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV : p = bm_search_notrev ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_MAP : p = map_search ( reg -> enc , reg -> map , p , range ) ; break ; } if ( p && p < range ) { if ( p - reg -> dmin < s ) { retry_gate : pprev = p ; p += enclen ( reg -> enc , p ) ; goto retry ; } if ( reg -> sub_anchor ) { UChar * prev ; switch ( reg -> sub_anchor ) { case ANCHOR_BEGIN_LINE : if ( ! ON_STR_BEGIN ( p ) ) { prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; } break ; case ANCHOR_END_LINE : if ( ON_STR_END ( p ) ) { # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE prev = ( UChar * ) onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( prev && ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; # endif } else if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , p , end ) # ifdef USE_CRNL_AS_LINE_TERMINATOR && ! ONIGENC_IS_MBC_CRNL ( reg -> enc , p , end ) # endif ) goto retry_gate ; break ; } } if ( reg -> dmax == 0 ) { * low = p ; if ( low_prev ) { if ( * low > s ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , s , p ) ; else * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; } } else { if ( reg -> dmax != ONIG_INFINITE_DISTANCE ) { * low = p - reg -> dmax ; if ( * low > s ) { * low = onigenc_get_right_adjust_char_head_with_prev ( reg -> enc , s , * low , ( const UChar * * ) low_prev ) ; if ( low_prev && IS_NULL ( * low_prev ) ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : s ) , * low ) ; } else { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , * low ) ; } } } * high = p - reg -> dmin ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range<S2SV_blank>success:<S2SV_blank>low:<S2SV_blank>%d,<S2SV_blank>high:<S2SV_blank>%d,<S2SV_blank>dmin:<S2SV_blank>%d,<S2SV_blank>dmax:<S2SV_blank>%d\\n"" , ( int ) ( * low - str ) , ( int ) ( * high - str ) , reg -> dmin , reg -> dmax ) ; # endif return 1 ; } return 0 ; }
","<S2SV_ModStart> -> dmin ; if ( q >= end ) return 0 ;
"
278,"CWE-416 <S2SV_StartBug> static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq ) <S2SV_EndBug> { <S2SV_StartBug> struct bfq_data * bfqd = bfqq -> bfqd ; <S2SV_EndBug> enum bfqq_expiration reason ; unsigned long flags ; <S2SV_StartBug> spin_lock_irqsave ( & bfqd -> lock , flags ) ; <S2SV_EndBug> bfq_clear_bfqq_wait_request ( bfqq ) ; if ( bfqq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; <S2SV_StartBug> } <S2SV_EndBug> if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ; else if ( bfqq -> queued [ 0 ] == 0 && bfqq -> queued [ 1 ] == 0 ) reason = BFQQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfqq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
","<S2SV_ModStart> void bfq_idle_slice_timer_body ( struct bfq_data * bfqd , <S2SV_ModStart> bfqq ) { <S2SV_ModEnd> enum bfqq_expiration reason <S2SV_ModStart> lock , flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> return ; } bfq_clear_bfqq_wait_request ( bfqq ) ;
"
279,"CWE-20 void big_key_revoke ( struct key * key ) { struct path * path = ( struct path * ) & key -> payload . data [ big_key_path ] ; key_payload_reserve ( key , 0 ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) && <S2SV_EndBug> ( size_t ) key -> payload . data [ big_key_len ] > BIG_KEY_FILE_THRESHOLD ) vfs_truncate ( path , 0 ) ; }
","<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
"
280,"CWE-20 static unsigned xen_netbk_tx_build_gops ( struct xen_netbk * netbk ) { struct gnttab_copy * gop = netbk -> tx_copy_ops , * request_gop ; struct sk_buff * skb ; int ret ; while ( ( ( nr_pending_reqs ( netbk ) + MAX_SKB_FRAGS ) < MAX_PENDING_REQS ) && ! list_empty ( & netbk -> net_schedule_list ) ) { struct xenvif * vif ; struct xen_netif_tx_request txreq ; struct xen_netif_tx_request txfrags [ MAX_SKB_FRAGS ] ; struct page * page ; struct xen_netif_extra_info extras [ XEN_NETIF_EXTRA_TYPE_MAX - 1 ] ; u16 pending_idx ; RING_IDX idx ; int work_to_do ; unsigned int data_len ; pending_ring_idx_t index ; vif = poll_net_schedule_list ( netbk ) ; if ( ! vif ) continue ; <S2SV_StartBug> RING_FINAL_CHECK_FOR_REQUESTS ( & vif -> tx , work_to_do ) ; <S2SV_EndBug> if ( ! work_to_do ) { xenvif_put ( vif ) ; continue ; } idx = vif -> tx . req_cons ; rmb ( ) ; memcpy ( & txreq , RING_GET_REQUEST ( & vif -> tx , idx ) , sizeof ( txreq ) ) ; if ( txreq . size > vif -> remaining_credit && tx_credit_exceeded ( vif , txreq . size ) ) { xenvif_put ( vif ) ; continue ; } vif -> remaining_credit -= txreq . size ; work_to_do -- ; vif -> tx . req_cons = ++ idx ; memset ( extras , 0 , sizeof ( extras ) ) ; if ( txreq . flags & XEN_NETTXF_extra_info ) { work_to_do = xen_netbk_get_extras ( vif , extras , work_to_do ) ; idx = vif -> tx . req_cons ; <S2SV_StartBug> if ( unlikely ( work_to_do < 0 ) ) { <S2SV_EndBug> netbk_tx_err ( vif , & txreq , idx ) ; continue ; } } ret = netbk_count_requests ( vif , & txreq , txfrags , work_to_do ) ; <S2SV_StartBug> if ( unlikely ( ret < 0 ) ) { <S2SV_EndBug> netbk_tx_err ( vif , & txreq , idx - ret ) ; continue ; } idx += ret ; if ( unlikely ( txreq . size < ETH_HLEN ) ) { netdev_dbg ( vif -> dev , ""Bad<S2SV_blank>packet<S2SV_blank>size:<S2SV_blank>%d\\n"" , txreq . size ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } if ( unlikely ( ( txreq . offset + txreq . size ) > PAGE_SIZE ) ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , <S2SV_EndBug> ""txreq.offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u,<S2SV_blank>end:<S2SV_blank>%lu\\n"" , txreq . offset , txreq . size , ( txreq . offset & ~ PAGE_MASK ) + txreq . size ) ; <S2SV_StartBug> netbk_tx_err ( vif , & txreq , idx ) ; <S2SV_EndBug> continue ; } index = pending_index ( netbk -> pending_cons ) ; pending_idx = netbk -> pending_ring [ index ] ; data_len = ( txreq . size > PKT_PROT_LEN && ret < MAX_SKB_FRAGS ) ? PKT_PROT_LEN : txreq . size ; skb = alloc_skb ( data_len + NET_SKB_PAD + NET_IP_ALIGN , GFP_ATOMIC | __GFP_NOWARN ) ; if ( unlikely ( skb == NULL ) ) { netdev_dbg ( vif -> dev , ""Can\'t<S2SV_blank>allocate<S2SV_blank>a<S2SV_blank>skb<S2SV_blank>in<S2SV_blank>start_xmit.\\n"" ) ; netbk_tx_err ( vif , & txreq , idx ) ; break ; } skb_reserve ( skb , NET_SKB_PAD + NET_IP_ALIGN ) ; if ( extras [ XEN_NETIF_EXTRA_TYPE_GSO - 1 ] . type ) { struct xen_netif_extra_info * gso ; gso = & extras [ XEN_NETIF_EXTRA_TYPE_GSO - 1 ] ; if ( netbk_set_skb_gso ( vif , skb , gso ) ) { kfree_skb ( skb ) ; <S2SV_StartBug> netbk_tx_err ( vif , & txreq , idx ) ; <S2SV_EndBug> continue ; } } page = xen_netbk_alloc_page ( netbk , skb , pending_idx ) ; if ( ! page ) { kfree_skb ( skb ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } gop -> source . u . ref = txreq . gref ; gop -> source . domid = vif -> domid ; gop -> source . offset = txreq . offset ; gop -> dest . u . gmfn = virt_to_mfn ( page_address ( page ) ) ; gop -> dest . domid = DOMID_SELF ; gop -> dest . offset = txreq . offset ; gop -> len = txreq . size ; gop -> flags = GNTCOPY_source_gref ; gop ++ ; memcpy ( & netbk -> pending_tx_info [ pending_idx ] . req , & txreq , sizeof ( txreq ) ) ; netbk -> pending_tx_info [ pending_idx ] . vif = vif ; * ( ( u16 * ) skb -> data ) = pending_idx ; __skb_put ( skb , data_len ) ; skb_shinfo ( skb ) -> nr_frags = ret ; if ( data_len < txreq . size ) { skb_shinfo ( skb ) -> nr_frags ++ ; frag_set_pending_idx ( & skb_shinfo ( skb ) -> frags [ 0 ] , pending_idx ) ; } else { frag_set_pending_idx ( & skb_shinfo ( skb ) -> frags [ 0 ] , INVALID_PENDING_IDX ) ; } netbk -> pending_cons ++ ; request_gop = xen_netbk_get_requests ( netbk , vif , skb , txfrags , gop ) ; if ( request_gop == NULL ) { kfree_skb ( skb ) ; netbk_tx_err ( vif , & txreq , idx ) ; continue ; } gop = request_gop ; __skb_queue_tail ( & netbk -> tx_queue , skb ) ; vif -> tx . req_cons = idx ; xen_netbk_check_rx_xenvif ( vif ) ; if ( ( gop - netbk -> tx_copy_ops ) >= ARRAY_SIZE ( netbk -> tx_copy_ops ) ) break ; } return gop - netbk -> tx_copy_ops ; }
","<S2SV_ModStart> ) continue ; if ( vif -> tx . sring -> req_prod - vif -> tx . req_cons > XEN_NETIF_TX_RING_SIZE ) { netdev_err ( vif -> dev , ""Impossible<S2SV_blank>number<S2SV_blank>of<S2SV_blank>requests.<S2SV_blank>"" ""req_prod<S2SV_blank>%d,<S2SV_blank>req_cons<S2SV_blank>%d,<S2SV_blank>size<S2SV_blank>%ld\\n"" , vif -> tx . sring -> req_prod , vif -> tx . req_cons , XEN_NETIF_TX_RING_SIZE ) ; netbk_fatal_tx_err ( vif ) ; continue ; } <S2SV_ModStart> 0 ) ) continue ; <S2SV_ModEnd> } ret = <S2SV_ModStart> 0 ) ) continue ; <S2SV_ModEnd> idx += ret <S2SV_ModStart> ) ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> size ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; continue <S2SV_ModStart> skb ) ; <S2SV_ModEnd> continue ; }
"
281,"CWE-399 void parser ( void ) { char * arg ; # ifndef MINIMAL char * sitearg ; # endif # ifdef WITH_RFC2640 char * narg = NULL ; # endif size_t n ; # ifdef IMPLICIT_TLS ( void ) tls_init_new_session ( ) ; data_protection_level = CPL_PRIVATE ; # endif for ( ; ; ) { xferfd = - 1 ; if ( state_needs_update != 0 ) { state_needs_update = 0 ; setprocessname ( ""pure-ftpd<S2SV_blank>(IDLE)"" ) ; # ifdef FTPWHO if ( shm_data_cur != NULL ) { ftpwho_lock ( ) ; shm_data_cur -> state = FTPWHO_STATE_IDLE ; * shm_data_cur -> filename = 0 ; ftpwho_unlock ( ) ; } # endif } doreply ( ) ; alarm ( idletime * 2 ) ; switch ( sfgets ( ) ) { case - 1 : # ifdef BORING_MODE die ( 421 , LOG_INFO , MSG_TIMEOUT ) ; # else die ( 421 , LOG_INFO , MSG_TIMEOUT_PARSER ) ; # endif case - 2 : return ; } # ifdef DEBUG if ( debug != 0 ) { addreply ( 0 , ""%s"" , cmd ) ; } # endif n = ( size_t ) 0U ; while ( ( isalpha ( ( unsigned char ) cmd [ n ] ) || cmd [ n ] == '@' ) && n < cmdsize ) { cmd [ n ] = ( char ) tolower ( ( unsigned char ) cmd [ n ] ) ; n ++ ; } if ( n >= cmdsize ) { die ( 421 , LOG_WARNING , MSG_LINE_TOO_LONG ) ; } if ( n == ( size_t ) 0U ) { nop : addreply_noformat ( 500 , ""?"" ) ; continue ; } # ifdef SKIP_COMMAND_TRAILING_SPACES while ( isspace ( ( unsigned char ) cmd [ n ] ) && n < cmdsize ) { cmd [ n ++ ] = 0 ; } arg = cmd + n ; while ( cmd [ n ] != 0 && n < cmdsize ) { n ++ ; } n -- ; while ( isspace ( ( unsigned char ) cmd [ n ] ) ) { cmd [ n -- ] = 0 ; } # else if ( cmd [ n ] == 0 ) { arg = cmd + n ; } else if ( isspace ( ( unsigned char ) cmd [ n ] ) ) { cmd [ n ] = 0 ; arg = cmd + n + 1 ; } else { goto nop ; } # endif if ( logging != 0 ) { # ifdef DEBUG logfile ( LOG_DEBUG , MSG_DEBUG_COMMAND ""<S2SV_blank>[%s]<S2SV_blank>[%s]"" , cmd , arg ) ; # else logfile ( LOG_DEBUG , MSG_DEBUG_COMMAND ""<S2SV_blank>[%s]<S2SV_blank>[%s]"" , cmd , strcmp ( cmd , ""pass"" ) ? arg : ""<*>"" ) ; # endif } # ifdef WITH_RFC2640 narg = charset_client2fs ( arg ) ; arg = narg ; # endif # ifndef MINIMAL if ( ! strcmp ( cmd , ""noop"" ) ) { antiidle ( ) ; donoop ( ) ; goto wayout ; } # endif if ( ! strcmp ( cmd , ""user"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth > 1 && tls_cnx == NULL ) { die ( 421 , LOG_WARNING , MSG_TLS_NEEDED ) ; } # endif douser ( arg ) ; } else if ( ! strcmp ( cmd , ""acct"" ) ) { addreply ( 202 , MSG_WHOAREYOU ) ; } else if ( ! strcmp ( cmd , ""pass"" ) ) { if ( guest == 0 ) { randomdelay ( ) ; } dopass ( arg ) ; } else if ( ! strcmp ( cmd , ""quit"" ) ) { addreply ( 221 , MSG_GOODBYE , ( unsigned long long ) ( ( uploaded + 1023ULL ) / 1024ULL ) , ( unsigned long long ) ( ( downloaded + 1023ULL ) / 1024ULL ) ) ; return ; } else if ( ! strcmp ( cmd , ""syst"" ) ) { antiidle ( ) ; addreply_noformat ( 215 , ""UNIX<S2SV_blank>Type:<S2SV_blank>L8"" ) ; goto wayout ; # ifdef WITH_TLS } else if ( enforce_tls_auth > 0 && ! strcmp ( cmd , ""auth"" ) && ! strcasecmp ( arg , ""tls"" ) ) { addreply_noformat ( 234 , ""AUTH<S2SV_blank>TLS<S2SV_blank>OK."" ) ; doreply ( ) ; if ( tls_cnx == NULL ) { <S2SV_StartBug> ( void ) tls_init_new_session ( ) ; <S2SV_EndBug> } goto wayout ; } else if ( ! strcmp ( cmd , ""pbsz"" ) ) { addreply_noformat ( tls_cnx == NULL ? 503 : 200 , ""PBSZ=0"" ) ; } else if ( ! strcmp ( cmd , ""prot"" ) ) { if ( tls_cnx == NULL ) { addreply_noformat ( 503 , MSG_PROT_BEFORE_PBSZ ) ; goto wayout ; } switch ( * arg ) { case 0 : addreply_noformat ( 503 , MSG_MISSING_ARG ) ; data_protection_level = CPL_NONE ; break ; case 'C' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_OK , ""clear"" ) ; data_protection_level = CPL_CLEAR ; break ; } case 'S' : case 'E' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_UNKNOWN_LEVEL , arg , ""private"" ) ; data_protection_level = CPL_PRIVATE ; break ; } case 'P' : if ( arg [ 1 ] == 0 ) { addreply ( 200 , MSG_PROT_OK , ""private"" ) ; data_protection_level = CPL_PRIVATE ; break ; } default : addreply_noformat ( 534 , ""Fallback<S2SV_blank>to<S2SV_blank>[C]"" ) ; data_protection_level = CPL_CLEAR ; break ; } # endif } else if ( ! strcmp ( cmd , ""auth"" ) || ! strcmp ( cmd , ""adat"" ) ) { addreply_noformat ( 500 , MSG_AUTH_UNIMPLEMENTED ) ; } else if ( ! strcmp ( cmd , ""type"" ) ) { antiidle ( ) ; dotype ( arg ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""mode"" ) ) { antiidle ( ) ; domode ( arg ) ; goto wayout ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""feat"" ) ) { dofeat ( ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""opts"" ) ) { doopts ( arg ) ; goto wayout ; # endif } else if ( ! strcmp ( cmd , ""stru"" ) ) { dostru ( arg ) ; goto wayout ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""help"" ) ) { goto help_site ; # endif # ifdef DEBUG } else if ( ! strcmp ( cmd , ""xdbg"" ) ) { debug ++ ; addreply ( 200 , MSG_XDBG_OK , debug ) ; goto wayout ; # endif } else if ( loggedin == 0 ) { addreply_noformat ( 530 , MSG_NOT_LOGGED_IN ) ; goto wayout ; } else { if ( ! strcmp ( cmd , ""cwd"" ) || ! strcmp ( cmd , ""xcwd"" ) ) { antiidle ( ) ; docwd ( arg ) ; goto wayout ; } else if ( ! strcmp ( cmd , ""port"" ) ) { doport ( arg ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""eprt"" ) ) { doeprt ( arg ) ; } else if ( ! strcmp ( cmd , ""esta"" ) && disallow_passive == 0 && STORAGE_FAMILY ( force_passive_ip ) == 0 ) { doesta ( ) ; } else if ( ! strcmp ( cmd , ""estp"" ) ) { doestp ( ) ; # endif } else if ( disallow_passive == 0 && ( ! strcmp ( cmd , ""pasv"" ) || ! strcmp ( cmd , ""p@sw"" ) ) ) { dopasv ( 0 ) ; } else if ( disallow_passive == 0 && ( ! strcmp ( cmd , ""epsv"" ) && ( broken_client_compat == 0 || STORAGE_FAMILY ( ctrlconn ) == AF_INET6 ) ) ) { if ( ! strcasecmp ( arg , ""all"" ) ) { epsv_all = 1 ; addreply_noformat ( 220 , MSG_ACTIVE_DISABLED ) ; } else if ( ! strcmp ( arg , ""2"" ) && ! v6ready ) { addreply_noformat ( 522 , MSG_ONLY_IPV4 ) ; } else { dopasv ( 1 ) ; } # ifndef MINIMAL } else if ( disallow_passive == 0 && ! strcmp ( cmd , ""spsv"" ) ) { dopasv ( 2 ) ; } else if ( ! strcmp ( cmd , ""allo"" ) ) { if ( * arg == 0 ) { addreply_noformat ( 501 , MSG_STAT_FAILURE ) ; } else { const off_t size = ( off_t ) strtoull ( arg , NULL , 10 ) ; if ( size < ( off_t ) 0 ) { addreply_noformat ( 501 , MSG_STAT_FAILURE ) ; } else { doallo ( size ) ; } } # endif } else if ( ! strcmp ( cmd , ""pwd"" ) || ! strcmp ( cmd , ""xpwd"" ) ) { # ifdef WITH_RFC2640 char * nwd ; # endif antiidle ( ) ; # ifdef WITH_RFC2640 nwd = charset_fs2client ( wd ) ; addreply ( 257 , ""\\""%s\\""<S2SV_blank>"" MSG_IS_YOUR_CURRENT_LOCATION , nwd ) ; free ( nwd ) ; # else addreply ( 257 , ""\\""%s\\""<S2SV_blank>"" MSG_IS_YOUR_CURRENT_LOCATION , wd ) ; # endif goto wayout ; } else if ( ! strcmp ( cmd , ""cdup"" ) || ! strcmp ( cmd , ""xcup"" ) ) { docwd ( "".."" ) ; } else if ( ! strcmp ( cmd , ""retr"" ) ) { if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { doretr ( arg ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""rest"" ) ) { antiidle ( ) ; if ( * arg != 0 ) { dorest ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_RESTART_POINT ) ; restartat = ( off_t ) 0 ; } goto wayout ; } else if ( ! strcmp ( cmd , ""dele"" ) ) { if ( * arg != 0 ) { dodele ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""stor"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostor ( arg , 0 , autorename ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""appe"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostor ( arg , 1 , 0 ) ; } } else { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; } # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""stou"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { dostou ( ) ; } # endif # ifndef DISABLE_MKD_RMD } else if ( ! strcmp ( cmd , ""mkd"" ) || ! strcmp ( cmd , ""xmkd"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { domkd ( arg ) ; } else { addreply_noformat ( 501 , MSG_NO_DIRECTORY_NAME ) ; } } else if ( ! strcmp ( cmd , ""rmd"" ) || ! strcmp ( cmd , ""xrmd"" ) ) { if ( * arg != 0 ) { dormd ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_DIRECTORY_NAME ) ; } # endif # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""stat"" ) ) { if ( * arg != 0 ) { modern_listings = 0 ; donlist ( arg , 1 , 1 , 1 , 1 ) ; } else { addreply_noformat ( 211 , ""http://www.pureftpd.org/"" ) ; } # endif } else if ( ! strcmp ( cmd , ""list"" ) ) { # ifndef MINIMAL modern_listings = 0 ; # endif # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 1 , 0 , 1 ) ; } } else if ( ! strcmp ( cmd , ""nlst"" ) ) { # ifndef MINIMAL modern_listings = 0 ; # endif # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 0 , 0 , broken_client_compat ) ; } # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""mlst"" ) ) { # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { domlst ( * arg != 0 ? arg : ""."" ) ; } } else if ( ! strcmp ( cmd , ""mlsd"" ) ) { modern_listings = 1 ; # ifdef WITH_TLS if ( enforce_tls_auth == 3 && data_protection_level != CPL_PRIVATE ) { addreply_noformat ( 521 , MSG_PROT_PRIVATE_NEEDED ) ; } else # endif { donlist ( arg , 0 , 1 , 1 , 0 ) ; } # endif } else if ( ! strcmp ( cmd , ""abor"" ) ) { addreply_noformat ( 226 , MSG_ABOR_SUCCESS ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""site"" ) ) { if ( ( sitearg = arg ) != NULL ) { while ( * sitearg != 0 && ! isspace ( ( unsigned char ) * sitearg ) ) { sitearg ++ ; } if ( * sitearg != 0 ) { * sitearg ++ = 0 ; } } if ( ! strcasecmp ( arg , ""idle"" ) ) { if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , ""SITE<S2SV_blank>IDLE:<S2SV_blank>"" MSG_MISSING_ARG ) ; } else { unsigned long int i = 0 ; i = strtoul ( sitearg , & sitearg , 10 ) ; if ( sitearg && * sitearg ) addreply ( 501 , MSG_GARBAGE_FOUND ""<S2SV_blank>:<S2SV_blank>%s"" , sitearg ) ; else if ( i > MAX_SITE_IDLE ) addreply_noformat ( 501 , MSG_VALUE_TOO_LARGE ) ; else { idletime = i ; addreply ( 200 , MSG_IDLE_TIME , idletime ) ; idletime_noop = ( double ) idletime * 2.0 ; } } } else if ( ! strcasecmp ( arg , ""time"" ) ) { dositetime ( ) ; } else if ( ! strcasecmp ( arg , ""help"" ) ) { help_site : addreply_noformat ( 214 , MSG_SITE_HELP CRLF # ifdef WITH_DIRALIASES ""<S2SV_blank>ALIAS"" CRLF # endif ""<S2SV_blank>CHMOD"" CRLF ""<S2SV_blank>IDLE"" CRLF ""<S2SV_blank>UTIME"" ) ; addreply_noformat ( 214 , ""Pure-FTPd<S2SV_blank>-<S2SV_blank>http://pureftpd.org/"" ) ; } else if ( ! strcasecmp ( arg , ""chmod"" ) ) { char * sitearg2 ; mode_t mode ; parsechmod : if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto chmod_wayout ; } sitearg2 = sitearg ; while ( * sitearg2 != 0 && ! isspace ( ( unsigned char ) * sitearg2 ) ) { sitearg2 ++ ; } while ( * sitearg2 != 0 && isspace ( ( unsigned char ) * sitearg2 ) ) { sitearg2 ++ ; } if ( * sitearg2 == 0 ) { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; goto chmod_wayout ; } mode = ( mode_t ) strtoul ( sitearg , NULL , 8 ) ; if ( mode > ( mode_t ) 07777 ) { addreply_noformat ( 501 , MSG_BAD_CHMOD ) ; goto chmod_wayout ; } dochmod ( sitearg2 , mode ) ; chmod_wayout : ( void ) 0 ; } else if ( ! strcasecmp ( arg , ""utime"" ) ) { char * sitearg2 ; if ( sitearg == NULL || * sitearg == 0 ) { addreply_noformat ( 501 , MSG_NO_FILE_NAME ) ; goto utime_wayout ; } if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto utime_wayout ; } if ( strcasecmp ( sitearg2 , ""<S2SV_blank>UTC"" ) != 0 ) { addreply_noformat ( 500 , ""UTC<S2SV_blank>Only"" ) ; goto utime_wayout ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { utime_no_arg : addreply_noformat ( 501 , MSG_MISSING_ARG ) ; goto utime_wayout ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { goto utime_no_arg ; } * sitearg2 -- = 0 ; if ( ( sitearg2 = strrchr ( sitearg , '<S2SV_blank>' ) ) == NULL || sitearg2 == sitearg ) { goto utime_no_arg ; } * sitearg2 ++ = 0 ; if ( * sitearg2 == 0 ) { goto utime_no_arg ; } doutime ( sitearg , sitearg2 ) ; utime_wayout : ( void ) 0 ; # ifdef WITH_DIRALIASES } else if ( ! strcasecmp ( arg , ""alias"" ) ) { if ( sitearg == NULL || * sitearg == 0 ) { print_aliases ( ) ; } else { const char * alias ; if ( ( alias = lookup_alias ( sitearg ) ) != NULL ) { addreply ( 214 , MSG_ALIASES_ALIAS , sitearg , alias ) ; } else { addreply ( 502 , MSG_ALIASES_UNKNOWN , sitearg ) ; } } # endif } else if ( * arg != 0 ) { addreply ( 500 , ""SITE<S2SV_blank>%s<S2SV_blank>"" MSG_UNKNOWN_EXTENSION , arg ) ; } else { addreply_noformat ( 500 , ""SITE:<S2SV_blank>"" MSG_MISSING_ARG ) ; } # endif } else if ( ! strcmp ( cmd , ""mdtm"" ) ) { domdtm ( arg ) ; } else if ( ! strcmp ( cmd , ""size"" ) ) { dosize ( arg ) ; # ifndef MINIMAL } else if ( ! strcmp ( cmd , ""chmod"" ) ) { sitearg = arg ; goto parsechmod ; # endif } else if ( ! strcmp ( cmd , ""rnfr"" ) ) { if ( * arg != 0 ) { dornfr ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; } } else if ( ! strcmp ( cmd , ""rnto"" ) ) { arg = revealextraspc ( arg ) ; if ( * arg != 0 ) { dornto ( arg ) ; } else { addreply_noformat ( 550 , MSG_NO_FILE_NAME ) ; } } else { addreply_noformat ( 500 , MSG_UNKNOWN_COMMAND ) ; } } noopidle = ( time_t ) - 1 ; wayout : # ifdef WITH_RFC2640 free ( narg ) ; narg = NULL ; # endif # ifdef THROTTLING if ( throttling_delay != 0UL ) { usleep2 ( throttling_delay ) ; } # else ( void ) 0 ; # endif } }
","<S2SV_ModStart> NULL ) { flush_cmd ( ) ;
"
282,"CWE-416 static int xfrm_dump_policy_done ( struct netlink_callback * cb ) { <S2SV_StartBug> struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ; <S2SV_EndBug> struct net * net = sock_net ( cb -> skb -> sk ) ; xfrm_policy_walk_done ( walk , net ) ; return 0 ; }
","<S2SV_ModStart> xfrm_policy_walk * ) <S2SV_ModEnd> cb -> args <S2SV_ModStart> cb -> args <S2SV_ModEnd> ; struct net
"
283,"CWE-000 static void on_read ( h2o_socket_t * sock , int status ) { h2o_http2_conn_t * conn = sock -> data ; if ( status != 0 ) { h2o_socket_read_stop ( conn -> sock ) ; close_connection ( conn ) ; return ; } update_idle_timeout ( conn ) ; <S2SV_StartBug> parse_input ( conn ) ; <S2SV_EndBug> if ( h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) { h2o_timeout_unlink ( & conn -> _write . timeout_entry ) ; do_emit_writereq ( conn ) ; } }
","<S2SV_ModStart> conn ) ; if ( <S2SV_ModStart> ( conn ) != 0 ) return
"
284,"CWE-399 static int xen_netbk_tx_check_gop ( struct xen_netbk * netbk , struct sk_buff * skb , struct gnttab_copy * * gopp ) { struct gnttab_copy * gop = * gopp ; u16 pending_idx = * ( ( u16 * ) skb -> data ) ; <S2SV_StartBug> struct pending_tx_info * pending_tx_info = netbk -> pending_tx_info ; <S2SV_EndBug> struct xenvif * vif = pending_tx_info [ pending_idx ] . vif ; struct xen_netif_tx_request * txp ; struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; int nr_frags = shinfo -> nr_frags ; int i , err , start ; err = gop -> status ; <S2SV_StartBug> if ( unlikely ( err ) ) { <S2SV_EndBug> pending_ring_idx_t index ; index = pending_index ( netbk -> pending_prod ++ ) ; txp = & pending_tx_info [ pending_idx ] . req ; make_tx_response ( vif , txp , XEN_NETIF_RSP_ERROR ) ; <S2SV_StartBug> netbk -> pending_ring [ index ] = pending_idx ; <S2SV_EndBug> xenvif_put ( vif ) ; } start = ( frag_get_pending_idx ( & shinfo -> frags [ 0 ] ) == pending_idx ) ; for ( i = start ; i < nr_frags ; i ++ ) { int j , newerr ; <S2SV_StartBug> pending_ring_idx_t index ; <S2SV_EndBug> pending_idx = frag_get_pending_idx ( & shinfo -> frags [ i ] ) ; newerr = ( ++ gop ) -> status ; if ( likely ( ! newerr ) ) { if ( unlikely ( err ) ) <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> continue ; } <S2SV_StartBug> txp = & netbk -> pending_tx_info [ pending_idx ] . req ; <S2SV_EndBug> make_tx_response ( vif , txp , XEN_NETIF_RSP_ERROR ) ; <S2SV_StartBug> index = pending_index ( netbk -> pending_prod ++ ) ; <S2SV_EndBug> netbk -> pending_ring [ index ] = pending_idx ; xenvif_put ( vif ) ; if ( err ) continue ; pending_idx = * ( ( u16 * ) skb -> data ) ; <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> for ( j = start ; j < i ; j ++ ) { pending_idx = frag_get_pending_idx ( & shinfo -> frags [ j ] ) ; <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> } err = newerr ; } * gopp = gop + 1 ; return err ; }
","<S2SV_ModStart> ) ; struct <S2SV_ModEnd> skb_shared_info * shinfo <S2SV_ModStart> err ) ) xen_netbk_idx_release ( netbk , pending_idx <S2SV_ModEnd> , XEN_NETIF_RSP_ERROR ) <S2SV_ModStart> XEN_NETIF_RSP_ERROR ) ; <S2SV_ModEnd> start = ( <S2SV_ModStart> , newerr ; <S2SV_ModEnd> pending_idx = frag_get_pending_idx <S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY <S2SV_ModStart> continue ; } xen_netbk_idx_release ( netbk , pending_idx <S2SV_ModEnd> , XEN_NETIF_RSP_ERROR ) <S2SV_ModStart> XEN_NETIF_RSP_ERROR ) ; <S2SV_ModEnd> if ( err <S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY <S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY
"
285,"CWE-119 void cJSON_AddItemReferenceToObject ( cJSON * object , const char * string , cJSON * item ) { cJSON_AddItemToObject ( object , string , create_reference ( item ) ) ; }
","
"
286,"CWE-772 static Image * ReadYUVImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * chroma_image , * image , * resize_image ; InterlaceType interlace ; MagickBooleanType status ; register const Quantum * chroma_pixels ; register ssize_t x ; register Quantum * q ; register unsigned char * p ; ssize_t count , horizontal_factor , vertical_factor , y ; size_t length , quantum ; unsigned char * scanline ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , ""MustSpecifyImageSize"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; quantum = ( ssize_t ) ( image -> depth <= 8 ? 1 : 2 ) ; interlace = image_info -> interlace ; horizontal_factor = 2 ; vertical_factor = 2 ; if ( image_info -> sampling_factor != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( image_info -> sampling_factor , & geometry_info ) ; horizontal_factor = ( ssize_t ) geometry_info . rho ; vertical_factor = ( ssize_t ) geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) vertical_factor = horizontal_factor ; if ( ( horizontal_factor != 1 ) && ( horizontal_factor != 2 ) && ( vertical_factor != 1 ) && ( vertical_factor != 2 ) ) ThrowReaderException ( CorruptImageError , ""UnexpectedSamplingFactor"" ) ; } if ( ( interlace == UndefinedInterlace ) || ( ( interlace == NoInterlace ) && ( vertical_factor == 2 ) ) ) { interlace = NoInterlace ; if ( vertical_factor == 2 ) interlace = PlaneInterlace ; } if ( interlace != PartitionInterlace ) { status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , ( MagickSizeType ) image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } if ( interlace == NoInterlace ) scanline = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( 2UL * image -> columns + 2UL ) , ( size_t ) quantum * sizeof ( * scanline ) ) ; else scanline = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , ( size_t ) quantum * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; status = MagickTrue ; do { chroma_image = CloneImage ( image , ( image -> columns + horizontal_factor - 1 ) / horizontal_factor , ( image -> rows + vertical_factor - 1 ) / vertical_factor , MagickTrue , exception ) ; if ( chroma_image == ( Image * ) NULL ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; if ( interlace == PartitionInterlace ) { AppendImageFormat ( ""Y"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> return ( ( Image * ) NULL ) ; } } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register Quantum * chroma_pixels ; if ( interlace == NoInterlace ) { if ( ( y > 0 ) || ( GetPreviousImageInList ( image ) == ( Image * ) NULL ) ) { length = 2 * quantum * image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } p = scanline ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; chroma_pixels = QueueAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( chroma_pixels == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x += 2 ) { SetPixelRed ( chroma_image , 0 , chroma_pixels ) ; if ( quantum == 1 ) SetPixelGreen ( chroma_image , ScaleCharToQuantum ( * p ++ ) , chroma_pixels ) ; else { SetPixelGreen ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , chroma_pixels ) ; p += 2 ; } if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; q += GetPixelChannels ( image ) ; SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; if ( quantum == 1 ) SetPixelBlue ( chroma_image , ScaleCharToQuantum ( * p ++ ) , chroma_pixels ) ; else { SetPixelBlue ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , chroma_pixels ) ; p += 2 ; } if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } chroma_pixels += GetPixelChannels ( chroma_image ) ; q += GetPixelChannels ( image ) ; } } else { if ( ( y > 0 ) || ( GetPreviousImageInList ( image ) == ( Image * ) NULL ) ) { length = quantum * image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } p = scanline ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( quantum == 1 ) SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelGreen ( image , 0 , q ) ; SetPixelBlue ( image , 0 , q ) ; q += GetPixelChannels ( image ) ; } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( interlace == NoInterlace ) if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( interlace == PartitionInterlace ) { ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""U"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> return ( ( Image * ) NULL ) ; } } if ( interlace != NoInterlace ) { for ( y = 0 ; y < ( ssize_t ) chroma_image -> rows ; y ++ ) { length = quantum * chroma_image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } p = scanline ; q = QueueAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) chroma_image -> columns ; x ++ ) { SetPixelRed ( chroma_image , 0 , q ) ; if ( quantum == 1 ) SetPixelGreen ( chroma_image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelGreen ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } SetPixelBlue ( chroma_image , 0 , q ) ; q += GetPixelChannels ( chroma_image ) ; } if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; } if ( interlace == PartitionInterlace ) { ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""V"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> return ( ( Image * ) NULL ) ; } } for ( y = 0 ; y < ( ssize_t ) chroma_image -> rows ; y ++ ) { length = quantum * chroma_image -> columns ; count = ReadBlob ( image , length , scanline ) ; if ( count != ( ssize_t ) length ) { status = MagickFalse ; ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } p = scanline ; q = GetAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) chroma_image -> columns ; x ++ ) { if ( quantum == 1 ) SetPixelBlue ( chroma_image , ScaleCharToQuantum ( * p ++ ) , q ) ; else { SetPixelBlue ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; p += 2 ; } q += GetPixelChannels ( chroma_image ) ; } if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) break ; } } resize_image = ResizeImage ( chroma_image , image -> columns , image -> rows , TriangleFilter , exception ) ; chroma_image = DestroyImage ( chroma_image ) ; if ( resize_image == ( Image * ) NULL ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; chroma_pixels = GetVirtualPixels ( resize_image , 0 , y , resize_image -> columns , 1 , exception ) ; if ( ( q == ( Quantum * ) NULL ) || ( chroma_pixels == ( const Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelGreen ( image , GetPixelGreen ( resize_image , chroma_pixels ) , q ) ; SetPixelBlue ( image , GetPixelBlue ( resize_image , chroma_pixels ) , q ) ; chroma_pixels += GetPixelChannels ( resize_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } resize_image = DestroyImage ( resize_image ) ; if ( SetImageColorspace ( image , YCbCrColorspace , exception ) == MagickFalse ) break ; if ( interlace == PartitionInterlace ) ( void ) CopyMagickString ( image -> filename , image_info -> filename , MagickPathExtent ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( interlace == NoInterlace ) count = ReadBlob ( image , ( size_t ) ( 2 * quantum * image -> columns ) , scanline ) ; else count = ReadBlob ( image , ( size_t ) quantum * image -> columns , scanline ) ; if ( count != 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( count != 0 ) ; scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) NULL ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> ""MemoryAllocationFailed"" ) ; } <S2SV_ModStart> MagickFalse ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> MagickFalse ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> MagickFalse ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> ) NULL ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> ""MemoryAllocationFailed"" ) ; } <S2SV_ModStart> NULL ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;
"
287,"CWE-000 int main ( void ) { int fd , len , sock_opt ; int error ; struct cn_msg * message ; struct pollfd pfd ; struct nlmsghdr * incoming_msg ; struct cn_msg * incoming_cn_msg ; struct hv_kvp_msg * hv_msg ; char * p ; char * key_value ; char * key_name ; int op ; int pool ; char * if_name ; struct hv_kvp_ipaddr_value * kvp_ip_val ; daemon ( 1 , 0 ) ; openlog ( ""KVP"" , 0 , LOG_USER ) ; syslog ( LOG_INFO , ""KVP<S2SV_blank>starting;<S2SV_blank>pid<S2SV_blank>is:%d"" , getpid ( ) ) ; kvp_get_os_info ( ) ; if ( kvp_file_init ( ) ) { syslog ( LOG_ERR , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>the<S2SV_blank>pools"" ) ; exit ( EXIT_FAILURE ) ; } fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ) ; if ( fd < 0 ) { syslog ( LOG_ERR , ""netlink<S2SV_blank>socket<S2SV_blank>creation<S2SV_blank>failed;<S2SV_blank>error:%d"" , fd ) ; exit ( EXIT_FAILURE ) ; } addr . nl_family = AF_NETLINK ; addr . nl_pad = 0 ; addr . nl_pid = 0 ; addr . nl_groups = CN_KVP_IDX ; error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ) ; if ( error < 0 ) { syslog ( LOG_ERR , ""bind<S2SV_blank>failed;<S2SV_blank>error:%d"" , error ) ; close ( fd ) ; exit ( EXIT_FAILURE ) ; } sock_opt = addr . nl_groups ; setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ) ; message = ( struct cn_msg * ) kvp_send_buffer ; message -> id . idx = CN_KVP_IDX ; message -> id . val = CN_KVP_VAL ; hv_msg = ( struct hv_kvp_msg * ) message -> data ; hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1 ; message -> ack = 0 ; message -> len = sizeof ( struct hv_kvp_msg ) ; len = netlink_send ( fd , message ) ; if ( len < 0 ) { syslog ( LOG_ERR , ""netlink_send<S2SV_blank>failed;<S2SV_blank>error:%d"" , len ) ; close ( fd ) ; exit ( EXIT_FAILURE ) ; } pfd . fd = fd ; while ( 1 ) { struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; socklen_t addr_l = sizeof ( addr ) ; pfd . events = POLLIN ; pfd . revents = 0 ; poll ( & pfd , 1 , - 1 ) ; len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ) ; <S2SV_StartBug> if ( len < 0 || addr . nl_pid ) { <S2SV_EndBug> syslog ( LOG_ERR , ""recvfrom<S2SV_blank>failed;<S2SV_blank>pid:%u<S2SV_blank>error:%d<S2SV_blank>%s"" , addr . nl_pid , errno , strerror ( errno ) ) ; close ( fd ) ; return - 1 ; } <S2SV_StartBug> incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ; <S2SV_EndBug> incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ) ; hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data ; op = hv_msg -> kvp_hdr . operation ; pool = hv_msg -> kvp_hdr . pool ; hv_msg -> error = HV_S_OK ; if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) ) { in_hand_shake = 0 ; p = ( char * ) hv_msg -> body . kvp_register . version ; lic_version = malloc ( strlen ( p ) + 1 ) ; if ( lic_version ) { strcpy ( lic_version , p ) ; syslog ( LOG_INFO , ""KVP<S2SV_blank>LIC<S2SV_blank>Version:<S2SV_blank>%s"" , lic_version ) ; } else { syslog ( LOG_ERR , ""malloc<S2SV_blank>failed"" ) ; } continue ; } switch ( op ) { case KVP_OP_GET_IP_INFO : kvp_ip_val = & hv_msg -> body . kvp_ip_val ; if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ) ; if ( if_name == NULL ) { hv_msg -> error = HV_E_FAIL ; break ; } error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ) ; if ( error ) hv_msg -> error = error ; free ( if_name ) ; break ; case KVP_OP_SET_IP_INFO : kvp_ip_val = & hv_msg -> body . kvp_ip_val ; if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ) ; if ( if_name == NULL ) { hv_msg -> error = HV_GUID_NOTFOUND ; break ; } error = kvp_set_ip_info ( if_name , kvp_ip_val ) ; if ( error ) hv_msg -> error = error ; free ( if_name ) ; break ; case KVP_OP_SET : if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) ) hv_msg -> error = HV_S_CONT ; break ; case KVP_OP_GET : if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) ) hv_msg -> error = HV_S_CONT ; break ; case KVP_OP_DELETE : if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) ) hv_msg -> error = HV_S_CONT ; break ; default : break ; } if ( op != KVP_OP_ENUMERATE ) goto kvp_done ; if ( pool != KVP_POOL_AUTO ) { if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ) hv_msg -> error = HV_S_CONT ; goto kvp_done ; } hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data ; key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key ; key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value ; switch ( hv_msg -> body . kvp_enum_data . index ) { case FullyQualifiedDomainName : kvp_get_domain_name ( key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , ""FullyQualifiedDomainName"" ) ; break ; case IntegrationServicesVersion : strcpy ( key_name , ""IntegrationServicesVersion"" ) ; strcpy ( key_value , lic_version ) ; break ; case NetworkAddressIPv4 : kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , ""NetworkAddressIPv4"" ) ; break ; case NetworkAddressIPv6 : kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; strcpy ( key_name , ""NetworkAddressIPv6"" ) ; break ; case OSBuildNumber : strcpy ( key_value , os_build ) ; strcpy ( key_name , ""OSBuildNumber"" ) ; break ; case OSName : strcpy ( key_value , os_name ) ; strcpy ( key_name , ""OSName"" ) ; break ; case OSMajorVersion : strcpy ( key_value , os_major ) ; strcpy ( key_name , ""OSMajorVersion"" ) ; break ; case OSMinorVersion : strcpy ( key_value , os_minor ) ; strcpy ( key_name , ""OSMinorVersion"" ) ; break ; case OSVersion : strcpy ( key_value , os_version ) ; strcpy ( key_name , ""OSVersion"" ) ; break ; case ProcessorArchitecture : strcpy ( key_value , processor_arch ) ; strcpy ( key_name , ""ProcessorArchitecture"" ) ; break ; default : hv_msg -> error = HV_S_CONT ; break ; } kvp_done : incoming_cn_msg -> id . idx = CN_KVP_IDX ; incoming_cn_msg -> id . val = CN_KVP_VAL ; incoming_cn_msg -> ack = 0 ; incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ) ; len = netlink_send ( fd , incoming_cn_msg ) ; if ( len < 0 ) { syslog ( LOG_ERR , ""net_link<S2SV_blank>send<S2SV_blank>failed;<S2SV_blank>error:%d"" , len ) ; exit ( EXIT_FAILURE ) ; } } }
","<S2SV_ModStart> len < 0 <S2SV_ModEnd> ) { syslog <S2SV_ModStart> 1 ; } if ( addr . nl_pid ) { syslog ( LOG_WARNING , ""Received<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>untrusted<S2SV_blank>pid:%u"" , addr . nl_pid ) ; continue ; }
"
288,"CWE-400 int handle_unaligned_access ( insn_size_t instruction , struct pt_regs * regs , struct mem_access * ma , int expected , unsigned long address ) { u_int rm ; int ret , index ; if ( instruction_size ( instruction ) != 2 ) return - EINVAL ; index = ( instruction >> 8 ) & 15 ; rm = regs -> regs [ index ] ; if ( ! expected ) { unaligned_fixups_notify ( current , instruction , regs ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , <S2SV_EndBug> regs , address ) ; } ret = - EFAULT ; switch ( instruction & 0xF000 ) { case 0x0000 : if ( instruction == 0x000B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc = regs -> pr ; } else if ( ( instruction & 0x00FF ) == 0x0023 ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc += rm + 4 ; } else if ( ( instruction & 0x00FF ) == 0x0003 ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc += rm + 4 ; } } else { goto simple ; } break ; case 0x1000 : goto simple ; case 0x2000 : goto simple ; case 0x4000 : if ( ( instruction & 0x00FF ) == 0x002B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc = rm ; } else if ( ( instruction & 0x00FF ) == 0x000B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc = rm ; } } else { goto simple ; } break ; case 0x5000 : goto simple ; case 0x6000 : goto simple ; case 0x8000 : switch ( instruction & 0x0F00 ) { case 0x0100 : goto simple ; case 0x0500 : goto simple ; case 0x0B00 : break ; case 0x0F00 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { # if defined ( CONFIG_CPU_SH4 ) || defined ( CONFIG_SH7705_CACHE_32KB ) if ( ( regs -> sr & 0x00000001 ) != 0 ) regs -> pc += 4 ; else # endif regs -> pc += SH_PC_8BIT_OFFSET ( instruction ) ; } break ; case 0x0900 : break ; case 0x0D00 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { # if defined ( CONFIG_CPU_SH4 ) || defined ( CONFIG_SH7705_CACHE_32KB ) if ( ( regs -> sr & 0x00000001 ) == 0 ) regs -> pc += 4 ; else # endif regs -> pc += SH_PC_8BIT_OFFSET ( instruction ) ; } break ; } break ; case 0xA000 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc += SH_PC_12BIT_OFFSET ( instruction ) ; break ; case 0xB000 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc += SH_PC_12BIT_OFFSET ( instruction ) ; } break ; } return ret ; simple : ret = handle_unaligned_ins ( instruction , regs , ma ) ; if ( ret == 0 ) regs -> pc += instruction_size ( instruction ) ; return ret ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
"
289,"CWE-399 gboolean cib_notify_client ( gpointer key , gpointer value , gpointer user_data ) { const char * type = NULL ; gboolean do_send = FALSE ; cib_client_t * client = value ; xmlNode * update_msg = user_data ; CRM_CHECK ( client != NULL , return TRUE ) ; CRM_CHECK ( update_msg != NULL , return TRUE ) ; <S2SV_StartBug> if ( client -> ipc == NULL ) { <S2SV_EndBug> crm_warn ( ""Skipping<S2SV_blank>client<S2SV_blank>with<S2SV_blank>NULL<S2SV_blank>channel"" ) ; return FALSE ; } type = crm_element_value ( update_msg , F_SUBTYPE ) ; CRM_LOG_ASSERT ( type != NULL ) ; if ( client -> diffs && safe_str_eq ( type , T_CIB_DIFF_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> replace && safe_str_eq ( type , T_CIB_REPLACE_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> confirmations && safe_str_eq ( type , T_CIB_UPDATE_CONFIRM ) ) { do_send = TRUE ; } else if ( client -> pre_notify && safe_str_eq ( type , T_CIB_PRE_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> post_notify && safe_str_eq ( type , T_CIB_POST_NOTIFY ) ) { do_send = TRUE ; } if ( do_send ) { if ( client -> ipc ) { if ( crm_ipcs_send ( client -> ipc , 0 , update_msg , TRUE ) == FALSE ) { crm_warn ( ""Notification<S2SV_blank>of<S2SV_blank>client<S2SV_blank>%s/%s<S2SV_blank>failed"" , client -> name , client -> id ) ; } # ifdef HAVE_GNUTLS_GNUTLS_H } else if ( client -> session ) { crm_debug ( ""Sent<S2SV_blank>%s<S2SV_blank>notification<S2SV_blank>to<S2SV_blank>client<S2SV_blank>%s/%s"" , type , client -> name , client -> id ) ; crm_send_remote_msg ( client -> session , update_msg , client -> encrypted ) ; # endif } else { crm_err ( ""Unknown<S2SV_blank>transport<S2SV_blank>for<S2SV_blank>%s"" , client -> name ) ; } } return FALSE ; }
","<S2SV_ModStart> ipc == NULL && client -> session == NULL
"
290,"CWE-787 static PyObject * patch ( PyObject * self , PyObject * args ) { char * origData , * newData , * diffBlock , * extraBlock , * diffPtr , * extraPtr ; Py_ssize_t origDataLength , newDataLength , diffBlockLength , extraBlockLength ; PyObject * controlTuples , * tuple , * results ; off_t oldpos , newpos , x , y , z ; int i , j , numTuples ; if ( ! PyArg_ParseTuple ( args , ""s#nO!s#s#"" , & origData , & origDataLength , & newDataLength , & PyList_Type , & controlTuples , & diffBlock , & diffBlockLength , & extraBlock , & extraBlockLength ) ) return NULL ; newData = PyMem_Malloc ( newDataLength + 1 ) ; if ( ! newData ) return PyErr_NoMemory ( ) ; oldpos = 0 ; newpos = 0 ; diffPtr = diffBlock ; extraPtr = extraBlock ; numTuples = PyList_GET_SIZE ( controlTuples ) ; for ( i = 0 ; i < numTuples ; i ++ ) { tuple = PyList_GET_ITEM ( controlTuples , i ) ; if ( ! PyTuple_Check ( tuple ) ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_TypeError , ""expecting<S2SV_blank>tuple"" ) ; return NULL ; } if ( PyTuple_GET_SIZE ( tuple ) != 3 ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_TypeError , ""expecting<S2SV_blank>tuple<S2SV_blank>of<S2SV_blank>size<S2SV_blank>3"" ) ; return NULL ; } x = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 0 ) ) ; y = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 1 ) ) ; z = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 2 ) ) ; if ( newpos + x > newDataLength || <S2SV_StartBug> diffPtr + x > diffBlock + diffBlockLength || <S2SV_EndBug> extraPtr + y > extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(overflow)"" ) ; return NULL ; } <S2SV_StartBug> memcpy ( newData + newpos , diffPtr , x ) ; <S2SV_EndBug> diffPtr += x ; for ( j = 0 ; j < x ; j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ; newpos += x ; oldpos += x ; memcpy ( newData + newpos , extraPtr , y ) ; extraPtr += y ; newpos += y ; oldpos += z ; } if ( newpos != newDataLength || diffPtr != diffBlock + diffBlockLength || extraPtr != extraBlock + extraBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(underflow)"" ) ; return NULL ; } results = PyBytes_FromStringAndSize ( newData , newDataLength ) ; PyMem_Free ( newData ) ; return results ; }
","<S2SV_ModStart> diffBlock + diffBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , ""corrupt<S2SV_blank>patch<S2SV_blank>(overflow)"" ) ; return NULL ; } memcpy ( newData + newpos , diffPtr , x ) ; diffPtr += x ; for ( j = 0 ; j < x ; j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ; newpos += x ; oldpos += x ; if ( newpos + y > newDataLength <S2SV_ModStart> NULL ; } <S2SV_ModEnd> memcpy ( newData
"
291,"CWE-17 static struct fileIdentDesc * udf_find_entry ( struct inode * dir , const struct qstr * child , struct udf_fileident_bh * fibh , struct fileIdentDesc * cfi ) { struct fileIdentDesc * fi = NULL ; loff_t f_pos ; int block , flen ; unsigned char * fname = NULL ; unsigned char * nameptr ; uint8_t lfi ; uint16_t liu ; loff_t size ; struct kernel_lb_addr eloc ; uint32_t elen ; sector_t offset ; struct extent_position epos = { } ; struct udf_inode_info * dinfo = UDF_I ( dir ) ; int isdotdot = child -> len == 2 && child -> name [ 0 ] == '.' && child -> name [ 1 ] == '.' ; size = udf_ext0_offset ( dir ) + dir -> i_size ; f_pos = udf_ext0_offset ( dir ) ; fibh -> sbh = fibh -> ebh = NULL ; fibh -> soffset = fibh -> eoffset = f_pos & ( dir -> i_sb -> s_blocksize - 1 ) ; if ( dinfo -> i_alloc_type != ICBTAG_FLAG_AD_IN_ICB ) { if ( inode_bmap ( dir , f_pos >> dir -> i_sb -> s_blocksize_bits , & epos , & eloc , & elen , & offset ) != ( EXT_RECORDED_ALLOCATED >> 30 ) ) goto out_err ; block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset ) ; if ( ( ++ offset << dir -> i_sb -> s_blocksize_bits ) < elen ) { if ( dinfo -> i_alloc_type == ICBTAG_FLAG_AD_SHORT ) epos . offset -= sizeof ( struct short_ad ) ; else if ( dinfo -> i_alloc_type == ICBTAG_FLAG_AD_LONG ) epos . offset -= sizeof ( struct long_ad ) ; } else offset = 0 ; fibh -> sbh = fibh -> ebh = udf_tread ( dir -> i_sb , block ) ; if ( ! fibh -> sbh ) goto out_err ; } fname = kmalloc ( UDF_NAME_LEN , GFP_NOFS ) ; if ( ! fname ) goto out_err ; while ( f_pos < size ) { fi = udf_fileident_read ( dir , & f_pos , fibh , cfi , & epos , & eloc , & elen , & offset ) ; if ( ! fi ) goto out_err ; liu = le16_to_cpu ( cfi -> lengthOfImpUse ) ; lfi = cfi -> lengthFileIdent ; if ( fibh -> sbh == fibh -> ebh ) { nameptr = fi -> fileIdent + liu ; } else { int poffset ; poffset = fibh -> soffset + sizeof ( struct fileIdentDesc ) + liu + lfi ; if ( poffset >= lfi ) nameptr = ( uint8_t * ) ( fibh -> ebh -> b_data + poffset - lfi ) ; else { nameptr = fname ; memcpy ( nameptr , fi -> fileIdent + liu , lfi - poffset ) ; memcpy ( nameptr + lfi - poffset , fibh -> ebh -> b_data , poffset ) ; } } if ( ( cfi -> fileCharacteristics & FID_FILE_CHAR_DELETED ) != 0 ) { if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNDELETE ) ) continue ; } if ( ( cfi -> fileCharacteristics & FID_FILE_CHAR_HIDDEN ) != 0 ) { if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNHIDE ) ) continue ; } if ( ( cfi -> fileCharacteristics & FID_FILE_CHAR_PARENT ) && isdotdot ) goto out_ok ; if ( ! lfi ) continue ; <S2SV_StartBug> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; <S2SV_EndBug> if ( flen && udf_match ( flen , fname , child -> len , child -> name ) ) goto out_ok ; } out_err : fi = NULL ; if ( fibh -> sbh != fibh -> ebh ) brelse ( fibh -> ebh ) ; brelse ( fibh -> sbh ) ; out_ok : brelse ( epos . bh ) ; kfree ( fname ) ; return fi ; }
","<S2SV_ModStart> , nameptr , lfi , fname , UDF_NAME_LEN <S2SV_ModEnd> ) ; if
"
292,"CWE-200 static int do_ip_vs_get_ctl ( struct sock * sk , int cmd , void __user * user , int * len ) { unsigned char arg [ 128 ] ; int ret = 0 ; unsigned int copylen ; struct net * net = sock_net ( sk ) ; struct netns_ipvs * ipvs = net_ipvs ( net ) ; BUG_ON ( ! net ) ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX ) return - EINVAL ; if ( * len < get_arglen [ GET_CMDID ( cmd ) ] ) { pr_err ( ""get_ctl:<S2SV_blank>len<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u\\n"" , * len , get_arglen [ GET_CMDID ( cmd ) ] ) ; return - EINVAL ; } copylen = get_arglen [ GET_CMDID ( cmd ) ] ; if ( copylen > 128 ) return - EINVAL ; if ( copy_from_user ( arg , user , copylen ) != 0 ) return - EFAULT ; if ( cmd == IP_VS_SO_GET_DAEMON ) { struct ip_vs_daemon_user d [ 2 ] ; memset ( & d , 0 , sizeof ( d ) ) ; if ( mutex_lock_interruptible ( & ipvs -> sync_mutex ) ) return - ERESTARTSYS ; if ( ipvs -> sync_state & IP_VS_STATE_MASTER ) { d [ 0 ] . state = IP_VS_STATE_MASTER ; strlcpy ( d [ 0 ] . mcast_ifn , ipvs -> master_mcast_ifn , sizeof ( d [ 0 ] . mcast_ifn ) ) ; d [ 0 ] . syncid = ipvs -> master_syncid ; } if ( ipvs -> sync_state & IP_VS_STATE_BACKUP ) { d [ 1 ] . state = IP_VS_STATE_BACKUP ; strlcpy ( d [ 1 ] . mcast_ifn , ipvs -> backup_mcast_ifn , sizeof ( d [ 1 ] . mcast_ifn ) ) ; d [ 1 ] . syncid = ipvs -> backup_syncid ; } if ( copy_to_user ( user , & d , sizeof ( d ) ) != 0 ) ret = - EFAULT ; mutex_unlock ( & ipvs -> sync_mutex ) ; return ret ; } if ( mutex_lock_interruptible ( & __ip_vs_mutex ) ) return - ERESTARTSYS ; switch ( cmd ) { case IP_VS_SO_GET_VERSION : { char buf [ 64 ] ; sprintf ( buf , ""IP<S2SV_blank>Virtual<S2SV_blank>Server<S2SV_blank>version<S2SV_blank>%d.%d.%d<S2SV_blank>(size=%d)"" , NVERSION ( IP_VS_VERSION_CODE ) , ip_vs_conn_tab_size ) ; if ( copy_to_user ( user , buf , strlen ( buf ) + 1 ) != 0 ) { ret = - EFAULT ; goto out ; } * len = strlen ( buf ) + 1 ; } break ; case IP_VS_SO_GET_INFO : { struct ip_vs_getinfo info ; info . version = IP_VS_VERSION_CODE ; info . size = ip_vs_conn_tab_size ; info . num_services = ipvs -> num_services ; if ( copy_to_user ( user , & info , sizeof ( info ) ) != 0 ) ret = - EFAULT ; } break ; case IP_VS_SO_GET_SERVICES : { struct ip_vs_get_services * get ; int size ; get = ( struct ip_vs_get_services * ) arg ; size = sizeof ( * get ) + sizeof ( struct ip_vs_service_entry ) * get -> num_services ; if ( * len != size ) { pr_err ( ""length:<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\n"" , * len , size ) ; ret = - EINVAL ; goto out ; } ret = __ip_vs_get_service_entries ( net , get , user ) ; } break ; case IP_VS_SO_GET_SERVICE : { struct ip_vs_service_entry * entry ; struct ip_vs_service * svc ; union nf_inet_addr addr ; entry = ( struct ip_vs_service_entry * ) arg ; addr . ip = entry -> addr ; if ( entry -> fwmark ) svc = __ip_vs_svc_fwm_find ( net , AF_INET , entry -> fwmark ) ; else svc = __ip_vs_service_find ( net , AF_INET , entry -> protocol , & addr , entry -> port ) ; if ( svc ) { ip_vs_copy_service ( entry , svc ) ; if ( copy_to_user ( user , entry , sizeof ( * entry ) ) != 0 ) ret = - EFAULT ; } else ret = - ESRCH ; } break ; case IP_VS_SO_GET_DESTS : { struct ip_vs_get_dests * get ; int size ; get = ( struct ip_vs_get_dests * ) arg ; size = sizeof ( * get ) + sizeof ( struct ip_vs_dest_entry ) * get -> num_dests ; if ( * len != size ) { pr_err ( ""length:<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\n"" , * len , size ) ; ret = - EINVAL ; goto out ; } ret = __ip_vs_get_dest_entries ( net , get , user ) ; } break ; case IP_VS_SO_GET_TIMEOUT : { struct ip_vs_timeout_user t ; <S2SV_StartBug> __ip_vs_get_timeouts ( net , & t ) ; <S2SV_EndBug> if ( copy_to_user ( user , & t , sizeof ( t ) ) != 0 ) ret = - EFAULT ; } break ; default : ret = - EINVAL ; } out : mutex_unlock ( & __ip_vs_mutex ) ; return ret ; }
","<S2SV_ModStart> ip_vs_timeout_user t ; memset ( & t , 0 , sizeof ( t ) ) ;
"
293,"CWE-264 static int tcp_v6_send_synack ( const struct sock * sk , struct dst_entry * dst , struct flowi * fl , struct request_sock * req , struct tcp_fastopen_cookie * foc , bool attach_req ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct flowi6 * fl6 = & fl -> u . ip6 ; struct sk_buff * skb ; int err = - ENOMEM ; if ( ! dst && ( dst = inet6_csk_route_req ( sk , fl6 , req , IPPROTO_TCP ) ) == NULL ) goto done ; skb = tcp_make_synack ( sk , dst , req , foc , attach_req ) ; if ( skb ) { __tcp_v6_send_check ( skb , & ireq -> ir_v6_loc_addr , & ireq -> ir_v6_rmt_addr ) ; fl6 -> daddr = ireq -> ir_v6_rmt_addr ; if ( np -> repflow && ireq -> pktopts ) fl6 -> flowlabel = ip6_flowlabel ( ipv6_hdr ( ireq -> pktopts ) ) ; <S2SV_StartBug> err = ip6_xmit ( sk , skb , fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> err = net_xmit_eval ( err ) ; } done : return err ; }
","<S2SV_ModStart> , fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) , <S2SV_ModEnd> np -> tclass
"
294,"CWE-264 static ssize_t ib_ucm_write ( struct file * filp , const char __user * buf , size_t len , loff_t * pos ) { struct ib_ucm_file * file = filp -> private_data ; struct ib_ucm_cmd_hdr hdr ; <S2SV_StartBug> ssize_t result ; <S2SV_EndBug> if ( len < sizeof ( hdr ) ) return - EINVAL ; if ( copy_from_user ( & hdr , buf , sizeof ( hdr ) ) ) return - EFAULT ; if ( hdr . cmd >= ARRAY_SIZE ( ucm_cmd_table ) ) return - EINVAL ; if ( hdr . in + sizeof ( hdr ) > len ) return - EINVAL ; result = ucm_cmd_table [ hdr . cmd ] ( file , buf + sizeof ( hdr ) , hdr . in , hdr . out ) ; if ( ! result ) result = len ; return result ; }
","<S2SV_ModStart> ; ssize_t result ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES
"
295,"CWE-264 int cg_mkdir ( const char * path , mode_t mode ) { struct fuse_context * fc = fuse_get_context ( ) ; <S2SV_StartBug> char * fpath = NULL , * path1 , * cgdir = NULL , * controller ; <S2SV_EndBug> const char * cgroup ; int ret ; if ( ! fc ) return - EIO ; controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EINVAL ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) return - EINVAL ; get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) path1 = ""/"" ; else path1 = cgdir ; <S2SV_StartBug> if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) { <S2SV_EndBug> <S2SV_StartBug> ret = - EACCES ; <S2SV_EndBug> goto out ; } <S2SV_StartBug> if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) { <S2SV_EndBug> ret = - EACCES ; goto out ; } ret = cgfs_create ( controller , cgroup , fc -> uid , fc -> gid ) ; printf ( ""cgfs_create<S2SV_blank>returned<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>%s\\n"" , ret , controller , cgroup ) ; out : free ( cgdir ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }
","<S2SV_ModStart> , * controller , * next = NULL <S2SV_ModStart> if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , & next <S2SV_ModEnd> ) ) { <S2SV_ModStart> ) ) { if ( fpath && strcmp ( next , fpath ) == 0 ) ret = - EEXIST ; else ret = - ENOENT <S2SV_ModEnd> ; goto out <S2SV_ModStart> if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) { ret = - EACCES ; goto out ; } if ( ! <S2SV_ModStart> cgdir ) ; free ( next ) ;
"
296,"CWE-476 static void pcd_init_units ( void ) { struct pcd_unit * cd ; int unit ; pcd_drive_count = 0 ; for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { struct gendisk * disk = alloc_disk ( 1 ) ; if ( ! disk ) continue ; disk -> queue = blk_mq_init_sq_queue ( & cd -> tag_set , & pcd_mq_ops , 1 , BLK_MQ_F_SHOULD_MERGE ) ; if ( IS_ERR ( disk -> queue ) ) { <S2SV_StartBug> disk -> queue = NULL ; <S2SV_EndBug> continue ; } INIT_LIST_HEAD ( & cd -> rq_list ) ; disk -> queue -> queuedata = cd ; blk_queue_bounce_limit ( disk -> queue , BLK_BOUNCE_HIGH ) ; cd -> disk = disk ; cd -> pi = & cd -> pia ; cd -> present = 0 ; cd -> last_sense = 0 ; cd -> changed = 1 ; cd -> drive = ( * drives [ unit ] ) [ D_SLV ] ; if ( ( * drives [ unit ] ) [ D_PRT ] ) pcd_drive_count ++ ; cd -> name = & cd -> info . name [ 0 ] ; snprintf ( cd -> name , sizeof ( cd -> info . name ) , ""%s%d"" , name , unit ) ; cd -> info . ops = & pcd_dops ; cd -> info . handle = cd ; cd -> info . speed = 0 ; cd -> info . capacity = 1 ; cd -> info . mask = 0 ; disk -> major = major ; disk -> first_minor = unit ; strcpy ( disk -> disk_name , cd -> name ) ; disk -> fops = & pcd_bdops ; disk -> flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE ; } }
","<S2SV_ModStart> ) ) { put_disk ( disk ) ;
"
297,"CWE-125 <S2SV_StartBug> void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <S2SV_EndBug> { Stream_Write ( s , header -> Signature , sizeof ( NTLM_SIGNATURE ) ) ; Stream_Write_UINT32 ( s , header -> MessageType ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
"
298,"CWE-120 static Image * ReadVIFFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define VFF_CM_genericRGB 15 # define VFF_CM_ntscRGB 1 # define VFF_CM_NONE 0 # define VFF_DEP_DECORDER 0x4 # define VFF_DEP_NSORDER 0x8 # define VFF_DES_RAW 0 # define VFF_LOC_IMPLICIT 1 # define VFF_MAPTYP_NONE 0 # define VFF_MAPTYP_1_BYTE 1 # define VFF_MAPTYP_2_BYTE 2 # define VFF_MAPTYP_4_BYTE 4 # define VFF_MAPTYP_FLOAT 5 # define VFF_MAPTYP_DOUBLE 7 # define VFF_MS_NONE 0 # define VFF_MS_ONEPERBAND 1 # define VFF_MS_SHARED 3 # define VFF_TYP_BIT 0 # define VFF_TYP_1_BYTE 1 # define VFF_TYP_2_BYTE 2 # define VFF_TYP_4_BYTE 4 # define VFF_TYP_FLOAT 5 # define VFF_TYP_DOUBLE 9 typedef struct _ViffInfo { unsigned char identifier , file_type , release , version , machine_dependency , reserve [ 3 ] ; char comment [ 512 ] ; unsigned int rows , columns , subrows ; int x_offset , y_offset ; float x_bits_per_pixel , y_bits_per_pixel ; unsigned int location_type , location_dimension , number_of_images , number_data_bands , data_storage_type , data_encode_scheme , map_scheme , map_storage_type , map_rows , map_columns , map_subrows , map_enable , maps_per_cycle , color_space_model ; } ViffInfo ; double min_value , scale_factor , value ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bytes_per_pixel , max_packets , quantum ; ssize_t count , y ; unsigned char * pixels ; unsigned long lsb_first ; ViffInfo viff_info ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 1 , & viff_info . identifier ) ; do { if ( ( count != 1 ) || ( ( unsigned char ) viff_info . identifier != 0xab ) ) ThrowReaderException ( CorruptImageError , ""NotAVIFFImage"" ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . file_type ) , & viff_info . file_type ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . release ) , & viff_info . release ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . version ) , & viff_info . version ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . machine_dependency ) , & viff_info . machine_dependency ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . reserve ) , viff_info . reserve ) ; count = ReadBlob ( image , 512 , ( unsigned char * ) viff_info . comment ) ; viff_info . comment [ 511 ] = '\\0' ; if ( strlen ( viff_info . comment ) > 4 ) ( void ) SetImageProperty ( image , ""comment"" , viff_info . comment , exception ) ; if ( ( viff_info . machine_dependency == VFF_DEP_DECORDER ) || ( viff_info . machine_dependency == VFF_DEP_NSORDER ) ) image -> endian = LSBEndian ; else image -> endian = MSBEndian ; viff_info . rows = ReadBlobLong ( image ) ; viff_info . columns = ReadBlobLong ( image ) ; viff_info . subrows = ReadBlobLong ( image ) ; viff_info . x_offset = ReadBlobSignedLong ( image ) ; viff_info . y_offset = ReadBlobSignedLong ( image ) ; viff_info . x_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . y_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . location_type = ReadBlobLong ( image ) ; viff_info . location_dimension = ReadBlobLong ( image ) ; viff_info . number_of_images = ReadBlobLong ( image ) ; viff_info . number_data_bands = ReadBlobLong ( image ) ; viff_info . data_storage_type = ReadBlobLong ( image ) ; viff_info . data_encode_scheme = ReadBlobLong ( image ) ; viff_info . map_scheme = ReadBlobLong ( image ) ; viff_info . map_storage_type = ReadBlobLong ( image ) ; viff_info . map_rows = ReadBlobLong ( image ) ; viff_info . map_columns = ReadBlobLong ( image ) ; viff_info . map_subrows = ReadBlobLong ( image ) ; viff_info . map_enable = ReadBlobLong ( image ) ; viff_info . maps_per_cycle = ReadBlobLong ( image ) ; viff_info . color_space_model = ReadBlobLong ( image ) ; for ( i = 0 ; i < 420 ; i ++ ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; image -> columns = viff_info . rows ; image -> rows = viff_info . columns ; image -> depth = viff_info . x_bits_per_pixel <= 8 ? 8UL : MAGICKCORE_QUANTUM_DEPTH ; number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ; if ( number_pixels != ( size_t ) number_pixels ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( number_pixels == 0 ) ThrowReaderException ( CoderError , ""ImageColumnOrRowSizeIsNotSupported"" ) ; if ( ( viff_info . number_data_bands < 1 ) || ( viff_info . number_data_bands > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( viff_info . data_storage_type != VFF_TYP_BIT ) && ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_2_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_4_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_FLOAT ) && ( viff_info . data_storage_type != VFF_TYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""DataStorageTypeIsNotSupported"" ) ; if ( viff_info . data_encode_scheme != VFF_DES_RAW ) ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; if ( ( viff_info . map_storage_type != VFF_MAPTYP_NONE ) && ( viff_info . map_storage_type != VFF_MAPTYP_1_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_2_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_4_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_FLOAT ) && ( viff_info . map_storage_type != VFF_MAPTYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""MapStorageTypeIsNotSupported"" ) ; if ( ( viff_info . color_space_model != VFF_CM_NONE ) && ( viff_info . color_space_model != VFF_CM_ntscRGB ) && ( viff_info . color_space_model != VFF_CM_genericRGB ) ) ThrowReaderException ( CoderError , ""ColorspaceModelIsNotSupported"" ) ; if ( viff_info . location_type != VFF_LOC_IMPLICIT ) ThrowReaderException ( CoderError , ""LocationTypeIsNotSupported"" ) ; if ( viff_info . number_of_images != 1 ) ThrowReaderException ( CoderError , ""NumberOfImagesIsNotSupported"" ) ; if ( viff_info . map_rows == 0 ) viff_info . map_scheme = VFF_MS_NONE ; switch ( ( int ) viff_info . map_scheme ) { case VFF_MS_NONE : { if ( viff_info . number_data_bands < 3 ) { if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ; else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ; else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ; status = AcquireImageColormap ( image , image -> colors , exception ) ; if ( status == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : { unsigned char * viff_colormap ; switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ; break ; case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } image -> colors = viff_info . map_columns ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ; if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : { MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : { MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } default : break ; } for ( i = 0 ; i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ; i ++ ) { switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ; break ; default : value = 1.0 * viff_colormap [ i ] ; break ; } if ( i < ( ssize_t ) image -> colors ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ; } else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ; else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ; } viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = viff_info . number_data_bands == 4 ? BlendPixelTrait : UndefinedPixelTrait ; image -> storage_class = ( viff_info . number_data_bands < 3 ? PseudoClass : DirectClass ) ; image -> columns = viff_info . rows ; image -> rows = viff_info . columns ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_TYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } if ( viff_info . data_storage_type == VFF_TYP_BIT ) { <S2SV_StartBug> if ( CheckMemoryOverflow ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse ) <S2SV_EndBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; } else { <S2SV_StartBug> if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) <S2SV_EndBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ; } pixels = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , bytes_per_pixel * max_packets , pixels ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : { MSBOrderShort ( pixels , bytes_per_pixel * max_packets ) ; break ; } case VFF_TYP_4_BYTE : case VFF_TYP_FLOAT : { MSBOrderLong ( pixels , bytes_per_pixel * max_packets ) ; break ; } default : break ; } min_value = 0.0 ; scale_factor = 1.0 ; if ( ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . map_scheme == VFF_MS_NONE ) ) { double max_value ; switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ 0 ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ 0 ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ 0 ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ 0 ] ; break ; default : value = 1.0 * pixels [ 0 ] ; break ; } max_value = value ; min_value = value ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( value > max_value ) max_value = value ; else if ( value < min_value ) min_value = value ; } if ( ( min_value == 0 ) && ( max_value == 0 ) ) scale_factor = 0 ; else if ( min_value == max_value ) { scale_factor = ( double ) QuantumRange / min_value ; min_value = 0 ; } else scale_factor = ( double ) QuantumRange / ( max_value - min_value ) ; } p = ( unsigned char * ) pixels ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( viff_info . map_scheme == VFF_MS_NONE ) { value = ( value - min_value ) * scale_factor ; if ( value > QuantumRange ) value = QuantumRange ; else if ( value < 0 ) value = 0 ; } * p = ( unsigned char ) ( ( Quantum ) value ) ; p ++ ; } p = ( unsigned char * ) pixels ; if ( viff_info . data_storage_type == VFF_TYP_BIT ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) ( image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelGreen ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelBlue ( image , quantum == 0 ? 0 : QuantumRange , q ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , ( Quantum ) quantum , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( int ) ( image -> columns % 8 ) ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelGreen ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelBlue ( image , quantum == 0 ? 0 : QuantumRange , q ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , ( Quantum ) quantum , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else if ( image -> storage_class == PseudoClass ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else { number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + number_pixels ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 * number_pixels ) ) , q ) ; if ( image -> colors != 0 ) { ssize_t index ; index = ( ssize_t ) GetPixelRed ( image , q ) ; SetPixelRed ( image , image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . red , q ) ; index = ( ssize_t ) GetPixelGreen ( image , q ) ; SetPixelGreen ( image , image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . green , q ) ; index = ( ssize_t ) GetPixelBlue ( image , q ) ; SetPixelBlue ( image , image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . blue , q ) ; } SetPixelAlpha ( image , image -> alpha_trait != UndefinedPixelTrait ? ScaleCharToQuantum ( * ( p + number_pixels * 3 ) ) : OpaqueAlpha , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; count = ReadBlob ( image , 1 , & viff_info . identifier ) ; if ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> { if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( ( image <S2SV_ModStart> { if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( number_pixels ,
"
299,"CWE-399 static int asf_build_simple_index ( AVFormatContext * s , int stream_index ) { ff_asf_guid g ; ASFContext * asf = s -> priv_data ; int64_t current_pos = avio_tell ( s -> pb ) ; int64_t ret ; if ( ( ret = avio_seek ( s -> pb , asf -> data_object_offset + asf -> data_object_size , SEEK_SET ) ) < 0 ) { return ret ; } if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; while ( ff_guidcmp ( & g , & ff_asf_simple_index_header ) ) { int64_t gsize = avio_rl64 ( s -> pb ) ; if ( gsize < 24 || avio_feof ( s -> pb ) ) { goto end ; } avio_skip ( s -> pb , gsize - 24 ) ; if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; } { int64_t itime , last_pos = - 1 ; int pct , ict ; int i ; int64_t av_unused gsize = avio_rl64 ( s -> pb ) ; if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; itime = avio_rl64 ( s -> pb ) ; pct = avio_rl32 ( s -> pb ) ; ict = avio_rl32 ( s -> pb ) ; av_log ( s , AV_LOG_DEBUG , ""itime:0x%"" PRIx64 "",<S2SV_blank>pct:%d,<S2SV_blank>ict:%d\\n"" , itime , pct , ict ) ; for ( i = 0 ; i < ict ; i ++ ) { int pktnum = avio_rl32 ( s -> pb ) ; int pktct = avio_rl16 ( s -> pb ) ; int64_t pos = s -> internal -> data_offset + s -> packet_size * ( int64_t ) pktnum ; <S2SV_StartBug> int64_t index_pts = FFMAX ( av_rescale ( itime , i , 10000 ) - asf -> hdr . preroll , 0 ) ; <S2SV_EndBug> if ( pos != last_pos ) { av_log ( s , AV_LOG_DEBUG , ""pktnum:%d,<S2SV_blank>pktct:%d<S2SV_blank><S2SV_blank>pts:<S2SV_blank>%"" PRId64 ""\\n"" , pktnum , pktct , index_pts ) ; av_add_index_entry ( s -> streams [ stream_index ] , pos , index_pts , s -> packet_size , 0 , AVINDEX_KEYFRAME ) ; last_pos = pos ; } } asf -> index_read = ict > 1 ; } end : avio_seek ( s -> pb , current_pos , SEEK_SET ) ; return ret ; }
","<S2SV_ModStart> 0 ) ; if ( avio_feof ( s -> pb ) ) { ret = AVERROR_INVALIDDATA ; goto end ; }
"
300,"CWE-200 static long sg_ioctl ( struct file * filp , unsigned int cmd_in , unsigned long arg ) { void __user * p = ( void __user * ) arg ; int __user * ip = p ; int result , val , read_only ; Sg_device * sdp ; Sg_fd * sfp ; Sg_request * srp ; unsigned long iflags ; if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) return - ENXIO ; SCSI_LOG_TIMEOUT ( 3 , sg_printk ( KERN_INFO , sdp , ""sg_ioctl:<S2SV_blank>cmd=0x%x\\n"" , ( int ) cmd_in ) ) ; read_only = ( O_RDWR != ( filp -> f_flags & O_ACCMODE ) ) ; switch ( cmd_in ) { case SG_IO : if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; if ( ! scsi_block_when_processing_errors ( sdp -> device ) ) return - ENXIO ; if ( ! access_ok ( VERIFY_WRITE , p , SZ_SG_IO_HDR ) ) return - EFAULT ; result = sg_new_write ( sfp , filp , p , SZ_SG_IO_HDR , 1 , read_only , 1 , & srp ) ; if ( result < 0 ) return result ; result = wait_event_interruptible ( sfp -> read_wait , ( srp_done ( sfp , srp ) || atomic_read ( & sdp -> detaching ) ) ) ; if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; write_lock_irq ( & sfp -> rq_list_lock ) ; if ( srp -> done ) { srp -> done = 2 ; write_unlock_irq ( & sfp -> rq_list_lock ) ; result = sg_new_read ( sfp , p , SZ_SG_IO_HDR , srp ) ; return ( result < 0 ) ? result : 0 ; } srp -> orphan = 1 ; write_unlock_irq ( & sfp -> rq_list_lock ) ; return result ; case SG_SET_TIMEOUT : result = get_user ( val , ip ) ; if ( result ) return result ; if ( val < 0 ) return - EIO ; if ( val >= mult_frac ( ( s64 ) INT_MAX , USER_HZ , HZ ) ) val = min_t ( s64 , mult_frac ( ( s64 ) INT_MAX , USER_HZ , HZ ) , INT_MAX ) ; sfp -> timeout_user = val ; sfp -> timeout = mult_frac ( val , HZ , USER_HZ ) ; return 0 ; case SG_GET_TIMEOUT : return sfp -> timeout_user ; case SG_SET_FORCE_LOW_DMA : return 0 ; case SG_GET_LOW_DMA : return put_user ( ( int ) sdp -> device -> host -> unchecked_isa_dma , ip ) ; case SG_GET_SCSI_ID : if ( ! access_ok ( VERIFY_WRITE , p , sizeof ( sg_scsi_id_t ) ) ) return - EFAULT ; else { sg_scsi_id_t __user * sg_idp = p ; if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; __put_user ( ( int ) sdp -> device -> host -> host_no , & sg_idp -> host_no ) ; __put_user ( ( int ) sdp -> device -> channel , & sg_idp -> channel ) ; __put_user ( ( int ) sdp -> device -> id , & sg_idp -> scsi_id ) ; __put_user ( ( int ) sdp -> device -> lun , & sg_idp -> lun ) ; __put_user ( ( int ) sdp -> device -> type , & sg_idp -> scsi_type ) ; __put_user ( ( short ) sdp -> device -> host -> cmd_per_lun , & sg_idp -> h_cmd_per_lun ) ; __put_user ( ( short ) sdp -> device -> queue_depth , & sg_idp -> d_queue_depth ) ; __put_user ( 0 , & sg_idp -> unused [ 0 ] ) ; __put_user ( 0 , & sg_idp -> unused [ 1 ] ) ; return 0 ; } case SG_SET_FORCE_PACK_ID : result = get_user ( val , ip ) ; if ( result ) return result ; sfp -> force_packid = val ? 1 : 0 ; return 0 ; case SG_GET_PACK_ID : if ( ! access_ok ( VERIFY_WRITE , ip , sizeof ( int ) ) ) return - EFAULT ; read_lock_irqsave ( & sfp -> rq_list_lock , iflags ) ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( ( 1 == srp -> done ) && ( ! srp -> sg_io_owned ) ) { read_unlock_irqrestore ( & sfp -> rq_list_lock , iflags ) ; __put_user ( srp -> header . pack_id , ip ) ; return 0 ; } } read_unlock_irqrestore ( & sfp -> rq_list_lock , iflags ) ; __put_user ( - 1 , ip ) ; return 0 ; case SG_GET_NUM_WAITING : read_lock_irqsave ( & sfp -> rq_list_lock , iflags ) ; val = 0 ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( ( 1 == srp -> done ) && ( ! srp -> sg_io_owned ) ) ++ val ; } read_unlock_irqrestore ( & sfp -> rq_list_lock , iflags ) ; return put_user ( val , ip ) ; case SG_GET_SG_TABLESIZE : return put_user ( sdp -> sg_tablesize , ip ) ; case SG_SET_RESERVED_SIZE : result = get_user ( val , ip ) ; if ( result ) return result ; if ( val < 0 ) return - EINVAL ; val = min_t ( int , val , max_sectors_bytes ( sdp -> device -> request_queue ) ) ; mutex_lock ( & sfp -> f_mutex ) ; if ( val != sfp -> reserve . bufflen ) { if ( sfp -> mmap_called || sfp -> res_in_use ) { mutex_unlock ( & sfp -> f_mutex ) ; return - EBUSY ; } sg_remove_scat ( sfp , & sfp -> reserve ) ; sg_build_reserve ( sfp , val ) ; } mutex_unlock ( & sfp -> f_mutex ) ; return 0 ; case SG_GET_RESERVED_SIZE : val = min_t ( int , sfp -> reserve . bufflen , max_sectors_bytes ( sdp -> device -> request_queue ) ) ; return put_user ( val , ip ) ; case SG_SET_COMMAND_Q : result = get_user ( val , ip ) ; if ( result ) return result ; sfp -> cmd_q = val ? 1 : 0 ; return 0 ; case SG_GET_COMMAND_Q : return put_user ( ( int ) sfp -> cmd_q , ip ) ; case SG_SET_KEEP_ORPHAN : result = get_user ( val , ip ) ; if ( result ) return result ; sfp -> keep_orphan = val ; return 0 ; case SG_GET_KEEP_ORPHAN : return put_user ( ( int ) sfp -> keep_orphan , ip ) ; case SG_NEXT_CMD_LEN : result = get_user ( val , ip ) ; if ( result ) return result ; if ( val > SG_MAX_CDB_SIZE ) return - ENOMEM ; sfp -> next_cmd_len = ( val > 0 ) ? val : 0 ; return 0 ; case SG_GET_VERSION_NUM : return put_user ( sg_version_num , ip ) ; case SG_GET_ACCESS_COUNT : val = ( sdp -> device ? 1 : 0 ) ; return put_user ( val , ip ) ; case SG_GET_REQUEST_TABLE : if ( ! access_ok ( VERIFY_WRITE , p , SZ_SG_REQ_INFO * SG_MAX_QUEUE ) ) return - EFAULT ; else { sg_req_info_t * rinfo ; <S2SV_StartBug> rinfo = kmalloc ( SZ_SG_REQ_INFO * SG_MAX_QUEUE , <S2SV_EndBug> GFP_KERNEL ) ; if ( ! rinfo ) return - ENOMEM ; read_lock_irqsave ( & sfp -> rq_list_lock , iflags ) ; sg_fill_request_table ( sfp , rinfo ) ; read_unlock_irqrestore ( & sfp -> rq_list_lock , iflags ) ; result = __copy_to_user ( p , rinfo , SZ_SG_REQ_INFO * SG_MAX_QUEUE ) ; result = result ? - EFAULT : 0 ; kfree ( rinfo ) ; return result ; } case SG_EMULATED_HOST : if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; return put_user ( sdp -> device -> host -> hostt -> emulated , ip ) ; case SCSI_IOCTL_SEND_COMMAND : if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; if ( read_only ) { unsigned char opcode = WRITE_6 ; Scsi_Ioctl_Command __user * siocp = p ; if ( copy_from_user ( & opcode , siocp -> data , 1 ) ) return - EFAULT ; if ( sg_allow_access ( filp , & opcode ) ) return - EPERM ; } return sg_scsi_ioctl ( sdp -> device -> request_queue , NULL , filp -> f_mode , p ) ; case SG_SET_DEBUG : result = get_user ( val , ip ) ; if ( result ) return result ; sdp -> sgdebug = ( char ) val ; return 0 ; case BLKSECTGET : return put_user ( max_sectors_bytes ( sdp -> device -> request_queue ) , ip ) ; case BLKTRACESETUP : return blk_trace_setup ( sdp -> device -> request_queue , sdp -> disk -> disk_name , MKDEV ( SCSI_GENERIC_MAJOR , sdp -> index ) , NULL , p ) ; case BLKTRACESTART : return blk_trace_startstop ( sdp -> device -> request_queue , 1 ) ; case BLKTRACESTOP : return blk_trace_startstop ( sdp -> device -> request_queue , 0 ) ; case BLKTRACETEARDOWN : return blk_trace_remove ( sdp -> device -> request_queue ) ; case SCSI_IOCTL_GET_IDLUN : case SCSI_IOCTL_GET_BUS_NUMBER : case SCSI_IOCTL_PROBE_HOST : case SG_GET_TRANSFORM : case SG_SCSI_RESET : if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; break ; default : if ( read_only ) return - EPERM ; break ; } result = scsi_ioctl_block_when_processing_errors ( sdp -> device , cmd_in , filp -> f_flags & O_NDELAY ) ; if ( result ) return result ; return scsi_ioctl ( sdp -> device , cmd_in , p ) ; }
","<S2SV_ModStart> ; rinfo = kzalloc <S2SV_ModEnd> ( SZ_SG_REQ_INFO *
"
301,"CWE-200 void init_global_keywords ( bool global_active ) { install_keyword_root ( ""linkbeat_use_polling"" , use_polling_handler , global_active ) ; # if HAVE_DECL_CLONE_NEWNET install_keyword_root ( ""net_namespace"" , & net_namespace_handler , global_active ) ; install_keyword_root ( ""namespace_with_ipsets"" , & namespace_ipsets_handler , global_active ) ; # endif install_keyword_root ( ""use_pid_dir"" , & use_pid_dir_handler , global_active ) ; install_keyword_root ( ""instance"" , & instance_handler , global_active ) ; install_keyword_root ( ""child_wait_time"" , & child_wait_handler , global_active ) ; install_keyword_root ( ""global_defs"" , NULL , global_active ) ; install_keyword ( ""router_id"" , & routerid_handler ) ; install_keyword ( ""notification_email_from"" , & emailfrom_handler ) ; install_keyword ( ""smtp_server"" , & smtpserver_handler ) ; install_keyword ( ""smtp_helo_name"" , & smtphelo_handler ) ; install_keyword ( ""smtp_connect_timeout"" , & smtpto_handler ) ; install_keyword ( ""notification_email"" , & email_handler ) ; install_keyword ( ""smtp_alert"" , & smtp_alert_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( ""smtp_alert_vrrp"" , & smtp_alert_vrrp_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""smtp_alert_checker"" , & smtp_alert_checker_handler ) ; # endif # ifdef _WITH_VRRP_ install_keyword ( ""dynamic_interfaces"" , & dynamic_interfaces_handler ) ; install_keyword ( ""no_email_faults"" , & no_email_faults_handler ) ; install_keyword ( ""default_interface"" , & default_interface_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""lvs_timeouts"" , & lvs_timeouts ) ; install_keyword ( ""lvs_flush"" , & lvs_flush_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( ""lvs_sync_daemon"" , & lvs_syncd_handler ) ; # endif # endif # ifdef _WITH_VRRP_ install_keyword ( ""vrrp_mcast_group4"" , & vrrp_mcast_group4_handler ) ; install_keyword ( ""vrrp_mcast_group6"" , & vrrp_mcast_group6_handler ) ; install_keyword ( ""vrrp_garp_master_delay"" , & vrrp_garp_delay_handler ) ; install_keyword ( ""vrrp_garp_master_repeat"" , & vrrp_garp_rep_handler ) ; install_keyword ( ""vrrp_garp_master_refresh"" , & vrrp_garp_refresh_handler ) ; install_keyword ( ""vrrp_garp_master_refresh_repeat"" , & vrrp_garp_refresh_rep_handler ) ; install_keyword ( ""vrrp_garp_lower_prio_delay"" , & vrrp_garp_lower_prio_delay_handler ) ; install_keyword ( ""vrrp_garp_lower_prio_repeat"" , & vrrp_garp_lower_prio_rep_handler ) ; install_keyword ( ""vrrp_garp_interval"" , & vrrp_garp_interval_handler ) ; install_keyword ( ""vrrp_gna_interval"" , & vrrp_gna_interval_handler ) ; install_keyword ( ""vrrp_lower_prio_no_advert"" , & vrrp_lower_prio_no_advert_handler ) ; install_keyword ( ""vrrp_higher_prio_send_advert"" , & vrrp_higher_prio_send_advert_handler ) ; install_keyword ( ""vrrp_version"" , & vrrp_version_handler ) ; install_keyword ( ""vrrp_iptables"" , & vrrp_iptables_handler ) ; # ifdef _HAVE_LIBIPSET_ install_keyword ( ""vrrp_ipsets"" , & vrrp_ipsets_handler ) ; # endif install_keyword ( ""vrrp_check_unicast_src"" , & vrrp_check_unicast_src_handler ) ; install_keyword ( ""vrrp_skip_check_adv_addr"" , & vrrp_check_adv_addr_handler ) ; install_keyword ( ""vrrp_strict"" , & vrrp_strict_handler ) ; install_keyword ( ""vrrp_priority"" , & vrrp_prio_handler ) ; install_keyword ( ""vrrp_no_swap"" , & vrrp_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( ""vrrp_rt_priority"" , & vrrp_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( ""vrrp_rlimit_rtime"" , & vrrp_rt_rlimit_handler ) ; # endif # endif # endif install_keyword ( ""notify_fifo"" , & global_notify_fifo ) ; install_keyword ( ""notify_fifo_script"" , & global_notify_fifo_script ) ; # ifdef _WITH_VRRP_ install_keyword ( ""vrrp_notify_fifo"" , & vrrp_notify_fifo ) ; install_keyword ( ""vrrp_notify_fifo_script"" , & vrrp_notify_fifo_script ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""lvs_notify_fifo"" , & lvs_notify_fifo ) ; install_keyword ( ""lvs_notify_fifo_script"" , & lvs_notify_fifo_script ) ; install_keyword ( ""checker_priority"" , & checker_prio_handler ) ; install_keyword ( ""checker_no_swap"" , & checker_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( ""checker_rt_priority"" , & checker_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( ""checker_rlimit_rtime"" , & checker_rt_rlimit_handler ) ; # endif # endif # endif # ifdef _WITH_BFD_ install_keyword ( ""bfd_priority"" , & bfd_prio_handler ) ; install_keyword ( ""bfd_no_swap"" , & bfd_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( ""bfd_rt_priority"" , & bfd_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( ""bfd_rlimit_rtime"" , & bfd_rt_rlimit_handler ) ; # endif # endif # endif # ifdef _WITH_SNMP_ install_keyword ( ""snmp_socket"" , & snmp_socket_handler ) ; install_keyword ( ""enable_traps"" , & trap_handler ) ; # ifdef _WITH_SNMP_VRRP_ install_keyword ( ""enable_snmp_vrrp"" , & snmp_vrrp_handler ) ; install_keyword ( ""enable_snmp_keepalived"" , & snmp_vrrp_handler ) ; # endif # ifdef _WITH_SNMP_RFC_ install_keyword ( ""enable_snmp_rfc"" , & snmp_rfc_handler ) ; # endif # ifdef _WITH_SNMP_RFCV2_ install_keyword ( ""enable_snmp_rfcv2"" , & snmp_rfcv2_handler ) ; # endif # ifdef _WITH_SNMP_RFCV3_ install_keyword ( ""enable_snmp_rfcv3"" , & snmp_rfcv3_handler ) ; # endif # ifdef _WITH_SNMP_CHECKER_ install_keyword ( ""enable_snmp_checker"" , & snmp_checker_handler ) ; # endif # endif # ifdef _WITH_DBUS_ install_keyword ( ""enable_dbus"" , & enable_dbus_handler ) ; install_keyword ( ""dbus_service_name"" , & dbus_service_name_handler ) ; # endif install_keyword ( ""script_user"" , & script_user_handler ) ; install_keyword ( ""enable_script_security"" , & script_security_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( ""vrrp_netlink_cmd_rcv_bufs"" , & vrrp_netlink_cmd_rcv_bufs_handler ) ; install_keyword ( ""vrrp_netlink_cmd_rcv_bufs_force"" , & vrrp_netlink_cmd_rcv_bufs_force_handler ) ; install_keyword ( ""vrrp_netlink_monitor_rcv_bufs"" , & vrrp_netlink_monitor_rcv_bufs_handler ) ; install_keyword ( ""vrrp_netlink_monitor_rcv_bufs_force"" , & vrrp_netlink_monitor_rcv_bufs_force_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""lvs_netlink_cmd_rcv_bufs"" , & lvs_netlink_cmd_rcv_bufs_handler ) ; install_keyword ( ""lvs_netlink_cmd_rcv_bufs_force"" , & lvs_netlink_cmd_rcv_bufs_force_handler ) ; install_keyword ( ""lvs_netlink_monitor_rcv_bufs"" , & lvs_netlink_monitor_rcv_bufs_handler ) ; install_keyword ( ""lvs_netlink_monitor_rcv_bufs_force"" , & lvs_netlink_monitor_rcv_bufs_force_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""rs_init_notifies"" , & rs_init_notifies_handler ) ; install_keyword ( ""no_checker_emails"" , & no_checker_emails_handler ) ; # endif # ifdef _WITH_VRRP_ install_keyword ( ""vrrp_rx_bufs_policy"" , & vrrp_rx_bufs_policy_handler ) ; install_keyword ( ""vrrp_rx_bufs_multiplier"" , & vrrp_rx_bufs_multiplier_handler ) ; # endif <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ; # endif install_keyword ( ""umask"" , & umask_handler ) ;
"
302,"CWE-119 static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) { <S2SV_StartBug> return encoder_common_init ( ctx ) ; <S2SV_EndBug> }
","<S2SV_ModStart> data ) { vpx_codec_err_t res = VPX_CODEC_OK ; ( void ) data ; if ( ctx -> priv == NULL ) { vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1 , sizeof ( * priv ) ) ; if ( priv == NULL ) return VPX_CODEC_MEM_ERROR ; ctx -> priv = ( vpx_codec_priv_t * ) priv ; ctx -> priv -> init_flags = ctx -> init_flags ; ctx -> priv -> enc . total_encoders = 1 ; priv -> buffer_pool = ( BufferPool * ) vpx_calloc ( 1 , sizeof ( BufferPool ) ) ; if ( priv -> buffer_pool == NULL ) return VPX_CODEC_MEM_ERROR ; # if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & priv -> buffer_pool -> pool_mutex , NULL ) ) { return VPX_CODEC_MEM_ERROR ; } # endif if ( ctx -> config . enc ) { priv -> cfg = * ctx -> config . enc ; ctx -> config . enc = & priv -> cfg ; } priv -> extra_cfg = default_extra_cfg ; once ( vp9_initialize_enc ) ; res = validate_config ( priv , & priv -> cfg , & priv -> extra_cfg ) ; if ( res == VPX_CODEC_OK ) { set_encoder_config ( & priv -> oxcf , & priv -> cfg , & priv -> extra_cfg ) ; # if CONFIG_VP9_HIGHBITDEPTH priv -> oxcf . use_highbitdepth = ( ctx -> init_flags & VPX_CODEC_USE_HIGHBITDEPTH ) ? 1 : 0 ; # endif priv -> cpi = vp9_create_compressor ( & priv -> oxcf , priv -> buffer_pool ) ; if ( priv -> cpi == NULL ) res = VPX_CODEC_MEM_ERROR ; else priv -> cpi -> output_pkt_list = & priv -> pkt_list . head ; } } return res <S2SV_ModEnd> ; } <S2SV_null>
"
303,"CWE-119 int iscsi_decode_text_input ( u8 phase , u8 sender , char * textbuf , u32 length , struct iscsi_conn * conn ) { struct iscsi_param_list * param_list = conn -> param_list ; char * tmpbuf , * start = NULL , * end = NULL ; tmpbuf = kzalloc ( length + 1 , GFP_KERNEL ) ; if ( ! tmpbuf ) { pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>tmpbuf.\\n"" ) ; return - 1 ; } memcpy ( tmpbuf , textbuf , length ) ; tmpbuf [ length ] = '\\0' ; start = tmpbuf ; end = ( start + length ) ; while ( start < end ) { char * key , * value ; struct iscsi_param * param ; if ( iscsi_extract_key_value ( start , & key , & value ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } pr_debug ( ""Got<S2SV_blank>key:<S2SV_blank>%s=%s\\n"" , key , value ) ; if ( phase & PHASE_SECURITY ) { if ( iscsi_check_for_auth_key ( key ) > 0 ) { <S2SV_StartBug> char * tmpptr = key + strlen ( key ) ; <S2SV_EndBug> * tmpptr = '=' ; kfree ( tmpbuf ) ; return 1 ; } } param = iscsi_check_key ( key , phase , sender , param_list ) ; if ( ! param ) { if ( iscsi_add_notunderstood_response ( key , value , param_list ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } start += strlen ( key ) + strlen ( value ) + 2 ; continue ; } if ( iscsi_check_value ( param , value ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } start += strlen ( key ) + strlen ( value ) + 2 ; if ( IS_PSTATE_PROPOSER ( param ) ) { if ( iscsi_check_proposer_state ( param , value ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } SET_PSTATE_RESPONSE_GOT ( param ) ; } else { if ( iscsi_check_acceptor_state ( param , value , conn ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } SET_PSTATE_ACCEPTOR ( param ) ; } } kfree ( tmpbuf ) ; return 0 ; }
","<S2SV_ModStart> 0 ) { <S2SV_ModEnd> kfree ( tmpbuf
"
304,"CWE-264 static int timer_start ( Unit * u ) { Timer * t = TIMER ( u ) ; TimerValue * v ; assert ( t ) ; assert ( t -> state == TIMER_DEAD || t -> state == TIMER_FAILED ) ; if ( UNIT_TRIGGER ( u ) -> load_state != UNIT_LOADED ) return - ENOENT ; t -> last_trigger = DUAL_TIMESTAMP_NULL ; LIST_FOREACH ( value , v , t -> values ) if ( v -> base == TIMER_ACTIVE ) v -> disabled = false ; if ( t -> stamp_path ) { struct stat st ; if ( stat ( t -> stamp_path , & st ) >= 0 ) t -> last_trigger . realtime = timespec_load ( & st . st_atim ) ; else if ( errno == ENOENT ) <S2SV_StartBug> touch_file ( t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> } t -> result = TIMER_SUCCESS ; timer_enter_waiting ( t , true ) ; return 1 ; }
","<S2SV_ModStart> , GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) ; }
"
305,"CWE-476 jp2_box_t * jp2_box_get ( jas_stream_t * in ) { jp2_box_t * box ; jp2_boxinfo_t * boxinfo ; jas_stream_t * tmpstream ; uint_fast32_t len ; uint_fast64_t extlen ; bool dataflag ; box = 0 ; tmpstream = 0 ; <S2SV_StartBug> if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { <S2SV_EndBug> goto error ; } box -> ops = & jp2_boxinfo_unk . ops ; if ( jp2_getuint32 ( in , & len ) || jp2_getuint32 ( in , & box -> type ) ) { goto error ; } boxinfo = jp2_boxinfolookup ( box -> type ) ; box -> info = boxinfo ; box -> len = len ; JAS_DBGLOG ( 10 , ( <S2SV_StartBug> ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n"" , <S2SV_EndBug> \'""\' , boxinfo -> name , \'""\' , box -> type , box -> len ) ) ; <S2SV_StartBug> if ( box -> len == 1 ) { <S2SV_EndBug> if ( jp2_getuint64 ( in , & extlen ) ) { goto error ; } if ( extlen > 0xffffffffUL ) { jas_eprintf ( ""warning:<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>large<S2SV_blank>64-bit<S2SV_blank>box<S2SV_blank>length\\n"" ) ; extlen = 0xffffffffUL ; } box -> len = extlen ; box -> datalen = extlen - JP2_BOX_HDRLEN ( true ) ; } else { box -> datalen = box -> len - JP2_BOX_HDRLEN ( false ) ; } if ( box -> len != 0 && box -> len < 8 ) { goto error ; } dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ; if ( dataflag ) { if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( jas_stream_copy ( tmpstream , in , box -> datalen ) ) { jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n"" ) ; goto error ; } jas_stream_rewind ( tmpstream ) ; box -> ops = & boxinfo -> ops ; if ( box -> ops -> getdata ) { if ( ( * box -> ops -> getdata ) ( box , tmpstream ) ) { jas_eprintf ( ""cannot<S2SV_blank>parse<S2SV_blank>box<S2SV_blank>data\\n"" ) ; goto error ; } } jas_stream_close ( tmpstream ) ; } if ( jas_getdbglevel ( ) >= 1 ) { jp2_box_dump ( box , stderr ) ; } return box ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( tmpstream ) { jas_stream_close ( tmpstream ) ; } return 0 ; }
","<S2SV_ModStart> ( box = jp2_box_create0 ( ) ) ) { goto error ; } <S2SV_ModEnd> if ( jp2_getuint32 <S2SV_ModStart> 10 , ( ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>"" ""type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%"" PRIuFAST32 ""\\n"" <S2SV_ModEnd> , \'""\' , <S2SV_ModStart> 1 ) { JAS_DBGLOG ( 10 , ( ""big<S2SV_blank>length\\n"" ) ) ;
"
306,"CWE-190 static int <S2SV_StartBug> _Unpickler_ResizeMemoList ( UnpicklerObject * self , Py_ssize_t new_size ) <S2SV_EndBug> { <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> assert ( new_size > self -> memo_size ) ; PyObject * * memo_new = self -> memo ; PyMem_RESIZE ( memo_new , PyObject * , new_size ) ; if ( memo_new == NULL ) { PyErr_NoMemory ( ) ; return - 1 ; } self -> memo = memo_new ; for ( i = self -> memo_size ; i < new_size ; i ++ ) self -> memo [ i ] = NULL ; self -> memo_size = new_size ; return 0 ; }
","<S2SV_ModStart> * self , size_t <S2SV_ModEnd> new_size ) { <S2SV_ModStart> new_size ) { size_t <S2SV_ModEnd> i ; assert
"
307,"CWE-119 static ssize_t macvtap_get_user ( struct macvtap_queue * q , struct msghdr * m , const struct iovec * iv , unsigned long total_len , size_t count , int noblock ) { struct sk_buff * skb ; struct macvlan_dev * vlan ; unsigned long len = total_len ; int err ; struct virtio_net_hdr vnet_hdr = { 0 } ; int vnet_hdr_len = 0 ; <S2SV_StartBug> int copylen ; <S2SV_EndBug> bool zerocopy = false ; if ( q -> flags & IFF_VNET_HDR ) { vnet_hdr_len = q -> vnet_hdr_sz ; err = - EINVAL ; if ( len < vnet_hdr_len ) goto err ; len -= vnet_hdr_len ; err = memcpy_fromiovecend ( ( void * ) & vnet_hdr , iv , 0 , sizeof ( vnet_hdr ) ) ; if ( err < 0 ) goto err ; if ( ( vnet_hdr . flags & VIRTIO_NET_HDR_F_NEEDS_CSUM ) && vnet_hdr . csum_start + vnet_hdr . csum_offset + 2 > vnet_hdr . hdr_len ) vnet_hdr . hdr_len = vnet_hdr . csum_start + vnet_hdr . csum_offset + 2 ; err = - EINVAL ; if ( vnet_hdr . hdr_len > len ) goto err ; } err = - EINVAL ; if ( unlikely ( len < ETH_HLEN ) ) goto err ; <S2SV_StartBug> if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) ) <S2SV_EndBug> zerocopy = true ; if ( zerocopy ) { <S2SV_StartBug> copylen = vnet_hdr . hdr_len ; <S2SV_EndBug> if ( ! copylen ) copylen = GOODCOPY_LEN ; } else copylen = len ; skb = macvtap_alloc_skb ( & q -> sk , NET_IP_ALIGN , copylen , vnet_hdr . hdr_len , noblock , & err ) ; if ( ! skb ) goto err ; if ( zerocopy ) err = zerocopy_sg_from_iovec ( skb , iv , vnet_hdr_len , count ) ; else err = skb_copy_datagram_from_iovec ( skb , 0 , iv , vnet_hdr_len , len ) ; if ( err ) goto err_kfree ; skb_set_network_header ( skb , ETH_HLEN ) ; skb_reset_mac_header ( skb ) ; skb -> protocol = eth_hdr ( skb ) -> h_proto ; if ( vnet_hdr_len ) { err = macvtap_skb_from_vnet_hdr ( skb , & vnet_hdr ) ; if ( err ) goto err_kfree ; } rcu_read_lock_bh ( ) ; vlan = rcu_dereference_bh ( q -> vlan ) ; if ( zerocopy ) { skb_shinfo ( skb ) -> destructor_arg = m -> msg_control ; skb_shinfo ( skb ) -> tx_flags |= SKBTX_DEV_ZEROCOPY ; } if ( vlan ) macvlan_start_xmit ( skb , vlan -> dev ) ; else kfree_skb ( skb ) ; rcu_read_unlock_bh ( ) ; return total_len ; err_kfree : kfree_skb ( skb ) ; err : rcu_read_lock_bh ( ) ; vlan = rcu_dereference_bh ( q -> vlan ) ; if ( vlan ) vlan -> dev -> stats . tx_dropped ++ ; rcu_read_unlock_bh ( ) ; return err ; }
","<S2SV_ModStart> ; int copylen = 0 <S2SV_ModStart> goto err ; err = - EMSGSIZE ; if ( unlikely ( count > UIO_MAXIOV ) ) goto err ; <S2SV_ModStart> zerocopy ) { if ( count > MAX_SKB_FRAGS ) { copylen = iov_length ( iv , count - MAX_SKB_FRAGS ) ; if ( copylen < vnet_hdr_len ) copylen = 0 ; else copylen -= vnet_hdr_len ; } if ( copylen < vnet_hdr . hdr_len )
"
308,"CWE-125 int ip6_find_1stfragopt ( struct sk_buff * skb , u8 * * nexthdr ) { <S2SV_StartBug> u16 offset = sizeof ( struct ipv6hdr ) ; <S2SV_EndBug> struct ipv6_opt_hdr * exthdr = ( struct ipv6_opt_hdr * ) ( ipv6_hdr ( skb ) + 1 ) ; unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ; int found_rhdr = 0 ; * nexthdr = & ipv6_hdr ( skb ) -> nexthdr ; <S2SV_StartBug> while ( offset + 1 <= packet_len ) { <S2SV_EndBug> <S2SV_StartBug> switch ( * * nexthdr ) { <S2SV_EndBug> case NEXTHDR_HOP : break ; case NEXTHDR_ROUTING : found_rhdr = 1 ; break ; case NEXTHDR_DEST : # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) if ( ipv6_find_tlv ( skb , offset , IPV6_TLV_HAO ) >= 0 ) break ; # endif if ( found_rhdr ) return offset ; break ; default : return offset ; } <S2SV_StartBug> offset += ipv6_optlen ( exthdr ) ; <S2SV_EndBug> * nexthdr = & exthdr -> nexthdr ; <S2SV_StartBug> exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + <S2SV_EndBug> offset ) ; } return offset ; }
","<S2SV_ModStart> ( struct ipv6hdr <S2SV_ModEnd> ) ; unsigned <S2SV_ModStart> while ( offset <S2SV_ModEnd> <= packet_len ) <S2SV_ModStart> packet_len ) { struct ipv6_opt_hdr * exthdr ; <S2SV_ModStart> offset ; } if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <S2SV_ModStart> -> nexthdr ; } return - EINVAL <S2SV_ModEnd> ; } <S2SV_null>
"
309,"CWE-119 <S2SV_StartBug> static void write_delta_q ( struct vp9_write_bit_buffer * wb , int delta_q ) { <S2SV_EndBug> if ( delta_q != 0 ) { <S2SV_StartBug> vp9_wb_write_bit ( wb , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , abs ( delta_q ) , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , delta_q < 0 ) ; <S2SV_EndBug> } else { <S2SV_StartBug> vp9_wb_write_bit ( wb , 0 ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> write_delta_q ( struct vpx_write_bit_buffer <S2SV_ModEnd> * wb , <S2SV_ModStart> 0 ) { vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> 1 ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> 4 ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> } else { vpx_wb_write_bit <S2SV_ModEnd> ( wb ,
"
310,"CWE-119 void vp8_mv_pred ( VP8_COMP * cpi , MACROBLOCKD * xd , const MODE_INFO * here , int_mv * mvp , int refframe , int * ref_frame_sign_bias , int * sr , int near_sadidx [ ] ) { const MODE_INFO * above = here - xd -> mode_info_stride ; const MODE_INFO * left = here - 1 ; const MODE_INFO * aboveleft = above - 1 ; int_mv near_mvs [ 8 ] ; int near_ref [ 8 ] ; int_mv mv ; int vcnt = 0 ; int find = 0 ; int mb_offset ; int mvx [ 8 ] ; int mvy [ 8 ] ; int i ; mv . as_int = 0 ; if ( here -> mbmi . ref_frame != INTRA_FRAME ) { near_mvs [ 0 ] . as_int = near_mvs [ 1 ] . as_int = near_mvs [ 2 ] . as_int = near_mvs [ 3 ] . as_int = near_mvs [ 4 ] . as_int = near_mvs [ 5 ] . as_int = near_mvs [ 6 ] . as_int = near_mvs [ 7 ] . as_int = 0 ; near_ref [ 0 ] = near_ref [ 1 ] = near_ref [ 2 ] = near_ref [ 3 ] = near_ref [ 4 ] = near_ref [ 5 ] = near_ref [ 6 ] = near_ref [ 7 ] = 0 ; if ( above -> mbmi . ref_frame != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = above -> mbmi . mv . as_int ; mv_bias ( ref_frame_sign_bias [ above -> mbmi . ref_frame ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = above -> mbmi . ref_frame ; } vcnt ++ ; if ( left -> mbmi . ref_frame != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = left -> mbmi . mv . as_int ; mv_bias ( ref_frame_sign_bias [ left -> mbmi . ref_frame ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = left -> mbmi . ref_frame ; } vcnt ++ ; if ( aboveleft -> mbmi . ref_frame != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = aboveleft -> mbmi . mv . as_int ; mv_bias ( ref_frame_sign_bias [ aboveleft -> mbmi . ref_frame ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = aboveleft -> mbmi . ref_frame ; } vcnt ++ ; if ( cpi -> common . last_frame_type != KEY_FRAME ) { mb_offset = ( - xd -> mb_to_top_edge / 128 + 1 ) * ( xd -> mode_info_stride + 1 ) + ( - xd -> mb_to_left_edge / 128 + 1 ) ; if ( cpi -> lf_ref_frame [ mb_offset ] != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = cpi -> lfmv [ mb_offset ] . as_int ; mv_bias ( cpi -> lf_ref_frame_sign_bias [ mb_offset ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = cpi -> lf_ref_frame [ mb_offset ] ; } vcnt ++ ; if ( cpi -> lf_ref_frame [ mb_offset - xd -> mode_info_stride - 1 ] != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = cpi -> lfmv [ mb_offset - xd -> mode_info_stride - 1 ] . as_int ; mv_bias ( cpi -> lf_ref_frame_sign_bias [ mb_offset - xd -> mode_info_stride - 1 ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = cpi -> lf_ref_frame [ mb_offset - xd -> mode_info_stride - 1 ] ; } vcnt ++ ; if ( cpi -> lf_ref_frame [ mb_offset - 1 ] != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = cpi -> lfmv [ mb_offset - 1 ] . as_int ; mv_bias ( cpi -> lf_ref_frame_sign_bias [ mb_offset - 1 ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = cpi -> lf_ref_frame [ mb_offset - 1 ] ; } vcnt ++ ; if ( cpi -> lf_ref_frame [ mb_offset + 1 ] != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = cpi -> lfmv [ mb_offset + 1 ] . as_int ; mv_bias ( cpi -> lf_ref_frame_sign_bias [ mb_offset + 1 ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = cpi -> lf_ref_frame [ mb_offset + 1 ] ; } vcnt ++ ; if ( cpi -> lf_ref_frame [ mb_offset + xd -> mode_info_stride + 1 ] != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = cpi -> lfmv [ mb_offset + xd -> mode_info_stride + 1 ] . as_int ; mv_bias ( cpi -> lf_ref_frame_sign_bias [ mb_offset + xd -> mode_info_stride + 1 ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = cpi -> lf_ref_frame [ mb_offset + xd -> mode_info_stride + 1 ] ; } vcnt ++ ; } for ( i = 0 ; i < vcnt ; i ++ ) { if ( near_ref [ near_sadidx [ i ] ] != INTRA_FRAME ) { if ( here -> mbmi . ref_frame == near_ref [ near_sadidx [ i ] ] ) { mv . as_int = near_mvs [ near_sadidx [ i ] ] . as_int ; find = 1 ; if ( i < 3 ) * sr = 3 ; else * sr = 2 ; break ; } } } if ( ! find ) { for ( i = 0 ; i < vcnt ; i ++ ) { mvx [ i ] = near_mvs [ i ] . as_mv . row ; mvy [ i ] = near_mvs [ i ] . as_mv . col ; } insertsortmv ( mvx , vcnt ) ; insertsortmv ( mvy , vcnt ) ; mv . as_mv . row = mvx [ vcnt / 2 ] ; mv . as_mv . col = mvy [ vcnt / 2 ] ; <S2SV_StartBug> find = 1 ; <S2SV_EndBug> * sr = 0 ; } } mvp -> as_int = mv . as_int ; vp8_clamp_mv2 ( mvp , xd ) ; }
","<S2SV_ModStart> 2 ] ; <S2SV_ModEnd> * sr =
"
311,"CWE-264 static int packet_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int copied , err ; struct sockaddr_ll * sll ; int vnet_hdr_len = 0 ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT | MSG_ERRQUEUE ) ) goto out ; # if 0 if ( pkt_sk ( sk ) -> ifindex < 0 ) return - ENODEV ; # endif if ( flags & MSG_ERRQUEUE ) { err = packet_recv_error ( sk , msg , len ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; if ( pkt_sk ( sk ) -> has_vnet_hdr ) { struct virtio_net_hdr vnet_hdr = { 0 } ; err = - EINVAL ; vnet_hdr_len = sizeof ( vnet_hdr ) ; if ( len < vnet_hdr_len ) goto out_free ; len -= vnet_hdr_len ; if ( skb_is_gso ( skb ) ) { struct skb_shared_info * sinfo = skb_shinfo ( skb ) ; vnet_hdr . hdr_len = skb_headlen ( skb ) ; vnet_hdr . gso_size = sinfo -> gso_size ; if ( sinfo -> gso_type & SKB_GSO_TCPV4 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV4 ; else if ( sinfo -> gso_type & SKB_GSO_TCPV6 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV6 ; else if ( sinfo -> gso_type & SKB_GSO_UDP ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_UDP ; else if ( sinfo -> gso_type & SKB_GSO_FCOE ) goto out_free ; else BUG ( ) ; if ( sinfo -> gso_type & SKB_GSO_TCP_ECN ) vnet_hdr . gso_type |= VIRTIO_NET_HDR_GSO_ECN ; } else vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) { vnet_hdr . flags = VIRTIO_NET_HDR_F_NEEDS_CSUM ; vnet_hdr . csum_start = skb_checksum_start_offset ( skb ) ; vnet_hdr . csum_offset = skb -> csum_offset ; } err = memcpy_toiovec ( msg -> msg_iov , ( void * ) & vnet_hdr , vnet_hdr_len ) ; if ( err < 0 ) goto out_free ; } sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; if ( sock -> type == SOCK_PACKET ) msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ; else msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ; copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , msg -> msg_namelen ) ; if ( pkt_sk ( sk ) -> auxdata ) { struct tpacket_auxdata aux ; aux . tp_status = TP_STATUS_USER ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) aux . tp_status |= TP_STATUS_CSUMNOTREADY ; aux . tp_len = PACKET_SKB_CB ( skb ) -> origlen ; aux . tp_snaplen = skb -> len ; aux . tp_mac = 0 ; aux . tp_net = skb_network_offset ( skb ) ; if ( vlan_tx_tag_present ( skb ) ) { aux . tp_vlan_tci = vlan_tx_tag_get ( skb ) ; aux . tp_status |= TP_STATUS_VLAN_VALID ; } else { aux . tp_vlan_tci = 0 ; } <S2SV_StartBug> put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ; <S2SV_EndBug> } err = vnet_hdr_len + ( ( flags & MSG_TRUNC ) ? skb -> len : copied ) ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; }
","<S2SV_ModStart> 0 ; } aux . tp_padding = 0 ;
"
312,"CWE-119 static void logi_dj_recv_add_djhid_device ( struct dj_receiver_dev * djrcv_dev , struct dj_report * dj_report ) { struct hid_device * djrcv_hdev = djrcv_dev -> hdev ; struct usb_interface * intf = to_usb_interface ( djrcv_hdev -> dev . parent ) ; struct usb_device * usbdev = interface_to_usbdev ( intf ) ; struct hid_device * dj_hiddev ; struct dj_device * dj_dev ; unsigned char tmpstr [ 3 ] ; if ( dj_report -> report_params [ DEVICE_PAIRED_PARAM_SPFUNCTION ] & SPFUNCTION_DEVICE_LIST_EMPTY ) { dbg_hid ( ""%s:<S2SV_blank>device<S2SV_blank>list<S2SV_blank>is<S2SV_blank>empty\\n"" , __func__ ) ; djrcv_dev -> querying_devices = false ; return ; } <S2SV_StartBug> if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || <S2SV_EndBug> ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) { dev_err ( & djrcv_hdev -> dev , ""%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\n"" , __func__ , dj_report -> device_index ) ; return ; } if ( djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] ) { dbg_hid ( ""%s:<S2SV_blank>device<S2SV_blank>is<S2SV_blank>already<S2SV_blank>known\\n"" , __func__ ) ; return ; } dj_hiddev = hid_allocate_device ( ) ; if ( IS_ERR ( dj_hiddev ) ) { dev_err ( & djrcv_hdev -> dev , ""%s:<S2SV_blank>hid_allocate_device<S2SV_blank>failed\\n"" , __func__ ) ; return ; } dj_hiddev -> ll_driver = & logi_dj_ll_driver ; dj_hiddev -> dev . parent = & djrcv_hdev -> dev ; dj_hiddev -> bus = BUS_USB ; dj_hiddev -> vendor = le16_to_cpu ( usbdev -> descriptor . idVendor ) ; dj_hiddev -> product = le16_to_cpu ( usbdev -> descriptor . idProduct ) ; snprintf ( dj_hiddev -> name , sizeof ( dj_hiddev -> name ) , ""Logitech<S2SV_blank>Unifying<S2SV_blank>Device.<S2SV_blank>Wireless<S2SV_blank>PID:%02x%02x"" , dj_report -> report_params [ DEVICE_PAIRED_PARAM_EQUAD_ID_MSB ] , dj_report -> report_params [ DEVICE_PAIRED_PARAM_EQUAD_ID_LSB ] ) ; usb_make_path ( usbdev , dj_hiddev -> phys , sizeof ( dj_hiddev -> phys ) ) ; snprintf ( tmpstr , sizeof ( tmpstr ) , "":%d"" , dj_report -> device_index ) ; strlcat ( dj_hiddev -> phys , tmpstr , sizeof ( dj_hiddev -> phys ) ) ; dj_dev = kzalloc ( sizeof ( struct dj_device ) , GFP_KERNEL ) ; if ( ! dj_dev ) { dev_err ( & djrcv_hdev -> dev , ""%s:<S2SV_blank>failed<S2SV_blank>allocating<S2SV_blank>dj_device\\n"" , __func__ ) ; goto dj_device_allocate_fail ; } dj_dev -> reports_supported = get_unaligned_le32 ( dj_report -> report_params + DEVICE_PAIRED_RF_REPORT_TYPE ) ; dj_dev -> hdev = dj_hiddev ; dj_dev -> dj_receiver_dev = djrcv_dev ; dj_dev -> device_index = dj_report -> device_index ; dj_hiddev -> driver_data = dj_dev ; djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] = dj_dev ; if ( hid_add_device ( dj_hiddev ) ) { dev_err ( & djrcv_hdev -> dev , ""%s:<S2SV_blank>failed<S2SV_blank>adding<S2SV_blank>dj_device\\n"" , __func__ ) ; goto hid_add_device_fail ; } return ; hid_add_device_fail : djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] = NULL ; kfree ( dj_dev ) ; dj_device_allocate_fail : hid_destroy_device ( dj_hiddev ) ; }
","<S2SV_ModStart> } if ( <S2SV_ModEnd> djrcv_dev -> paired_dj_devices
"
313,"CWE-119 static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { <S2SV_StartBug> pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" <S2SV_EndBug> ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
","<S2SV_ModStart> ) ) { pr_debug <S2SV_ModEnd> ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>""
"
314,"CWE-190 int bson_check_field_name ( bson * b , const char * string , <S2SV_StartBug> const int length ) { <S2SV_EndBug> return bson_validate_string ( b , ( const unsigned char * ) string , length , 1 , 1 , 1 ) ; }
","<S2SV_ModStart> string , const size_t <S2SV_ModEnd> length ) {
"
315,"CWE-20 struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { <S2SV_StartBug> sctp_addiphdr_t * hdr ; <S2SV_EndBug> union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; <S2SV_StartBug> int all_param_pass = 1 ; <S2SV_EndBug> chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; <S2SV_StartBug> while ( chunk_len > 0 ) { <S2SV_EndBug> err_code = sctp_process_asconf_param ( asoc , asconf , <S2SV_StartBug> asconf_param ) ; <S2SV_EndBug> if ( SCTP_ERROR_NO_ERROR != err_code ) <S2SV_StartBug> all_param_pass = 0 ; <S2SV_EndBug> if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , <S2SV_StartBug> asconf_param -> crr_id , err_code , <S2SV_EndBug> asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; <S2SV_StartBug> length = ntohs ( asconf_param -> param_hdr . length ) ; <S2SV_EndBug> asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }
","<S2SV_ModStart> asconf ) { sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) asconf -> chunk_hdr ; bool all_param_pass = true ; union sctp_params param ; <S2SV_ModStart> __u32 serial ; <S2SV_ModEnd> chunk_len = ntohs <S2SV_ModStart> goto done ; sctp_walk_params ( param , addip , addip_hdr . params ) { if ( param . p -> type == SCTP_PARAM_IPV4_ADDRESS || param . p -> type == SCTP_PARAM_IPV6_ADDRESS ) continue ; <S2SV_ModEnd> err_code = sctp_process_asconf_param <S2SV_ModStart> , asconf , param . addip ) ; if ( err_code != SCTP_ERROR_NO_ERROR <S2SV_ModEnd> ) all_param_pass = <S2SV_ModStart> ) all_param_pass = false <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( asconf_ack , param . addip <S2SV_ModEnd> -> crr_id , <S2SV_ModStart> -> crr_id , err_code , param . addip ) ; if ( err_code == SCTP_ERROR_RSRC_LOW <S2SV_ModEnd> ) goto done <S2SV_ModStart> goto done ; <S2SV_ModEnd> } done :
"
316,"CWE-190 void * jas_realloc ( void * ptr , size_t size ) { void * result ; <S2SV_StartBug> JAS_DBGLOG ( 101 , ( ""jas_realloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%x,%zu\\n"" , ptr , size ) ) ; <S2SV_EndBug> result = realloc ( ptr , size ) ; JAS_DBGLOG ( 100 , ( ""jas_realloc(%p,<S2SV_blank>%zu)<S2SV_blank>-><S2SV_blank>%p\\n"" , ptr , size , result ) ) ; return result ; }
","<S2SV_ModStart> 101 , ( ""jas_realloc(%x,<S2SV_blank>%zu)\\n"" <S2SV_ModEnd> , ptr ,
"
317,"CWE-20 static int recv_msg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; u32 err ; int res ; if ( unlikely ( ! buf_len ) ) return - EINVAL ; lock_sock ( sk ) ; if ( unlikely ( sock -> state == SS_UNCONNECTED ) ) { res = - ENOTCONN ; goto exit ; } <S2SV_StartBug> m -> msg_namelen = 0 ; <S2SV_EndBug> timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == SS_DISCONNECTING ) { res = - ENOTCONN ; goto exit ; } if ( timeout <= 0L ) { res = timeout ? timeout : - EWOULDBLOCK ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } set_orig_addr ( m , msg ) ; res = anc_data_recv ( m , msg , tport ) ; if ( res ) goto exit ; if ( ! err ) { if ( unlikely ( buf_len < sz ) ) { sz = buf_len ; m -> msg_flags |= MSG_TRUNC ; } res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) , m -> msg_iov , sz ) ; if ( res ) goto exit ; res = sz ; } else { if ( ( sock -> state == SS_READY ) || ( ( err == TIPC_CONN_SHUTDOWN ) || m -> msg_control ) ) res = 0 ; else res = - ECONNRESET ; } if ( likely ( ! ( flags & MSG_PEEK ) ) ) { if ( ( sock -> state != SS_READY ) && ( ++ tport -> conn_unacked >= TIPC_FLOW_CONTROL_WIN ) ) tipc_acknowledge ( tport -> ref , tport -> conn_unacked ) ; advance_rx_queue ( sk ) ; } exit : release_sock ( sk ) ; return res ; }
","<S2SV_ModStart> exit ; } <S2SV_ModEnd> timeout = sock_rcvtimeo
"
318,"CWE-476 int kvm_vm_ioctl_check_extension ( struct kvm * kvm , long ext ) { int r ; int hv_enabled = kvmppc_hv_ops ? 1 : 0 ; if ( kvm ) { hv_enabled = is_kvmppc_hv_enabled ( kvm ) ; } switch ( ext ) { # ifdef CONFIG_BOOKE case KVM_CAP_PPC_BOOKE_SREGS : case KVM_CAP_PPC_BOOKE_WATCHDOG : case KVM_CAP_PPC_EPR : # else case KVM_CAP_PPC_SEGSTATE : case KVM_CAP_PPC_HIOR : case KVM_CAP_PPC_PAPR : # endif case KVM_CAP_PPC_UNSET_IRQ : case KVM_CAP_PPC_IRQ_LEVEL : case KVM_CAP_ENABLE_CAP : case KVM_CAP_ENABLE_CAP_VM : case KVM_CAP_ONE_REG : case KVM_CAP_IOEVENTFD : case KVM_CAP_DEVICE_CTRL : case KVM_CAP_IMMEDIATE_EXIT : r = 1 ; break ; case KVM_CAP_PPC_PAIRED_SINGLES : case KVM_CAP_PPC_OSI : case KVM_CAP_PPC_GET_PVINFO : # if defined ( CONFIG_KVM_E500V2 ) || defined ( CONFIG_KVM_E500MC ) case KVM_CAP_SW_TLB : # endif r = ! hv_enabled ; break ; # ifdef CONFIG_KVM_MPIC case KVM_CAP_IRQ_MPIC : r = 1 ; break ; # endif # ifdef CONFIG_PPC_BOOK3S_64 case KVM_CAP_SPAPR_TCE : case KVM_CAP_SPAPR_TCE_64 : case KVM_CAP_SPAPR_TCE_VFIO : case KVM_CAP_PPC_RTAS : case KVM_CAP_PPC_FIXUP_HCALL : case KVM_CAP_PPC_ENABLE_HCALL : # ifdef CONFIG_KVM_XICS case KVM_CAP_IRQ_XICS : # endif r = 1 ; break ; case KVM_CAP_PPC_ALLOC_HTAB : r = hv_enabled ; break ; # endif # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE case KVM_CAP_PPC_SMT : r = 0 ; if ( kvm ) { if ( kvm -> arch . emul_smt_mode > 1 ) r = kvm -> arch . emul_smt_mode ; else r = kvm -> arch . smt_mode ; } else if ( hv_enabled ) { if ( cpu_has_feature ( CPU_FTR_ARCH_300 ) ) r = 1 ; else r = threads_per_subcore ; } break ; case KVM_CAP_PPC_SMT_POSSIBLE : r = 1 ; if ( hv_enabled ) { if ( ! cpu_has_feature ( CPU_FTR_ARCH_300 ) ) r = ( ( threads_per_subcore << 1 ) - 1 ) ; else r = 8 | 4 | 2 | 1 ; } break ; case KVM_CAP_PPC_RMA : r = 0 ; break ; case KVM_CAP_PPC_HWRNG : r = kvmppc_hwrng_present ( ) ; break ; case KVM_CAP_PPC_MMU_RADIX : r = ! ! ( hv_enabled && radix_enabled ( ) ) ; break ; case KVM_CAP_PPC_MMU_HASH_V3 : r = ! ! ( hv_enabled && ! radix_enabled ( ) && cpu_has_feature ( CPU_FTR_ARCH_300 ) ) ; break ; # endif case KVM_CAP_SYNC_MMU : # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE r = hv_enabled ; # elif defined ( KVM_ARCH_WANT_MMU_NOTIFIER ) r = 1 ; # else r = 0 ; # endif break ; # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE case KVM_CAP_PPC_HTAB_FD : r = hv_enabled ; break ; # endif case KVM_CAP_NR_VCPUS : if ( hv_enabled ) r = num_present_cpus ( ) ; else r = num_online_cpus ( ) ; break ; case KVM_CAP_NR_MEMSLOTS : r = KVM_USER_MEM_SLOTS ; break ; case KVM_CAP_MAX_VCPUS : r = KVM_MAX_VCPUS ; break ; # ifdef CONFIG_PPC_BOOK3S_64 case KVM_CAP_PPC_GET_SMMU_INFO : r = 1 ; break ; case KVM_CAP_SPAPR_MULTITCE : r = 1 ; break ; case KVM_CAP_SPAPR_RESIZE_HPT : r = ! ! hv_enabled && ! cpu_has_feature ( CPU_FTR_ARCH_300 ) ; break ; # endif # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE case KVM_CAP_PPC_FWNMI : r = hv_enabled ; break ; # endif case KVM_CAP_PPC_HTM : r = cpu_has_feature ( CPU_FTR_TM_COMP ) && <S2SV_StartBug> is_kvmppc_hv_enabled ( kvm ) ; <S2SV_EndBug> break ; default : r = 0 ; break ; } return r ; }
","<S2SV_ModStart> CPU_FTR_TM_COMP ) && hv_enabled <S2SV_ModEnd> ; break ;
"
319,"CWE-617 int pci_emul_add_msicap ( struct pci_vdev * dev , int msgnum ) { struct msicap msicap ; <S2SV_StartBug> pci_populate_msicap ( & msicap , msgnum , 0 ) ; <S2SV_EndBug> return pci_emul_add_capability ( dev , ( u_char * ) & msicap , sizeof ( msicap ) ) ; }
","<S2SV_ModStart> msicap msicap ; return <S2SV_ModStart> , 0 ) || <S2SV_ModEnd> pci_emul_add_capability ( dev
"
320,"CWE-119 static void kvp_respond_to_host ( char * key , char * value , int error ) { struct hv_kvp_msg * kvp_msg ; struct hv_kvp_msg_enumerate * kvp_data ; char * key_name ; struct icmsg_hdr * icmsghdrp ; int keylen , valuelen ; u32 buf_len ; struct vmbus_channel * channel ; u64 req_id ; if ( ! kvp_transaction . active ) { pr_warn ( ""KVP:<S2SV_blank>Transaction<S2SV_blank>not<S2SV_blank>active\\n"" ) ; return ; } buf_len = kvp_transaction . recv_len ; channel = kvp_transaction . recv_channel ; req_id = kvp_transaction . recv_req_id ; kvp_transaction . active = false ; if ( channel -> onchannel_callback == NULL ) return ; icmsghdrp = ( struct icmsg_hdr * ) & recv_buffer [ sizeof ( struct vmbuspipe_hdr ) ] ; kvp_msg = ( struct hv_kvp_msg * ) & recv_buffer [ sizeof ( struct vmbuspipe_hdr ) + sizeof ( struct icmsg_hdr ) ] ; kvp_data = & kvp_msg -> kvp_data ; key_name = key ; if ( error ) { icmsghdrp -> status = HV_E_FAIL ; goto response_done ; } <S2SV_StartBug> keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . key ) ; <S2SV_EndBug> kvp_data -> data . key_size = 2 * ( keylen + 1 ) ; <S2SV_StartBug> valuelen = utf8s_to_utf16s ( value , strlen ( value ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . value ) ; <S2SV_EndBug> kvp_data -> data . value_size = 2 * ( valuelen + 1 ) ; kvp_data -> data . value_type = REG_SZ ; icmsghdrp -> status = HV_S_OK ; response_done : icmsghdrp -> icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE ; vmbus_sendpacket ( channel , recv_buffer , buf_len , req_id , VM_PKT_DATA_INBAND , 0 ) ; }
","<S2SV_ModStart> key_name ) , UTF16_HOST_ENDIAN , <S2SV_ModStart> data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2 <S2SV_ModStart> value ) , UTF16_HOST_ENDIAN , <S2SV_ModStart> data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2
"
321,"CWE-399 long vhost_dev_ioctl ( struct vhost_dev * d , unsigned int ioctl , void __user * argp ) { struct file * eventfp , * filep = NULL ; struct eventfd_ctx * ctx = NULL ; u64 p ; long r ; int i , fd ; if ( ioctl == VHOST_SET_OWNER ) { r = vhost_dev_set_owner ( d ) ; goto done ; } r = vhost_dev_check_owner ( d ) ; if ( r ) goto done ; switch ( ioctl ) { case VHOST_SET_MEM_TABLE : r = vhost_set_memory ( d , argp ) ; break ; case VHOST_SET_LOG_BASE : if ( copy_from_user ( & p , argp , sizeof p ) ) { r = - EFAULT ; break ; } if ( ( u64 ) ( unsigned long ) p != p ) { r = - EFAULT ; break ; } for ( i = 0 ; i < d -> nvqs ; ++ i ) { struct vhost_virtqueue * vq ; void __user * base = ( void __user * ) ( unsigned long ) p ; vq = d -> vqs [ i ] ; mutex_lock ( & vq -> mutex ) ; if ( vq -> private_data && ! vq_log_access_ok ( vq , base ) ) r = - EFAULT ; else vq -> log_base = base ; mutex_unlock ( & vq -> mutex ) ; } break ; case VHOST_SET_LOG_FD : r = get_user ( fd , ( int __user * ) argp ) ; if ( r < 0 ) break ; eventfp = fd == - 1 ? NULL : eventfd_fget ( fd ) ; if ( IS_ERR ( eventfp ) ) { r = PTR_ERR ( eventfp ) ; break ; } if ( eventfp != d -> log_file ) { filep = d -> log_file ; <S2SV_StartBug> ctx = d -> log_ctx ; <S2SV_EndBug> d -> log_ctx = eventfp ? eventfd_ctx_fileget ( eventfp ) : NULL ; } else filep = eventfp ; for ( i = 0 ; i < d -> nvqs ; ++ i ) { mutex_lock ( & d -> vqs [ i ] -> mutex ) ; d -> vqs [ i ] -> log_ctx = d -> log_ctx ; mutex_unlock ( & d -> vqs [ i ] -> mutex ) ; } if ( ctx ) eventfd_ctx_put ( ctx ) ; if ( filep ) fput ( filep ) ; break ; default : r = - ENOIOCTLCMD ; break ; } done : return r ; }
","<S2SV_ModStart> -> log_file ; d -> log_file = eventfp ;
"
322,"CWE-125 void color_sycc_to_rgb ( opj_image_t * img ) { if ( img -> numcomps < 3 ) { img -> color_space = OPJ_CLRSPC_GRAY ; return ; } if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 2 ) && ( img -> comps [ 2 ] . dx == 2 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 2 ) && ( img -> comps [ 2 ] . dy == 2 ) ) { sycc420_to_rgb ( img ) ; } else if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 2 ) && ( img -> comps [ 2 ] . dx == 2 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 1 ) && ( img -> comps [ 2 ] . dy == 1 ) ) { sycc422_to_rgb ( img ) ; } else if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 1 ) && ( img -> comps [ 2 ] . dx == 1 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 1 ) && ( img -> comps [ 2 ] . dy == 1 ) ) { sycc444_to_rgb ( img ) ; } else { fprintf ( stderr , ""%s:%d:color_sycc_to_rgb\\n\\tCAN<S2SV_blank>NOT<S2SV_blank>CONVERT\\n"" , __FILE__ , __LINE__ ) ; return ; } <S2SV_StartBug> img -> color_space = OPJ_CLRSPC_SRGB ; <S2SV_EndBug> }
","<S2SV_ModStart> return ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
323,"CWE-399 long video_usercopy ( struct file * file , unsigned int cmd , unsigned long arg , v4l2_kioctl func ) { char sbuf [ 128 ] ; void * mbuf = NULL ; <S2SV_StartBug> void * parg = NULL ; <S2SV_EndBug> long err = - EINVAL ; <S2SV_StartBug> int is_ext_ctrl ; <S2SV_EndBug> size_t ctrls_size = 0 ; void __user * user_ptr = NULL ; is_ext_ctrl = ( cmd == VIDIOC_S_EXT_CTRLS || cmd == VIDIOC_G_EXT_CTRLS || cmd == VIDIOC_TRY_EXT_CTRLS ) ; switch ( _IOC_DIR ( cmd ) ) { <S2SV_StartBug> case _IOC_NONE : <S2SV_EndBug> parg = NULL ; break ; case _IOC_READ : <S2SV_StartBug> case _IOC_WRITE : <S2SV_EndBug> case ( _IOC_WRITE | _IOC_READ ) : <S2SV_StartBug> if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) { <S2SV_EndBug> parg = sbuf ; } else { mbuf = kmalloc ( _IOC_SIZE ( cmd ) , GFP_KERNEL ) ; if ( NULL == mbuf ) return - ENOMEM ; parg = mbuf ; } err = - EFAULT ; if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) if ( copy_from_user ( parg , ( void __user * ) arg , _IOC_SIZE ( cmd ) ) ) goto out ; break ; } if ( is_ext_ctrl ) { struct v4l2_ext_controls * p = parg ; p -> error_idx = p -> count ; user_ptr = ( void __user * ) p -> controls ; if ( p -> count ) { ctrls_size = sizeof ( struct v4l2_ext_control ) * p -> count ; mbuf = kmalloc ( ctrls_size , GFP_KERNEL ) ; err = - ENOMEM ; if ( NULL == mbuf ) goto out_ext_ctrl ; err = - EFAULT ; if ( copy_from_user ( mbuf , user_ptr , ctrls_size ) ) goto out_ext_ctrl ; p -> controls = mbuf ; } } err = func ( file , cmd , parg ) ; if ( err == - ENOIOCTLCMD ) err = - EINVAL ; if ( is_ext_ctrl ) { struct v4l2_ext_controls * p = parg ; p -> controls = ( void * ) user_ptr ; if ( p -> count && err == 0 && copy_to_user ( user_ptr , mbuf , ctrls_size ) ) err = - EFAULT ; goto out_ext_ctrl ; } if ( err < 0 ) goto out ; out_ext_ctrl : switch ( _IOC_DIR ( cmd ) ) { case _IOC_READ : case ( _IOC_WRITE | _IOC_READ ) : if ( copy_to_user ( ( void __user * ) arg , parg , _IOC_SIZE ( cmd ) ) ) err = - EFAULT ; break ; } out : kfree ( mbuf ) ; return err ; }
","<S2SV_ModStart> * parg = ( void * ) arg ; long err = - EINVAL ; bool has_array_args ; size_t array_size = 0 ; void __user * user_ptr = NULL ; void * * kernel_ptr = NULL ; if ( _IOC_DIR ( cmd ) != _IOC_NONE ) { if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) { parg = sbuf ; } else { mbuf = kmalloc ( _IOC_SIZE ( cmd ) , GFP_KERNEL ) ; if ( NULL == mbuf ) return - ENOMEM ; parg = mbuf ; } err = - EFAULT ; if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) { unsigned long n = cmd_input_size ( cmd ) ; if ( copy_from_user ( parg , ( void __user * ) arg , n ) ) goto out ; if ( n < _IOC_SIZE ( cmd ) ) memset ( ( u8 * ) parg + n , 0 , _IOC_SIZE ( cmd ) - n ) ; } else { memset ( parg , 0 , _IOC_SIZE ( cmd ) ) ; } } err = check_array_args ( cmd , parg , & array_size , & user_ptr , & kernel_ptr ) ; if ( err < 0 ) goto out ; has_array_args = err ; if ( has_array_args ) { mbuf = kmalloc ( array_size , GFP_KERNEL ) ; err = - ENOMEM ; if ( NULL == mbuf ) goto out_array_args ; err = - EFAULT ; if ( copy_from_user ( mbuf , user_ptr , array_size ) ) goto out_array_args ; * kernel_ptr = mbuf ; } err = func ( file , cmd , parg ) ; if ( err == - ENOIOCTLCMD ) <S2SV_ModEnd> err = - <S2SV_ModStart> - EINVAL ; if ( has_array_args ) { * kernel_ptr = user_ptr ; if ( copy_to_user ( user_ptr , mbuf , array_size ) ) err = - EFAULT ; goto out_array_args ; } if ( err < 0 ) goto out ; out_array_args : <S2SV_ModEnd> switch ( _IOC_DIR <S2SV_ModStart> ) ) { <S2SV_ModEnd> case _IOC_READ : <S2SV_ModStart> _IOC_READ : case <S2SV_ModEnd> ( _IOC_WRITE | <S2SV_ModStart> : if ( <S2SV_ModEnd> copy_to_user ( (
"
324,"CWE-20 int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknown<S2SV_blank>command<S2SV_blank>\'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>\'%s\'<S2SV_blank>command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operation<S2SV_blank>not<S2SV_blank>permitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""command<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>when<S2SV_blank>used<S2SV_blank>memory<S2SV_blank>><S2SV_blank>\'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only<S2SV_blank>(P)SUBSCRIBE<S2SV_blank>/<S2SV_blank>(P)UNSUBSCRIBE<S2SV_blank>/<S2SV_blank>QUIT<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""link<S2SV_blank>with<S2SV_blank>MASTER<S2SV_blank>is<S2SV_blank>down<S2SV_blank>and<S2SV_blank>slave-serve-stale-data<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>no"" ) ; return REDIS_OK ; } if ( server . loading && cmd -> proc != infoCommand ) { addReply ( c , shared . loadingerr ) ; return REDIS_OK ; } if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) { queueMultiCommand ( c , cmd ) ; addReply ( c , shared . queued ) ; } else { <S2SV_StartBug> if ( server . vm_enabled && server . vm_max_threads > 0 && <S2SV_EndBug> blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ; call ( c , cmd ) ; } return REDIS_OK ; }
","<S2SV_ModStart> ( server . ds_enabled && <S2SV_ModEnd> blockClientOnSwappedKeys ( c
"
325,"CWE-119 <S2SV_StartBug> static int set_registers ( rtl8150_t * dev , u16 indx , u16 size , void * data ) <S2SV_EndBug> { <S2SV_StartBug> return usb_control_msg ( dev -> udev , usb_sndctrlpipe ( dev -> udev , 0 ) , <S2SV_EndBug> RTL8150_REQ_SET_REGS , RTL8150_REQT_WRITE , <S2SV_StartBug> indx , 0 , data , size , 500 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> u16 size , const <S2SV_ModStart> data ) { void * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = <S2SV_ModEnd> usb_control_msg ( dev <S2SV_ModStart> , 0 , buf <S2SV_ModEnd> , size , <S2SV_ModStart> 500 ) ; kfree ( buf ) ; return ret ;
"
326,"CWE-000 static int gtco_probe ( struct usb_interface * usbinterface , const struct usb_device_id * id ) { struct gtco * gtco ; struct input_dev * input_dev ; struct hid_descriptor * hid_desc ; char * report ; int result = 0 , retry ; int error ; struct usb_endpoint_descriptor * endpoint ; gtco = kzalloc ( sizeof ( struct gtco ) , GFP_KERNEL ) ; input_dev = input_allocate_device ( ) ; if ( ! gtco || ! input_dev ) { dev_err ( & usbinterface -> dev , ""No<S2SV_blank>more<S2SV_blank>memory\\n"" ) ; error = - ENOMEM ; goto err_free_devs ; } gtco -> inputdevice = input_dev ; gtco -> usbdev = interface_to_usbdev ( usbinterface ) ; gtco -> intf = usbinterface ; gtco -> buffer = usb_alloc_coherent ( gtco -> usbdev , REPORT_MAX_SIZE , GFP_KERNEL , & gtco -> buf_dma ) ; if ( ! gtco -> buffer ) { dev_err ( & usbinterface -> dev , ""No<S2SV_blank>more<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>us<S2SV_blank>buffers\\n"" ) ; error = - ENOMEM ; goto err_free_devs ; } gtco -> urbinfo = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! gtco -> urbinfo ) { dev_err ( & usbinterface -> dev , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>URB\\n"" ) ; error = - ENOMEM ; goto err_free_buf ; } <S2SV_StartBug> endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; <S2SV_EndBug> dev_dbg ( & usbinterface -> dev , ""gtco<S2SV_blank>#<S2SV_blank>interfaces:<S2SV_blank>%d\\n"" , usbinterface -> num_altsetting ) ; dev_dbg ( & usbinterface -> dev , ""num<S2SV_blank>endpoints:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , usbinterface -> cur_altsetting -> desc . bNumEndpoints ) ; dev_dbg ( & usbinterface -> dev , ""interface<S2SV_blank>class:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , usbinterface -> cur_altsetting -> desc . bInterfaceClass ) ; dev_dbg ( & usbinterface -> dev , ""endpoint:<S2SV_blank>attribute:0x%x<S2SV_blank>type:0x%x\\n"" , endpoint -> bmAttributes , endpoint -> bDescriptorType ) ; if ( usb_endpoint_xfer_int ( endpoint ) ) dev_dbg ( & usbinterface -> dev , ""endpoint:<S2SV_blank>we<S2SV_blank>have<S2SV_blank>interrupt<S2SV_blank>endpoint\\n"" ) ; dev_dbg ( & usbinterface -> dev , ""endpoint<S2SV_blank>extra<S2SV_blank>len:%d\\n"" , usbinterface -> altsetting [ 0 ] . extralen ) ; if ( usb_get_extra_descriptor ( usbinterface -> cur_altsetting , HID_DEVICE_TYPE , & hid_desc ) != 0 ) { dev_err ( & usbinterface -> dev , ""Can\'t<S2SV_blank>retrieve<S2SV_blank>exta<S2SV_blank>USB<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>get<S2SV_blank>hid<S2SV_blank>report<S2SV_blank>descriptor<S2SV_blank>length\\n"" ) ; error = - EIO ; goto err_free_urb ; } dev_dbg ( & usbinterface -> dev , ""Extra<S2SV_blank>descriptor<S2SV_blank>success:<S2SV_blank>type:%d<S2SV_blank><S2SV_blank>len:%d\\n"" , hid_desc -> bDescriptorType , hid_desc -> wDescriptorLength ) ; report = kzalloc ( le16_to_cpu ( hid_desc -> wDescriptorLength ) , GFP_KERNEL ) ; if ( ! report ) { dev_err ( & usbinterface -> dev , ""No<S2SV_blank>more<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>report\\n"" ) ; error = - ENOMEM ; goto err_free_urb ; } for ( retry = 0 ; retry < 3 ; retry ++ ) { result = usb_control_msg ( gtco -> usbdev , usb_rcvctrlpipe ( gtco -> usbdev , 0 ) , USB_REQ_GET_DESCRIPTOR , USB_RECIP_INTERFACE | USB_DIR_IN , REPORT_DEVICE_TYPE << 8 , 0 , report , le16_to_cpu ( hid_desc -> wDescriptorLength ) , 5000 ) ; dev_dbg ( & usbinterface -> dev , ""usb_control_msg<S2SV_blank>result:<S2SV_blank>%d\\n"" , result ) ; if ( result == le16_to_cpu ( hid_desc -> wDescriptorLength ) ) { parse_hid_report_descriptor ( gtco , report , result ) ; break ; } } kfree ( report ) ; if ( result != le16_to_cpu ( hid_desc -> wDescriptorLength ) ) { dev_err ( & usbinterface -> dev , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>HID<S2SV_blank>Report<S2SV_blank>Descriptor<S2SV_blank>of<S2SV_blank>size:<S2SV_blank>%d\\n"" , hid_desc -> wDescriptorLength ) ; error = - EIO ; goto err_free_urb ; } usb_make_path ( gtco -> usbdev , gtco -> usbpath , sizeof ( gtco -> usbpath ) ) ; strlcat ( gtco -> usbpath , ""/input0"" , sizeof ( gtco -> usbpath ) ) ; input_dev -> open = gtco_input_open ; input_dev -> close = gtco_input_close ; input_dev -> name = ""GTCO_CalComp"" ; input_dev -> phys = gtco -> usbpath ; input_set_drvdata ( input_dev , gtco ) ; gtco_setup_caps ( input_dev ) ; usb_to_input_id ( gtco -> usbdev , & input_dev -> id ) ; input_dev -> dev . parent = & usbinterface -> dev ; endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; usb_fill_int_urb ( gtco -> urbinfo , gtco -> usbdev , usb_rcvintpipe ( gtco -> usbdev , endpoint -> bEndpointAddress ) , gtco -> buffer , REPORT_MAX_SIZE , gtco_urb_callback , gtco , endpoint -> bInterval ) ; gtco -> urbinfo -> transfer_dma = gtco -> buf_dma ; gtco -> urbinfo -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; usb_set_intfdata ( usbinterface , gtco ) ; error = input_register_device ( input_dev ) ; if ( error ) goto err_free_urb ; return 0 ; err_free_urb : usb_free_urb ( gtco -> urbinfo ) ; err_free_buf : usb_free_coherent ( gtco -> usbdev , REPORT_MAX_SIZE , gtco -> buffer , gtco -> buf_dma ) ; err_free_devs : input_free_device ( input_dev ) ; kfree ( gtco ) ; return error ; }
","<S2SV_ModStart> err_free_buf ; } if ( usbinterface -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & usbinterface -> dev , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n"" ) ; error = - EINVAL ; goto err_free_urb ; }
"
327,"CWE-20 static void untrusted_launcher_response_callback ( GtkDialog * dialog , int response_id , ActivateParametersDesktop * parameters ) { GdkScreen * screen ; char * uri ; GFile * file ; switch ( response_id ) { <S2SV_StartBug> case RESPONSE_RUN : <S2SV_EndBug> { screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window ) ) ; uri = nautilus_file_get_uri ( parameters -> file ) ; DEBUG ( ""Launching<S2SV_blank>untrusted<S2SV_blank>launcher<S2SV_blank>%s"" , uri ) ; nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ; g_free ( uri ) ; <S2SV_StartBug> } <S2SV_EndBug> break ; case RESPONSE_MARK_TRUSTED : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_mark_desktop_file_trusted ( file , parameters -> parent_window , TRUE , NULL , NULL ) ; g_object_unref ( file ) ; } break ; default : { } break ; } gtk_widget_destroy ( GTK_WIDGET ( dialog ) ) ; activate_parameters_desktop_free ( parameters ) ; }
","<S2SV_ModStart> ) { case GTK_RESPONSE_OK : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_set_metadata ( parameters -> file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL , ""yes"" ) ; nautilus_file_mark_desktop_file_executable ( file , parameters -> parent_window , TRUE , NULL , NULL ) ; nautilus_file_invalidate_all_attributes ( parameters -> file ) ; <S2SV_ModEnd> screen = gtk_widget_get_screen <S2SV_ModStart> uri ) ; <S2SV_ModEnd> g_object_unref ( file
"
328,"CWE-191 static void edge_bulk_in_callback ( struct urb * urb ) { struct edgeport_port * edge_port = urb -> context ; struct device * dev = & edge_port -> port -> dev ; unsigned char * data = urb -> transfer_buffer ; int retval = 0 ; int port_number ; int status = urb -> status ; switch ( status ) { case 0 : break ; case - ECONNRESET : case - ENOENT : case - ESHUTDOWN : dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>urb<S2SV_blank>shutting<S2SV_blank>down<S2SV_blank>with<S2SV_blank>status:<S2SV_blank>%d\\n"" , __func__ , status ) ; return ; default : dev_err ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>read<S2SV_blank>bulk<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>%d\\n"" , __func__ , status ) ; } if ( status == - EPIPE ) goto exit ; if ( status ) { dev_err ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>stopping<S2SV_blank>read!\\n"" , __func__ ) ; return ; } port_number = edge_port -> port -> port_number ; <S2SV_StartBug> if ( edge_port -> lsr_event ) { <S2SV_EndBug> edge_port -> lsr_event = 0 ; dev_dbg ( dev , ""%s<S2SV_blank>=====<S2SV_blank>Port<S2SV_blank>%u<S2SV_blank>LSR<S2SV_blank>Status<S2SV_blank>=<S2SV_blank>%02x,<S2SV_blank>Data<S2SV_blank>=<S2SV_blank>%02x<S2SV_blank>======\\n"" , __func__ , port_number , edge_port -> lsr_mask , * data ) ; handle_new_lsr ( edge_port , 1 , edge_port -> lsr_mask , * data ) ; -- urb -> actual_length ; ++ data ; } if ( urb -> actual_length ) { usb_serial_debug_data ( dev , __func__ , urb -> actual_length , data ) ; if ( edge_port -> close_pending ) dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>close<S2SV_blank>pending,<S2SV_blank>dropping<S2SV_blank>data<S2SV_blank>on<S2SV_blank>the<S2SV_blank>floor\\n"" , __func__ ) ; else edge_tty_recv ( edge_port -> port , data , urb -> actual_length ) ; edge_port -> port -> icount . rx += urb -> actual_length ; } exit : spin_lock ( & edge_port -> ep_lock ) ; if ( edge_port -> ep_read_urb_state == EDGE_READ_URB_RUNNING ) retval = usb_submit_urb ( urb , GFP_ATOMIC ) ; else if ( edge_port -> ep_read_urb_state == EDGE_READ_URB_STOPPING ) edge_port -> ep_read_urb_state = EDGE_READ_URB_STOPPED ; spin_unlock ( & edge_port -> ep_lock ) ; if ( retval ) dev_err ( dev , ""%s<S2SV_blank>-<S2SV_blank>usb_submit_urb<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>result<S2SV_blank>%d\\n"" , __func__ , retval ) ; }
","<S2SV_ModStart> ; if ( urb -> actual_length > 0 &&
"
329,"CWE-264 static struct cifsSesInfo * <S2SV_StartBug> cifs_find_smb_ses ( struct TCP_Server_Info * server , char * username ) <S2SV_EndBug> { struct list_head * tmp ; struct cifsSesInfo * ses ; write_lock ( & cifs_tcp_ses_lock ) ; <S2SV_StartBug> list_for_each ( tmp , & server -> smb_ses_list ) { <S2SV_EndBug> ses = list_entry ( tmp , struct cifsSesInfo , smb_ses_list ) ; <S2SV_StartBug> if ( strncmp ( ses -> userName , username , MAX_USERNAME_SIZE ) ) <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> ++ ses -> ses_count ; write_unlock ( & cifs_tcp_ses_lock ) ; return ses ; } write_unlock ( & cifs_tcp_ses_lock ) ; return NULL ; }
","<S2SV_ModStart> * server , struct smb_vol * vol ) { <S2SV_ModEnd> struct cifsSesInfo * <S2SV_ModStart> cifs_tcp_ses_lock ) ; list_for_each_entry ( ses <S2SV_ModEnd> , & server <S2SV_ModStart> server -> smb_ses_list , smb_ses_list ) { switch ( server -> secType ) { case Kerberos : if ( vol -> linux_uid != ses -> linux_uid ) continue ; break ; default : <S2SV_ModEnd> if ( strncmp <S2SV_ModStart> -> userName , vol -> <S2SV_ModStart> ) continue ; if ( strlen ( vol -> username ) != 0 && strncmp ( ses -> password , vol -> password , MAX_PASSWORD_SIZE ) ) continue ; }
"
330,"CWE-119 static vpx_codec_err_t vp8e_set_config ( vpx_codec_alg_priv_t * ctx , const vpx_codec_enc_cfg_t * cfg ) { vpx_codec_err_t res ; <S2SV_StartBug> if ( ( ( cfg -> g_w != ctx -> cfg . g_w ) || ( cfg -> g_h != ctx -> cfg . g_h ) ) <S2SV_EndBug> <S2SV_StartBug> && ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS ) ) <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ; <S2SV_EndBug> if ( ( cfg -> g_lag_in_frames > ctx -> cfg . g_lag_in_frames ) ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>lag_in_frames"" ) ; res = validate_config ( ctx , cfg , & ctx -> vp8_cfg , 0 ) ; if ( ! res ) { ctx -> cfg = * cfg ; set_vp8e_config ( & ctx -> oxcf , ctx -> cfg , ctx -> vp8_cfg , NULL ) ; vp8_change_config ( ctx -> cpi , & ctx -> oxcf ) ; } return res ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> cfg -> g_w <S2SV_ModStart> cfg . g_w || <S2SV_ModEnd> cfg -> g_h <S2SV_ModStart> . g_h ) { if <S2SV_ModEnd> ( cfg -> <S2SV_ModStart> != VPX_RC_ONE_PASS ) <S2SV_ModEnd> ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" <S2SV_ModStart> ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ; if ( ( ctx -> cpi -> initial_width && ( int ) cfg -> g_w > ctx -> cpi -> initial_width ) || ( ctx -> cpi -> initial_height && ( int ) cfg -> g_h > ctx -> cpi -> initial_height ) ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>their<S2SV_blank>initial<S2SV_blank>values"" ) ; }
"
331,"CWE-119 static int cmd_mount ( void * data , const char * _input ) { ut64 off = 0 ; char * input , * oinput , * ptr , * ptr2 ; RList * list ; RListIter * iter ; RFSFile * file ; RFSRoot * root ; RFSPlugin * plug ; RFSPartition * part ; RCore * core = ( RCore * ) data ; if ( ! strncmp ( ""kdir"" , _input , 4 ) ) { return cmd_mkdir ( data , _input ) ; } if ( ! strncmp ( ""v"" , _input , 1 ) ) { return cmd_mv ( data , _input ) ; } input = oinput = strdup ( _input ) ; switch ( * input ) { case '<S2SV_blank>' : input ++ ; if ( input [ 0 ] == '<S2SV_blank>' ) <S2SV_StartBug> input ++ ; <S2SV_EndBug> ptr = strchr ( input , '<S2SV_blank>' ) ; if ( ptr ) { * ptr = 0 ; ptr ++ ; ptr2 = strchr ( ptr , '<S2SV_blank>' ) ; if ( ptr2 ) { * ptr2 = 0 ; off = r_num_math ( core -> num , ptr2 + 1 ) ; } <S2SV_StartBug> if ( ! r_fs_mount ( core -> fs , ptr , input , off ) ) <S2SV_EndBug> eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\n"" , input ) ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = r_fs_name ( core -> fs , core -> offset ) ) ) <S2SV_EndBug> eprintf ( ""Unknown<S2SV_blank>filesystem<S2SV_blank>type\\n"" ) ; <S2SV_StartBug> else if ( ! r_fs_mount ( core -> fs , ptr , input , core -> offset ) ) <S2SV_EndBug> <S2SV_StartBug> eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\n"" , input ) ; <S2SV_EndBug> free ( ptr ) ; } break ; case '-' : r_fs_umount ( core -> fs , input + 1 ) ; break ; case '*' : eprintf ( ""List<S2SV_blank>commands<S2SV_blank>in<S2SV_blank>radare<S2SV_blank>format\\n"" ) ; r_list_foreach ( core -> fs -> roots , iter , root ) { r_cons_printf ( ""m<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>0x%"" PFMT64x ""\\n"" , root -> path , root -> p -> name , root -> delta ) ; } break ; case '\\0' : r_list_foreach ( core -> fs -> roots , iter , root ) { r_cons_printf ( ""%s\\t0x%"" PFMT64x ""\\t%s\\n"" , root -> p -> name , root -> delta , root -> path ) ; } break ; case 'l' : r_list_foreach ( core -> fs -> plugins , iter , plug ) { r_cons_printf ( ""%10s<S2SV_blank><S2SV_blank>%s\\n"" , plug -> name , plug -> desc ) ; } break ; case 'd' : input ++ ; if ( input [ 0 ] == '<S2SV_blank>' ) input ++ ; list = r_fs_dir ( core -> fs , input ) ; if ( list ) { r_list_foreach ( list , iter , file ) { r_cons_printf ( ""%c<S2SV_blank>%s\\n"" , file -> type , file -> name ) ; } r_list_free ( list ) ; } else eprintf ( ""Cannot<S2SV_blank>open<S2SV_blank>\'%s\'<S2SV_blank>directory\\n"" , input ) ; break ; case 'p' : input ++ ; if ( * input == '<S2SV_blank>' ) input ++ ; ptr = strchr ( input , '<S2SV_blank>' ) ; if ( ptr ) { * ptr = 0 ; off = r_num_math ( core -> num , ptr + 1 ) ; } list = r_fs_partitions ( core -> fs , input , off ) ; if ( list ) { r_list_foreach ( list , iter , part ) { r_cons_printf ( ""%d<S2SV_blank>%02x<S2SV_blank>0x%010"" PFMT64x ""<S2SV_blank>0x%010"" PFMT64x ""\\n"" , part -> number , part -> type , part -> start , part -> start + part -> length ) ; } r_list_free ( list ) ; } else eprintf ( ""Cannot<S2SV_blank>read<S2SV_blank>partition\\n"" ) ; break ; case 'o' : input ++ ; if ( input [ 0 ] == '<S2SV_blank>' ) input ++ ; file = r_fs_open ( core -> fs , input ) ; if ( file ) { r_fs_read ( core -> fs , file , 0 , file -> size ) ; r_cons_printf ( ""f<S2SV_blank>file<S2SV_blank>%d<S2SV_blank>0x%08"" PFMT64x ""\\n"" , file -> size , file -> off ) ; r_fs_close ( core -> fs , file ) ; } else eprintf ( ""Cannot<S2SV_blank>open<S2SV_blank>file\\n"" ) ; break ; case 'g' : input ++ ; if ( * input == '<S2SV_blank>' ) input ++ ; ptr = strchr ( input , '<S2SV_blank>' ) ; if ( ptr ) * ptr ++ = 0 ; else ptr = ""./"" ; file = r_fs_open ( core -> fs , input ) ; if ( file ) { r_fs_read ( core -> fs , file , 0 , file -> size ) ; write ( 1 , file -> data , file -> size ) ; r_fs_close ( core -> fs , file ) ; write ( 1 , ""\\n"" , 1 ) ; } else if ( ! r_fs_dir_dump ( core -> fs , input , ptr ) ) eprintf ( ""Cannot<S2SV_blank>open<S2SV_blank>file\\n"" ) ; break ; case 'f' : input ++ ; switch ( * input ) { case '?' : r_cons_printf ( ""Usage:<S2SV_blank>mf[no]<S2SV_blank>[...]\\n"" ""<S2SV_blank>mfn<S2SV_blank>/foo<S2SV_blank>*.c<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>;<S2SV_blank>search<S2SV_blank>files<S2SV_blank>by<S2SV_blank>name<S2SV_blank>in<S2SV_blank>/foo<S2SV_blank>path\\n"" ""<S2SV_blank>mfo<S2SV_blank>/foo<S2SV_blank>0x5e91<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>;<S2SV_blank>search<S2SV_blank>files<S2SV_blank>by<S2SV_blank>offset<S2SV_blank>in<S2SV_blank>/foo<S2SV_blank>path\\n"" ) ; break ; case 'n' : input ++ ; if ( * input == '<S2SV_blank>' ) input ++ ; ptr = strchr ( input , '<S2SV_blank>' ) ; if ( ptr ) { * ptr ++ = 0 ; list = r_fs_find_name ( core -> fs , input , ptr ) ; r_list_foreach ( list , iter , ptr ) { r_str_chop_path ( ptr ) ; printf ( ""%s\\n"" , ptr ) ; } } else eprintf ( ""Unknown<S2SV_blank>store<S2SV_blank>path\\n"" ) ; break ; case 'o' : input ++ ; if ( * input == '<S2SV_blank>' ) input ++ ; ptr = strchr ( input , '<S2SV_blank>' ) ; if ( ptr ) { * ptr ++ = 0 ; ut64 off = r_num_math ( core -> num , ptr ) ; list = r_fs_find_off ( core -> fs , input , off ) ; r_list_foreach ( list , iter , ptr ) { r_str_chop_path ( ptr ) ; printf ( ""%s\\n"" , ptr ) ; } } else eprintf ( ""Unknown<S2SV_blank>store<S2SV_blank>path\\n"" ) ; break ; } break ; case 's' : if ( core -> http_up ) { free ( oinput ) ; return false ; } input ++ ; if ( input [ 0 ] == '<S2SV_blank>' ) input ++ ; r_fs_prompt ( core -> fs , input ) ; break ; case 'y' : eprintf ( ""TODO\\n"" ) ; break ; case '?' : { const char * help_msg [ ] = { ""Usage:"" , ""m[-?*dgy]<S2SV_blank>[...]<S2SV_blank>"" , ""Mountpoints<S2SV_blank>management"" , ""m"" , """" , ""List<S2SV_blank>all<S2SV_blank>mountpoints<S2SV_blank>in<S2SV_blank>human<S2SV_blank>readable<S2SV_blank>format"" , ""m*"" , """" , ""Same<S2SV_blank>as<S2SV_blank>above,<S2SV_blank>but<S2SV_blank>in<S2SV_blank>r2<S2SV_blank>commands"" , ""ml"" , """" , ""List<S2SV_blank>filesystem<S2SV_blank>plugins"" , ""m"" , ""<S2SV_blank>/mnt"" , ""Mount<S2SV_blank>fs<S2SV_blank>at<S2SV_blank>/mnt<S2SV_blank>with<S2SV_blank>autodetect<S2SV_blank>fs<S2SV_blank>and<S2SV_blank>current<S2SV_blank>offset"" , ""m"" , ""<S2SV_blank>/mnt<S2SV_blank>ext2<S2SV_blank>0"" , ""Mount<S2SV_blank>ext2<S2SV_blank>fs<S2SV_blank>at<S2SV_blank>/mnt<S2SV_blank>with<S2SV_blank>delta<S2SV_blank>0<S2SV_blank>on<S2SV_blank>IO"" , ""m-/"" , """" , ""Umount<S2SV_blank>given<S2SV_blank>path<S2SV_blank>(/)"" , ""my"" , """" , ""Yank<S2SV_blank>contents<S2SV_blank>of<S2SV_blank>file<S2SV_blank>into<S2SV_blank>clipboard"" , ""mo"" , ""<S2SV_blank>/foo"" , ""Get<S2SV_blank>offset<S2SV_blank>and<S2SV_blank>size<S2SV_blank>of<S2SV_blank>given<S2SV_blank>file"" , ""mg"" , ""<S2SV_blank>/foo"" , ""Get<S2SV_blank>contents<S2SV_blank>of<S2SV_blank>file/dir<S2SV_blank>dumped<S2SV_blank>to<S2SV_blank>disk<S2SV_blank>(XXX?)"" , ""mf"" , ""[?]<S2SV_blank>[o|n]"" , ""Search<S2SV_blank>files<S2SV_blank>for<S2SV_blank>given<S2SV_blank>filename<S2SV_blank>or<S2SV_blank>for<S2SV_blank>offset"" , ""md"" , ""<S2SV_blank>/"" , ""List<S2SV_blank>directory<S2SV_blank>contents<S2SV_blank>for<S2SV_blank>path"" , ""mp"" , """" , ""List<S2SV_blank>all<S2SV_blank>supported<S2SV_blank>partition<S2SV_blank>types"" , ""mp"" , ""<S2SV_blank>msdos<S2SV_blank>0"" , ""Show<S2SV_blank>partitions<S2SV_blank>in<S2SV_blank>msdos<S2SV_blank>format<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>0"" , ""ms"" , ""<S2SV_blank>/mnt"" , ""Open<S2SV_blank>filesystem<S2SV_blank>prompt<S2SV_blank>at<S2SV_blank>/mnt"" , NULL } ; r_core_cmd_help ( core , help_msg ) ; } break ; } free ( oinput ) ; return 0 ; }
","<S2SV_ModStart> == '<S2SV_blank>' ) { input ++ ; } <S2SV_ModEnd> ptr = strchr <S2SV_ModStart> off ) ) { <S2SV_ModStart> ) ; } } <S2SV_ModStart> ) ) ) { <S2SV_ModStart> ""Unknown<S2SV_blank>filesystem<S2SV_blank>type\\n"" ) ; } <S2SV_ModStart> offset ) ) { <S2SV_ModStart> input ) ; }
"
332,"CWE-399 int hugetlb_reserve_pages ( struct inode * inode , long from , long to , struct vm_area_struct * vma , vm_flags_t vm_flags ) { long ret , chg ; struct hstate * h = hstate_inode ( inode ) ; <S2SV_StartBug> if ( vm_flags & VM_NORESERVE ) <S2SV_EndBug> return 0 ; if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) chg = region_chg ( & inode -> i_mapping -> private_list , from , to ) ; else { struct resv_map * resv_map = resv_map_alloc ( ) ; if ( ! resv_map ) return - ENOMEM ; chg = to - from ; set_vma_resv_map ( vma , resv_map ) ; set_vma_resv_flags ( vma , HPAGE_RESV_OWNER ) ; } if ( chg < 0 ) return chg ; <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> return - ENOSPC ; ret = hugetlb_acct_memory ( h , chg ) ; if ( ret < 0 ) { <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug> return ret ; } if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) region_add ( & inode -> i_mapping -> private_list , from , to ) ; return 0 ; }
","<S2SV_ModStart> inode ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> ; if ( hugepage_subpool_get_pages ( spool <S2SV_ModEnd> , chg ) <S2SV_ModStart> 0 ) { hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , chg )
"
333,"CWE-404 int install_thread_keyring_to_cred ( struct cred * new ) { <S2SV_StartBug> struct key * keyring ; <S2SV_EndBug> keyring = keyring_alloc ( ""_tid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ; if ( IS_ERR ( keyring ) ) return PTR_ERR ( keyring ) ; new -> thread_keyring = keyring ; return 0 ; }
","<S2SV_ModStart> key * keyring ; if ( new -> thread_keyring ) return 0
"
334,"CWE-399 int sfgets ( void ) { struct pollfd pfd ; int pollret ; ssize_t readnb ; signed char seen_r = 0 ; <S2SV_StartBug> static size_t scanned ; <S2SV_EndBug> static size_t readnbd ; if ( scanned > ( size_t ) 0U ) { readnbd -= scanned ; memmove ( cmd , cmd + scanned , readnbd ) ; scanned = ( size_t ) 0U ; } pfd . fd = clientfd ; # ifdef __APPLE_CC__ pfd . events = POLLIN | POLLERR | POLLHUP ; # else pfd . events = POLLIN | POLLPRI | POLLERR | POLLHUP ; # endif while ( scanned < cmdsize ) { if ( scanned >= readnbd ) { pfd . revents = 0 ; while ( ( pollret = poll ( & pfd , 1U , idletime * 1000UL ) ) < 0 && errno == EINTR ) ; if ( pollret == 0 ) { return - 1 ; } if ( pollret <= 0 || ( pfd . revents & ( POLLERR | POLLHUP | POLLNVAL ) ) != 0 ) { return - 2 ; } if ( ( pfd . revents & ( POLLIN | POLLPRI ) ) == 0 ) { continue ; } if ( readnbd >= cmdsize ) { break ; } # ifdef WITH_TLS if ( tls_cnx != NULL ) { while ( ( readnb = SSL_read ( tls_cnx , cmd + readnbd , cmdsize - readnbd ) ) < ( ssize_t ) 0 && errno == EINTR ) ; } else # endif { while ( ( readnb = read ( clientfd , cmd + readnbd , cmdsize - readnbd ) ) < ( ssize_t ) 0 && errno == EINTR ) ; } if ( readnb <= ( ssize_t ) 0 ) { return - 2 ; } readnbd += readnb ; if ( readnbd > cmdsize ) { return - 2 ; } } # ifdef RFC_CONFORMANT_LINES if ( seen_r != 0 ) { # endif if ( cmd [ scanned ] == '\\n' ) { # ifndef RFC_CONFORMANT_LINES if ( seen_r != 0 ) { # endif cmd [ scanned - 1U ] = 0 ; # ifndef RFC_CONFORMANT_LINES } else { cmd [ scanned ] = 0 ; } # endif if ( ++ scanned >= readnbd ) { scanned = readnbd = ( size_t ) 0U ; } return 0 ; } seen_r = 0 ; # ifdef RFC_CONFORMANT_LINES } # endif if ( ISCTRLCODE ( cmd [ scanned ] ) ) { if ( cmd [ scanned ] == '\\r' ) { seen_r = 1 ; } # ifdef RFC_CONFORMANT_PARSER else if ( cmd [ scanned ] == 0 ) { cmd [ scanned ] = '\\n' ; } # else cmd [ scanned ] = '_' ; # endif } scanned ++ ; } die ( 421 , LOG_WARNING , MSG_LINE_TOO_LONG ) ; return 0 ; }
","<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( scanned
"
335,"CWE-416 mrb_value mrb_io_initialize_copy ( mrb_state * mrb , mrb_value copy ) { mrb_value orig ; mrb_value buf ; struct mrb_io * fptr_copy ; struct mrb_io * fptr_orig ; mrb_bool failed = TRUE ; mrb_get_args ( mrb , ""o"" , & orig ) ; <S2SV_StartBug> fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ; <S2SV_EndBug> if ( fptr_copy != NULL ) { fptr_finalize ( mrb , fptr_copy , FALSE ) ; mrb_free ( mrb , fptr_copy ) ; } <S2SV_StartBug> fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ; <S2SV_EndBug> fptr_orig = io_get_open_fptr ( mrb , orig ) ; DATA_TYPE ( copy ) = & mrb_io_type ; DATA_PTR ( copy ) = fptr_copy ; buf = mrb_iv_get ( mrb , orig , mrb_intern_cstr ( mrb , ""@buf"" ) ) ; mrb_iv_set ( mrb , copy , mrb_intern_cstr ( mrb , ""@buf"" ) , buf ) ; fptr_copy -> fd = mrb_dup ( mrb , fptr_orig -> fd , & failed ) ; if ( failed ) { mrb_sys_fail ( mrb , 0 ) ; } mrb_fd_cloexec ( mrb , fptr_copy -> fd ) ; if ( fptr_orig -> fd2 != - 1 ) { fptr_copy -> fd2 = mrb_dup ( mrb , fptr_orig -> fd2 , & failed ) ; if ( failed ) { close ( fptr_copy -> fd ) ; mrb_sys_fail ( mrb , 0 ) ; } mrb_fd_cloexec ( mrb , fptr_copy -> fd2 ) ; } fptr_copy -> pid = fptr_orig -> pid ; fptr_copy -> readable = fptr_orig -> readable ; fptr_copy -> writable = fptr_orig -> writable ; fptr_copy -> sync = fptr_orig -> sync ; fptr_copy -> is_socket = fptr_orig -> is_socket ; return copy ; }
","<S2SV_ModStart> orig ) ; fptr_orig = io_get_open_fptr ( mrb , orig ) ; <S2SV_ModStart> mrb_io_alloc ( mrb <S2SV_ModEnd> ) ; DATA_TYPE
"
336,"CWE-476 struct key * key_get_instantiation_authkey ( key_serial_t target_id ) { char description [ 16 ] ; struct keyring_search_context ctx = { . index_key . type = & key_type_request_key_auth , . index_key . description = description , . cred = current_cred ( ) , <S2SV_StartBug> . match_data . cmp = user_match , <S2SV_EndBug> . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , } ; struct key * authkey ; key_ref_t authkey_ref ; sprintf ( description , ""%x"" , target_id ) ; authkey_ref = search_process_keyrings ( & ctx ) ; if ( IS_ERR ( authkey_ref ) ) { authkey = ERR_CAST ( authkey_ref ) ; if ( authkey == ERR_PTR ( - EAGAIN ) ) authkey = ERR_PTR ( - ENOKEY ) ; goto error ; } authkey = key_ref_to_ptr ( authkey_ref ) ; if ( test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) { key_put ( authkey ) ; authkey = ERR_PTR ( - EKEYREVOKED ) ; } error : return authkey ; }
","<S2SV_ModStart> . cmp = key_default_cmp <S2SV_ModEnd> , . match_data
"
337,"CWE-119 void vp9_frame_init_quantizer ( VP9_COMP * cpi ) { <S2SV_StartBug> cpi -> zbin_mode_boost = 0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ; <S2SV_EndBug> }
","<S2SV_ModStart> cpi ) { <S2SV_ModEnd> vp9_init_plane_quantizers ( cpi <S2SV_ModStart> & cpi -> td .
"
338,"CWE-119 static TEE_Result tee_svc_copy_param ( struct tee_ta_session * sess , struct tee_ta_session * called_sess , struct utee_params * callee_params , struct tee_ta_param * param , void * tmp_buf_va [ TEE_NUM_PARAMS ] , struct mobj * * mobj_tmp ) { size_t n ; TEE_Result res ; size_t req_mem = 0 ; size_t s ; uint8_t * dst = 0 ; bool ta_private_memref [ TEE_NUM_PARAMS ] ; struct user_ta_ctx * utc = to_user_ta_ctx ( sess -> ctx ) ; void * va ; size_t dst_offs ; if ( ! callee_params ) { memset ( param , 0 , sizeof ( * param ) ) ; } else { res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) callee_params , sizeof ( struct utee_params ) ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> utee_param_to_param ( param , callee_params ) ; <S2SV_EndBug> } if ( called_sess && is_pseudo_ta_ctx ( called_sess -> ctx ) ) { return TEE_SUCCESS ; } for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { ta_private_memref [ n ] = false ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; s = param -> u [ n ] . mem . size ; if ( ! va ) { if ( s ) return TEE_ERROR_BAD_PARAMETERS ; break ; } if ( tee_mmu_is_vbuf_inside_ta_private ( utc , va , s ) ) { s = ROUNDUP ( s , sizeof ( uint32_t ) ) ; if ( ADD_OVERFLOW ( req_mem , s , & req_mem ) ) return TEE_ERROR_BAD_PARAMETERS ; ta_private_memref [ n ] = true ; break ; } res = tee_mmu_vbuf_to_mobj_offs ( utc , va , s , & param -> u [ n ] . mem . mobj , & param -> u [ n ] . mem . offs ) ; if ( res != TEE_SUCCESS ) return res ; break ; default : break ; } } if ( req_mem == 0 ) return TEE_SUCCESS ; res = alloc_temp_sec_mem ( req_mem , mobj_tmp , & dst ) ; if ( res != TEE_SUCCESS ) return res ; dst_offs = 0 ; for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { if ( ! ta_private_memref [ n ] ) continue ; s = ROUNDUP ( param -> u [ n ] . mem . size , sizeof ( uint32_t ) ) ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; if ( va ) { res = tee_svc_copy_from_user ( dst , va , param -> u [ n ] . mem . size ) ; if ( res != TEE_SUCCESS ) return res ; param -> u [ n ] . mem . offs = dst_offs ; param -> u [ n ] . mem . mobj = * mobj_tmp ; tmp_buf_va [ n ] = dst ; dst += s ; dst_offs += s ; } break ; case TEE_PARAM_TYPE_MEMREF_OUTPUT : va = ( void * ) param -> u [ n ] . mem . offs ; if ( va ) { param -> u [ n ] . mem . offs = dst_offs ; param -> u [ n ] . mem . mobj = * mobj_tmp ; tmp_buf_va [ n ] = dst ; dst += s ; dst_offs += s ; } break ; default : continue ; } } return TEE_SUCCESS ; }
","<S2SV_ModStart> return res ; res = utee_param_to_param ( utc , <S2SV_ModEnd> param , callee_params <S2SV_ModStart> , callee_params ) ; if ( res != TEE_SUCCESS ) return res
"
339,"CWE-000 static int em_call_far ( struct x86_emulate_ctxt * ctxt ) { u16 sel , old_cs ; ulong old_eip ; int rc ; <S2SV_StartBug> old_cs = get_segment_selector ( ctxt , VCPU_SREG_CS ) ; <S2SV_EndBug> old_eip = ctxt -> _eip ; memcpy ( & sel , ctxt -> src . valptr + ctxt -> op_bytes , 2 ) ; <S2SV_StartBug> if ( load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) ) <S2SV_EndBug> return X86EMUL_CONTINUE ; <S2SV_StartBug> ctxt -> _eip = 0 ; <S2SV_EndBug> memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ; ctxt -> src . val = old_cs ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; ctxt -> src . val = old_eip ; return em_push ( ctxt ) ; }
","<S2SV_ModStart> int rc ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; int cpl = ctxt -> ops -> cpl ( ctxt ) ; old_eip = ctxt -> _eip ; ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL <S2SV_ModEnd> , VCPU_SREG_CS ) <S2SV_ModStart> , VCPU_SREG_CS ) <S2SV_ModEnd> ; memcpy ( <S2SV_ModStart> 2 ) ; rc = __load_segment_descriptor <S2SV_ModEnd> ( ctxt , <S2SV_ModStart> sel , VCPU_SREG_CS , cpl , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE <S2SV_ModEnd> ) return X86EMUL_CONTINUE <S2SV_ModStart> return X86EMUL_CONTINUE ; rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_cs ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_eip ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; return rc ; fail : ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; return rc <S2SV_ModEnd> ; } <S2SV_null>
"
340,"CWE-000 int ff_jpeg2000_init_component ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty , Jpeg2000QuantStyle * qntsty , int cbps , int dx , int dy , AVCodecContext * avctx ) { uint8_t log2_band_prec_width , log2_band_prec_height ; int reslevelno , bandno , gbandno = 0 , ret , i , j ; uint32_t csize ; if ( codsty -> nreslevels2decode <= 0 ) { av_log ( avctx , AV_LOG_ERROR , ""nreslevels2decode<S2SV_blank>%d<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>uninitialized\\n"" , codsty -> nreslevels2decode ) ; return AVERROR_INVALIDDATA ; } if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) ) return ret ; csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ) ; if ( codsty -> transform == FF_DWT97 ) { comp -> i_data = NULL ; comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ) ; if ( ! comp -> f_data ) return AVERROR ( ENOMEM ) ; } else { comp -> f_data = NULL ; comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ) ; if ( ! comp -> i_data ) return AVERROR ( ENOMEM ) ; } comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ) ; if ( ! comp -> reslevel ) return AVERROR ( ENOMEM ) ; for ( reslevelno = 0 ; reslevelno < codsty -> nreslevels ; reslevelno ++ ) { int declvl = codsty -> nreslevels - reslevelno ; Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ) ; reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ] ; reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ] ; if ( reslevelno == 0 ) reslevel -> nbands = 1 ; else reslevel -> nbands = 3 ; if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] ) reslevel -> num_precincts_x = 0 ; else reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ) ; if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] ) reslevel -> num_precincts_y = 0 ; else reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ) ; <S2SV_StartBug> reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ; <S2SV_EndBug> if ( ! reslevel -> band ) return AVERROR ( ENOMEM ) ; for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ , gbandno ++ ) { Jpeg2000Band * band = reslevel -> band + bandno ; int cblkno , precno ; int nb_precincts ; switch ( qntsty -> quantsty ) { uint8_t gain ; int numbps ; case JPEG2000_QSTY_NONE : band -> f_stepsize = 1 ; break ; case JPEG2000_QSTY_SI : numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ] ; band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ) ; break ; case JPEG2000_QSTY_SE : gain = cbps ; band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ) ; band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0 ; break ; default : band -> f_stepsize = 0 ; av_log ( avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>quantization<S2SV_blank>format\\n"" ) ; break ; } if ( ! av_codec_is_encoder ( avctx -> codec ) ) band -> f_stepsize *= 0.5 ; band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ) ; if ( reslevelno == 0 ) { for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ) ; log2_band_prec_width = reslevel -> log2_prec_width ; log2_band_prec_height = reslevel -> log2_prec_height ; band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ) ; band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ) ; } else { for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ) ; band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ) ; band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ) ; log2_band_prec_width = reslevel -> log2_prec_width - 1 ; log2_band_prec_height = reslevel -> log2_prec_height - 1 ; } for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ) ; for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ) ; <S2SV_StartBug> band -> prec = av_malloc_array ( reslevel -> num_precincts_x * <S2SV_EndBug> ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ) ; if ( ! band -> prec ) return AVERROR ( ENOMEM ) ; nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y ; for ( precno = 0 ; precno < nb_precincts ; precno ++ ) { Jpeg2000Prec * prec = band -> prec + precno ; prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ) ; prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ) ; prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ) ; prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ) ; prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ) ; prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ) ; prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ) ; prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ) ; prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ) ; prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ) ; prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ) ; if ( ! prec -> cblkincl ) return AVERROR ( ENOMEM ) ; prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ) ; if ( ! prec -> zerobits ) return AVERROR ( ENOMEM ) ; prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ) ; if ( ! prec -> cblk ) return AVERROR ( ENOMEM ) ; for ( cblkno = 0 ; cblkno < prec -> nb_codeblocks_width * prec -> nb_codeblocks_height ; cblkno ++ ) { Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; uint16_t Cx0 , Cy0 ; Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width ; Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ) ; cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ) ; Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height ; Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ) ; cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ) ; cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ) ; cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ) ; if ( ( bandno + ! ! reslevelno ) & 1 ) { cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ] ; cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ] ; } if ( ( bandno + ! ! reslevelno ) & 2 ) { cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ] ; cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ] ; } cblk -> zero = 0 ; cblk -> lblock = 3 ; cblk -> length = 0 ; cblk -> lengthinc = 0 ; cblk -> npasses = 0 ; } } } } return 0 ; }
","<S2SV_ModStart> -> band = av_calloc <S2SV_ModEnd> ( reslevel -> <S2SV_ModStart> -> prec = av_calloc <S2SV_ModEnd> ( reslevel ->
"
341,"CWE-269 void Con_Dump_f ( void ) { int l , x , i ; short * line ; fileHandle_t f ; int bufferlen ; char * buffer ; char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { Com_Printf ( ""usage:<S2SV_blank>condump<S2SV_blank><filename>\\n"" ) ; return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; <S2SV_StartBug> COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ; <S2SV_EndBug> f = FS_FOpenFileWrite ( filename ) ; if ( ! f ) { Com_Printf ( ""ERROR:<S2SV_blank>couldn\'t<S2SV_blank>open<S2SV_blank>%s.\\n"" , filename ) ; return ; } Com_Printf ( ""Dumped<S2SV_blank>console<S2SV_blank>text<S2SV_blank>to<S2SV_blank>%s.\\n"" , filename ) ; for ( l = con . current - con . totallines + 1 ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( x = 0 ; x < con . linewidth ; x ++ ) if ( ( line [ x ] & 0xff ) != '<S2SV_blank>' ) { break ; } if ( x != con . linewidth ) { break ; } } # ifdef _WIN32 bufferlen = con . linewidth + 3 * sizeof ( char ) ; # else bufferlen = con . linewidth + 2 * sizeof ( char ) ; # endif buffer = Hunk_AllocateTempMemory ( bufferlen ) ; buffer [ bufferlen - 1 ] = 0 ; for ( ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( i = 0 ; i < con . linewidth ; i ++ ) buffer [ i ] = line [ i ] & 0xff ; for ( x = con . linewidth - 1 ; x >= 0 ; x -- ) { if ( buffer [ x ] == '<S2SV_blank>' ) { buffer [ x ] = 0 ; } else { break ; } } # ifdef _WIN32 Q_strcat ( buffer , bufferlen , ""\\r\\n"" ) ; # else Q_strcat ( buffer , bufferlen , ""\\n"" ) ; # endif FS_Write ( buffer , strlen ( buffer ) , f ) ; } Hunk_FreeTempMemory ( buffer ) ; FS_FCloseFile ( f ) ; }
","<S2SV_ModStart> "".txt"" ) ; if ( ! COM_CompareExtension ( filename , "".txt"" ) ) { Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".txt\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" ) ; return ; }
"
342,"CWE-119 static RList * relocs ( RBinFile * arch ) { struct r_bin_bflt_obj * obj = ( struct r_bin_bflt_obj * ) arch -> o -> bin_obj ; RList * list = r_list_newf ( ( RListFree ) free ) ; int i , len , n_got , amount ; if ( ! list || ! obj ) { r_list_free ( list ) ; return NULL ; } if ( obj -> hdr -> flags & FLAT_FLAG_GOTPIC ) { n_got = get_ngot_entries ( obj ) ; if ( n_got ) { amount = n_got * sizeof ( ut32 ) ; if ( amount < n_got || amount > UT32_MAX ) { goto out_error ; } <S2SV_StartBug> struct reloc_struct_t * got_table = calloc ( 1 , n_got * sizeof ( ut32 ) ) ; <S2SV_EndBug> if ( got_table ) { ut32 offset = 0 ; for ( i = 0 ; i < n_got ; offset += 4 , i ++ ) { ut32 got_entry ; if ( obj -> hdr -> data_start + offset + 4 > obj -> size || obj -> hdr -> data_start + offset + 4 < offset ) { break ; } len = r_buf_read_at ( obj -> b , obj -> hdr -> data_start + offset , ( ut8 * ) & got_entry , sizeof ( ut32 ) ) ; if ( ! VALID_GOT_ENTRY ( got_entry ) || len != sizeof ( ut32 ) ) { break ; } got_table [ i ] . addr_to_patch = got_entry ; got_table [ i ] . data_offset = got_entry + BFLT_HDR_SIZE ; } obj -> n_got = n_got ; obj -> got_table = got_table ; } } } if ( obj -> hdr -> reloc_count > 0 ) { int n_reloc = obj -> hdr -> reloc_count ; amount = n_reloc * sizeof ( struct reloc_struct_t ) ; if ( amount < n_reloc || amount > UT32_MAX ) { goto out_error ; } struct reloc_struct_t * reloc_table = calloc ( 1 , amount + 1 ) ; if ( ! reloc_table ) { goto out_error ; } amount = n_reloc * sizeof ( ut32 ) ; if ( amount < n_reloc || amount > UT32_MAX ) { free ( reloc_table ) ; goto out_error ; } ut32 * reloc_pointer_table = calloc ( 1 , amount + 1 ) ; if ( ! reloc_pointer_table ) { free ( reloc_table ) ; goto out_error ; } if ( obj -> hdr -> reloc_start + amount > obj -> size || obj -> hdr -> reloc_start + amount < amount ) { free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } len = r_buf_read_at ( obj -> b , obj -> hdr -> reloc_start , ( ut8 * ) reloc_pointer_table , amount ) ; if ( len != amount ) { free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } for ( i = 0 ; i < obj -> hdr -> reloc_count ; i ++ ) { ut32 reloc_offset = r_swap_ut32 ( reloc_pointer_table [ i ] ) + BFLT_HDR_SIZE ; if ( reloc_offset < obj -> hdr -> bss_end && reloc_offset < obj -> size ) { ut32 reloc_fixed , reloc_data_offset ; if ( reloc_offset + sizeof ( ut32 ) > obj -> size || reloc_offset + sizeof ( ut32 ) < reloc_offset ) { free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } len = r_buf_read_at ( obj -> b , reloc_offset , ( ut8 * ) & reloc_fixed , sizeof ( ut32 ) ) ; if ( len != sizeof ( ut32 ) ) { eprintf ( ""problem<S2SV_blank>while<S2SV_blank>reading<S2SV_blank>relocation<S2SV_blank>entries\\n"" ) ; free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } reloc_data_offset = r_swap_ut32 ( reloc_fixed ) + BFLT_HDR_SIZE ; reloc_table [ i ] . addr_to_patch = reloc_offset ; reloc_table [ i ] . data_offset = reloc_data_offset ; RBinReloc * reloc = R_NEW0 ( RBinReloc ) ; if ( reloc ) { reloc -> type = R_BIN_RELOC_32 ; reloc -> paddr = reloc_table [ i ] . addr_to_patch ; reloc -> vaddr = reloc -> paddr ; r_list_append ( list , reloc ) ; } } } free ( reloc_pointer_table ) ; obj -> reloc_table = reloc_table ; } return list ; out_error : r_list_free ( list ) ; return NULL ; }
","<S2SV_ModStart> * sizeof ( struct reloc_struct_t <S2SV_ModEnd> ) ) ;
"
343,"CWE-000 long do_rt_tgsigqueueinfo ( pid_t tgid , pid_t pid , int sig , siginfo_t * info ) { if ( pid <= 0 || tgid <= 0 ) return - EINVAL ; <S2SV_StartBug> if ( info -> si_code >= 0 ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug> info -> si_signo = sig ; return do_send_specific ( tgid , pid , sig , info ) ; }
","<S2SV_ModStart> info -> si_code != SI_QUEUE ) { WARN_ON_ONCE ( info -> si_code < 0 ) ; <S2SV_ModEnd> return - EPERM <S2SV_ModStart> - EPERM ; }
"
344,"CWE-190 void opj_get_all_encoding_parameters ( const opj_image_t * p_image , const opj_cp_t * p_cp , OPJ_UINT32 tileno , OPJ_INT32 * p_tx0 , OPJ_INT32 * p_tx1 , OPJ_INT32 * p_ty0 , OPJ_INT32 * p_ty1 , OPJ_UINT32 * p_dx_min , OPJ_UINT32 * p_dy_min , OPJ_UINT32 * p_max_prec , OPJ_UINT32 * p_max_res , OPJ_UINT32 * * p_resolutions ) { OPJ_UINT32 compno , resno ; const opj_tcp_t * tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; const opj_image_comp_t * l_img_comp = 00 ; OPJ_UINT32 * lResolutionPtr ; OPJ_UINT32 p , q ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( tileno < p_cp -> tw * p_cp -> th ) ; tcp = & p_cp -> tcps [ tileno ] ; l_tccp = tcp -> tccps ; l_img_comp = p_image -> comps ; p = tileno % p_cp -> tw ; q = tileno / p_cp -> tw ; <S2SV_StartBug> * p_tx0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> tx0 + p * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x0 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x1 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y0 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y1 ) ; <S2SV_EndBug> * p_max_prec = 0 ; * p_max_res = 0 ; * p_dx_min = 0x7fffffff ; * p_dy_min = 0x7fffffff ; for ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) { OPJ_UINT32 l_level_no ; OPJ_INT32 l_rx0 , l_ry0 , l_rx1 , l_ry1 ; OPJ_INT32 l_px0 , l_py0 , l_px1 , py1 ; OPJ_UINT32 l_product ; OPJ_INT32 l_tcx0 , l_tcy0 , l_tcx1 , l_tcy1 ; OPJ_UINT32 l_pdx , l_pdy , l_pw , l_ph ; lResolutionPtr = p_resolutions [ compno ] ; l_tcx0 = opj_int_ceildiv ( * p_tx0 , ( OPJ_INT32 ) l_img_comp -> dx ) ; l_tcy0 = opj_int_ceildiv ( * p_ty0 , ( OPJ_INT32 ) l_img_comp -> dy ) ; l_tcx1 = opj_int_ceildiv ( * p_tx1 , ( OPJ_INT32 ) l_img_comp -> dx ) ; l_tcy1 = opj_int_ceildiv ( * p_ty1 , ( OPJ_INT32 ) l_img_comp -> dy ) ; if ( l_tccp -> numresolutions > * p_max_res ) { * p_max_res = l_tccp -> numresolutions ; } l_level_no = l_tccp -> numresolutions - 1 ; for ( resno = 0 ; resno < l_tccp -> numresolutions ; ++ resno ) { OPJ_UINT32 l_dx , l_dy ; l_pdx = l_tccp -> prcw [ resno ] ; l_pdy = l_tccp -> prch [ resno ] ; * lResolutionPtr ++ = l_pdx ; * lResolutionPtr ++ = l_pdy ; l_dx = l_img_comp -> dx * ( 1u << ( l_pdx + l_level_no ) ) ; l_dy = l_img_comp -> dy * ( 1u << ( l_pdy + l_level_no ) ) ; * p_dx_min = ( OPJ_UINT32 ) opj_int_min ( ( OPJ_INT32 ) * p_dx_min , ( OPJ_INT32 ) l_dx ) ; * p_dy_min = ( OPJ_UINT32 ) opj_int_min ( ( OPJ_INT32 ) * p_dy_min , ( OPJ_INT32 ) l_dy ) ; l_rx0 = opj_int_ceildivpow2 ( l_tcx0 , ( OPJ_INT32 ) l_level_no ) ; l_ry0 = opj_int_ceildivpow2 ( l_tcy0 , ( OPJ_INT32 ) l_level_no ) ; l_rx1 = opj_int_ceildivpow2 ( l_tcx1 , ( OPJ_INT32 ) l_level_no ) ; l_ry1 = opj_int_ceildivpow2 ( l_tcy1 , ( OPJ_INT32 ) l_level_no ) ; l_px0 = opj_int_floordivpow2 ( l_rx0 , ( OPJ_INT32 ) l_pdx ) << l_pdx ; l_py0 = opj_int_floordivpow2 ( l_ry0 , ( OPJ_INT32 ) l_pdy ) << l_pdy ; l_px1 = opj_int_ceildivpow2 ( l_rx1 , ( OPJ_INT32 ) l_pdx ) << l_pdx ; py1 = opj_int_ceildivpow2 ( l_ry1 , ( OPJ_INT32 ) l_pdy ) << l_pdy ; l_pw = ( l_rx0 == l_rx1 ) ? 0 : ( OPJ_UINT32 ) ( ( l_px1 - l_px0 ) >> l_pdx ) ; l_ph = ( l_ry0 == l_ry1 ) ? 0 : ( OPJ_UINT32 ) ( ( py1 - l_py0 ) >> l_pdy ) ; * lResolutionPtr ++ = l_pw ; * lResolutionPtr ++ = l_ph ; l_product = l_pw * l_ph ; if ( l_product > * p_max_prec ) { * p_max_prec = l_product ; } -- l_level_no ; } ++ l_tccp ; ++ l_img_comp ; } }
","<S2SV_ModStart> * p_tx0 = ( OPJ_INT32 ) opj_uint_max <S2SV_ModEnd> ( p_cp -> <S2SV_ModStart> p_cp -> tdx , <S2SV_ModEnd> p_image -> x0 <S2SV_ModStart> * p_tx1 = ( OPJ_INT32 ) opj_uint_min <S2SV_ModEnd> ( p_cp -> <S2SV_ModStart> p_cp -> tdx , <S2SV_ModEnd> p_image -> x1 <S2SV_ModStart> * p_ty0 = ( OPJ_INT32 ) opj_uint_max <S2SV_ModEnd> ( p_cp -> <S2SV_ModStart> p_cp -> tdy , <S2SV_ModEnd> p_image -> y0 <S2SV_ModStart> * p_ty1 = ( OPJ_INT32 ) opj_uint_min <S2SV_ModEnd> ( p_cp -> <S2SV_ModStart> p_cp -> tdy , <S2SV_ModEnd> p_image -> y1
"
345,"CWE-22 <S2SV_StartBug> static char * create_output_name ( unsigned char * fname , unsigned char * dir , <S2SV_EndBug> int lower , int isunix , int utf8 ) { unsigned char * p , * name , c , * fe , sep , slash ; unsigned int x ; sep = ( isunix ) ? '/' : '\\\\' ; slash = ( isunix ) ? '\\\\' : '/' ; x = strlen ( ( char * ) fname ) ; <S2SV_StartBug> if ( utf8 ) x *= 3 ; <S2SV_EndBug> if ( dir ) x += strlen ( ( char * ) dir ) ; if ( ! ( name = ( unsigned char * ) malloc ( x + 2 ) ) ) { <S2SV_StartBug> fprintf ( stderr , ""out<S2SV_blank>of<S2SV_blank>memory!\\n"" ) ; <S2SV_EndBug> return NULL ; } * name = '\\0' ; if ( dir ) { strcpy ( ( char * ) name , ( char * ) dir ) ; strcat ( ( char * ) name , ""/"" ) ; } <S2SV_StartBug> while ( * fname == sep ) fname ++ ; <S2SV_EndBug> <S2SV_StartBug> p = & name [ strlen ( ( char * ) name ) ] ; <S2SV_EndBug> fe = & fname [ strlen ( ( char * ) fname ) ] ; if ( utf8 ) { do { <S2SV_StartBug> if ( fname >= fe ) { <S2SV_EndBug> free ( name ) ; return NULL ; } if ( ( c = * fname ++ ) < 0x80 ) x = c ; else { if ( ( c >= 0xC0 ) && ( c < 0xE0 ) ) { <S2SV_StartBug> x = ( c & 0x1F ) << 6 ; <S2SV_EndBug> x |= * fname ++ & 0x3F ; } else if ( ( c >= 0xE0 ) && ( c < 0xF0 ) ) { x = ( c & 0xF ) << 12 ; x |= ( * fname ++ & 0x3F ) << 6 ; x |= * fname ++ & 0x3F ; } else x = '?' ; } if ( x == sep ) x = '/' ; else if ( x == slash ) x = '\\\\' ; else if ( lower ) x = ( unsigned int ) tolower ( ( int ) x ) ; if ( x < 0x80 ) { * p ++ = ( unsigned char ) x ; } else if ( x < 0x800 ) { * p ++ = 0xC0 | ( x >> 6 ) ; * p ++ = 0x80 | ( x & 0x3F ) ; } else { * p ++ = 0xE0 | ( x >> 12 ) ; * p ++ = 0x80 | ( ( x >> 6 ) & 0x3F ) ; * p ++ = 0x80 | ( x & 0x3F ) ; } <S2SV_StartBug> } while ( x ) ; <S2SV_EndBug> } else { do { c = * fname ++ ; if ( c == sep ) c = '/' ; else if ( c == slash ) c = '\\\\' ; else if ( lower ) c = ( unsigned char ) tolower ( ( int ) c ) ; } while ( ( * p ++ = c ) ) ; } return ( char * ) name ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> char * create_output_name <S2SV_ModStart> * create_output_name ( <S2SV_ModEnd> char * fname <S2SV_ModStart> char * fname ) { char * out , * p <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( ( out = malloc ( strlen ( fname ) + 1 <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ) ) { <S2SV_ModEnd> while ( * <S2SV_ModStart> * fname == '/' || * fname == '\\\\' <S2SV_ModEnd> ) fname ++ <S2SV_ModStart> fname ++ ; strcpy ( out , ( * fname ) ? fname : ""x"" ) ; for ( p = out ; * p ; p ++ ) <S2SV_ModEnd> { if ( <S2SV_ModStart> { if ( p [ 0 ] == '.' && p [ 1 ] == '.' && ( p [ 2 ] == '/' || p [ 2 ] == '\\\\' <S2SV_ModEnd> ) ) { <S2SV_ModStart> ) ) { p [ 0 ] = p [ 1 ] = 'x' <S2SV_ModEnd> ; } } <S2SV_ModStart> ; } } } return out <S2SV_ModEnd> ; } <S2SV_null>
"
346,"CWE-416 PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; <S2SV_StartBug> zval * options = NULL , * classes = NULL ; <S2SV_EndBug> HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } <S2SV_StartBug> if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { <S2SV_EndBug> PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } <S2SV_StartBug> zval_ptr_dtor ( return_value ) ; <S2SV_EndBug> if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>"" ZEND_LONG_FMT ""<S2SV_blank>of<S2SV_blank>%zd<S2SV_blank>bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } <S2SV_StartBug> var_push_dtor ( & var_hash , return_value ) ; <S2SV_EndBug> PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
","<S2SV_ModStart> classes = NULL ; zval * retval <S2SV_ModStart> ; } } retval = var_tmp_var ( & var_hash ) ; <S2SV_ModStart> ! php_var_unserialize_ex ( retval <S2SV_ModEnd> , & p <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> RETURN_FALSE ; } ZVAL_COPY ( return_value , retval <S2SV_ModEnd> ) ; PHP_VAR_UNSERIALIZE_DESTROY
"
347,"CWE-200 static int snd_timer_user_tselect ( struct file * file , struct snd_timer_select __user * _tselect ) { struct snd_timer_user * tu ; struct snd_timer_select tselect ; char str [ 32 ] ; int err = 0 ; tu = file -> private_data ; if ( tu -> timeri ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } if ( copy_from_user ( & tselect , _tselect , sizeof ( tselect ) ) ) { err = - EFAULT ; goto __err ; } sprintf ( str , ""application<S2SV_blank>%i"" , current -> pid ) ; if ( tselect . id . dev_class != SNDRV_TIMER_CLASS_SLAVE ) tselect . id . dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION ; err = snd_timer_open ( & tu -> timeri , str , & tselect . id , current -> pid ) ; if ( err < 0 ) goto __err ; <S2SV_StartBug> kfree ( tu -> queue ) ; <S2SV_EndBug> tu -> queue = NULL ; kfree ( tu -> tqueue ) ; tu -> tqueue = NULL ; if ( tu -> tread ) { tu -> tqueue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_tread ) , GFP_KERNEL ) ; if ( tu -> tqueue == NULL ) err = - ENOMEM ; } else { tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) , GFP_KERNEL ) ; if ( tu -> queue == NULL ) err = - ENOMEM ; } if ( err < 0 ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } else { tu -> timeri -> flags |= SNDRV_TIMER_IFLG_FAST ; tu -> timeri -> callback = tu -> tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt ; tu -> timeri -> ccallback = snd_timer_user_ccallback ; tu -> timeri -> callback_data = ( void * ) tu ; tu -> timeri -> disconnect = snd_timer_user_disconnect ; } __err : return err ; }
","<S2SV_ModStart> goto __err ; tu -> qhead = tu -> qtail = tu -> qused = 0 ;
"
348,"CWE-125 GF_Err abst_box_read ( GF_Box * s , GF_BitStream * bs ) { GF_AdobeBootstrapInfoBox * ptr = ( GF_AdobeBootstrapInfoBox * ) s ; int i ; u32 tmp_strsize ; char * tmp_str ; GF_Err e ; ISOM_DECREASE_SIZE ( ptr , 25 ) ptr -> bootstrapinfo_version = gf_bs_read_u32 ( bs ) ; ptr -> profile = gf_bs_read_int ( bs , 2 ) ; ptr -> live = gf_bs_read_int ( bs , 1 ) ; ptr -> update = gf_bs_read_int ( bs , 1 ) ; ptr -> reserved = gf_bs_read_int ( bs , 4 ) ; ptr -> time_scale = gf_bs_read_u32 ( bs ) ; ptr -> current_media_time = gf_bs_read_u64 ( bs ) ; ptr -> smpte_time_code_offset = gf_bs_read_u64 ( bs ) ; i = 0 ; if ( ptr -> size < 8 ) return GF_ISOM_INVALID_FILE ; <S2SV_StartBug> tmp_strsize = ( u32 ) ptr -> size - 8 ; <S2SV_EndBug> tmp_str = gf_malloc ( sizeof ( char ) * tmp_strsize ) ; if ( ! tmp_str ) return GF_OUT_OF_MEM ; memset ( tmp_str , 0 , sizeof ( char ) * tmp_strsize ) ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> movie_identifier = gf_strdup ( tmp_str ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> server_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> server_entry_count ; i ++ ) { int j = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ j ] ) break ; j ++ ; } if ( j ) { gf_list_insert ( ptr -> server_entry_table , gf_strdup ( tmp_str ) , i ) ; } } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> quality_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> quality_entry_count ; i ++ ) { int j = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ j ] ) break ; j ++ ; } if ( j ) { gf_list_insert ( ptr -> quality_entry_table , gf_strdup ( tmp_str ) , i ) ; } } i = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> drm_data = gf_strdup ( tmp_str ) ; } i = 0 ; tmp_strsize = ( u32 ) ptr -> size ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> meta_data = gf_strdup ( tmp_str ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> segment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> segment_run_table_count ; i ++ ) { GF_AdobeSegmentRunTableBox * asrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & asrt , bs ) ; if ( e ) { if ( asrt ) gf_isom_box_del ( ( GF_Box * ) asrt ) ; gf_free ( tmp_str ) ; return e ; } gf_list_add ( ptr -> segment_run_table_entries , asrt ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> fragment_run_table_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> fragment_run_table_count ; i ++ ) { GF_AdobeFragmentRunTableBox * afrt = NULL ; e = gf_isom_box_parse ( ( GF_Box * * ) & afrt , bs ) ; if ( e ) { if ( afrt ) gf_isom_box_del ( ( GF_Box * ) afrt ) ; gf_free ( tmp_str ) ; return e ; } gf_list_add ( ptr -> fragment_run_table_entries , afrt ) ; } gf_free ( tmp_str ) ; return GF_OK ; }
","<S2SV_ModStart> ptr -> size <S2SV_ModEnd> ; tmp_str =
"
349,"CWE-119 vpx_fixed_buf_t * vpx_codec_get_global_headers ( vpx_codec_ctx_t * ctx ) { vpx_fixed_buf_t * buf = NULL ; if ( ctx ) { if ( ! ctx -> iface || ! ctx -> priv ) ctx -> err = VPX_CODEC_ERROR ; else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) ctx -> err = VPX_CODEC_INCAPABLE ; else if ( ! ctx -> iface -> enc . get_glob_hdrs ) ctx -> err = VPX_CODEC_INCAPABLE ; else <S2SV_StartBug> buf = ctx -> iface -> enc . get_glob_hdrs ( ctx -> priv -> alg_priv ) ; <S2SV_EndBug> } return buf ; }
","<S2SV_ModStart> . get_glob_hdrs ( get_alg_priv ( ctx ) <S2SV_ModEnd> ) ; }
"
350,"CWE-404 int main ( int argc , char * * cargv ) { uschar * * argv = USS cargv ; int arg_receive_timeout = - 1 ; int arg_smtp_receive_timeout = - 1 ; int arg_error_handling = error_handling ; int filter_sfd = - 1 ; int filter_ufd = - 1 ; int group_count ; int i , rv ; int list_queue_option = 0 ; int msg_action = 0 ; int msg_action_arg = - 1 ; int namelen = ( argv [ 0 ] == NULL ) ? 0 : Ustrlen ( argv [ 0 ] ) ; int queue_only_reason = 0 ; # ifdef EXIM_PERL int perl_start_option = 0 ; # endif int recipients_arg = argc ; int sender_address_domain = 0 ; int test_retry_arg = - 1 ; int test_rewrite_arg = - 1 ; BOOL arg_queue_only = FALSE ; BOOL bi_option = FALSE ; BOOL checking = FALSE ; BOOL count_queue = FALSE ; BOOL expansion_test = FALSE ; BOOL extract_recipients = FALSE ; BOOL flag_G = FALSE ; BOOL flag_n = FALSE ; BOOL forced_delivery = FALSE ; BOOL f_end_dot = FALSE ; BOOL deliver_give_up = FALSE ; BOOL list_queue = FALSE ; BOOL list_options = FALSE ; BOOL list_config = FALSE ; BOOL local_queue_only ; BOOL more = TRUE ; BOOL one_msg_action = FALSE ; BOOL opt_D_used = FALSE ; BOOL queue_only_set = FALSE ; BOOL receiving_message = TRUE ; BOOL sender_ident_set = FALSE ; BOOL session_local_queue_only ; BOOL unprivileged ; BOOL removed_privilege = FALSE ; BOOL usage_wanted = FALSE ; BOOL verify_address_mode = FALSE ; BOOL verify_as_sender = FALSE ; BOOL version_printed = FALSE ; uschar * alias_arg = NULL ; uschar * called_as = US """" ; uschar * cmdline_syslog_name = NULL ; uschar * start_queue_run_id = NULL ; uschar * stop_queue_run_id = NULL ; uschar * expansion_test_message = NULL ; uschar * ftest_domain = NULL ; uschar * ftest_localpart = NULL ; uschar * ftest_prefix = NULL ; uschar * ftest_suffix = NULL ; uschar * log_oneline = NULL ; uschar * malware_test_file = NULL ; uschar * real_sender_address ; uschar * originator_home = US ""/"" ; size_t sz ; void * reset_point ; struct passwd * pw ; struct stat statbuf ; pid_t passed_qr_pid = ( pid_t ) 0 ; int passed_qr_pipe = - 1 ; gid_t group_list [ NGROUPS_MAX ] ; enum commandline_info info_flag = CMDINFO_NONE ; BOOL info_stdout = FALSE ; static uschar * rsopts [ ] = { US ""f"" , US ""ff"" , US ""r"" , US ""rf"" , US ""rff"" } ; extern char * * environ ; # ifdef EXIM_USERNAME if ( route_finduser ( US EXIM_USERNAME , & pw , & exim_uid ) ) { if ( exim_uid == 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>refusing<S2SV_blank>to<S2SV_blank>run<S2SV_blank>with<S2SV_blank>uid<S2SV_blank>0<S2SV_blank>for<S2SV_blank>\\""%s\\""\\n"" , EXIM_USERNAME ) ; exit ( EXIT_FAILURE ) ; } if ( pw ) exim_gid = pw -> pw_gid ; # ifndef EXIM_GROUPNAME else { fprintf ( stderr , ""exim:<S2SV_blank>ref:name<S2SV_blank>should<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>usercode,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>group.\\n"" ""exim:<S2SV_blank>can\'t<S2SV_blank>let<S2SV_blank>you<S2SV_blank>get<S2SV_blank>away<S2SV_blank>with<S2SV_blank>it<S2SV_blank>unless<S2SV_blank>you<S2SV_blank>also<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>group.\\n"" ) ; exit ( EXIT_FAILURE ) ; } # endif } else { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>uid<S2SV_blank>for<S2SV_blank>user<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , EXIM_USERNAME ) ; exit ( EXIT_FAILURE ) ; } # endif # ifdef EXIM_GROUPNAME if ( ! route_findgroup ( US EXIM_GROUPNAME , & exim_gid ) ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>gid<S2SV_blank>for<S2SV_blank>group<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , EXIM_GROUPNAME ) ; exit ( EXIT_FAILURE ) ; } # endif # ifdef CONFIGURE_OWNERNAME if ( ! route_finduser ( US CONFIGURE_OWNERNAME , NULL , & config_uid ) ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>uid<S2SV_blank>for<S2SV_blank>user<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , CONFIGURE_OWNERNAME ) ; exit ( EXIT_FAILURE ) ; } # endif system_filter_uid = exim_uid ; # ifdef CONFIGURE_GROUPNAME if ( ! route_findgroup ( US CONFIGURE_GROUPNAME , & config_gid ) ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>gid<S2SV_blank>for<S2SV_blank>group<S2SV_blank>name<S2SV_blank>\\""%s\\""\\n"" , CONFIGURE_GROUPNAME ) ; exit ( EXIT_FAILURE ) ; } # endif # ifdef OS_INIT OS_INIT # endif running_in_test_harness = * running_status == '<' && Ustrcmp ( running_status , ""<<<testing>>>"" ) == 0 ; setlocale ( LC_ALL , ""C"" ) ; os_non_restarting_signal ( SIGALRM , sigalrm_handler ) ; if ( ! ( log_buffer = US malloc ( LOG_BUFFER_SIZE ) ) ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>store<S2SV_blank>for<S2SV_blank>log<S2SV_blank>buffer\\n"" ) ; exit ( EXIT_FAILURE ) ; } bits_set ( log_selector , log_selector_size , log_default ) ; if ( fstat ( fileno ( stderr ) , & statbuf ) >= 0 ) log_stderr = stderr ; pcre_malloc = function_store_get ; pcre_free = function_dummy_free ; big_buffer = store_malloc ( big_buffer_size ) ; set_process_info ( ""initializing"" ) ; os_restarting_signal ( SIGUSR1 , usr1_handler ) ; signal ( SIGHUP , SIG_IGN ) ; signal ( SIGPIPE , SIG_IGN ) ; # ifdef SA_NOCLDWAIT { struct sigaction act ; act . sa_handler = SIG_DFL ; sigemptyset ( & ( act . sa_mask ) ) ; act . sa_flags = 0 ; sigaction ( SIGCHLD , & act , NULL ) ; } # else signal ( SIGCHLD , SIG_DFL ) ; # endif sighup_argv = argv ; version_init ( ) ; message_id_option [ 0 ] = '-' ; message_id_external = message_id_option + 1 ; message_id_external [ 0 ] = 'E' ; message_id = message_id_external + 1 ; message_id [ 0 ] = 0 ; ( void ) umask ( 0 ) ; regex_ismsgid = regex_must_compile ( US ""^(?:[^\\\\W_]{6}-){2}[^\\\\W_]{2}$"" , FALSE , TRUE ) ; regex_smtp_code = regex_must_compile ( US ""^\\\\d\\\\d\\\\d\\\\s(?:\\\\d\\\\.\\\\d\\\\d?\\\\d?\\\\.\\\\d\\\\d?\\\\d?\\\\s)?"" , FALSE , TRUE ) ; # ifdef WHITELIST_D_MACROS regex_whitelisted_macro = regex_must_compile ( US ""^[A-Za-z0-9_/.-]*$"" , FALSE , TRUE ) ; # endif for ( i = 0 ; i < REGEX_VARS ; i ++ ) regex_vars [ i ] = NULL ; if ( ( namelen == 5 && Ustrcmp ( argv [ 0 ] , ""mailq"" ) == 0 ) || ( namelen > 5 && Ustrncmp ( argv [ 0 ] + namelen - 6 , ""/mailq"" , 6 ) == 0 ) ) { list_queue = TRUE ; receiving_message = FALSE ; called_as = US ""-mailq"" ; } if ( ( namelen == 5 && Ustrcmp ( argv [ 0 ] , ""rmail"" ) == 0 ) || ( namelen > 5 && Ustrncmp ( argv [ 0 ] + namelen - 6 , ""/rmail"" , 6 ) == 0 ) ) { dot_ends = FALSE ; called_as = US ""-rmail"" ; errors_sender_rc = EXIT_SUCCESS ; } if ( ( namelen == 5 && Ustrcmp ( argv [ 0 ] , ""rsmtp"" ) == 0 ) || ( namelen > 5 && Ustrncmp ( argv [ 0 ] + namelen - 6 , ""/rsmtp"" , 6 ) == 0 ) ) { smtp_input = smtp_batched_input = TRUE ; called_as = US ""-rsmtp"" ; } if ( ( namelen == 4 && Ustrcmp ( argv [ 0 ] , ""runq"" ) == 0 ) || ( namelen > 4 && Ustrncmp ( argv [ 0 ] + namelen - 5 , ""/runq"" , 5 ) == 0 ) ) { queue_interval = 0 ; receiving_message = FALSE ; called_as = US ""-runq"" ; } if ( ( namelen == 10 && Ustrcmp ( argv [ 0 ] , ""newaliases"" ) == 0 ) || ( namelen > 10 && Ustrncmp ( argv [ 0 ] + namelen - 11 , ""/newaliases"" , 11 ) == 0 ) ) { bi_option = TRUE ; receiving_message = FALSE ; called_as = US ""-newaliases"" ; } original_euid = geteuid ( ) ; real_uid = getuid ( ) ; real_gid = getgid ( ) ; if ( real_uid == root_uid ) { rv = setgid ( real_gid ) ; if ( rv ) { fprintf ( stderr , ""exim:<S2SV_blank>setgid(%ld)<S2SV_blank>failed:<S2SV_blank>%s\\n"" , ( long int ) real_gid , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } rv = setuid ( real_uid ) ; if ( rv ) { fprintf ( stderr , ""exim:<S2SV_blank>setuid(%ld)<S2SV_blank>failed:<S2SV_blank>%s\\n"" , ( long int ) real_uid , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } } unprivileged = ( real_uid != root_uid && original_euid != root_uid ) ; for ( i = 1 ; i < argc ; i ++ ) { BOOL badarg = FALSE ; uschar * arg = argv [ i ] ; uschar * argrest ; int switchchar ; if ( arg [ 0 ] != '-' ) { recipients_arg = i ; break ; } if ( Ustrcmp ( arg , ""--"" ) == 0 ) { recipients_arg = i + 1 ; break ; } switchchar = arg [ 1 ] ; argrest = arg + 2 ; if ( Ustrncmp ( arg + 1 , ""oe"" , 2 ) == 0 || Ustrncmp ( arg + 1 , ""qR"" , 2 ) == 0 || Ustrncmp ( arg + 1 , ""qS"" , 2 ) == 0 ) { switchchar = arg [ 2 ] ; argrest ++ ; } else if ( Ustrncmp ( arg + 1 , ""qqR"" , 3 ) == 0 || Ustrncmp ( arg + 1 , ""qqS"" , 3 ) == 0 ) { switchchar = arg [ 3 ] ; argrest += 2 ; queue_2stage = TRUE ; } else if ( arg [ 1 ] == 'r' ) switchchar = 'f' ; else if ( Ustrcmp ( arg , ""-ov"" ) == 0 ) { switchchar = 'v' ; argrest ++ ; } else if ( switchchar == '-' ) { if ( Ustrcmp ( argrest , ""help"" ) == 0 ) { usage_wanted = TRUE ; break ; } else if ( Ustrcmp ( argrest , ""version"" ) == 0 ) { switchchar = 'b' ; argrest = US ""V"" ; } } switch ( switchchar ) { case 'A' : if ( * argrest == '\\0' ) { badarg = TRUE ; break ; } else { BOOL ignore = FALSE ; switch ( * argrest ) { case 'c' : case 'm' : if ( * ( argrest + 1 ) == '\\0' ) ignore = TRUE ; break ; } if ( ! ignore ) { badarg = TRUE ; break ; } } break ; case 'B' : if ( * argrest == 0 ) i ++ ; break ; case 'b' : receiving_message = FALSE ; if ( * argrest == 'd' ) { daemon_listen = TRUE ; if ( * ( ++ argrest ) == 'f' ) background_daemon = FALSE ; else if ( * argrest != 0 ) { badarg = TRUE ; break ; } } else if ( * argrest == 'e' ) { expansion_test = checking = TRUE ; if ( argrest [ 1 ] == 'm' ) { if ( ++ i >= argc ) { badarg = TRUE ; break ; } expansion_test_message = argv [ i ] ; argrest ++ ; } if ( argrest [ 1 ] != 0 ) { badarg = TRUE ; break ; } } else if ( * argrest == 'F' ) { filter_test |= checking = FTEST_SYSTEM ; if ( * ( ++ argrest ) != 0 ) { badarg = TRUE ; break ; } if ( ++ i < argc ) filter_test_sfile = argv [ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>file<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n"" , argv [ i - 1 ] ) ; exit ( EXIT_FAILURE ) ; } } else if ( * argrest == 'f' ) { if ( * ( ++ argrest ) == 0 ) { filter_test |= checking = FTEST_USER ; if ( ++ i < argc ) filter_test_ufile = argv [ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>file<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n"" , argv [ i - 1 ] ) ; exit ( EXIT_FAILURE ) ; } } else { if ( ++ i >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n"" , arg ) ; exit ( EXIT_FAILURE ) ; } if ( Ustrcmp ( argrest , ""d"" ) == 0 ) ftest_domain = argv [ i ] ; else if ( Ustrcmp ( argrest , ""l"" ) == 0 ) ftest_localpart = argv [ i ] ; else if ( Ustrcmp ( argrest , ""p"" ) == 0 ) ftest_prefix = argv [ i ] ; else if ( Ustrcmp ( argrest , ""s"" ) == 0 ) ftest_suffix = argv [ i ] ; else { badarg = TRUE ; break ; } } } else if ( Ustrcmp ( argrest , ""h"" ) == 0 || Ustrcmp ( argrest , ""hc"" ) == 0 ) { if ( ++ i >= argc ) { badarg = TRUE ; break ; } sender_host_address = argv [ i ] ; host_checking = checking = log_testing_mode = TRUE ; host_checking_callout = argrest [ 1 ] == 'c' ; message_logs = FALSE ; } else if ( Ustrcmp ( argrest , ""i"" ) == 0 ) bi_option = TRUE ; else if ( argrest [ 0 ] == 'I' && Ustrlen ( argrest ) >= 2 && argrest [ 1 ] == ':' ) { uschar * p = & argrest [ 2 ] ; info_flag = CMDINFO_HELP ; if ( Ustrlen ( p ) ) { if ( strcmpic ( p , CUS ""sieve"" ) == 0 ) { info_flag = CMDINFO_SIEVE ; info_stdout = TRUE ; } else if ( strcmpic ( p , CUS ""dscp"" ) == 0 ) { info_flag = CMDINFO_DSCP ; info_stdout = TRUE ; } else if ( strcmpic ( p , CUS ""help"" ) == 0 ) { info_stdout = TRUE ; } } } else if ( Ustrcmp ( argrest , ""m"" ) == 0 ) receiving_message = TRUE ; else if ( Ustrcmp ( argrest , ""malware"" ) == 0 ) { if ( ++ i >= argc ) { badarg = TRUE ; break ; } checking = TRUE ; malware_test_file = argv [ i ] ; } else if ( Ustrcmp ( argrest , ""nq"" ) == 0 ) { allow_unqualified_sender = FALSE ; allow_unqualified_recipient = FALSE ; } else if ( * argrest == 'p' ) { if ( * ( ++ argrest ) == 'c' ) { count_queue = TRUE ; if ( * ( ++ argrest ) != 0 ) badarg = TRUE ; break ; } if ( * argrest == 'r' ) { list_queue_option = 8 ; argrest ++ ; } else list_queue_option = 0 ; list_queue = TRUE ; if ( * argrest == 0 ) { } else if ( Ustrcmp ( argrest , ""u"" ) == 0 ) list_queue_option += 1 ; else if ( Ustrcmp ( argrest , ""a"" ) == 0 ) list_queue_option += 2 ; else { badarg = TRUE ; break ; } } else if ( Ustrcmp ( argrest , ""P"" ) == 0 ) { if ( argv [ i + 1 ] && Ustrcmp ( argv [ i + 1 ] , ""config"" ) == 0 ) { list_config = TRUE ; readconf_save_config ( version_string ) ; } else { list_options = TRUE ; debug_selector |= D_v ; debug_file = stderr ; } } else if ( Ustrcmp ( argrest , ""rt"" ) == 0 ) { checking = TRUE ; test_retry_arg = i + 1 ; goto END_ARG ; } else if ( Ustrcmp ( argrest , ""rw"" ) == 0 ) { checking = TRUE ; test_rewrite_arg = i + 1 ; goto END_ARG ; } else if ( Ustrcmp ( argrest , ""S"" ) == 0 ) smtp_input = smtp_batched_input = receiving_message = TRUE ; else if ( Ustrcmp ( argrest , ""s"" ) == 0 ) smtp_input = receiving_message = TRUE ; else if ( Ustrcmp ( argrest , ""t"" ) == 0 ) address_test_mode = checking = log_testing_mode = TRUE ; else if ( Ustrcmp ( argrest , ""v"" ) == 0 ) verify_address_mode = checking = log_testing_mode = TRUE ; else if ( Ustrcmp ( argrest , ""vs"" ) == 0 ) { verify_address_mode = checking = log_testing_mode = TRUE ; verify_as_sender = TRUE ; } else if ( Ustrcmp ( argrest , ""V"" ) == 0 ) { printf ( ""Exim<S2SV_blank>version<S2SV_blank>%s<S2SV_blank>#%s<S2SV_blank>built<S2SV_blank>%s\\n"" , version_string , version_cnumber , version_date ) ; printf ( ""%s\\n"" , CS version_copyright ) ; version_printed = TRUE ; show_whats_supported ( stdout ) ; log_testing_mode = TRUE ; } else if ( * argrest == 'w' ) { inetd_wait_mode = TRUE ; background_daemon = FALSE ; daemon_listen = TRUE ; if ( * ( ++ argrest ) != '\\0' ) { inetd_wait_timeout = readconf_readtime ( argrest , 0 , FALSE ) ; if ( inetd_wait_timeout <= 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>time<S2SV_blank>value<S2SV_blank>%s:<S2SV_blank>abandoned\\n"" , argv [ i ] ) ; exit ( EXIT_FAILURE ) ; } } } else badarg = TRUE ; break ; case 'C' : if ( * argrest == 0 ) { if ( ++ i < argc ) argrest = argv [ i ] ; else { badarg = TRUE ; break ; } } if ( Ustrcmp ( config_main_filelist , argrest ) != 0 ) { # ifdef ALT_CONFIG_PREFIX int sep = 0 ; int len = Ustrlen ( ALT_CONFIG_PREFIX ) ; const uschar * list = argrest ; uschar * filename ; while ( ( filename = string_nextinlist ( & list , & sep , big_buffer , big_buffer_size ) ) != NULL ) { if ( ( Ustrlen ( filename ) < len || Ustrncmp ( filename , ALT_CONFIG_PREFIX , len ) != 0 || Ustrstr ( filename , ""/../"" ) != NULL ) && ( Ustrcmp ( filename , ""/dev/null"" ) != 0 || real_uid != root_uid ) ) { fprintf ( stderr , ""-C<S2SV_blank>Permission<S2SV_blank>denied\\n"" ) ; exit ( EXIT_FAILURE ) ; } } # endif if ( real_uid != root_uid ) { # ifdef TRUSTED_CONFIG_LIST if ( real_uid != exim_uid # ifdef CONFIGURE_OWNER && real_uid != config_uid # endif ) trusted_config = FALSE ; else { FILE * trust_list = Ufopen ( TRUSTED_CONFIG_LIST , ""rb"" ) ; if ( trust_list ) { struct stat statbuf ; if ( fstat ( fileno ( trust_list ) , & statbuf ) != 0 || ( statbuf . st_uid != root_uid # ifdef CONFIGURE_OWNER && statbuf . st_uid != config_uid # endif ) || ( statbuf . st_gid != root_gid # ifdef CONFIGURE_GROUP && statbuf . st_gid != config_gid # endif && ( statbuf . st_mode & 020 ) != 0 ) || ( statbuf . st_mode & 2 ) != 0 ) { trusted_config = FALSE ; fclose ( trust_list ) ; } else { void * reset_point = store_get ( 0 ) ; uschar * trusted_configs [ 32 ] ; int nr_configs = 0 ; int i = 0 ; while ( Ufgets ( big_buffer , big_buffer_size , trust_list ) ) { uschar * start = big_buffer , * nl ; while ( * start && isspace ( * start ) ) start ++ ; if ( * start != '/' ) continue ; nl = Ustrchr ( start , '\\n' ) ; if ( nl ) * nl = 0 ; trusted_configs [ nr_configs ++ ] = string_copy ( start ) ; if ( nr_configs == 32 ) break ; } fclose ( trust_list ) ; if ( nr_configs ) { int sep = 0 ; const uschar * list = argrest ; uschar * filename ; while ( trusted_config && ( filename = string_nextinlist ( & list , & sep , big_buffer , big_buffer_size ) ) != NULL ) { for ( i = 0 ; i < nr_configs ; i ++ ) { if ( Ustrcmp ( filename , trusted_configs [ i ] ) == 0 ) break ; } if ( i == nr_configs ) { trusted_config = FALSE ; break ; } } store_reset ( reset_point ) ; } else { trusted_config = FALSE ; } } } else { trusted_config = FALSE ; } } # else trusted_config = FALSE ; # endif } config_main_filelist = argrest ; config_changed = TRUE ; } break ; case 'D' : # ifdef DISABLE_D_OPTION fprintf ( stderr , ""exim:<S2SV_blank>-D<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available<S2SV_blank>in<S2SV_blank>this<S2SV_blank>Exim<S2SV_blank>binary\\n"" ) ; exit ( EXIT_FAILURE ) ; # else { int ptr = 0 ; macro_item * m ; uschar name [ 24 ] ; uschar * s = argrest ; opt_D_used = TRUE ; while ( isspace ( * s ) ) s ++ ; if ( * s < 'A' || * s > 'Z' ) { fprintf ( stderr , ""exim:<S2SV_blank>macro<S2SV_blank>name<S2SV_blank>set<S2SV_blank>by<S2SV_blank>-D<S2SV_blank>must<S2SV_blank>start<S2SV_blank>with<S2SV_blank>"" ""an<S2SV_blank>upper<S2SV_blank>case<S2SV_blank>letter\\n"" ) ; exit ( EXIT_FAILURE ) ; } while ( isalnum ( * s ) || * s == '_' ) { if ( ptr < sizeof ( name ) - 1 ) name [ ptr ++ ] = * s ; s ++ ; } name [ ptr ] = 0 ; if ( ptr == 0 ) { badarg = TRUE ; break ; } while ( isspace ( * s ) ) s ++ ; if ( * s != 0 ) { if ( * s ++ != '=' ) { badarg = TRUE ; break ; } while ( isspace ( * s ) ) s ++ ; } for ( m = macros ; m ; m = m -> next ) if ( Ustrcmp ( m -> name , name ) == 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>duplicated<S2SV_blank>-D<S2SV_blank>in<S2SV_blank>command<S2SV_blank>line\\n"" ) ; exit ( EXIT_FAILURE ) ; } m = macro_create ( name , s , TRUE , FALSE ) ; if ( clmacro_count >= MAX_CLMACROS ) { fprintf ( stderr , ""exim:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>-D<S2SV_blank>options<S2SV_blank>on<S2SV_blank>command<S2SV_blank>line\\n"" ) ; exit ( EXIT_FAILURE ) ; } clmacros [ clmacro_count ++ ] = string_sprintf ( ""-D%s=%s"" , m -> name , m -> replacement ) ; } # endif break ; case 'd' : if ( Ustrcmp ( argrest , ""ropcr"" ) == 0 ) { } else { unsigned int selector = D_default ; debug_selector = 0 ; debug_file = NULL ; if ( * argrest == 'd' ) { debug_daemon = TRUE ; argrest ++ ; } if ( * argrest != 0 ) decode_bits ( & selector , 1 , debug_notall , argrest , debug_options , debug_options_count , US ""debug"" , 0 ) ; debug_selector = selector ; } break ; case 'E' : local_error_message = TRUE ; if ( mac_ismsgid ( argrest ) ) message_reference = argrest ; break ; case 'e' : if ( Ustrcmp ( argrest , ""e"" ) == 0 ) { arg_error_handling = ERRORS_SENDER ; errors_sender_rc = EXIT_SUCCESS ; } else if ( Ustrcmp ( argrest , ""m"" ) == 0 ) arg_error_handling = ERRORS_SENDER ; else if ( Ustrcmp ( argrest , ""p"" ) == 0 ) arg_error_handling = ERRORS_STDERR ; else if ( Ustrcmp ( argrest , ""q"" ) == 0 ) arg_error_handling = ERRORS_STDERR ; else if ( Ustrcmp ( argrest , ""w"" ) == 0 ) arg_error_handling = ERRORS_SENDER ; else badarg = TRUE ; break ; case 'F' : if ( * argrest == 0 ) { if ( ++ i < argc ) argrest = argv [ i ] ; else { badarg = TRUE ; break ; } } originator_name = argrest ; sender_name_forced = TRUE ; break ; case 'f' : { int dummy_start , dummy_end ; uschar * errmess ; if ( * argrest == 0 ) { if ( i + 1 < argc ) argrest = argv [ ++ i ] ; else { badarg = TRUE ; break ; } } if ( * argrest == 0 ) sender_address = string_sprintf ( """" ) ; else { uschar * temp = argrest + Ustrlen ( argrest ) - 1 ; while ( temp >= argrest && isspace ( * temp ) ) temp -- ; if ( temp >= argrest && * temp == '.' ) f_end_dot = TRUE ; allow_domain_literals = TRUE ; strip_trailing_dot = TRUE ; # ifdef SUPPORT_I18N allow_utf8_domains = TRUE ; # endif sender_address = parse_extract_address ( argrest , & errmess , & dummy_start , & dummy_end , & sender_address_domain , TRUE ) ; # ifdef SUPPORT_I18N message_smtputf8 = string_is_utf8 ( sender_address ) ; allow_utf8_domains = FALSE ; # endif allow_domain_literals = FALSE ; strip_trailing_dot = FALSE ; if ( sender_address == NULL ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>-f<S2SV_blank>address<S2SV_blank>\\""%s\\"":<S2SV_blank>%s\\n"" , argrest , errmess ) ; return EXIT_FAILURE ; } } sender_address_forced = TRUE ; } break ; case 'G' : flag_G = TRUE ; break ; case 'h' : if ( * argrest == 0 ) { if ( ++ i < argc ) argrest = argv [ i ] ; else { badarg = TRUE ; break ; } } if ( ! isdigit ( * argrest ) ) badarg = TRUE ; break ; case 'i' : if ( * argrest == 0 ) dot_ends = FALSE ; else badarg = TRUE ; break ; case 'L' : if ( * argrest == '\\0' ) { if ( ++ i < argc ) argrest = argv [ i ] ; else { badarg = TRUE ; break ; } } sz = Ustrlen ( argrest ) ; if ( sz > 32 ) { fprintf ( stderr , ""exim:<S2SV_blank>the<S2SV_blank>-L<S2SV_blank>syslog<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>\\""%s\\""\\n"" , argrest ) ; return EXIT_FAILURE ; } if ( sz < 1 ) { fprintf ( stderr , ""exim:<S2SV_blank>the<S2SV_blank>-L<S2SV_blank>syslog<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\\n"" ) ; return EXIT_FAILURE ; } cmdline_syslog_name = argrest ; break ; case 'M' : receiving_message = FALSE ; if ( Ustrcmp ( argrest , ""C"" ) == 0 ) { union sockaddr_46 interface_sock ; EXIM_SOCKLEN_T size = sizeof ( interface_sock ) ; if ( argc != i + 6 ) { fprintf ( stderr , ""exim:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>or<S2SV_blank>too<S2SV_blank>few<S2SV_blank>arguments<S2SV_blank>after<S2SV_blank>-MC\\n"" ) ; return EXIT_FAILURE ; } if ( msg_action_arg >= 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>incompatible<S2SV_blank>arguments\\n"" ) ; return EXIT_FAILURE ; } continue_transport = argv [ ++ i ] ; continue_hostname = argv [ ++ i ] ; continue_host_address = argv [ ++ i ] ; continue_sequence = Uatoi ( argv [ ++ i ] ) ; msg_action = MSG_DELIVER ; msg_action_arg = ++ i ; forced_delivery = TRUE ; queue_run_pid = passed_qr_pid ; queue_run_pipe = passed_qr_pipe ; if ( ! mac_ismsgid ( argv [ i ] ) ) { fprintf ( stderr , ""exim:<S2SV_blank>malformed<S2SV_blank>message<S2SV_blank>id<S2SV_blank>%s<S2SV_blank>after<S2SV_blank>-MC<S2SV_blank>option\\n"" , argv [ i ] ) ; return EXIT_FAILURE ; } if ( ! continue_proxy_cipher ) if ( getsockname ( fileno ( stdin ) , ( struct sockaddr * ) ( & interface_sock ) , & size ) == 0 ) sending_ip_address = host_ntoa ( - 1 , & interface_sock , NULL , & sending_port ) ; else { fprintf ( stderr , ""exim:<S2SV_blank>getsockname()<S2SV_blank>failed<S2SV_blank>after<S2SV_blank>-MC<S2SV_blank>option:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; return EXIT_FAILURE ; } if ( running_in_test_harness ) millisleep ( 500 ) ; break ; } else if ( * argrest == 'C' && argrest [ 1 ] && ! argrest [ 2 ] ) { switch ( argrest [ 1 ] ) { case 'A' : smtp_authenticated = TRUE ; break ; case 'D' : smtp_peer_options |= PEER_OFFERED_DSN ; break ; case 'G' : if ( ++ i < argc ) queue_name = string_copy ( argv [ i ] ) ; else badarg = TRUE ; break ; case 'K' : smtp_peer_options |= PEER_OFFERED_CHUNKING ; break ; case 'P' : smtp_peer_options |= PEER_OFFERED_PIPE ; break ; case 'Q' : if ( ++ i < argc ) passed_qr_pid = ( pid_t ) ( Uatol ( argv [ i ] ) ) ; else badarg = TRUE ; if ( ++ i < argc ) passed_qr_pipe = ( int ) ( Uatol ( argv [ i ] ) ) ; else badarg = TRUE ; break ; case 'S' : smtp_peer_options |= PEER_OFFERED_SIZE ; break ; # ifdef SUPPORT_TLS case 't' : if ( ++ i < argc ) sending_ip_address = argv [ i ] ; else badarg = TRUE ; if ( ++ i < argc ) sending_port = ( int ) ( Uatol ( argv [ i ] ) ) ; else badarg = TRUE ; if ( ++ i < argc ) continue_proxy_cipher = argv [ i ] ; else badarg = TRUE ; case 'T' : smtp_peer_options |= PEER_OFFERED_TLS ; break ; # endif default : badarg = TRUE ; break ; } break ; } else if ( * argrest == 0 ) { msg_action = MSG_DELIVER ; forced_delivery = deliver_force_thaw = TRUE ; } else if ( Ustrcmp ( argrest , ""ar"" ) == 0 ) { msg_action = MSG_ADD_RECIPIENT ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""c"" ) == 0 ) msg_action = MSG_DELIVER ; else if ( Ustrcmp ( argrest , ""es"" ) == 0 ) { msg_action = MSG_EDIT_SENDER ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""f"" ) == 0 ) msg_action = MSG_FREEZE ; else if ( Ustrcmp ( argrest , ""g"" ) == 0 ) { msg_action = MSG_DELIVER ; deliver_give_up = TRUE ; } else if ( Ustrcmp ( argrest , ""mad"" ) == 0 ) { msg_action = MSG_MARK_ALL_DELIVERED ; } else if ( Ustrcmp ( argrest , ""md"" ) == 0 ) { msg_action = MSG_MARK_DELIVERED ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""rm"" ) == 0 ) msg_action = MSG_REMOVE ; else if ( Ustrcmp ( argrest , ""set"" ) == 0 ) { msg_action = MSG_LOAD ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""t"" ) == 0 ) msg_action = MSG_THAW ; else if ( Ustrcmp ( argrest , ""vb"" ) == 0 ) { msg_action = MSG_SHOW_BODY ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""vc"" ) == 0 ) { msg_action = MSG_SHOW_COPY ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""vh"" ) == 0 ) { msg_action = MSG_SHOW_HEADER ; one_msg_action = TRUE ; } else if ( Ustrcmp ( argrest , ""vl"" ) == 0 ) { msg_action = MSG_SHOW_LOG ; one_msg_action = TRUE ; } else { badarg = TRUE ; break ; } msg_action_arg = i + 1 ; if ( msg_action_arg >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>no<S2SV_blank>message<S2SV_blank>ids<S2SV_blank>given<S2SV_blank>after<S2SV_blank>%s<S2SV_blank>option\\n"" , arg ) ; return EXIT_FAILURE ; } if ( ! one_msg_action ) { int j ; for ( j = msg_action_arg ; j < argc ; j ++ ) if ( ! mac_ismsgid ( argv [ j ] ) ) { fprintf ( stderr , ""exim:<S2SV_blank>malformed<S2SV_blank>message<S2SV_blank>id<S2SV_blank>%s<S2SV_blank>after<S2SV_blank>%s<S2SV_blank>option\\n"" , argv [ j ] , arg ) ; return EXIT_FAILURE ; } goto END_ARG ; } else { if ( ! mac_ismsgid ( argv [ msg_action_arg ] ) ) { fprintf ( stderr , ""exim:<S2SV_blank>malformed<S2SV_blank>message<S2SV_blank>id<S2SV_blank>%s<S2SV_blank>after<S2SV_blank>%s<S2SV_blank>option\\n"" , argv [ msg_action_arg ] , arg ) ; return EXIT_FAILURE ; } i ++ ; } break ; case 'm' : if ( * argrest != 0 ) badarg = TRUE ; break ; case 'N' : if ( * argrest == 0 ) { dont_deliver = TRUE ; debug_selector |= D_v ; debug_file = stderr ; } else badarg = TRUE ; break ; case 'n' : flag_n = TRUE ; break ; case 'O' : if ( * argrest == 0 ) { if ( ++ i >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-O\\n"" ) ; exit ( EXIT_FAILURE ) ; } } break ; case 'o' : if ( * argrest == 'A' ) { alias_arg = argrest + 1 ; if ( alias_arg [ 0 ] == 0 ) { if ( i + 1 < argc ) alias_arg = argv [ ++ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-oA\\n"" ) ; exit ( EXIT_FAILURE ) ; } } } else if ( * argrest == 'B' ) { uschar * p = argrest + 1 ; if ( p [ 0 ] == 0 ) { if ( i + 1 < argc && isdigit ( ( argv [ i + 1 ] [ 0 ] ) ) ) p = argv [ ++ i ] ; else { connection_max_messages = 1 ; p = NULL ; } } if ( p != NULL ) { if ( ! isdigit ( * p ) ) { fprintf ( stderr , ""exim:<S2SV_blank>number<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-oB\\n"" ) ; exit ( EXIT_FAILURE ) ; } connection_max_messages = Uatoi ( p ) ; } } else if ( Ustrcmp ( argrest , ""db"" ) == 0 ) { synchronous_delivery = FALSE ; arg_queue_only = FALSE ; queue_only_set = TRUE ; } else if ( Ustrcmp ( argrest , ""df"" ) == 0 || Ustrcmp ( argrest , ""di"" ) == 0 ) { synchronous_delivery = TRUE ; arg_queue_only = FALSE ; queue_only_set = TRUE ; } else if ( Ustrcmp ( argrest , ""dq"" ) == 0 ) { synchronous_delivery = FALSE ; arg_queue_only = TRUE ; queue_only_set = TRUE ; } else if ( Ustrcmp ( argrest , ""dqs"" ) == 0 ) { queue_smtp = TRUE ; arg_queue_only = FALSE ; queue_only_set = TRUE ; } else if ( Ustrcmp ( argrest , ""i"" ) == 0 || Ustrcmp ( argrest , ""itrue"" ) == 0 ) dot_ends = FALSE ; else if ( * argrest == 'M' ) { if ( i + 1 >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>data<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-o%s\\n"" , argrest ) ; exit ( EXIT_FAILURE ) ; } if ( Ustrcmp ( argrest , ""Ma"" ) == 0 ) sender_host_address = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Maa"" ) == 0 ) sender_host_authenticated = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mas"" ) == 0 ) authenticated_sender = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mai"" ) == 0 ) authenticated_id = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mi"" ) == 0 ) interface_address = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mm"" ) == 0 ) { if ( ! mac_ismsgid ( argv [ i + 1 ] ) ) { fprintf ( stderr , ""-oMm<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>message<S2SV_blank>ID\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( ! trusted_config ) { fprintf ( stderr , ""-oMm<S2SV_blank>must<S2SV_blank>be<S2SV_blank>called<S2SV_blank>by<S2SV_blank>a<S2SV_blank>trusted<S2SV_blank>user/config\\n"" ) ; exit ( EXIT_FAILURE ) ; } message_reference = argv [ ++ i ] ; } <S2SV_StartBug> else if ( Ustrcmp ( argrest , ""Mr"" ) == 0 ) received_protocol = argv [ ++ i ] ; <S2SV_EndBug> else if ( Ustrcmp ( argrest , ""Ms"" ) == 0 ) sender_host_name = argv [ ++ i ] ; else if ( Ustrcmp ( argrest , ""Mt"" ) == 0 ) { sender_ident_set = TRUE ; sender_ident = argv [ ++ i ] ; } else { badarg = TRUE ; break ; } } else if ( Ustrcmp ( argrest , ""m"" ) == 0 ) { } else if ( Ustrcmp ( argrest , ""o"" ) == 0 ) { } else if ( Ustrcmp ( argrest , ""P"" ) == 0 ) override_pid_file_path = argv [ ++ i ] ; else if ( * argrest == 'r' || * argrest == 's' ) { int * tp = ( * argrest == 'r' ) ? & arg_receive_timeout : & arg_smtp_receive_timeout ; if ( argrest [ 1 ] == 0 ) { if ( i + 1 < argc ) * tp = readconf_readtime ( argv [ ++ i ] , 0 , FALSE ) ; } else * tp = readconf_readtime ( argrest + 1 , 0 , FALSE ) ; if ( * tp < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>time<S2SV_blank>value<S2SV_blank>%s:<S2SV_blank>abandoned\\n"" , argv [ i ] ) ; exit ( EXIT_FAILURE ) ; } } else if ( Ustrcmp ( argrest , ""X"" ) == 0 ) override_local_interfaces = argv [ ++ i ] ; else badarg = TRUE ; break ; case 'p' : # ifdef EXIM_PERL if ( * argrest == 's' && argrest [ 1 ] == 0 ) { perl_start_option = 1 ; break ; } if ( * argrest == 'd' && argrest [ 1 ] == 0 ) { perl_start_option = - 1 ; break ; } # endif if ( * argrest == 0 ) { if ( i + 1 < argc ) argrest = argv [ ++ i ] ; else { badarg = TRUE ; break ; } } if ( * argrest != 0 ) { <S2SV_StartBug> uschar * hn = Ustrchr ( argrest , ':' ) ; <S2SV_EndBug> if ( hn == NULL ) { received_protocol = argrest ; } else { int old_pool = store_pool ; store_pool = POOL_PERM ; received_protocol = string_copyn ( argrest , hn - argrest ) ; store_pool = old_pool ; sender_host_name = hn + 1 ; } } break ; case 'q' : receiving_message = FALSE ; if ( queue_interval >= 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>-q<S2SV_blank>specified<S2SV_blank>more<S2SV_blank>than<S2SV_blank>once\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( * argrest == 'q' ) { queue_2stage = TRUE ; argrest ++ ; } if ( * argrest == 'i' ) { queue_run_first_delivery = TRUE ; argrest ++ ; } if ( * argrest == 'f' ) { queue_run_force = TRUE ; if ( * ++ argrest == 'f' ) { deliver_force_thaw = TRUE ; argrest ++ ; } } if ( * argrest == 'l' ) { queue_run_local = TRUE ; argrest ++ ; } if ( * argrest == 'G' ) { int i ; for ( argrest ++ , i = 0 ; argrest [ i ] && argrest [ i ] != '/' ; ) i ++ ; queue_name = string_copyn ( argrest , i ) ; argrest += i ; if ( * argrest == '/' ) argrest ++ ; } if ( * argrest == 0 && ( i + 1 >= argc || argv [ i + 1 ] [ 0 ] == '-' || mac_ismsgid ( argv [ i + 1 ] ) ) ) { queue_interval = 0 ; if ( i + 1 < argc && mac_ismsgid ( argv [ i + 1 ] ) ) start_queue_run_id = argv [ ++ i ] ; if ( i + 1 < argc && mac_ismsgid ( argv [ i + 1 ] ) ) stop_queue_run_id = argv [ ++ i ] ; } else if ( ( queue_interval = readconf_readtime ( * argrest ? argrest : argv [ ++ i ] , 0 , FALSE ) ) <= 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>time<S2SV_blank>value<S2SV_blank>%s:<S2SV_blank>abandoned\\n"" , argv [ i ] ) ; exit ( EXIT_FAILURE ) ; } break ; case 'R' : receiving_message = FALSE ; if ( * argrest != 0 ) { int i ; for ( i = 0 ; i < nelem ( rsopts ) ; i ++ ) if ( Ustrcmp ( argrest , rsopts [ i ] ) == 0 ) { if ( i != 2 ) queue_run_force = TRUE ; if ( i >= 2 ) deliver_selectstring_regex = TRUE ; if ( i == 1 || i == 4 ) deliver_force_thaw = TRUE ; argrest += Ustrlen ( rsopts [ i ] ) ; } } if ( * argrest ) deliver_selectstring = argrest ; else if ( i + 1 < argc ) deliver_selectstring = argv [ ++ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-R\\n"" ) ; exit ( EXIT_FAILURE ) ; } break ; case 'S' : receiving_message = FALSE ; if ( * argrest ) { int i ; for ( i = 0 ; i < nelem ( rsopts ) ; i ++ ) if ( Ustrcmp ( argrest , rsopts [ i ] ) == 0 ) { if ( i != 2 ) queue_run_force = TRUE ; if ( i >= 2 ) deliver_selectstring_sender_regex = TRUE ; if ( i == 1 || i == 4 ) deliver_force_thaw = TRUE ; argrest += Ustrlen ( rsopts [ i ] ) ; } } if ( * argrest ) deliver_selectstring_sender = argrest ; else if ( i + 1 < argc ) deliver_selectstring_sender = argv [ ++ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-S\\n"" ) ; exit ( EXIT_FAILURE ) ; } break ; case 'T' : if ( running_in_test_harness && Ustrcmp ( argrest , ""qt"" ) == 0 ) fudged_queue_times = argv [ ++ i ] ; else badarg = TRUE ; break ; case 't' : if ( * argrest == 0 ) extract_recipients = TRUE ; else if ( Ustrcmp ( argrest , ""i"" ) == 0 ) { extract_recipients = TRUE ; dot_ends = FALSE ; } # ifdef SUPPORT_TLS else if ( Ustrcmp ( argrest , ""ls-on-connect"" ) == 0 ) tls_in . on_connect = TRUE ; # endif else badarg = TRUE ; break ; case 'U' : break ; case 'v' : if ( * argrest == 0 ) { debug_selector |= D_v ; debug_file = stderr ; } else badarg = TRUE ; break ; case 'x' : if ( * argrest != 0 ) badarg = TRUE ; break ; case 'X' : if ( * argrest == '\\0' ) if ( ++ i >= argc ) { fprintf ( stderr , ""exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-X\\n"" ) ; exit ( EXIT_FAILURE ) ; } break ; case 'z' : if ( * argrest == '\\0' ) if ( ++ i < argc ) log_oneline = argv [ i ] ; else { fprintf ( stderr , ""exim:<S2SV_blank>file<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n"" , argv [ i - 1 ] ) ; exit ( EXIT_FAILURE ) ; } break ; default : badarg = TRUE ; break ; } if ( badarg ) { fprintf ( stderr , ""exim<S2SV_blank>abandoned:<S2SV_blank>unknown,<S2SV_blank>malformed,<S2SV_blank>or<S2SV_blank>incomplete<S2SV_blank>"" ""option<S2SV_blank>%s\\n"" , arg ) ; exit ( EXIT_FAILURE ) ; } } if ( ( deliver_selectstring || deliver_selectstring_sender ) && queue_interval < 0 ) queue_interval = 0 ; END_ARG : if ( usage_wanted ) exim_usage ( called_as ) ; if ( ( ( smtp_input || extract_recipients || recipients_arg < argc ) && ( daemon_listen || queue_interval >= 0 || bi_option || test_retry_arg >= 0 || test_rewrite_arg >= 0 || filter_test != FTEST_NONE || ( msg_action_arg > 0 && ! one_msg_action ) ) ) || ( msg_action_arg > 0 && ( daemon_listen || queue_interval > 0 || list_options || ( checking && msg_action != MSG_LOAD ) || bi_option || test_retry_arg >= 0 || test_rewrite_arg >= 0 ) ) || ( ( daemon_listen || queue_interval > 0 ) && ( sender_address != NULL || list_options || list_queue || checking || bi_option ) ) || ( daemon_listen && queue_interval == 0 ) || ( inetd_wait_mode && queue_interval >= 0 ) || ( list_options && ( checking || smtp_input || extract_recipients || filter_test != FTEST_NONE || bi_option ) ) || ( verify_address_mode && ( address_test_mode || smtp_input || extract_recipients || filter_test != FTEST_NONE || bi_option ) ) || ( address_test_mode && ( smtp_input || extract_recipients || filter_test != FTEST_NONE || bi_option ) ) || ( smtp_input && ( sender_address != NULL || filter_test != FTEST_NONE || extract_recipients ) ) || ( deliver_selectstring != NULL && queue_interval < 0 ) || ( msg_action == MSG_LOAD && ( ! expansion_test || expansion_test_message != NULL ) ) ) { fprintf ( stderr , ""exim:<S2SV_blank>incompatible<S2SV_blank>command-line<S2SV_blank>options<S2SV_blank>or<S2SV_blank>arguments\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( debug_selector != 0 ) { debug_file = stderr ; debug_fd = fileno ( debug_file ) ; background_daemon = FALSE ; if ( running_in_test_harness ) millisleep ( 100 ) ; if ( debug_selector != D_v ) { debug_printf ( ""Exim<S2SV_blank>version<S2SV_blank>%s<S2SV_blank>uid=%ld<S2SV_blank>gid=%ld<S2SV_blank>pid=%d<S2SV_blank>D=%x\\n"" , version_string , ( long int ) real_uid , ( long int ) real_gid , ( int ) getpid ( ) , debug_selector ) ; if ( ! version_printed ) show_whats_supported ( stderr ) ; } } if ( unprivileged ) { DEBUG ( D_any ) debug_print_ids ( US ""Exim<S2SV_blank>has<S2SV_blank>no<S2SV_blank>root<S2SV_blank>privilege:"" ) ; } else { struct rlimit rlp ; # ifdef RLIMIT_NOFILE if ( getrlimit ( RLIMIT_NOFILE , & rlp ) < 0 ) { log_write ( 0 , LOG_MAIN | LOG_PANIC , ""getrlimit(RLIMIT_NOFILE)<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( errno ) ) ; rlp . rlim_cur = rlp . rlim_max = 0 ; } if ( rlp . rlim_cur < 1000 ) { rlp . rlim_cur = rlp . rlim_max = 1000 ; if ( setrlimit ( RLIMIT_NOFILE , & rlp ) < 0 ) { rlp . rlim_cur = rlp . rlim_max = 256 ; if ( setrlimit ( RLIMIT_NOFILE , & rlp ) < 0 ) log_write ( 0 , LOG_MAIN | LOG_PANIC , ""setrlimit(RLIMIT_NOFILE)<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( errno ) ) ; } } # endif # ifdef RLIMIT_NPROC if ( getrlimit ( RLIMIT_NPROC , & rlp ) < 0 ) { log_write ( 0 , LOG_MAIN | LOG_PANIC , ""getrlimit(RLIMIT_NPROC)<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( errno ) ) ; rlp . rlim_cur = rlp . rlim_max = 0 ; } # ifdef RLIM_INFINITY if ( rlp . rlim_cur != RLIM_INFINITY && rlp . rlim_cur < 1000 ) { rlp . rlim_cur = rlp . rlim_max = RLIM_INFINITY ; # else if ( rlp . rlim_cur < 1000 ) { rlp . rlim_cur = rlp . rlim_max = 1000 ; # endif if ( setrlimit ( RLIMIT_NPROC , & rlp ) < 0 ) log_write ( 0 , LOG_MAIN | LOG_PANIC , ""setrlimit(RLIMIT_NPROC)<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( errno ) ) ; } # endif } group_count = getgroups ( NGROUPS_MAX , group_list ) ; if ( group_count < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>getgroups()<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } if ( setgroups ( 0 , NULL ) != 0 ) { if ( setgroups ( 1 , group_list ) != 0 && ! unprivileged ) { fprintf ( stderr , ""exim:<S2SV_blank>setgroups()<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } } if ( ( ( ! trusted_config || ! macros_trusted ( opt_D_used ) ) && real_uid != root_uid && ! running_in_test_harness ) || expansion_test || filter_test != FTEST_NONE ) { setgroups ( group_count , group_list ) ; exim_setugid ( real_uid , real_gid , FALSE , US ""-C,<S2SV_blank>-D,<S2SV_blank>-be<S2SV_blank>or<S2SV_blank>-bf<S2SV_blank>forces<S2SV_blank>real<S2SV_blank>uid"" ) ; removed_privilege = TRUE ; if ( ( log_stderr != NULL ) && ( real_uid != exim_uid ) ) really_exim = FALSE ; } else exim_setugid ( geteuid ( ) , getegid ( ) , FALSE , US ""forcing<S2SV_blank>real<S2SV_blank>=<S2SV_blank>effective"" ) ; if ( ( filter_test & FTEST_SYSTEM ) != 0 ) { filter_sfd = Uopen ( filter_test_sfile , O_RDONLY , 0 ) ; if ( filter_sfd < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s\\n"" , filter_test_sfile , strerror ( errno ) ) ; return EXIT_FAILURE ; } } if ( ( filter_test & FTEST_USER ) != 0 ) { filter_ufd = Uopen ( filter_test_ufile , O_RDONLY , 0 ) ; if ( filter_ufd < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s\\n"" , filter_test_ufile , strerror ( errno ) ) ; return EXIT_FAILURE ; } } init_lookup_list ( ) ; # ifdef SUPPORT_I18N if ( running_in_test_harness ) smtputf8_advertise_hosts = NULL ; # endif if ( ( initial_cwd = os_getcwd ( NULL , 0 ) ) == NULL ) { perror ( ""exim:<S2SV_blank>can\'t<S2SV_blank>get<S2SV_blank>the<S2SV_blank>current<S2SV_blank>working<S2SV_blank>directory"" ) ; exit ( EXIT_FAILURE ) ; } readconf_main ( checking || list_options ) ; if ( builtin_macros_create_trigger ) DEBUG ( D_any ) debug_printf ( ""Builtin<S2SV_blank>macros<S2SV_blank>created<S2SV_blank>(expensive)<S2SV_blank>due<S2SV_blank>to<S2SV_blank>config<S2SV_blank>line<S2SV_blank>\'%.*s\'\\n"" , Ustrlen ( builtin_macros_create_trigger ) - 1 , builtin_macros_create_trigger ) ; if ( cleanup_environment ( ) == FALSE ) log_write ( 0 , LOG_PANIC_DIE , ""Can\'t<S2SV_blank>cleanup<S2SV_blank>environment"" ) ; if ( real_uid == root_uid || real_uid == exim_uid || real_gid == exim_gid ) admin_user = TRUE ; else { int i , j ; for ( i = 0 ; i < group_count && ! admin_user ; i ++ ) if ( group_list [ i ] == exim_gid ) admin_user = TRUE ; else if ( admin_groups ) for ( j = 1 ; j <= ( int ) admin_groups [ 0 ] && ! admin_user ; j ++ ) if ( admin_groups [ j ] == group_list [ i ] ) admin_user = TRUE ; } if ( real_uid == root_uid || real_uid == exim_uid ) trusted_caller = TRUE ; else { int i , j ; if ( trusted_users ) for ( i = 1 ; i <= ( int ) trusted_users [ 0 ] && ! trusted_caller ; i ++ ) if ( trusted_users [ i ] == real_uid ) trusted_caller = TRUE ; if ( trusted_groups ) for ( i = 1 ; i <= ( int ) trusted_groups [ 0 ] && ! trusted_caller ; i ++ ) if ( trusted_groups [ i ] == real_gid ) trusted_caller = TRUE ; else for ( j = 0 ; j < group_count && ! trusted_caller ; j ++ ) if ( trusted_groups [ i ] == group_list [ j ] ) trusted_caller = TRUE ; } if ( checking && commandline_checks_require_admin && ! admin_user ) { fprintf ( stderr , ""exim:<S2SV_blank>those<S2SV_blank>command-line<S2SV_blank>flags<S2SV_blank>are<S2SV_blank>set<S2SV_blank>to<S2SV_blank>require<S2SV_blank>admin\\n"" ) ; exit ( EXIT_FAILURE ) ; } decode_bits ( log_selector , log_selector_size , log_notall , log_selector_string , log_options , log_options_count , US ""log"" , 0 ) ; DEBUG ( D_any ) { int i ; debug_printf ( ""configuration<S2SV_blank>file<S2SV_blank>is<S2SV_blank>%s\\n"" , config_main_filename ) ; debug_printf ( ""log<S2SV_blank>selectors<S2SV_blank>="" ) ; for ( i = 0 ; i < log_selector_size ; i ++ ) debug_printf ( ""<S2SV_blank>%08x"" , log_selector [ i ] ) ; debug_printf ( ""\\n"" ) ; } if ( sender_address != NULL ) { if ( sender_address [ sender_address_domain ] == '[' && ! allow_domain_literals ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>-f<S2SV_blank>address<S2SV_blank>\\""%s\\"":<S2SV_blank>domain<S2SV_blank>literals<S2SV_blank>not<S2SV_blank>"" ""allowed\\n"" , sender_address ) ; return EXIT_FAILURE ; } if ( f_end_dot && ! strip_trailing_dot ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>-f<S2SV_blank>address<S2SV_blank>\\""%s.\\"":<S2SV_blank>domain<S2SV_blank>is<S2SV_blank>malformed<S2SV_blank>"" ""(trailing<S2SV_blank>dot<S2SV_blank>not<S2SV_blank>allowed)\\n"" , sender_address ) ; return EXIT_FAILURE ; } } if ( cmdline_syslog_name != NULL ) { if ( admin_user ) { syslog_processname = cmdline_syslog_name ; log_file_path = string_copy ( CUS ""syslog"" ) ; } else { fprintf ( stderr , ""exim:<S2SV_blank>you<S2SV_blank>lack<S2SV_blank>sufficient<S2SV_blank>privilege<S2SV_blank>to<S2SV_blank>specify<S2SV_blank>syslog<S2SV_blank>process<S2SV_blank>name\\n"" ) ; return EXIT_FAILURE ; } } if ( Ustrlen ( log_file_path ) > 200 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""log_file_path<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>200<S2SV_blank>chars:<S2SV_blank>aborting"" ) ; if ( Ustrlen ( pid_file_path ) > 200 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""pid_file_path<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>200<S2SV_blank>chars:<S2SV_blank>aborting"" ) ; if ( Ustrlen ( spool_directory ) > 200 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""spool_directory<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>200<S2SV_blank>chars:<S2SV_blank>aborting"" ) ; if ( Ustrlen ( syslog_processname ) > 32 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""syslog_processname<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>32<S2SV_blank>chars:<S2SV_blank>aborting"" ) ; if ( log_oneline ) if ( admin_user ) { log_write ( 0 , LOG_MAIN , ""%s"" , log_oneline ) ; return EXIT_SUCCESS ; } else return EXIT_FAILURE ; # ifdef EXIM_TMPDIR { uschar * * p ; if ( environ ) for ( p = USS environ ; * p ; p ++ ) if ( Ustrncmp ( * p , ""TMPDIR="" , 7 ) == 0 && Ustrcmp ( * p + 7 , EXIM_TMPDIR ) != 0 ) { uschar * newp = store_malloc ( Ustrlen ( EXIM_TMPDIR ) + 8 ) ; sprintf ( CS newp , ""TMPDIR=%s"" , EXIM_TMPDIR ) ; * p = newp ; DEBUG ( D_any ) debug_printf ( ""reset<S2SV_blank>TMPDIR=%s<S2SV_blank>in<S2SV_blank>environment\\n"" , EXIM_TMPDIR ) ; } } # endif if ( timezone_string && strcmpic ( timezone_string , US ""UTC"" ) == 0 ) timestamps_utc = TRUE ; else { uschar * envtz = US getenv ( ""TZ"" ) ; if ( envtz ? ! timezone_string || Ustrcmp ( timezone_string , envtz ) != 0 : timezone_string != NULL ) { uschar * * p = USS environ ; uschar * * new ; uschar * * newp ; int count = 0 ; if ( environ ) while ( * p ++ ) count ++ ; if ( ! envtz ) count ++ ; newp = new = store_malloc ( sizeof ( uschar * ) * ( count + 1 ) ) ; if ( environ ) for ( p = USS environ ; * p ; p ++ ) if ( Ustrncmp ( * p , ""TZ="" , 3 ) != 0 ) * newp ++ = * p ; if ( timezone_string ) { * newp = store_malloc ( Ustrlen ( timezone_string ) + 4 ) ; sprintf ( CS * newp ++ , ""TZ=%s"" , timezone_string ) ; } * newp = NULL ; environ = CSS new ; tzset ( ) ; DEBUG ( D_any ) debug_printf ( ""Reset<S2SV_blank>TZ<S2SV_blank>to<S2SV_blank>%s:<S2SV_blank>time<S2SV_blank>is<S2SV_blank>%s\\n"" , timezone_string , tod_stamp ( tod_log ) ) ; } } if ( removed_privilege && ( ! trusted_config || opt_D_used ) && real_uid == exim_uid ) if ( deliver_drop_privilege ) really_exim = TRUE ; else log_write ( 0 , LOG_MAIN | LOG_PANIC , ""exim<S2SV_blank>user<S2SV_blank>lost<S2SV_blank>privilege<S2SV_blank>for<S2SV_blank>using<S2SV_blank>%s<S2SV_blank>option"" , trusted_config ? ""-D"" : ""-C"" ) ; # ifdef EXIM_PERL if ( perl_start_option != 0 ) opt_perl_at_start = ( perl_start_option > 0 ) ; if ( opt_perl_at_start && opt_perl_startup != NULL ) { uschar * errstr ; DEBUG ( D_any ) debug_printf ( ""Starting<S2SV_blank>Perl<S2SV_blank>interpreter\\n"" ) ; errstr = init_perl ( opt_perl_startup ) ; if ( errstr != NULL ) { fprintf ( stderr , ""exim:<S2SV_blank>error<S2SV_blank>in<S2SV_blank>perl_startup<S2SV_blank>code:<S2SV_blank>%s\\n"" , errstr ) ; return EXIT_FAILURE ; } opt_perl_started = TRUE ; } # endif if ( ( ( debug_selector & D_any ) != 0 || LOGGING ( arguments ) ) && really_exim && ! list_options && ! checking ) { int i ; uschar * p = big_buffer ; Ustrcpy ( p , ""cwd=<S2SV_blank>(failed)"" ) ; Ustrncpy ( p + 4 , initial_cwd , big_buffer_size - 5 ) ; while ( * p ) p ++ ; ( void ) string_format ( p , big_buffer_size - ( p - big_buffer ) , ""<S2SV_blank>%d<S2SV_blank>args:"" , argc ) ; while ( * p ) p ++ ; for ( i = 0 ; i < argc ; i ++ ) { int len = Ustrlen ( argv [ i ] ) ; const uschar * printing ; uschar * quote ; if ( p + len + 8 >= big_buffer + big_buffer_size ) { Ustrcpy ( p , ""<S2SV_blank>..."" ) ; log_write ( 0 , LOG_MAIN , ""%s"" , big_buffer ) ; Ustrcpy ( big_buffer , ""..."" ) ; p = big_buffer + 3 ; } printing = string_printing ( argv [ i ] ) ; if ( printing [ 0 ] == 0 ) quote = US ""\\"""" ; else { const uschar * pp = printing ; quote = US """" ; while ( * pp != 0 ) if ( isspace ( * pp ++ ) ) { quote = US ""\\"""" ; break ; } } sprintf ( CS p , ""<S2SV_blank>%s%.*s%s"" , quote , ( int ) ( big_buffer_size - ( p - big_buffer ) - 4 ) , printing , quote ) ; while ( * p ) p ++ ; } if ( LOGGING ( arguments ) ) log_write ( 0 , LOG_MAIN , ""%s"" , big_buffer ) ; else debug_printf ( ""%s\\n"" , big_buffer ) ; } if ( Uchdir ( spool_directory ) != 0 ) { int dummy ; ( void ) directory_make ( spool_directory , US """" , SPOOL_DIRECTORY_MODE , FALSE ) ; dummy = Uchdir ( spool_directory ) ; } if ( bi_option ) { ( void ) fclose ( config_file ) ; if ( bi_command != NULL ) { int i = 0 ; uschar * argv [ 3 ] ; argv [ i ++ ] = bi_command ; if ( alias_arg != NULL ) argv [ i ++ ] = alias_arg ; argv [ i ++ ] = NULL ; setgroups ( group_count , group_list ) ; exim_setugid ( real_uid , real_gid , FALSE , US ""running<S2SV_blank>bi_command"" ) ; DEBUG ( D_exec ) debug_printf ( ""exec<S2SV_blank>%.256s<S2SV_blank>%.256s\\n"" , argv [ 0 ] , ( argv [ 1 ] == NULL ) ? US """" : argv [ 1 ] ) ; execv ( CS argv [ 0 ] , ( char * const * ) argv ) ; fprintf ( stderr , ""exim:<S2SV_blank>exec<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } else { DEBUG ( D_any ) debug_printf ( ""-bi<S2SV_blank>used<S2SV_blank>but<S2SV_blank>bi_command<S2SV_blank>not<S2SV_blank>set;<S2SV_blank>exiting\\n"" ) ; exit ( EXIT_SUCCESS ) ; } } if ( trusted_caller ) DEBUG ( D_any ) debug_printf ( ""trusted<S2SV_blank>user\\n"" ) ; if ( admin_user ) DEBUG ( D_any ) debug_printf ( ""admin<S2SV_blank>user\\n"" ) ; if ( ! admin_user ) { BOOL debugset = ( debug_selector & ~ D_v ) != 0 ; if ( deliver_give_up || daemon_listen || malware_test_file || ( count_queue && queue_list_requires_admin ) || ( list_queue && queue_list_requires_admin ) || ( queue_interval >= 0 && prod_requires_admin ) || ( debugset && ! running_in_test_harness ) ) { fprintf ( stderr , ""exim:%s<S2SV_blank>permission<S2SV_blank>denied\\n"" , debugset ? ""<S2SV_blank>debugging"" : """" ) ; exit ( EXIT_FAILURE ) ; } } if ( real_uid != root_uid && real_uid != exim_uid && ( continue_hostname != NULL || ( dont_deliver && ( queue_interval >= 0 || daemon_listen || msg_action_arg > 0 ) ) ) && ! running_in_test_harness ) { fprintf ( stderr , ""exim:<S2SV_blank>Permission<S2SV_blank>denied\\n"" ) ; return EXIT_FAILURE ; } if ( ! trusted_caller && ! checking ) { sender_host_name = sender_host_address = interface_address = sender_ident = received_protocol = NULL ; sender_host_port = interface_port = 0 ; sender_host_authenticated = authenticated_sender = authenticated_id = NULL ; } else { if ( sender_host_address != NULL ) sender_host_port = check_port ( sender_host_address ) ; if ( interface_address != NULL ) interface_port = check_port ( interface_address ) ; } if ( flag_G ) { if ( trusted_caller ) { suppress_local_fixups = suppress_local_fixups_default = TRUE ; DEBUG ( D_acl ) debug_printf ( ""suppress_local_fixups<S2SV_blank>forced<S2SV_blank>on<S2SV_blank>by<S2SV_blank>-G\\n"" ) ; } else { fprintf ( stderr , ""exim:<S2SV_blank>permission<S2SV_blank>denied<S2SV_blank>(-G<S2SV_blank>requires<S2SV_blank>a<S2SV_blank>trusted<S2SV_blank>user)\\n"" ) ; return EXIT_FAILURE ; } } if ( smtp_input ) { union sockaddr_46 inetd_sock ; EXIM_SOCKLEN_T size = sizeof ( inetd_sock ) ; if ( getpeername ( 0 , ( struct sockaddr * ) ( & inetd_sock ) , & size ) == 0 ) { int family = ( ( struct sockaddr * ) ( & inetd_sock ) ) -> sa_family ; if ( family == AF_INET || family == AF_INET6 ) { union sockaddr_46 interface_sock ; size = sizeof ( interface_sock ) ; if ( getsockname ( 0 , ( struct sockaddr * ) ( & interface_sock ) , & size ) == 0 ) interface_address = host_ntoa ( - 1 , & interface_sock , NULL , & interface_port ) ; if ( host_is_tls_on_connect_port ( interface_port ) ) tls_in . on_connect = TRUE ; if ( real_uid == root_uid || real_uid == exim_uid || interface_port < 1024 ) { is_inetd = TRUE ; sender_host_address = host_ntoa ( - 1 , ( struct sockaddr * ) ( & inetd_sock ) , NULL , & sender_host_port ) ; if ( mua_wrapper ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""Input<S2SV_blank>from<S2SV_blank>"" ""inetd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>when<S2SV_blank>mua_wrapper<S2SV_blank>is<S2SV_blank>set"" ) ; } else { fprintf ( stderr , ""exim:<S2SV_blank>Permission<S2SV_blank>denied<S2SV_blank>(unprivileged<S2SV_blank>user,<S2SV_blank>unprivileged<S2SV_blank>port)\\n"" ) ; return EXIT_FAILURE ; } } } } # ifdef LOAD_AVG_NEEDS_ROOT if ( receiving_message && ( queue_only_load >= 0 || ( is_inetd && smtp_load_reserve >= 0 ) ) ) { load_average = OS_GETLOADAVG ( ) ; } # endif if ( queue_only_set && ( queue_only_override || arg_queue_only ) ) queue_only = arg_queue_only ; if ( arg_receive_timeout >= 0 ) receive_timeout = arg_receive_timeout ; if ( arg_smtp_receive_timeout >= 0 ) smtp_receive_timeout = arg_smtp_receive_timeout ; if ( ! unprivileged && ! removed_privilege && ! daemon_listen && queue_interval <= 0 && ( deliver_drop_privilege || ( queue_interval < 0 && ( msg_action_arg < 0 || msg_action != MSG_DELIVER ) && ( ! checking || ! address_test_mode ) ) ) ) exim_setugid ( exim_uid , exim_gid , TRUE , US ""privilege<S2SV_blank>not<S2SV_blank>needed"" ) ; else { int rv ; rv = setgid ( exim_gid ) ; if ( rv == - 1 ) if ( ! ( unprivileged || removed_privilege ) ) { fprintf ( stderr , ""exim:<S2SV_blank>changing<S2SV_blank>group<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } else DEBUG ( D_any ) debug_printf ( ""changing<S2SV_blank>group<S2SV_blank>to<S2SV_blank>%ld<S2SV_blank>failed:<S2SV_blank>%s\\n"" , ( long int ) exim_gid , strerror ( errno ) ) ; } if ( malware_test_file ) { # ifdef WITH_CONTENT_SCAN int result ; set_process_info ( ""scanning<S2SV_blank>file<S2SV_blank>for<S2SV_blank>malware"" ) ; result = malware_in_file ( malware_test_file ) ; if ( result == FAIL ) { printf ( ""No<S2SV_blank>malware<S2SV_blank>found.\\n"" ) ; exit ( EXIT_SUCCESS ) ; } if ( result != OK ) { printf ( ""Malware<S2SV_blank>lookup<S2SV_blank>returned<S2SV_blank>non-okay/fail:<S2SV_blank>%d\\n"" , result ) ; exit ( EXIT_FAILURE ) ; } if ( malware_name ) printf ( ""Malware<S2SV_blank>found:<S2SV_blank>%s\\n"" , malware_name ) ; else printf ( ""Malware<S2SV_blank>scan<S2SV_blank>detected<S2SV_blank>malware<S2SV_blank>of<S2SV_blank>unknown<S2SV_blank>name.\\n"" ) ; # else printf ( ""Malware<S2SV_blank>scanning<S2SV_blank>not<S2SV_blank>enabled<S2SV_blank>at<S2SV_blank>compile<S2SV_blank>time.\\n"" ) ; # endif exit ( EXIT_FAILURE ) ; } if ( list_queue ) { set_process_info ( ""listing<S2SV_blank>the<S2SV_blank>queue"" ) ; queue_list ( list_queue_option , argv + recipients_arg , argc - recipients_arg ) ; exit ( EXIT_SUCCESS ) ; } if ( count_queue ) { set_process_info ( ""counting<S2SV_blank>the<S2SV_blank>queue"" ) ; queue_count ( ) ; exit ( EXIT_SUCCESS ) ; } if ( msg_action_arg > 0 && msg_action != MSG_DELIVER && msg_action != MSG_LOAD ) { int yield = EXIT_SUCCESS ; set_process_info ( ""acting<S2SV_blank>on<S2SV_blank>specified<S2SV_blank>messages"" ) ; if ( ! one_msg_action ) { for ( i = msg_action_arg ; i < argc ; i ++ ) if ( ! queue_action ( argv [ i ] , msg_action , NULL , 0 , 0 ) ) yield = EXIT_FAILURE ; } else if ( ! queue_action ( argv [ msg_action_arg ] , msg_action , argv , argc , recipients_arg ) ) yield = EXIT_FAILURE ; exit ( yield ) ; } readconf_rest ( ) ; store_pool = POOL_MAIN ; if ( test_retry_arg >= 0 ) { retry_config * yield ; int basic_errno = 0 ; int more_errno = 0 ; uschar * s1 , * s2 ; if ( test_retry_arg >= argc ) { printf ( ""-brt<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>domain<S2SV_blank>or<S2SV_blank>address<S2SV_blank>argument\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } s1 = argv [ test_retry_arg ++ ] ; s2 = NULL ; if ( Ustrchr ( s1 , '@' ) == NULL && Ustrchr ( s1 , '.' ) == NULL ) { printf ( ""Warning:<S2SV_blank>\\""%s\\""<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>\'@\'<S2SV_blank>and<S2SV_blank>no<S2SV_blank>\'.\'<S2SV_blank>characters.<S2SV_blank>It<S2SV_blank>is<S2SV_blank>"" ""being<S2SV_blank>\\ntreated<S2SV_blank>as<S2SV_blank>a<S2SV_blank>one-component<S2SV_blank>domain,<S2SV_blank>not<S2SV_blank>as<S2SV_blank>a<S2SV_blank>local<S2SV_blank>part.\\n\\n"" , s1 ) ; } if ( test_retry_arg < argc && Ustrchr ( argv [ test_retry_arg ] , '.' ) != NULL ) s2 = argv [ test_retry_arg ++ ] ; if ( test_retry_arg < argc ) { uschar * ss = argv [ test_retry_arg ] ; uschar * error = readconf_retry_error ( ss , ss + Ustrlen ( ss ) , & basic_errno , & more_errno ) ; if ( error != NULL ) { printf ( ""%s\\n"" , CS error ) ; return EXIT_FAILURE ; } if ( basic_errno == ERRNO_MAIL4XX || basic_errno == ERRNO_RCPT4XX || basic_errno == ERRNO_DATA4XX ) { int code = ( more_errno >> 8 ) & 255 ; if ( code == 255 ) more_errno = ( more_errno & 0xffff00ff ) | ( 21 << 8 ) ; else if ( code > 100 ) more_errno = ( more_errno & 0xffff00ff ) | ( ( code - 96 ) << 8 ) ; } } yield = retry_find_config ( s1 , s2 , basic_errno , more_errno ) ; if ( yield == NULL ) printf ( ""No<S2SV_blank>retry<S2SV_blank>information<S2SV_blank>found\\n"" ) ; else { retry_rule * r ; more_errno = yield -> more_errno ; printf ( ""Retry<S2SV_blank>rule:<S2SV_blank>%s<S2SV_blank><S2SV_blank>"" , yield -> pattern ) ; if ( yield -> basic_errno == ERRNO_EXIMQUOTA ) { printf ( ""quota%s%s<S2SV_blank><S2SV_blank>"" , ( more_errno > 0 ) ? ""_"" : """" , ( more_errno > 0 ) ? readconf_printtime ( more_errno ) : US """" ) ; } else if ( yield -> basic_errno == ECONNREFUSED ) { printf ( ""refused%s%s<S2SV_blank><S2SV_blank>"" , ( more_errno > 0 ) ? ""_"" : """" , ( more_errno == 'M' ) ? ""MX"" : ( more_errno == 'A' ) ? ""A"" : """" ) ; } else if ( yield -> basic_errno == ETIMEDOUT ) { printf ( ""timeout"" ) ; if ( ( more_errno & RTEF_CTOUT ) != 0 ) printf ( ""_connect"" ) ; more_errno &= 255 ; if ( more_errno != 0 ) printf ( ""_%s"" , ( more_errno == 'M' ) ? ""MX"" : ""A"" ) ; printf ( ""<S2SV_blank><S2SV_blank>"" ) ; } else if ( yield -> basic_errno == ERRNO_AUTHFAIL ) printf ( ""auth_failed<S2SV_blank><S2SV_blank>"" ) ; else printf ( ""*<S2SV_blank><S2SV_blank>"" ) ; for ( r = yield -> rules ; r != NULL ; r = r -> next ) { printf ( ""%c,%s"" , r -> rule , readconf_printtime ( r -> timeout ) ) ; printf ( "",%s"" , readconf_printtime ( r -> p1 ) ) ; if ( r -> rule == 'G' ) { int x = r -> p2 ; int f = x % 1000 ; int d = 100 ; printf ( "",%d."" , x / 1000 ) ; do { printf ( ""%d"" , f / d ) ; f %= d ; d /= 10 ; } while ( f != 0 ) ; } printf ( "";<S2SV_blank>"" ) ; } printf ( ""\\n"" ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( list_options ) { set_process_info ( ""listing<S2SV_blank>variables"" ) ; if ( recipients_arg >= argc ) readconf_print ( US ""all"" , NULL , flag_n ) ; else for ( i = recipients_arg ; i < argc ; i ++ ) { if ( i < argc - 1 && ( Ustrcmp ( argv [ i ] , ""router"" ) == 0 || Ustrcmp ( argv [ i ] , ""transport"" ) == 0 || Ustrcmp ( argv [ i ] , ""authenticator"" ) == 0 || Ustrcmp ( argv [ i ] , ""macro"" ) == 0 || Ustrcmp ( argv [ i ] , ""environment"" ) == 0 ) ) { readconf_print ( argv [ i + 1 ] , argv [ i ] , flag_n ) ; i ++ ; } else readconf_print ( argv [ i ] , NULL , flag_n ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( list_config ) { set_process_info ( ""listing<S2SV_blank>config"" ) ; readconf_print ( US ""config"" , NULL , flag_n ) ; exim_exit ( EXIT_SUCCESS ) ; } # ifndef DISABLE_DKIM dkim_exim_init ( ) ; # endif deliver_init ( ) ; if ( msg_action_arg > 0 && msg_action != MSG_LOAD ) { if ( prod_requires_admin && ! admin_user ) { fprintf ( stderr , ""exim:<S2SV_blank>Permission<S2SV_blank>denied\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } set_process_info ( ""delivering<S2SV_blank>specified<S2SV_blank>messages"" ) ; if ( deliver_give_up ) forced_delivery = deliver_force_thaw = TRUE ; for ( i = msg_action_arg ; i < argc ; i ++ ) { int status ; pid_t pid ; if ( i == argc - 1 ) ( void ) deliver_message ( argv [ i ] , forced_delivery , deliver_give_up ) ; else if ( ( pid = fork ( ) ) == 0 ) { ( void ) deliver_message ( argv [ i ] , forced_delivery , deliver_give_up ) ; _exit ( EXIT_SUCCESS ) ; } else if ( pid < 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>fork<S2SV_blank>delivery<S2SV_blank>process<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s\\n"" , argv [ i ] , strerror ( errno ) ) ; exim_exit ( EXIT_FAILURE ) ; } else wait ( & status ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( queue_interval == 0 && ! daemon_listen ) { DEBUG ( D_queue_run ) debug_printf ( ""Single<S2SV_blank>queue<S2SV_blank>run%s%s%s%s\\n"" , ( start_queue_run_id == NULL ) ? US """" : US ""<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>"" , ( start_queue_run_id == NULL ) ? US """" : start_queue_run_id , ( stop_queue_run_id == NULL ) ? US """" : US ""<S2SV_blank>stopping<S2SV_blank>at<S2SV_blank>"" , ( stop_queue_run_id == NULL ) ? US """" : stop_queue_run_id ) ; if ( * queue_name ) set_process_info ( ""running<S2SV_blank>the<S2SV_blank>\'%s\'<S2SV_blank>queue<S2SV_blank>(single<S2SV_blank>queue<S2SV_blank>run)"" , queue_name ) ; else set_process_info ( ""running<S2SV_blank>the<S2SV_blank>queue<S2SV_blank>(single<S2SV_blank>queue<S2SV_blank>run)"" ) ; queue_run ( start_queue_run_id , stop_queue_run_id , FALSE ) ; exim_exit ( EXIT_SUCCESS ) ; } for ( i = 0 ; ; ) { if ( ( pw = getpwuid ( real_uid ) ) != NULL ) { originator_login = string_copy ( US pw -> pw_name ) ; originator_home = string_copy ( US pw -> pw_dir ) ; if ( originator_name == NULL ) { if ( sender_address == NULL || ( ! trusted_caller && filter_test == FTEST_NONE ) ) { uschar * name = US pw -> pw_gecos ; uschar * amp = Ustrchr ( name , '&' ) ; uschar buffer [ 256 ] ; if ( amp != NULL ) { int loffset ; string_format ( buffer , sizeof ( buffer ) , ""%.*s%n%s%s"" , amp - name , name , & loffset , originator_login , amp + 1 ) ; buffer [ loffset ] = toupper ( buffer [ loffset ] ) ; name = buffer ; } if ( gecos_pattern != NULL && gecos_name != NULL ) { const pcre * re ; re = regex_must_compile ( gecos_pattern , FALSE , TRUE ) ; if ( regex_match_and_setup ( re , name , 0 , - 1 ) ) { uschar * new_name = expand_string ( gecos_name ) ; expand_nmax = - 1 ; if ( new_name != NULL ) { DEBUG ( D_receive ) debug_printf ( ""user<S2SV_blank>name<S2SV_blank>\\""%s\\""<S2SV_blank>extracted<S2SV_blank>from<S2SV_blank>"" ""gecos<S2SV_blank>field<S2SV_blank>\\""%s\\""\\n"" , new_name , name ) ; name = new_name ; } else DEBUG ( D_receive ) debug_printf ( ""failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>gecos_name<S2SV_blank>string<S2SV_blank>"" ""\\""%s\\"":<S2SV_blank>%s\\n"" , gecos_name , expand_string_message ) ; } else DEBUG ( D_receive ) debug_printf ( ""gecos_pattern<S2SV_blank>\\""%s\\""<S2SV_blank>did<S2SV_blank>not<S2SV_blank>match<S2SV_blank>"" ""gecos<S2SV_blank>field<S2SV_blank>\\""%s\\""\\n"" , gecos_pattern , name ) ; store_free ( ( void * ) re ) ; } originator_name = string_copy ( name ) ; } else originator_name = US """" ; } break ; } if ( ++ i > finduser_retries ) break ; sleep ( 1 ) ; } if ( originator_login == NULL || running_in_test_harness ) { if ( unknown_login != NULL ) { originator_login = expand_string ( unknown_login ) ; if ( originator_name == NULL && unknown_username != NULL ) originator_name = expand_string ( unknown_username ) ; if ( originator_name == NULL ) originator_name = US """" ; } if ( originator_login == NULL ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>user<S2SV_blank>name<S2SV_blank>for<S2SV_blank>uid<S2SV_blank>%d"" , ( int ) real_uid ) ; } originator_name = string_copy ( parse_fix_phrase ( originator_name , Ustrlen ( originator_name ) , big_buffer , big_buffer_size ) ) ; originator_uid = real_uid ; originator_gid = real_gid ; DEBUG ( D_receive ) debug_printf ( ""originator:<S2SV_blank>uid=%d<S2SV_blank>gid=%d<S2SV_blank>login=%s<S2SV_blank>name=%s\\n"" , ( int ) originator_uid , ( int ) originator_gid , originator_login , originator_name ) ; if ( daemon_listen || inetd_wait_mode || queue_interval > 0 ) { if ( mua_wrapper ) { fprintf ( stderr , ""Daemon<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>run<S2SV_blank>when<S2SV_blank>mua_wrapper<S2SV_blank>is<S2SV_blank>set\\n"" ) ; log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""Daemon<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>run<S2SV_blank>when<S2SV_blank>"" ""mua_wrapper<S2SV_blank>is<S2SV_blank>set"" ) ; } daemon_go ( ) ; } if ( sender_ident == NULL ) sender_ident = originator_login ; else if ( sender_ident [ 0 ] == 0 ) sender_ident = NULL ; if ( test_rewrite_arg >= 0 ) { really_exim = FALSE ; if ( test_rewrite_arg >= argc ) { printf ( ""-brw<S2SV_blank>needs<S2SV_blank>an<S2SV_blank>address<S2SV_blank>argument\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } rewrite_test ( argv [ test_rewrite_arg ] ) ; exim_exit ( EXIT_SUCCESS ) ; } if ( ( sender_address == NULL && ! smtp_input ) || ( ! trusted_caller && filter_test == FTEST_NONE ) ) { sender_local = TRUE ; if ( authenticated_sender == NULL && ! host_checking ) authenticated_sender = string_sprintf ( ""%s@%s"" , originator_login , qualify_domain_sender ) ; if ( authenticated_id == NULL && ! host_checking ) authenticated_id = originator_login ; } if ( ( ! smtp_input && sender_address == NULL ) || ! receive_check_set_sender ( sender_address ) ) { if ( sender_address == NULL || ( sender_address [ 0 ] != 0 && ! checking ) ) { sender_address = originator_login ; sender_address_forced = FALSE ; sender_address_domain = 0 ; } } sender_set_untrusted = sender_address != originator_login && ! trusted_caller ; if ( sender_address != NULL && sender_address [ 0 ] != 0 && sender_address_domain == 0 ) sender_address = string_sprintf ( ""%s@%s"" , local_part_quote ( sender_address ) , qualify_domain_sender ) ; DEBUG ( D_receive ) debug_printf ( ""sender<S2SV_blank>address<S2SV_blank>=<S2SV_blank>%s\\n"" , sender_address ) ; if ( verify_address_mode || address_test_mode ) { int exit_value = 0 ; int flags = vopt_qualify ; if ( verify_address_mode ) { if ( ! verify_as_sender ) flags |= vopt_is_recipient ; DEBUG ( D_verify ) debug_print_ids ( US ""Verifying:"" ) ; } else { flags |= vopt_is_recipient ; debug_selector |= D_v ; debug_file = stderr ; debug_fd = fileno ( debug_file ) ; DEBUG ( D_verify ) debug_print_ids ( US ""Address<S2SV_blank>testing:"" ) ; } if ( recipients_arg < argc ) { while ( recipients_arg < argc ) { uschar * s = argv [ recipients_arg ++ ] ; while ( * s != 0 ) { BOOL finished = FALSE ; uschar * ss = parse_find_address_end ( s , FALSE ) ; if ( * ss == ',' ) * ss = 0 ; else finished = TRUE ; test_address ( s , flags , & exit_value ) ; s = ss ; if ( ! finished ) while ( * ( ++ s ) != 0 && ( * s == ',' || isspace ( * s ) ) ) ; } } } else for ( ; ; ) { uschar * s = get_stdinput ( NULL , NULL ) ; if ( s == NULL ) break ; test_address ( s , flags , & exit_value ) ; } route_tidyup ( ) ; exim_exit ( exit_value ) ; } if ( expansion_test ) { dns_init ( FALSE , FALSE , FALSE ) ; if ( msg_action_arg > 0 && msg_action == MSG_LOAD ) { uschar spoolname [ 256 ] ; if ( ! admin_user ) { fprintf ( stderr , ""exim:<S2SV_blank>permission<S2SV_blank>denied\\n"" ) ; exit ( EXIT_FAILURE ) ; } message_id = argv [ msg_action_arg ] ; ( void ) string_format ( spoolname , sizeof ( spoolname ) , ""%s-H"" , message_id ) ; if ( ( deliver_datafile = spool_open_datafile ( message_id ) ) < 0 ) printf ( ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>message<S2SV_blank>datafile<S2SV_blank>%s\\n"" , message_id ) ; if ( spool_read_header ( spoolname , TRUE , FALSE ) != spool_read_OK ) printf ( ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>message<S2SV_blank>%s\\n"" , message_id ) ; } else if ( expansion_test_message != NULL ) { int save_stdin = dup ( 0 ) ; int fd = Uopen ( expansion_test_message , O_RDONLY , 0 ) ; if ( fd < 0 ) { fprintf ( stderr , ""exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s\\n"" , expansion_test_message , strerror ( errno ) ) ; return EXIT_FAILURE ; } ( void ) dup2 ( fd , 0 ) ; filter_test = FTEST_USER ; message_ended = END_NOTENDED ; read_message_body ( receive_msg ( extract_recipients ) ) ; message_linecount += body_linecount ; ( void ) dup2 ( save_stdin , 0 ) ; ( void ) close ( save_stdin ) ; clearerr ( stdin ) ; } enable_dollar_recipients = TRUE ; if ( recipients_arg < argc ) { while ( recipients_arg < argc ) { uschar * s = argv [ recipients_arg ++ ] ; uschar * ss = expand_string ( s ) ; if ( ss == NULL ) printf ( ""Failed:<S2SV_blank>%s\\n"" , expand_string_message ) ; else printf ( ""%s\\n"" , CS ss ) ; } } else { char * ( * fn_readline ) ( const char * ) = NULL ; void ( * fn_addhist ) ( const char * ) = NULL ; # ifdef USE_READLINE void * dlhandle = set_readline ( & fn_readline , & fn_addhist ) ; # endif for ( ; ; ) { uschar * ss ; uschar * source = get_stdinput ( fn_readline , fn_addhist ) ; if ( source == NULL ) break ; ss = expand_string ( source ) ; if ( ss == NULL ) printf ( ""Failed:<S2SV_blank>%s\\n"" , expand_string_message ) ; else printf ( ""%s\\n"" , CS ss ) ; } # ifdef USE_READLINE if ( dlhandle != NULL ) dlclose ( dlhandle ) ; # endif } if ( deliver_datafile >= 0 ) { ( void ) close ( deliver_datafile ) ; deliver_datafile = - 1 ; } exim_exit ( EXIT_SUCCESS ) ; } smtp_active_hostname = primary_hostname ; if ( raw_active_hostname != NULL ) { uschar * nah = expand_string ( raw_active_hostname ) ; if ( nah == NULL ) { if ( ! expand_string_forcedfail ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>\\""%s\\""<S2SV_blank>"" ""(smtp_active_hostname):<S2SV_blank>%s"" , raw_active_hostname , expand_string_message ) ; } else if ( nah [ 0 ] != 0 ) smtp_active_hostname = nah ; } if ( host_checking ) { int x [ 4 ] ; int size ; if ( ! sender_ident_set ) { sender_ident = NULL ; if ( running_in_test_harness && sender_host_port != 0 && interface_address != NULL && interface_port != 0 ) verify_get_ident ( 1413 ) ; } size = host_aton ( sender_host_address , x ) ; sender_host_address = store_get ( 48 ) ; ( void ) host_nmtoa ( size , x , - 1 , sender_host_address , ':' ) ; host_build_sender_fullhost ( ) ; smtp_input = TRUE ; smtp_in = stdin ; smtp_out = stdout ; sender_local = FALSE ; sender_host_notsocket = TRUE ; debug_file = stderr ; debug_fd = fileno ( debug_file ) ; fprintf ( stdout , ""\\n****<S2SV_blank>SMTP<S2SV_blank>testing<S2SV_blank>session<S2SV_blank>as<S2SV_blank>if<S2SV_blank>from<S2SV_blank>host<S2SV_blank>%s\\n"" ""****<S2SV_blank>but<S2SV_blank>without<S2SV_blank>any<S2SV_blank>ident<S2SV_blank>(RFC<S2SV_blank>1413)<S2SV_blank>callback.\\n"" ""****<S2SV_blank>This<S2SV_blank>is<S2SV_blank>not<S2SV_blank>for<S2SV_blank>real!\\n\\n"" , sender_host_address ) ; memset ( sender_host_cache , 0 , sizeof ( sender_host_cache ) ) ; if ( verify_check_host ( & hosts_connection_nolog ) == OK ) BIT_CLEAR ( log_selector , log_selector_size , Li_smtp_connection ) ; log_write ( L_smtp_connection , LOG_MAIN , ""%s"" , smtp_get_connection_info ( ) ) ; if ( smtp_start_session ( ) ) { for ( reset_point = store_get ( 0 ) ; ; store_reset ( reset_point ) ) { if ( smtp_setup_msg ( ) <= 0 ) break ; if ( ! receive_msg ( FALSE ) ) break ; return_path = sender_address = NULL ; dnslist_domain = dnslist_matched = NULL ; # ifndef DISABLE_DKIM dkim_cur_signer = NULL ; # endif acl_var_m = NULL ; deliver_localpart_orig = NULL ; deliver_domain_orig = NULL ; callout_address = sending_ip_address = NULL ; sender_rate = sender_rate_limit = sender_rate_period = NULL ; } smtp_log_no_mail ( ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( recipients_arg >= argc && ! extract_recipients && ! smtp_input ) { if ( version_printed ) { printf ( ""Configuration<S2SV_blank>file<S2SV_blank>is<S2SV_blank>%s\\n"" , config_main_filename ) ; return EXIT_SUCCESS ; } if ( info_flag != CMDINFO_NONE ) { show_exim_information ( info_flag , info_stdout ? stdout : stderr ) ; return info_stdout ? EXIT_SUCCESS : EXIT_FAILURE ; } if ( filter_test == FTEST_NONE ) exim_usage ( called_as ) ; } if ( mua_wrapper ) { synchronous_delivery = TRUE ; arg_error_handling = ERRORS_STDERR ; remote_max_parallel = 1 ; deliver_drop_privilege = TRUE ; queue_smtp = FALSE ; queue_smtp_domains = NULL ; # ifdef SUPPORT_I18N message_utf8_downconvert = - 1 ; # endif } if ( ! smtp_input ) error_handling = arg_error_handling ; else if ( is_inetd ) { ( void ) fclose ( stderr ) ; exim_nullstd ( ) ; verify_get_ident ( IDENT_PORT ) ; host_build_sender_fullhost ( ) ; set_process_info ( ""handling<S2SV_blank>incoming<S2SV_blank>connection<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>inetd"" , sender_fullhost ) ; } if ( sender_host_address != NULL && sender_fullhost == NULL ) { host_build_sender_fullhost ( ) ; set_process_info ( ""handling<S2SV_blank>incoming<S2SV_blank>connection<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>-oMa"" , sender_fullhost ) ; sender_host_notsocket = TRUE ; } else if ( ! is_inetd ) sender_host_unknown = TRUE ; if ( fstat ( 1 , & statbuf ) < 0 ) ( void ) dup2 ( 0 , 1 ) ; if ( smtp_input ) { if ( ! is_inetd ) set_process_info ( ""accepting<S2SV_blank>a<S2SV_blank>local<S2SV_blank>%sSMTP<S2SV_blank>message<S2SV_blank>from<S2SV_blank><%s>"" , smtp_batched_input ? ""batched<S2SV_blank>"" : """" , ( sender_address != NULL ) ? sender_address : originator_login ) ; } else { int old_pool = store_pool ; store_pool = POOL_PERM ; if ( ! received_protocol ) received_protocol = string_sprintf ( ""local%s"" , called_as ) ; store_pool = old_pool ; set_process_info ( ""accepting<S2SV_blank>a<S2SV_blank>local<S2SV_blank>non-SMTP<S2SV_blank>message<S2SV_blank>from<S2SV_blank><%s>"" , sender_address ) ; } queue_check_only ( ) ; session_local_queue_only = queue_only ; if ( ( ! smtp_input || smtp_batched_input ) && ! receive_check_fs ( 0 ) ) { fprintf ( stderr , ""exim:<S2SV_blank>insufficient<S2SV_blank>disk<S2SV_blank>space\\n"" ) ; return EXIT_FAILURE ; } if ( smtp_input ) { smtp_in = stdin ; smtp_out = stdout ; memset ( sender_host_cache , 0 , sizeof ( sender_host_cache ) ) ; if ( verify_check_host ( & hosts_connection_nolog ) == OK ) BIT_CLEAR ( log_selector , log_selector_size , Li_smtp_connection ) ; log_write ( L_smtp_connection , LOG_MAIN , ""%s"" , smtp_get_connection_info ( ) ) ; if ( ! smtp_start_session ( ) ) { mac_smtp_fflush ( ) ; exim_exit ( EXIT_SUCCESS ) ; } } else { thismessage_size_limit = expand_string_integer ( message_size_limit , TRUE ) ; if ( expand_string_message ) if ( thismessage_size_limit == - 1 ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>"" ""message_size_limit:<S2SV_blank>%s"" , expand_string_message ) ; else log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , ""invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>"" ""message_size_limit:<S2SV_blank>%s"" , expand_string_message ) ; } if ( ! synchronous_delivery ) { # ifdef SA_NOCLDWAIT struct sigaction act ; act . sa_handler = SIG_IGN ; sigemptyset ( & ( act . sa_mask ) ) ; act . sa_flags = SA_NOCLDWAIT ; sigaction ( SIGCHLD , & act , NULL ) ; # else signal ( SIGCHLD , SIG_IGN ) ; # endif } reset_point = store_get ( 0 ) ; real_sender_address = sender_address ; while ( more ) { message_id [ 0 ] = 0 ; if ( smtp_input ) { int rc ; if ( ( rc = smtp_setup_msg ( ) ) > 0 ) { if ( real_sender_address != NULL && ! receive_check_set_sender ( sender_address ) ) { sender_address = raw_sender = real_sender_address ; sender_address_unrewritten = NULL ; } if ( smtp_batched_input && acl_not_smtp_start != NULL ) { uschar * user_msg , * log_msg ; enable_dollar_recipients = TRUE ; ( void ) acl_check ( ACL_WHERE_NOTSMTP_START , NULL , acl_not_smtp_start , & user_msg , & log_msg ) ; enable_dollar_recipients = FALSE ; } more = receive_msg ( extract_recipients ) ; if ( message_id [ 0 ] == 0 ) { cancel_cutthrough_connection ( TRUE , US ""receive<S2SV_blank>dropped"" ) ; if ( more ) goto moreloop ; smtp_log_no_mail ( ) ; exim_exit ( EXIT_FAILURE ) ; } } else { cancel_cutthrough_connection ( TRUE , US ""message<S2SV_blank>setup<S2SV_blank>dropped"" ) ; smtp_log_no_mail ( ) ; exim_exit ( ( rc == 0 ) ? EXIT_SUCCESS : EXIT_FAILURE ) ; } } else { int i ; int rcount = 0 ; int count = argc - recipients_arg ; uschar * * list = argv + recipients_arg ; active_local_sender_retain = local_sender_retain ; active_local_from_check = local_from_check ; raw_sender = string_copy ( sender_address ) ; for ( i = 0 ; i < count ; i ++ ) { int start , end , domain ; uschar * errmess ; uschar * s = list [ i ] ; while ( * s != 0 ) { BOOL finished = FALSE ; uschar * recipient ; uschar * ss = parse_find_address_end ( s , FALSE ) ; if ( * ss == ',' ) * ss = 0 ; else finished = TRUE ; if ( recipients_max > 0 && ++ rcount > recipients_max && ! extract_recipients ) if ( error_handling == ERRORS_STDERR ) { fprintf ( stderr , ""exim:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>recipients\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } else { return moan_to_sender ( ERRMESS_TOOMANYRECIP , NULL , NULL , stdin , TRUE ) ? errors_sender_rc : EXIT_FAILURE ; } # ifdef SUPPORT_I18N { BOOL b = allow_utf8_domains ; allow_utf8_domains = TRUE ; # endif recipient = parse_extract_address ( s , & errmess , & start , & end , & domain , FALSE ) ; # ifdef SUPPORT_I18N if ( string_is_utf8 ( recipient ) ) message_smtputf8 = TRUE ; else allow_utf8_domains = b ; } # endif if ( domain == 0 && ! allow_unqualified_recipient ) { recipient = NULL ; errmess = US ""unqualified<S2SV_blank>recipient<S2SV_blank>address<S2SV_blank>not<S2SV_blank>allowed"" ; } if ( recipient == NULL ) { if ( error_handling == ERRORS_STDERR ) { fprintf ( stderr , ""exim:<S2SV_blank>bad<S2SV_blank>recipient<S2SV_blank>address<S2SV_blank>\\""%s\\"":<S2SV_blank>%s\\n"" , string_printing ( list [ i ] ) , errmess ) ; exim_exit ( EXIT_FAILURE ) ; } else { error_block eblock ; eblock . next = NULL ; eblock . text1 = string_printing ( list [ i ] ) ; eblock . text2 = errmess ; return moan_to_sender ( ERRMESS_BADARGADDRESS , & eblock , NULL , stdin , TRUE ) ? errors_sender_rc : EXIT_FAILURE ; } } receive_add_recipient ( recipient , - 1 ) ; s = ss ; if ( ! finished ) while ( * ( ++ s ) != 0 && ( * s == ',' || isspace ( * s ) ) ) ; } } DEBUG ( D_receive ) { int i ; if ( sender_address != NULL ) debug_printf ( ""Sender:<S2SV_blank>%s\\n"" , sender_address ) ; if ( recipients_list != NULL ) { debug_printf ( ""Recipients:\\n"" ) ; for ( i = 0 ; i < recipients_count ; i ++ ) debug_printf ( ""<S2SV_blank><S2SV_blank>%s\\n"" , recipients_list [ i ] . address ) ; } } if ( acl_not_smtp_start ) { uschar * user_msg , * log_msg ; enable_dollar_recipients = TRUE ; ( void ) acl_check ( ACL_WHERE_NOTSMTP_START , NULL , acl_not_smtp_start , & user_msg , & log_msg ) ; enable_dollar_recipients = FALSE ; } if ( ! receive_timeout ) { struct timeval t = { 30 * 60 , 0 } ; fd_set r ; FD_ZERO ( & r ) ; FD_SET ( 0 , & r ) ; if ( select ( 1 , & r , NULL , NULL , & t ) == 0 ) mainlog_close ( ) ; } message_ended = END_NOTENDED ; more = receive_msg ( extract_recipients ) ; if ( message_id [ 0 ] == 0 ) exim_exit ( EXIT_FAILURE ) ; } if ( filter_test != FTEST_NONE ) { deliver_domain = ( ftest_domain != NULL ) ? ftest_domain : qualify_domain_recipient ; deliver_domain_orig = deliver_domain ; deliver_localpart = ( ftest_localpart != NULL ) ? ftest_localpart : originator_login ; deliver_localpart_orig = deliver_localpart ; deliver_localpart_prefix = ftest_prefix ; deliver_localpart_suffix = ftest_suffix ; deliver_home = originator_home ; if ( return_path == NULL ) { printf ( ""Return-path<S2SV_blank>copied<S2SV_blank>from<S2SV_blank>sender\\n"" ) ; return_path = string_copy ( sender_address ) ; } else printf ( ""Return-path<S2SV_blank>=<S2SV_blank>%s\\n"" , ( return_path [ 0 ] == 0 ) ? US ""<>"" : return_path ) ; printf ( ""Sender<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n"" , ( sender_address [ 0 ] == 0 ) ? US ""<>"" : sender_address ) ; receive_add_recipient ( string_sprintf ( ""%s%s%s@%s"" , ( ftest_prefix == NULL ) ? US """" : ftest_prefix , deliver_localpart , ( ftest_suffix == NULL ) ? US """" : ftest_suffix , deliver_domain ) , - 1 ) ; printf ( ""Recipient<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n"" , recipients_list [ 0 ] . address ) ; if ( ftest_prefix != NULL ) printf ( ""Prefix<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n"" , ftest_prefix ) ; if ( ftest_suffix != NULL ) printf ( ""Suffix<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n"" , ftest_suffix ) ; if ( chdir ( ""/"" ) ) { DEBUG ( D_receive ) debug_printf ( ""chdir(\\""/\\"")<S2SV_blank>failed\\n"" ) ; exim_exit ( EXIT_FAILURE ) ; } if ( ( filter_test & FTEST_SYSTEM ) != 0 ) { if ( ! filter_runtest ( filter_sfd , filter_test_sfile , TRUE , more ) ) exim_exit ( EXIT_FAILURE ) ; } memcpy ( filter_sn , filter_n , sizeof ( filter_sn ) ) ; if ( ( filter_test & FTEST_USER ) != 0 ) { if ( ! filter_runtest ( filter_ufd , filter_test_ufile , FALSE , more ) ) exim_exit ( EXIT_FAILURE ) ; } exim_exit ( EXIT_SUCCESS ) ; } if ( ! session_local_queue_only && smtp_accept_queue_per_connection > 0 && receive_messagecount > smtp_accept_queue_per_connection ) { session_local_queue_only = TRUE ; queue_only_reason = 2 ; } local_queue_only = session_local_queue_only ; if ( ! local_queue_only && queue_only_load >= 0 ) { local_queue_only = ( load_average = OS_GETLOADAVG ( ) ) > queue_only_load ; if ( local_queue_only ) { queue_only_reason = 3 ; if ( queue_only_load_latch ) session_local_queue_only = TRUE ; } } if ( mua_wrapper ) local_queue_only = queue_only_policy = deliver_freeze = FALSE ; if ( local_queue_only ) { cancel_cutthrough_connection ( TRUE , US ""no<S2SV_blank>delivery;<S2SV_blank>queueing"" ) ; switch ( queue_only_reason ) { case 2 : log_write ( L_delay_delivery , LOG_MAIN , ""no<S2SV_blank>immediate<S2SV_blank>delivery:<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d<S2SV_blank>messages<S2SV_blank>"" ""received<S2SV_blank>in<S2SV_blank>one<S2SV_blank>connection"" , smtp_accept_queue_per_connection ) ; break ; case 3 : log_write ( L_delay_delivery , LOG_MAIN , ""no<S2SV_blank>immediate<S2SV_blank>delivery:<S2SV_blank>load<S2SV_blank>average<S2SV_blank>%.2f"" , ( double ) load_average / 1000.0 ) ; break ; } } else if ( queue_only_policy || deliver_freeze ) cancel_cutthrough_connection ( TRUE , US ""no<S2SV_blank>delivery;<S2SV_blank>queueing"" ) ; else { pid_t pid ; search_tidyup ( ) ; if ( ( pid = fork ( ) ) == 0 ) { int rc ; close_unwanted ( ) ; exim_nullstd ( ) ; if ( geteuid ( ) != root_uid && ! deliver_drop_privilege && ! unprivileged ) { delivery_re_exec ( CEE_EXEC_EXIT ) ; } rc = deliver_message ( message_id , FALSE , FALSE ) ; search_tidyup ( ) ; _exit ( ( ! mua_wrapper || rc == DELIVER_MUA_SUCCEEDED ) ? EXIT_SUCCESS : EXIT_FAILURE ) ; } if ( pid < 0 ) { cancel_cutthrough_connection ( TRUE , US ""delivery<S2SV_blank>fork<S2SV_blank>failed"" ) ; log_write ( 0 , LOG_MAIN | LOG_PANIC , ""failed<S2SV_blank>to<S2SV_blank>fork<S2SV_blank>automatic<S2SV_blank>delivery<S2SV_blank>"" ""process:<S2SV_blank>%s"" , strerror ( errno ) ) ; } else { release_cutthrough_connection ( US ""msg<S2SV_blank>passed<S2SV_blank>for<S2SV_blank>delivery"" ) ; if ( synchronous_delivery ) { int status ; while ( wait ( & status ) != pid ) ; if ( ( status & 0x00ff ) != 0 ) log_write ( 0 , LOG_MAIN | LOG_PANIC , ""process<S2SV_blank>%d<S2SV_blank>crashed<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d<S2SV_blank>while<S2SV_blank>delivering<S2SV_blank>%s"" , ( int ) pid , status & 0x00ff , message_id ) ; if ( mua_wrapper && ( status & 0xffff ) != 0 ) exim_exit ( EXIT_FAILURE ) ; } } } # ifndef SIG_IGN_WORKS while ( waitpid ( - 1 , NULL , WNOHANG ) > 0 ) ; # endif moreloop : return_path = sender_address = NULL ; authenticated_sender = NULL ; deliver_localpart_orig = NULL ; deliver_domain_orig = NULL ; deliver_host = deliver_host_address = NULL ; dnslist_domain = dnslist_matched = NULL ; # ifdef WITH_CONTENT_SCAN malware_name = NULL ; # endif callout_address = NULL ; sending_ip_address = NULL ; acl_var_m = NULL ; { int i ; for ( i = 0 ; i < REGEX_VARS ; i ++ ) regex_vars [ i ] = NULL ; } store_reset ( reset_point ) ; } exim_exit ( EXIT_SUCCESS ) ; return 0 ; }
","<S2SV_ModStart> == 0 ) if ( received_protocol ) { fprintf ( stderr , ""received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\n"" ) ; exit ( EXIT_FAILURE ) ; } else <S2SV_ModStart> { uschar * hn ; if ( received_protocol ) { fprintf ( stderr , ""received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\n"" ) ; exit ( EXIT_FAILURE ) ; }
"
351,"CWE-000 long do_rt_tgsigqueueinfo ( pid_t tgid , pid_t pid , int sig , siginfo_t * info ) { if ( pid <= 0 || tgid <= 0 ) return - EINVAL ; <S2SV_StartBug> if ( info -> si_code >= 0 ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug> info -> si_signo = sig ; return do_send_specific ( tgid , pid , sig , info ) ; }
","<S2SV_ModStart> info -> si_code != SI_QUEUE ) { WARN_ON_ONCE ( info -> si_code < 0 ) ; <S2SV_ModEnd> return - EPERM <S2SV_ModStart> - EPERM ; }
"
352,"CWE-119 static void parse_content_range ( URLContext * h , const char * p ) { HTTPContext * s = h -> priv_data ; const char * slash ; if ( ! strncmp ( p , ""bytes<S2SV_blank>"" , 6 ) ) { p += 6 ; <S2SV_StartBug> s -> off = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> if ( ( slash = strchr ( p , '/' ) ) && strlen ( slash ) > 0 ) <S2SV_StartBug> s -> filesize = strtoll ( slash + 1 , NULL , 10 ) ; <S2SV_EndBug> } if ( s -> seekable == - 1 && ( ! s -> is_akamai || s -> filesize != 2147483647 ) ) h -> is_streamed = 0 ; }
","<S2SV_ModStart> -> off = strtoull <S2SV_ModEnd> ( p , <S2SV_ModStart> -> filesize = strtoull <S2SV_ModEnd> ( slash +
"
353,"CWE-125 static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; <S2SV_StartBug> unsigned int maxw , maxh , max ; <S2SV_EndBug> int offset , upb ; <S2SV_StartBug> unsigned int i , j ; <S2SV_EndBug> upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> if ( r == NULL || g == NULL || b == NULL ) goto fails ; <S2SV_StartBug> for ( i = 0U ; i < maxh ; ++ i ) <S2SV_EndBug> { <S2SV_StartBug> for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } <S2SV_StartBug> if ( j < maxw ) { <S2SV_EndBug> sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; <S2SV_StartBug> # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; <S2SV_EndBug> # else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_StartBug> img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_StartBug> img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_EndBug> return ; fails : <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> <S2SV_StartBug> if ( g ) free ( g ) ; <S2SV_EndBug> <S2SV_StartBug> if ( b ) free ( b ) ; <S2SV_EndBug> }
","<S2SV_ModStart> * cr ; size_t <S2SV_ModEnd> maxw , maxh <S2SV_ModStart> maxh , max , offx , loopmaxw <S2SV_ModStart> , upb ; size_t i <S2SV_ModEnd> ; upb = <S2SV_ModStart> maxw = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> maxh = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> goto fails ; offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; <S2SV_ModStart> i ) { size_t j ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } <S2SV_ModStart> j < ( loopmaxw <S2SV_ModEnd> & ~ ( <S2SV_ModStart> & ~ ( size_t <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> ( j < loopmaxw <S2SV_ModEnd> ) { sycc_to_rgb <S2SV_ModStart> = d2 ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . h = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . <S2SV_ModEnd> dy = img <S2SV_ModStart> ; img -> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> ; return ; <S2SV_ModStart> ; fails : <S2SV_ModEnd> free ( r <S2SV_ModStart> r ) ; <S2SV_ModEnd> free ( g <S2SV_ModStart> g ) ; <S2SV_ModEnd> free ( b
"
354,"CWE-000 void <S2SV_StartBug> nfs4_state_set_mode_locked ( struct nfs4_state * state , mode_t mode ) <S2SV_EndBug> { <S2SV_StartBug> if ( state -> state == mode ) <S2SV_EndBug> return ; <S2SV_StartBug> if ( ( mode & FMODE_WRITE ) != ( state -> state & FMODE_WRITE ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( mode & FMODE_WRITE ) <S2SV_EndBug> list_move ( & state -> open_states , & state -> owner -> so_states ) ; else list_move_tail ( & state -> open_states , & state -> owner -> so_states ) ; } <S2SV_StartBug> state -> state = mode ; <S2SV_EndBug> }
","<S2SV_ModStart> * state , fmode_t fmode <S2SV_ModEnd> ) { if <S2SV_ModStart> -> state == fmode <S2SV_ModEnd> ) return ; <S2SV_ModStart> if ( ( fmode <S2SV_ModEnd> & FMODE_WRITE ) <S2SV_ModStart> { if ( fmode <S2SV_ModEnd> & FMODE_WRITE ) <S2SV_ModStart> -> state = fmode <S2SV_ModEnd> ; } <S2SV_null>
"
355,"CWE-399 int kex_input_kexinit ( int type , u_int32_t seq , void * ctxt ) { struct ssh * ssh = ctxt ; struct kex * kex = ssh -> kex ; const u_char * ptr ; u_int i ; size_t dlen ; int r ; debug ( ""SSH2_MSG_KEXINIT<S2SV_blank>received"" ) ; if ( kex == NULL ) return SSH_ERR_INVALID_ARGUMENT ; <S2SV_StartBug> ptr = sshpkt_ptr ( ssh , & dlen ) ; <S2SV_EndBug> if ( ( r = sshbuf_put ( kex -> peer , ptr , dlen ) ) != 0 ) return r ; for ( i = 0 ; i < KEX_COOKIE_LEN ; i ++ ) if ( ( r = sshpkt_get_u8 ( ssh , NULL ) ) != 0 ) return r ; for ( i = 0 ; i < PROPOSAL_MAX ; i ++ ) if ( ( r = sshpkt_get_string ( ssh , NULL , NULL ) ) != 0 ) return r ; if ( ( r = sshpkt_get_u8 ( ssh , NULL ) ) != 0 || ( r = sshpkt_get_u32 ( ssh , NULL ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) return r ; if ( ! ( kex -> flags & KEX_INIT_SENT ) ) if ( ( r = kex_send_kexinit ( ssh ) ) != 0 ) return r ; if ( ( r = kex_choose_conf ( ssh ) ) != 0 ) return r ; if ( kex -> kex_type < KEX_MAX && kex -> kex [ kex -> kex_type ] != NULL ) return ( kex -> kex [ kex -> kex_type ] ) ( ssh ) ; return SSH_ERR_INTERNAL_ERROR ; }
","<S2SV_ModStart> return SSH_ERR_INVALID_ARGUMENT ; ssh_dispatch_set ( ssh , SSH2_MSG_KEXINIT , NULL ) ;
"
356,"CWE-119 static void test_modules ( ) { assert_true_rule ( <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\""baz\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""foo\\""]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""bar\\""]<S2SV_blank>==<S2SV_blank>\\""bar\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\""dummy\\"")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_false_rule ( <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> NULL ) ; assert_false_rule ( <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> NULL ) ; assert_false_rule ( <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""foo\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""bar\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_error ( ""import<S2SV_blank>\\""\\\\x00\\"""" , ERROR_INVALID_MODULE_NAME ) ; assert_error ( ""import<S2SV_blank>\\""\\"""" , ERROR_INVALID_MODULE_NAME ) ; }
","<S2SV_ModStart> { assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[256]<S2SV_blank>==<S2SV_blank>256<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\""baz\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""foo\\""]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""bar\\""]<S2SV_blank>==<S2SV_blank>\\""bar\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\""dummy\\"")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""foo\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""bar\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> , NULL )
"
357,"CWE-416 static Image * ReadPWPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { FILE * file ; Image * image , * next_image , * pwp_image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register Image * p ; register ssize_t i ; size_t filesize , length ; ssize_t count ; unsigned char magick [ MaxTextExtent ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; pwp_image = AcquireImage ( image_info ) ; image = pwp_image ; status = OpenBlob ( image_info , pwp_image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( ( Image * ) NULL ) ; count = ReadBlob ( pwp_image , 5 , magick ) ; if ( ( count != 5 ) || ( LocaleNCompare ( ( char * ) magick , ""SFW95"" , 5 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; read_info = CloneImageInfo ( image_info ) ; ( void ) SetImageInfoProgressMonitor ( read_info , ( MagickProgressMonitor ) NULL , ( void * ) NULL ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; unique_file = AcquireUniqueFileResource ( read_info -> filename ) ; for ( ; ; ) { for ( c = ReadBlobByte ( pwp_image ) ; c != EOF ; c = ReadBlobByte ( pwp_image ) ) { for ( i = 0 ; i < 17 ; i ++ ) magick [ i ] = magick [ i + 1 ] ; magick [ 17 ] = ( unsigned char ) c ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) == 0 ) break ; } if ( c == EOF ) break ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) != 0 ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToWriteFile"" , image -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = fwrite ( ""SFW94A"" , 1 , 6 , file ) ; ( void ) length ; filesize = 65535UL * magick [ 2 ] + 256L * magick [ 1 ] + magick [ 0 ] ; for ( i = 0 ; i < ( ssize_t ) filesize ; i ++ ) { c = ReadBlobByte ( pwp_image ) ; ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; next_image = ReadImage ( read_info , exception ) ; if ( next_image == ( Image * ) NULL ) break ; ( void ) FormatLocaleString ( next_image -> filename , MaxTextExtent , ""slide_%02ld.sfw"" , ( long ) next_image -> scene ) ; if ( image == ( Image * ) NULL ) image = next_image ; else { for ( p = image ; p -> next != ( Image * ) NULL ; p = GetNextImageInList ( p ) ) ; next_image -> previous = p ; next_image -> scene = p -> scene + 1 ; p -> next = next_image ; } if ( image_info -> number_scenes != 0 ) if ( next_image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( pwp_image ) , GetBlobSize ( pwp_image ) ) ; if ( status == MagickFalse ) break ; } if ( unique_file != - 1 ) ( void ) close ( unique_file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; <S2SV_StartBug> ( void ) CloseBlob ( pwp_image ) ; <S2SV_EndBug> pwp_image = DestroyImage ( pwp_image ) ; if ( EOFBlob ( image ) != MagickFalse ) { char * message ; message = GetExceptionMessage ( errno ) ; ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""UnexpectedEndOfFile"" , ""`%s\':<S2SV_blank>%s"" , image -> filename , message ) ; message = DestroyString ( message ) ; } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> read_info ) ; <S2SV_ModEnd> if ( EOFBlob
"
358,"CWE-119 int main ( int argc , char * * argv ) { test_cmp_parameters inParam ; FILE * fbase = NULL , * ftest = NULL ; int same = 0 ; <S2SV_StartBug> char lbase [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char strbase [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char ltest [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char strtest [ 256 ] ; <S2SV_EndBug> if ( parse_cmdline_cmp ( argc , argv , & inParam ) == 1 ) { compare_dump_files_help_display ( ) ; goto cleanup ; } printf ( ""******Parameters*********<S2SV_blank>\\n"" ) ; printf ( ""<S2SV_blank>base_filename<S2SV_blank>=<S2SV_blank>%s\\n"" ""<S2SV_blank>test_filename<S2SV_blank>=<S2SV_blank>%s\\n"" , inParam . base_filename , inParam . test_filename ) ; printf ( ""*************************<S2SV_blank>\\n"" ) ; printf ( ""Try<S2SV_blank>to<S2SV_blank>open:<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading<S2SV_blank>...<S2SV_blank>"" , inParam . base_filename ) ; if ( ( fbase = fopen ( inParam . base_filename , ""rb"" ) ) == NULL ) { goto cleanup ; } printf ( ""Ok.\\n"" ) ; printf ( ""Try<S2SV_blank>to<S2SV_blank>open:<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading<S2SV_blank>...<S2SV_blank>"" , inParam . test_filename ) ; if ( ( ftest = fopen ( inParam . test_filename , ""rb"" ) ) == NULL ) { goto cleanup ; } printf ( ""Ok.\\n"" ) ; while ( fgets ( lbase , sizeof ( lbase ) , fbase ) && fgets ( ltest , sizeof ( ltest ) , ftest ) ) { <S2SV_StartBug> int nbase = sscanf ( lbase , ""%255[^\\r\\n]"" , strbase ) ; <S2SV_EndBug> <S2SV_StartBug> int ntest = sscanf ( ltest , ""%255[^\\r\\n]"" , strtest ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( nbase != 255 && ntest != 255 ) ; <S2SV_EndBug> if ( nbase != 1 || ntest != 1 ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>line<S2SV_blank>from<S2SV_blank>files\\n"" ) ; goto cleanup ; } if ( strcmp ( strbase , strtest ) != 0 ) { fprintf ( stderr , ""<%s><S2SV_blank>vs.<S2SV_blank><%s>\\n"" , strbase , strtest ) ; goto cleanup ; } } same = 1 ; printf ( ""\\n*****<S2SV_blank>TEST<S2SV_blank>SUCCEED:<S2SV_blank>Files<S2SV_blank>are<S2SV_blank>the<S2SV_blank>same.<S2SV_blank>*****\\n"" ) ; cleanup : if ( fbase ) fclose ( fbase ) ; if ( ftest ) fclose ( ftest ) ; free ( inParam . base_filename ) ; free ( inParam . test_filename ) ; return same ? EXIT_SUCCESS : EXIT_FAILURE ; }
","<S2SV_ModStart> char lbase [ 512 <S2SV_ModEnd> ] ; char <S2SV_ModStart> char strbase [ 512 <S2SV_ModEnd> ] ; char <S2SV_ModStart> char ltest [ 512 <S2SV_ModEnd> ] ; char <S2SV_ModStart> char strtest [ 512 <S2SV_ModEnd> ] ; if <S2SV_ModStart> ( lbase , ""%511[^\\r\\n]"" <S2SV_ModEnd> , strbase ) <S2SV_ModStart> ( ltest , ""%511[^\\r\\n]"" <S2SV_ModEnd> , strtest ) <S2SV_ModStart> ( nbase != 511 <S2SV_ModEnd> && ntest != <S2SV_ModStart> && ntest != 511 <S2SV_ModEnd> ) ; if
"
359,"CWE-000 static int cdc_ncm_bind ( struct usbnet * dev , struct usb_interface * intf ) { <S2SV_StartBug> int ret ; <S2SV_EndBug> if ( cdc_ncm_select_altsetting ( intf ) != CDC_NCM_COMM_ALTSETTING_NCM ) return - ENODEV ; <S2SV_StartBug> ret = cdc_ncm_bind_common ( dev , intf , CDC_NCM_DATA_ALTSETTING_NCM , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> usbnet_link_change ( dev , 0 , 0 ) ; <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> intf ) { <S2SV_ModEnd> if ( cdc_ncm_select_altsetting <S2SV_ModStart> - ENODEV ; return <S2SV_ModEnd> cdc_ncm_bind_common ( dev <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
360,"CWE-120 static size_t send_control_msg ( VirtIOSerial * vser , void * buf , size_t len ) { VirtQueueElement elem ; VirtQueue * vq ; vq = vser -> c_ivq ; if ( ! virtio_queue_ready ( vq ) ) { return 0 ; } if ( ! virtqueue_pop ( vq , & elem ) ) { return 0 ; } <S2SV_StartBug> memcpy ( elem . in_sg [ 0 ] . iov_base , buf , len ) ; <S2SV_EndBug> virtqueue_push ( vq , & elem , len ) ; virtio_notify ( VIRTIO_DEVICE ( vser ) , vq ) ; return len ; }
","<S2SV_ModStart> 0 ; } iov_from_buf <S2SV_ModEnd> ( elem . <S2SV_ModStart> elem . in_sg , elem . in_num , 0 <S2SV_ModEnd> , buf ,
"
361,"CWE-000 static int jpc_qcd_dumpparms ( jpc_ms_t * ms , FILE * out ) { jpc_qcd_t * qcd = & ms -> parms . qcd ; int i ; fprintf ( out , ""qntsty<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numguard<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numstepsizes<S2SV_blank>=<S2SV_blank>%d\\n"" , ( int ) qcd -> compparms . qntsty , qcd -> compparms . numguard , qcd -> compparms . numstepsizes ) ; for ( i = 0 ; i < qcd -> compparms . numstepsizes ; ++ i ) { fprintf ( out , ""expn[%d]<S2SV_blank>=<S2SV_blank>0x%04x;<S2SV_blank>mant[%d]<S2SV_blank>=<S2SV_blank>0x%04x;\\n"" , <S2SV_StartBug> i , ( unsigned ) JPC_QCX_GETEXPN ( qcd -> compparms . stepsizes [ i ] ) , <S2SV_EndBug> <S2SV_StartBug> i , ( unsigned ) JPC_QCX_GETMANT ( qcd -> compparms . stepsizes [ i ] ) ) ; <S2SV_EndBug> } return 0 ; }
","<S2SV_ModStart> , i , JAS_CAST ( unsigned , <S2SV_ModEnd> JPC_QCX_GETEXPN ( qcd <S2SV_ModStart> i ] ) ) <S2SV_ModStart> , i , JAS_CAST ( unsigned , <S2SV_ModEnd> JPC_QCX_GETMANT ( qcd <S2SV_ModStart> ] ) ) )
"
362,"CWE-264 static int check_entry_size_and_hooks ( struct ip6t_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ip6t_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } if ( ! ip6_checkentry ( & e -> ipv6 ) ) return - EINVAL ; <S2SV_StartBug> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <S2SV_EndBug> if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_debug ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
","<S2SV_ModStart> , e -> elems , e ->
"
363,"CWE-119 static int cdxl_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) { CDXLVideoContext * c = avctx -> priv_data ; AVFrame * const p = data ; int ret , w , h , encoding , aligned_width , buf_size = pkt -> size ; const uint8_t * buf = pkt -> data ; if ( buf_size < 32 ) return AVERROR_INVALIDDATA ; encoding = buf [ 1 ] & 7 ; c -> format = buf [ 1 ] & 0xE0 ; w = AV_RB16 ( & buf [ 14 ] ) ; h = AV_RB16 ( & buf [ 16 ] ) ; c -> bpp = buf [ 19 ] ; c -> palette_size = AV_RB16 ( & buf [ 20 ] ) ; c -> palette = buf + 32 ; c -> video = c -> palette + c -> palette_size ; c -> video_size = buf_size - c -> palette_size - 32 ; if ( c -> palette_size > 512 ) return AVERROR_INVALIDDATA ; if ( buf_size < c -> palette_size + 32 ) return AVERROR_INVALIDDATA ; if ( c -> bpp < 1 ) return AVERROR_INVALIDDATA ; if ( c -> format != BIT_PLANAR && c -> format != BIT_LINE && c -> format != CHUNKY ) { avpriv_request_sample ( avctx , ""Pixel<S2SV_blank>format<S2SV_blank>0x%0x"" , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_set_dimensions ( avctx , w , h ) ) < 0 ) return ret ; if ( c -> format == CHUNKY ) aligned_width = avctx -> width ; else aligned_width = FFALIGN ( c -> avctx -> width , 16 ) ; c -> padded_bits = aligned_width - c -> avctx -> width ; if ( c -> video_size < aligned_width * avctx -> height * ( int64_t ) c -> bpp / 8 ) return AVERROR_INVALIDDATA ; if ( ! encoding && c -> palette_size && c -> bpp <= 8 && c -> format != CHUNKY ) { avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; <S2SV_StartBug> } else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) { <S2SV_EndBug> if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ; avctx -> pix_fmt = AV_PIX_FMT_BGR24 ; } else if ( ! encoding && c -> bpp == 24 && c -> format == CHUNKY && ! c -> palette_size ) { avctx -> pix_fmt = AV_PIX_FMT_RGB24 ; } else { avpriv_request_sample ( avctx , ""Encoding<S2SV_blank>%d,<S2SV_blank>bpp<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>format<S2SV_blank>0x%x"" , encoding , c -> bpp , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) return ret ; p -> pict_type = AV_PICTURE_TYPE_I ; if ( encoding ) { av_fast_padded_malloc ( & c -> new_video , & c -> new_video_size , h * w + AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! c -> new_video ) return AVERROR ( ENOMEM ) ; if ( c -> bpp == 8 ) cdxl_decode_ham8 ( c , p ) ; else cdxl_decode_ham6 ( c , p ) ; } else if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) { cdxl_decode_rgb ( c , p ) ; } else { cdxl_decode_raw ( c , p ) ; } * got_frame = 1 ; return buf_size ; }
","<S2SV_ModStart> == 8 ) && c -> format != CHUNKY
"
364,"CWE-125 int ethertype_print ( netdissect_options * ndo , u_short ether_type , const u_char * p , u_int length , u_int caplen , const struct lladdr_info * src , const struct lladdr_info * dst ) { switch ( ether_type ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ARP : case ETHERTYPE_REVARP : arp_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_DN : decnet_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_ATALK : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""et1<S2SV_blank>"" ) ) ; atalk_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_AARP : aarp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPX : ND_PRINT ( ( ndo , ""(NOV-ETHII)<S2SV_blank>"" ) ) ; ipx_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ISO : if ( length == 0 || caplen == 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|osi]"" ) ) ; return ( 1 ) ; } <S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <S2SV_EndBug> return ( 1 ) ; case ETHERTYPE_PPPOED : case ETHERTYPE_PPPOES : case ETHERTYPE_PPPOED2 : case ETHERTYPE_PPPOES2 : pppoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_EAPOL : eap_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_RRCP : rrcp_print ( ndo , p , length , src , dst ) ; return ( 1 ) ; case ETHERTYPE_PPP : if ( length ) { ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; ppp_print ( ndo , p , length ) ; } return ( 1 ) ; case ETHERTYPE_MPCP : mpcp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_SLOW : slow_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_CFM : case ETHERTYPE_CFM_OLD : cfm_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_LLDP : lldp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_NSH : nsh_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_LOOPBACK : loopback_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_MPLS : case ETHERTYPE_MPLS_MULTI : mpls_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_TIPC : tipc_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_MS_NLB_HB : msnlb_print ( ndo , p ) ; return ( 1 ) ; case ETHERTYPE_GEONET_OLD : case ETHERTYPE_GEONET : geonet_print ( ndo , p , length , src ) ; return ( 1 ) ; case ETHERTYPE_CALM_FAST : calm_fast_print ( ndo , p , length , src ) ; return ( 1 ) ; case ETHERTYPE_AOE : aoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_MEDSA : medsa_print ( ndo , p , length , caplen , src , dst ) ; return ( 1 ) ; case ETHERTYPE_LAT : case ETHERTYPE_SCA : case ETHERTYPE_MOPRC : case ETHERTYPE_MOPDL : case ETHERTYPE_IEEE1905_1 : default : return ( 0 ) ; } }
","<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; return
"
365,"CWE-362 static void queue_delete ( struct snd_seq_queue * q ) { <S2SV_StartBug> snd_seq_timer_stop ( q -> timer ) ; <S2SV_EndBug> <S2SV_StartBug> snd_seq_timer_close ( q ) ; <S2SV_EndBug> snd_use_lock_sync ( & q -> use_lock ) ; snd_seq_prioq_delete ( & q -> tickq ) ; snd_seq_prioq_delete ( & q -> timeq ) ; snd_seq_timer_delete ( & q -> timer ) ; kfree ( q ) ; }
","<S2SV_ModStart> q ) { mutex_lock ( & q -> timer_mutex ) ; <S2SV_ModStart> snd_seq_timer_close ( q ) ; mutex_unlock ( & q -> timer_mutex
"
366,"CWE-119 static int fallocate_chunk ( struct inode * inode , loff_t offset , loff_t len , int mode ) { struct gfs2_inode * ip = GFS2_I ( inode ) ; struct buffer_head * dibh ; int error ; <S2SV_StartBug> u64 start = offset >> PAGE_CACHE_SHIFT ; <S2SV_EndBug> unsigned int start_offset = offset & ~ PAGE_CACHE_MASK ; <S2SV_StartBug> u64 end = ( offset + len - 1 ) >> PAGE_CACHE_SHIFT ; <S2SV_EndBug> pgoff_t curr ; struct page * page ; unsigned int end_offset = ( offset + len ) & ~ PAGE_CACHE_MASK ; unsigned int from , to ; if ( ! end_offset ) end_offset = PAGE_CACHE_SIZE ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) goto out ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } curr = start ; offset = start << PAGE_CACHE_SHIFT ; from = start_offset ; to = PAGE_CACHE_SIZE ; while ( curr <= end ) { page = grab_cache_page_write_begin ( inode -> i_mapping , curr , AOP_FLAG_NOFS ) ; if ( unlikely ( ! page ) ) { error = - ENOMEM ; goto out ; } if ( curr == end ) to = end_offset ; error = write_empty_blocks ( page , from , to , mode ) ; if ( ! error && offset + to > inode -> i_size && <S2SV_StartBug> ! ( mode & FALLOC_FL_KEEP_SIZE ) ) { <S2SV_EndBug> <S2SV_StartBug> i_size_write ( inode , offset + to ) ; <S2SV_EndBug> } unlock_page ( page ) ; page_cache_release ( page ) ; if ( error ) goto out ; curr ++ ; offset += PAGE_CACHE_SIZE ; from = 0 ; } <S2SV_StartBug> mark_inode_dirty ( inode ) ; <S2SV_EndBug> brelse ( dibh ) ; out : <S2SV_StartBug> return error ; <S2SV_EndBug> }
","<S2SV_ModStart> int error ; unsigned int nr_blks ; sector_t lblock <S2SV_ModEnd> = offset >> <S2SV_ModStart> = offset >> inode -> i_blkbits ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) return error ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } while ( len ) { struct buffer_head bh_map = { . b_state = 0 , . b_blocknr = 0 } ; bh_map . b_size = len ; set_buffer_zeronew ( & bh_map ) ; error = gfs2_block_map ( inode , lblock , & bh_map , 1 ) ; if ( unlikely ( error ) ) goto out ; len -= bh_map . b_size ; nr_blks = bh_map . b_size >> inode -> i_blkbits ; lblock += nr_blks ; if ( ! buffer_new ( & bh_map ) ) continue ; if ( unlikely ( ! buffer_zeronew ( & bh_map ) ) ) { error = - EIO ; goto out ; } } if <S2SV_ModEnd> ( offset + <S2SV_ModStart> offset + len <S2SV_ModEnd> > inode -> <S2SV_ModStart> FALLOC_FL_KEEP_SIZE ) ) <S2SV_ModEnd> i_size_write ( inode <S2SV_ModStart> , offset + len ) ; <S2SV_ModEnd> mark_inode_dirty ( inode <S2SV_ModStart> mark_inode_dirty ( inode <S2SV_ModEnd> ) ; out <S2SV_ModStart> ; out : brelse ( dibh ) ;
"
367,"CWE-362 static void * vips_foreign_load_start ( VipsImage * out , void * a , void * b ) { VipsForeignLoad * load = VIPS_FOREIGN_LOAD ( b ) ; <S2SV_StartBug> VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ; <S2SV_EndBug> if ( ! load -> real ) { if ( ! ( load -> real = vips_foreign_load_temp ( load ) ) ) return ( NULL ) ; # ifdef DEBUG printf ( ""vips_foreign_load_start:<S2SV_blank>triggering<S2SV_blank>->load()\\n"" ) ; # endif load -> real -> progress_signal = load -> out ; g_object_set_qdata ( G_OBJECT ( load -> real ) , vips__foreign_load_operation , load ) ; if ( class -> load ( load ) || <S2SV_StartBug> vips_image_pio_input ( load -> real ) ) <S2SV_EndBug> return ( NULL ) ; if ( ! vips_foreign_load_iscompat ( load -> real , out ) ) <S2SV_StartBug> return ( NULL ) ; <S2SV_EndBug> vips_image_pipelinev ( load -> out , load -> out -> dhint , load -> real , NULL ) ; } return ( vips_region_new ( load -> real ) ) ; }
","<S2SV_ModStart> VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ; if ( load -> error ) return ( NULL <S2SV_ModStart> -> real ) || <S2SV_ModEnd> vips_foreign_load_iscompat ( load <S2SV_ModStart> out ) ) { vips_operation_invalidate ( VIPS_OPERATION ( load ) ) ; load -> error = TRUE ; return ( NULL ) ; } <S2SV_ModEnd> vips_image_pipelinev ( load
"
368,"CWE-000 static int fit_image_verify_sig ( const void * fit , int image_noffset , const char * data , size_t size , const void * sig_blob , int sig_offset ) { int noffset ; char * err_msg = """" ; int verified = 0 ; int ret ; fdt_for_each_subnode ( noffset , fit , image_noffset ) { <S2SV_StartBug> const char * name = fit_get_name ( fit , noffset , NULL ) ; <S2SV_EndBug> if ( ! strncmp ( name , FIT_SIG_NODENAME , strlen ( FIT_SIG_NODENAME ) ) ) { ret = fit_image_check_sig ( fit , noffset , data , size , - 1 , & err_msg ) ; if ( ret ) { puts ( ""-<S2SV_blank>"" ) ; } else { puts ( ""+<S2SV_blank>"" ) ; verified = 1 ; break ; } } } if ( noffset == - FDT_ERR_TRUNCATED || noffset == - FDT_ERR_BADSTRUCTURE ) { err_msg = ""Corrupted<S2SV_blank>or<S2SV_blank>truncated<S2SV_blank>tree"" ; goto error ; } return verified ? 0 : - EPERM ; error : printf ( ""<S2SV_blank>error!\\n%s<S2SV_blank>for<S2SV_blank>\'%s\'<S2SV_blank>hash<S2SV_blank>node<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>image<S2SV_blank>node\\n"" , err_msg , fit_get_name ( fit , noffset , NULL ) , fit_get_name ( fit , image_noffset , NULL ) ) ; return - 1 ; }
","<S2SV_ModStart> NULL ) ; if ( strchr ( name , '@' ) ) { err_msg = ""Node<S2SV_blank>name<S2SV_blank>contains<S2SV_blank>@"" ; goto error ; }
"
369,"CWE-400 int xfs_attr3_leaf_list_int ( struct xfs_buf * bp , struct xfs_attr_list_context * context ) { struct attrlist_cursor_kern * cursor ; struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_entry * entry ; int retval ; int i ; struct xfs_mount * mp = context -> dp -> i_mount ; trace_xfs_attr_list_leaf ( context ) ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( mp -> m_attr_geo , & ichdr , leaf ) ; entries = xfs_attr3_leaf_entryp ( leaf ) ; cursor = context -> cursor ; cursor -> initted = 1 ; if ( context -> resynch ) { entry = & entries [ 0 ] ; for ( i = 0 ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval ) { if ( cursor -> offset == context -> dupcnt ) { context -> dupcnt = 0 ; break ; } context -> dupcnt ++ ; } else if ( be32_to_cpu ( entry -> hashval ) > cursor -> hashval ) { context -> dupcnt = 0 ; break ; } } if ( i == ichdr . count ) { trace_xfs_attr_list_notfound ( context ) ; return 0 ; } } else { entry = & entries [ 0 ] ; i = 0 ; } context -> resynch = 0 ; retval = 0 ; for ( ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) != cursor -> hashval ) { cursor -> hashval = be32_to_cpu ( entry -> hashval ) ; cursor -> offset = 0 ; } if ( entry -> flags & XFS_ATTR_INCOMPLETE ) continue ; if ( entry -> flags & XFS_ATTR_LOCAL ) { xfs_attr_leaf_name_local_t * name_loc = xfs_attr3_leaf_name_local ( leaf , i ) ; retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ; if ( retval ) return retval ; } else { xfs_attr_leaf_name_remote_t * name_rmt = xfs_attr3_leaf_name_remote ( leaf , i ) ; int valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; if ( context -> put_value ) { xfs_da_args_t args ; memset ( ( char * ) & args , 0 , sizeof ( args ) ) ; args . geo = context -> dp -> i_mount -> m_attr_geo ; args . dp = context -> dp ; args . whichfork = XFS_ATTR_FORK ; args . valuelen = valuelen ; args . rmtvaluelen = valuelen ; args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ; args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args . rmtblkcnt = xfs_attr3_rmt_blocks ( args . dp -> i_mount , valuelen ) ; retval = xfs_attr_rmtval_get ( & args ) ; <S2SV_StartBug> if ( retval ) <S2SV_EndBug> return retval ; retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , args . value ) ; kmem_free ( args . value ) ; } else { retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , NULL ) ; } if ( retval ) return retval ; } if ( context -> seen_enough ) break ; cursor -> offset ++ ; } trace_xfs_attr_list_leaf_end ( context ) ; return retval ; }
","<S2SV_ModStart> ; if ( ! retval ) <S2SV_ModEnd> retval = context
"
370,"CWE-401 int cx23888_ir_probe ( struct cx23885_dev * dev ) { struct cx23888_ir_state * state ; struct v4l2_subdev * sd ; struct v4l2_subdev_ir_parameters default_params ; int ret ; state = kzalloc ( sizeof ( struct cx23888_ir_state ) , GFP_KERNEL ) ; if ( state == NULL ) return - ENOMEM ; spin_lock_init ( & state -> rx_kfifo_lock ) ; <S2SV_StartBug> if ( kfifo_alloc ( & state -> rx_kfifo , CX23888_IR_RX_KFIFO_SIZE , GFP_KERNEL ) ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> state -> dev = dev ; <S2SV_EndBug> sd = & state -> sd ; v4l2_subdev_init ( sd , & cx23888_ir_controller_ops ) ; v4l2_set_subdevdata ( sd , state ) ; snprintf ( sd -> name , sizeof ( sd -> name ) , ""%s/888-ir"" , dev -> name ) ; sd -> grp_id = CX23885_HW_888_IR ; ret = v4l2_device_register_subdev ( & dev -> v4l2_dev , sd ) ; if ( ret == 0 ) { cx23888_ir_write4 ( dev , CX23888_IR_IRQEN_REG , 0 ) ; mutex_init ( & state -> rx_params_lock ) ; default_params = default_rx_params ; v4l2_subdev_call ( sd , ir , rx_s_parameters , & default_params ) ; mutex_init ( & state -> tx_params_lock ) ; default_params = default_tx_params ; v4l2_subdev_call ( sd , ir , tx_s_parameters , & default_params ) ; } else { kfifo_free ( & state -> rx_kfifo ) ; } return ret ; }
","<S2SV_ModStart> GFP_KERNEL ) ) { kfree ( state ) ; <S2SV_ModStart> - ENOMEM ; }
"
371,"CWE-476 int nfc_llcp_send_connect ( struct nfc_llcp_sock * sock ) { struct nfc_llcp_local * local ; struct sk_buff * skb ; u8 * service_name_tlv = NULL , service_name_tlv_length ; u8 * miux_tlv = NULL , miux_tlv_length ; u8 * rw_tlv = NULL , rw_tlv_length , rw ; int err ; u16 size = 0 ; __be16 miux ; pr_debug ( ""Sending<S2SV_blank>CONNECT\\n"" ) ; local = sock -> local ; if ( local == NULL ) return - ENODEV ; if ( sock -> service_name != NULL ) { service_name_tlv = nfc_llcp_build_tlv ( LLCP_TLV_SN , sock -> service_name , sock -> service_name_len , & service_name_tlv_length ) ; <S2SV_StartBug> size += service_name_tlv_length ; <S2SV_EndBug> } miux = be16_to_cpu ( sock -> miux ) > LLCP_MAX_MIUX ? local -> miux : sock -> miux ; rw = sock -> rw > LLCP_MAX_RW ? local -> rw : sock -> rw ; miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & miux , 0 , & miux_tlv_length ) ; <S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ; <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug> pr_debug ( ""SKB<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>SN<S2SV_blank>length<S2SV_blank>%zu\\n"" , size , sock -> service_name_len ) ; skb = llcp_allocate_pdu ( sock , LLCP_PDU_CONNECT , size ) ; if ( skb == NULL ) { err = - ENOMEM ; goto error_tlv ; } llcp_add_tlv ( skb , service_name_tlv , service_name_tlv_length ) ; llcp_add_tlv ( skb , miux_tlv , miux_tlv_length ) ; llcp_add_tlv ( skb , rw_tlv , rw_tlv_length ) ; skb_queue_tail ( & local -> tx_queue , skb ) ; err = 0 ; error_tlv : if ( err ) pr_err ( ""error<S2SV_blank>%d\\n"" , err ) ; kfree ( service_name_tlv ) ; kfree ( miux_tlv ) ; kfree ( rw_tlv ) ; return err ; }
","<S2SV_ModStart> service_name_tlv_length ) ; if ( ! service_name_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> miux_tlv_length ) ; if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> rw_tlv_length ) ; if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; }
"
372,"CWE-119 struct monitor * monitor_init ( void ) { <S2SV_StartBug> struct ssh * ssh = active_state ; <S2SV_EndBug> struct monitor * mon ; mon = xcalloc ( 1 , sizeof ( * mon ) ) ; monitor_openfds ( mon , 1 ) ; <S2SV_StartBug> if ( options . compression ) { <S2SV_EndBug> mon -> m_zback = mm_create ( NULL , MM_MEMSIZE ) ; mon -> m_zlib = mm_create ( mon -> m_zback , 20 * MM_MEMSIZE ) ; ssh_packet_set_compress_hooks ( ssh , mon -> m_zlib , ( ssh_packet_comp_alloc_func * ) mm_zalloc , ( ssh_packet_comp_free_func * ) mm_zfree ) ; } return mon ; }
","<S2SV_ModStart> void ) { <S2SV_ModEnd> struct monitor * <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> return mon ;
"
373,"CWE-119 vpx_codec_err_t vpx_codec_dec_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , <S2SV_StartBug> vpx_codec_dec_cfg_t * cfg , <S2SV_EndBug> vpx_codec_flags_t flags , int ver ) { vpx_codec_err_t res ; if ( ver != VPX_DECODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; <S2SV_StartBug> else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) <S2SV_EndBug> res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_POSTPROC ) && ! ( iface -> caps & VPX_CODEC_CAP_POSTPROC ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_ERROR_CONCEALMENT ) && ! ( iface -> caps & VPX_CODEC_CAP_ERROR_CONCEALMENT ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_INPUT_FRAGMENTS ) && ! ( iface -> caps & VPX_CODEC_CAP_INPUT_FRAGMENTS ) ) res = VPX_CODEC_INCAPABLE ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_DECODER ) ) res = VPX_CODEC_INCAPABLE ; else { memset ( ctx , 0 , sizeof ( * ctx ) ) ; ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; ctx -> config . dec = cfg ; <S2SV_StartBug> res = VPX_CODEC_OK ; <S2SV_EndBug> if ( ! ( flags & VPX_CODEC_USE_XMA ) ) { res = ctx -> iface -> init ( ctx , NULL ) ; if ( res ) { ctx -> err_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; vpx_codec_destroy ( ctx ) ; } <S2SV_StartBug> if ( ctx -> priv ) <S2SV_EndBug> ctx -> priv -> iface = ctx -> iface ; } } return SAVE_STATUS ( ctx , res ) ; }
","<S2SV_ModStart> * iface , const <S2SV_ModStart> ( flags & <S2SV_ModEnd> VPX_CODEC_USE_POSTPROC ) && <S2SV_ModStart> ; res = <S2SV_ModEnd> ctx -> iface <S2SV_ModStart> ) ; } <S2SV_ModEnd> } return SAVE_STATUS
"
374,"CWE-476 static int jp2_cdef_getdata ( jp2_box_t * box , jas_stream_t * in ) { jp2_cdef_t * cdef = & box -> data . cdef ; jp2_cdefchan_t * chan ; <S2SV_StartBug> unsigned int channo ; <S2SV_EndBug> if ( jp2_getuint16 ( in , & cdef -> numchans ) ) { return - 1 ; } if ( ! ( cdef -> ents = jas_alloc2 ( cdef -> numchans , sizeof ( jp2_cdefchan_t ) ) ) ) { return - 1 ; } for ( channo = 0 ; channo < cdef -> numchans ; ++ channo ) { chan = & cdef -> ents [ channo ] ; if ( jp2_getuint16 ( in , & chan -> channo ) || jp2_getuint16 ( in , & chan -> type ) || jp2_getuint16 ( in , & chan -> assoc ) ) { return - 1 ; } } return 0 ; }
","<S2SV_ModStart> unsigned int channo ; cdef -> ents = 0
"
375,"CWE-20 error_t tja1100Init ( NetInterface * interface ) { uint16_t value ; TRACE_INFO ( ""Initializing<S2SV_blank>TJA1100...\\r\\n"" ) ; if ( interface -> phyAddr >= 32 ) { interface -> phyAddr = TJA1100_PHY_ADDR ; } if ( interface -> smiDriver != NULL ) { interface -> smiDriver -> init ( ) ; } if ( interface -> extIntDriver != NULL ) { interface -> extIntDriver -> init ( ) ; } tja1100WritePhyReg ( interface , TJA1100_BASIC_CTRL , TJA1100_BASIC_CTRL_RESET ) ; while ( tja1100ReadPhyReg ( interface , TJA1100_BASIC_CTRL ) & TJA1100_BASIC_CTRL_RESET ) { } tja1100DumpPhyReg ( interface ) ; value = tja1100ReadPhyReg ( interface , TJA1100_EXTENDED_CTRL ) ; value |= TJA1100_EXTENDED_CTRL_CONFIG_EN ; tja1100WritePhyReg ( interface , TJA1100_EXTENDED_CTRL , value ) ; value = tja1100ReadPhyReg ( interface , TJA1100_CONFIG1 ) ; value &= ~ TJA1100_CONFIG1_MII_MODE ; <S2SV_StartBug> value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ ; <S2SV_EndBug> tja1100WritePhyReg ( interface , TJA1100_CONFIG1 , value ) ; value = tja1100ReadPhyReg ( interface , TJA1100_CONFIG1 ) ; value |= TJA1100_CONFIG1_AUTO_OP ; tja1100WritePhyReg ( interface , TJA1100_CONFIG1 , value ) ; interface -> phyEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }
","<S2SV_ModStart> ; value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ_XTAL <S2SV_ModEnd> ; tja1100WritePhyReg (
"
376,"CWE-362 void icmp_send ( struct sk_buff * skb_in , int type , int code , __be32 info ) { struct iphdr * iph ; int room ; struct icmp_bxm icmp_param ; struct rtable * rt = skb_rtable ( skb_in ) ; struct ipcm_cookie ipc ; __be32 saddr ; u8 tos ; struct net * net ; struct sock * sk ; if ( ! rt ) goto out ; net = dev_net ( rt -> dst . dev ) ; iph = ip_hdr ( skb_in ) ; if ( ( u8 * ) iph < skb_in -> head || ( skb_in -> network_header + sizeof ( * iph ) ) > skb_in -> tail ) goto out ; if ( skb_in -> pkt_type != PACKET_HOST ) goto out ; if ( rt -> rt_flags & ( RTCF_BROADCAST | RTCF_MULTICAST ) ) goto out ; if ( iph -> frag_off & htons ( IP_OFFSET ) ) goto out ; if ( icmp_pointers [ type ] . error ) { if ( iph -> protocol == IPPROTO_ICMP ) { u8 _inner_type , * itp ; itp = skb_header_pointer ( skb_in , skb_network_header ( skb_in ) + ( iph -> ihl << 2 ) + offsetof ( struct icmphdr , type ) - skb_in -> data , sizeof ( _inner_type ) , & _inner_type ) ; if ( itp == NULL ) goto out ; if ( * itp > NR_ICMP_TYPES || icmp_pointers [ * itp ] . error ) goto out ; } } sk = icmp_xmit_lock ( net ) ; if ( sk == NULL ) return ; saddr = iph -> daddr ; if ( ! ( rt -> rt_flags & RTCF_LOCAL ) ) { struct net_device * dev = NULL ; rcu_read_lock ( ) ; if ( rt_is_input_route ( rt ) && net -> ipv4 . sysctl_icmp_errors_use_inbound_ifaddr ) dev = dev_get_by_index_rcu ( net , rt -> rt_iif ) ; if ( dev ) saddr = inet_select_addr ( dev , 0 , RT_SCOPE_LINK ) ; else saddr = 0 ; rcu_read_unlock ( ) ; } tos = icmp_pointers [ type ] . error ? ( ( iph -> tos & IPTOS_TOS_MASK ) | IPTOS_PREC_INTERNETCONTROL ) : iph -> tos ; <S2SV_StartBug> if ( ip_options_echo ( & icmp_param . replyopts , skb_in ) ) <S2SV_EndBug> goto out_unlock ; icmp_param . data . icmph . type = type ; icmp_param . data . icmph . code = code ; icmp_param . data . icmph . un . gateway = info ; icmp_param . data . icmph . checksum = 0 ; icmp_param . skb = skb_in ; icmp_param . offset = skb_network_offset ( skb_in ) ; inet_sk ( sk ) -> tos = tos ; ipc . addr = iph -> saddr ; <S2SV_StartBug> ipc . opt = & icmp_param . replyopts ; <S2SV_EndBug> ipc . tx_flags = 0 ; rt = icmp_route_lookup ( net , skb_in , iph , saddr , tos , type , code , & icmp_param ) ; if ( IS_ERR ( rt ) ) goto out_unlock ; if ( ! icmpv4_xrlim_allow ( net , rt , type , code ) ) goto ende ; room = dst_mtu ( & rt -> dst ) ; if ( room > 576 ) room = 576 ; <S2SV_StartBug> room -= sizeof ( struct iphdr ) + icmp_param . replyopts . optlen ; <S2SV_EndBug> room -= sizeof ( struct icmphdr ) ; icmp_param . data_len = skb_in -> len - icmp_param . offset ; if ( icmp_param . data_len > room ) icmp_param . data_len = room ; icmp_param . head_len = sizeof ( struct icmphdr ) ; icmp_push_reply ( & icmp_param , & ipc , & rt ) ; ende : ip_rt_put ( rt ) ; out_unlock : icmp_xmit_unlock ( sk ) ; out : ; }
","<S2SV_ModStart> icmp_param . replyopts . opt . opt <S2SV_ModStart> icmp_param . replyopts . opt <S2SV_ModStart> . replyopts . opt . opt .
"
377,"CWE-125 static int print_bacp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)"" , tok2str ( bacconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( bacconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; switch ( opt ) { case BACPOPT_FPEER : if ( len != 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>Magic-Num<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ; break ; default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , ""[|bacp]"" ) ) ; return 0 ; }
","<S2SV_ModStart> len ; } ND_TCHECK_32BITS <S2SV_ModEnd> ( p + <S2SV_ModStart> p + 2 <S2SV_ModEnd> ) ; ND_PRINT
"
378,"CWE-476 void ipv4_pktinfo_prepare ( const struct sock * sk , struct sk_buff * skb ) { struct in_pktinfo * pktinfo = PKTINFO_SKB_CB ( skb ) ; bool prepare = ( inet_sk ( sk ) -> cmsg_flags & IP_CMSG_PKTINFO ) || ipv6_sk_rxinfo ( sk ) ; if ( prepare && skb_rtable ( skb ) ) { if ( pktinfo -> ipi_ifindex == LOOPBACK_IFINDEX ) pktinfo -> ipi_ifindex = inet_iif ( skb ) ; pktinfo -> ipi_spec_dst . s_addr = fib_compute_spec_dst ( skb ) ; } else { pktinfo -> ipi_ifindex = 0 ; pktinfo -> ipi_spec_dst . s_addr = 0 ; } <S2SV_StartBug> skb_dst_drop ( skb ) ; <S2SV_EndBug> }
","<S2SV_ModStart> 0 ; } if ( unlikely ( IPCB ( skb ) -> opt . optlen ) ) skb_dst_force ( skb ) ; else
"
379,"CWE-476 static void skcipher_release ( void * private ) { <S2SV_StartBug> crypto_free_skcipher ( private ) ; <S2SV_EndBug> }
","<S2SV_ModStart> private ) { struct skcipher_tfm * tfm = private ; crypto_free_skcipher ( tfm -> skcipher ) ; kfree ( tfm <S2SV_ModEnd> ) ; }
"
380,"CWE-362 int prepare_binprm ( struct linux_binprm * bprm ) { <S2SV_StartBug> struct inode * inode = file_inode ( bprm -> file ) ; <S2SV_EndBug> umode_t mode = inode -> i_mode ; int retval ; <S2SV_StartBug> bprm -> cred -> euid = current_euid ( ) ; <S2SV_EndBug> bprm -> cred -> egid = current_egid ( ) ; if ( ! ( bprm -> file -> f_path . mnt -> mnt_flags & MNT_NOSUID ) && ! task_no_new_privs ( current ) && kuid_has_mapping ( bprm -> cred -> user_ns , inode -> i_uid ) && kgid_has_mapping ( bprm -> cred -> user_ns , inode -> i_gid ) ) { if ( mode & S_ISUID ) { bprm -> per_clear |= PER_CLEAR_ON_SETID ; bprm -> cred -> euid = inode -> i_uid ; } if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) ) { bprm -> per_clear |= PER_CLEAR_ON_SETID ; bprm -> cred -> egid = inode -> i_gid ; } } retval = security_bprm_set_creds ( bprm ) ; if ( retval ) return retval ; bprm -> cred_prepared = 1 ; memset ( bprm -> buf , 0 , BINPRM_BUF_SIZE ) ; return kernel_read ( bprm -> file , 0 , bprm -> buf , BINPRM_BUF_SIZE ) ; }
","<S2SV_ModStart> bprm ) { <S2SV_ModEnd> int retval ; <S2SV_ModStart> int retval ; bprm_fill_uid ( bprm ) ; <S2SV_ModEnd> retval = security_bprm_set_creds
"
381,"CWE-20 static int get_rx_bufs ( struct vhost_virtqueue * vq , struct vring_used_elem * heads , int datalen , unsigned * iovcount , struct vhost_log * log , unsigned * log_num , unsigned int quota ) { unsigned int out , in ; int seg = 0 ; int headcount = 0 ; unsigned d ; int r , nlogs = 0 ; while ( datalen > 0 && headcount < quota ) { if ( unlikely ( seg >= UIO_MAXIOV ) ) { r = - ENOBUFS ; goto err ; } d = vhost_get_vq_desc ( vq -> dev , vq , vq -> iov + seg , ARRAY_SIZE ( vq -> iov ) - seg , & out , & in , log , log_num ) ; if ( d == vq -> num ) { r = 0 ; goto err ; } if ( unlikely ( out || in <= 0 ) ) { vq_err ( vq , ""unexpected<S2SV_blank>descriptor<S2SV_blank>format<S2SV_blank>for<S2SV_blank>RX:<S2SV_blank>"" ""out<S2SV_blank>%d,<S2SV_blank>in<S2SV_blank>%d\\n"" , out , in ) ; r = - EINVAL ; goto err ; } if ( unlikely ( log ) ) { nlogs += * log_num ; log += * log_num ; } heads [ headcount ] . id = d ; heads [ headcount ] . len = iov_length ( vq -> iov + seg , in ) ; datalen -= heads [ headcount ] . len ; ++ headcount ; seg += in ; } heads [ headcount - 1 ] . len += datalen ; * iovcount = seg ; if ( unlikely ( log ) ) * log_num = nlogs ; <S2SV_StartBug> return headcount ; <S2SV_EndBug> err : vhost_discard_vq_desc ( vq , headcount ) ; return r ; }
","<S2SV_ModStart> = nlogs ; if ( unlikely ( datalen > 0 ) ) { r = UIO_MAXIOV + 1 ; goto err ; }
"
382,"CWE-191 void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) { const char * quote = ""`\\""\\\\"" ; if ( ! quote_backtick ) quote ++ ; char * pt = dest ; const char * s = src ; * pt ++ = \'""\' ; dlen -= 2 ; for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { <S2SV_StartBug> dlen -= 2 ; <S2SV_EndBug> if ( dlen == 0 ) break ; * pt ++ = '\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \'""\' ; * pt = '\\0' ; }
","<S2SV_ModStart> ) ) { if ( dlen < 2 ) break ; <S2SV_ModStart> dlen -= 2 <S2SV_ModEnd> ; * pt
"
383,"CWE-362 static void bt_tags_for_each ( struct blk_mq_tags * tags , struct blk_mq_bitmap_tags * bt , unsigned int off , busy_tag_iter_fn * fn , void * data , bool reserved ) { struct request * rq ; int bit , i ; if ( ! tags -> rqs ) return ; for ( i = 0 ; i < bt -> map_nr ; i ++ ) { struct blk_align_bitmap * bm = & bt -> map [ i ] ; for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) { <S2SV_StartBug> rq = blk_mq_tag_to_rq ( tags , off + bit ) ; <S2SV_EndBug> fn ( rq , data , reserved ) ; } off += ( 1 << bt -> bits_per_word ) ; } }
","<S2SV_ModStart> { rq = tags -> rqs [ <S2SV_ModEnd> off + bit <S2SV_ModStart> off + bit ] <S2SV_ModEnd> ; fn (
"
384,"CWE-119 vpx_codec_err_t vpx_codec_enc_init_multi_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , vpx_codec_enc_cfg_t * cfg , int num_enc , vpx_codec_flags_t flags , vpx_rational_t * dsf , int ver ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( ver != VPX_ENCODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface || ! cfg || ( num_enc > 16 || num_enc < 1 ) ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; <S2SV_StartBug> else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) <S2SV_EndBug> res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_PSNR ) && ! ( iface -> caps & VPX_CODEC_CAP_PSNR ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_OUTPUT_PARTITION ) && ! ( iface -> caps & VPX_CODEC_CAP_OUTPUT_PARTITION ) ) res = VPX_CODEC_INCAPABLE ; else { int i ; void * mem_loc = NULL ; if ( ! ( res = iface -> enc . mr_get_mem_loc ( cfg , & mem_loc ) ) ) { for ( i = 0 ; i < num_enc ; i ++ ) { vpx_codec_priv_enc_mr_cfg_t mr_cfg ; if ( dsf -> num < 1 || dsf -> num > 4096 || dsf -> den < 1 || dsf -> den > dsf -> num ) { res = VPX_CODEC_INVALID_PARAM ; break ; } mr_cfg . mr_low_res_mode_info = mem_loc ; mr_cfg . mr_total_resolutions = num_enc ; mr_cfg . mr_encoder_id = num_enc - 1 - i ; mr_cfg . mr_down_sampling_factor . num = dsf -> num ; mr_cfg . mr_down_sampling_factor . den = dsf -> den ; if ( mr_cfg . mr_encoder_id ) cfg -> kf_mode = VPX_KF_DISABLED ; ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; ctx -> config . enc = cfg ; res = ctx -> iface -> init ( ctx , & mr_cfg ) ; if ( res ) { const char * error_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; ctx -> err_detail = error_detail ; vpx_codec_destroy ( ctx ) ; while ( i ) { ctx -- ; ctx -> err_detail = error_detail ; vpx_codec_destroy ( ctx ) ; i -- ; } } <S2SV_StartBug> if ( ctx -> priv ) <S2SV_EndBug> ctx -> priv -> iface = ctx -> iface ; if ( res ) break ; ctx ++ ; cfg ++ ; dsf ++ ; } ctx -- ; } } return SAVE_STATUS ( ctx , res ) ; }
","<S2SV_ModStart> ( flags & <S2SV_ModEnd> VPX_CODEC_USE_PSNR ) && <S2SV_ModStart> } if ( <S2SV_ModEnd> res ) break
"
385,"CWE-20 static int vmci_transport_dgram_dequeue ( struct kiocb * kiocb , struct vsock_sock * vsk , struct msghdr * msg , size_t len , int flags ) { int err ; int noblock ; struct vmci_datagram * dg ; size_t payload_len ; struct sk_buff * skb ; noblock = flags & MSG_DONTWAIT ; if ( flags & MSG_OOB || flags & MSG_ERRQUEUE ) return - EOPNOTSUPP ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> err = 0 ; skb = skb_recv_datagram ( & vsk -> sk , flags , noblock , & err ) ; if ( err ) return err ; if ( ! skb ) return - EAGAIN ; dg = ( struct vmci_datagram * ) skb -> data ; if ( ! dg ) goto out ; payload_len = dg -> payload_size ; if ( payload_len != skb -> len - sizeof ( * dg ) ) { err = - EINVAL ; goto out ; } if ( payload_len > len ) { payload_len = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , sizeof ( * dg ) , msg -> msg_iov , payload_len ) ; if ( err ) goto out ; if ( msg -> msg_name ) { struct sockaddr_vm * vm_addr ; vm_addr = ( struct sockaddr_vm * ) msg -> msg_name ; vsock_addr_init ( vm_addr , dg -> src . context , dg -> src . resource ) ; msg -> msg_namelen = sizeof ( * vm_addr ) ; } err = payload_len ; out : skb_free_datagram ( & vsk -> sk , skb ) ; return err ; }
","<S2SV_ModStart> - EOPNOTSUPP ; <S2SV_ModEnd> err = 0
"
386,"CWE-189 static u64 __skb_get_nlattr ( u64 ctx , u64 A , u64 X , u64 r4 , u64 r5 ) { struct sk_buff * skb = ( struct sk_buff * ) ( long ) ctx ; struct nlattr * nla ; <S2SV_StartBug> if ( skb_is_nonlinear ( skb ) ) <S2SV_EndBug> return 0 ; if ( A > skb -> len - sizeof ( struct nlattr ) ) return 0 ; nla = nla_find ( ( struct nlattr * ) & skb -> data [ A ] , skb -> len - A , X ) ; if ( nla ) return ( void * ) nla - ( void * ) skb -> data ; return 0 ; }
","<S2SV_ModStart> skb_is_nonlinear ( skb ) ) return 0 ; if ( skb -> len < sizeof ( struct nlattr
"
387,"CWE-000 static inline void encode_openhdr ( struct xdr_stream * xdr , const struct nfs_openargs * arg ) { __be32 * p ; RESERVE_SPACE ( 8 ) ; WRITE32 ( OP_OPEN ) ; WRITE32 ( arg -> seqid -> sequence -> counter ) ; <S2SV_StartBug> encode_share_access ( xdr , arg -> open_flags ) ; <S2SV_EndBug> RESERVE_SPACE ( 28 ) ; WRITE64 ( arg -> clientid ) ; WRITE32 ( 16 ) ; WRITEMEM ( ""open<S2SV_blank>id:"" , 8 ) ; WRITE64 ( arg -> id ) ; }
","<S2SV_ModStart> , arg -> fmode <S2SV_ModEnd> ) ; RESERVE_SPACE
"
388,"CWE-125 static void gre_print_0 ( netdissect_options * ndo , const u_char * bp , u_int length ) { u_int len = length ; uint16_t flags , prot ; flags = EXTRACT_16BITS ( bp ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( gre_flag_values , ""none"" , flags ) ) ) ; len -= 2 ; bp += 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; prot = EXTRACT_16BITS ( bp ) ; len -= 2 ; bp += 2 ; if ( ( flags & GRE_CP ) | ( flags & GRE_RP ) ) { ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>sum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>off<S2SV_blank>0x%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; } if ( flags & GRE_KP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>key=0x%x"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_SP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_RP ) { for ( ; ; ) { uint16_t af ; uint8_t sreoff ; uint8_t srelen ; ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; af = EXTRACT_16BITS ( bp ) ; sreoff = * ( bp + 2 ) ; srelen = * ( bp + 3 ) ; bp += 4 ; len -= 4 ; if ( af == 0 && srelen == 0 ) break ; if ( ! gre_sre_print ( ndo , af , sreoff , srelen , bp , len ) ) goto trunc ; if ( len < srelen ) goto trunc ; bp += srelen ; len -= srelen ; } } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>proto<S2SV_blank>%s<S2SV_blank>(0x%04x)"" , tok2str ( ethertype_values , ""unknown"" , prot ) , prot ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; if ( ndo -> ndo_vflag < 1 ) ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; else ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; switch ( prot ) { case ETHERTYPE_IP : ip_print ( ndo , bp , len ) ; break ; case ETHERTYPE_IPV6 : ip6_print ( ndo , bp , len ) ; break ; case ETHERTYPE_MPLS : mpls_print ( ndo , bp , len ) ; break ; case ETHERTYPE_IPX : ipx_print ( ndo , bp , len ) ; break ; case ETHERTYPE_ATALK : atalk_print ( ndo , bp , len ) ; break ; case ETHERTYPE_GRE_ISO : <S2SV_StartBug> isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ; <S2SV_EndBug> break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ; break ; default : ND_PRINT ( ( ndo , ""gre-proto-0x%x"" , prot ) ) ; } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }
","<S2SV_ModStart> bp , len ) ; break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len <S2SV_ModStart> ndo_snapend - bp <S2SV_ModEnd> , NULL ,
"
389,"CWE-119 static int readContigTilesIntoBuffer ( TIFF * in , uint8 * buf , uint32 imagelength , uint32 imagewidth , uint32 tw , uint32 tl , tsample_t spp , uint16 bps ) { int status = 1 ; tsample_t sample = 0 ; tsample_t count = spp ; uint32 row , col , trow ; uint32 nrow , ncol ; uint32 dst_rowsize , shift_width ; uint32 bytes_per_sample , bytes_per_pixel ; uint32 trailing_bits , prev_trailing_bits ; uint32 tile_rowsize = TIFFTileRowSize ( in ) ; uint32 src_offset , dst_offset ; uint32 row_offset , col_offset ; uint8 * bufp = ( uint8 * ) buf ; unsigned char * src = NULL ; unsigned char * dst = NULL ; tsize_t tbytes = 0 , tile_buffsize = 0 ; tsize_t tilesize = TIFFTileSize ( in ) ; unsigned char * tilebuf = NULL ; bytes_per_sample = ( bps + 7 ) / 8 ; bytes_per_pixel = ( ( bps * spp ) + 7 ) / 8 ; if ( ( bps % 8 ) == 0 ) shift_width = 0 ; else { if ( bytes_per_pixel < ( bytes_per_sample + 1 ) ) shift_width = bytes_per_pixel ; else shift_width = bytes_per_sample + 1 ; } tile_buffsize = tilesize ; if ( tilesize == 0 || tile_rowsize == 0 ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Tile<S2SV_blank>size<S2SV_blank>or<S2SV_blank>tile<S2SV_blank>rowsize<S2SV_blank>is<S2SV_blank>zero"" ) ; exit ( - 1 ) ; } if ( tilesize < ( tsize_t ) ( tl * tile_rowsize ) ) { # ifdef DEBUG2 TIFFError ( ""readContigTilesIntoBuffer"" , ""Tilesize<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small,<S2SV_blank>using<S2SV_blank>alternate<S2SV_blank>calculation<S2SV_blank>%u"" , tilesize , tl * tile_rowsize ) ; # endif tile_buffsize = tl * tile_rowsize ; if ( tl != ( tile_buffsize / tile_rowsize ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size."" ) ; exit ( - 1 ) ; } } <S2SV_StartBug> tilebuf = _TIFFmalloc ( tile_buffsize ) ; <S2SV_EndBug> if ( tilebuf == 0 ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> dst_rowsize = ( ( imagewidth * bps * spp ) + 7 ) / 8 ; for ( row = 0 ; row < imagelength ; row += tl ) { nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; for ( col = 0 ; col < imagewidth ; col += tw ) { tbytes = TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) ; if ( tbytes < tilesize && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>tile<S2SV_blank>at<S2SV_blank>row<S2SV_blank>%lu<S2SV_blank>col<S2SV_blank>%lu,<S2SV_blank>Read<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>%lu"" , ( unsigned long ) col , ( unsigned long ) row , ( unsigned long ) tbytes , ( unsigned long ) tilesize ) ; status = 0 ; _TIFFfree ( tilebuf ) ; return status ; } row_offset = row * dst_rowsize ; col_offset = ( ( col * bps * spp ) + 7 ) / 8 ; bufp = buf + row_offset + col_offset ; if ( col + tw > imagewidth ) ncol = imagewidth - col ; else ncol = tw ; if ( ( ( bps % 8 ) == 0 ) && ( count == spp ) ) { for ( trow = 0 ; trow < nrow ; trow ++ ) { src_offset = trow * tile_rowsize ; _TIFFmemcpy ( bufp , tilebuf + src_offset , ( ncol * spp * bps ) / 8 ) ; bufp += ( imagewidth * bps * spp ) / 8 ; } } else { prev_trailing_bits = trailing_bits = 0 ; trailing_bits = ( ncol * bps * spp ) % 8 ; for ( trow = 0 ; trow < nrow ; trow ++ ) { src_offset = trow * tile_rowsize ; src = tilebuf + src_offset ; dst_offset = ( row + trow ) * dst_rowsize ; dst = buf + dst_offset + col_offset ; switch ( shift_width ) { case 0 : if ( extractContigSamplesBytes ( src , dst , ncol , sample , spp , bps , count , 0 , ncol ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu"" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; case 1 : if ( bps == 1 ) { if ( extractContigSamplesShifted8bits ( src , dst , ncol , sample , spp , bps , count , 0 , ncol , prev_trailing_bits ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu"" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; } else if ( extractContigSamplesShifted16bits ( src , dst , ncol , sample , spp , bps , count , 0 , ncol , prev_trailing_bits ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu"" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; case 2 : if ( extractContigSamplesShifted24bits ( src , dst , ncol , sample , spp , bps , count , 0 , ncol , prev_trailing_bits ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu"" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; case 3 : case 4 : case 5 : if ( extractContigSamplesShifted32bits ( src , dst , ncol , sample , spp , bps , count , 0 , ncol , prev_trailing_bits ) ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu"" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; default : TIFFError ( ""readContigTilesIntoBuffer"" , ""Unsupported<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>%d"" , bps ) ; return 1 ; } } prev_trailing_bits += trailing_bits ; } } } _TIFFfree ( tilebuf ) ; return status ; }
","<S2SV_ModStart> ; } } if ( tile_buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size."" ) ; exit ( - 1 ) ; } <S2SV_ModStart> _TIFFmalloc ( tile_buffsize + 3 <S2SV_ModStart> 0 ) return 0 ; tilebuf [ tile_buffsize ] = 0 ; tilebuf [ tile_buffsize + 1 ] = 0 ; tilebuf [ tile_buffsize + 2 ] =
"
390,"CWE-59 static bool parse_cmdline ( int argc , char * * argv ) { int c ; bool reopen_log = false ; int signum ; struct utsname uname_buf ; int longindex ; int curind ; bool bad_option = false ; unsigned facility ; mode_t new_umask_val ; struct option long_options [ ] = { { ""use-file"" , required_argument , NULL , 'f' } , # if defined _WITH_VRRP_ && defined _WITH_LVS_ { ""vrrp"" , no_argument , NULL , 'P' } , { ""check"" , no_argument , NULL , 'C' } , # endif # ifdef _WITH_BFD_ { ""no_bfd"" , no_argument , NULL , 'B' } , # endif { ""all"" , no_argument , NULL , 3 } , { ""log-console"" , no_argument , NULL , 'l' } , { ""log-detail"" , no_argument , NULL , 'D' } , { ""log-facility"" , required_argument , NULL , 'S' } , { ""log-file"" , optional_argument , NULL , 'g' } , { ""flush-log-file"" , no_argument , NULL , 2 } , { ""no-syslog"" , no_argument , NULL , 'G' } , { ""umask"" , required_argument , NULL , 'u' } , # ifdef _WITH_VRRP_ { ""release-vips"" , no_argument , NULL , 'X' } , { ""dont-release-vrrp"" , no_argument , NULL , 'V' } , # endif # ifdef _WITH_LVS_ { ""dont-release-ipvs"" , no_argument , NULL , 'I' } , # endif { ""dont-respawn"" , no_argument , NULL , 'R' } , { ""dont-fork"" , no_argument , NULL , 'n' } , { ""dump-conf"" , no_argument , NULL , 'd' } , { ""pid"" , required_argument , NULL , 'p' } , # ifdef _WITH_VRRP_ { ""vrrp_pid"" , required_argument , NULL , 'r' } , # endif # ifdef _WITH_LVS_ { ""checkers_pid"" , required_argument , NULL , 'c' } , { ""address-monitoring"" , no_argument , NULL , 'a' } , # endif # ifdef _WITH_BFD_ { ""bfd_pid"" , required_argument , NULL , 'b' } , # endif # ifdef _WITH_SNMP_ { ""snmp"" , no_argument , NULL , 'x' } , { ""snmp-agent-socket"" , required_argument , NULL , 'A' } , # endif { ""core-dump"" , no_argument , NULL , 'm' } , { ""core-dump-pattern"" , optional_argument , NULL , 'M' } , # ifdef _MEM_CHECK_LOG_ { ""mem-check-log"" , no_argument , NULL , 'L' } , # endif # if HAVE_DECL_CLONE_NEWNET { ""namespace"" , required_argument , NULL , 's' } , # endif { ""config-id"" , required_argument , NULL , 'i' } , { ""signum"" , required_argument , NULL , 4 } , { ""config-test"" , optional_argument , NULL , 't' } , # ifdef _WITH_PERF_ { ""perf"" , optional_argument , NULL , 5 } , # endif # ifdef WITH_DEBUG_OPTIONS { ""debug"" , optional_argument , NULL , 6 } , # endif { ""version"" , no_argument , NULL , 'v' } , { ""help"" , no_argument , NULL , 'h' } , { NULL , 0 , NULL , 0 } } ; curind = optind ; while ( longindex = - 1 , ( c = getopt_long ( argc , argv , "":vhlndu:DRS:f:p:i:mM::g::Gt::"" # if defined _WITH_VRRP_ && defined _WITH_LVS_ ""PC"" # endif # ifdef _WITH_VRRP_ ""r:VX"" # endif # ifdef _WITH_LVS_ ""ac:I"" # endif # ifdef _WITH_BFD_ ""Bb:"" # endif # ifdef _WITH_SNMP_ ""xA:"" # endif # ifdef _MEM_CHECK_LOG_ ""L"" # endif # if HAVE_DECL_CLONE_NEWNET ""s:"" # endif , long_options , & longindex ) ) != - 1 ) { if ( longindex >= 0 && long_options [ longindex ] . has_arg == required_argument && optarg && ! optarg [ 0 ] ) { c = ':' ; optarg = NULL ; } switch ( c ) { case 'v' : fprintf ( stderr , ""%s"" , version_string ) ; # ifdef GIT_COMMIT fprintf ( stderr , "",<S2SV_blank>git<S2SV_blank>commit<S2SV_blank>%s"" , GIT_COMMIT ) ; # endif fprintf ( stderr , ""\\n\\n%s\\n\\n"" , COPYRIGHT_STRING ) ; fprintf ( stderr , ""Built<S2SV_blank>with<S2SV_blank>kernel<S2SV_blank>headers<S2SV_blank>for<S2SV_blank>Linux<S2SV_blank>%d.%d.%d\\n"" , ( LINUX_VERSION_CODE >> 16 ) & 0xff , ( LINUX_VERSION_CODE >> 8 ) & 0xff , ( LINUX_VERSION_CODE ) & 0xff ) ; uname ( & uname_buf ) ; fprintf ( stderr , ""Running<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\n\\n"" , uname_buf . sysname , uname_buf . release , uname_buf . version ) ; fprintf ( stderr , ""configure<S2SV_blank>options:<S2SV_blank>%s\\n\\n"" , KEEPALIVED_CONFIGURE_OPTIONS ) ; fprintf ( stderr , ""Config<S2SV_blank>options:<S2SV_blank>%s\\n\\n"" , CONFIGURATION_OPTIONS ) ; fprintf ( stderr , ""System<S2SV_blank>options:<S2SV_blank>%s\\n"" , SYSTEM_OPTIONS ) ; exit ( 0 ) ; break ; case 'h' : usage ( argv [ 0 ] ) ; exit ( 0 ) ; break ; case 'l' : __set_bit ( LOG_CONSOLE_BIT , & debug ) ; reopen_log = true ; break ; case 'n' : __set_bit ( DONT_FORK_BIT , & debug ) ; break ; case 'd' : __set_bit ( DUMP_CONF_BIT , & debug ) ; break ; # ifdef _WITH_VRRP_ case 'V' : __set_bit ( DONT_RELEASE_VRRP_BIT , & debug ) ; break ; # endif # ifdef _WITH_LVS_ case 'I' : __set_bit ( DONT_RELEASE_IPVS_BIT , & debug ) ; break ; # endif case 'D' : if ( __test_bit ( LOG_DETAIL_BIT , & debug ) ) __set_bit ( LOG_EXTRA_DETAIL_BIT , & debug ) ; else __set_bit ( LOG_DETAIL_BIT , & debug ) ; break ; case 'R' : __set_bit ( DONT_RESPAWN_BIT , & debug ) ; break ; # ifdef _WITH_VRRP_ case 'X' : __set_bit ( RELEASE_VIPS_BIT , & debug ) ; break ; # endif case 'S' : if ( ! read_unsigned ( optarg , & facility , 0 , LOG_FACILITY_MAX , false ) ) fprintf ( stderr , ""Invalid<S2SV_blank>log<S2SV_blank>facility<S2SV_blank>\'%s\'\\n"" , optarg ) ; else { log_facility = LOG_FACILITY [ facility ] . facility ; reopen_log = true ; } break ; case 'g' : if ( optarg && optarg [ 0 ] ) log_file_name = optarg ; else log_file_name = ""/tmp/keepalived.log"" ; open_log_file ( log_file_name , NULL , NULL , NULL ) ; break ; case 'G' : __set_bit ( NO_SYSLOG_BIT , & debug ) ; reopen_log = true ; break ; case 'u' : new_umask_val = set_umask ( optarg ) ; if ( umask_cmdline ) umask_val = new_umask_val ; break ; case 't' : __set_bit ( CONFIG_TEST_BIT , & debug ) ; __set_bit ( DONT_RESPAWN_BIT , & debug ) ; __set_bit ( DONT_FORK_BIT , & debug ) ; __set_bit ( NO_SYSLOG_BIT , & debug ) ; if ( optarg && optarg [ 0 ] ) { <S2SV_StartBug> int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <S2SV_EndBug> if ( fd == - 1 ) { fprintf ( stderr , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config-test<S2SV_blank>log<S2SV_blank>file<S2SV_blank>%s\\n"" , optarg ) ; exit ( EXIT_FAILURE ) ; } dup2 ( fd , STDERR_FILENO ) ; close ( fd ) ; } break ; case 'f' : conf_file = optarg ; break ; case 2 : set_flush_log_file ( ) ; break ; # if defined _WITH_VRRP_ && defined _WITH_LVS_ case 'P' : __clear_bit ( DAEMON_CHECKERS , & daemon_mode ) ; break ; case 'C' : __clear_bit ( DAEMON_VRRP , & daemon_mode ) ; break ; # endif # ifdef _WITH_BFD_ case 'B' : __clear_bit ( DAEMON_BFD , & daemon_mode ) ; break ; # endif case 'p' : main_pidfile = optarg ; break ; # ifdef _WITH_LVS_ case 'c' : checkers_pidfile = optarg ; break ; case 'a' : __set_bit ( LOG_ADDRESS_CHANGES , & debug ) ; break ; # endif # ifdef _WITH_VRRP_ case 'r' : vrrp_pidfile = optarg ; break ; # endif # ifdef _WITH_BFD_ case 'b' : bfd_pidfile = optarg ; break ; # endif # ifdef _WITH_SNMP_ case 'x' : snmp = 1 ; break ; case 'A' : snmp_socket = optarg ; break ; # endif case 'M' : set_core_dump_pattern = true ; if ( optarg && optarg [ 0 ] ) core_dump_pattern = optarg ; case 'm' : create_core_dump = true ; break ; # ifdef _MEM_CHECK_LOG_ case 'L' : __set_bit ( MEM_CHECK_LOG_BIT , & debug ) ; break ; # endif # if HAVE_DECL_CLONE_NEWNET case 's' : override_namespace = MALLOC ( strlen ( optarg ) + 1 ) ; strcpy ( override_namespace , optarg ) ; break ; # endif case 'i' : FREE_PTR ( config_id ) ; config_id = MALLOC ( strlen ( optarg ) + 1 ) ; strcpy ( config_id , optarg ) ; break ; case 4 : signum = get_signum ( optarg ) ; if ( signum == - 1 ) { fprintf ( stderr , ""Unknown<S2SV_blank>sigfunc<S2SV_blank>%s\\n"" , optarg ) ; exit ( 1 ) ; } printf ( ""%d\\n"" , signum ) ; exit ( 0 ) ; break ; case 3 : __set_bit ( RUN_ALL_CHILDREN , & daemon_mode ) ; # ifdef _WITH_VRRP_ __set_bit ( DAEMON_VRRP , & daemon_mode ) ; # endif # ifdef _WITH_LVS_ __set_bit ( DAEMON_CHECKERS , & daemon_mode ) ; # endif # ifdef _WITH_BFD_ __set_bit ( DAEMON_BFD , & daemon_mode ) ; # endif break ; # ifdef _WITH_PERF_ case 5 : if ( optarg && optarg [ 0 ] ) { if ( ! strcmp ( optarg , ""run"" ) ) perf_run = PERF_RUN ; else if ( ! strcmp ( optarg , ""all"" ) ) perf_run = PERF_ALL ; else if ( ! strcmp ( optarg , ""end"" ) ) perf_run = PERF_END ; else log_message ( LOG_INFO , ""Unknown<S2SV_blank>perf<S2SV_blank>start<S2SV_blank>point<S2SV_blank>%s"" , optarg ) ; } else perf_run = PERF_RUN ; break ; # endif # ifdef WITH_DEBUG_OPTIONS case 6 : set_debug_options ( optarg && optarg [ 0 ] ? optarg : NULL ) ; break ; # endif case '?' : if ( optopt && argv [ curind ] [ 1 ] != '-' ) fprintf ( stderr , ""Unknown<S2SV_blank>option<S2SV_blank>-%c\\n"" , optopt ) ; else fprintf ( stderr , ""Unknown<S2SV_blank>option<S2SV_blank>%s\\n"" , argv [ curind ] ) ; bad_option = true ; break ; case ':' : if ( optopt && argv [ curind ] [ 1 ] != '-' ) fprintf ( stderr , ""Missing<S2SV_blank>parameter<S2SV_blank>for<S2SV_blank>option<S2SV_blank>-%c\\n"" , optopt ) ; else fprintf ( stderr , ""Missing<S2SV_blank>parameter<S2SV_blank>for<S2SV_blank>option<S2SV_blank>--%s\\n"" , long_options [ longindex ] . name ) ; bad_option = true ; break ; default : exit ( 1 ) ; break ; } curind = optind ; } if ( optind < argc ) { printf ( ""Unexpected<S2SV_blank>argument(s):<S2SV_blank>"" ) ; while ( optind < argc ) printf ( ""%s<S2SV_blank>"" , argv [ optind ++ ] ) ; printf ( ""\\n"" ) ; } if ( bad_option ) exit ( 1 ) ; return reopen_log ; }
","<S2SV_ModStart> O_APPEND | O_CREAT | O_NOFOLLOW
"
391,"CWE-617 <S2SV_StartBug> static void <S2SV_EndBug> modify_bar_registration ( struct pci_vdev * dev , int idx , int registration ) { int error ; struct inout_port iop ; struct mem_range mr ; if ( is_pci_gvt ( dev ) ) { printf ( ""modify_bar_registration:<S2SV_blank>bypass<S2SV_blank>for<S2SV_blank>pci-gvt\\n"" ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } switch ( dev -> bar [ idx ] . type ) { case PCIBAR_IO : bzero ( & iop , sizeof ( struct inout_port ) ) ; iop . name = dev -> name ; iop . port = dev -> bar [ idx ] . addr ; iop . size = dev -> bar [ idx ] . size ; if ( registration ) { iop . flags = IOPORT_F_INOUT ; iop . handler = pci_emul_io_handler ; iop . arg = dev ; error = register_inout ( & iop ) ; } else error = unregister_inout ( & iop ) ; break ; case PCIBAR_MEM32 : case PCIBAR_MEM64 : bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = dev -> name ; mr . base = dev -> bar [ idx ] . addr ; mr . size = dev -> bar [ idx ] . size ; if ( registration ) { mr . flags = MEM_F_RW ; mr . handler = pci_emul_mem_handler ; mr . arg1 = dev ; mr . arg2 = idx ; error = register_mem ( & mr ) ; } else error = unregister_mem ( & mr ) ; break ; default : error = EINVAL ; break ; } <S2SV_StartBug> assert ( error == 0 ) ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> modify_bar_registration ( struct <S2SV_ModStart> ) ; return 0 <S2SV_ModStart> break ; } return error <S2SV_ModEnd> ; } <S2SV_null>
"
392,"CWE-476 static ssize_t o2nm_node_local_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; <S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> unsigned long tmp ; char * p = ( char * ) page ; ssize_t ret ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\n' ) ) ) return - EINVAL ; tmp = ! ! tmp ; if ( ! test_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_NUM , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_PORT , & node -> nd_set_attributes ) ) return - EINVAL ; <S2SV_StartBug> if ( tmp && tmp == cluster -> cl_has_local && <S2SV_EndBug> cluster -> cl_local_node != node -> nd_num ) <S2SV_StartBug> return - EBUSY ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp && ! cluster -> cl_has_local ) { <S2SV_EndBug> ret = o2net_start_listening ( node ) ; if ( ret ) <S2SV_StartBug> return ret ; <S2SV_EndBug> } if ( ! tmp && cluster -> cl_has_local && cluster -> cl_local_node == node -> nd_num ) { o2net_stop_listening ( node ) ; cluster -> cl_local_node = O2NM_INVALID_NODE_NUM ; } node -> nd_local = tmp ; if ( node -> nd_local ) { cluster -> cl_has_local = tmp ; cluster -> cl_local_node = node -> nd_num ; } <S2SV_StartBug> return count ; <S2SV_EndBug> }
","<S2SV_ModStart> o2nm_cluster * cluster <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { ret = - EINVAL ; goto out ; } <S2SV_ModStart> -> nd_num ) { ret = <S2SV_ModEnd> - EBUSY ; <S2SV_ModStart> - EBUSY ; goto out ; } <S2SV_ModStart> ( ret ) goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> nd_num ; } ret = count ; out : o2nm_unlock_subsystem ( ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
"
393,"CWE-119 PTA * ptaReadStream ( FILE * fp ) { char typestr [ 128 ] ; l_int32 i , n , ix , iy , type , version ; l_float32 x , y ; PTA * pta ; PROCNAME ( ""ptaReadStream"" ) ; if ( ! fp ) return ( PTA * ) ERROR_PTR ( ""stream<S2SV_blank>not<S2SV_blank>defined"" , procName , NULL ) ; if ( fscanf ( fp , ""\\n<S2SV_blank>Pta<S2SV_blank>Version<S2SV_blank>%d\\n"" , & version ) != 1 ) return ( PTA * ) ERROR_PTR ( ""not<S2SV_blank>a<S2SV_blank>pta<S2SV_blank>file"" , procName , NULL ) ; if ( version != PTA_VERSION_NUMBER ) return ( PTA * ) ERROR_PTR ( ""invalid<S2SV_blank>pta<S2SV_blank>version"" , procName , NULL ) ; <S2SV_StartBug> if ( fscanf ( fp , ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%s\\n"" , & n , typestr ) != 2 ) <S2SV_EndBug> return ( PTA * ) ERROR_PTR ( ""not<S2SV_blank>a<S2SV_blank>pta<S2SV_blank>file"" , procName , NULL ) ; if ( ! strcmp ( typestr , ""float"" ) ) type = 0 ; else type = 1 ; if ( ( pta = ptaCreate ( n ) ) == NULL ) return ( PTA * ) ERROR_PTR ( ""pta<S2SV_blank>not<S2SV_blank>made"" , procName , NULL ) ; for ( i = 0 ; i < n ; i ++ ) { if ( type == 0 ) { if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank><S2SV_blank>(%f,<S2SV_blank>%f)\\n"" , & x , & y ) != 2 ) { ptaDestroy ( & pta ) ; return ( PTA * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>floats"" , procName , NULL ) ; } ptaAddPt ( pta , x , y ) ; } else { if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank><S2SV_blank>(%d,<S2SV_blank>%d)\\n"" , & ix , & iy ) != 2 ) { ptaDestroy ( & pta ) ; return ( PTA * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>ints"" , procName , NULL ) ; } ptaAddPt ( pta , ix , iy ) ; } } return pta ; }
","<S2SV_ModStart> ( fp , ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%127s\\n"" <S2SV_ModEnd> , & n
"
394,"CWE-125 static int _6502_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { char addrbuf [ 64 ] ; const int buffsize = sizeof ( addrbuf ) - 1 ; memset ( op , '\\0' , sizeof ( RAnalOp ) ) ; op -> size = snes_op_get_size ( 1 , 1 , & snes_op [ data [ 0 ] ] ) ; op -> addr = addr ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> id = data [ 0 ] ; r_strbuf_init ( & op -> esil ) ; switch ( data [ 0 ] ) { case 0x02 : case 0x03 : case 0x04 : case 0x07 : case 0x0b : case 0x0c : case 0x0f : case 0x12 : case 0x13 : case 0x14 : case 0x17 : case 0x1a : case 0x1b : case 0x1c : case 0x1f : case 0x22 : case 0x23 : case 0x27 : case 0x2b : case 0x2f : case 0x32 : case 0x33 : case 0x34 : case 0x37 : case 0x3a : case 0x3b : case 0x3c : case 0x3f : case 0x42 : case 0x43 : case 0x44 : case 0x47 : case 0x4b : case 0x4f : case 0x52 : case 0x53 : case 0x54 : case 0x57 : case 0x5a : case 0x5b : case 0x5c : case 0x5f : case 0x62 : case 0x63 : case 0x64 : case 0x67 : case 0x6b : case 0x6f : case 0x72 : case 0x73 : case 0x74 : case 0x77 : case 0x7a : case 0x7b : case 0x7c : case 0x7f : case 0x80 : case 0x82 : case 0x83 : case 0x87 : case 0x89 : case 0x8b : case 0x8f : case 0x92 : case 0x93 : case 0x97 : case 0x9b : case 0x9c : case 0x9e : case 0x9f : case 0xa3 : case 0xa7 : case 0xab : case 0xaf : case 0xb2 : case 0xb3 : case 0xb7 : case 0xbb : case 0xbf : case 0xc2 : case 0xc3 : case 0xc7 : case 0xcb : case 0xcf : case 0xd2 : case 0xd3 : case 0xd4 : case 0xd7 : case 0xda : case 0xdb : case 0xdc : case 0xdf : case 0xe2 : case 0xe3 : case 0xe7 : case 0xeb : case 0xef : case 0xf2 : case 0xf3 : case 0xf4 : case 0xf7 : case 0xfa : case 0xfb : case 0xfc : case 0xff : op -> size = 1 ; op -> type = R_ANAL_OP_TYPE_ILL ; break ; case 0x00 : op -> cycles = 7 ; op -> type = R_ANAL_OP_TYPE_SWI ; op -> size = 1 ; r_strbuf_set ( & op -> esil , "",1,I,=,0,D,=,flags,0x10,|,0x100,sp,+,=[1],pc,1,+,0xfe,sp,+,=[2],3,sp,-=,0xfffe,[2],pc,="" ) ; break ; case 0x78 : case 0x58 : case 0x38 : case 0x18 : case 0xf8 : case 0xd8 : case 0xb8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_NOP ; _6502_anal_esil_flags ( op , data [ 0 ] ) ; break ; case 0x24 : case 0x2c : op -> type = R_ANAL_OP_TYPE_MOV ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; r_strbuf_setf ( & op -> esil , ""a,%s,[1],&,0x80,&,!,!,N,=,a,%s,[1],&,0x40,&,!,!,V,=,a,%s,[1],&,0xff,&,!,Z,="" , addrbuf , addrbuf , addrbuf ) ; break ; case 0x69 : case 0x65 : case 0x75 : case 0x6d : case 0x7d : case 0x79 : case 0x61 : case 0x71 : op -> type = R_ANAL_OP_TYPE_ADD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x69 ) r_strbuf_setf ( & op -> esil , ""%s,a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; r_strbuf_append ( & op -> esil , "",a,a,=,$z,Z,="" ) ; break ; case 0xe9 : case 0xe5 : case 0xf5 : case 0xed : case 0xfd : case 0xf9 : case 0xe1 : case 0xf1 : op -> type = R_ANAL_OP_TYPE_SUB ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xe9 ) r_strbuf_setf ( & op -> esil , ""C,!,%s,+,a,-="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""C,!,%s,[1],+,a,-="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",a,a,=,$z,Z,=,C,!="" ) ; break ; case 0x09 : case 0x05 : case 0x15 : case 0x0d : case 0x1d : case 0x19 : case 0x01 : case 0x11 : op -> type = R_ANAL_OP_TYPE_OR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x09 ) r_strbuf_setf ( & op -> esil , ""%s,a,|="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,|="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x29 : case 0x25 : case 0x35 : case 0x2d : case 0x3d : case 0x39 : case 0x21 : case 0x31 : op -> type = R_ANAL_OP_TYPE_AND ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x29 ) r_strbuf_setf ( & op -> esil , ""%s,a,&="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,&="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x49 : case 0x45 : case 0x55 : case 0x4d : case 0x5d : case 0x59 : case 0x41 : case 0x51 : op -> type = R_ANAL_OP_TYPE_XOR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x49 ) r_strbuf_setf ( & op -> esil , ""%s,a,^="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,^="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x0a : case 0x06 : case 0x16 : case 0x0e : case 0x1e : op -> type = R_ANAL_OP_TYPE_SHL ; if ( data [ 0 ] == 0x0a ) { r_strbuf_set ( & op -> esil , ""1,a,<<=,$c7,C,=,a,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],<<,%s,=[1],$c7,C,="" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x4a : case 0x46 : case 0x56 : case 0x4e : case 0x5e : op -> type = R_ANAL_OP_TYPE_SHR ; if ( data [ 0 ] == 0x4a ) { r_strbuf_set ( & op -> esil , ""1,a,&,C,=,1,a,>>="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],&,C,=,1,%s,[1],>>,%s,=[1]"" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x2a : case 0x26 : case 0x36 : case 0x2e : case 0x3e : op -> type = R_ANAL_OP_TYPE_ROL ; if ( data [ 0 ] == 0x2a ) { r_strbuf_set ( & op -> esil , ""1,a,<<,C,|,a,=,$c7,C,=,a,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""1,%s,[1],<<,C,|,%s,=[1],$c7,C,="" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x6a : case 0x66 : case 0x76 : case 0x6e : case 0x7e : op -> type = R_ANAL_OP_TYPE_ROR ; if ( data [ 0 ] == 0x6a ) { r_strbuf_set ( & op -> esil , ""C,N,=,1,a,&,C,=,1,a,>>,7,N,<<,|,a,="" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""C,N,=,1,%s,[1],&,C,=,1,%s,[1],>>,7,N,<<,|,%s,=[1]"" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe6 : case 0xf6 : case 0xee : case 0xfe : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""%s,++=[1]"" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xc6 : case 0xd6 : case 0xce : case 0xde : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""%s,--=[1]"" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe8 : case 0xc8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , ""+"" ) ; break ; case 0xca : case 0x88 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , ""-"" ) ; break ; case 0xc9 : case 0xc5 : case 0xd5 : case 0xcd : case 0xdd : case 0xd9 : case 0xc1 : case 0xd1 : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xc9 ) r_strbuf_setf ( & op -> esil , ""%s,a,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0xe0 : case 0xe4 : case 0xec : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xe0 ) r_strbuf_setf ( & op -> esil , ""%s,x,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],x,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0xc0 : case 0xc4 : case 0xcc : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xc0 ) r_strbuf_setf ( & op -> esil , ""%s,y,=="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],y,=="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , "",C,!,C,="" ) ; break ; case 0x10 : case 0x30 : case 0x50 : case 0x70 : case 0x90 : case 0xb0 : case 0xd0 : case 0xf0 : op -> cycles = 2 ; op -> failcycles = 3 ; op -> type = R_ANAL_OP_TYPE_CJMP ; <S2SV_StartBug> if ( data [ 1 ] <= 127 ) <S2SV_EndBug> op -> jump = addr + data [ 1 ] + op -> size ; <S2SV_StartBug> else op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ; <S2SV_EndBug> <S2SV_StartBug> op -> fail = addr + op -> size ; <S2SV_EndBug> _6502_anal_esil_ccall ( op , data [ 0 ] ) ; break ; case 0x20 : op -> cycles = 6 ; op -> type = R_ANAL_OP_TYPE_CALL ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 2 ; r_strbuf_setf ( & op -> esil , ""1,pc,-,0xff,sp,+,=[2],0x%04x,pc,=,2,sp,-="" , op -> jump ) ; break ; case 0x4c : op -> cycles = 3 ; op -> type = R_ANAL_OP_TYPE_JMP ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; r_strbuf_setf ( & op -> esil , ""0x%04x,pc,="" , op -> jump ) ; break ; case 0x6c : op -> cycles = 5 ; op -> type = R_ANAL_OP_TYPE_UJMP ; r_strbuf_setf ( & op -> esil , ""0x%04x,[2],pc,="" , data [ 1 ] | data [ 2 ] << 8 ) ; break ; case 0x60 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 2 ; r_strbuf_set ( & op -> esil , ""0x101,sp,+,[2],pc,=,pc,++=,2,sp,+="" ) ; break ; case 0x40 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 3 ; r_strbuf_set ( & op -> esil , ""0x101,sp,+,[1],flags,=,0x102,sp,+,[2],pc,=,3,sp,+="" ) ; break ; case 0xea : op -> type = R_ANAL_OP_TYPE_NOP ; op -> cycles = 2 ; break ; case 0xa9 : case 0xa5 : case 0xb5 : case 0xad : case 0xbd : case 0xb9 : case 0xa1 : case 0xb1 : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xa9 ) r_strbuf_setf ( & op -> esil , ""%s,a,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],a,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa2 : case 0xa6 : case 0xb6 : case 0xae : case 0xbe : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; if ( data [ 0 ] == 0xa2 ) r_strbuf_setf ( & op -> esil , ""%s,x,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],x,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa0 : case 0xa4 : case 0xb4 : case 0xac : case 0xbc : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; if ( data [ 0 ] == 0xa0 ) r_strbuf_setf ( & op -> esil , ""%s,y,="" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , ""%s,[1],y,="" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x85 : case 0x95 : case 0x8d : case 0x9d : case 0x99 : case 0x81 : case 0x91 : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; r_strbuf_setf ( & op -> esil , ""a,%s,=[1]"" , addrbuf ) ; break ; case 0x86 : case 0x96 : case 0x8e : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; r_strbuf_setf ( & op -> esil , ""x,%s,=[1]"" , addrbuf ) ; break ; case 0x84 : case 0x94 : case 0x8c : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , ""y,%s,=[1]"" , addrbuf ) ; break ; case 0x08 : case 0x48 : op -> type = R_ANAL_OP_TYPE_PUSH ; op -> cycles = 3 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 1 ; _6502_anal_esil_push ( op , data [ 0 ] ) ; break ; case 0x28 : case 0x68 : op -> type = R_ANAL_OP_TYPE_POP ; op -> cycles = 4 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 1 ; _6502_anal_esil_pop ( op , data [ 0 ] ) ; break ; case 0xaa : case 0x8a : case 0xa8 : case 0x98 : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0x9a : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_SET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0xba : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_GET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; } return op -> size ; }
","<S2SV_ModStart> ; if ( len > 1 ) { if ( <S2SV_ModStart> <= 127 ) { <S2SV_ModStart> -> size ; } else { <S2SV_ModEnd> op -> jump <S2SV_ModStart> -> size ; } } else { op -> jump = addr ; }
"
395,"CWE-362 void sctp_generate_t3_rtx_event ( unsigned long peer ) { int error ; struct sctp_transport * transport = ( struct sctp_transport * ) peer ; struct sctp_association * asoc = transport -> asoc ; <S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\n"" , __func__ ) ; if ( ! mod_timer ( & transport -> T3_rtx_timer , jiffies + ( HZ / 20 ) ) ) sctp_transport_hold ( transport ) ; goto out_unlock ; } if ( transport -> dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( SCTP_EVENT_TIMEOUT_T3_RTX ) , asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; if ( error ) <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> out_unlock : <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> sctp_transport_put ( transport ) ; }
","<S2SV_ModStart> asoc ; struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> ( error ) <S2SV_ModEnd> sk -> sk_err <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;
"
396,"CWE-20 error_t httpParseRequestLine ( HttpConnection * connection , char_t * requestLine ) { error_t error ; char_t * token ; char_t * p ; char_t * s ; token = osStrtok_r ( requestLine , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_REQUEST ; error = strSafeCopy ( connection -> request . method , token , HTTP_SERVER_METHOD_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_REQUEST ; <S2SV_StartBug> s = strchr ( token , '?' ) ; <S2SV_EndBug> if ( s != NULL ) { * s = '\\0' ; error = httpDecodePercentEncodedString ( token , connection -> request . uri , HTTP_SERVER_URI_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; if ( osStrlen ( s + 1 ) > HTTP_SERVER_QUERY_STRING_MAX_LEN ) return ERROR_INVALID_REQUEST ; osStrcpy ( connection -> request . queryString , s + 1 ) ; } else { error = httpDecodePercentEncodedString ( token , connection -> request . uri , HTTP_SERVER_URI_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; connection -> request . queryString [ 0 ] = '\\0' ; } if ( ! osStrcasecmp ( connection -> request . uri , ""/"" ) ) osStrcpy ( connection -> request . uri , connection -> settings -> defaultDocument ) ; pathCanonicalize ( connection -> request . uri ) ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) { connection -> request . version = HTTP_VERSION_0_9 ; connection -> request . keepAlive = FALSE ; } else if ( ! osStrcasecmp ( token , ""HTTP/1.0"" ) ) { connection -> request . version = HTTP_VERSION_1_0 ; connection -> request . keepAlive = FALSE ; } else if ( ! osStrcasecmp ( token , ""HTTP/1.1"" ) ) { connection -> request . version = HTTP_VERSION_1_1 ; connection -> request . keepAlive = TRUE ; } else { return ERROR_INVALID_REQUEST ; } return NO_ERROR ; }
","<S2SV_ModStart> ; s = osStrchr <S2SV_ModEnd> ( token ,
"
397,"CWE-125 int write_output ( void ) { int fd ; struct filter_op * fop ; struct filter_header fh ; size_t ninst , i ; u_char * data ; ninst = compile_tree ( & fop ) ; if ( fop == NULL ) <S2SV_StartBug> return - E_NOTHANDLED ; <S2SV_EndBug> fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ; ON_ERROR ( fd , - 1 , ""Can\'t<S2SV_blank>create<S2SV_blank>file<S2SV_blank>%s"" , EF_GBL_OPTIONS -> output_file ) ; fprintf ( stdout , ""<S2SV_blank>Writing<S2SV_blank>output<S2SV_blank>to<S2SV_blank>\\\'%s\\\'<S2SV_blank>"" , EF_GBL_OPTIONS -> output_file ) ; fflush ( stdout ) ; fh . magic = htons ( EC_FILTER_MAGIC ) ; strncpy ( fh . version , EC_VERSION , sizeof ( fh . version ) ) ; fh . data = sizeof ( fh ) ; data = create_data_segment ( & fh , fop , ninst ) ; write ( fd , & fh , sizeof ( struct filter_header ) ) ; write ( fd , data , fh . code - fh . data ) ; for ( i = 0 ; i <= ninst ; i ++ ) { print_progress_bar ( & fop [ i ] ) ; write ( fd , & fop [ i ] , sizeof ( struct filter_op ) ) ; } close ( fd ) ; fprintf ( stdout , ""<S2SV_blank>done.\\n\\n"" ) ; fprintf ( stdout , ""<S2SV_blank>-><S2SV_blank>Script<S2SV_blank>encoded<S2SV_blank>into<S2SV_blank>%d<S2SV_blank>instructions.\\n\\n"" , ( int ) ( i - 1 ) ) ; return E_SUCCESS ; }
","<S2SV_ModStart> return - E_NOTHANDLED ; if ( ninst == 0 ) return - E_INVALID
"
398,"CWE-125 static int ospf6_print_lshdr ( netdissect_options * ndo , register const struct lsa6_hdr * lshp , const u_char * dataend ) { if ( ( const u_char * ) ( lshp + 1 ) > dataend ) goto trunc ; <S2SV_StartBug> ND_TCHECK ( lshp -> ls_type ) ; <S2SV_EndBug> ND_TCHECK ( lshp -> ls_seq ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertising<S2SV_blank>Router<S2SV_blank>%s,<S2SV_blank>seq<S2SV_blank>0x%08x,<S2SV_blank>age<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>%u"" , ipaddr_string ( ndo , & lshp -> ls_router ) , EXTRACT_32BITS ( & lshp -> ls_seq ) , EXTRACT_16BITS ( & lshp -> ls_age ) , EXTRACT_16BITS ( & lshp -> ls_length ) - ( u_int ) sizeof ( struct lsa6_hdr ) ) ) ; ospf6_print_ls_type ( ndo , EXTRACT_16BITS ( & lshp -> ls_type ) , & lshp -> ls_stateid ) ; return ( 0 ) ; trunc : return ( 1 ) ; }
","<S2SV_ModStart> ( lshp -> ls_length <S2SV_ModEnd> ) ; ND_PRINT
"
399,"CWE-190 <S2SV_StartBug> static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val ) <S2SV_EndBug> { int i ; int c ; for ( i = n ; i > 0 ; -- i ) { c = ( val >> ( 8 * ( i - 1 ) ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) return - 1 ; } return 0 ; }
","<S2SV_ModStart> int n , jas_ulonglong <S2SV_ModEnd> val ) {
"
400,"CWE-125 static int parse_elements ( netdissect_options * ndo , struct mgmt_body_t * pbody , const u_char * p , int offset , u_int length ) { u_int elementlen ; struct ssid_t ssid ; struct challenge_t challenge ; struct rates_t rates ; struct ds_t ds ; struct cf_t cf ; struct tim_t tim ; pbody -> challenge_present = 0 ; pbody -> ssid_present = 0 ; pbody -> rates_present = 0 ; pbody -> ds_present = 0 ; pbody -> cf_present = 0 ; pbody -> tim_present = 0 ; while ( length != 0 ) { if ( ! ND_TTEST2 ( * ( p + offset ) , 2 ) ) return 0 ; if ( length < 2 ) return 0 ; elementlen = * ( p + offset + 1 ) ; if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ; if ( length < elementlen + 2 ) return 0 ; switch ( * ( p + offset ) ) { case E_SSID : memcpy ( & ssid , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ssid . length != 0 ) { if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) return 0 ; if ( length < ssid . length ) return 0 ; memcpy ( & ssid . ssid , p + offset , ssid . length ) ; offset += ssid . length ; length -= ssid . length ; } ssid . ssid [ ssid . length ] = '\\0' ; if ( ! pbody -> ssid_present ) { pbody -> ssid = ssid ; pbody -> ssid_present = 1 ; } break ; case E_CHALLENGE : memcpy ( & challenge , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( challenge . length != 0 ) { if ( challenge . length > sizeof ( challenge . text ) - 1 ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) return 0 ; if ( length < challenge . length ) return 0 ; memcpy ( & challenge . text , p + offset , challenge . length ) ; offset += challenge . length ; length -= challenge . length ; } challenge . text [ challenge . length ] = '\\0' ; if ( ! pbody -> challenge_present ) { pbody -> challenge = challenge ; pbody -> challenge_present = 1 ; } break ; case E_RATES : memcpy ( & rates , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( rates . length != 0 ) { if ( rates . length > sizeof rates . rate ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) return 0 ; if ( length < rates . length ) return 0 ; memcpy ( & rates . rate , p + offset , rates . length ) ; offset += rates . length ; length -= rates . length ; } if ( ! pbody -> rates_present && rates . length != 0 ) { pbody -> rates = rates ; pbody -> rates_present = 1 ; } break ; case E_DS : memcpy ( & ds , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ds . length != 1 ) { offset += ds . length ; length -= ds . length ; break ; } ds . channel = * ( p + offset ) ; offset += 1 ; length -= 1 ; if ( ! pbody -> ds_present ) { pbody -> ds = ds ; pbody -> ds_present = 1 ; } break ; case E_CF : memcpy ( & cf , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( cf . length != 6 ) { offset += cf . length ; length -= cf . length ; break ; } memcpy ( & cf . count , p + offset , 6 ) ; offset += 6 ; length -= 6 ; if ( ! pbody -> cf_present ) { pbody -> cf = cf ; pbody -> cf_present = 1 ; } break ; case E_TIM : memcpy ( & tim , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( tim . length <= 3 ) { offset += tim . length ; length -= tim . length ; break ; } if ( tim . length - 3 > ( int ) sizeof tim . bitmap ) return 0 ; memcpy ( & tim . count , p + offset , 3 ) ; offset += 3 ; length -= 3 ; <S2SV_StartBug> memcpy ( tim . bitmap , p + ( tim . length - 3 ) , <S2SV_EndBug> <S2SV_StartBug> ( tim . length - 3 ) ) ; <S2SV_EndBug> offset += tim . length - 3 ; <S2SV_StartBug> length -= tim . length - 3 ; <S2SV_EndBug> if ( ! pbody -> tim_present ) { pbody -> tim = tim ; pbody -> tim_present = 1 ; } break ; default : # if 0 ND_PRINT ( ( ndo , ""(1)<S2SV_blank>unhandled<S2SV_blank>element_id<S2SV_blank>(%d)<S2SV_blank><S2SV_blank>"" , * ( p + offset ) ) ) ; # endif offset += 2 + elementlen ; length -= 2 + elementlen ; break ; } } return 1 ; }
","<S2SV_ModStart> , p + offset + 3 , <S2SV_ModEnd> tim . length <S2SV_ModStart> - 3 ) ; offset += <S2SV_ModEnd> tim . length <S2SV_ModStart> length - 3 ; length -= <S2SV_ModEnd> tim . length <S2SV_ModStart> - 3 ; <S2SV_ModEnd> if ( !
"
401,"CWE-416 static int splice_pipe_to_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , nbuf ; bool input_wakeup = false ; retry : ret = ipipe_prep ( ipipe , flags ) ; if ( ret ) return ret ; ret = opipe_prep ( opipe , flags ) ; if ( ret ) return ret ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( ! ipipe -> nrbufs && ! ipipe -> writers ) break ; if ( ! ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) { if ( ret ) break ; if ( flags & SPLICE_F_NONBLOCK ) { ret = - EAGAIN ; break ; } pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; goto retry ; } ibuf = ipipe -> bufs + ipipe -> curbuf ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; obuf = opipe -> bufs + nbuf ; if ( len >= ibuf -> len ) { * obuf = * ibuf ; ibuf -> ops = NULL ; opipe -> nrbufs ++ ; ipipe -> curbuf = ( ipipe -> curbuf + 1 ) & ( ipipe -> buffers - 1 ) ; ipipe -> nrbufs -- ; input_wakeup = true ; } else { <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; pipe_buf_mark_unmergeable ( obuf ) ; obuf -> len = len ; opipe -> nrbufs ++ ; ibuf -> offset += obuf -> len ; ibuf -> len -= obuf -> len ; } ret += obuf -> len ; len -= obuf -> len ; } while ( len ) ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; if ( input_wakeup ) wakeup_pipe_writers ( ipipe ) ; return ret ; }
","<S2SV_ModStart> } else { if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> * obuf =
"
402,"CWE-119 static void * load_bytes ( RBinFile * arch , const ut8 * buf , ut64 sz , ut64 loaddr , Sdb * sdb ) { if ( ! buf || ! sz || sz == UT64_MAX ) { return NULL ; } RBuffer * tbuf = r_buf_new ( ) ; <S2SV_StartBug> r_buf_set_bytes ( tbuf , buf , sz ) ; <S2SV_EndBug> struct r_bin_bflt_obj * res = r_bin_bflt_new_buf ( tbuf ) ; r_buf_free ( tbuf ) ; return res ? res : NULL ; }
","<S2SV_ModStart> ( ) ; if ( ! tbuf ) { return NULL ; }
"
403,"CWE-264 SYSCALL_DEFINE4 ( osf_wait4 , pid_t , pid , int __user * , ustatus , int , options , struct rusage32 __user * , ur ) { struct rusage r ; long ret , err ; <S2SV_StartBug> mm_segment_t old_fs ; <S2SV_EndBug> if ( ! ur ) return sys_wait4 ( pid , ustatus , options , NULL ) ; old_fs = get_fs ( ) ; set_fs ( KERNEL_DS ) ; <S2SV_StartBug> ret = sys_wait4 ( pid , ustatus , options , ( struct rusage __user * ) & r ) ; <S2SV_EndBug> set_fs ( old_fs ) ; if ( ! access_ok ( VERIFY_WRITE , ur , sizeof ( * ur ) ) ) return - EFAULT ; err = 0 ; <S2SV_StartBug> err |= __put_user ( r . ru_utime . tv_sec , & ur -> ru_utime . tv_sec ) ; <S2SV_EndBug> err |= __put_user ( r . ru_utime . tv_usec , & ur -> ru_utime . tv_usec ) ; err |= __put_user ( r . ru_stime . tv_sec , & ur -> ru_stime . tv_sec ) ; err |= __put_user ( r . ru_stime . tv_usec , & ur -> ru_stime . tv_usec ) ; err |= __put_user ( r . ru_maxrss , & ur -> ru_maxrss ) ; err |= __put_user ( r . ru_ixrss , & ur -> ru_ixrss ) ; err |= __put_user ( r . ru_idrss , & ur -> ru_idrss ) ; err |= __put_user ( r . ru_isrss , & ur -> ru_isrss ) ; err |= __put_user ( r . ru_minflt , & ur -> ru_minflt ) ; err |= __put_user ( r . ru_majflt , & ur -> ru_majflt ) ; err |= __put_user ( r . ru_nswap , & ur -> ru_nswap ) ; err |= __put_user ( r . ru_inblock , & ur -> ru_inblock ) ; err |= __put_user ( r . ru_oublock , & ur -> ru_oublock ) ; err |= __put_user ( r . ru_msgsnd , & ur -> ru_msgsnd ) ; err |= __put_user ( r . ru_msgrcv , & ur -> ru_msgrcv ) ; err |= __put_user ( r . ru_nsignals , & ur -> ru_nsignals ) ; err |= __put_user ( r . ru_nvcsw , & ur -> ru_nvcsw ) ; err |= __put_user ( r . ru_nivcsw , & ur -> ru_nivcsw ) ; return err ? err : ret ; }
","<S2SV_ModStart> , err ; unsigned int status = 0 ; <S2SV_ModStart> ( pid , ( unsigned int __user * ) & status <S2SV_ModEnd> , options , <S2SV_ModStart> ; err |= put_user ( status , ustatus ) ; err |=
"
404,"CWE-59 static int lxc_mount_auto_mounts ( struct lxc_conf * conf , int flags , struct lxc_handler * handler ) { int r ; size_t i ; static struct { int match_mask ; int match_flag ; const char * source ; const char * destination ; const char * fstype ; unsigned long flags ; const char * options ; } default_mounts [ ] = { { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""proc"" , ""%r/proc"" , ""proc"" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } , <S2SV_StartBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys/net"" , ""%r/proc/net"" , NULL , MS_BIND , NULL } , <S2SV_EndBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys"" , ""%r/proc/sys"" , NULL , MS_BIND , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , NULL , ""%r/proc/sys"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , <S2SV_StartBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/net"" , ""%r/proc/sys/net"" , NULL , MS_MOVE , NULL } , <S2SV_EndBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sysrq-trigger"" , ""%r/proc/sysrq-trigger"" , NULL , MS_BIND , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , NULL , ""%r/proc/sysrq-trigger"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_RW , ""proc"" , ""%r/proc"" , ""proc"" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_RW , ""sysfs"" , ""%r/sys"" , ""sysfs"" , 0 , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_RO , ""sysfs"" , ""%r/sys"" , ""sysfs"" , MS_RDONLY , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , ""sysfs"" , ""%r/sys"" , ""sysfs"" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , ""%r/sys"" , ""%r/sys"" , NULL , MS_BIND , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , NULL , ""%r/sys"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , ""sysfs"" , ""%r/sys/devices/virtual/net"" , ""sysfs"" , 0 , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , ""%r/sys/devices/virtual/net/devices/virtual/net"" , ""%r/sys/devices/virtual/net"" , NULL , MS_BIND , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , NULL , ""%r/sys/devices/virtual/net"" , NULL , MS_REMOUNT | MS_BIND | MS_NOSUID | MS_NODEV | MS_NOEXEC , NULL } , { 0 , 0 , NULL , NULL , NULL , 0 , NULL } } ; for ( i = 0 ; default_mounts [ i ] . match_mask ; i ++ ) { if ( ( flags & default_mounts [ i ] . match_mask ) == default_mounts [ i ] . match_flag ) { char * source = NULL ; char * destination = NULL ; int saved_errno ; unsigned long mflags ; if ( default_mounts [ i ] . source ) { source = lxc_string_replace ( ""%r"" , conf -> rootfs . path ? conf -> rootfs . mount : """" , default_mounts [ i ] . source ) ; if ( ! source ) { SYSERROR ( ""memory<S2SV_blank>allocation<S2SV_blank>error"" ) ; return - 1 ; } } if ( default_mounts [ i ] . destination ) { destination = lxc_string_replace ( ""%r"" , conf -> rootfs . path ? conf -> rootfs . mount : """" , default_mounts [ i ] . destination ) ; if ( ! destination ) { saved_errno = errno ; SYSERROR ( ""memory<S2SV_blank>allocation<S2SV_blank>error"" ) ; free ( source ) ; errno = saved_errno ; return - 1 ; } } mflags = add_required_remount_flags ( source , destination , default_mounts [ i ] . flags ) ; <S2SV_StartBug> r = mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options ) ; <S2SV_EndBug> saved_errno = errno ; if ( r < 0 && errno == ENOENT ) { INFO ( ""Mount<S2SV_blank>source<S2SV_blank>or<S2SV_blank>target<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>doesn\'t<S2SV_blank>exist.<S2SV_blank>Skipping."" , source , destination ) ; r = 0 ; } else if ( r < 0 ) SYSERROR ( ""error<S2SV_blank>mounting<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>flags<S2SV_blank>%lu"" , source , destination , mflags ) ; free ( source ) ; free ( destination ) ; if ( r < 0 ) { errno = saved_errno ; return - 1 ; } } } if ( flags & LXC_AUTO_CGROUP_MASK ) { int cg_flags ; cg_flags = flags & LXC_AUTO_CGROUP_MASK ; if ( cg_flags == LXC_AUTO_CGROUP_NOSPEC || cg_flags == LXC_AUTO_CGROUP_FULL_NOSPEC ) { int has_sys_admin = 0 ; if ( ! lxc_list_empty ( & conf -> keepcaps ) ) { has_sys_admin = in_caplist ( CAP_SYS_ADMIN , & conf -> keepcaps ) ; } else { has_sys_admin = ! in_caplist ( CAP_SYS_ADMIN , & conf -> caps ) ; } if ( cg_flags == LXC_AUTO_CGROUP_NOSPEC ) { cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_RW : LXC_AUTO_CGROUP_MIXED ; } else { cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_FULL_RW : LXC_AUTO_CGROUP_FULL_MIXED ; } } if ( ! cgroup_mount ( conf -> rootfs . path ? conf -> rootfs . mount : """" , handler , cg_flags ) ) { SYSERROR ( ""error<S2SV_blank>mounting<S2SV_blank>/sys/fs/cgroup"" ) ; return - 1 ; } } return 0 ; }
","<S2SV_ModStart> , ""%r/proc/sys/net"" , ""%r/proc/tty"" <S2SV_ModEnd> , NULL , <S2SV_ModStart> , LXC_AUTO_PROC_MIXED , ""%r/proc/tty"" <S2SV_ModEnd> , ""%r/proc/sys/net"" , <S2SV_ModStart> ; r = safe_mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options , conf -> rootfs . path ? conf -> rootfs . mount : NULL <S2SV_ModEnd> ) ; saved_errno
"
405,"CWE-20 stf_status ikev2parent_inI1outR1 ( struct msg_digest * md ) { struct state * st = md -> st ; lset_t policy = POLICY_IKEV2_ALLOW ; struct connection * c = find_host_connection ( & md -> iface -> ip_addr , md -> iface -> port , & md -> sender , md -> sender_port , POLICY_IKEV2_ALLOW ) ; # if 0 if ( c == NULL ) { pb_stream pre_sa_pbs = sa_pd -> pbs ; policy = preparse_isakmp_sa_body ( & pre_sa_pbs ) ; c = find_host_connection ( & md -> iface -> ip_addr , pluto_port , ( ip_address * ) NULL , md -> sender_port , policy ) ; } # endif if ( c == NULL ) { { struct connection * d ; d = find_host_connection ( & md -> iface -> ip_addr , pluto_port , ( ip_address * ) NULL , md -> sender_port , policy ) ; for ( ; d != NULL ; d = d -> hp_next ) { if ( d -> kind == CK_GROUP ) { } else { if ( d -> kind == CK_TEMPLATE && ! ( d -> policy & POLICY_OPPO ) ) { c = d ; break ; } if ( addrinsubnet ( & md -> sender , & d -> spd . that . client ) && ( c == NULL || ! subnetinsubnet ( & c -> spd . that . client , & d -> spd . that . client ) ) ) c = d ; } } } if ( c == NULL ) { loglog ( RC_LOG_SERIOUS , ""initial<S2SV_blank>parent<S2SV_blank>SA<S2SV_blank>message<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s:%u"" ""<S2SV_blank>but<S2SV_blank>no<S2SV_blank>connection<S2SV_blank>has<S2SV_blank>been<S2SV_blank>authorized%s%s"" , ip_str ( & md -> iface -> ip_addr ) , ntohs ( portof ( & md -> iface -> ip_addr ) ) , ( policy != LEMPTY ) ? ""<S2SV_blank>with<S2SV_blank>policy="" : """" , ( policy != LEMPTY ) ? bitnamesof ( sa_policy_bit_names , policy ) : """" ) ; return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN ; } if ( c -> kind != CK_TEMPLATE ) { loglog ( RC_LOG_SERIOUS , ""initial<S2SV_blank>parent<S2SV_blank>SA<S2SV_blank>message<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s:%u"" ""<S2SV_blank>but<S2SV_blank>\\""%s\\""<S2SV_blank>forbids<S2SV_blank>connection"" , ip_str ( & md -> iface -> ip_addr ) , pluto_port , c -> name ) ; return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN ; } c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } else { if ( ( c -> kind == CK_TEMPLATE ) && c -> spd . that . virt ) { DBG ( DBG_CONTROL , DBG_log ( ""local<S2SV_blank>endpoint<S2SV_blank>has<S2SV_blank>virt<S2SV_blank>(vnet/vhost)<S2SV_blank>set<S2SV_blank>without<S2SV_blank>wildcards<S2SV_blank>-<S2SV_blank>needs<S2SV_blank>instantiation"" ) ) ; c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } else if ( ( c -> kind == CK_TEMPLATE ) && ( c -> policy & POLICY_IKEV2_ALLOW_NARROWING ) ) { DBG ( DBG_CONTROL , DBG_log ( ""local<S2SV_blank>endpoint<S2SV_blank>has<S2SV_blank>narrowing=yes<S2SV_blank>-<S2SV_blank>needs<S2SV_blank>instantiation"" ) ) ; c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } } DBG_log ( ""found<S2SV_blank>connection:<S2SV_blank>%s\\n"" , c ? c -> name : ""<none>"" ) ; if ( ! st ) { st = new_state ( ) ; memcpy ( st -> st_icookie , md -> hdr . isa_icookie , COOKIE_SIZE ) ; get_cookie ( FALSE , st -> st_rcookie , COOKIE_SIZE , & md -> sender ) ; initialize_new_state ( st , c , policy , 0 , NULL_FD , pcim_stranger_crypto ) ; st -> st_ikev2 = TRUE ; change_state ( st , STATE_PARENT_R1 ) ; st -> st_msgid_lastack = INVALID_MSGID ; st -> st_msgid_nextuse = 0 ; md -> st = st ; md -> from_state = STATE_IKEv2_BASE ; } if ( force_busy == TRUE ) { u_char dcookie [ SHA1_DIGEST_SIZE ] ; chunk_t dc ; ikev2_get_dcookie ( dcookie , st -> st_ni , & md -> sender , st -> st_icookie ) ; dc . ptr = dcookie ; dc . len = SHA1_DIGEST_SIZE ; if ( md -> chain [ ISAKMP_NEXT_v2KE ] && md -> chain [ ISAKMP_NEXT_v2N ] && ( md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type == v2N_COOKIE ) ) { u_int8_t spisize ; const pb_stream * dc_pbs ; chunk_t blob ; DBG ( DBG_CONTROLMORE , DBG_log ( ""received<S2SV_blank>a<S2SV_blank>DOS<S2SV_blank>cookie<S2SV_blank>in<S2SV_blank>I1<S2SV_blank>verify<S2SV_blank>it"" ) ) ; spisize = md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_spisize ; dc_pbs = & md -> chain [ ISAKMP_NEXT_v2N ] -> pbs ; blob . ptr = dc_pbs -> cur + spisize ; blob . len = pbs_left ( dc_pbs ) - spisize ; DBG ( DBG_CONTROLMORE , DBG_dump_chunk ( ""dcookie<S2SV_blank>received<S2SV_blank>in<S2SV_blank>I1<S2SV_blank>Packet"" , blob ) ; DBG_dump ( ""dcookie<S2SV_blank>computed"" , dcookie , SHA1_DIGEST_SIZE ) ) ; if ( memcmp ( blob . ptr , dcookie , SHA1_DIGEST_SIZE ) != 0 ) { libreswan_log ( ""mismatch<S2SV_blank>in<S2SV_blank>DOS<S2SV_blank>v2N_COOKIE,send<S2SV_blank>a<S2SV_blank>new<S2SV_blank>one"" ) ; SEND_NOTIFICATION_AA ( v2N_COOKIE , & dc ) ; return STF_FAIL + v2N_INVALID_IKE_SPI ; } DBG ( DBG_CONTROLMORE , DBG_log ( ""dcookie<S2SV_blank>received<S2SV_blank>match<S2SV_blank>with<S2SV_blank>computed<S2SV_blank>one"" ) ) ; } else { DBG ( DBG_CONTROLMORE , DBG_log ( ""busy<S2SV_blank>mode<S2SV_blank>on.<S2SV_blank>receieved<S2SV_blank>I1<S2SV_blank>without<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>dcookie"" ) ; DBG_log ( ""send<S2SV_blank>a<S2SV_blank>dcookie<S2SV_blank>and<S2SV_blank>forget<S2SV_blank>this<S2SV_blank>state"" ) ) ; SEND_NOTIFICATION_AA ( v2N_COOKIE , & dc ) ; return STF_FAIL ; } } else { DBG ( DBG_CONTROLMORE , DBG_log ( ""will<S2SV_blank>not<S2SV_blank>send/process<S2SV_blank>a<S2SV_blank>dcookie"" ) ) ; } { struct ikev2_ke * ke ; <S2SV_StartBug> ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; <S2SV_EndBug> st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { char fromname [ ADDRTOT_BUF ] ; addrtot ( & md -> sender , 0 , fromname , ADDRTOT_BUF ) ; <S2SV_StartBug> libreswan_log ( <S2SV_EndBug> ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname , md -> sender_port , ke -> isak_group ) ; <S2SV_StartBug> return v2N_INVALID_KE_PAYLOAD ; <S2SV_EndBug> } } { struct ke_continuation * ke = alloc_thing ( struct ke_continuation , ""ikev2_inI1outR1<S2SV_blank>KE"" ) ; stf_status e ; ke -> md = md ; set_suspended ( st , ke -> md ) ; if ( ! st -> st_sec_in_use ) { pcrc_init ( & ke -> ke_pcrc ) ; ke -> ke_pcrc . pcrc_func = ikev2_parent_inI1outR1_continue ; e = build_ke ( & ke -> ke_pcrc , st , st -> st_oakley . group , pcim_stranger_crypto ) ; if ( e != STF_SUSPEND && e != STF_INLINE ) { loglog ( RC_CRYPTOFAILED , ""system<S2SV_blank>too<S2SV_blank>busy"" ) ; delete_state ( st ) ; } } else { e = ikev2_parent_inI1outR1_tail ( ( struct pluto_crypto_req_cont * ) ke , NULL ) ; } reset_globals ( ) ; return e ; } }
","<S2SV_ModStart> * ke ; <S2SV_ModEnd> char fromname [ <S2SV_ModStart> ADDRTOT_BUF ) ; if ( ! md -> chain [ ISAKMP_NEXT_v2KE ] ) { if ( md -> chain [ ISAKMP_NEXT_v2N ] ) { libreswan_log ( ""Received<S2SV_blank>Notify(%d):<S2SV_blank>%s"" , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type , enum_name ( & ikev2_notify_names , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type ) ) ; } libreswan_log ( ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>no<S2SV_blank>KE<S2SV_blank>payload<S2SV_blank>present"" , fromname , md -> sender_port ) ; return STF_FAIL + v2N_INVALID_KE_PAYLOAD ; } ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { libreswan_log ( <S2SV_ModEnd> ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname <S2SV_ModStart> ) ; return STF_FAIL +
"
406,"CWE-787 <S2SV_StartBug> void nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride ) <S2SV_EndBug> { <S2SV_StartBug> nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ; <S2SV_EndBug> if ( context -> ChromaSubsamplingLevel ) { <S2SV_StartBug> nsc_encode_subsampling ( context ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nsc_encode ( NSC_CONTEXT <S2SV_ModStart> rowstride ) { if ( ! context || ! bmpdata || ( rowstride == 0 ) ) return FALSE ; if ( ! <S2SV_ModStart> , rowstride ) ) return FALSE <S2SV_ModStart> ChromaSubsamplingLevel ) { if ( ! <S2SV_ModStart> ( context ) ) return FALSE ; } return TRUE ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
407,"CWE-119 <S2SV_StartBug> void vp9_tree_probs_from_distribution ( vp9_tree tree , <S2SV_EndBug> unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) { convert_distribution ( 0 , tree , branch_ct , num_events ) ; }
","<S2SV_ModStart> void vp9_tree_probs_from_distribution ( vpx_tree <S2SV_ModEnd> tree , unsigned
"
408,"CWE-119 static int hns_xgmac_get_sset_count ( int stringset ) { <S2SV_StartBug> if ( stringset == ETH_SS_STATS ) <S2SV_EndBug> return ARRAY_SIZE ( g_xgmac_stats_string ) ; return 0 ; }
","<S2SV_ModStart> stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS
"
409,"CWE-125 static inline size_t GetPSDRowSize ( Image * image ) { if ( image -> depth == 1 ) <S2SV_StartBug> return ( ( image -> columns + 7 ) / 8 ) ; <S2SV_EndBug> else return ( image -> columns * GetPSDPacketSize ( image ) ) ; }
","<S2SV_ModStart> return ( ( ( <S2SV_ModStart> ) / 8 ) * GetPSDPacketSize ( image )
"
410,"CWE-284 void bta_hh_co_open ( UINT8 dev_handle , UINT8 sub_class , tBTA_HH_ATTR_MASK attr_mask , UINT8 app_id ) { UINT32 i ; btif_hh_device_t * p_dev = NULL ; if ( dev_handle == BTA_HH_INVALID_HANDLE ) { APPL_TRACE_WARNING ( ""%s:<S2SV_blank>Oops,<S2SV_blank>dev_handle<S2SV_blank>(%d)<S2SV_blank>is<S2SV_blank>invalid..."" , __FUNCTION__ , dev_handle ) ; return ; } for ( i = 0 ; i < BTIF_HH_MAX_HID ; i ++ ) { p_dev = & btif_hh_cb . devices [ i ] ; if ( p_dev -> dev_status != BTHH_CONN_STATE_UNKNOWN && p_dev -> dev_handle == dev_handle ) { APPL_TRACE_WARNING ( ""%s:<S2SV_blank>Found<S2SV_blank>an<S2SV_blank>existing<S2SV_blank>device<S2SV_blank>with<S2SV_blank>the<S2SV_blank>same<S2SV_blank>handle<S2SV_blank>"" ""dev_status<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> dev_status ) ; APPL_TRACE_WARNING ( ""%s:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>bd_addr<S2SV_blank>=<S2SV_blank>[%02X:%02X:%02X:%02X:%02X:]"" , __FUNCTION__ , p_dev -> bd_addr . address [ 0 ] , p_dev -> bd_addr . address [ 1 ] , p_dev -> bd_addr . address [ 2 ] , p_dev -> bd_addr . address [ 3 ] , p_dev -> bd_addr . address [ 4 ] ) ; APPL_TRACE_WARNING ( ""%s:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>attr_mask<S2SV_blank>=<S2SV_blank>0x%04x,<S2SV_blank>sub_class<S2SV_blank>=<S2SV_blank>0x%02x,<S2SV_blank>app_id<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> attr_mask , p_dev -> sub_class , p_dev -> app_id ) ; if ( p_dev -> fd < 0 ) { <S2SV_StartBug> p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> if ( p_dev -> fd < 0 ) { APPL_TRACE_ERROR ( ""%s:<S2SV_blank>Error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>uhid,<S2SV_blank>err:%s"" , __FUNCTION__ , strerror ( errno ) ) ; return ; } else APPL_TRACE_DEBUG ( ""%s:<S2SV_blank>uhid<S2SV_blank>fd<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> fd ) ; } p_dev -> hh_keep_polling = 1 ; p_dev -> hh_poll_thread_id = create_thread ( btif_hh_poll_event_thread , p_dev ) ; break ; } p_dev = NULL ; } if ( p_dev == NULL ) { for ( i = 0 ; i < BTIF_HH_MAX_HID ; i ++ ) { if ( btif_hh_cb . devices [ i ] . dev_status == BTHH_CONN_STATE_UNKNOWN ) { p_dev = & btif_hh_cb . devices [ i ] ; p_dev -> dev_handle = dev_handle ; p_dev -> attr_mask = attr_mask ; p_dev -> sub_class = sub_class ; p_dev -> app_id = app_id ; p_dev -> local_vup = FALSE ; btif_hh_cb . device_num ++ ; <S2SV_StartBug> p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> if ( p_dev -> fd < 0 ) { APPL_TRACE_ERROR ( ""%s:<S2SV_blank>Error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>uhid,<S2SV_blank>err:%s"" , __FUNCTION__ , strerror ( errno ) ) ; return ; } else { APPL_TRACE_DEBUG ( ""%s:<S2SV_blank>uhid<S2SV_blank>fd<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> fd ) ; p_dev -> hh_keep_polling = 1 ; p_dev -> hh_poll_thread_id = create_thread ( btif_hh_poll_event_thread , p_dev ) ; } break ; } } } if ( p_dev == NULL ) { APPL_TRACE_ERROR ( ""%s:<S2SV_blank>Error:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>HID<S2SV_blank>devices<S2SV_blank>are<S2SV_blank>connected"" , __FUNCTION__ ) ; return ; } p_dev -> dev_status = BTHH_CONN_STATE_CONNECTED ; APPL_TRACE_DEBUG ( ""%s:<S2SV_blank>Return<S2SV_blank>device<S2SV_blank>status<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> dev_status ) ; }
","<S2SV_ModStart> -> fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> | O_CLOEXEC ) ) <S2SV_ModStart> -> fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> | O_CLOEXEC ) )
"
411,"CWE-000 static int ims_pcu_parse_cdc_data ( struct usb_interface * intf , struct ims_pcu * pcu ) { const struct usb_cdc_union_desc * union_desc ; struct usb_host_interface * alt ; union_desc = ims_pcu_get_cdc_union_desc ( intf ) ; if ( ! union_desc ) return - EINVAL ; pcu -> ctrl_intf = usb_ifnum_to_if ( pcu -> udev , union_desc -> bMasterInterface0 ) ; <S2SV_StartBug> alt = pcu -> ctrl_intf -> cur_altsetting ; <S2SV_EndBug> pcu -> ep_ctrl = & alt -> endpoint [ 0 ] . desc ; pcu -> max_ctrl_size = usb_endpoint_maxp ( pcu -> ep_ctrl ) ; pcu -> data_intf = usb_ifnum_to_if ( pcu -> udev , union_desc -> bSlaveInterface0 ) ; <S2SV_StartBug> alt = pcu -> data_intf -> cur_altsetting ; <S2SV_EndBug> if ( alt -> desc . bNumEndpoints != 2 ) { dev_err ( pcu -> dev , ""Incorrect<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints<S2SV_blank>on<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>(%d)\\n"" , alt -> desc . bNumEndpoints ) ; return - EINVAL ; } pcu -> ep_out = & alt -> endpoint [ 0 ] . desc ; if ( ! usb_endpoint_is_bulk_out ( pcu -> ep_out ) ) { dev_err ( pcu -> dev , ""First<S2SV_blank>endpoint<S2SV_blank>on<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>is<S2SV_blank>not<S2SV_blank>BULK<S2SV_blank>OUT\\n"" ) ; return - EINVAL ; } pcu -> max_out_size = usb_endpoint_maxp ( pcu -> ep_out ) ; if ( pcu -> max_out_size < 8 ) { dev_err ( pcu -> dev , ""Max<S2SV_blank>OUT<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%zd)\\n"" , pcu -> max_out_size ) ; return - EINVAL ; } pcu -> ep_in = & alt -> endpoint [ 1 ] . desc ; if ( ! usb_endpoint_is_bulk_in ( pcu -> ep_in ) ) { dev_err ( pcu -> dev , ""Second<S2SV_blank>endpoint<S2SV_blank>on<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>is<S2SV_blank>not<S2SV_blank>BULK<S2SV_blank>IN\\n"" ) ; return - EINVAL ; } pcu -> max_in_size = usb_endpoint_maxp ( pcu -> ep_in ) ; if ( pcu -> max_in_size < 8 ) { dev_err ( pcu -> dev , ""Max<S2SV_blank>IN<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%zd)\\n"" , pcu -> max_in_size ) ; return - EINVAL ; } return 0 ; }
","<S2SV_ModStart> bMasterInterface0 ) ; if ( ! pcu -> ctrl_intf ) return - EINVAL ; <S2SV_ModStart> bSlaveInterface0 ) ; if ( ! pcu -> data_intf ) return - EINVAL ;
"
412,"CWE-119 void dvb_usbv2_disconnect ( struct usb_interface * intf ) { struct dvb_usb_device * d = usb_get_intfdata ( intf ) ; <S2SV_StartBug> const char * name = d -> name ; <S2SV_EndBug> <S2SV_StartBug> struct device dev = d -> udev -> dev ; <S2SV_EndBug> dev_dbg ( & d -> udev -> dev , ""%s:<S2SV_blank>bInterfaceNumber=%d\\n"" , __func__ , intf -> cur_altsetting -> desc . bInterfaceNumber ) ; if ( d -> props -> exit ) d -> props -> exit ( d ) ; dvb_usbv2_exit ( d ) ; <S2SV_StartBug> dev_info ( & dev , ""%s:<S2SV_blank>\'%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n"" , <S2SV_EndBug> <S2SV_StartBug> KBUILD_MODNAME , name ) ; <S2SV_EndBug> }
","<S2SV_ModStart> const char * devname = kstrdup ( dev_name ( & <S2SV_ModEnd> d -> udev <S2SV_ModStart> udev -> dev ) , GFP_KERNEL ) ; const char * drvname = d -> name <S2SV_ModStart> d ) ; pr_info ( ""%s:<S2SV_blank>\'%s:%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n"" <S2SV_ModEnd> , KBUILD_MODNAME , <S2SV_ModStart> , KBUILD_MODNAME , drvname , devname ) ; kfree ( devname <S2SV_ModEnd> ) ; }
"
413,"CWE-125 static int jpc_pi_nextpcrl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; int compno ; jpc_picomp_t * picomp ; int xstep ; int ystep ; uint_fast32_t trx0 ; uint_fast32_t try0 ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> xstep = 0 ; pi -> ystep = 0 ; for ( compno = 0 , picomp = pi -> picomps ; compno < pi -> numcomps ; ++ compno , ++ picomp ) { for ( rlvlno = 0 , pirlvl = picomp -> pirlvls ; rlvlno < picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { <S2SV_StartBug> xstep = picomp -> hsamp * ( 1 << <S2SV_EndBug> ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; <S2SV_StartBug> ystep = picomp -> vsamp * ( 1 << <S2SV_EndBug> ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; pi -> xstep = ( ! pi -> xstep ) ? xstep : JAS_MIN ( pi -> xstep , xstep ) ; pi -> ystep = ( ! pi -> ystep ) ? ystep : JAS_MIN ( pi -> ystep , ystep ) ; } } pi -> prgvolfirst = 0 ; } for ( pi -> y = pi -> ystart ; pi -> y < pi -> yend ; pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) { for ( pi -> x = pi -> xstart ; pi -> x < pi -> xend ; pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { for ( pi -> rlvlno = pchg -> rlvlnostart , pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; pi -> rlvlno < pi -> picomp -> numrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno , ++ pi -> pirlvl ) { if ( pi -> pirlvl -> numprcs == 0 ) { continue ; } r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ; trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ; try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ; rpx = r + pi -> pirlvl -> prcwidthexpn ; rpy = r + pi -> pirlvl -> prcheightexpn ; <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || <S2SV_EndBug> ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || <S2SV_EndBug> ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) { prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ; prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ; pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ; assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if ( pi -> lyrno >= * prclyrno ) { ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } } } return 1 ; }
","<S2SV_ModStart> pirlvl ) { if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << ( pirlvl <S2SV_ModStart> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << ( pirlvl <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx ) <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy )
"
414,"CWE-416 extern int onig_new_deluxe ( regex_t * * reg , const UChar * pattern , const UChar * pattern_end , OnigCompileInfo * ci , OnigErrorInfo * einfo ) { int r ; UChar * cpat , * cpat_end ; if ( IS_NOT_NULL ( einfo ) ) einfo -> par = ( UChar * ) NULL ; if ( ci -> pattern_enc != ci -> target_enc ) { <S2SV_StartBug> r = conv_encoding ( ci -> pattern_enc , ci -> target_enc , pattern , pattern_end , <S2SV_EndBug> & cpat , & cpat_end ) ; if ( r != 0 ) return r ; } else { cpat = ( UChar * ) pattern ; cpat_end = ( UChar * ) pattern_end ; } * reg = ( regex_t * ) xmalloc ( sizeof ( regex_t ) ) ; if ( IS_NULL ( * reg ) ) { r = ONIGERR_MEMORY ; goto err2 ; } r = onig_reg_init ( * reg , ci -> option , ci -> case_fold_flag , ci -> target_enc , ci -> syntax ) ; if ( r != 0 ) goto err ; r = onig_compile ( * reg , cpat , cpat_end , einfo ) ; if ( r != 0 ) { err : onig_free ( * reg ) ; * reg = NULL ; } err2 : if ( cpat != pattern ) xfree ( cpat ) ; return r ; }
","<S2SV_ModStart> target_enc ) { return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION <S2SV_ModEnd> ; } else
"
415,"CWE-787 <S2SV_StartBug> static void InsertRow ( Image * image , ssize_t depth , unsigned char * p , ssize_t y , <S2SV_EndBug> ExceptionInfo * exception ) { <S2SV_StartBug> size_t bit ; ssize_t x ; <S2SV_EndBug> <S2SV_StartBug> register Quantum * q ; <S2SV_EndBug> Quantum index ; index = 0 ; <S2SV_StartBug> switch ( depth ) <S2SV_EndBug> { case 1 : { <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { <S2SV_StartBug> index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { <S2SV_StartBug> for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) <S2SV_EndBug> { <S2SV_StartBug> index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> } p ++ ; } <S2SV_StartBug> ( void ) SyncAuthenticPixels ( image , exception ) ; <S2SV_EndBug> break ; } case 2 : { <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> if ( q == ( Quantum * ) NULL ) <S2SV_EndBug> break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) >= 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) >= 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0xf , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> p ++ ; <S2SV_EndBug> } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } case 8 : { <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> if ( q == ( Quantum * ) NULL ) <S2SV_EndBug> break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> index = ConstrainColormapIndex ( image , * p , exception ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static MagickBooleanType <S2SV_ModEnd> InsertRow ( Image <S2SV_ModStart> image , ssize_t bpp <S2SV_ModEnd> , unsigned char <S2SV_ModStart> exception ) { int bit ; Quantum index <S2SV_ModEnd> ; register Quantum <S2SV_ModStart> ; register Quantum * q ; ssize_t x ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) return ( MagickFalse ) <S2SV_ModEnd> ; switch ( <S2SV_ModStart> ; switch ( bpp <S2SV_ModEnd> ) { case <S2SV_ModStart> 1 : { <S2SV_ModEnd> for ( x <S2SV_ModStart> index = ( <S2SV_ModEnd> ( * p <S2SV_ModStart> 0x80 >> bit <S2SV_ModEnd> ) ? 0x01 <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> bit < ( ssize_t ) ( <S2SV_ModStart> index = ( <S2SV_ModEnd> ( * p <S2SV_ModStart> 0x80 >> bit <S2SV_ModEnd> ) ? 0x01 <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> ++ ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> 2 : { for ( x = 0 ; x < ( ( ssize_t ) <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> columns - 3 ) ; x += 4 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 <S2SV_ModEnd> , exception ) <S2SV_ModStart> exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } break ; } case 4 : { <S2SV_ModEnd> for ( x <S2SV_ModStart> * p >> 4 ) & 0x0f <S2SV_ModEnd> , exception ) <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> ( * p ) & 0x0f <S2SV_ModEnd> , exception ) <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; <S2SV_ModStart> ( image ) <S2SV_ModEnd> ; } if <S2SV_ModStart> 4 ) & 0x0f <S2SV_ModEnd> , exception ) <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; <S2SV_ModStart> image ) ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> 8 : { for ( x = 0 ; x < ( ssize_t ) <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p <S2SV_ModEnd> , exception ) <S2SV_ModStart> exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } } break ; case 24 : <S2SV_ModEnd> for ( x <S2SV_ModStart> ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } if ( ! SyncAuthenticPixels ( image <S2SV_ModEnd> , exception ) <S2SV_ModStart> , exception ) ) return ( MagickFalse ) ; return ( MagickTrue ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
416,"CWE-125 static int cfm_network_addr_print ( netdissect_options * ndo , <S2SV_StartBug> register const u_char * tptr ) <S2SV_EndBug> { u_int network_addr_type ; <S2SV_StartBug> u_int hexdump = FALSE ; <S2SV_EndBug> network_addr_type = * tptr ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Network<S2SV_blank>Address<S2SV_blank>Type<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown"" , network_addr_type ) , network_addr_type ) ) ; switch ( network_addr_type ) { case AFNUM_INET : <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ; <S2SV_EndBug> break ; case AFNUM_INET6 : <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ; <S2SV_EndBug> break ; default : hexdump = TRUE ; break ; } return hexdump ; }
","<S2SV_ModStart> u_char * tptr , const u_int length ) { u_int network_addr_type ; u_int <S2SV_ModEnd> hexdump = FALSE <S2SV_ModStart> = FALSE ; if ( length < 1 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Network<S2SV_blank>Address<S2SV_blank>Type<S2SV_blank>(invalid,<S2SV_blank>no<S2SV_blank>data"" ) ) ; return hexdump ; } <S2SV_ModStart> case AFNUM_INET : if ( length != 1 + 4 ) { ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> case AFNUM_INET6 : if ( length != 1 + 16 ) { ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ; hexdump = TRUE ; break ; }
"
417,"CWE-264 static int em_sysexit ( struct x86_emulate_ctxt * ctxt ) { const struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ; <S2SV_StartBug> u64 msr_data ; <S2SV_EndBug> int usermode ; u16 cs_sel = 0 , ss_sel = 0 ; if ( ctxt -> mode == X86EMUL_MODE_REAL || ctxt -> mode == X86EMUL_MODE_VM86 ) return emulate_gp ( ctxt , 0 ) ; setup_syscalls_segments ( ctxt , & cs , & ss ) ; if ( ( ctxt -> rex_prefix & 0x8 ) != 0x0 ) usermode = X86EMUL_MODE_PROT64 ; else usermode = X86EMUL_MODE_PROT32 ; <S2SV_StartBug> cs . dpl = 3 ; <S2SV_EndBug> ss . dpl = 3 ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_CS , & msr_data ) ; switch ( usermode ) { case X86EMUL_MODE_PROT32 : cs_sel = ( u16 ) ( msr_data + 16 ) ; if ( ( msr_data & 0xfffc ) == 0x0 ) return emulate_gp ( ctxt , 0 ) ; ss_sel = ( u16 ) ( msr_data + 24 ) ; break ; case X86EMUL_MODE_PROT64 : cs_sel = ( u16 ) ( msr_data + 32 ) ; if ( msr_data == 0x0 ) return emulate_gp ( ctxt , 0 ) ; ss_sel = cs_sel + 8 ; cs . d = 0 ; cs . l = 1 ; <S2SV_StartBug> break ; <S2SV_EndBug> } cs_sel |= SELECTOR_RPL_MASK ; ss_sel |= SELECTOR_RPL_MASK ; ops -> set_segment ( ctxt , cs_sel , & cs , 0 , VCPU_SREG_CS ) ; ops -> set_segment ( ctxt , ss_sel , & ss , 0 , VCPU_SREG_SS ) ; <S2SV_StartBug> ctxt -> _eip = reg_read ( ctxt , VCPU_REGS_RDX ) ; <S2SV_EndBug> <S2SV_StartBug> * reg_write ( ctxt , VCPU_REGS_RSP ) = reg_read ( ctxt , VCPU_REGS_RCX ) ; <S2SV_EndBug> return X86EMUL_CONTINUE ; }
","<S2SV_ModStart> ; u64 msr_data , rcx , rdx <S2SV_ModStart> = X86EMUL_MODE_PROT32 ; rcx = reg_read ( ctxt , VCPU_REGS_RCX ) ; rdx = reg_read ( ctxt , VCPU_REGS_RDX ) ; <S2SV_ModStart> = 1 ; if ( is_noncanonical_address ( rcx ) || is_noncanonical_address ( rdx ) ) return emulate_gp ( ctxt , 0 ) ; <S2SV_ModStart> -> _eip = rdx <S2SV_ModEnd> ; * reg_write <S2SV_ModStart> VCPU_REGS_RSP ) = rcx <S2SV_ModEnd> ; return X86EMUL_CONTINUE
"
418,"CWE-362 static ssize_t driver_override_show ( struct device * dev , struct device_attribute * attr , char * buf ) { struct platform_device * pdev = to_platform_device ( dev ) ; <S2SV_StartBug> return sprintf ( buf , ""%s\\n"" , pdev -> driver_override ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> dev ) ; ssize_t len ; device_lock ( dev ) ; len = <S2SV_ModEnd> sprintf ( buf <S2SV_ModStart> driver_override ) ; device_unlock ( dev ) ; return len ;
"
419,"CWE-399 static int cms_copy_content ( BIO * out , BIO * in , unsigned int flags ) { unsigned char buf [ 4096 ] ; int r = 0 , i ; <S2SV_StartBug> BIO * tmpout = NULL ; <S2SV_EndBug> if ( out == NULL ) tmpout = BIO_new ( BIO_s_null ( ) ) ; else if ( flags & CMS_TEXT ) { <S2SV_StartBug> tmpout = BIO_new ( BIO_s_mem ( ) ) ; <S2SV_EndBug> BIO_set_mem_eof_return ( tmpout , 0 ) ; } else tmpout = out ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ; goto err ; } for ( ; ; ) { i = BIO_read ( in , buf , sizeof ( buf ) ) ; if ( i <= 0 ) { if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) { if ( ! BIO_get_cipher_status ( in ) ) goto err ; } if ( i < 0 ) goto err ; break ; } if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ; } if ( flags & CMS_TEXT ) { if ( ! SMIME_text ( tmpout , out ) ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , CMS_R_SMIME_TEXT_ERROR ) ; goto err ; } } r = 1 ; err : if ( tmpout && ( tmpout != out ) ) BIO_free ( tmpout ) ; return r ; }
","<S2SV_ModStart> BIO * tmpout ; tmpout = cms_get_text_bio ( out , flags ) ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ; goto err ; } for ( ; ; ) { i = BIO_read ( in , buf , sizeof ( buf ) ) ; if ( i <= 0 ) { if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) { if ( ! BIO_get_cipher_status ( in ) ) goto err ; } if ( i < 0 ) goto err ; break ; } if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ; } <S2SV_ModEnd> if ( flags <S2SV_ModStart> CMS_TEXT ) { <S2SV_ModEnd> if ( !
"
420,"CWE-264 static void on_response ( void * data , krb5_error_code retval , otp_response response ) { struct request_state rs = * ( struct request_state * ) data ; free ( data ) ; if ( retval == 0 && response != otp_response_success ) retval = KRB5_PREAUTH_FAILED ; <S2SV_StartBug> rs . respond ( rs . arg , retval , NULL , NULL , NULL ) ; <S2SV_EndBug> }
","<S2SV_ModStart> = KRB5_PREAUTH_FAILED ; if ( retval == 0 ) rs . enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ;
"
421,"CWE-119 <S2SV_StartBug> static void cost ( int * costs , vp9_tree tree , const vp9_prob * probs , <S2SV_EndBug> int i , int c ) { <S2SV_StartBug> const vp9_prob prob = probs [ i / 2 ] ; <S2SV_EndBug> int b ; for ( b = 0 ; b <= 1 ; ++ b ) { const int cc = c + vp9_cost_bit ( prob , b ) ; <S2SV_StartBug> const vp9_tree_index ii = tree [ i + b ] ; <S2SV_EndBug> if ( ii <= 0 ) costs [ - ii ] = cc ; else cost ( costs , tree , probs , ii , cc ) ; } }
","<S2SV_ModStart> * costs , vpx_tree <S2SV_ModEnd> tree , const <S2SV_ModStart> tree , const vpx_prob <S2SV_ModEnd> * probs , <S2SV_ModStart> ) { const vpx_prob <S2SV_ModEnd> prob = probs <S2SV_ModStart> ) ; const vpx_tree_index <S2SV_ModEnd> ii = tree
"
422,"CWE-59 void init_rc ( void ) { int i ; struct stat st ; FILE * f ; if ( rc_dir != NULL ) goto open_rc ; rc_dir = expandPath ( RC_DIR ) ; i = strlen ( rc_dir ) ; if ( i > 1 && rc_dir [ i - 1 ] == '/' ) rc_dir [ i - 1 ] = '\\0' ; # ifdef USE_M17N display_charset_str = wc_get_ces_list ( ) ; document_charset_str = display_charset_str ; system_charset_str = display_charset_str ; # endif if ( stat ( rc_dir , & st ) < 0 ) { if ( errno == ENOENT ) { if ( do_mkdir ( rc_dir , 0700 ) < 0 ) { goto rc_dir_err ; } else { stat ( rc_dir , & st ) ; } } else { goto rc_dir_err ; } } if ( ! S_ISDIR ( st . st_mode ) ) { goto rc_dir_err ; } if ( ! ( st . st_mode & S_IWUSR ) ) { goto rc_dir_err ; } no_rc_dir = FALSE ; tmp_dir = rc_dir ; if ( config_file == NULL ) config_file = rcFile ( CONFIG_FILE ) ; create_option_search_table ( ) ; open_rc : if ( ( f = fopen ( etcFile ( W3MCONFIG ) , ""rt"" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } if ( ( f = fopen ( confFile ( CONFIG_FILE ) , ""rt"" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } if ( config_file && ( f = fopen ( config_file , ""rt"" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } return ; rc_dir_err : no_rc_dir = TRUE ; if ( ( ( tmp_dir = getenv ( ""TMPDIR"" ) ) == NULL || * tmp_dir == '\\0' ) && ( ( tmp_dir = getenv ( ""TMP"" ) ) == NULL || * tmp_dir == '\\0' ) && ( ( tmp_dir = getenv ( ""TEMP"" ) ) == NULL || * tmp_dir == '\\0' ) ) tmp_dir = ""/tmp"" ; <S2SV_StartBug> create_option_search_table ( ) ; <S2SV_EndBug> goto open_rc ; }
","<S2SV_ModStart> = ""/tmp"" ; # ifdef HAVE_MKDTEMP tmp_dir = mkdtemp ( Strnew_m_charp ( tmp_dir , ""/w3m-XXXXXX"" , NULL ) -> ptr ) ; if ( tmp_dir == NULL ) tmp_dir = rc_dir ; # endif
"
423,"CWE-125 static inline void get_conn_text ( const conn * c , const int af , char * addr , struct sockaddr * sock_addr ) { char addr_text [ MAXPATHLEN ] ; addr_text [ 0 ] = '\\0' ; const char * protoname = ""?"" ; unsigned short port = 0 ; <S2SV_StartBug> switch ( af ) { <S2SV_EndBug> case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ; port = ntohs ( ( ( struct sockaddr_in * ) sock_addr ) -> sin_port ) ; protoname = IS_UDP ( c -> transport ) ? ""udp"" : ""tcp"" ; break ; case AF_INET6 : addr_text [ 0 ] = '[' ; addr_text [ 1 ] = '\\0' ; if ( inet_ntop ( af , & ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_addr , addr_text + 1 , sizeof ( addr_text ) - 2 ) ) { strcat ( addr_text , ""]"" ) ; } port = ntohs ( ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_port ) ; protoname = IS_UDP ( c -> transport ) ? ""udp6"" : ""tcp6"" ; break ; case AF_UNIX : <S2SV_StartBug> strncpy ( addr_text , <S2SV_EndBug> <S2SV_StartBug> ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , <S2SV_EndBug> sizeof ( addr_text ) - 1 ) ; addr_text [ sizeof ( addr_text ) - 1 ] = '\\0' ; protoname = ""unix"" ; break ; } if ( strlen ( addr_text ) < 2 ) { sprintf ( addr_text , ""<AF<S2SV_blank>%d>"" , af ) ; } if ( port ) { sprintf ( addr , ""%s:%s:%u"" , protoname , addr_text , port ) ; } else { sprintf ( addr , ""%s:%s"" , protoname , addr_text ) ; } }
","<S2SV_ModStart> = 0 ; size_t pathlen = 0 ; <S2SV_ModStart> case AF_UNIX : pathlen = sizeof ( <S2SV_ModEnd> ( ( struct <S2SV_ModStart> ) -> sun_path ) ; if ( MAXPATHLEN <= pathlen ) { pathlen = MAXPATHLEN - 1 ; } strncpy ( addr_text , ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , pathlen ) ; addr_text [ pathlen <S2SV_ModEnd> ] = '\\0'
"
424,"CWE-119 <S2SV_StartBug> static INLINE void write_buffer_16x16 ( int16_t * output , __m128i * in0 , <S2SV_EndBug> __m128i * in1 , int stride ) { write_buffer_8x8 ( output , in0 , stride ) ; write_buffer_8x8 ( output + 8 * stride , in0 + 8 , stride ) ; output += 8 ; write_buffer_8x8 ( output , in1 , stride ) ; write_buffer_8x8 ( output + 8 * stride , in1 + 8 , stride ) ; }
","<S2SV_ModStart> void write_buffer_16x16 ( tran_low_t <S2SV_ModEnd> * output ,
"
425,"CWE-189 int sequencer_write ( int dev , struct file * file , const char __user * buf , int count ) { unsigned char event_rec [ EV_SZ ] , ev_code ; int p = 0 , c , ev_size ; int mode = translate_mode ( file ) ; dev = dev >> 4 ; DEB ( printk ( ""sequencer_write(dev=%d,<S2SV_blank>count=%d)\\n"" , dev , count ) ) ; if ( mode == OPEN_READ ) return - EIO ; c = count ; while ( c >= 4 ) { if ( copy_from_user ( ( char * ) event_rec , & ( buf ) [ p ] , 4 ) ) goto out ; ev_code = event_rec [ 0 ] ; if ( ev_code == SEQ_FULLSIZE ) { int err , fmt ; dev = * ( unsigned short * ) & event_rec [ 2 ] ; if ( dev < 0 || dev >= max_synthdev || synth_devs [ dev ] == NULL ) return - ENXIO ; if ( ! ( synth_open_mask & ( 1 << dev ) ) ) return - ENXIO ; fmt = ( * ( short * ) & event_rec [ 0 ] ) & 0xffff ; <S2SV_StartBug> err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf , p + 4 , c , 0 ) ; <S2SV_EndBug> if ( err < 0 ) return err ; return err ; } if ( ev_code >= 128 ) { if ( seq_mode == SEQ_2 && ev_code == SEQ_EXTENDED ) { printk ( KERN_WARNING ""Sequencer:<S2SV_blank>Invalid<S2SV_blank>level<S2SV_blank>2<S2SV_blank>event<S2SV_blank>%x\\n"" , ev_code ) ; return - EINVAL ; } ev_size = 8 ; if ( c < ev_size ) { if ( ! seq_playing ) seq_startplay ( ) ; return count - c ; } if ( copy_from_user ( ( char * ) & event_rec [ 4 ] , & ( buf ) [ p + 4 ] , 4 ) ) goto out ; } else { if ( seq_mode == SEQ_2 ) { printk ( KERN_WARNING ""Sequencer:<S2SV_blank>4<S2SV_blank>byte<S2SV_blank>event<S2SV_blank>in<S2SV_blank>level<S2SV_blank>2<S2SV_blank>mode\\n"" ) ; return - EINVAL ; } ev_size = 4 ; if ( event_rec [ 0 ] != SEQ_MIDIPUTC ) obsolete_api_used = 1 ; } if ( event_rec [ 0 ] == SEQ_MIDIPUTC ) { if ( ! midi_opened [ event_rec [ 2 ] ] ) { int err , mode ; int dev = event_rec [ 2 ] ; if ( dev >= max_mididev || midi_devs [ dev ] == NULL ) { return - ENXIO ; } mode = translate_mode ( file ) ; if ( ( err = midi_devs [ dev ] -> open ( dev , mode , sequencer_midi_input , sequencer_midi_output ) ) < 0 ) { seq_reset ( ) ; printk ( KERN_WARNING ""Sequencer<S2SV_blank>Error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>Midi<S2SV_blank>#%d\\n"" , dev ) ; return err ; } midi_opened [ dev ] = 1 ; } } if ( ! seq_queue ( event_rec , ( file -> f_flags & ( O_NONBLOCK ) ? 1 : 0 ) ) ) { int processed = count - c ; if ( ! seq_playing ) seq_startplay ( ) ; if ( ! processed && ( file -> f_flags & O_NONBLOCK ) ) return - EAGAIN ; else return processed ; } p += ev_size ; c -= ev_size ; } if ( ! seq_playing ) seq_startplay ( ) ; out : return count ; }
","<S2SV_ModStart> fmt , buf + p <S2SV_ModEnd> , c ,
"
426,"CWE-399 static struct page * alloc_huge_page ( struct vm_area_struct * vma , unsigned long addr , int avoid_reserve ) { <S2SV_StartBug> struct hstate * h = hstate_vma ( vma ) ; <S2SV_EndBug> <S2SV_StartBug> struct page * page ; <S2SV_EndBug> struct address_space * mapping = vma -> vm_file -> f_mapping ; struct inode * inode = mapping -> host ; long chg ; chg = vma_needs_reservation ( h , vma , addr ) ; if ( chg < 0 ) return ERR_PTR ( - VM_FAULT_OOM ) ; if ( chg ) <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> return ERR_PTR ( - VM_FAULT_SIGBUS ) ; spin_lock ( & hugetlb_lock ) ; page = dequeue_huge_page_vma ( h , vma , addr , avoid_reserve ) ; spin_unlock ( & hugetlb_lock ) ; if ( ! page ) { page = alloc_buddy_huge_page ( h , NUMA_NO_NODE ) ; if ( ! page ) { <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug> return ERR_PTR ( - VM_FAULT_SIGBUS ) ; } } <S2SV_StartBug> set_page_private ( page , ( unsigned long ) mapping ) ; <S2SV_EndBug> vma_commit_reservation ( h , vma , addr ) ; return page ; }
","<S2SV_ModStart> ) { struct hugepage_subpool * spool = subpool_vma ( vma ) ; struct <S2SV_ModStart> page * page <S2SV_ModEnd> ; long chg <S2SV_ModStart> ) if ( hugepage_subpool_get_pages ( spool <S2SV_ModEnd> , chg ) <S2SV_ModStart> page ) { hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , chg ) <S2SV_ModStart> unsigned long ) spool <S2SV_ModEnd> ) ; vma_commit_reservation
"
427,"CWE-20 static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; <S2SV_StartBug> DPRINTF ( 4 , ( ""enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\'%s%s\'\\n"" , <S2SV_EndBug> filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; <S2SV_StartBug> filegen_flag = filegen -> flag ; <S2SV_EndBug> filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown<S2SV_blank>filegen<S2SV_blank>flag<S2SV_blank>token<S2SV_blank>%d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown<S2SV_blank>filegen<S2SV_blank>option<S2SV_blank>token<S2SV_blank>%d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
","<S2SV_ModStart> filegen_string ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , ""stats<S2SV_blank>%s<S2SV_blank>unrecognized"" , filegen_string ) ; continue ; } <S2SV_ModStart> filegen_file ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , ""filegen<S2SV_blank>category<S2SV_blank>\'%s\'<S2SV_blank>unrecognized"" , filegen_file ) ; continue ; }
"
428,"CWE-264 static void timer_enter_running ( Timer * t ) { _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL ; int r ; assert ( t ) ; if ( unit_stop_pending ( UNIT ( t ) ) ) return ; r = manager_add_job ( UNIT ( t ) -> manager , JOB_START , UNIT_TRIGGER ( UNIT ( t ) ) , JOB_REPLACE , true , & error , NULL ) ; if ( r < 0 ) goto fail ; dual_timestamp_get ( & t -> last_trigger ) ; if ( t -> stamp_path ) <S2SV_StartBug> touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> timer_set_state ( t , TIMER_RUNNING ) ; return ; fail : log_unit_warning ( UNIT ( t ) , ""Failed<S2SV_blank>to<S2SV_blank>queue<S2SV_blank>unit<S2SV_blank>startup<S2SV_blank>job:<S2SV_blank>%s"" , bus_error_message ( & error , r ) ) ; timer_enter_dead ( t , TIMER_FAILURE_RESOURCES ) ; }
","<S2SV_ModStart> , GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) ; timer_set_state
"
429,"CWE-119 <S2SV_StartBug> static void fadst16 ( const int16_t * input , int16_t * output ) { <S2SV_EndBug> <S2SV_StartBug> int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8 , s9 , s10 , s11 , s12 , s13 , s14 , s15 ; <S2SV_EndBug> <S2SV_StartBug> int x0 = input [ 15 ] ; <S2SV_EndBug> <S2SV_StartBug> int x1 = input [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> int x2 = input [ 13 ] ; <S2SV_EndBug> <S2SV_StartBug> int x3 = input [ 2 ] ; <S2SV_EndBug> <S2SV_StartBug> int x4 = input [ 11 ] ; <S2SV_EndBug> <S2SV_StartBug> int x5 = input [ 4 ] ; <S2SV_EndBug> <S2SV_StartBug> int x6 = input [ 9 ] ; <S2SV_EndBug> <S2SV_StartBug> int x7 = input [ 6 ] ; <S2SV_EndBug> <S2SV_StartBug> int x8 = input [ 7 ] ; <S2SV_EndBug> <S2SV_StartBug> int x9 = input [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int x10 = input [ 5 ] ; <S2SV_EndBug> <S2SV_StartBug> int x11 = input [ 10 ] ; <S2SV_EndBug> <S2SV_StartBug> int x12 = input [ 3 ] ; <S2SV_EndBug> <S2SV_StartBug> int x13 = input [ 12 ] ; <S2SV_EndBug> <S2SV_StartBug> int x14 = input [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> int x15 = input [ 14 ] ; <S2SV_EndBug> s0 = x0 * cospi_1_64 + x1 * cospi_31_64 ; s1 = x0 * cospi_31_64 - x1 * cospi_1_64 ; s2 = x2 * cospi_5_64 + x3 * cospi_27_64 ; s3 = x2 * cospi_27_64 - x3 * cospi_5_64 ; s4 = x4 * cospi_9_64 + x5 * cospi_23_64 ; s5 = x4 * cospi_23_64 - x5 * cospi_9_64 ; s6 = x6 * cospi_13_64 + x7 * cospi_19_64 ; s7 = x6 * cospi_19_64 - x7 * cospi_13_64 ; s8 = x8 * cospi_17_64 + x9 * cospi_15_64 ; s9 = x8 * cospi_15_64 - x9 * cospi_17_64 ; s10 = x10 * cospi_21_64 + x11 * cospi_11_64 ; s11 = x10 * cospi_11_64 - x11 * cospi_21_64 ; s12 = x12 * cospi_25_64 + x13 * cospi_7_64 ; s13 = x12 * cospi_7_64 - x13 * cospi_25_64 ; s14 = x14 * cospi_29_64 + x15 * cospi_3_64 ; s15 = x14 * cospi_3_64 - x15 * cospi_29_64 ; x0 = fdct_round_shift ( s0 + s8 ) ; x1 = fdct_round_shift ( s1 + s9 ) ; x2 = fdct_round_shift ( s2 + s10 ) ; x3 = fdct_round_shift ( s3 + s11 ) ; x4 = fdct_round_shift ( s4 + s12 ) ; x5 = fdct_round_shift ( s5 + s13 ) ; x6 = fdct_round_shift ( s6 + s14 ) ; x7 = fdct_round_shift ( s7 + s15 ) ; x8 = fdct_round_shift ( s0 - s8 ) ; x9 = fdct_round_shift ( s1 - s9 ) ; x10 = fdct_round_shift ( s2 - s10 ) ; x11 = fdct_round_shift ( s3 - s11 ) ; x12 = fdct_round_shift ( s4 - s12 ) ; x13 = fdct_round_shift ( s5 - s13 ) ; x14 = fdct_round_shift ( s6 - s14 ) ; x15 = fdct_round_shift ( s7 - s15 ) ; s0 = x0 ; s1 = x1 ; s2 = x2 ; s3 = x3 ; s4 = x4 ; s5 = x5 ; s6 = x6 ; s7 = x7 ; s8 = x8 * cospi_4_64 + x9 * cospi_28_64 ; s9 = x8 * cospi_28_64 - x9 * cospi_4_64 ; s10 = x10 * cospi_20_64 + x11 * cospi_12_64 ; s11 = x10 * cospi_12_64 - x11 * cospi_20_64 ; s12 = - x12 * cospi_28_64 + x13 * cospi_4_64 ; s13 = x12 * cospi_4_64 + x13 * cospi_28_64 ; s14 = - x14 * cospi_12_64 + x15 * cospi_20_64 ; s15 = x14 * cospi_20_64 + x15 * cospi_12_64 ; x0 = s0 + s4 ; x1 = s1 + s5 ; x2 = s2 + s6 ; x3 = s3 + s7 ; x4 = s0 - s4 ; x5 = s1 - s5 ; x6 = s2 - s6 ; x7 = s3 - s7 ; x8 = fdct_round_shift ( s8 + s12 ) ; x9 = fdct_round_shift ( s9 + s13 ) ; x10 = fdct_round_shift ( s10 + s14 ) ; x11 = fdct_round_shift ( s11 + s15 ) ; x12 = fdct_round_shift ( s8 - s12 ) ; x13 = fdct_round_shift ( s9 - s13 ) ; x14 = fdct_round_shift ( s10 - s14 ) ; x15 = fdct_round_shift ( s11 - s15 ) ; s0 = x0 ; s1 = x1 ; s2 = x2 ; s3 = x3 ; s4 = x4 * cospi_8_64 + x5 * cospi_24_64 ; s5 = x4 * cospi_24_64 - x5 * cospi_8_64 ; s6 = - x6 * cospi_24_64 + x7 * cospi_8_64 ; s7 = x6 * cospi_8_64 + x7 * cospi_24_64 ; s8 = x8 ; s9 = x9 ; s10 = x10 ; s11 = x11 ; s12 = x12 * cospi_8_64 + x13 * cospi_24_64 ; s13 = x12 * cospi_24_64 - x13 * cospi_8_64 ; s14 = - x14 * cospi_24_64 + x15 * cospi_8_64 ; s15 = x14 * cospi_8_64 + x15 * cospi_24_64 ; x0 = s0 + s2 ; x1 = s1 + s3 ; x2 = s0 - s2 ; x3 = s1 - s3 ; x4 = fdct_round_shift ( s4 + s6 ) ; x5 = fdct_round_shift ( s5 + s7 ) ; x6 = fdct_round_shift ( s4 - s6 ) ; x7 = fdct_round_shift ( s5 - s7 ) ; x8 = s8 + s10 ; x9 = s9 + s11 ; x10 = s8 - s10 ; x11 = s9 - s11 ; x12 = fdct_round_shift ( s12 + s14 ) ; x13 = fdct_round_shift ( s13 + s15 ) ; x14 = fdct_round_shift ( s12 - s14 ) ; x15 = fdct_round_shift ( s13 - s15 ) ; s2 = ( - cospi_16_64 ) * ( x2 + x3 ) ; s3 = cospi_16_64 * ( x2 - x3 ) ; s6 = cospi_16_64 * ( x6 + x7 ) ; s7 = cospi_16_64 * ( - x6 + x7 ) ; s10 = cospi_16_64 * ( x10 + x11 ) ; s11 = cospi_16_64 * ( - x10 + x11 ) ; s14 = ( - cospi_16_64 ) * ( x14 + x15 ) ; s15 = cospi_16_64 * ( x14 - x15 ) ; x2 = fdct_round_shift ( s2 ) ; x3 = fdct_round_shift ( s3 ) ; x6 = fdct_round_shift ( s6 ) ; x7 = fdct_round_shift ( s7 ) ; x10 = fdct_round_shift ( s10 ) ; x11 = fdct_round_shift ( s11 ) ; x14 = fdct_round_shift ( s14 ) ; x15 = fdct_round_shift ( s15 ) ; <S2SV_StartBug> output [ 0 ] = x0 ; <S2SV_EndBug> <S2SV_StartBug> output [ 1 ] = - x8 ; <S2SV_EndBug> <S2SV_StartBug> output [ 2 ] = x12 ; <S2SV_EndBug> <S2SV_StartBug> output [ 3 ] = - x4 ; <S2SV_EndBug> <S2SV_StartBug> output [ 4 ] = x6 ; <S2SV_EndBug> <S2SV_StartBug> output [ 5 ] = x14 ; <S2SV_EndBug> <S2SV_StartBug> output [ 6 ] = x10 ; <S2SV_EndBug> <S2SV_StartBug> output [ 7 ] = x2 ; <S2SV_EndBug> <S2SV_StartBug> output [ 8 ] = x3 ; <S2SV_EndBug> <S2SV_StartBug> output [ 9 ] = x11 ; <S2SV_EndBug> <S2SV_StartBug> output [ 10 ] = x15 ; <S2SV_EndBug> <S2SV_StartBug> output [ 11 ] = x7 ; <S2SV_EndBug> <S2SV_StartBug> output [ 12 ] = x5 ; <S2SV_EndBug> <S2SV_StartBug> output [ 13 ] = - x13 ; <S2SV_EndBug> <S2SV_StartBug> output [ 14 ] = x9 ; <S2SV_EndBug> <S2SV_StartBug> output [ 15 ] = - x1 ; <S2SV_EndBug> }
","<S2SV_ModStart> fadst16 ( const tran_low_t <S2SV_ModEnd> * input , <S2SV_ModStart> * input , tran_low_t <S2SV_ModEnd> * output ) <S2SV_ModStart> output ) { tran_high_t <S2SV_ModEnd> s0 , s1 <S2SV_ModStart> s7 , s8 ; tran_high_t <S2SV_ModEnd> s9 , s10 <S2SV_ModStart> , s15 ; tran_high_t <S2SV_ModEnd> x0 = input <S2SV_ModStart> 15 ] ; tran_high_t <S2SV_ModEnd> x1 = input <S2SV_ModStart> 0 ] ; tran_high_t <S2SV_ModEnd> x2 = input <S2SV_ModStart> 13 ] ; tran_high_t <S2SV_ModEnd> x3 = input <S2SV_ModStart> 2 ] ; tran_high_t <S2SV_ModEnd> x4 = input <S2SV_ModStart> 11 ] ; tran_high_t <S2SV_ModEnd> x5 = input <S2SV_ModStart> 4 ] ; tran_high_t <S2SV_ModEnd> x6 = input <S2SV_ModStart> 9 ] ; tran_high_t <S2SV_ModEnd> x7 = input <S2SV_ModStart> 6 ] ; tran_high_t <S2SV_ModEnd> x8 = input <S2SV_ModStart> 7 ] ; tran_high_t <S2SV_ModEnd> x9 = input <S2SV_ModStart> 8 ] ; tran_high_t <S2SV_ModEnd> x10 = input <S2SV_ModStart> 5 ] ; tran_high_t <S2SV_ModEnd> x11 = input <S2SV_ModStart> 10 ] ; tran_high_t <S2SV_ModEnd> x12 = input <S2SV_ModStart> 3 ] ; tran_high_t <S2SV_ModEnd> x13 = input <S2SV_ModStart> 12 ] ; tran_high_t <S2SV_ModEnd> x14 = input <S2SV_ModStart> 1 ] ; tran_high_t <S2SV_ModEnd> x15 = input <S2SV_ModStart> 0 ] = ( tran_low_t ) <S2SV_ModStart> 1 ] = ( tran_low_t ) <S2SV_ModStart> 2 ] = ( tran_low_t ) <S2SV_ModStart> 3 ] = ( tran_low_t ) <S2SV_ModStart> 4 ] = ( tran_low_t ) <S2SV_ModStart> 5 ] = ( tran_low_t ) <S2SV_ModStart> 6 ] = ( tran_low_t ) <S2SV_ModStart> 7 ] = ( tran_low_t ) <S2SV_ModStart> 8 ] = ( tran_low_t ) <S2SV_ModStart> 9 ] = ( tran_low_t ) <S2SV_ModStart> 10 ] = ( tran_low_t ) <S2SV_ModStart> 11 ] = ( tran_low_t ) <S2SV_ModStart> 12 ] = ( tran_low_t ) <S2SV_ModStart> 13 ] = ( tran_low_t ) <S2SV_ModStart> 14 ] = ( tran_low_t ) <S2SV_ModStart> 15 ] = ( tran_low_t )
"
430,"CWE-119 int arm_cpu_caps ( void ) { int flags ; int mask ; if ( ! arm_cpu_env_flags ( & flags ) ) { return flags ; } mask = arm_cpu_env_mask ( ) ; <S2SV_StartBug> # if HAVE_EDSP <S2SV_EndBug> flags |= HAS_EDSP ; # endif # if HAVE_MEDIA flags |= HAS_MEDIA ; # endif <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> flags |= HAS_NEON ; # endif return flags & mask ; }
","<S2SV_ModStart> ; # if <S2SV_ModEnd> HAVE_MEDIA flags |= <S2SV_ModStart> # if HAVE_NEON || HAVE_NEON_ASM
"
431,"CWE-119 <S2SV_StartBug> MB_PREDICTION_MODE vp9_left_block_mode ( const MODE_INFO * cur_mi , <S2SV_EndBug> const MODE_INFO * left_mi , int b ) { if ( b == 0 || b == 2 ) { if ( ! left_mi || is_inter_block ( & left_mi -> mbmi ) ) return DC_PRED ; return get_y_mode ( left_mi , b + 1 ) ; } else { assert ( b == 1 || b == 3 ) ; return cur_mi -> bmi [ b - 1 ] . as_mode ; } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> PREDICTION_MODE <S2SV_ModEnd> vp9_left_block_mode ( const
"
432,"CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> swabHorAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; TIFFSwabArrayOfShort ( wp , wc ) ; <S2SV_StartBug> horAcc16 ( tif , cp0 , cc ) ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> swabHorAcc16 ( TIFF <S2SV_ModStart> wc ) ; return
"
433,"CWE-416 struct ipv6_txoptions * ipv6_renew_options ( struct sock * sk , struct ipv6_txoptions * opt , int newtype , struct ipv6_opt_hdr __user * newopt , int newoptlen ) { int tot_len = 0 ; char * p ; struct ipv6_txoptions * opt2 ; int err ; if ( opt ) { if ( newtype != IPV6_HOPOPTS && opt -> hopopt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> hopopt ) ) ; if ( newtype != IPV6_RTHDRDSTOPTS && opt -> dst0opt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> dst0opt ) ) ; if ( newtype != IPV6_RTHDR && opt -> srcrt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> srcrt ) ) ; if ( newtype != IPV6_DSTOPTS && opt -> dst1opt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> dst1opt ) ) ; } if ( newopt && newoptlen ) tot_len += CMSG_ALIGN ( newoptlen ) ; if ( ! tot_len ) return NULL ; tot_len += sizeof ( * opt2 ) ; opt2 = sock_kmalloc ( sk , tot_len , GFP_ATOMIC ) ; if ( ! opt2 ) return ERR_PTR ( - ENOBUFS ) ; memset ( opt2 , 0 , tot_len ) ; <S2SV_StartBug> opt2 -> tot_len = tot_len ; <S2SV_EndBug> p = ( char * ) ( opt2 + 1 ) ; err = ipv6_renew_option ( opt ? opt -> hopopt : NULL , newopt , newoptlen , newtype != IPV6_HOPOPTS , & opt2 -> hopopt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> dst0opt : NULL , newopt , newoptlen , newtype != IPV6_RTHDRDSTOPTS , & opt2 -> dst0opt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> srcrt : NULL , newopt , newoptlen , newtype != IPV6_RTHDR , ( struct ipv6_opt_hdr * * ) & opt2 -> srcrt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> dst1opt : NULL , newopt , newoptlen , newtype != IPV6_DSTOPTS , & opt2 -> dst1opt , & p ) ; if ( err ) goto out ; opt2 -> opt_nflen = ( opt2 -> hopopt ? ipv6_optlen ( opt2 -> hopopt ) : 0 ) + ( opt2 -> dst0opt ? ipv6_optlen ( opt2 -> dst0opt ) : 0 ) + ( opt2 -> srcrt ? ipv6_optlen ( opt2 -> srcrt ) : 0 ) ; opt2 -> opt_flen = ( opt2 -> dst1opt ? ipv6_optlen ( opt2 -> dst1opt ) : 0 ) ; return opt2 ; out : sock_kfree_s ( sk , opt2 , opt2 -> tot_len ) ; return ERR_PTR ( err ) ; }
","<S2SV_ModStart> tot_len ) ; atomic_set ( & opt2 -> refcnt , 1 ) ;
"
434,"CWE-834 static int cine_read_header ( AVFormatContext * avctx ) { AVIOContext * pb = avctx -> pb ; AVStream * st ; unsigned int version , compression , offImageHeader , offSetup , offImageOffsets , biBitCount , length , CFA ; int vflip ; char * description ; uint64_t i ; st = avformat_new_stream ( avctx , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_RAWVIDEO ; st -> codecpar -> codec_tag = 0 ; avio_skip ( pb , 4 ) ; compression = avio_rl16 ( pb ) ; version = avio_rl16 ( pb ) ; if ( version != 1 ) { avpriv_request_sample ( avctx , ""unknown<S2SV_blank>version<S2SV_blank>%i"" , version ) ; return AVERROR_INVALIDDATA ; } avio_skip ( pb , 12 ) ; st -> duration = avio_rl32 ( pb ) ; offImageHeader = avio_rl32 ( pb ) ; offSetup = avio_rl32 ( pb ) ; offImageOffsets = avio_rl32 ( pb ) ; avio_skip ( pb , 8 ) ; avio_seek ( pb , offImageHeader , SEEK_SET ) ; avio_skip ( pb , 4 ) ; st -> codecpar -> width = avio_rl32 ( pb ) ; st -> codecpar -> height = avio_rl32 ( pb ) ; if ( avio_rl16 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; biBitCount = avio_rl16 ( pb ) ; if ( biBitCount != 8 && biBitCount != 16 && biBitCount != 24 && biBitCount != 48 ) { avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>biBitCount<S2SV_blank>%i"" , biBitCount ) ; return AVERROR_INVALIDDATA ; } switch ( avio_rl32 ( pb ) ) { case BMP_RGB : vflip = 0 ; break ; case 0x100 : st -> codecpar -> codec_tag = MKTAG ( 'B' , 'I' , 'T' , 0 ) ; vflip = 1 ; break ; default : avpriv_request_sample ( avctx , ""unknown<S2SV_blank>bitmap<S2SV_blank>compression"" ) ; return AVERROR_INVALIDDATA ; } avio_skip ( pb , 4 ) ; avio_seek ( pb , offSetup , SEEK_SET ) ; avio_skip ( pb , 140 ) ; if ( avio_rl16 ( pb ) != 0x5453 ) return AVERROR_INVALIDDATA ; length = avio_rl16 ( pb ) ; if ( length < 0x163C ) { avpriv_request_sample ( avctx , ""short<S2SV_blank>SETUP<S2SV_blank>header"" ) ; return AVERROR_INVALIDDATA ; } avio_skip ( pb , 616 ) ; if ( ! avio_rl32 ( pb ) ^ vflip ) { st -> codecpar -> extradata = av_strdup ( ""BottomUp"" ) ; st -> codecpar -> extradata_size = 9 ; } avio_skip ( pb , 4 ) ; avpriv_set_pts_info ( st , 64 , 1 , avio_rl32 ( pb ) ) ; avio_skip ( pb , 20 ) ; set_metadata_int ( & st -> metadata , ""camera_version"" , avio_rl32 ( pb ) , 0 ) ; set_metadata_int ( & st -> metadata , ""firmware_version"" , avio_rl32 ( pb ) , 0 ) ; set_metadata_int ( & st -> metadata , ""software_version"" , avio_rl32 ( pb ) , 0 ) ; set_metadata_int ( & st -> metadata , ""recording_timezone"" , avio_rl32 ( pb ) , 0 ) ; CFA = avio_rl32 ( pb ) ; set_metadata_int ( & st -> metadata , ""brightness"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""contrast"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""gamma"" , avio_rl32 ( pb ) , 1 ) ; avio_skip ( pb , 12 + 16 ) ; set_metadata_float ( & st -> metadata , ""wbgain[0].r"" , av_int2float ( avio_rl32 ( pb ) ) , 1 ) ; set_metadata_float ( & st -> metadata , ""wbgain[0].b"" , av_int2float ( avio_rl32 ( pb ) ) , 1 ) ; avio_skip ( pb , 36 ) ; st -> codecpar -> bits_per_coded_sample = avio_rl32 ( pb ) ; if ( compression == CC_RGB ) { if ( biBitCount == 8 ) { st -> codecpar -> format = AV_PIX_FMT_GRAY8 ; } else if ( biBitCount == 16 ) { st -> codecpar -> format = AV_PIX_FMT_GRAY16LE ; } else if ( biBitCount == 24 ) { st -> codecpar -> format = AV_PIX_FMT_BGR24 ; } else if ( biBitCount == 48 ) { st -> codecpar -> format = AV_PIX_FMT_BGR48LE ; } else { avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>biBitCount<S2SV_blank>%i"" , biBitCount ) ; return AVERROR_INVALIDDATA ; } } else if ( compression == CC_UNINT ) { switch ( CFA & 0xFFFFFF ) { case CFA_BAYER : if ( biBitCount == 8 ) { st -> codecpar -> format = AV_PIX_FMT_BAYER_GBRG8 ; } else if ( biBitCount == 16 ) { st -> codecpar -> format = AV_PIX_FMT_BAYER_GBRG16LE ; } else { avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>biBitCount<S2SV_blank>%i"" , biBitCount ) ; return AVERROR_INVALIDDATA ; } break ; case CFA_BAYERFLIP : if ( biBitCount == 8 ) { st -> codecpar -> format = AV_PIX_FMT_BAYER_RGGB8 ; } else if ( biBitCount == 16 ) { st -> codecpar -> format = AV_PIX_FMT_BAYER_RGGB16LE ; } else { avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>biBitCount<S2SV_blank>%i"" , biBitCount ) ; return AVERROR_INVALIDDATA ; } break ; default : avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>Color<S2SV_blank>Field<S2SV_blank>Array<S2SV_blank>(CFA)<S2SV_blank>%i"" , CFA & 0xFFFFFF ) ; return AVERROR_INVALIDDATA ; } } else { avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>compression<S2SV_blank>%i"" , compression ) ; return AVERROR_INVALIDDATA ; } avio_skip ( pb , 668 ) ; set_metadata_int ( & st -> metadata , ""shutter_ns"" , avio_rl32 ( pb ) , 0 ) ; avio_skip ( pb , 24 ) ; # define DESCRIPTION_SIZE 4096 description = av_malloc ( DESCRIPTION_SIZE + 1 ) ; if ( ! description ) return AVERROR ( ENOMEM ) ; i = avio_get_str ( pb , DESCRIPTION_SIZE , description , DESCRIPTION_SIZE + 1 ) ; if ( i < DESCRIPTION_SIZE ) avio_skip ( pb , DESCRIPTION_SIZE - i ) ; if ( description [ 0 ] ) av_dict_set ( & st -> metadata , ""description"" , description , AV_DICT_DONT_STRDUP_VAL ) ; else av_free ( description ) ; avio_skip ( pb , 1176 ) ; set_metadata_int ( & st -> metadata , ""enable_crop"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""crop_left"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""crop_top"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""crop_right"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""crop_bottom"" , avio_rl32 ( pb ) , 1 ) ; avio_seek ( pb , offImageOffsets , SEEK_SET ) ; <S2SV_StartBug> for ( i = 0 ; i < st -> duration ; i ++ ) <S2SV_EndBug> av_add_index_entry ( st , avio_rl64 ( pb ) , i , 0 , 0 , AVINDEX_KEYFRAME ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> AVINDEX_KEYFRAME ) ; }
"
435,"CWE-310 int asn1_ber_decoder ( const struct asn1_decoder * decoder , void * context , const unsigned char * data , size_t datalen ) { const unsigned char * machine = decoder -> machine ; const asn1_action_t * actions = decoder -> actions ; size_t machlen = decoder -> machlen ; enum asn1_opcode op ; unsigned char tag = 0 , csp = 0 , jsp = 0 , optag = 0 , hdr = 0 ; const char * errmsg ; size_t pc = 0 , dp = 0 , tdp = 0 , len = 0 ; int ret ; unsigned char flags = 0 ; # define FLAG_INDEFINITE_LENGTH 0x01 # define FLAG_MATCHED 0x02 # define FLAG_LAST_MATCHED 0x04 # define FLAG_CONS 0x20 # define NR_CONS_STACK 10 unsigned short cons_dp_stack [ NR_CONS_STACK ] ; unsigned short cons_datalen_stack [ NR_CONS_STACK ] ; unsigned char cons_hdrlen_stack [ NR_CONS_STACK ] ; # define NR_JUMP_STACK 10 unsigned char jump_stack [ NR_JUMP_STACK ] ; if ( datalen > 65535 ) return - EMSGSIZE ; next_op : pr_debug ( ""next_op:<S2SV_blank>pc=\\e[32m%zu\\e[m/%zu<S2SV_blank>dp=\\e[33m%zu\\e[m/%zu<S2SV_blank>C=%d<S2SV_blank>J=%d\\n"" , pc , machlen , dp , datalen , csp , jsp ) ; if ( unlikely ( pc >= machlen ) ) goto machine_overrun_error ; op = machine [ pc ] ; if ( unlikely ( pc + asn1_op_lengths [ op ] > machlen ) ) goto machine_overrun_error ; if ( op <= ASN1_OP__MATCHES_TAG ) { unsigned char tmp ; if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) || <S2SV_StartBug> dp == datalen ) { <S2SV_EndBug> flags &= ~ FLAG_LAST_MATCHED ; pc += asn1_op_lengths [ op ] ; goto next_op ; } flags = 0 ; hdr = 2 ; if ( unlikely ( dp >= datalen - 1 ) ) goto data_overrun_error ; tag = data [ dp ++ ] ; if ( unlikely ( ( tag & 0x1f ) == ASN1_LONG_TAG ) ) goto long_tag_not_supported ; if ( op & ASN1_OP_MATCH__ANY ) { pr_debug ( ""-<S2SV_blank>any<S2SV_blank>%02x\\n"" , tag ) ; } else { optag = machine [ pc + 1 ] ; flags |= optag & FLAG_CONS ; tmp = optag ^ tag ; tmp &= ~ ( optag & ASN1_CONS_BIT ) ; pr_debug ( ""-<S2SV_blank>match?<S2SV_blank>%02x<S2SV_blank>%02x<S2SV_blank>%02x\\n"" , tag , optag , tmp ) ; if ( tmp != 0 ) { if ( op & ASN1_OP_MATCH__SKIP ) { pc += asn1_op_lengths [ op ] ; dp -- ; goto next_op ; } goto tag_mismatch ; } } flags |= FLAG_MATCHED ; len = data [ dp ++ ] ; if ( len > 0x7f ) { if ( unlikely ( len == ASN1_INDEFINITE_LENGTH ) ) { if ( unlikely ( ! ( tag & ASN1_CONS_BIT ) ) ) goto indefinite_len_primitive ; flags |= FLAG_INDEFINITE_LENGTH ; if ( unlikely ( 2 > datalen - dp ) ) goto data_overrun_error ; } else { int n = len - 0x80 ; if ( unlikely ( n > 2 ) ) goto length_too_long ; if ( unlikely ( dp >= datalen - n ) ) goto data_overrun_error ; hdr += n ; for ( len = 0 ; n > 0 ; n -- ) { len <<= 8 ; len |= data [ dp ++ ] ; } if ( unlikely ( len > datalen - dp ) ) goto data_overrun_error ; } } if ( flags & FLAG_CONS ) { if ( unlikely ( csp >= NR_CONS_STACK ) ) goto cons_stack_overflow ; cons_dp_stack [ csp ] = dp ; cons_hdrlen_stack [ csp ] = hdr ; if ( ! ( flags & FLAG_INDEFINITE_LENGTH ) ) { cons_datalen_stack [ csp ] = datalen ; datalen = dp + len ; } else { cons_datalen_stack [ csp ] = 0 ; } csp ++ ; } pr_debug ( ""-<S2SV_blank>TAG:<S2SV_blank>%02x<S2SV_blank>%zu%s\\n"" , tag , len , flags & FLAG_CONS ? ""<S2SV_blank>CONS"" : """" ) ; tdp = dp ; } switch ( op ) { case ASN1_OP_MATCH_ANY_ACT : case ASN1_OP_COND_MATCH_ANY_ACT : ret = actions [ machine [ pc + 1 ] ] ( context , hdr , tag , data + dp , len ) ; if ( ret < 0 ) return ret ; goto skip_data ; case ASN1_OP_MATCH_ACT : case ASN1_OP_MATCH_ACT_OR_SKIP : case ASN1_OP_COND_MATCH_ACT_OR_SKIP : ret = actions [ machine [ pc + 2 ] ] ( context , hdr , tag , data + dp , len ) ; if ( ret < 0 ) return ret ; goto skip_data ; case ASN1_OP_MATCH : case ASN1_OP_MATCH_OR_SKIP : case ASN1_OP_MATCH_ANY : case ASN1_OP_COND_MATCH_OR_SKIP : case ASN1_OP_COND_MATCH_ANY : skip_data : if ( ! ( flags & FLAG_CONS ) ) { if ( flags & FLAG_INDEFINITE_LENGTH ) { ret = asn1_find_indefinite_length ( data , datalen , & dp , & len , & errmsg ) ; if ( ret < 0 ) goto error ; } else { dp += len ; } pr_debug ( ""-<S2SV_blank>LEAF:<S2SV_blank>%zu\\n"" , len ) ; } pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_MATCH_JUMP : case ASN1_OP_MATCH_JUMP_OR_SKIP : case ASN1_OP_COND_MATCH_JUMP_OR_SKIP : pr_debug ( ""-<S2SV_blank>MATCH_JUMP\\n"" ) ; if ( unlikely ( jsp == NR_JUMP_STACK ) ) goto jump_stack_overflow ; jump_stack [ jsp ++ ] = pc + asn1_op_lengths [ op ] ; pc = machine [ pc + 2 ] ; goto next_op ; case ASN1_OP_COND_FAIL : if ( unlikely ( ! ( flags & FLAG_MATCHED ) ) ) goto tag_mismatch ; pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_COMPLETE : if ( unlikely ( jsp != 0 || csp != 0 ) ) { pr_err ( ""ASN.1<S2SV_blank>decoder<S2SV_blank>error:<S2SV_blank>Stacks<S2SV_blank>not<S2SV_blank>empty<S2SV_blank>at<S2SV_blank>completion<S2SV_blank>(%u,<S2SV_blank>%u)\\n"" , jsp , csp ) ; return - EBADMSG ; } return 0 ; case ASN1_OP_END_SET : case ASN1_OP_END_SET_ACT : if ( unlikely ( ! ( flags & FLAG_MATCHED ) ) ) goto tag_mismatch ; case ASN1_OP_END_SEQ : case ASN1_OP_END_SET_OF : case ASN1_OP_END_SEQ_OF : case ASN1_OP_END_SEQ_ACT : case ASN1_OP_END_SET_OF_ACT : case ASN1_OP_END_SEQ_OF_ACT : if ( unlikely ( csp <= 0 ) ) goto cons_stack_underflow ; csp -- ; tdp = cons_dp_stack [ csp ] ; hdr = cons_hdrlen_stack [ csp ] ; len = datalen ; datalen = cons_datalen_stack [ csp ] ; pr_debug ( ""-<S2SV_blank>end<S2SV_blank>cons<S2SV_blank>t=%zu<S2SV_blank>dp=%zu<S2SV_blank>l=%zu/%zu\\n"" , tdp , dp , len , datalen ) ; if ( datalen == 0 ) { datalen = len ; if ( unlikely ( datalen - dp < 2 ) ) goto data_overrun_error ; if ( data [ dp ++ ] != 0 ) { if ( op & ASN1_OP_END__OF ) { dp -- ; csp ++ ; pc = machine [ pc + 1 ] ; pr_debug ( ""-<S2SV_blank>continue\\n"" ) ; goto next_op ; } goto missing_eoc ; } if ( data [ dp ++ ] != 0 ) goto invalid_eoc ; len = dp - tdp - 2 ; } else { if ( dp < len && ( op & ASN1_OP_END__OF ) ) { datalen = len ; csp ++ ; pc = machine [ pc + 1 ] ; pr_debug ( ""-<S2SV_blank>continue\\n"" ) ; goto next_op ; } if ( dp != len ) goto cons_length_error ; len -= tdp ; pr_debug ( ""-<S2SV_blank>cons<S2SV_blank>len<S2SV_blank>l=%zu<S2SV_blank>d=%zu\\n"" , len , dp - tdp ) ; } if ( op & ASN1_OP_END__ACT ) { unsigned char act ; if ( op & ASN1_OP_END__OF ) act = machine [ pc + 2 ] ; else act = machine [ pc + 1 ] ; ret = actions [ act ] ( context , hdr , 0 , data + tdp , len ) ; } pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_MAYBE_ACT : if ( ! ( flags & FLAG_LAST_MATCHED ) ) { pc += asn1_op_lengths [ op ] ; goto next_op ; } case ASN1_OP_ACT : ret = actions [ machine [ pc + 1 ] ] ( context , hdr , tag , data + tdp , len ) ; if ( ret < 0 ) return ret ; pc += asn1_op_lengths [ op ] ; goto next_op ; case ASN1_OP_RETURN : if ( unlikely ( jsp <= 0 ) ) goto jump_stack_underflow ; pc = jump_stack [ -- jsp ] ; flags |= FLAG_MATCHED | FLAG_LAST_MATCHED ; goto next_op ; default : break ; } pr_err ( ""ASN.1<S2SV_blank>decoder<S2SV_blank>error:<S2SV_blank>Found<S2SV_blank>reserved<S2SV_blank>opcode<S2SV_blank>(%u)<S2SV_blank>pc=%zu\\n"" , op , pc ) ; return - EBADMSG ; data_overrun_error : errmsg = ""Data<S2SV_blank>overrun<S2SV_blank>error"" ; goto error ; machine_overrun_error : errmsg = ""Machine<S2SV_blank>overrun<S2SV_blank>error"" ; goto error ; jump_stack_underflow : errmsg = ""Jump<S2SV_blank>stack<S2SV_blank>underflow"" ; goto error ; jump_stack_overflow : errmsg = ""Jump<S2SV_blank>stack<S2SV_blank>overflow"" ; goto error ; cons_stack_underflow : errmsg = ""Cons<S2SV_blank>stack<S2SV_blank>underflow"" ; goto error ; cons_stack_overflow : errmsg = ""Cons<S2SV_blank>stack<S2SV_blank>overflow"" ; goto error ; cons_length_error : errmsg = ""Cons<S2SV_blank>length<S2SV_blank>error"" ; goto error ; missing_eoc : errmsg = ""Missing<S2SV_blank>EOC<S2SV_blank>in<S2SV_blank>indefinite<S2SV_blank>len<S2SV_blank>cons"" ; goto error ; invalid_eoc : errmsg = ""Invalid<S2SV_blank>length<S2SV_blank>EOC"" ; goto error ; length_too_long : errmsg = ""Unsupported<S2SV_blank>length"" ; goto error ; indefinite_len_primitive : errmsg = ""Indefinite<S2SV_blank>len<S2SV_blank>primitive<S2SV_blank>not<S2SV_blank>permitted"" ; goto error ; tag_mismatch : errmsg = ""Unexpected<S2SV_blank>tag"" ; goto error ; long_tag_not_supported : errmsg = ""Long<S2SV_blank>tag<S2SV_blank>not<S2SV_blank>supported"" ; error : pr_debug ( ""\\nASN1:<S2SV_blank>%s<S2SV_blank>[m=%zu<S2SV_blank>d=%zu<S2SV_blank>ot=%02x<S2SV_blank>t=%02x<S2SV_blank>l=%zu]\\n"" , errmsg , pc , dp , optag , tag , len ) ; return - EBADMSG ; }
","<S2SV_ModStart> FLAG_MATCHED ) || ( op & ASN1_OP_MATCH__SKIP && <S2SV_ModStart> dp == datalen )
"
436,"CWE-264 static int cg_rmdir ( const char * path ) { struct fuse_context * fc = fuse_get_context ( ) ; <S2SV_StartBug> char * fpath = NULL , * cgdir = NULL , * controller ; <S2SV_EndBug> const char * cgroup ; int ret ; if ( ! fc ) return - EIO ; controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EINVAL ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) return - EINVAL ; get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) { ret = - EINVAL ; goto out ; } <S2SV_StartBug> fprintf ( stderr , ""rmdir:<S2SV_blank>verifying<S2SV_blank>access<S2SV_blank>to<S2SV_blank>%s:%s<S2SV_blank>(req<S2SV_blank>path<S2SV_blank>%s)\\n"" , <S2SV_EndBug> controller , cgdir , path ) ; if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY ) ) { ret = - EACCES ; goto out ; } <S2SV_StartBug> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { <S2SV_EndBug> ret = - EACCES ; goto out ; } <S2SV_StartBug> if ( ! cgfs_remove ( controller , cgroup ) ) { <S2SV_EndBug> ret = - EINVAL ; goto out ; } ret = 0 ; out : free ( cgdir ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }
","<S2SV_ModStart> , * controller , * next = NULL <S2SV_ModStart> out ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> , cgroup , & next ) ) { if ( ! fpath || strcmp ( next , fpath ) == 0 ) ret = - EBUSY ; else ret = - ENOENT ; goto out ; } if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY <S2SV_ModEnd> ) ) { <S2SV_ModStart> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { ret = - EACCES ; goto out ; } if ( ! <S2SV_ModStart> cgdir ) ; free ( next ) ;
"
437,"CWE-269 static struct mount * clone_mnt ( struct mount * old , struct dentry * root , int flag ) { struct super_block * sb = old -> mnt . mnt_sb ; struct mount * mnt ; int err ; mnt = alloc_vfsmnt ( old -> mnt_devname ) ; if ( ! mnt ) return ERR_PTR ( - ENOMEM ) ; if ( flag & ( CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE ) ) mnt -> mnt_group_id = 0 ; else mnt -> mnt_group_id = old -> mnt_group_id ; if ( ( flag & CL_MAKE_SHARED ) && ! mnt -> mnt_group_id ) { err = mnt_alloc_group_id ( mnt ) ; if ( err ) goto out_free ; } mnt -> mnt . mnt_flags = old -> mnt . mnt_flags & ~ ( MNT_WRITE_HOLD | MNT_MARKED ) ; <S2SV_StartBug> if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) <S2SV_EndBug> mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ; <S2SV_StartBug> if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) ) <S2SV_EndBug> mnt -> mnt . mnt_flags |= MNT_LOCKED ; atomic_inc ( & sb -> s_active ) ; mnt -> mnt . mnt_sb = sb ; mnt -> mnt . mnt_root = dget ( root ) ; mnt -> mnt_mountpoint = mnt -> mnt . mnt_root ; mnt -> mnt_parent = mnt ; lock_mount_hash ( ) ; list_add_tail ( & mnt -> mnt_instance , & sb -> s_mounts ) ; unlock_mount_hash ( ) ; if ( ( flag & CL_SLAVE ) || ( ( flag & CL_SHARED_TO_SLAVE ) && IS_MNT_SHARED ( old ) ) ) { list_add ( & mnt -> mnt_slave , & old -> mnt_slave_list ) ; mnt -> mnt_master = old ; CLEAR_MNT_SHARED ( mnt ) ; } else if ( ! ( flag & CL_PRIVATE ) ) { if ( ( flag & CL_MAKE_SHARED ) || IS_MNT_SHARED ( old ) ) list_add ( & mnt -> mnt_share , & old -> mnt_share ) ; if ( IS_MNT_SLAVE ( old ) ) list_add ( & mnt -> mnt_slave , & old -> mnt_slave ) ; mnt -> mnt_master = old -> mnt_master ; } if ( flag & CL_MAKE_SHARED ) set_mnt_shared ( mnt ) ; if ( flag & CL_EXPIRE ) { if ( ! list_empty ( & old -> mnt_expire ) ) list_add ( & mnt -> mnt_expire , & old -> mnt_expire ) ; } return mnt ; out_free : mnt_free_id ( mnt ) ; free_vfsmnt ( mnt ) ; return ERR_PTR ( err ) ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> flag & CL_UNPRIVILEGED <S2SV_ModStart> & CL_UNPRIVILEGED ) { mnt -> mnt . mnt_flags |= MNT_LOCK_ATIME ; if <S2SV_ModEnd> ( mnt -> <S2SV_ModStart> mnt_flags & MNT_READONLY <S2SV_ModEnd> ) mnt -> <S2SV_ModStart> ; if ( mnt -> mnt . mnt_flags & MNT_NODEV ) mnt -> mnt . mnt_flags |= MNT_LOCK_NODEV ; if ( mnt -> mnt . mnt_flags & MNT_NOSUID ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOSUID ; if ( mnt -> mnt . mnt_flags & MNT_NOEXEC ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOEXEC ; } if (
"
438,"CWE-362 static struct rds_connection * __rds_conn_create ( struct net * net , __be32 laddr , __be32 faddr , struct rds_transport * trans , gfp_t gfp , int is_outgoing ) { struct rds_connection * conn , * parent = NULL ; struct hlist_head * head = rds_conn_bucket ( laddr , faddr ) ; struct rds_transport * loop_trans ; unsigned long flags ; int ret ; rcu_read_lock ( ) ; conn = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( conn && conn -> c_loopback && conn -> c_trans != & rds_loop_transport && laddr == faddr && ! is_outgoing ) { parent = conn ; conn = parent -> c_passive ; } rcu_read_unlock ( ) ; if ( conn ) goto out ; conn = kmem_cache_zalloc ( rds_conn_slab , gfp ) ; if ( ! conn ) { conn = ERR_PTR ( - ENOMEM ) ; goto out ; } INIT_HLIST_NODE ( & conn -> c_hash_node ) ; conn -> c_laddr = laddr ; conn -> c_faddr = faddr ; spin_lock_init ( & conn -> c_lock ) ; conn -> c_next_tx_seq = 1 ; rds_conn_net_set ( conn , net ) ; init_waitqueue_head ( & conn -> c_waitq ) ; INIT_LIST_HEAD ( & conn -> c_send_queue ) ; INIT_LIST_HEAD ( & conn -> c_retrans ) ; ret = rds_cong_get_maps ( conn ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( ret ) ; goto out ; } loop_trans = rds_trans_get_preferred ( net , faddr ) ; if ( loop_trans ) { rds_trans_put ( loop_trans ) ; conn -> c_loopback = 1 ; if ( is_outgoing && trans -> t_prefer_loopback ) { trans = & rds_loop_transport ; } <S2SV_StartBug> } <S2SV_EndBug> if ( trans == NULL ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( - ENODEV ) ; goto out ; } conn -> c_trans = trans ; ret = trans -> conn_alloc ( conn , gfp ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( ret ) ; goto out ; } atomic_set ( & conn -> c_state , RDS_CONN_DOWN ) ; conn -> c_send_gen = 0 ; conn -> c_outgoing = ( is_outgoing ? 1 : 0 ) ; conn -> c_reconnect_jiffies = 0 ; INIT_DELAYED_WORK ( & conn -> c_send_w , rds_send_worker ) ; INIT_DELAYED_WORK ( & conn -> c_recv_w , rds_recv_worker ) ; INIT_DELAYED_WORK ( & conn -> c_conn_w , rds_connect_worker ) ; INIT_WORK ( & conn -> c_down_w , rds_shutdown_worker ) ; mutex_init ( & conn -> c_cm_lock ) ; conn -> c_flags = 0 ; rdsdebug ( ""allocated<S2SV_blank>conn<S2SV_blank>%p<S2SV_blank>for<S2SV_blank>%pI4<S2SV_blank>-><S2SV_blank>%pI4<S2SV_blank>over<S2SV_blank>%s<S2SV_blank>%s\\n"" , conn , & laddr , & faddr , trans -> t_name ? trans -> t_name : ""[unknown]"" , is_outgoing ? ""(outgoing)"" : """" ) ; spin_lock_irqsave ( & rds_conn_lock , flags ) ; if ( parent ) { if ( parent -> c_passive ) { trans -> conn_free ( conn -> c_transport_data ) ; kmem_cache_free ( rds_conn_slab , conn ) ; conn = parent -> c_passive ; } else { parent -> c_passive = conn ; rds_cong_add_conn ( conn ) ; rds_conn_count ++ ; } } else { struct rds_connection * found ; found = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( found ) { trans -> conn_free ( conn -> c_transport_data ) ; kmem_cache_free ( rds_conn_slab , conn ) ; conn = found ; } else { hlist_add_head_rcu ( & conn -> c_hash_node , head ) ; rds_cong_add_conn ( conn ) ; rds_conn_count ++ ; } } spin_unlock_irqrestore ( & rds_conn_lock , flags ) ; out : return conn ; }
","<S2SV_ModStart> rds_loop_transport ; } <S2SV_ModEnd> } conn ->
"
439,"CWE-119 static __u8 * sp_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <S2SV_StartBug> if ( * rsize >= 107 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 && <S2SV_EndBug> rdesc [ 106 ] == 0x03 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Sunplus<S2SV_blank>Wireless<S2SV_blank>Desktop<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 105 ] = rdesc [ 110 ] = 0x03 ; rdesc [ 106 ] = rdesc [ 111 ] = 0x21 ; } return rdesc ; }
","<S2SV_ModStart> * rsize >= 112 <S2SV_ModEnd> && rdesc [
"
440,"CWE-20 static INT AirPDcapScanForKeys ( PAIRPDCAP_CONTEXT ctx , const guint8 * data , const guint mac_header_len , const guint tot_len , AIRPDCAP_SEC_ASSOCIATION_ID id ) { const UCHAR * addr ; guint bodyLength ; PAIRPDCAP_SEC_ASSOCIATION sta_sa ; PAIRPDCAP_SEC_ASSOCIATION sa ; guint offset = 0 ; const guint8 dot1x_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x00 , 0x00 , 0x88 , 0x8E } ; const guint8 bt_dot1x_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x19 , 0x58 , 0x00 , 0x03 } ; const guint8 tdls_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x00 , 0x00 , 0x89 , 0x0D , 0x02 , 0X0C } ; const EAPOL_RSN_KEY * pEAPKey ; # ifdef _DEBUG # define MSGBUF_LEN 255 CHAR msgbuf [ MSGBUF_LEN ] ; # endif AIRPDCAP_DEBUG_TRACE_START ( ""AirPDcapScanForKeys"" ) ; offset = mac_header_len ; if ( memcmp ( data + offset , dot1x_header , 8 ) == 0 || memcmp ( data + offset , bt_dot1x_header , 8 ) == 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Authentication:<S2SV_blank>EAPOL<S2SV_blank>packet"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; offset += 8 ; if ( data [ offset + 1 ] != 3 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Not<S2SV_blank>EAPOL-Key"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } bodyLength = pntoh16 ( data + offset + 2 ) ; <S2SV_StartBug> if ( ( tot_len - offset - 4 ) < bodyLength ) { <S2SV_EndBug> AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""EAPOL<S2SV_blank>body<S2SV_blank>too<S2SV_blank>short"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += 4 ; pEAPKey = ( const EAPOL_RSN_KEY * ) ( data + offset ) ; if ( pEAPKey -> type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR && pEAPKey -> type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Not<S2SV_blank>valid<S2SV_blank>key<S2SV_blank>descriptor<S2SV_blank>type"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += 1 ; sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sa == NULL ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""No<S2SV_blank>SA<S2SV_blank>for<S2SV_blank>BSSID<S2SV_blank>found"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_REQ_DATA ; } if ( AirPDcapRsna4WHandshake ( ctx , data , sa , offset , tot_len ) == AIRPDCAP_RET_SUCCESS_HANDSHAKE ) return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; if ( mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Message<S2SV_blank>too<S2SV_blank>short<S2SV_blank>for<S2SV_blank>Group<S2SV_blank>Key"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } if ( AIRPDCAP_EAP_KEY ( data [ offset + 1 ] ) != 0 || AIRPDCAP_EAP_ACK ( data [ offset + 1 ] ) != 1 || AIRPDCAP_EAP_MIC ( data [ offset ] ) != 1 || AIRPDCAP_EAP_SEC ( data [ offset ] ) != 1 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Key<S2SV_blank>bitfields<S2SV_blank>not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>Group<S2SV_blank>Key"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } memcpy ( id . sta , broadcast_mac , AIRPDCAP_MAC_LEN ) ; sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sa == NULL ) { return AIRPDCAP_RET_REQ_DATA ; } if ( ( addr = AirPDcapGetStaAddress ( ( const AIRPDCAP_MAC_FRAME_ADDR4 * ) ( data ) ) ) != NULL ) { memcpy ( id . sta , addr , AIRPDCAP_MAC_LEN ) ; # ifdef _DEBUG g_snprintf ( msgbuf , MSGBUF_LEN , ""ST_MAC:<S2SV_blank>%2X.%2X.%2X.%2X.%2X.%2X\\t"" , id . sta [ 0 ] , id . sta [ 1 ] , id . sta [ 2 ] , id . sta [ 3 ] , id . sta [ 4 ] , id . sta [ 5 ] ) ; # endif AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , msgbuf , AIRPDCAP_DEBUG_LEVEL_3 ) ; } else { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""SA<S2SV_blank>not<S2SV_blank>found"" , AIRPDCAP_DEBUG_LEVEL_5 ) ; return AIRPDCAP_RET_REQ_DATA ; } sta_sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sta_sa == NULL ) { return AIRPDCAP_RET_REQ_DATA ; } return ( AirPDcapDecryptWPABroadcastKey ( pEAPKey , sta_sa -> wpa . ptk + 16 , sa , tot_len - offset + 1 ) ) ; } else if ( memcmp ( data + offset , tdls_header , 10 ) == 0 ) { const guint8 * initiator , * responder ; guint8 action ; guint status , offset_rsne = 0 , offset_fte = 0 , offset_link = 0 , offset_timeout = 0 ; AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Authentication:<S2SV_blank>TDLS<S2SV_blank>Action<S2SV_blank>Frame"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; offset += 10 ; action = data [ offset ] ; if ( action != 1 && action != 2 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Not<S2SV_blank>Response<S2SV_blank>nor<S2SV_blank>confirm"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset ++ ; status = pntoh16 ( data + offset ) ; if ( status != 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""TDLS<S2SV_blank>setup<S2SV_blank>not<S2SV_blank>successfull"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += 5 ; while ( offset < ( tot_len - 2 ) ) { if ( data [ offset ] == 48 ) { offset_rsne = offset ; } else if ( data [ offset ] == 55 ) { offset_fte = offset ; } else if ( data [ offset ] == 56 ) { offset_timeout = offset ; } else if ( data [ offset ] == 101 ) { offset_link = offset ; } if ( tot_len < offset + data [ offset + 1 ] + 2 ) { return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += data [ offset + 1 ] + 2 ; } if ( offset_rsne == 0 || offset_fte == 0 || offset_timeout == 0 || offset_link == 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Cannot<S2SV_blank>Find<S2SV_blank>all<S2SV_blank>necessary<S2SV_blank>IEs"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Found<S2SV_blank>RSNE/Fast<S2SV_blank>BSS/Timeout<S2SV_blank>Interval/Link<S2SV_blank>IEs"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; initiator = & data [ offset_link + 8 ] ; responder = & data [ offset_link + 14 ] ; if ( memcmp ( initiator , responder , AIRPDCAP_MAC_LEN ) < 0 ) { memcpy ( id . sta , initiator , AIRPDCAP_MAC_LEN ) ; memcpy ( id . bssid , responder , AIRPDCAP_MAC_LEN ) ; } else { memcpy ( id . sta , responder , AIRPDCAP_MAC_LEN ) ; memcpy ( id . bssid , initiator , AIRPDCAP_MAC_LEN ) ; } sa = AirPDcapGetSaPtr ( ctx , & id ) ; if ( sa == NULL ) { return AIRPDCAP_RET_REQ_DATA ; } if ( sa -> validKey ) { if ( memcmp ( sa -> wpa . nonce , data + offset_fte + 52 , AIRPDCAP_WPA_NONCE_LEN ) == 0 ) { return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; } else { AIRPDCAP_SEC_ASSOCIATION * tmp_sa = g_new ( AIRPDCAP_SEC_ASSOCIATION , 1 ) ; memcpy ( tmp_sa , sa , sizeof ( AIRPDCAP_SEC_ASSOCIATION ) ) ; sa -> next = tmp_sa ; sa -> validKey = FALSE ; } } if ( AirPDcapTDLSDeriveKey ( sa , data , offset_rsne , offset_fte , offset_timeout , offset_link , action ) == AIRPDCAP_RET_SUCCESS ) { AIRPDCAP_DEBUG_TRACE_END ( ""AirPDcapScanForKeys"" ) ; return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; } } else { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Skipping:<S2SV_blank>not<S2SV_blank>an<S2SV_blank>EAPOL<S2SV_blank>packet"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; } AIRPDCAP_DEBUG_TRACE_END ( ""AirPDcapScanForKeys"" ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; }
","<S2SV_ModStart> if ( ( ( <S2SV_ModStart> ) < bodyLength ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) )
"
441,"CWE-476 static irqreturn_t i8042_interrupt ( int irq , void * dev_id ) { struct i8042_port * port ; struct serio * serio ; unsigned long flags ; unsigned char str , data ; unsigned int dfl ; unsigned int port_no ; bool filtered ; int ret = 1 ; spin_lock_irqsave ( & i8042_lock , flags ) ; str = i8042_read_status ( ) ; if ( unlikely ( ~ str & I8042_STR_OBF ) ) { spin_unlock_irqrestore ( & i8042_lock , flags ) ; if ( irq ) dbg ( ""Interrupt<S2SV_blank>%d,<S2SV_blank>without<S2SV_blank>any<S2SV_blank>data\\n"" , irq ) ; ret = 0 ; goto out ; } data = i8042_read_data ( ) ; if ( i8042_mux_present && ( str & I8042_STR_AUXDATA ) ) { static unsigned long last_transmit ; static unsigned char last_str ; dfl = 0 ; if ( str & I8042_STR_MUXERR ) { dbg ( ""MUX<S2SV_blank>error,<S2SV_blank>status<S2SV_blank>is<S2SV_blank>%02x,<S2SV_blank>data<S2SV_blank>is<S2SV_blank>%02x\\n"" , str , data ) ; switch ( data ) { default : if ( time_before ( jiffies , last_transmit + HZ / 10 ) ) { str = last_str ; break ; } case 0xfc : case 0xfd : case 0xfe : dfl = SERIO_TIMEOUT ; data = 0xfe ; break ; case 0xff : dfl = SERIO_PARITY ; data = 0xfe ; break ; } } port_no = I8042_MUX_PORT_NO + ( ( str >> 6 ) & 3 ) ; last_str = str ; last_transmit = jiffies ; } else { dfl = ( ( str & I8042_STR_PARITY ) ? SERIO_PARITY : 0 ) | ( ( str & I8042_STR_TIMEOUT && ! i8042_notimeout ) ? SERIO_TIMEOUT : 0 ) ; port_no = ( str & I8042_STR_AUXDATA ) ? I8042_AUX_PORT_NO : I8042_KBD_PORT_NO ; } port = & i8042_ports [ port_no ] ; serio = port -> exists ? port -> serio : NULL ; filter_dbg ( port -> driver_bound , data , ""<-<S2SV_blank>i8042<S2SV_blank>(interrupt,<S2SV_blank>%d,<S2SV_blank>%d%s%s)\\n"" , port_no , irq , dfl & SERIO_PARITY ? "",<S2SV_blank>bad<S2SV_blank>parity"" : """" , dfl & SERIO_TIMEOUT ? "",<S2SV_blank>timeout"" : """" ) ; filtered = i8042_filter ( data , str , serio ) ; spin_unlock_irqrestore ( & i8042_lock , flags ) ; <S2SV_StartBug> if ( likely ( port -> exists && ! filtered ) ) <S2SV_EndBug> serio_interrupt ( serio , data , dfl ) ; out : return IRQ_RETVAL ( ret ) ; }
","<S2SV_ModStart> ( likely ( serio <S2SV_ModEnd> && ! filtered
"
442,"CWE-125 static void interp_reply ( netdissect_options * ndo , const struct sunrpc_msg * rp , uint32_t proc , uint32_t vers , int length ) { register const uint32_t * dp ; register int v3 ; int er ; v3 = ( vers == NFS_VER3 ) ; if ( ! v3 && proc < NFS_NPROCS ) proc = nfsv3_procid [ proc ] ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( nfsproc_str , ""proc-%u"" , proc ) ) ) ; switch ( proc ) { case NFSPROC_GETATTR : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parseattrstat ( ndo , dp , ! ndo -> ndo_qflag , v3 ) != 0 ) return ; break ; case NFSPROC_SETATTR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) return ; if ( v3 ) { if ( parsewccres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parseattrstat ( ndo , dp , ! ndo -> ndo_qflag , 0 ) != 0 ) return ; } break ; case NFSPROC_LOOKUP : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( er ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>post<S2SV_blank>dattr:"" ) ) ; dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ; } } else { if ( ! ( dp = parsefh ( ndo , dp , v3 ) ) ) break ; if ( ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) && ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>post<S2SV_blank>dattr:"" ) ) ; dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ; } } if ( dp ) return ; } else { if ( parsediropres ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_ACCESS : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>attr:"" ) ) ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( ! er ) <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; <S2SV_EndBug> return ; case NFSPROC_READLINK : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parselinkres ( ndo , dp , v3 ) != 0 ) return ; break ; case NFSPROC_READ : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( er ) return ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; if ( EXTRACT_32BITS ( & dp [ 1 ] ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>EOF"" ) ) ; } return ; } else { if ( parseattrstat ( ndo , dp , ndo -> ndo_vflag , 0 ) != 0 ) return ; } break ; case NFSPROC_WRITE : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( er ) return ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 1 ] ) ) ) ) ; } return ; } } else { if ( parseattrstat ( ndo , dp , ndo -> ndo_vflag , v3 ) != 0 ) return ; } break ; case NFSPROC_CREATE : case NFSPROC_MKDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; } else { if ( parsediropres ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_SYMLINK : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_MKNOD : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; break ; case NFSPROC_REMOVE : case NFSPROC_RMDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsewccres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_RENAME : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>from:"" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>to:"" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; } return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_LINK : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>file<S2SV_blank>POST:"" ) ) ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>dir:"" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; return ; } } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_READDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsev3rddirres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parserddires ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_READDIRPLUS : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( parsev3rddirres ( ndo , dp , ndo -> ndo_vflag ) ) return ; break ; case NFSPROC_FSSTAT : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsestatfs ( ndo , dp , v3 ) != 0 ) return ; break ; case NFSPROC_FSINFO : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsefsinfo ( ndo , dp ) != 0 ) return ; break ; case NFSPROC_PATHCONF : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsepathconf ( ndo , dp ) != 0 ) return ; break ; case NFSPROC_COMMIT : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsewccres ( ndo , dp , ndo -> ndo_vflag ) != 0 ) return ; break ; default : return ; } trunc : if ( ! nfserr ) ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }
","<S2SV_ModStart> ! er ) { ND_TCHECK ( <S2SV_ModEnd> dp [ 0 <S2SV_ModStart> 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } <S2SV_ModEnd> return ; case
"
443,"CWE-17 <S2SV_StartBug> static int udf_translate_to_linux ( uint8_t * newName , uint8_t * udfName , <S2SV_EndBug> <S2SV_StartBug> int udfLen , uint8_t * fidName , <S2SV_EndBug> int fidNameLen ) { int index , newIndex = 0 , needsCRC = 0 ; int extIndex = 0 , newExtIndex = 0 , hasExt = 0 ; unsigned short valueCRC ; uint8_t curr ; if ( udfName [ 0 ] == '.' && ( udfLen == 1 || ( udfLen == 2 && udfName [ 1 ] == '.' ) ) ) { needsCRC = 1 ; newIndex = udfLen ; memcpy ( newName , udfName , udfLen ) ; } else { for ( index = 0 ; index < udfLen ; index ++ ) { curr = udfName [ index ] ; if ( curr == '/' || curr == 0 ) { needsCRC = 1 ; curr = ILLEGAL_CHAR_MARK ; while ( index + 1 < udfLen && ( udfName [ index + 1 ] == '/' || udfName [ index + 1 ] == 0 ) ) index ++ ; } if ( curr == EXT_MARK && ( udfLen - index - 1 ) <= EXT_SIZE ) { if ( udfLen == index + 1 ) hasExt = 0 ; else { hasExt = 1 ; extIndex = index ; newExtIndex = newIndex ; } } <S2SV_StartBug> if ( newIndex < 256 ) <S2SV_EndBug> newName [ newIndex ++ ] = curr ; else needsCRC = 1 ; } } if ( needsCRC ) { uint8_t ext [ EXT_SIZE ] ; int localExtIndex = 0 ; if ( hasExt ) { int maxFilenameLen ; for ( index = 0 ; index < EXT_SIZE && extIndex + index + 1 < udfLen ; index ++ ) { curr = udfName [ extIndex + index + 1 ] ; if ( curr == '/' || curr == 0 ) { needsCRC = 1 ; curr = ILLEGAL_CHAR_MARK ; while ( extIndex + index + 2 < udfLen && ( index + 1 < EXT_SIZE && ( udfName [ extIndex + index + 2 ] == '/' || udfName [ extIndex + index + 2 ] == 0 ) ) ) index ++ ; } ext [ localExtIndex ++ ] = curr ; } <S2SV_StartBug> maxFilenameLen = 250 - localExtIndex ; <S2SV_EndBug> if ( newIndex > maxFilenameLen ) newIndex = maxFilenameLen ; else newIndex = newExtIndex ; <S2SV_StartBug> } else if ( newIndex > 250 ) <S2SV_EndBug> newIndex = 250 ; newName [ newIndex ++ ] = CRC_MARK ; valueCRC = crc_itu_t ( 0 , fidName , fidNameLen ) ; newName [ newIndex ++ ] = hex_asc_upper_hi ( valueCRC >> 8 ) ; newName [ newIndex ++ ] = hex_asc_upper_lo ( valueCRC >> 8 ) ; newName [ newIndex ++ ] = hex_asc_upper_hi ( valueCRC ) ; newName [ newIndex ++ ] = hex_asc_upper_lo ( valueCRC ) ; if ( hasExt ) { newName [ newIndex ++ ] = EXT_MARK ; for ( index = 0 ; index < localExtIndex ; index ++ ) newName [ newIndex ++ ] = ext [ index ] ; } } return newIndex ; }
","<S2SV_ModStart> * newName , int newLen , <S2SV_ModStart> * udfName , int udfLen , <S2SV_ModEnd> uint8_t * fidName <S2SV_ModStart> ( newIndex < newLen <S2SV_ModEnd> ) newName [ <S2SV_ModStart> } maxFilenameLen = newLen - CRC_LEN <S2SV_ModEnd> - localExtIndex ; <S2SV_ModStart> ( newIndex > newLen - CRC_LEN ) newIndex = newLen - CRC_LEN <S2SV_ModEnd> ; newName [
"
444,"CWE-119 <S2SV_StartBug> static void count_segs_sb ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 , <S2SV_EndBug> int * no_pred_segcounts , int ( * temporal_predictor_count ) [ 2 ] , int * t_unpred_seg_counts , int mi_row , int mi_col , BLOCK_SIZE bsize ) { <S2SV_StartBug> const VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> const int mis = cm -> mi_stride ; int bw , bh ; const int bs = num_8x8_blocks_wide_lookup [ bsize ] , hbs = bs / 2 ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; <S2SV_StartBug> bw = num_8x8_blocks_wide_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ; <S2SV_EndBug> <S2SV_StartBug> bh = num_8x8_blocks_high_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ; <S2SV_EndBug> if ( bw == bs && bh == bs ) { <S2SV_StartBug> count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count , <S2SV_EndBug> t_unpred_seg_counts , bs , bs , mi_row , mi_col ) ; } else if ( bw == bs && bh < bs ) { <S2SV_StartBug> count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count , <S2SV_EndBug> t_unpred_seg_counts , bs , hbs , mi_row , mi_col ) ; <S2SV_StartBug> count_segs ( cpi , tile , mi_8x8 + hbs * mis , no_pred_segcounts , <S2SV_EndBug> temporal_predictor_count , t_unpred_seg_counts , bs , hbs , mi_row + hbs , mi_col ) ; } else if ( bw < bs && bh == bs ) { <S2SV_StartBug> count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count , <S2SV_EndBug> t_unpred_seg_counts , hbs , bs , mi_row , mi_col ) ; <S2SV_StartBug> count_segs ( cpi , tile , mi_8x8 + hbs , <S2SV_EndBug> no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , hbs , bs , mi_row , mi_col + hbs ) ; } else { const BLOCK_SIZE subsize = subsize_lookup [ PARTITION_SPLIT ] [ bsize ] ; int n ; assert ( bw < bs && bh < bs ) ; for ( n = 0 ; n < 4 ; n ++ ) { const int mi_dc = hbs * ( n & 1 ) ; const int mi_dr = hbs * ( n >> 1 ) ; <S2SV_StartBug> count_segs_sb ( cpi , tile , & mi_8x8 [ mi_dr * mis + mi_dc ] , <S2SV_EndBug> no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , mi_row + mi_dr , mi_col + mi_dc , subsize ) ; } } }
","<S2SV_ModStart> void count_segs_sb ( const VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_ModEnd> const TileInfo * <S2SV_ModStart> const TileInfo * tile , <S2SV_ModEnd> MODE_INFO * * <S2SV_ModStart> MODE_INFO * * mi <S2SV_ModEnd> , int * <S2SV_ModStart> bsize ) { <S2SV_ModEnd> const int mis <S2SV_ModStart> = num_8x8_blocks_wide_lookup [ mi <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = num_8x8_blocks_high_lookup [ mi <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> { count_segs ( cm , xd , tile , mi <S2SV_ModEnd> , no_pred_segcounts , <S2SV_ModStart> { count_segs ( cm , xd , tile , mi <S2SV_ModEnd> , no_pred_segcounts , <S2SV_ModStart> ; count_segs ( cm , xd , tile , mi <S2SV_ModEnd> + hbs * <S2SV_ModStart> { count_segs ( cm , xd , tile , mi <S2SV_ModEnd> , no_pred_segcounts , <S2SV_ModStart> ; count_segs ( cm , xd , tile , mi <S2SV_ModEnd> + hbs , <S2SV_ModStart> ; count_segs_sb ( cm , xd <S2SV_ModEnd> , tile , <S2SV_ModStart> tile , & mi <S2SV_ModEnd> [ mi_dr *
"
445,"CWE-254 void processInputBuffer ( client * c ) { server . current_client = c ; while ( sdslen ( c -> querybuf ) ) { if ( ! ( c -> flags & CLIENT_SLAVE ) && clientsArePaused ( ) ) break ; if ( c -> flags & CLIENT_BLOCKED ) break ; <S2SV_StartBug> if ( c -> flags & CLIENT_CLOSE_AFTER_REPLY ) break ; <S2SV_EndBug> if ( ! c -> reqtype ) { if ( c -> querybuf [ 0 ] == '*' ) { c -> reqtype = PROTO_REQ_MULTIBULK ; } else { c -> reqtype = PROTO_REQ_INLINE ; } } if ( c -> reqtype == PROTO_REQ_INLINE ) { if ( processInlineBuffer ( c ) != C_OK ) break ; } else if ( c -> reqtype == PROTO_REQ_MULTIBULK ) { if ( processMultibulkBuffer ( c ) != C_OK ) break ; } else { serverPanic ( ""Unknown<S2SV_blank>request<S2SV_blank>type"" ) ; } if ( c -> argc == 0 ) { resetClient ( c ) ; } else { if ( processCommand ( c ) == C_OK ) resetClient ( c ) ; if ( server . current_client == NULL ) break ; } } server . current_client = NULL ; }
","<S2SV_ModStart> -> flags & ( CLIENT_CLOSE_AFTER_REPLY | CLIENT_CLOSE_ASAP ) <S2SV_ModEnd> ) break ;
"
446,"CWE-000 static int mpage_da_map_blocks ( struct mpage_da_data * mpd ) { int err , blks , get_blocks_flags ; struct buffer_head new ; sector_t next = mpd -> b_blocknr ; unsigned max_blocks = mpd -> b_size >> mpd -> inode -> i_blkbits ; loff_t disksize = EXT4_I ( mpd -> inode ) -> i_disksize ; handle_t * handle = NULL ; if ( ( mpd -> b_state & ( 1 << BH_Mapped ) ) && ! ( mpd -> b_state & ( 1 << BH_Delay ) ) && ! ( mpd -> b_state & ( 1 << BH_Unwritten ) ) ) return 0 ; if ( ! mpd -> b_size ) return 0 ; handle = ext4_journal_current_handle ( ) ; BUG_ON ( ! handle ) ; new . b_state = 0 ; <S2SV_StartBug> get_blocks_flags = EXT4_GET_BLOCKS_CREATE ; <S2SV_EndBug> if ( mpd -> b_state & ( 1 << BH_Delay ) ) get_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE ; blks = ext4_get_blocks ( handle , mpd -> inode , next , max_blocks , & new , get_blocks_flags ) ; if ( blks < 0 ) { err = blks ; if ( err == - EAGAIN ) return 0 ; if ( err == - ENOSPC && ext4_count_free_blocks ( mpd -> inode -> i_sb ) ) { mpd -> retval = err ; return 0 ; } ext4_msg ( mpd -> inode -> i_sb , KERN_CRIT , ""delayed<S2SV_blank>block<S2SV_blank>allocation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>at<S2SV_blank>"" ""logical<S2SV_blank>offset<S2SV_blank>%llu<S2SV_blank>with<S2SV_blank>max<S2SV_blank>blocks<S2SV_blank>%zd<S2SV_blank>with<S2SV_blank>"" ""error<S2SV_blank>%d\\n"" , mpd -> inode -> i_ino , ( unsigned long long ) next , mpd -> b_size >> mpd -> inode -> i_blkbits , err ) ; printk ( KERN_CRIT ""This<S2SV_blank>should<S2SV_blank>not<S2SV_blank>happen!!<S2SV_blank><S2SV_blank>"" ""Data<S2SV_blank>will<S2SV_blank>be<S2SV_blank>lost\\n"" ) ; if ( err == - ENOSPC ) { ext4_print_free_blocks ( mpd -> inode ) ; } ext4_da_block_invalidatepages ( mpd , next , mpd -> b_size >> mpd -> inode -> i_blkbits ) ; return err ; } BUG_ON ( blks == 0 ) ; new . b_size = ( blks << mpd -> inode -> i_blkbits ) ; if ( buffer_new ( & new ) ) __unmap_underlying_blocks ( mpd -> inode , & new ) ; if ( ( mpd -> b_state & ( 1 << BH_Delay ) ) || ( mpd -> b_state & ( 1 << BH_Unwritten ) ) ) mpage_put_bnr_to_bhs ( mpd , next , & new ) ; if ( ext4_should_order_data ( mpd -> inode ) ) { err = ext4_jbd2_file_inode ( handle , mpd -> inode ) ; if ( err ) return err ; } disksize = ( ( loff_t ) next + blks ) << mpd -> inode -> i_blkbits ; if ( disksize > i_size_read ( mpd -> inode ) ) disksize = i_size_read ( mpd -> inode ) ; if ( disksize > EXT4_I ( mpd -> inode ) -> i_disksize ) { ext4_update_i_disksize ( mpd -> inode , disksize ) ; return ext4_mark_inode_dirty ( handle , mpd -> inode ) ; } return 0 ; }
","<S2SV_ModStart> get_blocks_flags = EXT4_GET_BLOCKS_CREATE ; if ( ext4_should_dioread_nolock ( mpd -> inode ) ) get_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT
"
447,"CWE-310 int DSA_verify ( int type , const unsigned char * dgst , int dgst_len , const unsigned char * sigbuf , int siglen , DSA * dsa ) { DSA_SIG * s ; <S2SV_StartBug> int ret = - 1 ; <S2SV_EndBug> s = DSA_SIG_new ( ) ; if ( s == NULL ) return ( ret ) ; <S2SV_StartBug> if ( d2i_DSA_SIG ( & s , & sigbuf , siglen ) == NULL ) goto err ; <S2SV_EndBug> ret = DSA_do_verify ( dgst , dgst_len , s , dsa ) ; err : <S2SV_StartBug> DSA_SIG_free ( s ) ; <S2SV_EndBug> return ( ret ) ; }
","<S2SV_ModStart> * s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> s , & p <S2SV_ModEnd> , siglen ) <S2SV_ModStart> == NULL ) goto err ; derlen = i2d_DSA_SIG ( s , & der ) ; if ( derlen != siglen || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> ; err : if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; }
"
448,"CWE-415 void * gdImageGifPtr ( gdImagePtr im , int * size ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; <S2SV_StartBug> gdImageGifCtx ( im , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> out -> gd_free ( out ) ; return rv ; }
","<S2SV_ModStart> NULL ) ; if ( ! _gdImageGifCtx <S2SV_ModEnd> ( im , <S2SV_ModStart> , out ) ) { <S2SV_ModEnd> rv = gdDPExtractData <S2SV_ModStart> size ) ; } else { rv = NULL ; }
"
449,"CWE-200 void free_bprm ( struct linux_binprm * bprm ) { free_arg_pages ( bprm ) ; if ( bprm -> cred ) { mutex_unlock ( & current -> signal -> cred_guard_mutex ) ; abort_creds ( bprm -> cred ) ; } <S2SV_StartBug> kfree ( bprm ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; } if ( bprm -> interp != bprm -> filename ) kfree ( bprm -> interp ) ;
"
450,"CWE-552 static int _hostresolver_getaddrinfo ( oe_resolver_t * resolver , const char * node , const char * service , const struct oe_addrinfo * hints , struct oe_addrinfo * * res ) { int ret = OE_EAI_FAIL ; uint64_t handle = 0 ; struct oe_addrinfo * head = NULL ; struct oe_addrinfo * tail = NULL ; struct oe_addrinfo * p = NULL ; OE_UNUSED ( resolver ) ; if ( res ) * res = NULL ; if ( ! res ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } { int retval = OE_EAI_FAIL ; if ( oe_syscall_getaddrinfo_open_ocall ( & retval , node , service , hints , & handle ) != OE_OK ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( ! handle ) { ret = retval ; goto done ; } } for ( ; ; ) { int retval = 0 ; <S2SV_StartBug> size_t canonnamelen = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( p = oe_calloc ( 1 , sizeof ( struct oe_addrinfo ) ) ) ) <S2SV_EndBug> { ret = OE_EAI_MEMORY ; goto done ; } if ( oe_syscall_getaddrinfo_read_ocall ( & retval , handle , <S2SV_StartBug> & p -> ai_flags , <S2SV_EndBug> <S2SV_StartBug> & p -> ai_family , <S2SV_EndBug> <S2SV_StartBug> & p -> ai_socktype , <S2SV_EndBug> <S2SV_StartBug> & p -> ai_protocol , <S2SV_EndBug> p -> ai_addrlen , <S2SV_StartBug> & p -> ai_addrlen , <S2SV_EndBug> NULL , <S2SV_StartBug> canonnamelen , <S2SV_EndBug> & canonnamelen , NULL ) != OE_OK ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( retval == 1 ) break ; if ( retval != - 1 || oe_errno != OE_ENAMETOOLONG ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( oe_errno ) ; } <S2SV_StartBug> if ( p -> ai_addrlen && ! ( p -> ai_addr = oe_calloc ( 1 , p -> ai_addrlen ) ) ) <S2SV_EndBug> { ret = OE_EAI_MEMORY ; goto done ; } <S2SV_StartBug> if ( canonnamelen && ! ( p -> ai_canonname = oe_calloc ( 1 , canonnamelen ) ) ) <S2SV_EndBug> { ret = OE_EAI_MEMORY ; goto done ; } <S2SV_StartBug> if ( oe_syscall_getaddrinfo_read_ocall ( <S2SV_EndBug> & retval , handle , & p -> ai_flags , & p -> ai_family , & p -> ai_socktype , & p -> ai_protocol , <S2SV_StartBug> p -> ai_addrlen , <S2SV_EndBug> & p -> ai_addrlen , p -> ai_addr , <S2SV_StartBug> canonnamelen , <S2SV_EndBug> & canonnamelen , p -> ai_canonname ) != OE_OK ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> if ( tail ) <S2SV_EndBug> { tail -> ai_next = p ; tail = p ; } else { head = p ; tail = p ; } p = NULL ; } if ( handle ) { int retval = - 1 ; if ( oe_syscall_getaddrinfo_close_ocall ( & retval , handle ) != OE_OK ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } handle = 0 ; if ( retval != 0 ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( oe_errno ) ; } } if ( ! head ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } * res = head ; head = NULL ; tail = NULL ; ret = 0 ; done : if ( handle ) { int retval ; oe_syscall_getaddrinfo_close_ocall ( & retval , handle ) ; } if ( head ) oe_freeaddrinfo ( head ) ; if ( p ) oe_freeaddrinfo ( p ) ; return ret ; }
","<S2SV_ModStart> 0 ; size_t canonnamelen_in <S2SV_ModEnd> = 0 ; <S2SV_ModStart> = 0 ; size_t canonnamelen_out = 0 ; struct oe_addrinfo p_out ; memset ( & p_out , 0 , sizeof ( struct oe_addrinfo ) ) ; <S2SV_ModEnd> if ( oe_syscall_getaddrinfo_read_ocall <S2SV_ModStart> handle , & p_out . <S2SV_ModEnd> ai_flags , & <S2SV_ModStart> ai_flags , & p_out . <S2SV_ModEnd> ai_family , & <S2SV_ModStart> ai_family , & p_out . <S2SV_ModEnd> ai_socktype , & <S2SV_ModStart> ai_socktype , & p_out . ai_protocol , p_out . <S2SV_ModEnd> ai_addrlen , & <S2SV_ModStart> ai_addrlen , & p_out . <S2SV_ModEnd> ai_addrlen , NULL <S2SV_ModStart> , NULL , canonnamelen_in , & canonnamelen_out <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ) ; } switch ( p_out . ai_family ) { case OE_AF_INET : if ( p_out . ai_addrlen != sizeof ( struct oe_sockaddr ) ) { ret = OE_EAI_FAIL ; goto done ; } break ; case OE_AF_INET6 : case OE_AF_INET6_WIN : case OE_AF_UNSPEC : if ( p_out . ai_addrlen != sizeof ( struct oe_sockaddr_in6 ) ) { ret = OE_EAI_FAIL ; goto done ; } break ; default : ret = OE_EAI_FAIL ; goto done ; } if ( ! ( p = oe_calloc ( 1 , sizeof ( struct oe_addrinfo ) ) ) ) { ret = OE_EAI_MEMORY ; goto done ; } if ( p_out . <S2SV_ModEnd> ai_addrlen && ! <S2SV_ModStart> ( 1 , p_out . <S2SV_ModEnd> ai_addrlen ) ) <S2SV_ModStart> } if ( canonnamelen_out <S2SV_ModEnd> && ! ( <S2SV_ModStart> ( 1 , canonnamelen_out <S2SV_ModEnd> ) ) ) <S2SV_ModStart> done ; } canonnamelen_in = canonnamelen_out ; <S2SV_ModStart> -> ai_protocol , p_out . <S2SV_ModEnd> ai_addrlen , & <S2SV_ModStart> -> ai_addr , canonnamelen_in , & canonnamelen_out <S2SV_ModEnd> , p -> <S2SV_ModStart> } if ( ( p -> ai_flags != p_out . ai_flags ) || ( p -> ai_family != p_out . ai_family ) || ( p -> ai_socktype != p_out . ai_socktype ) || ( p -> ai_protocol != p_out . ai_protocol ) || ( p -> ai_addrlen != p_out . ai_addrlen ) || ( canonnamelen_out != canonnamelen_in ) || ( canonnamelen_out && p -> ai_canonname [ canonnamelen_out - 1 ] != '\\0' ) ) { ret = OE_EAI_FAIL ; goto done ; } if ( tail ) { tail -> ai_next = p ; tail = p ; } else { head = p ; tail = p ; } p = NULL ; } if ( handle ) { int retval = - 1 <S2SV_ModEnd> ; if (
"
451,"CWE-20 void httpParseAuthorizationField ( HttpConnection * connection , char_t * value ) { char_t * p ; char_t * token ; token = osStrtok_r ( value , ""<S2SV_blank>\\t"" , & p ) ; if ( token == NULL ) { return ; } # if ( HTTP_SERVER_BASIC_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( token , ""Basic"" ) ) { error_t error ; size_t n ; char_t * separator ; connection -> request . auth . mode = HTTP_AUTH_MODE_BASIC ; token = osStrtok_r ( NULL , ""<S2SV_blank>\\t"" , & p ) ; if ( token != NULL ) { error = base64Decode ( token , osStrlen ( token ) , token , & n ) ; if ( ! error ) { token [ n ] = '\\0' ; <S2SV_StartBug> separator = strchr ( token , ':' ) ; <S2SV_EndBug> if ( separator != NULL ) { * separator = '\\0' ; strSafeCopy ( connection -> request . auth . user , token , HTTP_SERVER_USERNAME_MAX_LEN ) ; token = separator + 1 ; connection -> request . auth . password = token ; } } } TRACE_DEBUG ( ""Authorization<S2SV_blank>header:\\r\\n"" ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>username:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . user ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>password:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . password ) ; } # endif # if ( HTTP_SERVER_DIGEST_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( token , ""Digest"" ) ) { size_t n ; char_t * separator ; char_t * name ; connection -> request . auth . mode = HTTP_AUTH_MODE_DIGEST ; token = osStrtok_r ( NULL , "","" , & p ) ; while ( token != NULL ) { <S2SV_StartBug> separator = strchr ( token , '=' ) ; <S2SV_EndBug> if ( separator != NULL ) { * separator = '\\0' ; name = strTrimWhitespace ( token ) ; value = strTrimWhitespace ( separator + 1 ) ; n = osStrlen ( value ) ; if ( n > 0 && value [ n - 1 ] == \'\\""\' ) value [ n - 1 ] = '\\0' ; if ( value [ 0 ] == \'\\""\' ) value ++ ; if ( ! osStrcasecmp ( name , ""username"" ) ) { strSafeCopy ( connection -> request . auth . user , value , HTTP_SERVER_USERNAME_MAX_LEN ) ; } else if ( ! osStrcasecmp ( name , ""realm"" ) ) { connection -> request . auth . realm = value ; } else if ( ! osStrcasecmp ( name , ""nonce"" ) ) { connection -> request . auth . nonce = value ; } else if ( ! osStrcasecmp ( name , ""uri"" ) ) { connection -> request . auth . uri = value ; } else if ( ! osStrcasecmp ( name , ""qop"" ) ) { connection -> request . auth . qop = value ; } else if ( ! osStrcasecmp ( name , ""nc"" ) ) { connection -> request . auth . nc = value ; } else if ( ! osStrcasecmp ( name , ""cnonce"" ) ) { connection -> request . auth . cnonce = value ; } else if ( ! osStrcasecmp ( name , ""response"" ) ) { connection -> request . auth . response = value ; } else if ( ! osStrcasecmp ( name , ""opaque"" ) ) { connection -> request . auth . opaque = value ; } token = osStrtok_r ( NULL , "","" , & p ) ; } } TRACE_DEBUG ( ""Authorization<S2SV_blank>header:\\r\\n"" ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>username:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . user ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>realm:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . realm ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>nonce:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . nonce ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>uri:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . uri ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>qop:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . qop ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>nc:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . nc ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>cnonce:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . cnonce ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>response:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . response ) ; TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>opaque:<S2SV_blank>%s\\r\\n"" , connection -> request . auth . opaque ) ; } # endif else { return ; } # if ( HTTP_SERVER_BASIC_AUTH_SUPPORT == ENABLED || HTTP_SERVER_DIGEST_AUTH_SUPPORT == ENABLED ) connection -> request . auth . found = TRUE ; if ( connection -> settings -> authCallback != NULL ) { connection -> status = connection -> settings -> authCallback ( connection , connection -> request . auth . user , connection -> request . uri ) ; } else { connection -> status = HTTP_ACCESS_ALLOWED ; } # endif }
","<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( token , <S2SV_ModStart> { separator = osStrchr <S2SV_ModEnd> ( token ,
"
452,"CWE-369 static int iwgif_read_image ( struct iwgifrcontext * rctx ) { int retval = 0 ; struct lzwdeccontext d ; size_t subblocksize ; int has_local_ct ; int local_ct_size ; unsigned int root_codesize ; if ( ! iwgif_read ( rctx , rctx -> rbuf , 9 ) ) goto done ; rctx -> image_left = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 0 ] ) ; rctx -> image_top = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 2 ] ) ; rctx -> image_width = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 4 ] ) ; <S2SV_StartBug> rctx -> image_height = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 6 ] ) ; <S2SV_EndBug> rctx -> interlaced = ( int ) ( ( rctx -> rbuf [ 8 ] >> 6 ) & 0x01 ) ; has_local_ct = ( int ) ( ( rctx -> rbuf [ 8 ] >> 7 ) & 0x01 ) ; if ( has_local_ct ) { local_ct_size = ( int ) ( rctx -> rbuf [ 8 ] & 0x07 ) ; rctx -> colortable . num_entries = 1 << ( 1 + local_ct_size ) ; } if ( has_local_ct ) { if ( ! iwgif_read_color_table ( rctx , & rctx -> colortable ) ) goto done ; } if ( rctx -> has_transparency ) { rctx -> colortable . entry [ rctx -> trans_color_index ] . a = 0 ; } if ( ! iwgif_read ( rctx , rctx -> rbuf , 1 ) ) goto done ; root_codesize = ( unsigned int ) rctx -> rbuf [ 0 ] ; if ( root_codesize < 2 || root_codesize > 11 ) { iw_set_error ( rctx -> ctx , ""Invalid<S2SV_blank>LZW<S2SV_blank>minimum<S2SV_blank>code<S2SV_blank>size"" ) ; goto done ; } if ( ! iwgif_init_screen ( rctx ) ) goto done ; rctx -> total_npixels = ( size_t ) rctx -> image_width * ( size_t ) rctx -> image_height ; if ( ! iwgif_make_row_pointers ( rctx ) ) goto done ; lzw_init ( & d , root_codesize ) ; lzw_clear ( & d ) ; while ( 1 ) { if ( ! iwgif_read ( rctx , rctx -> rbuf , 1 ) ) goto done ; subblocksize = ( size_t ) rctx -> rbuf [ 0 ] ; if ( subblocksize == 0 ) break ; if ( ! iwgif_read ( rctx , rctx -> rbuf , subblocksize ) ) goto done ; if ( ! lzw_process_bytes ( rctx , & d , rctx -> rbuf , subblocksize ) ) goto done ; if ( d . eoi_flag ) break ; if ( rctx -> pixels_set >= rctx -> total_npixels ) break ; } retval = 1 ; done : return retval ; }
","<S2SV_ModStart> ] ) ; if ( rctx -> image_width < 1 || rctx -> image_height < 1 ) { iw_set_error ( rctx -> ctx , ""Invalid<S2SV_blank>image<S2SV_blank>dimensions"" ) ; goto done ; }
"
453,"CWE-119 void vp8_default_coef_probs ( VP8_COMMON * pc ) { <S2SV_StartBug> vpx_memcpy ( pc -> fc . coef_probs , default_coef_probs , <S2SV_EndBug> sizeof ( default_coef_probs ) ) ; }
","<S2SV_ModStart> pc ) { memcpy <S2SV_ModEnd> ( pc ->
"
454,"CWE-119 <S2SV_StartBug> static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data ) <S2SV_EndBug> { <S2SV_StartBug> int ret ; <S2SV_EndBug> ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REGS , PEGASUS_REQT_WRITE , 0 , <S2SV_StartBug> indx , data , size , 100 ) ; <S2SV_EndBug> if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\n"" , __func__ , ret ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }
","<S2SV_ModStart> __u16 size , const <S2SV_ModStart> data ) { u8 * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> , indx , buf <S2SV_ModEnd> , size , <S2SV_ModStart> ret ) ; kfree ( buf ) ;
"
455,"CWE-125 mod_ty <S2SV_StartBug> Module ( asdl_seq * body , PyArena * arena ) <S2SV_EndBug> { mod_ty p ; p = ( mod_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = Module_kind ; p -> v . Module . body = body ; <S2SV_StartBug> return p ; <S2SV_EndBug> }
","<S2SV_ModStart> asdl_seq * body , asdl_seq * type_ignores <S2SV_ModStart> = body ; p -> v . Module . type_ignores = type_ignores ;
"
456,"CWE-000 void sas_unregister_dev ( struct asd_sas_port * port , struct domain_device * dev ) { if ( ! test_bit ( SAS_DEV_DESTROY , & dev -> state ) && ! list_empty ( & dev -> disco_list_node ) ) { list_del_init ( & dev -> disco_list_node ) ; sas_rphy_free ( dev -> rphy ) ; sas_unregister_common_dev ( port , dev ) ; return ; } if ( ! test_and_set_bit ( SAS_DEV_DESTROY , & dev -> state ) ) { sas_rphy_unlink ( dev -> rphy ) ; list_move_tail ( & dev -> disco_list_node , & port -> destroy_list ) ; <S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_DESTRUCT ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> destroy_list ) ; <S2SV_ModEnd> } } <S2SV_null>
"
457,"CWE-119 int vp9_lookahead_push ( struct lookahead_ctx * ctx , YV12_BUFFER_CONFIG * src , <S2SV_StartBug> int64_t ts_start , int64_t ts_end , unsigned int flags ) { <S2SV_EndBug> struct lookahead_entry * buf ; # if USE_PARTIAL_COPY int row , col , active_end ; int mb_rows = ( src -> y_height + 15 ) >> 4 ; int mb_cols = ( src -> y_width + 15 ) >> 4 ; <S2SV_StartBug> # endif <S2SV_EndBug> if ( ctx -> sz + 1 + MAX_PRE_FRAMES > ctx -> max_sz ) return 1 ; ctx -> sz ++ ; buf = pop ( ctx , & ctx -> write_idx ) ; <S2SV_StartBug> # if USE_PARTIAL_COPY <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> max_sz == 1 && active_map && ! flags ) { <S2SV_EndBug> for ( row = 0 ; row < mb_rows ; ++ row ) { col = 0 ; while ( 1 ) { for ( ; col < mb_cols ; ++ col ) { if ( active_map [ col ] ) break ; } if ( col == mb_cols ) break ; active_end = col ; for ( ; active_end < mb_cols ; ++ active_end ) { if ( ! active_map [ active_end ] ) break ; } vp9_copy_and_extend_frame_with_rect ( src , & buf -> img , row << 4 , col << 4 , 16 , ( active_end - col ) << 4 ) ; col = active_end ; } active_map += mb_cols ; } } else { <S2SV_StartBug> vp9_copy_and_extend_frame ( src , & buf -> img ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> # else vp9_copy_and_extend_frame ( src , & buf -> img ) ; # endif buf -> ts_start = ts_start ; buf -> ts_end = ts_end ; buf -> flags = flags ; return 0 ; }
","<S2SV_ModStart> int64_t ts_end , # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif <S2SV_ModStart> ; # endif int width = src -> y_crop_width ; int height = src -> y_crop_height ; int uv_width = src -> uv_crop_width ; int uv_height = src -> uv_crop_height ; int subsampling_x = src -> subsampling_x ; int subsampling_y = src -> subsampling_y ; int larger_dimensions , new_dimensions ; <S2SV_ModStart> write_idx ) ; new_dimensions = width != buf -> img . y_crop_width || height != buf -> img . y_crop_height || uv_width != buf -> img . uv_crop_width || uv_height != buf -> img . uv_crop_height ; larger_dimensions = width > buf -> img . y_width || height > buf -> img . y_height || uv_width > buf -> img . uv_width || uv_height > buf -> img . uv_height ; assert ( ! larger_dimensions || new_dimensions ) ; <S2SV_ModStart> USE_PARTIAL_COPY if ( ! new_dimensions && <S2SV_ModStart> } else { # endif if ( larger_dimensions ) { YV12_BUFFER_CONFIG new_img ; memset ( & new_img , 0 , sizeof ( new_img ) ) ; if ( vpx_alloc_frame_buffer ( & new_img , width , height , subsampling_x , subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , 0 ) ) return 1 ; vpx_free_frame_buffer ( & buf -> img ) ; buf -> img = new_img ; } else if ( new_dimensions ) { buf -> img . y_crop_width = src -> y_crop_width ; buf -> img . y_crop_height = src -> y_crop_height ; buf -> img . uv_crop_width = src -> uv_crop_width ; buf -> img . uv_crop_height = src -> uv_crop_height ; buf -> img . subsampling_x = src -> subsampling_x ; buf -> img . subsampling_y = src -> subsampling_y ; } <S2SV_ModStart> img ) ; # if USE_PARTIAL_COPY } <S2SV_ModEnd> # endif buf
"
458,"CWE-399 static int cuse_channel_release ( struct inode * inode , struct file * file ) { struct fuse_dev * fud = file -> private_data ; struct cuse_conn * cc = fc_to_cc ( fud -> fc ) ; int rc ; mutex_lock ( & cuse_lock ) ; list_del_init ( & cc -> list ) ; mutex_unlock ( & cuse_lock ) ; if ( cc -> dev ) device_unregister ( cc -> dev ) ; if ( cc -> cdev ) { unregister_chrdev_region ( cc -> cdev -> dev , 1 ) ; cdev_del ( cc -> cdev ) ; } <S2SV_StartBug> rc = fuse_dev_release ( inode , file ) ; <S2SV_EndBug> return rc ; }
","<S2SV_ModStart> ) ; } fuse_conn_put ( & cc -> fc ) ;
"
459,"CWE-617 static krb5_error_code kdc_process_s4u_x509_user ( krb5_context context , krb5_kdc_req * request , krb5_pa_data * pa_data , krb5_keyblock * tgs_subkey , krb5_keyblock * tgs_session , krb5_pa_s4u_x509_user * * s4u_x509_user , const char * * status ) { krb5_error_code code ; krb5_data req_data ; req_data . length = pa_data -> length ; req_data . data = ( char * ) pa_data -> contents ; code = decode_krb5_pa_s4u_x509_user ( & req_data , s4u_x509_user ) ; if ( code ) <S2SV_StartBug> return code ; <S2SV_EndBug> code = verify_s4u_x509_user_checksum ( context , tgs_subkey ? tgs_subkey : tgs_session , & req_data , request -> nonce , * s4u_x509_user ) ; if ( code ) { * status = ""INVALID_S4U2SELF_CHECKSUM"" ; krb5_free_pa_s4u_x509_user ( context , * s4u_x509_user ) ; * s4u_x509_user = NULL ; return code ; } if ( krb5_princ_size ( context , ( * s4u_x509_user ) -> user_id . user ) == 0 || ( * s4u_x509_user ) -> user_id . subject_cert . length != 0 ) { * status = ""INVALID_S4U2SELF_REQUEST"" ; krb5_free_pa_s4u_x509_user ( context , * s4u_x509_user ) ; * s4u_x509_user = NULL ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } return 0 ; }
","<S2SV_ModStart> ( code ) { * status = ""DECODE_PA_S4U_X509_USER"" ; return code ; } <S2SV_ModEnd> code = verify_s4u_x509_user_checksum
"
460,"CWE-119 <S2SV_StartBug> static int scsi_disk_emulate_command ( SCSIDiskReq * r , uint8_t * outbuf ) <S2SV_EndBug> { SCSIRequest * req = & r -> req ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; uint64_t nb_sectors ; int buflen = 0 ; switch ( req -> cmd . buf [ 0 ] ) { case TEST_UNIT_READY : if ( s -> tray_open || ! bdrv_is_inserted ( s -> bs ) ) goto not_ready ; break ; case INQUIRY : buflen = scsi_disk_emulate_inquiry ( req , outbuf ) ; if ( buflen < 0 ) goto illegal_request ; break ; case MODE_SENSE : case MODE_SENSE_10 : buflen = scsi_disk_emulate_mode_sense ( r , outbuf ) ; if ( buflen < 0 ) goto illegal_request ; break ; case READ_TOC : buflen = scsi_disk_emulate_read_toc ( req , outbuf ) ; if ( buflen < 0 ) goto illegal_request ; break ; case RESERVE : if ( req -> cmd . buf [ 1 ] & 1 ) goto illegal_request ; break ; case RESERVE_10 : if ( req -> cmd . buf [ 1 ] & 3 ) goto illegal_request ; break ; case RELEASE : if ( req -> cmd . buf [ 1 ] & 1 ) goto illegal_request ; break ; case RELEASE_10 : if ( req -> cmd . buf [ 1 ] & 3 ) goto illegal_request ; break ; case START_STOP : if ( scsi_disk_emulate_start_stop ( r ) < 0 ) { return - 1 ; } break ; case ALLOW_MEDIUM_REMOVAL : s -> tray_locked = req -> cmd . buf [ 4 ] & 1 ; bdrv_lock_medium ( s -> bs , req -> cmd . buf [ 4 ] & 1 ) ; break ; case READ_CAPACITY_10 : memset ( outbuf , 0 , 8 ) ; bdrv_get_geometry ( s -> bs , & nb_sectors ) ; if ( ! nb_sectors ) goto not_ready ; nb_sectors /= s -> cluster_size ; nb_sectors -- ; s -> max_lba = nb_sectors ; if ( nb_sectors > UINT32_MAX ) nb_sectors = UINT32_MAX ; outbuf [ 0 ] = ( nb_sectors >> 24 ) & 0xff ; outbuf [ 1 ] = ( nb_sectors >> 16 ) & 0xff ; outbuf [ 2 ] = ( nb_sectors >> 8 ) & 0xff ; outbuf [ 3 ] = nb_sectors & 0xff ; outbuf [ 4 ] = 0 ; outbuf [ 5 ] = 0 ; outbuf [ 6 ] = s -> cluster_size * 2 ; outbuf [ 7 ] = 0 ; buflen = 8 ; break ; case GET_CONFIGURATION : memset ( outbuf , 0 , 8 ) ; outbuf [ 7 ] = 8 ; buflen = 8 ; break ; case SERVICE_ACTION_IN_16 : if ( ( req -> cmd . buf [ 1 ] & 31 ) == SAI_READ_CAPACITY_16 ) { DPRINTF ( ""SAI<S2SV_blank>READ<S2SV_blank>CAPACITY(16)\\n"" ) ; memset ( outbuf , 0 , req -> cmd . xfer ) ; bdrv_get_geometry ( s -> bs , & nb_sectors ) ; if ( ! nb_sectors ) goto not_ready ; nb_sectors /= s -> cluster_size ; nb_sectors -- ; s -> max_lba = nb_sectors ; outbuf [ 0 ] = ( nb_sectors >> 56 ) & 0xff ; outbuf [ 1 ] = ( nb_sectors >> 48 ) & 0xff ; outbuf [ 2 ] = ( nb_sectors >> 40 ) & 0xff ; outbuf [ 3 ] = ( nb_sectors >> 32 ) & 0xff ; outbuf [ 4 ] = ( nb_sectors >> 24 ) & 0xff ; outbuf [ 5 ] = ( nb_sectors >> 16 ) & 0xff ; outbuf [ 6 ] = ( nb_sectors >> 8 ) & 0xff ; outbuf [ 7 ] = nb_sectors & 0xff ; outbuf [ 8 ] = 0 ; outbuf [ 9 ] = 0 ; outbuf [ 10 ] = s -> cluster_size * 2 ; outbuf [ 11 ] = 0 ; outbuf [ 12 ] = 0 ; outbuf [ 13 ] = get_physical_block_exp ( & s -> qdev . conf ) ; if ( s -> qdev . conf . discard_granularity ) { outbuf [ 14 ] = 0x80 ; } buflen = req -> cmd . xfer ; break ; } DPRINTF ( ""Unsupported<S2SV_blank>Service<S2SV_blank>Action<S2SV_blank>In\\n"" ) ; goto illegal_request ; case VERIFY_10 : break ; default : scsi_check_condition ( r , SENSE_CODE ( INVALID_OPCODE ) ) ; return - 1 ; } return buflen ; not_ready : if ( s -> tray_open || ! bdrv_is_inserted ( s -> bs ) ) { scsi_check_condition ( r , SENSE_CODE ( NO_MEDIUM ) ) ; } else { scsi_check_condition ( r , SENSE_CODE ( LUN_NOT_READY ) ) ; } return - 1 ; illegal_request : if ( r -> req . status == - 1 ) { scsi_check_condition ( r , SENSE_CODE ( INVALID_FIELD ) ) ; } return - 1 ; }
","<S2SV_ModStart> SCSIDiskReq * r ) { SCSIRequest * req = & r -> req ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; uint64_t nb_sectors ; <S2SV_ModEnd> uint8_t * outbuf <S2SV_ModStart> uint8_t * outbuf ; int buflen = 0 ; if ( ! r -> iov . iov_base ) { if ( req -> cmd . xfer > 65536 ) { goto illegal_request ; } r -> buflen = MAX ( 4096 , req -> cmd . xfer ) ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } outbuf = r -> iov . iov_base <S2SV_ModEnd> ; switch (
"
461,"CWE-617 static int er_supported ( ERContext * s ) { if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f || <S2SV_StartBug> s -> cur_pic . field_picture || <S2SV_EndBug> s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) return 0 ; return 1 ; }
","<S2SV_ModStart> cur_pic . field_picture <S2SV_ModEnd> ) return 0
"
462,"CWE-000 static int rds_loop_xmit ( struct rds_connection * conn , struct rds_message * rm , unsigned int hdr_off , unsigned int sg , unsigned int off ) { <S2SV_StartBug> if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) { <S2SV_EndBug> rds_cong_map_updated ( conn -> c_fcong , ~ ( u64 ) 0 ) ; <S2SV_StartBug> return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ; <S2SV_EndBug> } BUG_ON ( hdr_off || sg || off ) ; rds_inc_init ( & rm -> m_inc , conn , conn -> c_laddr ) ; rds_message_addref ( rm ) ; rds_recv_incoming ( conn , conn -> c_laddr , conn -> c_faddr , & rm -> m_inc , GFP_KERNEL , KM_USER0 ) ; rds_send_drop_acked ( conn , be64_to_cpu ( rm -> m_inc . i_hdr . h_sequence ) , NULL ) ; rds_inc_put ( & rm -> m_inc ) ; <S2SV_StartBug> return sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; <S2SV_EndBug> }
","<S2SV_ModStart> off ) { struct scatterlist * sgp = & rm -> data . op_sg [ sg ] ; int ret = sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; <S2SV_ModStart> 0 ) ; ret = min_t ( int , ret , sgp -> length - conn -> c_xmit_data_off ) ; goto out <S2SV_ModEnd> ; } BUG_ON <S2SV_ModStart> m_inc ) ; out : return ret <S2SV_ModEnd> ; } <S2SV_null>
"
463,"CWE-119 static struct grub_ext4_extent_header * grub_ext4_find_leaf ( struct grub_ext2_data * data , char * buf , struct grub_ext4_extent_header * ext_block , grub_uint32_t fileblock ) { struct grub_ext4_extent_idx * index ; while ( 1 ) { int i ; grub_disk_addr_t block ; index = ( struct grub_ext4_extent_idx * ) ( ext_block + 1 ) ; if ( grub_le_to_cpu16 ( ext_block -> magic ) != EXT4_EXT_MAGIC ) return 0 ; if ( ext_block -> depth == 0 ) return ext_block ; for ( i = 0 ; i < grub_le_to_cpu16 ( ext_block -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( index [ i ] . block ) ) break ; } if ( -- i < 0 ) return 0 ; block = grub_le_to_cpu16 ( index [ i ] . leaf_hi ) ; block = ( block << 32 ) + grub_le_to_cpu32 ( index [ i ] . leaf ) ; if ( grub_disk_read ( data -> disk , block << LOG2_EXT2_BLOCK_SIZE ( data ) , 0 , EXT2_BLOCK_SIZE ( data ) , buf ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> ext_block = ( struct grub_ext4_extent_header * ) buf ; } }
","<S2SV_ModStart> buf ) ) { return 0 ; } <S2SV_ModEnd> ext_block = (
"
464,"CWE-20 long keyctl_read_key ( key_serial_t keyid , char __user * buffer , size_t buflen ) { struct key * key ; key_ref_t key_ref ; long ret ; key_ref = lookup_user_key ( keyid , 0 , 0 ) ; if ( IS_ERR ( key_ref ) ) { ret = - ENOKEY ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <S2SV_EndBug> ret = - ENOKEY ; goto error2 ; } ret = key_permission ( key_ref , KEY_NEED_READ ) ; if ( ret == 0 ) goto can_read_key ; if ( ret != - EACCES ) goto error2 ; if ( ! is_key_possessed ( key_ref ) ) { ret = - EACCES ; goto error2 ; } can_read_key : ret = - EOPNOTSUPP ; if ( key -> type -> read ) { down_read ( & key -> sem ) ; ret = key_validate ( key ) ; if ( ret == 0 ) ret = key -> type -> read ( key , buffer , buflen ) ; up_read ( & key -> sem ) ; } error2 : key_put ( key ) ; error : return ret ; }
","<S2SV_ModStart> key_ref ) ; ret = key_read_state ( key ) ; if ( ret < 0 ) goto error2 ; <S2SV_ModEnd> ret = key_permission
"
465,"CWE-125 int mobility_print ( netdissect_options * ndo , const u_char * bp , const u_char * bp2 _U_ ) { const struct ip6_mobility * mh ; const u_char * ep ; unsigned mhlen , hlen ; uint8_t type ; mh = ( const struct ip6_mobility * ) bp ; ep = ndo -> ndo_snapend ; if ( ! ND_TTEST ( mh -> ip6m_len ) ) { mhlen = ep - bp ; goto trunc ; } mhlen = ( mh -> ip6m_len + 1 ) << 3 ; ND_TCHECK ( mh -> ip6m_type ) ; type = mh -> ip6m_type ; if ( type <= IP6M_MAX && mhlen < ip6m_hdrlen [ type ] ) { ND_PRINT ( ( ndo , ""(header<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>for<S2SV_blank>type<S2SV_blank>%u)"" , mhlen , type ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""mobility:<S2SV_blank>%s"" , tok2str ( ip6m_str , ""type-#%u"" , type ) ) ) ; switch ( type ) { case IP6M_BINDING_REQUEST : hlen = IP6M_MINLEN ; break ; case IP6M_HOME_TEST_INIT : case IP6M_CAREOF_TEST_INIT : hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_HOME_TEST : case IP6M_CAREOF_TEST : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>nonce<S2SV_blank>id=0x%x"" , EXTRACT_16BITS ( & mh -> ip6m_data16 [ 0 ] ) ) ) ; hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; if ( ndo -> ndo_vflag ) { <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_BINDING_UPDATE : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & mh -> ip6m_data16 [ 0 ] ) ) ) ; hlen = IP6M_MINLEN ; <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bp [ hlen ] & 0xf0 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( bp [ hlen ] & 0x80 ) ND_PRINT ( ( ndo , ""A"" ) ) ; if ( bp [ hlen ] & 0x40 ) ND_PRINT ( ( ndo , ""H"" ) ) ; if ( bp [ hlen ] & 0x20 ) ND_PRINT ( ( ndo , ""L"" ) ) ; if ( bp [ hlen ] & 0x10 ) <S2SV_StartBug> ND_PRINT ( ( ndo , ""K"" ) ) ; <S2SV_EndBug> hlen += 1 ; hlen += 1 ; <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ; hlen += 2 ; break ; case IP6M_BINDING_ACK : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>status=%u"" , mh -> ip6m_data8 [ 0 ] ) ) ; <S2SV_StartBug> if ( mh -> ip6m_data8 [ 1 ] & 0x80 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>K"" ) ) ; hlen = IP6M_MINLEN ; <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) ) ) ; hlen += 2 ; <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ; hlen += 2 ; break ; case IP6M_BINDING_ERROR : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>status=%u"" , mh -> ip6m_data8 [ 0 ] ) ) ; hlen = IP6M_MINLEN ; <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 16 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>homeaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ; hlen += 16 ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>len=%u"" , mh -> ip6m_len ) ) ; return ( mhlen ) ; break ; } if ( ndo -> ndo_vflag ) if ( mobility_opt_print ( ndo , & bp [ hlen ] , mhlen - hlen ) ) goto trunc ; return ( mhlen ) ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( - 1 ) ; }
","<S2SV_ModStart> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> = IP6M_MINLEN ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; if <S2SV_ModStart> & 0xf0 ) { <S2SV_ModStart> ) ) ; } <S2SV_ModStart> += 1 ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ) ) ; ND_TCHECK <S2SV_ModEnd> ( mh -> <S2SV_ModStart> [ 1 ] ) ; if ( mh -> ip6m_data8 [ 1 ] <S2SV_ModStart> = IP6M_MINLEN ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> += 2 ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ; ND_TCHECK2 ( bp [ hlen ] , <S2SV_ModEnd> 16 ) ;
"
466,"CWE-000 static void ieee80211_if_setup ( struct net_device * dev ) { ether_setup ( dev ) ; <S2SV_StartBug> dev -> netdev_ops = & ieee80211_dataif_ops ; <S2SV_EndBug> dev -> destructor = free_netdev ; }
","<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
"
467,"CWE-125 struct _mdi * _WM_ParseNewHmi ( uint8_t * hmi_data , uint32_t hmi_size ) { uint32_t hmi_tmp = 0 ; uint8_t * hmi_base = hmi_data ; <S2SV_StartBug> uint16_t hmi_bpm = 0 ; <S2SV_EndBug> uint16_t hmi_division = 0 ; uint32_t hmi_track_cnt = 0 ; uint32_t * hmi_track_offset = NULL ; uint32_t i = 0 ; uint32_t j = 0 ; uint8_t * hmi_addr = NULL ; uint32_t * hmi_track_header_length = NULL ; struct _mdi * hmi_mdi = NULL ; uint32_t tempo_f = 5000000.0 ; uint32_t * hmi_track_end = NULL ; uint8_t hmi_tracks_ended = 0 ; uint8_t * hmi_running_event = NULL ; uint32_t setup_ret = 0 ; uint32_t * hmi_delta = NULL ; uint32_t smallest_delta = 0 ; uint32_t subtract_delta = 0 ; uint32_t sample_count = 0 ; float sample_count_f = 0 ; float sample_remainder = 0 ; float samples_per_delta_f = 0.0 ; struct _note { uint32_t length ; uint8_t channel ; <S2SV_StartBug> } * note ; <S2SV_EndBug> UNUSED ( hmi_size ) ; if ( memcmp ( hmi_data , ""HMI-MIDISONG061595"" , 18 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , NULL , 0 ) ; return NULL ; } hmi_bpm = hmi_data [ 212 ] ; hmi_division = 60 ; hmi_track_cnt = hmi_data [ 228 ] ; hmi_mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( hmi_mdi , hmi_division ) ; if ( ( _WM_MixerOptions & WM_MO_ROUNDTEMPO ) ) { tempo_f = ( float ) ( 60000000 / hmi_bpm ) + 0.5f ; } else { tempo_f = ( float ) ( 60000000 / hmi_bpm ) ; } samples_per_delta_f = _WM_GetSamplesPerTick ( hmi_division , ( uint32_t ) tempo_f ) ; _WM_midi_setup_tempo ( hmi_mdi , ( uint32_t ) tempo_f ) ; hmi_track_offset = ( uint32_t * ) malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_track_header_length = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_track_end = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; hmi_delta = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; note = malloc ( sizeof ( struct _note ) * 128 * hmi_track_cnt ) ; hmi_running_event = malloc ( sizeof ( uint8_t ) * 128 * hmi_track_cnt ) ; hmi_data += 370 ; smallest_delta = 0xffffffff ; if ( hmi_size < ( 370 + ( hmi_track_cnt * 17 ) ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } hmi_track_offset [ 0 ] = * hmi_data ; for ( i = 0 ; i < hmi_track_cnt ; i ++ ) { hmi_track_offset [ i ] = * hmi_data ++ ; hmi_track_offset [ i ] += ( * hmi_data ++ << 8 ) ; hmi_track_offset [ i ] += ( * hmi_data ++ << 16 ) ; hmi_track_offset [ i ] += ( * hmi_data ++ << 24 ) ; if ( hmi_size < ( hmi_track_offset [ i ] + 0x5a + 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } hmi_addr = hmi_base + hmi_track_offset [ i ] ; if ( memcmp ( hmi_addr , ""HMI-MIDITRACK"" , 13 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , NULL , 0 ) ; goto _hmi_end ; } hmi_track_header_length [ i ] = hmi_addr [ 0x57 ] ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x58 ] << 8 ) ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x59 ] << 16 ) ; hmi_track_header_length [ i ] += ( hmi_addr [ 0x5a ] << 24 ) ; hmi_addr += hmi_track_header_length [ i ] ; hmi_track_offset [ i ] += hmi_track_header_length [ i ] ; hmi_delta [ i ] = 0 ; if ( * hmi_addr > 0x7f ) { do { hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) + ( * hmi_addr & 0x7f ) ; hmi_addr ++ ; hmi_track_offset [ i ] ++ ; } while ( * hmi_addr > 0x7f ) ; } hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) + ( * hmi_addr & 0x7f ) ; hmi_track_offset [ i ] ++ ; hmi_addr ++ ; if ( hmi_delta [ i ] < smallest_delta ) { smallest_delta = hmi_delta [ i ] ; } hmi_track_end [ i ] = 0 ; hmi_running_event [ i ] = 0 ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; note [ hmi_tmp ] . length = 0 ; note [ hmi_tmp ] . channel = 0 ; } } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; hmi_mdi -> events [ hmi_mdi -> event_count - 1 ] . samples_to_next += sample_count ; hmi_mdi -> extra_info . approx_total_samples += sample_count ; while ( hmi_tracks_ended < hmi_track_cnt ) { smallest_delta = 0 ; for ( i = 0 ; i < hmi_track_cnt ; i ++ ) { if ( hmi_track_end [ i ] ) continue ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; if ( note [ hmi_tmp ] . length ) { note [ hmi_tmp ] . length -= subtract_delta ; if ( note [ hmi_tmp ] . length ) { if ( ( ! smallest_delta ) || ( smallest_delta > note [ hmi_tmp ] . length ) ) { smallest_delta = note [ hmi_tmp ] . length ; } } else { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; } } } if ( hmi_delta [ i ] ) { hmi_delta [ i ] -= subtract_delta ; if ( hmi_delta [ i ] ) { if ( ( ! smallest_delta ) || ( smallest_delta > hmi_delta [ i ] ) ) { smallest_delta = hmi_delta [ i ] ; } continue ; } } do { hmi_data = hmi_base + hmi_track_offset [ i ] ; hmi_delta [ i ] = 0 ; <S2SV_StartBug> if ( hmi_data [ 0 ] == 0xfe ) { <S2SV_EndBug> if ( hmi_data [ 1 ] == 0x10 ) { hmi_tmp = ( hmi_data [ 4 ] + 5 ) ; hmi_data += hmi_tmp ; hmi_track_offset [ i ] += hmi_tmp ; <S2SV_StartBug> } else if ( hmi_data [ 1 ] == 0x15 ) { <S2SV_EndBug> hmi_data += 4 ; hmi_track_offset [ i ] += 4 ; <S2SV_StartBug> } <S2SV_EndBug> hmi_data += 4 ; hmi_track_offset [ i ] += 4 ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , hmi_running_event [ i ] ) ) == 0 ) { <S2SV_EndBug> goto _hmi_end ; } if ( ( hmi_data [ 0 ] == 0xff ) && ( hmi_data [ 1 ] == 0x2f ) && ( hmi_data [ 2 ] == 0x00 ) ) { hmi_track_end [ i ] = 1 ; hmi_tracks_ended ++ ; for ( j = 0 ; j < 128 ; j ++ ) { hmi_tmp = ( 128 * i ) + j ; if ( note [ hmi_tmp ] . length ) { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; note [ hmi_tmp ] . length = 0 ; } } goto _hmi_next_track ; } if ( ( * hmi_data == 0xF0 ) || ( * hmi_data == 0xF7 ) ) { hmi_running_event [ i ] = 0 ; } else if ( * hmi_data < 0xF0 ) { if ( * hmi_data >= 0x80 ) { hmi_running_event [ i ] = * hmi_data ; } } if ( ( hmi_running_event [ i ] & 0xf0 ) == 0x90 ) { if ( * hmi_data > 127 ) { hmi_tmp = hmi_data [ 1 ] ; } else { hmi_tmp = * hmi_data ; } hmi_tmp += ( i * 128 ) ; note [ hmi_tmp ] . channel = hmi_running_event [ i ] & 0xf ; hmi_data += setup_ret ; hmi_track_offset [ i ] += setup_ret ; <S2SV_StartBug> note [ hmi_tmp ] . length = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( * hmi_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ; hmi_data ++ ; <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> } while ( * hmi_data > 0x7F ) ; <S2SV_EndBug> } note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ; hmi_data ++ ; <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> if ( note [ hmi_tmp ] . length ) { if ( ( ! smallest_delta ) || ( smallest_delta > note [ hmi_tmp ] . length ) ) { smallest_delta = note [ hmi_tmp ] . length ; } } else { _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; } } else { hmi_data += setup_ret ; hmi_track_offset [ i ] += setup_ret ; <S2SV_StartBug> } <S2SV_EndBug> } if ( * hmi_data > 0x7f ) { do { <S2SV_StartBug> hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ; <S2SV_EndBug> hmi_data ++ ; <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> } while ( * hmi_data > 0x7F ) ; } <S2SV_StartBug> hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> hmi_data ++ ; <S2SV_EndBug> hmi_track_offset [ i ] ++ ; } while ( ! hmi_delta [ i ] ) ; if ( ( ! smallest_delta ) || ( smallest_delta > hmi_delta [ i ] ) ) { smallest_delta = hmi_delta [ i ] ; } _hmi_next_track : hmi_tmp = 0 ; UNUSED ( hmi_tmp ) ; } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; hmi_mdi -> events [ hmi_mdi -> event_count - 1 ] . samples_to_next += sample_count ; hmi_mdi -> extra_info . approx_total_samples += sample_count ; } if ( ( hmi_mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""to<S2SV_blank>init<S2SV_blank>reverb"" , 0 ) ; goto _hmi_end ; } hmi_mdi -> extra_info . current_sample = 0 ; hmi_mdi -> current_event = & hmi_mdi -> events [ 0 ] ; hmi_mdi -> samples_to_mix = 0 ; hmi_mdi -> note = NULL ; _WM_ResetToStart ( hmi_mdi ) ; _hmi_end : free ( hmi_track_offset ) ; free ( hmi_track_header_length ) ; free ( hmi_track_end ) ; free ( hmi_delta ) ; free ( note ) ; free ( hmi_running_event ) ; if ( hmi_mdi -> reverb ) return ( hmi_mdi ) ; _WM_freeMDI ( hmi_mdi ) ; return 0 ; }
","<S2SV_ModStart> = hmi_data ; uint32_t data_siz ; <S2SV_ModStart> } * note <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( hmi_track_offset [ i ] >= hmi_size ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } data_siz = hmi_size - hmi_track_offset [ i ] ; if ( <S2SV_ModStart> += hmi_tmp ; hmi_tmp += 4 ; <S2SV_ModStart> += 4 ; hmi_tmp = 8 ; } else { hmi_tmp = 4 ; } hmi_data <S2SV_ModEnd> += 4 ; <S2SV_ModStart> += 4 ; hmi_track_offset [ i ] += 4 ; if ( hmi_tmp > data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } data_siz -= hmi_tmp ; <S2SV_ModStart> hmi_mdi , hmi_data , data_siz <S2SV_ModStart> += setup_ret ; data_siz -= setup_ret ; <S2SV_ModStart> ; if ( data_siz && <S2SV_ModStart> { do { if ( ! data_siz ) break ; <S2SV_ModStart> hmi_data ++ ; data_siz -- ; <S2SV_ModStart> > 0x7F ) ; } if ( ! data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end <S2SV_ModStart> hmi_data ++ ; data_siz -- ; <S2SV_ModStart> += setup_ret ; data_siz -= setup_ret ; } } if ( data_siz && <S2SV_ModEnd> * hmi_data > <S2SV_ModStart> { do { if ( ! data_siz ) break ; <S2SV_ModStart> hmi_data ++ ; data_siz -- ; <S2SV_ModStart> ) ; } if ( ! data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } <S2SV_ModStart> ; hmi_data ++ ; data_siz --
"
468,"CWE-200 static int hci_sock_getname ( struct socket * sock , struct sockaddr * addr , int * addr_len , int peer ) { struct sockaddr_hci * haddr = ( struct sockaddr_hci * ) addr ; struct sock * sk = sock -> sk ; struct hci_dev * hdev = hci_pi ( sk ) -> hdev ; BT_DBG ( ""sock<S2SV_blank>%p<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ; if ( ! hdev ) return - EBADFD ; lock_sock ( sk ) ; * addr_len = sizeof ( * haddr ) ; haddr -> hci_family = AF_BLUETOOTH ; haddr -> hci_dev = hdev -> id ; <S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> -> id ; haddr -> hci_channel = 0 ;
"
469,"CWE-200 static int isofs_export_encode_fh ( struct inode * inode , __u32 * fh32 , int * max_len , struct inode * parent ) { struct iso_inode_info * ei = ISOFS_I ( inode ) ; int len = * max_len ; int type = 1 ; __u16 * fh16 = ( __u16 * ) fh32 ; if ( parent && ( len < 5 ) ) { * max_len = 5 ; return 255 ; } else if ( len < 3 ) { * max_len = 3 ; return 255 ; } len = 3 ; fh32 [ 0 ] = ei -> i_iget5_block ; fh16 [ 2 ] = ( __u16 ) ei -> i_iget5_offset ; <S2SV_StartBug> fh32 [ 2 ] = inode -> i_generation ; <S2SV_EndBug> if ( parent ) { struct iso_inode_info * eparent ; eparent = ISOFS_I ( parent ) ; fh32 [ 3 ] = eparent -> i_iget5_block ; fh16 [ 3 ] = ( __u16 ) eparent -> i_iget5_offset ; fh32 [ 4 ] = parent -> i_generation ; len = 5 ; type = 2 ; } * max_len = len ; return type ; }
","<S2SV_ModStart> -> i_iget5_offset ; fh16 [ 3 ] = 0 ;
"
470,"CWE-476 int validate_as_request ( kdc_realm_t * kdc_active_realm , register krb5_kdc_req * request , krb5_db_entry client , krb5_db_entry server , krb5_timestamp kdc_time , const char * * status , krb5_pa_data * * * e_data ) { int errcode ; krb5_error_code ret ; if ( request -> kdc_options & AS_INVALID_OPTIONS ) { * status = ""INVALID<S2SV_blank>AS<S2SV_blank>OPTIONS"" ; return KDC_ERR_BADOPTION ; } if ( client . expiration && client . expiration < kdc_time ) { * status = ""CLIENT<S2SV_blank>EXPIRED"" ; if ( vague_errors ) return ( KRB_ERR_GENERIC ) ; else return ( KDC_ERR_NAME_EXP ) ; } if ( client . pw_expiration && client . pw_expiration < kdc_time && ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { * status = ""CLIENT<S2SV_blank>KEY<S2SV_blank>EXPIRED"" ; if ( vague_errors ) return ( KRB_ERR_GENERIC ) ; else return ( KDC_ERR_KEY_EXP ) ; } if ( server . expiration && server . expiration < kdc_time ) { * status = ""SERVICE<S2SV_blank>EXPIRED"" ; return ( KDC_ERR_SERVICE_EXP ) ; } if ( isflagset ( client . attributes , KRB5_KDB_REQUIRES_PWCHANGE ) && ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { * status = ""REQUIRED<S2SV_blank>PWCHANGE"" ; return ( KDC_ERR_KEY_EXP ) ; } if ( ( isflagset ( request -> kdc_options , KDC_OPT_ALLOW_POSTDATE ) || isflagset ( request -> kdc_options , KDC_OPT_POSTDATED ) ) && ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_POSTDATED ) || isflagset ( server . attributes , KRB5_KDB_DISALLOW_POSTDATED ) ) ) { * status = ""POSTDATE<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ; return ( KDC_ERR_CANNOT_POSTDATE ) ; } if ( isflagset ( request -> kdc_options , KDC_OPT_PROXIABLE ) && ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_PROXIABLE ) || isflagset ( server . attributes , KRB5_KDB_DISALLOW_PROXIABLE ) ) ) { * status = ""PROXIABLE<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ; return ( KDC_ERR_POLICY ) ; } if ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_ALL_TIX ) ) { * status = ""CLIENT<S2SV_blank>LOCKED<S2SV_blank>OUT"" ; return ( KDC_ERR_CLIENT_REVOKED ) ; } if ( isflagset ( server . attributes , KRB5_KDB_DISALLOW_ALL_TIX ) ) { * status = ""SERVICE<S2SV_blank>LOCKED<S2SV_blank>OUT"" ; return ( KDC_ERR_S_PRINCIPAL_UNKNOWN ) ; } if ( isflagset ( server . attributes , KRB5_KDB_DISALLOW_SVR ) ) { * status = ""SERVICE<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ; return ( KDC_ERR_MUST_USE_USER2USER ) ; } <S2SV_StartBug> if ( check_anon ( kdc_active_realm , request -> client , request -> server ) != 0 ) { <S2SV_EndBug> * status = ""ANONYMOUS<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ; return ( KDC_ERR_POLICY ) ; } ret = krb5_db_check_policy_as ( kdc_context , request , & client , & server , kdc_time , status , e_data ) ; if ( ret && ret != KRB5_PLUGIN_OP_NOTSUPP ) return errcode_to_protocol ( ret ) ; errcode = against_local_policy_as ( request , client , server , kdc_time , status , e_data ) ; if ( errcode ) return errcode ; return 0 ; }
","<S2SV_ModStart> ( kdc_active_realm , client . princ <S2SV_ModEnd> , request ->
"
471,"CWE-119 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_32 ( dst_reg ) ; coerce_reg_to_32 ( & src_reg ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } <S2SV_StartBug> if ( dst_reg -> smin_value < 0 ) { <S2SV_EndBug> if ( umin_val ) { dst_reg -> smin_value = 0 ; } else { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; <S2SV_StartBug> } <S2SV_EndBug> } else { dst_reg -> smin_value = ( u64 ) ( dst_reg -> smin_value ) >> umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }
","<S2SV_ModStart> break ; } <S2SV_ModEnd> dst_reg -> smin_value <S2SV_ModStart> = S64_MAX ; <S2SV_ModEnd> if ( src_known
"
472,"CWE-119 void vp9_pick_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi , LPF_PICK_METHOD method ) { VP9_COMMON * const cm = & cpi -> common ; struct loopfilter * const lf = & cm -> lf ; lf -> sharpness_level = cm -> frame_type == KEY_FRAME ? 0 : cpi -> oxcf . sharpness ; <S2SV_StartBug> if ( method == LPF_PICK_FROM_Q ) { <S2SV_EndBug> const int min_filter_level = 0 ; const int max_filter_level = get_max_filter_level ( cpi ) ; <S2SV_StartBug> const int q = vp9_ac_quant ( cm -> base_qindex , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> int filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ; <S2SV_EndBug> if ( cm -> frame_type == KEY_FRAME ) filt_guess -= 4 ; lf -> filter_level = clamp ( filt_guess , min_filter_level , max_filter_level ) ; } else { <S2SV_StartBug> search_filter_level ( sd , cpi , method == LPF_PICK_FROM_SUBIMAGE ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> ( method == LPF_PICK_MINIMAL_LPF && lf -> filter_level ) { lf -> filter_level = 0 ; } else if ( method >= <S2SV_ModStart> base_qindex , 0 , cm -> bit_depth ) ; # if CONFIG_VP9_HIGHBITDEPTH int filt_guess ; switch ( cm -> bit_depth ) { case VPX_BITS_8 : <S2SV_ModEnd> filt_guess = ROUND_POWER_OF_TWO <S2SV_ModStart> 18 ) ; break ; case VPX_BITS_10 : filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 4060632 , 20 ) ; break ; case VPX_BITS_12 : filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 16242526 , 22 ) ; break ; default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>"" ""or<S2SV_blank>VPX_BITS_12"" ) ; return ; } # else int filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ; # endif <S2SV_ModStart> } else { lf -> filter_level =
"
473,"CWE-284 static void btif_dm_upstreams_evt ( UINT16 event , char * p_param ) { tBTA_DM_SEC * p_data = ( tBTA_DM_SEC * ) p_param ; tBTA_SERVICE_MASK service_mask ; uint32_t i ; bt_bdaddr_t bd_addr ; BTIF_TRACE_EVENT ( ""btif_dm_upstreams_cback<S2SV_blank><S2SV_blank>ev:<S2SV_blank>%s"" , dump_dm_event ( event ) ) ; switch ( event ) { case BTA_DM_ENABLE_EVT : { BD_NAME bdname ; bt_status_t status ; bt_property_t prop ; prop . type = BT_PROPERTY_BDNAME ; prop . len = BD_NAME_LEN ; prop . val = ( void * ) bdname ; status = btif_storage_get_adapter_property ( & prop ) ; if ( status == BT_STATUS_SUCCESS ) { BTA_DmSetDeviceName ( ( char * ) prop . val ) ; } else { BTA_DmSetDeviceName ( btif_get_default_local_name ( ) ) ; } # if ( defined ( BLE_INCLUDED ) && ( BLE_INCLUDED == TRUE ) ) BTA_DmBleConfigLocalPrivacy ( BLE_LOCAL_PRIVACY_ENABLED ) ; # endif service_mask = btif_get_enabled_services_mask ( ) ; for ( i = 0 ; i <= BTA_MAX_SERVICE_ID ; i ++ ) { if ( service_mask & ( tBTA_SERVICE_MASK ) ( BTA_SERVICE_ID_TO_SERVICE_MASK ( i ) ) ) { btif_in_execute_service_request ( i , TRUE ) ; } } memset ( & pairing_cb , 0 , sizeof ( btif_dm_pairing_cb_t ) ) ; pairing_cb . bond_type = BOND_TYPE_PERSISTENT ; btif_storage_load_bonded_devices ( ) ; btif_storage_load_autopair_device_list ( ) ; btif_enable_bluetooth_evt ( p_data -> enable . status ) ; } break ; case BTA_DM_DISABLE_EVT : service_mask = btif_get_enabled_services_mask ( ) ; for ( i = 0 ; i <= BTA_MAX_SERVICE_ID ; i ++ ) { if ( service_mask & ( tBTA_SERVICE_MASK ) ( BTA_SERVICE_ID_TO_SERVICE_MASK ( i ) ) ) { btif_in_execute_service_request ( i , FALSE ) ; } } btif_disable_bluetooth_evt ( ) ; break ; case BTA_DM_PIN_REQ_EVT : btif_dm_pin_req_evt ( & p_data -> pin_req ) ; break ; case BTA_DM_AUTH_CMPL_EVT : btif_dm_auth_cmpl_evt ( & p_data -> auth_cmpl ) ; break ; case BTA_DM_BOND_CANCEL_CMPL_EVT : if ( pairing_cb . state == BT_BOND_STATE_BONDING ) { bdcpy ( bd_addr . address , pairing_cb . bd_addr ) ; btm_set_bond_type_dev ( pairing_cb . bd_addr , BOND_TYPE_UNKNOWN ) ; bond_state_changed ( p_data -> bond_cancel_cmpl . result , & bd_addr , BT_BOND_STATE_NONE ) ; } break ; case BTA_DM_SP_CFM_REQ_EVT : btif_dm_ssp_cfm_req_evt ( & p_data -> cfm_req ) ; break ; case BTA_DM_SP_KEY_NOTIF_EVT : btif_dm_ssp_key_notif_evt ( & p_data -> key_notif ) ; break ; case BTA_DM_DEV_UNPAIRED_EVT : bdcpy ( bd_addr . address , p_data -> link_down . bd_addr ) ; btm_set_bond_type_dev ( p_data -> link_down . bd_addr , BOND_TYPE_UNKNOWN ) ; # if ( defined ( BTA_HH_INCLUDED ) && ( BTA_HH_INCLUDED == TRUE ) ) btif_hh_remove_device ( bd_addr ) ; # endif btif_storage_remove_bonded_device ( & bd_addr ) ; bond_state_changed ( BT_STATUS_SUCCESS , & bd_addr , BT_BOND_STATE_NONE ) ; break ; case BTA_DM_BUSY_LEVEL_EVT : { if ( p_data -> busy_level . level_flags & BTM_BL_INQUIRY_PAGING_MASK ) { if ( p_data -> busy_level . level_flags == BTM_BL_INQUIRY_STARTED ) { HAL_CBACK ( bt_hal_cbacks , discovery_state_changed_cb , BT_DISCOVERY_STARTED ) ; btif_dm_inquiry_in_progress = TRUE ; } else if ( p_data -> busy_level . level_flags == BTM_BL_INQUIRY_CANCELLED ) { HAL_CBACK ( bt_hal_cbacks , discovery_state_changed_cb , BT_DISCOVERY_STOPPED ) ; btif_dm_inquiry_in_progress = FALSE ; } else if ( p_data -> busy_level . level_flags == BTM_BL_INQUIRY_COMPLETE ) { btif_dm_inquiry_in_progress = FALSE ; } } } break ; case BTA_DM_LINK_UP_EVT : bdcpy ( bd_addr . address , p_data -> link_up . bd_addr ) ; BTIF_TRACE_DEBUG ( ""BTA_DM_LINK_UP_EVT.<S2SV_blank>Sending<S2SV_blank>BT_ACL_STATE_CONNECTED"" ) ; btif_update_remote_version_property ( & bd_addr ) ; HAL_CBACK ( bt_hal_cbacks , acl_state_changed_cb , BT_STATUS_SUCCESS , & bd_addr , BT_ACL_STATE_CONNECTED ) ; break ; case BTA_DM_LINK_DOWN_EVT : bdcpy ( bd_addr . address , p_data -> link_down . bd_addr ) ; btm_set_bond_type_dev ( p_data -> link_down . bd_addr , BOND_TYPE_UNKNOWN ) ; BTIF_TRACE_DEBUG ( ""BTA_DM_LINK_DOWN_EVT.<S2SV_blank>Sending<S2SV_blank>BT_ACL_STATE_DISCONNECTED"" ) ; HAL_CBACK ( bt_hal_cbacks , acl_state_changed_cb , BT_STATUS_SUCCESS , & bd_addr , BT_ACL_STATE_DISCONNECTED ) ; break ; case BTA_DM_HW_ERROR_EVT : BTIF_TRACE_ERROR ( ""Received<S2SV_blank>H/W<S2SV_blank>Error.<S2SV_blank>"" ) ; btif_config_flush ( ) ; <S2SV_StartBug> usleep ( 100000 ) ; <S2SV_EndBug> kill ( getpid ( ) , SIGKILL ) ; break ; # if ( defined ( BLE_INCLUDED ) && ( BLE_INCLUDED == TRUE ) ) case BTA_DM_BLE_KEY_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_KEY_EVT<S2SV_blank>key_type=0x%02x<S2SV_blank>"" , p_data -> ble_key . key_type ) ; if ( pairing_cb . state != BT_BOND_STATE_BONDING ) { BTIF_TRACE_DEBUG ( ""Bond<S2SV_blank>state<S2SV_blank>not<S2SV_blank>sent<S2SV_blank>to<S2SV_blank>App<S2SV_blank>so<S2SV_blank>far.Notify<S2SV_blank>the<S2SV_blank>app<S2SV_blank>now"" ) ; bond_state_changed ( BT_STATUS_SUCCESS , ( bt_bdaddr_t * ) p_data -> ble_key . bd_addr , BT_BOND_STATE_BONDING ) ; } else if ( memcmp ( pairing_cb . bd_addr , p_data -> ble_key . bd_addr , BD_ADDR_LEN ) != 0 ) { BTIF_TRACE_ERROR ( ""BD<S2SV_blank>mismatch<S2SV_blank>discard<S2SV_blank>BLE<S2SV_blank>key_type=%d<S2SV_blank>"" , p_data -> ble_key . key_type ) ; break ; } switch ( p_data -> ble_key . key_type ) { case BTA_LE_KEY_PENC : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_PENC"" ) ; pairing_cb . ble . is_penc_key_rcvd = TRUE ; pairing_cb . ble . penc_key = p_data -> ble_key . p_key_value -> penc_key ; break ; case BTA_LE_KEY_PID : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_PID"" ) ; pairing_cb . ble . is_pid_key_rcvd = TRUE ; pairing_cb . ble . pid_key = p_data -> ble_key . p_key_value -> pid_key ; break ; case BTA_LE_KEY_PCSRK : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_PCSRK"" ) ; pairing_cb . ble . is_pcsrk_key_rcvd = TRUE ; pairing_cb . ble . pcsrk_key = p_data -> ble_key . p_key_value -> pcsrk_key ; break ; case BTA_LE_KEY_LENC : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_LENC"" ) ; pairing_cb . ble . is_lenc_key_rcvd = TRUE ; pairing_cb . ble . lenc_key = p_data -> ble_key . p_key_value -> lenc_key ; break ; case BTA_LE_KEY_LCSRK : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_LCSRK"" ) ; pairing_cb . ble . is_lcsrk_key_rcvd = TRUE ; pairing_cb . ble . lcsrk_key = p_data -> ble_key . p_key_value -> lcsrk_key ; break ; case BTA_LE_KEY_LID : BTIF_TRACE_DEBUG ( ""Rcv<S2SV_blank>BTA_LE_KEY_LID"" ) ; pairing_cb . ble . is_lidk_key_rcvd = TRUE ; break ; default : BTIF_TRACE_ERROR ( ""unknown<S2SV_blank>BLE<S2SV_blank>key<S2SV_blank>type<S2SV_blank>(0x%02x)"" , p_data -> ble_key . key_type ) ; break ; } break ; case BTA_DM_BLE_SEC_REQ_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_SEC_REQ_EVT.<S2SV_blank>"" ) ; btif_dm_ble_sec_req_evt ( & p_data -> ble_req ) ; break ; case BTA_DM_BLE_PASSKEY_NOTIF_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_PASSKEY_NOTIF_EVT.<S2SV_blank>"" ) ; btif_dm_ble_key_notif_evt ( & p_data -> key_notif ) ; break ; case BTA_DM_BLE_PASSKEY_REQ_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_PASSKEY_REQ_EVT.<S2SV_blank>"" ) ; btif_dm_ble_passkey_req_evt ( & p_data -> pin_req ) ; break ; case BTA_DM_BLE_NC_REQ_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_PASSKEY_REQ_EVT.<S2SV_blank>"" ) ; btif_dm_ble_key_nc_req_evt ( & p_data -> key_notif ) ; break ; case BTA_DM_BLE_OOB_REQ_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_OOB_REQ_EVT.<S2SV_blank>"" ) ; break ; case BTA_DM_BLE_LOCAL_IR_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_LOCAL_IR_EVT.<S2SV_blank>"" ) ; ble_local_key_cb . is_id_keys_rcvd = TRUE ; memcpy ( & ble_local_key_cb . id_keys . irk [ 0 ] , & p_data -> ble_id_keys . irk [ 0 ] , sizeof ( BT_OCTET16 ) ) ; memcpy ( & ble_local_key_cb . id_keys . ir [ 0 ] , & p_data -> ble_id_keys . ir [ 0 ] , sizeof ( BT_OCTET16 ) ) ; memcpy ( & ble_local_key_cb . id_keys . dhk [ 0 ] , & p_data -> ble_id_keys . dhk [ 0 ] , sizeof ( BT_OCTET16 ) ) ; btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . id_keys . irk [ 0 ] , BTIF_DM_LE_LOCAL_KEY_IRK , BT_OCTET16_LEN ) ; btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . id_keys . ir [ 0 ] , BTIF_DM_LE_LOCAL_KEY_IR , BT_OCTET16_LEN ) ; btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . id_keys . dhk [ 0 ] , BTIF_DM_LE_LOCAL_KEY_DHK , BT_OCTET16_LEN ) ; break ; case BTA_DM_BLE_LOCAL_ER_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_LOCAL_ER_EVT.<S2SV_blank>"" ) ; ble_local_key_cb . is_er_rcvd = TRUE ; memcpy ( & ble_local_key_cb . er [ 0 ] , & p_data -> ble_er [ 0 ] , sizeof ( BT_OCTET16 ) ) ; btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . er [ 0 ] , BTIF_DM_LE_LOCAL_KEY_ER , BT_OCTET16_LEN ) ; break ; case BTA_DM_BLE_AUTH_CMPL_EVT : BTIF_TRACE_DEBUG ( ""BTA_DM_BLE_AUTH_CMPL_EVT.<S2SV_blank>"" ) ; btif_dm_ble_auth_cmpl_evt ( & p_data -> auth_cmpl ) ; break ; case BTA_DM_LE_FEATURES_READ : { tBTM_BLE_VSC_CB cmn_vsc_cb ; bt_local_le_features_t local_le_features ; char buf [ 512 ] ; bt_property_t prop ; prop . type = BT_PROPERTY_LOCAL_LE_FEATURES ; prop . val = ( void * ) buf ; prop . len = sizeof ( buf ) ; BTM_BleGetVendorCapabilities ( & cmn_vsc_cb ) ; local_le_features . local_privacy_enabled = BTM_BleLocalPrivacyEnabled ( ) ; prop . len = sizeof ( bt_local_le_features_t ) ; if ( cmn_vsc_cb . filter_support == 1 ) local_le_features . max_adv_filter_supported = cmn_vsc_cb . max_filter ; else local_le_features . max_adv_filter_supported = 0 ; local_le_features . max_adv_instance = cmn_vsc_cb . adv_inst_max ; local_le_features . max_irk_list_size = cmn_vsc_cb . max_irk_list_sz ; local_le_features . rpa_offload_supported = cmn_vsc_cb . rpa_offloading ; local_le_features . activity_energy_info_supported = cmn_vsc_cb . energy_support ; local_le_features . scan_result_storage_size = cmn_vsc_cb . tot_scan_results_strg ; local_le_features . version_supported = cmn_vsc_cb . version_supported ; local_le_features . total_trackable_advertisers = cmn_vsc_cb . total_trackable_advertisers ; local_le_features . extended_scan_support = cmn_vsc_cb . extended_scan_support > 0 ; local_le_features . debug_logging_supported = cmn_vsc_cb . debug_logging_supported > 0 ; memcpy ( prop . val , & local_le_features , prop . len ) ; HAL_CBACK ( bt_hal_cbacks , adapter_properties_cb , BT_STATUS_SUCCESS , 1 , & prop ) ; break ; } case BTA_DM_ENER_INFO_READ : { btif_activity_energy_info_cb_t * p_ener_data = ( btif_activity_energy_info_cb_t * ) p_param ; bt_activity_energy_info energy_info ; energy_info . status = p_ener_data -> status ; energy_info . ctrl_state = p_ener_data -> ctrl_state ; energy_info . rx_time = p_ener_data -> rx_time ; energy_info . tx_time = p_ener_data -> tx_time ; energy_info . idle_time = p_ener_data -> idle_time ; energy_info . energy_used = p_ener_data -> energy_used ; HAL_CBACK ( bt_hal_cbacks , energy_info_cb , & energy_info ) ; break ; } # endif case BTA_DM_AUTHORIZE_EVT : case BTA_DM_SIG_STRENGTH_EVT : case BTA_DM_SP_RMT_OOB_EVT : case BTA_DM_SP_KEYPRESS_EVT : case BTA_DM_ROLE_CHG_EVT : default : BTIF_TRACE_WARNING ( ""btif_dm_cback<S2SV_blank>:<S2SV_blank>unhandled<S2SV_blank>event<S2SV_blank>(%d)"" , event ) ; break ; } btif_dm_data_free ( event , p_data ) ; }
","<S2SV_ModStart> ( ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> usleep ( 100000 )
"
474,"CWE-772 static Image * ReadYCBCRImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { const unsigned char * pixels ; Image * canvas_image , * image ; MagickBooleanType status ; MagickOffsetType scene ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register const Quantum * p ; register ssize_t i , x ; register Quantum * q ; size_t length ; ssize_t count , y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , ""MustSpecifyImageSize"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; SetImageColorspace ( image , YCbCrColorspace , exception ) ; if ( image_info -> interlace != PartitionInterlace ) { status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } canvas_image = CloneImage ( image , image -> extract_info . width , 1 , MagickFalse , exception ) ; ( void ) SetImageVirtualPixelMethod ( canvas_image , BlackVirtualPixelMethod , exception ) ; quantum_info = AcquireQuantumInfo ( image_info , canvas_image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; quantum_type = RGBQuantum ; if ( LocaleCompare ( image_info -> magick , ""YCbCrA"" ) == 0 ) { quantum_type = RGBAQuantum ; image -> alpha_trait = BlendPixelTrait ; } pixels = ( const unsigned char * ) NULL ; if ( image_info -> number_scenes != 0 ) while ( image -> scene < image_info -> scene ) { image -> scene ++ ; length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) break ; } } count = 0 ; length = 0 ; scene = 0 ; do { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { <S2SV_StartBug> quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_EndBug> return ( DestroyImageList ( image ) ) ; } SetImageColorspace ( image , YCbCrColorspace , exception ) ; switch ( image_info -> interlace ) { case NoInterlace : default : { if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = QueueAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , GetPixelRed ( canvas_image , p ) , q ) ; SetPixelGreen ( image , GetPixelGreen ( canvas_image , p ) , q ) ; SetPixelBlue ( image , GetPixelBlue ( canvas_image , p ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , GetPixelAlpha ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } break ; } case LineInterlace : { static QuantumType quantum_types [ 4 ] = { RedQuantum , GreenQuantum , BlueQuantum , OpacityQuantum } ; if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , RedQuantum ) ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { for ( i = 0 ; i < ( image -> alpha_trait != UndefinedPixelTrait ? 4 : 3 ) ; i ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } quantum_type = quantum_types [ i ] ; q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( quantum_type ) { case RedQuantum : { SetPixelRed ( image , GetPixelRed ( canvas_image , p ) , q ) ; break ; } case GreenQuantum : { SetPixelGreen ( image , GetPixelGreen ( canvas_image , p ) , q ) ; break ; } case BlueQuantum : { SetPixelBlue ( image , GetPixelBlue ( canvas_image , p ) , q ) ; break ; } case OpacityQuantum : { SetPixelAlpha ( image , GetPixelAlpha ( canvas_image , p ) , q ) ; break ; } default : break ; } p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case PlaneInterlace : { if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , RedQuantum ) ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , RedQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , GetPixelRed ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 1 , 5 ) ; if ( status == MagickFalse ) break ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , GreenQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelGreen ( image , GetPixelGreen ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 2 , 5 ) ; if ( status == MagickFalse ) break ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , BlueQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , GetPixelBlue ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 3 , 5 ) ; if ( status == MagickFalse ) break ; } if ( image -> alpha_trait != UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , AlphaQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelAlpha ( image , GetPixelAlpha ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 4 , 5 ) ; if ( status == MagickFalse ) break ; } } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 5 , 5 ) ; if ( status == MagickFalse ) break ; } break ; } case PartitionInterlace : { AppendImageFormat ( ""Y"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; length = GetQuantumExtent ( canvas_image , quantum_info , RedQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , RedQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , GetPixelRed ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 1 , 5 ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""Cb"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , GreenQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , GreenQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelGreen ( image , GetPixelGreen ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 2 , 5 ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""Cr"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , BlueQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , BlueQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , GetPixelBlue ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 3 , 5 ) ; if ( status == MagickFalse ) break ; } if ( image -> alpha_trait != UndefinedPixelTrait ) { ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""A"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , AlphaQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , BlueQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelAlpha ( image , GetPixelAlpha ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 4 , 5 ) ; if ( status == MagickFalse ) break ; } } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 5 , 5 ) ; if ( status == MagickFalse ) break ; } break ; } } SetQuantumImageType ( image , quantum_type ) ; if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( count == ( ssize_t ) length ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } scene ++ ; } while ( count == ( ssize_t ) length ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; canvas_image = DestroyImage ( canvas_image ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> DestroyQuantumInfo ( quantum_info ) ; canvas_image = DestroyImage ( canvas_image
"
475,"CWE-190 static void controloptions ( lua_State * L , int opt , const char * * fmt , Header * h ) { switch ( opt ) { case '<S2SV_blank>' : return ; case '>' : h -> endian = BIG ; return ; case '<' : h -> endian = LITTLE ; return ; case '!' : { <S2SV_StartBug> int a = getnum ( fmt , MAXALIGN ) ; <S2SV_EndBug> if ( ! isp2 ( a ) ) luaL_error ( L , ""alignment<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>2"" , a ) ; h -> align = a ; return ; } default : { const char * msg = lua_pushfstring ( L , ""invalid<S2SV_blank>format<S2SV_blank>option<S2SV_blank>\'%c\'"" , opt ) ; luaL_argerror ( L , 1 , msg ) ; } } }
","<S2SV_ModStart> = getnum ( L ,
"
476,"CWE-119 <S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><codec><S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile>\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; }
","<S2SV_ModStart> void usage_exit ( void
"
477,"CWE-119 void edge_sparse_csr_reader_double ( const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , double * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , ""r"" ) ; if ( l_csr_file_handle == NULL ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>CSR<S2SV_blank>file!\\n"" ) ; return ; } while ( fgets ( l_line , l_line_length , l_csr_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>file<S2SV_blank>length!\\n"" ) ; return ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { <S2SV_StartBug> if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; * o_values = ( double * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_row_idx_id = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count ) ) ; if ( ( * o_row_idx == NULL ) || ( * o_column_idx == NULL ) || ( * o_values == NULL ) || ( l_row_idx_id == NULL ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>sp<S2SV_blank>data!\\n"" ) ; return ; } memset ( * o_row_idx , 0 , sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; memset ( * o_column_idx , 0 , sizeof ( unsigned int ) * ( * o_element_count ) ) ; memset ( * o_values , 0 , sizeof ( double ) * ( * o_element_count ) ) ; memset ( l_row_idx_id , 0 , sizeof ( unsigned int ) * ( * o_row_count ) ) ; for ( l_i = 0 ; l_i < ( * o_row_count + 1 ) ; l_i ++ ) ( * o_row_idx ) [ l_i ] = ( * o_element_count ) ; ( * o_row_idx ) [ 0 ] = 0 ; l_i = 0 ; l_header_read = 1 ; } else { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>csr<S2SV_blank>description!\\n"" ) ; return ; } } else { unsigned int l_row , l_column ; double l_value ; if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%lf"" , & l_row , & l_column , & l_value ) != 3 ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>element!\\n"" ) ; return ; } l_row -- ; l_column -- ; ( * o_column_idx ) [ l_i ] = l_column ; ( * o_values ) [ l_i ] = l_value ; l_i ++ ; l_row_idx_id [ l_row ] = 1 ; ( * o_row_idx ) [ l_row + 1 ] = l_i ; } } } fclose ( l_csr_file_handle ) ; if ( l_i != ( * o_element_count ) ) { fprintf ( stderr , ""we<S2SV_blank>were<S2SV_blank>not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>read<S2SV_blank>all<S2SV_blank>elements!\\n"" ) ; return ; } for ( l_i = 0 ; l_i < ( * o_row_count ) ; l_i ++ ) { if ( l_row_idx_id [ l_i ] == 0 ) { ( * o_row_idx ) [ l_i + 1 ] = ( * o_row_idx ) [ l_i ] ; } } if ( l_row_idx_id != NULL ) { free ( l_row_idx_id ) ; } }
","<S2SV_ModStart> { if ( 3 == <S2SV_ModStart> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> { * o_column_idx
"
478,"CWE-119 static Image * ReadCMYKImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * canvas_image , * image ; MagickBooleanType status ; MagickOffsetType scene ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; size_t length ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , ""MustSpecifyImageSize"" ) ; SetImageColorspace ( image , CMYKColorspace ) ; if ( image_info -> interlace != PartitionInterlace ) { status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } canvas_image = CloneImage ( image , image -> extract_info . width , 1 , MagickFalse , exception ) ; ( void ) SetImageVirtualPixelMethod ( canvas_image , BlackVirtualPixelMethod ) ; quantum_info = AcquireQuantumInfo ( image_info , canvas_image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = GetQuantumPixels ( quantum_info ) ; quantum_type = CMYKQuantum ; if ( LocaleCompare ( image_info -> magick , ""CMYKA"" ) == 0 ) { quantum_type = CMYKAQuantum ; image -> matte = MagickTrue ; } if ( image_info -> number_scenes != 0 ) while ( image -> scene < image_info -> scene ) { image -> scene ++ ; length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) break ; } } count = 0 ; length = 0 ; scene = 0 ; do { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) <S2SV_StartBug> break ; <S2SV_EndBug> SetImageColorspace ( image , CMYKColorspace ) ; switch ( image_info -> interlace ) { case NoInterlace : default : { if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; count = ReadBlob ( image , length , pixels ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const IndexPacket * restrict canvas_indexes ; register const PixelPacket * restrict p ; register IndexPacket * restrict indexes ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = QueueAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; canvas_indexes = GetVirtualIndexQueue ( canvas_image ) ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , GetPixelRed ( p ) ) ; SetPixelGreen ( q , GetPixelGreen ( p ) ) ; SetPixelBlue ( q , GetPixelBlue ( p ) ) ; SetPixelBlack ( indexes + x , GetPixelBlack ( canvas_indexes + image -> extract_info . x + x ) ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; if ( image -> matte != MagickFalse ) SetPixelOpacity ( q , GetPixelOpacity ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } break ; } case LineInterlace : { static QuantumType quantum_types [ 5 ] = { CyanQuantum , MagentaQuantum , YellowQuantum , BlackQuantum , OpacityQuantum } ; if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , CyanQuantum ) ; count = ReadBlob ( image , length , pixels ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const IndexPacket * restrict canvas_indexes ; register const PixelPacket * restrict p ; register IndexPacket * restrict indexes ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } for ( i = 0 ; i < ( image -> matte != MagickFalse ? 5 : 4 ) ; i ++ ) { quantum_type = quantum_types [ i ] ; q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; canvas_indexes = GetVirtualIndexQueue ( canvas_image ) ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( quantum_type ) { case CyanQuantum : { SetPixelCyan ( q , GetPixelCyan ( p ) ) ; break ; } case MagentaQuantum : { SetPixelMagenta ( q , GetPixelMagenta ( p ) ) ; break ; } case YellowQuantum : { SetPixelYellow ( q , GetPixelYellow ( p ) ) ; break ; } case BlackQuantum : { SetPixelIndex ( indexes + x , GetPixelIndex ( canvas_indexes + image -> extract_info . x + x ) ) ; break ; } case OpacityQuantum : { SetPixelOpacity ( q , GetPixelOpacity ( p ) ) ; break ; } default : break ; } p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case PlaneInterlace : { if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , CyanQuantum ) ; count = ReadBlob ( image , length , pixels ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , CyanQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , GetPixelRed ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 1 , 6 ) ; if ( status == MagickFalse ) break ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , MagentaQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelGreen ( q , GetPixelGreen ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 2 , 6 ) ; if ( status == MagickFalse ) break ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , YellowQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( q , GetPixelBlue ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 3 , 6 ) ; if ( status == MagickFalse ) break ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const IndexPacket * restrict canvas_indexes ; register const PixelPacket * restrict p ; register IndexPacket * restrict indexes ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , BlackQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; canvas_indexes = GetVirtualIndexQueue ( canvas_image ) ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( indexes + x , GetPixelIndex ( canvas_indexes + image -> extract_info . x + x ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 4 , 6 ) ; if ( status == MagickFalse ) break ; } if ( image -> matte != MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , AlphaQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelOpacity ( q , GetPixelOpacity ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 5 , 6 ) ; if ( status == MagickFalse ) break ; } } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 6 , 6 ) ; if ( status == MagickFalse ) break ; } break ; } case PartitionInterlace : { AppendImageFormat ( ""C"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; length = GetQuantumExtent ( canvas_image , quantum_info , CyanQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) if ( ReadBlob ( image , length , pixels ) != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } count = ReadBlob ( image , length , pixels ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , CyanQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , GetPixelRed ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 1 , 5 ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""M"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , MagentaQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) if ( ReadBlob ( image , length , pixels ) != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } count = ReadBlob ( image , length , pixels ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , MagentaQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelGreen ( q , GetPixelGreen ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 2 , 5 ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""Y"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , YellowQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) if ( ReadBlob ( image , length , pixels ) != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } count = ReadBlob ( image , length , pixels ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , YellowQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( q , GetPixelBlue ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 3 , 5 ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""K"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , BlackQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) if ( ReadBlob ( image , length , pixels ) != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } count = ReadBlob ( image , length , pixels ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const IndexPacket * restrict canvas_indexes ; register const PixelPacket * restrict p ; register IndexPacket * restrict indexes ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , BlackQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; canvas_indexes = GetVirtualIndexQueue ( canvas_image ) ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( indexes + x , GetPixelIndex ( canvas_indexes + image -> extract_info . x + x ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 3 , 5 ) ; if ( status == MagickFalse ) break ; } if ( image -> matte != MagickFalse ) { ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""A"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , AlphaQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) if ( ReadBlob ( image , length , pixels ) != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } count = ReadBlob ( image , length , pixels ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register PixelPacket * restrict q ; register ssize_t x ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , YellowQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelOpacity ( q , GetPixelOpacity ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 4 , 5 ) ; if ( status == MagickFalse ) break ; } } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 5 , 5 ) ; if ( status == MagickFalse ) break ; } break ; } } SetQuantumImageType ( image , quantum_type ) ; if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( count == ( ssize_t ) length ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } scene ++ ; } while ( count == ( ssize_t ) length ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; InheritException ( & image -> exception , & canvas_image -> exception ) ; canvas_image = DestroyImage ( canvas_image ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
"
479,"CWE-189 static inline void jiffies_to_compat_timeval ( unsigned long jiffies , struct compat_timeval * value ) { u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_StartBug> long rem ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> value -> tv_usec = rem / NSEC_PER_USEC ; }
","<S2SV_ModStart> * TICK_NSEC ; u32 <S2SV_ModEnd> rem ; value <S2SV_ModStart> -> tv_sec = div_u64_rem <S2SV_ModEnd> ( nsec ,
"
480,"CWE-119 vpx_codec_err_t vpx_codec_decode ( vpx_codec_ctx_t * ctx , const uint8_t * data , unsigned int data_sz , void * user_priv , long deadline ) { vpx_codec_err_t res ; <S2SV_StartBug> if ( ! ctx || ( ! data && data_sz ) ) <S2SV_EndBug> res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) res = VPX_CODEC_ERROR ; else { <S2SV_StartBug> res = ctx -> iface -> dec . decode ( ctx -> priv -> alg_priv , data , data_sz , <S2SV_EndBug> user_priv , deadline ) ; } return SAVE_STATUS ( ctx , res ) ; }
","<S2SV_ModStart> && data_sz ) || ( data && ! data_sz ) <S2SV_ModStart> . decode ( get_alg_priv ( ctx ) <S2SV_ModEnd> , data ,
"
481,"CWE-119 static int sdp_parse_fmtp_config_h264 ( AVFormatContext * s , AVStream * stream , PayloadContext * h264_data , const char * attr , const char * value ) { AVCodecParameters * par = stream -> codecpar ; if ( ! strcmp ( attr , ""packetization-mode"" ) ) { av_log ( s , AV_LOG_DEBUG , ""RTP<S2SV_blank>Packetization<S2SV_blank>Mode:<S2SV_blank>%d\\n"" , atoi ( value ) ) ; h264_data -> packetization_mode = atoi ( value ) ; if ( h264_data -> packetization_mode > 1 ) av_log ( s , AV_LOG_ERROR , ""Interleaved<S2SV_blank>RTP<S2SV_blank>mode<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>yet.\\n"" ) ; } else if ( ! strcmp ( attr , ""profile-level-id"" ) ) { if ( strlen ( value ) == 6 ) parse_profile_level_id ( s , h264_data , value ) ; } else if ( ! strcmp ( attr , ""sprop-parameter-sets"" ) ) { int ret ; <S2SV_StartBug> if ( value [ strlen ( value ) - 1 ] == ',' ) { <S2SV_EndBug> av_log ( s , AV_LOG_WARNING , ""Missing<S2SV_blank>PPS<S2SV_blank>in<S2SV_blank>sprop-parameter-sets,<S2SV_blank>ignoring\\n"" ) ; return 0 ; } par -> extradata_size = 0 ; av_freep ( & par -> extradata ) ; ret = ff_h264_parse_sprop_parameter_sets ( s , & par -> extradata , & par -> extradata_size , value ) ; av_log ( s , AV_LOG_DEBUG , ""Extradata<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%p<S2SV_blank>(size:<S2SV_blank>%d)\\n"" , par -> extradata , par -> extradata_size ) ; return ret ; } return 0 ; }
","<S2SV_ModStart> ; if ( * value == 0 ||
"
482,"CWE-20 <S2SV_StartBug> static int isofs_read_inode ( struct inode * inode ) <S2SV_EndBug> { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; unsigned long block ; int high_sierra = sbi -> s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ; unsigned long offset ; struct iso_inode_info * ei = ISOFS_I ( inode ) ; int ret = - EIO ; block = ei -> i_iget5_block ; bh = sb_bread ( inode -> i_sb , block ) ; if ( ! bh ) goto out_badread ; offset = ei -> i_iget5_offset ; de = ( struct iso_directory_record * ) ( bh -> b_data + offset ) ; de_len = * ( unsigned char * ) de ; if ( offset + de_len > bufsize ) { int frag1 = bufsize - offset ; tmpde = kmalloc ( de_len , GFP_KERNEL ) ; if ( tmpde == NULL ) { printk ( KERN_INFO ""%s:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" , __func__ ) ; ret = - ENOMEM ; goto fail ; } memcpy ( tmpde , bh -> b_data + offset , frag1 ) ; brelse ( bh ) ; bh = sb_bread ( inode -> i_sb , ++ block ) ; if ( ! bh ) goto out_badread ; memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ) ; de = tmpde ; } inode -> i_ino = isofs_get_ino ( ei -> i_iget5_block , ei -> i_iget5_offset , ISOFS_BUFFER_BITS ( inode ) ) ; ei -> i_file_format = isofs_file_normal ; if ( de -> flags [ - high_sierra ] & 2 ) { if ( sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; else inode -> i_mode = S_IFDIR | S_IRUGO | S_IXUGO ; set_nlink ( inode , 1 ) ; } else { if ( sbi -> s_fmode != ISOFS_INVALID_MODE ) { inode -> i_mode = S_IFREG | sbi -> s_fmode ; } else { inode -> i_mode = S_IFREG | S_IRUGO | S_IXUGO ; } set_nlink ( inode , 1 ) ; } inode -> i_uid = sbi -> s_uid ; inode -> i_gid = sbi -> s_gid ; inode -> i_blocks = 0 ; ei -> i_format_parm [ 0 ] = 0 ; ei -> i_format_parm [ 1 ] = 0 ; ei -> i_format_parm [ 2 ] = 0 ; ei -> i_section_size = isonum_733 ( de -> size ) ; if ( de -> flags [ - high_sierra ] & 0x80 ) { ret = isofs_read_level3_size ( inode ) ; if ( ret < 0 ) goto fail ; ret = - EIO ; } else { ei -> i_next_section_block = 0 ; ei -> i_next_section_offset = 0 ; inode -> i_size = isonum_733 ( de -> size ) ; } if ( sbi -> s_cruft ) inode -> i_size &= 0x00ffffff ; if ( de -> interleave [ 0 ] ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>Interleaved<S2SV_blank>files<S2SV_blank>not<S2SV_blank>(yet)<S2SV_blank>supported.\\n"" ) ; inode -> i_size = 0 ; } if ( de -> file_unit_size [ 0 ] != 0 ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>File<S2SV_blank>unit<S2SV_blank>size<S2SV_blank>!=<S2SV_blank>0<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>(%ld).\\n"" , inode -> i_ino ) ; } # ifdef DEBUG if ( ( de -> flags [ - high_sierra ] & ~ 2 ) != 0 ) { printk ( KERN_DEBUG ""ISOFS:<S2SV_blank>Unusual<S2SV_blank>flag<S2SV_blank>settings<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>"" ""(%ld<S2SV_blank>%x).\\n"" , inode -> i_ino , de -> flags [ - high_sierra ] ) ; } # endif inode -> i_mtime . tv_sec = inode -> i_atime . tv_sec = inode -> i_ctime . tv_sec = iso_date ( de -> date , high_sierra ) ; inode -> i_mtime . tv_nsec = inode -> i_atime . tv_nsec = inode -> i_ctime . tv_nsec = 0 ; ei -> i_first_extent = ( isonum_733 ( de -> extent ) + isonum_711 ( de -> ext_attr_length ) ) ; inode -> i_blocks = ( inode -> i_size + 511 ) >> 9 ; if ( ! high_sierra ) { <S2SV_StartBug> parse_rock_ridge_inode ( de , inode ) ; <S2SV_EndBug> if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ; if ( sbi -> s_gid_set ) inode -> i_gid = sbi -> s_gid ; } if ( S_ISDIR ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; if ( S_ISREG ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_fmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFREG | sbi -> s_fmode ; if ( S_ISREG ( inode -> i_mode ) ) { inode -> i_fop = & generic_ro_fops ; switch ( ei -> i_file_format ) { # ifdef CONFIG_ZISOFS case isofs_file_compressed : inode -> i_data . a_ops = & zisofs_aops ; break ; # endif default : inode -> i_data . a_ops = & isofs_aops ; break ; } } else if ( S_ISDIR ( inode -> i_mode ) ) { inode -> i_op = & isofs_dir_inode_operations ; inode -> i_fop = & isofs_dir_operations ; } else if ( S_ISLNK ( inode -> i_mode ) ) { inode -> i_op = & page_symlink_inode_operations ; inode -> i_data . a_ops = & isofs_symlink_aops ; } else init_special_inode ( inode , inode -> i_mode , inode -> i_rdev ) ; ret = 0 ; out : kfree ( tmpde ) ; if ( bh ) brelse ( bh ) ; return ret ; out_badread : printk ( KERN_WARNING ""ISOFS:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>i-node<S2SV_blank>block\\n"" ) ; fail : goto out ; }
","<S2SV_ModStart> inode * inode , int relocated <S2SV_ModStart> de , inode , relocated
"
483,"CWE-000 void Con_Dump_f ( void ) { int l , x , i ; short * line ; fileHandle_t f ; int bufferlen ; char * buffer ; char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { Com_Printf ( ""usage:<S2SV_blank>condump<S2SV_blank><filename>\\n"" ) ; return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; <S2SV_StartBug> COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ; <S2SV_EndBug> f = FS_FOpenFileWrite ( filename ) ; if ( ! f ) { Com_Printf ( ""ERROR:<S2SV_blank>couldn\'t<S2SV_blank>open<S2SV_blank>%s.\\n"" , filename ) ; return ; } Com_Printf ( ""Dumped<S2SV_blank>console<S2SV_blank>text<S2SV_blank>to<S2SV_blank>%s.\\n"" , filename ) ; for ( l = con . current - con . totallines + 1 ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( x = 0 ; x < con . linewidth ; x ++ ) if ( ( line [ x ] & 0xff ) != '<S2SV_blank>' ) { break ; } if ( x != con . linewidth ) { break ; } } # ifdef _WIN32 bufferlen = con . linewidth + 3 * sizeof ( char ) ; # else bufferlen = con . linewidth + 2 * sizeof ( char ) ; # endif buffer = Hunk_AllocateTempMemory ( bufferlen ) ; buffer [ bufferlen - 1 ] = 0 ; for ( ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( i = 0 ; i < con . linewidth ; i ++ ) buffer [ i ] = line [ i ] & 0xff ; for ( x = con . linewidth - 1 ; x >= 0 ; x -- ) { if ( buffer [ x ] == '<S2SV_blank>' ) { buffer [ x ] = 0 ; } else { break ; } } # ifdef _WIN32 Q_strcat ( buffer , bufferlen , ""\\r\\n"" ) ; # else Q_strcat ( buffer , bufferlen , ""\\n"" ) ; # endif FS_Write ( buffer , strlen ( buffer ) , f ) ; } Hunk_FreeTempMemory ( buffer ) ; FS_FCloseFile ( f ) ; }
","<S2SV_ModStart> "".txt"" ) ; if ( ! COM_CompareExtension ( filename , "".txt"" ) ) { Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".txt\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" ) ; return ; }
"
484,"CWE-125 static void esis_print ( netdissect_options * ndo , const uint8_t * pptr , u_int length ) { const uint8_t * optr ; u_int li , esis_pdu_type , source_address_length , source_address_number ; const struct esis_header_t * esis_header ; if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""ES-IS"" ) ) ; if ( length <= 2 ) { ND_PRINT ( ( ndo , ndo -> ndo_qflag ? ""bad<S2SV_blank>pkt!"" : ""no<S2SV_blank>header<S2SV_blank>at<S2SV_blank>all!"" ) ) ; return ; } esis_header = ( const struct esis_header_t * ) pptr ; ND_TCHECK ( * esis_header ) ; li = esis_header -> length_indicator ; optr = pptr ; if ( esis_header -> nlpid != NLPID_ESIS ) { ND_PRINT ( ( ndo , ""<S2SV_blank>nlpid<S2SV_blank>0x%02x<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> nlpid ) ) ; return ; } if ( esis_header -> version != ESIS_VERSION ) { ND_PRINT ( ( ndo , ""<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> version ) ) ; return ; } if ( li > length ) { ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator(%u)<S2SV_blank>><S2SV_blank>PDU<S2SV_blank>size<S2SV_blank>(%u)!"" , li , length ) ) ; return ; } if ( li < sizeof ( struct esis_header_t ) + 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator<S2SV_blank>%u<S2SV_blank><<S2SV_blank>min<S2SV_blank>PDU<S2SV_blank>size:"" , li ) ) ; while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo , ""%02X"" , * pptr ++ ) ) ; return ; } esis_pdu_type = esis_header -> type & ESIS_PDU_TYPE_MASK ; if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""%s%s,<S2SV_blank>length<S2SV_blank>%u"" , ndo -> ndo_eflag ? """" : "",<S2SV_blank>"" , tok2str ( esis_pdu_values , ""unknown<S2SV_blank>type<S2SV_blank>(%u)"" , esis_pdu_type ) , length ) ) ; return ; } else ND_PRINT ( ( ndo , ""%slength<S2SV_blank>%u\\n\\t%s<S2SV_blank>(%u)"" , ndo -> ndo_eflag ? """" : "",<S2SV_blank>"" , length , tok2str ( esis_pdu_values , ""unknown<S2SV_blank>type:<S2SV_blank>%u"" , esis_pdu_type ) , esis_pdu_type ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>v:<S2SV_blank>%u%s"" , esis_header -> version , esis_header -> version == ESIS_VERSION ? """" : ""unsupported"" ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>checksum:<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( esis_header -> cksum ) ) ) ; osi_print_cksum ( ndo , pptr , EXTRACT_16BITS ( esis_header -> cksum ) , 7 , li ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>holding<S2SV_blank>time:<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>indicator:<S2SV_blank>%u"" , EXTRACT_16BITS ( esis_header -> holdtime ) , li ) ) ; if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , optr , ""\\n\\t"" , sizeof ( struct esis_header_t ) ) ; pptr += sizeof ( struct esis_header_t ) ; li -= sizeof ( struct esis_header_t ) ; switch ( esis_pdu_type ) { case ESIS_PDU_REDIRECT : { const uint8_t * dst , * snpa , * neta ; u_int dstl , snpal , netal ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } dstl = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , dstl ) ; if ( li < dstl ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } dst = pptr ; pptr += dstl ; li -= dstl ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s"" , isonsap_string ( ndo , dst , dstl ) ) ) ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } snpal = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , snpal ) ; if ( li < snpal ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } snpa = pptr ; pptr += snpal ; li -= snpal ; ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } netal = * pptr ; pptr ++ ; ND_TCHECK2 ( * pptr , netal ) ; if ( li < netal ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ; return ; } neta = pptr ; pptr += netal ; li -= netal ; <S2SV_StartBug> if ( netal == 0 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s"" , etheraddr_string ( ndo , snpa ) ) ) ; <S2SV_EndBug> else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s"" , isonsap_string ( ndo , neta , netal ) ) ) ; break ; } case ESIS_PDU_ESH : ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>esh/li"" ) ) ; return ; } source_address_number = * pptr ; pptr ++ ; li -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>Source<S2SV_blank>Addresses:<S2SV_blank>%u"" , source_address_number ) ) ; while ( source_address_number > 0 ) { ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>esh/li"" ) ) ; return ; } source_address_length = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , source_address_length ) ; if ( li < source_address_length ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>esh/li"" ) ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , source_address_length , isonsap_string ( ndo , pptr , source_address_length ) ) ) ; pptr += source_address_length ; li -= source_address_length ; source_address_number -- ; } break ; case ESIS_PDU_ISH : { ND_TCHECK ( * pptr ) ; if ( li < 1 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>ish/li"" ) ) ; return ; } source_address_length = * pptr ; pptr ++ ; li -- ; ND_TCHECK2 ( * pptr , source_address_length ) ; if ( li < source_address_length ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>ish/li"" ) ) ; return ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , source_address_length , isonsap_string ( ndo , pptr , source_address_length ) ) ) ; pptr += source_address_length ; li -= source_address_length ; break ; } default : if ( ndo -> ndo_vflag <= 1 ) { if ( pptr < ndo -> ndo_snapend ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ndo -> ndo_snapend - pptr ) ; } return ; } while ( li != 0 ) { u_int op , opli ; const uint8_t * tptr ; if ( li < 2 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>opts/li"" ) ) ; return ; } ND_TCHECK2 ( * pptr , 2 ) ; op = * pptr ++ ; opli = * pptr ++ ; li -= 2 ; if ( opli > li ) { ND_PRINT ( ( ndo , "",<S2SV_blank>opt<S2SV_blank>(%d)<S2SV_blank>too<S2SV_blank>long"" , op ) ) ; return ; } li -= opli ; tptr = pptr ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>value:<S2SV_blank>"" , tok2str ( esis_option_values , ""Unknown"" , op ) , op , opli ) ) ; switch ( op ) { case ESIS_OPTION_ES_CONF_TIME : if ( opli == 2 ) { ND_TCHECK2 ( * pptr , 2 ) ; ND_PRINT ( ( ndo , ""%us"" , EXTRACT_16BITS ( tptr ) ) ) ; } else ND_PRINT ( ( ndo , ""(bad<S2SV_blank>length)"" ) ) ; break ; case ESIS_OPTION_PROTOCOLS : while ( opli > 0 ) { ND_TCHECK ( * pptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%02x)"" , tok2str ( nlpid_values , ""unknown"" , * tptr ) , * tptr ) ) ; if ( opli > 1 ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; tptr ++ ; opli -- ; } break ; case ESIS_OPTION_QOS_MAINTENANCE : case ESIS_OPTION_SECURITY : case ESIS_OPTION_PRIORITY : case ESIS_OPTION_ADDRESS_MASK : case ESIS_OPTION_SNPA_MASK : default : print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , opli ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , opli ) ; pptr += opli ; } trunc : return ; }
","<S2SV_ModStart> ; if ( snpal == 6 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , snpal , etheraddr_string ( ndo , snpa ) ) ) ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , snpal , linkaddr_string ( ndo , snpa , LINKADDR_OTHER , snpal ) ) ) ; if ( netal != <S2SV_ModEnd> 0 ) ND_PRINT <S2SV_ModStart> ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u)<S2SV_blank>%s"" , netal , <S2SV_ModEnd> isonsap_string ( ndo
"
485,"CWE-20 void SetColor ( double c , double m , double y , double k , int par ) { if ( par == STROKING ) { <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>K"" , c , m , y , k ) ; <S2SV_EndBug> } else { <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>k"" , c , m , y , k ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> STROKING ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>K"" , <S2SV_ModStart> } else { sprintf ( outputbuffer <S2SV_ModEnd> , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>k"" , <S2SV_ModStart> ) ; } sendClean ( outputbuffer ) ;
"
486,"CWE-617 static bool access_pmu_evcntr ( struct kvm_vcpu * vcpu , struct sys_reg_params * p , const struct sys_reg_desc * r ) { u64 idx ; if ( ! kvm_arm_pmu_v3_ready ( vcpu ) ) return trap_raz_wi ( vcpu , p , r ) ; if ( r -> CRn == 9 && r -> CRm == 13 ) { if ( r -> Op2 == 2 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = vcpu_sys_reg ( vcpu , PMSELR_EL0 ) & ARMV8_PMU_COUNTER_MASK ; } else if ( r -> Op2 == 0 ) { if ( pmu_access_cycle_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; } else { <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> } } else if ( r -> CRn == 14 && ( r -> CRm & 12 ) == 8 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ( ( r -> CRm & 3 ) << 3 ) | ( r -> Op2 & 7 ) ; } else { <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> } if ( ! pmu_counter_idx_valid ( vcpu , idx ) ) return false ; if ( p -> is_write ) { if ( pmu_access_el0_disabled ( vcpu ) ) return false ; kvm_pmu_set_counter_value ( vcpu , idx , p -> regval ) ; } else { p -> regval = kvm_pmu_get_counter_value ( vcpu , idx ) ; } return true ; }
","<S2SV_ModStart> } else { return false ; } } else if ( r -> CRn == 0 && r -> CRm == 9 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; <S2SV_ModEnd> } else if <S2SV_ModStart> } else { return false <S2SV_ModEnd> ; } if
"
487,"CWE-189 PHP_FUNCTION ( imageaffine ) { zval * IM ; gdImagePtr src ; gdImagePtr dst ; gdRect rect ; gdRectPtr pRect = NULL ; zval * z_rect = NULL ; zval * z_affine ; zval * * tmp ; double affine [ 6 ] ; int i , nelems ; zval * * zval_affine_elem = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""ra|a"" , & IM , & z_affine , & z_rect ) == FAILURE ) { return ; } ZEND_FETCH_RESOURCE ( src , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ; if ( ( nelems = zend_hash_num_elements ( Z_ARRVAL_P ( z_affine ) ) ) != 6 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Affine<S2SV_blank>array<S2SV_blank>must<S2SV_blank>have<S2SV_blank>six<S2SV_blank>elements"" ) ; RETURN_FALSE ; } for ( i = 0 ; i < nelems ; i ++ ) { if ( zend_hash_index_find ( Z_ARRVAL_P ( z_affine ) , i , ( void * * ) & zval_affine_elem ) == SUCCESS ) { switch ( Z_TYPE_PP ( zval_affine_elem ) ) { case IS_LONG : affine [ i ] = Z_LVAL_PP ( zval_affine_elem ) ; break ; case IS_DOUBLE : affine [ i ] = Z_DVAL_PP ( zval_affine_elem ) ; break ; case IS_STRING : <S2SV_StartBug> convert_to_double_ex ( zval_affine_elem ) ; <S2SV_EndBug> <S2SV_StartBug> affine [ i ] = Z_DVAL_PP ( zval_affine_elem ) ; <S2SV_EndBug> break ; default : php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Invalid<S2SV_blank>type<S2SV_blank>for<S2SV_blank>element<S2SV_blank>%i"" , i ) ; RETURN_FALSE ; } } } if ( z_rect != NULL ) { if ( zend_hash_find ( HASH_OF ( z_rect ) , ""x"" , sizeof ( ""x"" ) , ( void * * ) & tmp ) != FAILURE ) { <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . x = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>x<S2SV_blank>position"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""y"" , sizeof ( ""x"" ) , ( void * * ) & tmp ) != FAILURE ) { <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . y = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>y<S2SV_blank>position"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""width"" , sizeof ( ""width"" ) , ( void * * ) & tmp ) != FAILURE ) { <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . width = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>width"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""height"" , sizeof ( ""height"" ) , ( void * * ) & tmp ) != FAILURE ) { <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . height = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>height"" ) ; RETURN_FALSE ; } pRect = & rect ; } else { rect . x = - 1 ; rect . y = - 1 ; rect . width = gdImageSX ( src ) ; rect . height = gdImageSY ( src ) ; pRect = NULL ; } if ( gdTransformAffineGetImage ( & dst , src , pRect , affine ) != GD_TRUE ) { RETURN_FALSE ; } if ( dst == NULL ) { RETURN_FALSE ; } else { ZEND_REGISTER_RESOURCE ( return_value , dst , le_gd ) ; } }
","<S2SV_ModStart> case IS_STRING : { zval dval ; dval = * * zval_affine_elem ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> ) ; affine <S2SV_ModStart> i ] = Z_DVAL ( dval ) ; } <S2SV_ModEnd> break ; default <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> ) ; rect <S2SV_ModStart> . x = Z_LVAL ( lval ) ; } else { rect . x = <S2SV_ModStart> ) ; } } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> ) ; rect <S2SV_ModStart> . y = Z_LVAL ( lval ) ; } else { rect . y = <S2SV_ModStart> ) ; } } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> ) ; rect <S2SV_ModStart> . width = Z_LVAL ( lval ) ; } else { rect . width = <S2SV_ModStart> ) ; } } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> ) ; rect <S2SV_ModStart> . height = Z_LVAL ( lval ) ; } else { rect . height = <S2SV_ModStart> tmp ) ; }
"
488,"CWE-125 static void ast_dealloc ( AST_object * self ) <S2SV_StartBug> { <S2SV_EndBug> Py_CLEAR ( self -> dict ) ; Py_TYPE ( self ) -> tp_free ( self ) ; }
","<S2SV_ModStart> self ) { PyObject_GC_UnTrack ( self ) ;
"
489,"CWE-119 static int ExecuteSQL ( SQLHDBC hDbc , char * szSQL , char cDelimiter , int bColumnNames , int bHTMLTable ) { SQLHSTMT hStmt ; SQLTCHAR szSepLine [ 32001 ] ; SQLTCHAR szUcSQL [ 32001 ] ; SQLSMALLINT cols ; SQLINTEGER ret ; SQLLEN nRows = 0 ; szSepLine [ 0 ] = 0 ; ansi_to_unicode ( szSQL , szUcSQL ) ; if ( SQLAllocStmt ( hDbc , & hStmt ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , 0 ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLAllocStmt\\n"" ) ; return 0 ; } if ( buseED ) { ret = SQLExecDirect ( hStmt , szUcSQL , SQL_NTS ) ; if ( ret == SQL_NO_DATA ) { fprintf ( stderr , ""[ISQL]INFO:<S2SV_blank>SQLExecDirect<S2SV_blank>returned<S2SV_blank>SQL_NO_DATA\\n"" ) ; } else if ( ret == SQL_SUCCESS_WITH_INFO ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]INFO:<S2SV_blank>SQLExecDirect<S2SV_blank>returned<S2SV_blank>SQL_SUCCESS_WITH_INFO\\n"" ) ; } else if ( ret != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLExecDirect\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; <S2SV_StartBug> free ( szSepLine ) ; <S2SV_EndBug> return 0 ; } } else { if ( SQLPrepare ( hStmt , szUcSQL , SQL_NTS ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLPrepare\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } ret = SQLExecute ( hStmt ) ; if ( ret == SQL_NO_DATA ) { fprintf ( stderr , ""[ISQL]INFO:<S2SV_blank>SQLExecute<S2SV_blank>returned<S2SV_blank>SQL_NO_DATA\\n"" ) ; } else if ( ret == SQL_SUCCESS_WITH_INFO ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]INFO:<S2SV_blank>SQLExecute<S2SV_blank>returned<S2SV_blank>SQL_SUCCESS_WITH_INFO\\n"" ) ; } else if ( ret != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLExecute\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } } do { if ( SQLNumResultCols ( hStmt , & cols ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLNumResultCols\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } if ( cols > 0 ) { if ( bHTMLTable ) WriteHeaderHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) UWriteHeaderNormal ( hStmt , szSepLine ) ; else if ( cDelimiter && bColumnNames ) WriteHeaderDelimited ( hStmt , cDelimiter ) ; if ( bHTMLTable ) WriteBodyHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) nRows = WriteBodyNormal ( hStmt ) ; else WriteBodyDelimited ( hStmt , cDelimiter ) ; } if ( bHTMLTable ) WriteFooterHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) UWriteFooterNormal ( hStmt , szSepLine , nRows ) ; } while ( SQL_SUCCEEDED ( SQLMoreResults ( hStmt ) ) ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 1 ; }
","<S2SV_ModStart> SQL_DROP ) ; <S2SV_ModEnd> return 0 ;
"
490,"CWE-20 int kvm_read_guest_page ( struct kvm * kvm , gfn_t gfn , void * data , int offset , int len ) { int r ; unsigned long addr ; addr = gfn_to_hva ( kvm , gfn ) ; if ( kvm_is_error_hva ( addr ) ) return - EFAULT ; <S2SV_StartBug> r = copy_from_user ( data , ( void __user * ) addr + offset , len ) ; <S2SV_EndBug> if ( r ) return - EFAULT ; return 0 ; }
","<S2SV_ModStart> ; r = __copy_from_user <S2SV_ModEnd> ( data ,
"
491,"CWE-119 int main ( int argc , char * argv [ ] ) { <S2SV_StartBug> char * p , * q , * r ; <S2SV_EndBug> Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ; program_name = Clp_ProgramName ( clp ) ; while ( 1 ) { int opt = Clp_Next ( clp ) ; switch ( opt ) { case BLOCK_LEN_OPT : blocklen = clp -> val . i ; break ; output_file : case OUTPUT_OPT : if ( ofp ) fatal_error ( ""output<S2SV_blank>file<S2SV_blank>already<S2SV_blank>specified"" ) ; if ( strcmp ( clp -> vstr , ""-"" ) == 0 ) ofp = stdout ; else if ( ! ( ofp = fopen ( clp -> vstr , ""w"" ) ) ) fatal_error ( ""%s:<S2SV_blank>%s"" , clp -> vstr , strerror ( errno ) ) ; break ; case PFB_OPT : pfb = 1 ; break ; case PFA_OPT : pfb = 0 ; break ; case HELP_OPT : usage ( ) ; exit ( 0 ) ; break ; case VERSION_OPT : printf ( ""t1asm<S2SV_blank>(LCDF<S2SV_blank>t1utils)<S2SV_blank>%s\\n"" , VERSION ) ; <S2SV_StartBug> printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\n<S2SV_blank>This<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\n<S2SV_blank>There<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\n<S2SV_blank>particular<S2SV_blank>purpose.\\n"" ) ; <S2SV_EndBug> exit ( 0 ) ; break ; case Clp_NotOption : if ( ifp && ofp ) fatal_error ( ""too<S2SV_blank>many<S2SV_blank>arguments"" ) ; else if ( ifp ) goto output_file ; if ( strcmp ( clp -> vstr , ""-"" ) == 0 ) ifp = stdin ; else if ( ! ( ifp = fopen ( clp -> vstr , ""r"" ) ) ) fatal_error ( ""%s:<S2SV_blank>%s"" , clp -> vstr , strerror ( errno ) ) ; break ; case Clp_Done : goto done ; case Clp_BadOption : short_usage ( ) ; exit ( 1 ) ; break ; } } done : if ( ! pfb ) { if ( blocklen == - 1 ) blocklen = 64 ; else if ( blocklen < 8 ) { blocklen = 8 ; error ( ""warning:<S2SV_blank>line<S2SV_blank>length<S2SV_blank>raised<S2SV_blank>to<S2SV_blank>%d"" , blocklen ) ; } else if ( blocklen > 1024 ) { blocklen = 1024 ; error ( ""warning:<S2SV_blank>line<S2SV_blank>length<S2SV_blank>lowered<S2SV_blank>to<S2SV_blank>%d"" , blocklen ) ; } } if ( ! ifp ) ifp = stdin ; if ( ! ofp ) ofp = stdout ; if ( pfb ) init_pfb_writer ( & w , blocklen , ofp ) ; # if defined ( _MSDOS ) || defined ( _WIN32 ) if ( pfb ) _setmode ( _fileno ( ofp ) , _O_BINARY ) ; # endif while ( ! feof ( ifp ) && ! ferror ( ifp ) ) { t1utils_getline ( ) ; if ( ! ever_active ) { <S2SV_StartBug> if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( p = line + 18 ; isspace ( * p ) ; p ++ ) <S2SV_EndBug> ; eexec_start ( p ) ; continue ; } else if ( strncmp ( line , ""/lenIV"" , 6 ) == 0 ) { <S2SV_StartBug> lenIV = atoi ( line + 6 ) ; <S2SV_EndBug> } else if ( ( p = strstr ( line , ""string<S2SV_blank>currentfile"" ) ) <S2SV_StartBug> && strstr ( line , ""readstring"" ) ) { <S2SV_EndBug> * p = '\\0' ; q = strrchr ( line , '/' ) ; if ( q ) { r = cs_start ; ++ q ; while ( ! isspace ( * q ) && * q != '{' ) * r ++ = * q ++ ; * r = '\\0' ; } * p = 's' ; } } if ( ! active ) { <S2SV_StartBug> if ( ( p = strstr ( line , ""/Subrs"" ) ) && isdigit ( p [ 7 ] ) ) <S2SV_EndBug> ever_active = active = 1 ; <S2SV_StartBug> else if ( ( p = strstr ( line , ""/CharStrings"" ) ) && isdigit ( p [ 13 ] ) ) <S2SV_EndBug> ever_active = active = 1 ; } if ( ( p = strstr ( line , ""currentfile<S2SV_blank>closefile"" ) ) ) { p += sizeof ( ""currentfile<S2SV_blank>closefile"" ) - 1 ; <S2SV_StartBug> for ( q = p ; isspace ( * q ) && * q != '\\n' ; q ++ ) <S2SV_EndBug> ; if ( q == p && ! * q ) error ( ""warning:<S2SV_blank>`currentfile<S2SV_blank>closefile\'<S2SV_blank>line<S2SV_blank>too<S2SV_blank>long"" ) ; else if ( q != p ) { if ( * q != '\\n' ) error ( ""text<S2SV_blank>after<S2SV_blank>`currentfile<S2SV_blank>closefile\'<S2SV_blank>ignored"" ) ; * p ++ = '\\n' ; * p ++ = '\\0' ; } eexec_string ( line ) ; break ; } eexec_string ( line ) ; if ( start_charstring ) { if ( ! cs_start [ 0 ] ) fatal_error ( ""couldn\'t<S2SV_blank>find<S2SV_blank>charstring<S2SV_blank>start<S2SV_blank>command"" ) ; parse_charstring ( ) ; } } if ( in_eexec ) eexec_end ( ) ; while ( ! feof ( ifp ) && ! ferror ( ifp ) ) { t1utils_getline ( ) ; eexec_string ( line ) ; } if ( pfb ) pfb_writer_end ( & w ) ; if ( ! ever_active ) error ( ""warning:<S2SV_blank>no<S2SV_blank>charstrings<S2SV_blank>found<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file"" ) ; fclose ( ifp ) ; fclose ( ofp ) ; return 0 ; }
","<S2SV_ModStart> , * q <S2SV_ModEnd> ; Clp_Parser * <S2SV_ModStart> ; printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\nThis<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\nThere<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\nparticular<S2SV_blank>purpose.\\n"" <S2SV_ModEnd> ) ; exit <S2SV_ModStart> && isspace ( ( unsigned char ) <S2SV_ModStart> ; isspace ( ( unsigned char ) <S2SV_ModStart> 0 ) { set_lenIV ( line <S2SV_ModEnd> ) ; } <S2SV_ModStart> ""string<S2SV_blank>currentfile"" ) ) ) { set_cs_start ( line ) <S2SV_ModEnd> ; } } <S2SV_ModStart> && isdigit ( ( unsigned char ) <S2SV_ModStart> && isdigit ( ( unsigned char ) <S2SV_ModStart> ; isspace ( ( unsigned char )
"
492,"CWE-416 static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""No<S2SV_blank>USB<S2SV_blank>device<S2SV_blank>connected<S2SV_blank>to<S2SV_blank>ttyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , ""could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>USB<S2SV_blank>console<S2SV_blank>port\\n"" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <S2SV_StartBug> usb_autopm_put_interface ( serial -> interface ) ; <S2SV_EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
","<S2SV_ModStart> = 0 ; info -> port = NULL ;
"
493,"CWE-264 int perf_pmu_register ( struct pmu * pmu , const char * name , int type ) { int cpu , ret ; mutex_lock ( & pmus_lock ) ; ret = - ENOMEM ; pmu -> pmu_disable_count = alloc_percpu ( int ) ; if ( ! pmu -> pmu_disable_count ) goto unlock ; pmu -> type = - 1 ; if ( ! name ) goto skip_type ; pmu -> name = name ; if ( type < 0 ) { type = idr_alloc ( & pmu_idr , pmu , PERF_TYPE_MAX , 0 , GFP_KERNEL ) ; if ( type < 0 ) { ret = type ; goto free_pdc ; } } pmu -> type = type ; if ( pmu_bus_running ) { ret = pmu_dev_alloc ( pmu ) ; if ( ret ) goto free_idr ; } skip_type : pmu -> pmu_cpu_context = find_pmu_context ( pmu -> task_ctx_nr ) ; if ( pmu -> pmu_cpu_context ) goto got_cpu_context ; ret = - ENOMEM ; pmu -> pmu_cpu_context = alloc_percpu ( struct perf_cpu_context ) ; if ( ! pmu -> pmu_cpu_context ) goto free_dev ; for_each_possible_cpu ( cpu ) { struct perf_cpu_context * cpuctx ; cpuctx = per_cpu_ptr ( pmu -> pmu_cpu_context , cpu ) ; __perf_event_init_context ( & cpuctx -> ctx ) ; lockdep_set_class ( & cpuctx -> ctx . mutex , & cpuctx_mutex ) ; lockdep_set_class ( & cpuctx -> ctx . lock , & cpuctx_lock ) ; <S2SV_StartBug> cpuctx -> ctx . type = cpu_context ; <S2SV_EndBug> cpuctx -> ctx . pmu = pmu ; __perf_cpu_hrtimer_init ( cpuctx , cpu ) ; INIT_LIST_HEAD ( & cpuctx -> rotation_list ) ; cpuctx -> unique_pmu = pmu ; } got_cpu_context : if ( ! pmu -> start_txn ) { if ( pmu -> pmu_enable ) { pmu -> start_txn = perf_pmu_start_txn ; pmu -> commit_txn = perf_pmu_commit_txn ; pmu -> cancel_txn = perf_pmu_cancel_txn ; } else { pmu -> start_txn = perf_pmu_nop_void ; pmu -> commit_txn = perf_pmu_nop_int ; pmu -> cancel_txn = perf_pmu_nop_void ; } } if ( ! pmu -> pmu_enable ) { pmu -> pmu_enable = perf_pmu_nop_void ; pmu -> pmu_disable = perf_pmu_nop_void ; } if ( ! pmu -> event_idx ) pmu -> event_idx = perf_event_idx_default ; list_add_rcu ( & pmu -> entry , & pmus ) ; ret = 0 ; unlock : mutex_unlock ( & pmus_lock ) ; return ret ; free_dev : device_del ( pmu -> dev ) ; put_device ( pmu -> dev ) ; free_idr : if ( pmu -> type >= PERF_TYPE_MAX ) idr_remove ( & pmu_idr , pmu -> type ) ; free_pdc : free_percpu ( pmu -> pmu_disable_count ) ; goto unlock ; }
","<S2SV_ModStart> -> ctx . <S2SV_ModEnd> pmu = pmu
"
494,"CWE-000 static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t len , <S2SV_StartBug> struct iovec * iovec ) <S2SV_EndBug> { if ( unlikely ( ! access_ok ( ! rw , buf , len ) ) ) return - EFAULT ; iovec -> iov_base = buf ; iovec -> iov_len = len ; * nr_segs = 1 ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> iovec * iovec , struct iov_iter * iter ) { if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> = 1 ; iov_iter_init ( iter , rw , iovec , * nr_segs , len ) ;
"
495,"CWE-189 static int ext4_fill_flex_info ( struct super_block * sb ) { struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; struct ext4_group_desc * gdp = NULL ; ext4_group_t flex_group_count ; ext4_group_t flex_group ; <S2SV_StartBug> int groups_per_flex = 0 ; <S2SV_EndBug> size_t size ; int i ; sbi -> s_log_groups_per_flex = sbi -> s_es -> s_log_groups_per_flex ; <S2SV_StartBug> groups_per_flex = 1 << sbi -> s_log_groups_per_flex ; <S2SV_EndBug> <S2SV_StartBug> if ( groups_per_flex < 2 ) { <S2SV_EndBug> sbi -> s_log_groups_per_flex = 0 ; return 1 ; } flex_group_count = ( ( sbi -> s_groups_count + groups_per_flex - 1 ) + ( ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) + 1 ) << EXT4_DESC_PER_BLOCK_BITS ( sb ) ) ) / groups_per_flex ; size = flex_group_count * sizeof ( struct flex_groups ) ; sbi -> s_flex_groups = ext4_kvzalloc ( size , GFP_KERNEL ) ; if ( sbi -> s_flex_groups == NULL ) { ext4_msg ( sb , KERN_ERR , ""not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>%u<S2SV_blank>flex<S2SV_blank>groups"" , flex_group_count ) ; goto failed ; } for ( i = 0 ; i < sbi -> s_groups_count ; i ++ ) { gdp = ext4_get_group_desc ( sb , i , NULL ) ; flex_group = ext4_flex_group ( sbi , i ) ; atomic_add ( ext4_free_inodes_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_inodes ) ; atomic_add ( ext4_free_group_clusters ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_clusters ) ; atomic_add ( ext4_used_dirs_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . used_dirs ) ; } return 1 ; failed : return 0 ; }
","<S2SV_ModStart> ext4_group_t flex_group ; unsigned <S2SV_ModStart> -> s_log_groups_per_flex ; if ( sbi -> s_log_groups_per_flex < 1 || sbi -> s_log_groups_per_flex > 31 ) { sbi -> s_log_groups_per_flex = 0 ; return 1 ; } <S2SV_ModStart> -> s_log_groups_per_flex ; <S2SV_ModEnd> flex_group_count = (
"
496,"CWE-399 static inline int sctp_chunk_length_valid ( struct sctp_chunk * chunk , __u16 required_length ) { __u16 chunk_length = ntohs ( chunk -> chunk_hdr -> length ) ; <S2SV_StartBug> if ( unlikely ( chunk_length < required_length ) ) <S2SV_EndBug> return 0 ; return 1 ; }
","<S2SV_ModStart> ( unlikely ( chunk -> pdiscard ) ) return 0 ; if ( unlikely (
"
497,"CWE-119 cJSON * cJSON_CreateStringArray ( const char * * strings , int count ) { int i ; cJSON * n = 0 , * p = 0 , * a = cJSON_CreateArray ( ) ; <S2SV_StartBug> for ( i = 0 ; a && i < count ; ++ i ) { <S2SV_EndBug> n = cJSON_CreateString ( strings [ i ] ) ; <S2SV_StartBug> if ( ! i ) <S2SV_EndBug> a -> child = n ; else suffix_object ( p , n ) ; p = n ; } return a ; }
","<S2SV_ModStart> < count ; i ++ <S2SV_ModEnd> ) { n <S2SV_ModStart> ] ) ; if ( ! n ) { cJSON_Delete ( a ) ; return 0 ; }
"
498,"CWE-287 int m_authenticate ( struct Client * cptr , struct Client * sptr , int parc , char * parv [ ] ) { struct Client * acptr ; int first = 0 ; char realhost [ HOSTLEN + 3 ] ; char * hoststr = ( cli_sockhost ( cptr ) ? cli_sockhost ( cptr ) : cli_sock_ip ( cptr ) ) ; if ( ! CapActive ( cptr , CAP_SASL ) ) return 0 ; if ( parc < 2 ) return need_more_params ( cptr , ""AUTHENTICATE"" ) ; if ( strlen ( parv [ 1 ] ) > 400 ) return send_reply ( cptr , ERR_SASLTOOLONG ) ; if ( IsSASLComplete ( cptr ) ) return send_reply ( cptr , ERR_SASLALREADY ) ; if ( ! ( acptr = cli_saslagent ( cptr ) ) ) { if ( strcmp ( feature_str ( FEAT_SASL_SERVER ) , ""*"" ) ) acptr = find_match_server ( ( char * ) feature_str ( FEAT_SASL_SERVER ) ) ; else acptr = NULL ; } if ( ! acptr && strcmp ( feature_str ( FEAT_SASL_SERVER ) , ""*"" ) ) return send_reply ( cptr , ERR_SASLFAIL , "":<S2SV_blank>service<S2SV_blank>unavailable"" ) ; if ( acptr && IsMe ( acptr ) ) return 0 ; if ( ! cli_saslcookie ( cptr ) ) { do { cli_saslcookie ( cptr ) = ircrandom ( ) & 0x7fffffff ; } while ( ! cli_saslcookie ( cptr ) ) ; first = 1 ; } if ( strchr ( hoststr , ':' ) != NULL ) ircd_snprintf ( 0 , realhost , sizeof ( realhost ) , ""[%s]"" , hoststr ) ; else ircd_strncpy ( realhost , hoststr , sizeof ( realhost ) ) ; if ( acptr ) { if ( first ) { <S2SV_StartBug> if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) <S2SV_EndBug> sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ; else sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; if ( feature_bool ( FEAT_SASL_SENDHOST ) ) sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>H<S2SV_blank>:%s@%s:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , cli_username ( cptr ) , realhost , cli_sock_ip ( cptr ) ) ; } else { sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>C<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; } } else { if ( first ) { <S2SV_StartBug> if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) <S2SV_EndBug> sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ; else sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; if ( feature_bool ( FEAT_SASL_SENDHOST ) ) sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>H<S2SV_blank>:%s@%s:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , cli_username ( cptr ) , realhost , cli_sock_ip ( cptr ) ) ; } else { sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>C<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; } } if ( ! t_active ( & cli_sasltimeout ( cptr ) ) ) timer_add ( timer_init ( & cli_sasltimeout ( cptr ) ) , sasl_timeout_callback , ( void * ) cptr , TT_RELATIVE , feature_int ( FEAT_SASL_TIMEOUT ) ) ; return 0 ; }
","<S2SV_ModStart> { if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ; if ( <S2SV_ModStart> { if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ; if (
"
499,"CWE-189 static void diff_bytes_c ( uint8_t * dst , const uint8_t * src1 , const uint8_t * src2 , int w ) { long i ; # if ! HAVE_FAST_UNALIGNED if ( ( long ) src2 & ( sizeof ( long ) - 1 ) ) { for ( i = 0 ; i + 7 < w ; i += 8 ) { dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ] ; dst [ i + 1 ] = src1 [ i + 1 ] - src2 [ i + 1 ] ; dst [ i + 2 ] = src1 [ i + 2 ] - src2 [ i + 2 ] ; dst [ i + 3 ] = src1 [ i + 3 ] - src2 [ i + 3 ] ; dst [ i + 4 ] = src1 [ i + 4 ] - src2 [ i + 4 ] ; dst [ i + 5 ] = src1 [ i + 5 ] - src2 [ i + 5 ] ; dst [ i + 6 ] = src1 [ i + 6 ] - src2 [ i + 6 ] ; dst [ i + 7 ] = src1 [ i + 7 ] - src2 [ i + 7 ] ; } } else # endif <S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> long a = * ( long * ) ( src1 + i ) ; long b = * ( long * ) ( src2 + i ) ; * ( long * ) ( dst + i ) = ( ( a | pb_80 ) - ( b & pb_7f ) ) ^ ( ( a ^ b ^ pb_80 ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ] ; }
","<S2SV_ModStart> <= w - ( int )
"
500,"CWE-125 int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; <S2SV_StartBug> match_length += callback_args -> forward_matches ; <S2SV_EndBug> if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
","<S2SV_ModStart> callback_args -> forward_matches ; assert ( match_offset + match_length <= callback_args -> data_size )
"
501,"CWE-264 static Channel * server_request_direct_streamlocal ( void ) { Channel * c = NULL ; char * target , * originator ; u_short originator_port ; target = packet_get_string ( NULL ) ; originator = packet_get_string ( NULL ) ; originator_port = packet_get_int ( ) ; packet_check_eom ( ) ; debug ( ""server_request_direct_streamlocal:<S2SV_blank>originator<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>target<S2SV_blank>%s"" , originator , originator_port , target ) ; if ( ( options . allow_streamlocal_forwarding & FORWARD_LOCAL ) != 0 && <S2SV_StartBug> ! no_port_forwarding_flag && ! options . disable_forwarding ) { <S2SV_EndBug> c = channel_connect_to_path ( target , ""direct-streamlocal@openssh.com"" , ""direct-streamlocal"" ) ; } else { logit ( ""refused<S2SV_blank>streamlocal<S2SV_blank>port<S2SV_blank>forward:<S2SV_blank>"" ""originator<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>target<S2SV_blank>%s"" , originator , originator_port , target ) ; } free ( originator ) ; free ( target ) ; return c ; }
","<S2SV_ModStart> options . disable_forwarding && use_privsep
"
502,"CWE-119 static int smacker_decode_tree ( BitstreamContext * bc , HuffContext * hc , uint32_t prefix , int length ) { <S2SV_StartBug> if ( ! bitstream_read_bit ( bc ) ) { <S2SV_EndBug> if ( hc -> current >= 256 ) { av_log ( NULL , AV_LOG_ERROR , ""Tree<S2SV_blank>size<S2SV_blank>exceeded!\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( length ) { hc -> bits [ hc -> current ] = prefix ; hc -> lengths [ hc -> current ] = length ; } else { hc -> bits [ hc -> current ] = 0 ; hc -> lengths [ hc -> current ] = 0 ; } hc -> values [ hc -> current ] = bitstream_read ( bc , 8 ) ; hc -> current ++ ; if ( hc -> maxlength < length ) hc -> maxlength = length ; return 0 ; } else { int r ; length ++ ; r = smacker_decode_tree ( bc , hc , prefix , length ) ; if ( r ) return r ; return smacker_decode_tree ( bc , hc , prefix | ( 1 << ( length - 1 ) ) , length ) ; } }
","<S2SV_ModStart> { if ( length > SMKTREE_DECODE_MAX_RECURSION ) { av_log ( NULL , AV_LOG_ERROR , ""Maximum<S2SV_blank>tree<S2SV_blank>recursion<S2SV_blank>level<S2SV_blank>exceeded.\\n"" ) ; return AVERROR_INVALIDDATA ; } if (
"
503,"CWE-20 int verify_iovec ( struct msghdr * m , struct iovec * iov , struct sockaddr_storage * address , int mode ) { int size , ct , err ; if ( m -> msg_namelen ) { if ( mode == VERIFY_READ ) { void __user * namep ; namep = ( void __user __force * ) m -> msg_name ; err = move_addr_to_kernel ( namep , m -> msg_namelen , address ) ; if ( err < 0 ) return err ; } <S2SV_StartBug> m -> msg_name = address ; <S2SV_EndBug> } else { m -> msg_name = NULL ; } size = m -> msg_iovlen * sizeof ( struct iovec ) ; if ( copy_from_user ( iov , ( void __user __force * ) m -> msg_iov , size ) ) return - EFAULT ; m -> msg_iov = iov ; err = 0 ; for ( ct = 0 ; ct < m -> msg_iovlen ; ct ++ ) { size_t len = iov [ ct ] . iov_len ; if ( len > INT_MAX - err ) { len = INT_MAX - err ; iov [ ct ] . iov_len = len ; } err += len ; } return err ; }
","<S2SV_ModStart> err ; } if ( m -> msg_name )
"
504,"CWE-125 int obj2ast_mod ( PyObject * obj , mod_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Module_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; asdl_seq * type_ignores ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_type_ignores ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_type_ignores ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; type_ignores = _Ta3_asdl_seq_new ( len , arena ) ; if ( type_ignores == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> type_ignore_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Module<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( type_ignores , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } * out = Module ( body , type_ignores , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ; return 1 ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & body , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; return 1 ; } * out = Expression ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionType_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * argtypes ; expr_ty returns ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_argtypes ) ) { <S2SV_EndBug> int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_argtypes ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; argtypes = _Ta3_asdl_seq_new ( len , arena ) ; if ( argtypes == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( argtypes , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; <S2SV_EndBug> return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_returns ) ) { int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""returns\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Suite<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ; <S2SV_EndBug> return 1 ; } * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>mod,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
","<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_ignores , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""type_ignores\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { type_ignore_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } * out = Module ( body , type_ignores , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_argtypes , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""argtypes\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""returns\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { <S2SV_ModEnd> PyErr_SetString ( PyExc_TypeError <S2SV_ModStart> ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <S2SV_ModEnd> ( PyExc_TypeError , <S2SV_ModStart> ( PyExc_TypeError , <S2SV_ModEnd> ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>mod,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj
"
505,"CWE-119 void jpc_qmfb_split_col ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE ] ; jpc_fix_t * buf = splitbuf ; register jpc_fix_t * srcptr ; register jpc_fix_t * dstptr ; register int n ; register int m ; <S2SV_StartBug> int hstartcol ; <S2SV_EndBug> if ( bufsize > QMFB_SPLITBUFSIZE ) { if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { abort ( ) ; } } if ( numrows >= 2 ) { <S2SV_StartBug> hstartcol = ( numrows + 1 - parity ) >> 1 ; <S2SV_EndBug> <S2SV_StartBug> m = numrows - hstartcol ; <S2SV_EndBug> n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { * dstptr = * srcptr ; ++ dstptr ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { * dstptr = * srcptr ; dstptr += stride ; srcptr += stride << 1 ; } <S2SV_StartBug> dstptr = & a [ hstartcol * stride ] ; <S2SV_EndBug> srcptr = buf ; n = m ; while ( n -- > 0 ) { * dstptr = * srcptr ; dstptr += stride ; ++ srcptr ; } } if ( buf != splitbuf ) { jas_free ( buf ) ; } }
","<S2SV_ModStart> m ; int hstartrow <S2SV_ModEnd> ; if ( <S2SV_ModStart> 2 ) { hstartrow <S2SV_ModEnd> = ( numrows <S2SV_ModStart> = numrows - hstartrow <S2SV_ModEnd> ; n = <S2SV_ModStart> & a [ hstartrow <S2SV_ModEnd> * stride ]
"
506,"CWE-119 static int iwl_process_add_sta_resp ( struct iwl_priv * priv , struct iwl_addsta_cmd * addsta , struct iwl_rx_packet * pkt ) { u8 sta_id = addsta -> sta . sta_id ; unsigned long flags ; int ret = - EIO ; if ( pkt -> hdr . flags & IWL_CMD_FAILED_MSK ) { IWL_ERR ( priv , ""Bad<S2SV_blank>return<S2SV_blank>from<S2SV_blank>REPLY_ADD_STA<S2SV_blank>(0x%08X)\\n"" , pkt -> hdr . flags ) ; return ret ; } IWL_DEBUG_INFO ( priv , ""Processing<S2SV_blank>response<S2SV_blank>for<S2SV_blank>adding<S2SV_blank>station<S2SV_blank>%u\\n"" , sta_id ) ; spin_lock_irqsave ( & priv -> shrd -> sta_lock , flags ) ; switch ( pkt -> u . add_sta . status ) { case ADD_STA_SUCCESS_MSK : IWL_DEBUG_INFO ( priv , ""REPLY_ADD_STA<S2SV_blank>PASSED\\n"" ) ; <S2SV_StartBug> iwl_sta_ucode_activate ( priv , sta_id ) ; <S2SV_EndBug> ret = 0 ; break ; case ADD_STA_NO_ROOM_IN_TABLE : IWL_ERR ( priv , ""Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>room<S2SV_blank>in<S2SV_blank>table.\\n"" , sta_id ) ; break ; case ADD_STA_NO_BLOCK_ACK_RESOURCE : IWL_ERR ( priv , ""Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>block<S2SV_blank>ack<S2SV_blank>"" ""resource.\\n"" , sta_id ) ; break ; case ADD_STA_MODIFY_NON_EXIST_STA : IWL_ERR ( priv , ""Attempting<S2SV_blank>to<S2SV_blank>modify<S2SV_blank>non-existing<S2SV_blank>station<S2SV_blank>%d\\n"" , sta_id ) ; break ; default : IWL_DEBUG_ASSOC ( priv , ""Received<S2SV_blank>REPLY_ADD_STA:(0x%08X)\\n"" , pkt -> u . add_sta . status ) ; break ; } IWL_DEBUG_INFO ( priv , ""%s<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM\\n"" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? ""Modified"" : ""Added"" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; IWL_DEBUG_INFO ( priv , ""%s<S2SV_blank>station<S2SV_blank>according<S2SV_blank>to<S2SV_blank>cmd<S2SV_blank>buffer<S2SV_blank>%pM\\n"" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? ""Modified"" : ""Added"" , addsta -> sta . addr ) ; spin_unlock_irqrestore ( & priv -> shrd -> sta_lock , flags ) ; return ret ; }
","<S2SV_ModStart> ""REPLY_ADD_STA<S2SV_blank>PASSED\\n"" ) ; ret = iwl_sta_ucode_activate ( priv , sta_id ) <S2SV_ModEnd> ; break ;
"
507,"CWE-59 void open_log_file ( const char * name , const char * prog , const char * namespace , const char * instance ) { char * file_name ; if ( log_file ) { fclose ( log_file ) ; log_file = NULL ; } if ( ! name ) return ; file_name = make_file_name ( name , prog , namespace , instance ) ; <S2SV_StartBug> log_file = fopen ( file_name , ""a"" ) ; <S2SV_EndBug> if ( log_file ) { int n = fileno ( log_file ) ; fcntl ( n , F_SETFD , FD_CLOEXEC | fcntl ( n , F_GETFD ) ) ; fcntl ( n , F_SETFL , O_NONBLOCK | fcntl ( n , F_GETFL ) ) ; } FREE ( file_name ) ; }
","<S2SV_ModStart> ; log_file = fopen_safe <S2SV_ModEnd> ( file_name ,
"
508,"CWE-476 void test_re ( ) { assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ssi/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ssi(s|p)/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ssim*/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ssa?/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/Miss/<S2SV_blank>nocase<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/(M|N)iss/<S2SV_blank>nocase<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/[M-N]iss/<S2SV_blank>nocase<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/(Mi|ssi)ssippi/<S2SV_blank>nocase<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ppi\\\\tmi/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ppi\\\\.mi/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/^mississippi/<S2SV_blank>fullword<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/mississippi.*mississippi$/s<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_false_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/^ssi/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi"" ) ; assert_false_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ssi$/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi"" ) ; assert_false_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ssissi/<S2SV_blank>fullword<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi"" ) ; assert_false_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/^[isp]+/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi"" ) ; assert_regexp_syntax_error ( "")"" ) ; assert_true_regexp ( ""abc"" , ""abc"" , ""abc"" ) ; assert_false_regexp ( ""abc"" , ""xbc"" ) ; assert_false_regexp ( ""abc"" , ""axc"" ) ; assert_false_regexp ( ""abc"" , ""abx"" ) ; assert_true_regexp ( ""abc"" , ""xabcx"" , ""abc"" ) ; assert_true_regexp ( ""abc"" , ""ababc"" , ""abc"" ) ; assert_true_regexp ( ""a.c"" , ""abc"" , ""abc"" ) ; assert_false_regexp ( ""a.b"" , ""a\\nb"" ) ; assert_false_regexp ( ""a.*b"" , ""acc\\nccb"" ) ; assert_false_regexp ( ""a.{4,5}b"" , ""acc\\nccb"" ) ; assert_true_regexp ( ""a.b"" , ""a\\rb"" , ""a\\rb"" ) ; assert_true_regexp ( ""ab*c"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""ab*c"" , ""ac"" , ""ac"" ) ; assert_true_regexp ( ""ab*bc"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""ab*bc"" , ""abbc"" , ""abbc"" ) ; assert_true_regexp ( ""a.*bb"" , ""abbbb"" , ""abbbb"" ) ; assert_true_regexp ( ""a.*?bbb"" , ""abbbbbb"" , ""abbb"" ) ; assert_true_regexp ( ""a.*c"" , ""ac"" , ""ac"" ) ; assert_true_regexp ( ""a.*c"" , ""axyzc"" , ""axyzc"" ) ; assert_true_regexp ( ""ab+c"" , ""abbc"" , ""abbc"" ) ; assert_false_regexp ( ""ab+c"" , ""ac"" ) ; assert_true_regexp ( ""ab+"" , ""abbbb"" , ""abbbb"" ) ; assert_true_regexp ( ""ab+?"" , ""abbbb"" , ""ab"" ) ; assert_false_regexp ( ""ab+bc"" , ""abc"" ) ; assert_false_regexp ( ""ab+bc"" , ""abq"" ) ; assert_true_regexp ( ""a+b+c"" , ""aabbabc"" , ""abc"" ) ; assert_false_regexp ( ""ab?bc"" , ""abbbbc"" ) ; assert_true_regexp ( ""ab?c"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""ab*?"" , ""abbb"" , ""a"" ) ; assert_true_regexp ( ""ab?c"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""ab??"" , ""ab"" , ""a"" ) ; assert_true_regexp ( ""a(b|x)c"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""a(b|x)c"" , ""axc"" , ""axc"" ) ; assert_true_regexp ( ""a(b|.)c"" , ""axc"" , ""axc"" ) ; assert_true_regexp ( ""a(b|x|y)c"" , ""ayc"" , ""ayc"" ) ; assert_true_regexp ( ""(a+|b)*"" , ""ab"" , ""ab"" ) ; assert_true_regexp ( ""a|b|c|d|e"" , ""e"" , ""e"" ) ; assert_true_regexp ( ""(a|b|c|d|e)f"" , ""ef"" , ""ef"" ) ; assert_true_regexp ( "".b{2}"" , ""abb"" , ""abb"" ) ; assert_true_regexp ( ""ab{1}c"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""ab{1,2}c"" , ""abbc"" , ""abbc"" ) ; assert_true_regexp ( ""ab{1,}c"" , ""abbbc"" , ""abbbc"" ) ; assert_false_regexp ( ""ab{1,}b"" , ""ab"" ) ; assert_false_regexp ( ""ab{1}c"" , ""abbc"" ) ; assert_true_regexp ( ""ab{0,}c"" , ""ac"" , ""ac"" ) ; assert_true_regexp ( ""ab{0,}c"" , ""abbbc"" , ""abbbc"" ) ; assert_true_regexp ( ""ab{,3}c"" , ""abbbc"" , ""abbbc"" ) ; assert_false_regexp ( ""ab{,2}c"" , ""abbbc"" ) ; assert_false_regexp ( ""ab{4,5}bc"" , ""abbbbc"" ) ; assert_true_regexp ( ""ab{2,3}?"" , ""abbbbb"" , ""abb"" ) ; assert_true_regexp ( ""ab{.*}"" , ""ab{c}"" , ""ab{c}"" ) ; assert_true_regexp ( "".(aa){1,2}"" , ""aaaaaaaaaa"" , ""aaaaa"" ) ; assert_true_regexp ( ""a.(bc.){2}"" , ""aabcabca"" , ""aabcabca"" ) ; assert_true_regexp ( ""(ab{1,2}c){1,3}"" , ""abbcabc"" , ""abbcabc"" ) ; assert_true_regexp ( ""ab(c|cc){1,3}d"" , ""abccccccd"" , ""abccccccd"" ) ; assert_true_regexp ( ""a[bx]c"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""a[bx]c"" , ""axc"" , ""axc"" ) ; assert_true_regexp ( ""a[0-9]*b"" , ""ab"" , ""ab"" ) ; assert_true_regexp ( ""a[0-9]*b"" , ""a0123456789b"" , ""a0123456789b"" ) ; assert_true_regexp ( ""[0-9a-f]+"" , ""0123456789abcdef"" , ""0123456789abcdef"" ) ; assert_true_regexp ( ""[0-9a-f]+"" , ""xyz0123456789xyz"" , ""0123456789"" ) ; assert_true_regexp ( ""a[\\\\s\\\\S]b"" , ""a<S2SV_blank>b"" , ""a<S2SV_blank>b"" ) ; assert_true_regexp ( ""a[\\\\d\\\\D]b"" , ""a1b"" , ""a1b"" ) ; assert_false_regexp ( ""[x-z]+"" , ""abc"" ) ; assert_true_regexp ( ""a[-]?c"" , ""ac"" , ""ac"" ) ; assert_true_regexp ( ""a[-b]"" , ""a-"" , ""a-"" ) ; assert_true_regexp ( ""a[-b]"" , ""ab"" , ""ab"" ) ; assert_true_regexp ( ""a[b-]"" , ""a-"" , ""a-"" ) ; assert_true_regexp ( ""a[b-]"" , ""ab"" , ""ab"" ) ; assert_true_regexp ( ""[a-c-e]"" , ""b"" , ""b"" ) ; assert_true_regexp ( ""[a-c-e]"" , ""-"" , ""-"" ) ; assert_false_regexp ( ""[a-c-e]"" , ""d"" ) ; assert_regexp_syntax_error ( ""[b-a]"" ) ; assert_regexp_syntax_error ( ""(abc"" ) ; assert_regexp_syntax_error ( ""abc)"" ) ; assert_regexp_syntax_error ( ""a[]b"" ) ; assert_regexp_syntax_error ( ""a\\\\"" ) ; assert_true_regexp ( ""a[\\\\-b]"" , ""a-"" , ""a-"" ) ; assert_true_regexp ( ""a[\\\\-b]"" , ""ab"" , ""ab"" ) ; assert_regexp_syntax_error ( ""a[\\\\"" ) ; assert_true_regexp ( ""a]"" , ""a]"" , ""a]"" ) ; assert_true_regexp ( ""a[]]b"" , ""a]b"" , ""a]b"" ) ; assert_true_regexp ( ""a[\\\\]]b"" , ""a]b"" , ""a]b"" ) ; assert_true_regexp ( ""a[^bc]d"" , ""aed"" , ""aed"" ) ; assert_false_regexp ( ""a[^bc]d"" , ""abd"" ) ; assert_true_regexp ( ""a[^-b]c"" , ""adc"" , ""adc"" ) ; assert_false_regexp ( ""a[^-b]c"" , ""a-c"" ) ; assert_false_regexp ( ""a[^]b]c"" , ""a]c"" ) ; assert_true_regexp ( ""a[^]b]c"" , ""adc"" , ""adc"" ) ; assert_true_regexp ( ""[^ab]*"" , ""cde"" , ""cde"" ) ; assert_regexp_syntax_error ( "")("" ) ; assert_true_regexp ( ""a\\\\sb"" , ""a<S2SV_blank>b"" , ""a<S2SV_blank>b"" ) ; assert_true_regexp ( ""a\\\\sb"" , ""a\\tb"" , ""a\\tb"" ) ; assert_true_regexp ( ""a\\\\sb"" , ""a\\rb"" , ""a\\rb"" ) ; assert_true_regexp ( ""a\\\\sb"" , ""a\\nb"" , ""a\\nb"" ) ; assert_true_regexp ( ""a\\\\sb"" , ""a\\vb"" , ""a\\vb"" ) ; assert_true_regexp ( ""a\\\\sb"" , ""a\\fb"" , ""a\\fb"" ) ; assert_false_regexp ( ""a\\\\Sb"" , ""a<S2SV_blank>b"" ) ; assert_false_regexp ( ""a\\\\Sb"" , ""a\\tb"" ) ; assert_false_regexp ( ""a\\\\Sb"" , ""a\\rb"" ) ; assert_false_regexp ( ""a\\\\Sb"" , ""a\\nb"" ) ; assert_false_regexp ( ""a\\\\Sb"" , ""a\\vb"" ) ; assert_false_regexp ( ""a\\\\Sb"" , ""a\\fb"" ) ; assert_true_regexp ( ""\\\\n\\\\r\\\\t\\\\f\\\\a"" , ""\\n\\r\\t\\f\\a"" , ""\\n\\r\\t\\f\\a"" ) ; assert_true_regexp ( ""[\\\\n][\\\\r][\\\\t][\\\\f][\\\\a]"" , ""\\n\\r\\t\\f\\a"" , ""\\n\\r\\t\\f\\a"" ) ; assert_true_regexp ( ""\\\\x01\\\\x02\\\\x03"" , ""\\x01\\x02\\x03"" , ""\\x01\\x02\\x03"" ) ; assert_true_regexp ( ""[\\\\x01-\\\\x03]+"" , ""\\x01\\x02\\x03"" , ""\\x01\\x02\\x03"" ) ; assert_false_regexp ( ""[\\\\x00-\\\\x02]+"" , ""\\x03\\x04\\x05"" ) ; assert_true_regexp ( ""[\\\\x5D]"" , ""]"" , ""]"" ) ; assert_true_regexp ( ""[\\\\0x5A-\\\\x5D]"" , ""\\x5B"" , ""\\x5B"" ) ; assert_true_regexp ( ""[\\\\x5D-\\\\x5F]"" , ""\\x5E"" , ""\\x5E"" ) ; assert_true_regexp ( ""[\\\\x5C-\\\\x5F]"" , ""\\x5E"" , ""\\x5E"" ) ; assert_true_regexp ( ""[\\\\x5D-\\\\x5F]"" , ""\\x5E"" , ""\\x5E"" ) ; assert_true_regexp ( ""a\\\\wc"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""a\\\\wc"" , ""a_c"" , ""a_c"" ) ; assert_true_regexp ( ""a\\\\wc"" , ""a0c"" , ""a0c"" ) ; assert_false_regexp ( ""a\\\\wc"" , ""a*c"" ) ; assert_true_regexp ( ""\\\\w+"" , ""--ab_cd0123--"" , ""ab_cd0123"" ) ; assert_true_regexp ( ""[\\\\w]+"" , ""--ab_cd0123--"" , ""ab_cd0123"" ) ; assert_true_regexp ( ""\\\\D+"" , ""1234abc5678"" , ""abc"" ) ; assert_true_regexp ( ""[\\\\d]+"" , ""0123456789"" , ""0123456789"" ) ; assert_true_regexp ( ""[\\\\D]+"" , ""1234abc5678"" , ""abc"" ) ; assert_true_regexp ( ""[\\\\da-fA-F]+"" , ""123abc"" , ""123abc"" ) ; assert_false_regexp ( ""^(ab|cd)e"" , ""abcde"" ) ; assert_true_regexp ( ""(abc|)ef"" , ""abcdef"" , ""ef"" ) ; assert_true_regexp ( ""(abc|)ef"" , ""abcef"" , ""abcef"" ) ; assert_true_regexp ( ""\\\\babc"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""abc\\\\b"" , ""abc"" , ""abc"" ) ; assert_false_regexp ( ""\\\\babc"" , ""1abc"" ) ; assert_false_regexp ( ""abc\\\\b"" , ""abc1"" ) ; assert_true_regexp ( ""abc\\\\s\\\\b"" , ""abc<S2SV_blank>x"" , ""abc<S2SV_blank>"" ) ; assert_false_regexp ( ""abc\\\\s\\\\b"" , ""abc<S2SV_blank><S2SV_blank>"" ) ; assert_true_regexp ( ""\\\\babc\\\\b"" , ""<S2SV_blank>abc<S2SV_blank>"" , ""abc"" ) ; assert_true_regexp ( ""\\\\b\\\\w\\\\w\\\\w\\\\b"" , ""<S2SV_blank>abc<S2SV_blank>"" , ""abc"" ) ; assert_true_regexp ( ""\\\\w\\\\w\\\\w\\\\b"" , ""abcd"" , ""bcd"" ) ; assert_true_regexp ( ""\\\\b\\\\w\\\\w\\\\w"" , ""abcd"" , ""abc"" ) ; assert_false_regexp ( ""\\\\b\\\\w\\\\w\\\\w\\\\b"" , ""abcd"" ) ; assert_false_regexp ( ""\\\\Babc"" , ""abc"" ) ; assert_false_regexp ( ""abc\\\\B"" , ""abc"" ) ; assert_true_regexp ( ""\\\\Babc"" , ""1abc"" , ""abc"" ) ; assert_true_regexp ( ""abc\\\\B"" , ""abc1"" , ""abc"" ) ; assert_false_regexp ( ""abc\\\\s\\\\B"" , ""abc<S2SV_blank>x"" ) ; assert_true_regexp ( ""abc\\\\s\\\\B"" , ""abc<S2SV_blank><S2SV_blank>"" , ""abc<S2SV_blank>"" ) ; assert_true_regexp ( ""\\\\w\\\\w\\\\w\\\\B"" , ""abcd"" , ""abc"" ) ; assert_true_regexp ( ""\\\\B\\\\w\\\\w\\\\w"" , ""abcd"" , ""bcd"" ) ; assert_false_regexp ( ""\\\\B\\\\w\\\\w\\\\w\\\\B"" , ""abcd"" ) ; assert_regexp_syntax_error ( ""(|abc)ef"" ) ; assert_true_regexp ( ""((a)(b)c)(d)"" , ""abcd"" , ""abcd"" ) ; assert_true_regexp ( ""(a|b)c*d"" , ""abcd"" , ""bcd"" ) ; assert_true_regexp ( ""(ab|ab*)bc"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""a([bc]*)c*"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""a([bc]*)c*"" , ""ac"" , ""ac"" ) ; assert_true_regexp ( ""a([bc]*)c*"" , ""a"" , ""a"" ) ; assert_true_regexp ( ""a([bc]*)(c*d)"" , ""abcd"" , ""abcd"" ) ; assert_true_regexp ( ""a([bc]+)(c*d)"" , ""abcd"" , ""abcd"" ) ; assert_true_regexp ( ""a([bc]*)(c+d)"" , ""abcd"" , ""abcd"" ) ; assert_true_regexp ( ""a[bcd]*dcdcde"" , ""adcdcde"" , ""adcdcde"" ) ; assert_false_regexp ( ""a[bcd]+dcdcde"" , ""adcdcde"" ) ; assert_true_regexp ( ""\\\\((.*),<S2SV_blank>(.*)\\\\)"" , ""(a,<S2SV_blank>b)"" , ""(a,<S2SV_blank>b)"" ) ; assert_true_regexp ( ""abc|123$"" , ""abcx"" , ""abc"" ) ; assert_false_regexp ( ""abc|123$"" , ""123x"" ) ; assert_true_regexp ( ""abc|^123"" , ""123"" , ""123"" ) ; assert_false_regexp ( ""abc|^123"" , ""x123"" ) ; assert_true_regexp ( ""^abc$"" , ""abc"" , ""abc"" ) ; assert_false_regexp ( ""^abc$"" , ""abcc"" ) ; assert_true_regexp ( ""^abc"" , ""abcc"" , ""abc"" ) ; assert_false_regexp ( ""^abc$"" , ""aabc"" ) ; assert_true_regexp ( ""abc$"" , ""aabc"" , ""abc"" ) ; assert_true_regexp ( ""^a(bc+|b[eh])g|.h$"" , ""abhg"" , ""abhg"" ) ; assert_true_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""effgz"" , ""effgz"" ) ; assert_true_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""ij"" , ""ij"" ) ; assert_false_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""effg"" ) ; assert_false_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""bcdd"" ) ; assert_true_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""reffgz"" , ""effgz"" ) ; assert_true_regexp ( ""whatever|<S2SV_blank><S2SV_blank><S2SV_blank>x.<S2SV_blank><S2SV_blank><S2SV_blank>x"" , ""<S2SV_blank><S2SV_blank><S2SV_blank>xy<S2SV_blank><S2SV_blank><S2SV_blank>x"" , ""<S2SV_blank><S2SV_blank><S2SV_blank>xy<S2SV_blank><S2SV_blank><S2SV_blank>x"" ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ""<S2SV_blank><S2SV_blank><S2SV_blank>xy<S2SV_blank><S2SV_blank><S2SV_blank>x"" ) ; assert_regexp_syntax_error ( ""\\\\x0"" ) ; assert_regexp_syntax_error ( ""\\\\x"" ) ; assert_regexp_syntax_error ( ""\\\\xxy"" ) ;
"
509,"CWE-000 int hashbin_delete ( hashbin_t * hashbin , FREE_FUNC free_func ) { irda_queue_t * queue ; unsigned long flags = 0 ; int i ; IRDA_ASSERT ( hashbin != NULL , return - 1 ; ) ; IRDA_ASSERT ( hashbin -> magic == HB_MAGIC , return - 1 ; ) ; <S2SV_StartBug> if ( hashbin -> hb_type & HB_LOCK ) { <S2SV_EndBug> spin_lock_irqsave_nested ( & hashbin -> hb_spinlock , flags , hashbin_lock_depth ++ ) ; } for ( i = 0 ; i < HASHBIN_SIZE ; i ++ ) { <S2SV_StartBug> queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> while ( queue ) { <S2SV_EndBug> if ( free_func ) <S2SV_StartBug> ( * free_func ) ( queue ) ; <S2SV_EndBug> queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ; } } hashbin -> hb_current = NULL ; hashbin -> magic = ~ HB_MAGIC ; <S2SV_StartBug> if ( hashbin -> hb_type & HB_LOCK ) { <S2SV_EndBug> spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ; <S2SV_StartBug> # ifdef CONFIG_LOCKDEP <S2SV_EndBug> hashbin_lock_depth -- ; # endif } kfree ( hashbin ) ; return 0 ; }
","<S2SV_ModStart> & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; <S2SV_ModEnd> for ( i <S2SV_ModStart> ++ ) { while ( 1 ) { <S2SV_ModStart> ] ) ; if ( ! queue ) break ; <S2SV_ModEnd> if ( free_func <S2SV_ModStart> ( free_func ) { if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ; free_func ( queue ) ; if ( hashbin -> hb_type & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; } <S2SV_ModEnd> } } hashbin <S2SV_ModStart> & HB_LOCK ) <S2SV_ModEnd> spin_unlock_irqrestore ( & <S2SV_ModStart> flags ) ; <S2SV_ModEnd> kfree ( hashbin
"
510,"CWE-269 static int do_remount ( struct path * path , int flags , int mnt_flags , void * data ) { int err ; struct super_block * sb = path -> mnt -> mnt_sb ; struct mount * mnt = real_mount ( path -> mnt ) ; if ( ! check_mnt ( mnt ) ) return - EINVAL ; if ( path -> dentry != path -> mnt -> mnt_root ) return - EINVAL ; if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_READONLY ) && ! ( mnt_flags & MNT_READONLY ) ) { return - EPERM ; } <S2SV_StartBug> err = security_sb_remount ( sb , data ) ; <S2SV_EndBug> if ( err ) return err ; down_write ( & sb -> s_umount ) ; if ( flags & MS_BIND ) err = change_mount_flags ( path -> mnt , flags ) ; else if ( ! capable ( CAP_SYS_ADMIN ) ) err = - EPERM ; else err = do_remount_sb ( sb , flags , data , 0 ) ; if ( ! err ) { lock_mount_hash ( ) ; mnt_flags |= mnt -> mnt . mnt_flags & ~ MNT_USER_SETTABLE_MASK ; mnt -> mnt . mnt_flags = mnt_flags ; touch_mnt_namespace ( mnt -> mnt_ns ) ; unlock_mount_hash ( ) ; } up_write ( & sb -> s_umount ) ; return err ; }
","<S2SV_ModStart> EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NODEV ) && ! ( mnt_flags & MNT_NODEV ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOSUID ) && ! ( mnt_flags & MNT_NOSUID ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOEXEC ) && ! ( mnt_flags & MNT_NOEXEC ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_ATIME ) && ( ( mnt -> mnt . mnt_flags & MNT_ATIME_MASK ) != ( mnt_flags & MNT_ATIME_MASK ) ) ) { return - EPERM ; }
"
511,"CWE-20 static int packet_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; <S2SV_StartBug> int copied , err ; <S2SV_EndBug> struct sockaddr_ll * sll ; int vnet_hdr_len = 0 ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT | MSG_ERRQUEUE ) ) goto out ; # if 0 if ( pkt_sk ( sk ) -> ifindex < 0 ) return - ENODEV ; # endif if ( flags & MSG_ERRQUEUE ) { err = sock_recv_errqueue ( sk , msg , len , SOL_PACKET , PACKET_TX_TIMESTAMP ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; if ( pkt_sk ( sk ) -> has_vnet_hdr ) { struct virtio_net_hdr vnet_hdr = { 0 } ; err = - EINVAL ; vnet_hdr_len = sizeof ( vnet_hdr ) ; if ( len < vnet_hdr_len ) goto out_free ; len -= vnet_hdr_len ; if ( skb_is_gso ( skb ) ) { struct skb_shared_info * sinfo = skb_shinfo ( skb ) ; vnet_hdr . hdr_len = skb_headlen ( skb ) ; vnet_hdr . gso_size = sinfo -> gso_size ; if ( sinfo -> gso_type & SKB_GSO_TCPV4 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV4 ; else if ( sinfo -> gso_type & SKB_GSO_TCPV6 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV6 ; else if ( sinfo -> gso_type & SKB_GSO_UDP ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_UDP ; else if ( sinfo -> gso_type & SKB_GSO_FCOE ) goto out_free ; else BUG ( ) ; if ( sinfo -> gso_type & SKB_GSO_TCP_ECN ) vnet_hdr . gso_type |= VIRTIO_NET_HDR_GSO_ECN ; } else vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) { vnet_hdr . flags = VIRTIO_NET_HDR_F_NEEDS_CSUM ; vnet_hdr . csum_start = skb_checksum_start_offset ( skb ) ; vnet_hdr . csum_offset = skb -> csum_offset ; } else if ( skb -> ip_summed == CHECKSUM_UNNECESSARY ) { vnet_hdr . flags = VIRTIO_NET_HDR_F_DATA_VALID ; } err = memcpy_toiovec ( msg -> msg_iov , ( void * ) & vnet_hdr , vnet_hdr_len ) ; if ( err < 0 ) goto out_free ; } <S2SV_StartBug> sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_EndBug> <S2SV_StartBug> if ( sock -> type == SOCK_PACKET ) <S2SV_EndBug> msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ; <S2SV_StartBug> else <S2SV_EndBug> msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ; <S2SV_StartBug> copied = skb -> len ; <S2SV_EndBug> if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; <S2SV_StartBug> if ( msg -> msg_name ) <S2SV_EndBug> memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , <S2SV_StartBug> msg -> msg_namelen ) ; <S2SV_EndBug> if ( pkt_sk ( sk ) -> auxdata ) { struct tpacket_auxdata aux ; aux . tp_status = TP_STATUS_USER ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) aux . tp_status |= TP_STATUS_CSUMNOTREADY ; aux . tp_len = PACKET_SKB_CB ( skb ) -> origlen ; aux . tp_snaplen = skb -> len ; aux . tp_mac = 0 ; aux . tp_net = skb_network_offset ( skb ) ; if ( vlan_tx_tag_present ( skb ) ) { aux . tp_vlan_tci = vlan_tx_tag_get ( skb ) ; aux . tp_status |= TP_STATUS_VLAN_VALID ; } else { aux . tp_vlan_tci = 0 ; } aux . tp_padding = 0 ; put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ; } err = vnet_hdr_len + ( ( flags & MSG_TRUNC ) ? skb -> len : copied ) ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; }
","<S2SV_ModStart> copied , err <S2SV_ModEnd> ; int vnet_hdr_len <S2SV_ModStart> out_free ; } copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { <S2SV_ModEnd> if ( sock <S2SV_ModStart> == SOCK_PACKET ) { <S2SV_ModStart> sockaddr_pkt ) ; } else { struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> sll_addr ) ; } memcpy <S2SV_ModEnd> ( msg -> <S2SV_ModStart> msg -> msg_name <S2SV_ModEnd> , & PACKET_SKB_CB <S2SV_ModStart> msg_namelen ) ; }
"
512,"CWE-190 int ras_validate ( jas_stream_t * in ) { <S2SV_StartBug> uchar buf [ RAS_MAGICLEN ] ; <S2SV_EndBug> int i ; int n ; uint_fast32_t magic ; assert ( JAS_STREAM_MAXPUTBACK >= RAS_MAGICLEN ) ; if ( ( n = jas_stream_read ( in , buf , RAS_MAGICLEN ) ) < 0 ) { return - 1 ; } for ( i = n - 1 ; i >= 0 ; -- i ) { if ( jas_stream_ungetc ( in , buf [ i ] ) == EOF ) { return - 1 ; } } if ( n < RAS_MAGICLEN ) { return - 1 ; } magic = ( JAS_CAST ( uint_fast32_t , buf [ 0 ] ) << 24 ) | ( JAS_CAST ( uint_fast32_t , buf [ 1 ] ) << 16 ) | ( JAS_CAST ( uint_fast32_t , buf [ 2 ] ) << 8 ) | buf [ 3 ] ; if ( magic != RAS_MAGIC ) { return - 1 ; } return 0 ; }
","<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> buf [ RAS_MAGICLEN
"
513,"CWE-000 static int clie_5_attach ( struct usb_serial * serial ) { struct usb_serial_port * port ; unsigned int pipe ; int j ; <S2SV_StartBug> if ( serial -> num_ports < 2 ) <S2SV_EndBug> return - 1 ; port = serial -> port [ 0 ] ; port -> bulk_out_endpointAddress = serial -> port [ 1 ] -> bulk_out_endpointAddress ; pipe = usb_sndbulkpipe ( serial -> dev , port -> bulk_out_endpointAddress ) ; for ( j = 0 ; j < ARRAY_SIZE ( port -> write_urbs ) ; ++ j ) port -> write_urbs [ j ] -> pipe = pipe ; return 0 ; }
","<S2SV_ModStart> ( serial -> num_bulk_out <S2SV_ModEnd> < 2 ) <S2SV_ModStart> < 2 ) { dev_err ( & serial -> interface -> dev , ""missing<S2SV_blank>bulk<S2SV_blank>out<S2SV_blank>endpoints\\n"" ) ; return - ENODEV ; } <S2SV_ModEnd> port = serial
"
514,"CWE-119 int WriteRiffHeader ( FILE * outfile , WavpackContext * wpc , int64_t total_samples , int qmode ) { <S2SV_StartBug> int do_rf64 = 0 , write_junk = 1 ; <S2SV_EndBug> ChunkHeader ds64hdr , datahdr , fmthdr ; RiffChunkHeader riffhdr ; <S2SV_StartBug> DS64Chunk ds64_chunk ; <S2SV_EndBug> JunkChunk junkchunk ; WaveHeader wavhdr ; uint32_t bcount ; int64_t total_data_bytes , total_riff_bytes ; int num_channels = WavpackGetNumChannels ( wpc ) ; int32_t channel_mask = WavpackGetChannelMask ( wpc ) ; int32_t sample_rate = WavpackGetSampleRate ( wpc ) ; int bytes_per_sample = WavpackGetBytesPerSample ( wpc ) ; int bits_per_sample = WavpackGetBitsPerSample ( wpc ) ; int format = WavpackGetFloatNormExp ( wpc ) ? 3 : 1 ; int wavhdrsize = 16 ; if ( format == 3 && WavpackGetFloatNormExp ( wpc ) != 127 ) { error_line ( ""can\'t<S2SV_blank>create<S2SV_blank>valid<S2SV_blank>RIFF<S2SV_blank>wav<S2SV_blank>header<S2SV_blank>for<S2SV_blank>non-normalized<S2SV_blank>floating<S2SV_blank>data!"" ) ; return FALSE ; } if ( total_samples == - 1 ) total_samples = 0x7ffff000 / ( bytes_per_sample * num_channels ) ; total_data_bytes = total_samples * bytes_per_sample * num_channels ; if ( total_data_bytes > 0xff000000 ) { if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>rf64"" , total_data_bytes ) ; write_junk = 0 ; do_rf64 = 1 ; } else if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>riff"" , total_data_bytes ) ; CLEAR ( wavhdr ) ; wavhdr . FormatTag = format ; wavhdr . NumChannels = num_channels ; wavhdr . SampleRate = sample_rate ; wavhdr . BytesPerSecond = sample_rate * num_channels * bytes_per_sample ; wavhdr . BlockAlign = bytes_per_sample * num_channels ; wavhdr . BitsPerSample = bits_per_sample ; if ( num_channels > 2 || channel_mask != 0x5 - num_channels ) { wavhdrsize = sizeof ( wavhdr ) ; wavhdr . cbSize = 22 ; wavhdr . ValidBitsPerSample = bits_per_sample ; wavhdr . SubFormat = format ; wavhdr . ChannelMask = channel_mask ; wavhdr . FormatTag = 0xfffe ; wavhdr . BitsPerSample = bytes_per_sample * 8 ; wavhdr . GUID [ 4 ] = 0x10 ; wavhdr . GUID [ 6 ] = 0x80 ; wavhdr . GUID [ 9 ] = 0xaa ; wavhdr . GUID [ 11 ] = 0x38 ; wavhdr . GUID [ 12 ] = 0x9b ; wavhdr . GUID [ 13 ] = 0x71 ; } strncpy ( riffhdr . ckID , do_rf64 ? ""RF64"" : ""RIFF"" , sizeof ( riffhdr . ckID ) ) ; strncpy ( riffhdr . formType , ""WAVE"" , sizeof ( riffhdr . formType ) ) ; total_riff_bytes = sizeof ( riffhdr ) + wavhdrsize + sizeof ( datahdr ) + ( ( total_data_bytes + 1 ) & ~ ( int64_t ) 1 ) ; if ( do_rf64 ) total_riff_bytes += sizeof ( ds64hdr ) + sizeof ( ds64_chunk ) ; <S2SV_StartBug> if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ; <S2SV_EndBug> strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ; strncpy ( datahdr . ckID , ""data"" , sizeof ( datahdr . ckID ) ) ; fmthdr . ckSize = wavhdrsize ; if ( write_junk ) { CLEAR ( junkchunk ) ; strncpy ( junkchunk . ckID , ""junk"" , sizeof ( junkchunk . ckID ) ) ; junkchunk . ckSize = sizeof ( junkchunk ) - 8 ; WavpackNativeToLittleEndian ( & junkchunk , ChunkHeaderFormat ) ; } if ( do_rf64 ) { strncpy ( ds64hdr . ckID , ""ds64"" , sizeof ( ds64hdr . ckID ) ) ; <S2SV_StartBug> ds64hdr . ckSize = sizeof ( ds64_chunk ) ; <S2SV_EndBug> CLEAR ( ds64_chunk ) ; ds64_chunk . riffSize64 = total_riff_bytes ; ds64_chunk . dataSize64 = total_data_bytes ; <S2SV_StartBug> ds64_chunk . sampleCount64 = total_samples ; <S2SV_EndBug> riffhdr . ckSize = ( uint32_t ) - 1 ; datahdr . ckSize = ( uint32_t ) - 1 ; WavpackNativeToLittleEndian ( & ds64hdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & ds64_chunk , DS64ChunkFormat ) ; } else { riffhdr . ckSize = ( uint32_t ) total_riff_bytes ; datahdr . ckSize = ( uint32_t ) total_data_bytes ; } <S2SV_StartBug> WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ; <S2SV_EndBug> WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & wavhdr , WaveHeaderFormat ) ; WavpackNativeToLittleEndian ( & datahdr , ChunkHeaderFormat ) ; if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) || <S2SV_StartBug> ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) || <S2SV_EndBug> ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } return TRUE ; }
","<S2SV_ModStart> write_junk = 1 , table_length = 0 <S2SV_ModStart> ; DS64Chunk ds64_chunk ; CS64Chunk cs64_chunk <S2SV_ModStart> ds64_chunk ) ; total_riff_bytes += table_length * sizeof ( CS64Chunk ) ; if ( write_junk ) total_riff_bytes += <S2SV_ModEnd> sizeof ( junkchunk <S2SV_ModStart> ( ds64_chunk ) + ( table_length * sizeof ( CS64Chunk ) ) <S2SV_ModStart> sampleCount64 = total_samples ; ds64_chunk . tableLength = table_length <S2SV_ModStart> total_data_bytes ; } if ( table_length ) { strncpy ( cs64_chunk . ckID , ""dmmy"" , sizeof ( cs64_chunk . ckID ) ) ; cs64_chunk . chunkSize64 = 12345678 ; WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ; } <S2SV_ModStart> ) ) ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } if ( <S2SV_ModEnd> ( write_junk &&
"
515,"CWE-20 static int ___sys_recvmsg ( struct socket * sock , struct msghdr __user * msg , struct msghdr * msg_sys , unsigned int flags , int nosec ) { struct compat_msghdr __user * msg_compat = ( struct compat_msghdr __user * ) msg ; struct iovec iovstack [ UIO_FASTIOV ] ; struct iovec * iov = iovstack ; unsigned long cmsg_ptr ; int err , total_len , len ; struct sockaddr_storage addr ; struct sockaddr __user * uaddr ; int __user * uaddr_len ; if ( MSG_CMSG_COMPAT & flags ) { if ( get_compat_msghdr ( msg_sys , msg_compat ) ) return - EFAULT ; } else { err = copy_msghdr_from_user ( msg_sys , msg ) ; if ( err ) return err ; } if ( msg_sys -> msg_iovlen > UIO_FASTIOV ) { err = - EMSGSIZE ; if ( msg_sys -> msg_iovlen > UIO_MAXIOV ) goto out ; err = - ENOMEM ; iov = kmalloc ( msg_sys -> msg_iovlen * sizeof ( struct iovec ) , GFP_KERNEL ) ; if ( ! iov ) goto out ; } uaddr = ( __force void __user * ) msg_sys -> msg_name ; uaddr_len = COMPAT_NAMELEN ( msg ) ; <S2SV_StartBug> if ( MSG_CMSG_COMPAT & flags ) { <S2SV_EndBug> err = verify_compat_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ; <S2SV_StartBug> } else <S2SV_EndBug> err = verify_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ; if ( err < 0 ) goto out_freeiov ; total_len = err ; cmsg_ptr = ( unsigned long ) msg_sys -> msg_control ; <S2SV_StartBug> msg_sys -> msg_flags = flags & ( MSG_CMSG_CLOEXEC | MSG_CMSG_COMPAT ) ; <S2SV_EndBug> if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; err = ( nosec ? sock_recvmsg_nosec : sock_recvmsg ) ( sock , msg_sys , total_len , flags ) ; if ( err < 0 ) goto out_freeiov ; len = err ; if ( uaddr != NULL ) { err = move_addr_to_user ( & addr , msg_sys -> msg_namelen , uaddr , uaddr_len ) ; if ( err < 0 ) goto out_freeiov ; } err = __put_user ( ( msg_sys -> msg_flags & ~ MSG_CMSG_COMPAT ) , COMPAT_FLAGS ( msg ) ) ; if ( err ) goto out_freeiov ; if ( MSG_CMSG_COMPAT & flags ) err = __put_user ( ( unsigned long ) msg_sys -> msg_control - cmsg_ptr , & msg_compat -> msg_controllen ) ; else err = __put_user ( ( unsigned long ) msg_sys -> msg_control - cmsg_ptr , & msg -> msg_controllen ) ; if ( err ) goto out_freeiov ; err = len ; out_freeiov : if ( iov != iovstack ) kfree ( iov ) ; out : return err ; }
","<S2SV_ModStart> & flags ) <S2SV_ModEnd> err = verify_compat_iovec <S2SV_ModStart> VERIFY_WRITE ) ; <S2SV_ModEnd> else err = <S2SV_ModStart> | MSG_CMSG_COMPAT ) ; msg_sys -> msg_namelen = 0
"
516,"CWE-119 static int gfs2_bmap_alloc ( struct inode * inode , const sector_t lblock , struct buffer_head * bh_map , struct metapath * mp , const unsigned int sheight , const unsigned int height , const unsigned int maxlen ) { struct gfs2_inode * ip = GFS2_I ( inode ) ; struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; <S2SV_StartBug> struct buffer_head * dibh = mp -> mp_bh [ 0 ] ; <S2SV_EndBug> u64 bn , dblock = 0 ; unsigned n , i , blks , alloced = 0 , iblks = 0 , branch_start = 0 ; unsigned dblks = 0 ; unsigned ptrs_per_blk ; <S2SV_StartBug> const unsigned end_of_metadata = height - 1 ; <S2SV_EndBug> int eob = 0 ; enum alloc_state state ; __be64 * ptr ; __be64 zero_bn = 0 ; BUG_ON ( sheight < 1 ) ; BUG_ON ( dibh == NULL ) ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( height == sheight ) { struct buffer_head * bh ; ptr = metapointer ( end_of_metadata , mp ) ; bh = mp -> mp_bh [ end_of_metadata ] ; dblks = gfs2_extent_length ( bh -> b_data , bh -> b_size , ptr , maxlen , & eob ) ; BUG_ON ( dblks < 1 ) ; state = ALLOC_DATA ; } else { ptrs_per_blk = height > 1 ? sdp -> sd_inptrs : sdp -> sd_diptrs ; dblks = min ( maxlen , ptrs_per_blk - mp -> mp_list [ end_of_metadata ] ) ; if ( height == ip -> i_height ) { iblks = height - sheight ; state = ALLOC_GROW_DEPTH ; } else { state = ALLOC_GROW_HEIGHT ; iblks = height - ip -> i_height ; branch_start = metapath_branch_start ( mp ) ; iblks += ( height - branch_start ) ; } } blks = dblks + iblks ; i = sheight ; do { int error ; n = blks - alloced ; error = gfs2_alloc_block ( ip , & bn , & n ) ; if ( error ) return error ; alloced += n ; if ( state != ALLOC_DATA || gfs2_is_jdata ( ip ) ) gfs2_trans_add_unrevoke ( sdp , bn , n ) ; switch ( state ) { case ALLOC_GROW_HEIGHT : if ( i == 1 ) { ptr = ( __be64 * ) ( dibh -> b_data + sizeof ( struct gfs2_dinode ) ) ; zero_bn = * ptr ; } for ( ; i - 1 < height - ip -> i_height && n > 0 ; i ++ , n -- ) gfs2_indirect_init ( mp , ip -> i_gl , i , 0 , bn ++ ) ; if ( i - 1 == height - ip -> i_height ) { i -- ; gfs2_buffer_copy_tail ( mp -> mp_bh [ i ] , sizeof ( struct gfs2_meta_header ) , dibh , sizeof ( struct gfs2_dinode ) ) ; gfs2_buffer_clear_tail ( dibh , sizeof ( struct gfs2_dinode ) + sizeof ( __be64 ) ) ; ptr = ( __be64 * ) ( mp -> mp_bh [ i ] -> b_data + sizeof ( struct gfs2_meta_header ) ) ; * ptr = zero_bn ; state = ALLOC_GROW_DEPTH ; for ( i = branch_start ; i < height ; i ++ ) { if ( mp -> mp_bh [ i ] == NULL ) break ; brelse ( mp -> mp_bh [ i ] ) ; mp -> mp_bh [ i ] = NULL ; } i = branch_start ; } if ( n == 0 ) break ; case ALLOC_GROW_DEPTH : if ( i > 1 && i < height ) gfs2_trans_add_bh ( ip -> i_gl , mp -> mp_bh [ i - 1 ] , 1 ) ; for ( ; i < height && n > 0 ; i ++ , n -- ) gfs2_indirect_init ( mp , ip -> i_gl , i , mp -> mp_list [ i - 1 ] , bn ++ ) ; if ( i == height ) state = ALLOC_DATA ; if ( n == 0 ) break ; case ALLOC_DATA : BUG_ON ( n > dblks ) ; BUG_ON ( mp -> mp_bh [ end_of_metadata ] == NULL ) ; gfs2_trans_add_bh ( ip -> i_gl , mp -> mp_bh [ end_of_metadata ] , 1 ) ; dblks = n ; ptr = metapointer ( end_of_metadata , mp ) ; dblock = bn ; while ( n -- > 0 ) * ptr ++ = cpu_to_be64 ( bn ++ ) ; <S2SV_StartBug> break ; <S2SV_EndBug> } } while ( ( state != ALLOC_DATA ) || ! dblock ) ; ip -> i_height = height ; gfs2_add_inode_blocks ( & ip -> i_inode , alloced ) ; gfs2_dinode_out ( ip , mp -> mp_bh [ 0 ] -> b_data ) ; map_bh ( bh_map , inode -> i_sb , dblock ) ; bh_map -> b_size = dblks << inode -> i_blkbits ; set_buffer_new ( bh_map ) ; return 0 ; }
","<S2SV_ModStart> ) ; struct super_block * sb = sdp -> sd_vfs ; struct <S2SV_ModStart> height - 1 ; int ret <S2SV_ModStart> ++ ) ; if ( buffer_zeronew ( bh_map ) ) { ret = sb_issue_zeroout ( sb , dblock , dblks , GFP_NOFS ) ; if ( ret ) { fs_err ( sdp , ""Failed<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>data<S2SV_blank>buffers\\n"" ) ; clear_buffer_zeronew ( bh_map ) ; } }
"
517,"CWE-119 static void show_stream_config ( struct stream_state * stream , struct VpxEncoderConfig * global , struct VpxInputContext * input ) { # define SHOW ( field ) fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-28s<S2SV_blank>=<S2SV_blank>%d\\n"" , # field , stream -> config . cfg . field ) if ( stream -> index == 0 ) { fprintf ( stderr , ""Codec:<S2SV_blank>%s\\n"" , <S2SV_StartBug> vpx_codec_iface_name ( global -> codec -> interface ( ) ) ) ; <S2SV_EndBug> fprintf ( stderr , ""Source<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>Format:<S2SV_blank>%s\\n"" , input -> filename , <S2SV_StartBug> input -> use_i420 ? ""I420"" : ""YV12"" ) ; <S2SV_EndBug> } if ( stream -> next || stream -> index ) fprintf ( stderr , ""\\nStream<S2SV_blank>Index:<S2SV_blank>%d\\n"" , stream -> index ) ; fprintf ( stderr , ""Destination<S2SV_blank>file:<S2SV_blank>%s\\n"" , stream -> config . out_fn ) ; fprintf ( stderr , ""Encoder<S2SV_blank>parameters:\\n"" ) ; SHOW ( g_usage ) ; SHOW ( g_threads ) ; SHOW ( g_profile ) ; SHOW ( g_w ) ; SHOW ( g_h ) ; <S2SV_StartBug> SHOW ( g_timebase . num ) ; <S2SV_EndBug> SHOW ( g_timebase . den ) ; SHOW ( g_error_resilient ) ; SHOW ( g_pass ) ; SHOW ( g_lag_in_frames ) ; SHOW ( rc_dropframe_thresh ) ; <S2SV_StartBug> SHOW ( rc_resize_allowed ) ; <S2SV_EndBug> SHOW ( rc_resize_up_thresh ) ; SHOW ( rc_resize_down_thresh ) ; SHOW ( rc_end_usage ) ; SHOW ( rc_target_bitrate ) ; SHOW ( rc_min_quantizer ) ; SHOW ( rc_max_quantizer ) ; SHOW ( rc_undershoot_pct ) ; SHOW ( rc_overshoot_pct ) ; SHOW ( rc_buf_sz ) ; SHOW ( rc_buf_initial_sz ) ; SHOW ( rc_buf_optimal_sz ) ; SHOW ( rc_2pass_vbr_bias_pct ) ; SHOW ( rc_2pass_vbr_minsection_pct ) ; SHOW ( rc_2pass_vbr_maxsection_pct ) ; SHOW ( kf_mode ) ; SHOW ( kf_min_dist ) ; SHOW ( kf_max_dist ) ; }
","<S2SV_ModStart> -> codec -> codec_interface ( ) ) ) ; fprintf ( stderr , ""Source<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>File<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>Format:<S2SV_blank>%s\\n"" , <S2SV_ModEnd> input -> filename <S2SV_ModStart> -> filename , file_type_to_string ( input -> file_type ) , image_format_to_string ( input -> fmt ) <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; SHOW ( g_bit_depth ) ; SHOW ( g_input_bit_depth ) ; SHOW ( <S2SV_ModStart> SHOW ( rc_resize_allowed ) ; SHOW ( rc_scaled_width ) ; SHOW ( rc_scaled_height
"
518,"CWE-787 BOOL nsc_process_message ( NSC_CONTEXT * context , UINT16 bpp , UINT32 width , UINT32 height , const BYTE * data , UINT32 length , BYTE * pDstData , UINT32 DstFormat , UINT32 nDstStride , UINT32 nXDst , UINT32 nYDst , UINT32 nWidth , UINT32 nHeight , UINT32 flip ) { wStream * s ; BOOL ret ; s = Stream_New ( ( BYTE * ) data , length ) ; if ( ! s ) return FALSE ; if ( nDstStride == 0 ) nDstStride = nWidth * GetBytesPerPixel ( DstFormat ) ; switch ( bpp ) { case 32 : context -> format = PIXEL_FORMAT_BGRA32 ; break ; case 24 : context -> format = PIXEL_FORMAT_BGR24 ; break ; case 16 : context -> format = PIXEL_FORMAT_BGR16 ; break ; case 8 : context -> format = PIXEL_FORMAT_RGB8 ; break ; case 4 : context -> format = PIXEL_FORMAT_A4 ; break ; default : Stream_Free ( s , TRUE ) ; return FALSE ; } context -> width = width ; context -> height = height ; ret = nsc_context_initialize ( context , s ) ; Stream_Free ( s , FALSE ) ; if ( ! ret ) return FALSE ; <S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decompress_data ( context ) ; <S2SV_EndBug> PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data ) <S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> <S2SV_StartBug> context -> decode ( context ) ; <S2SV_EndBug> <S2SV_StartBug> PROFILER_EXIT ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ; return TRUE ; }
","<S2SV_ModStart> return FALSE ; { BOOL rc ; <S2SV_ModStart> -> prof_nsc_rle_decompress_data ) rc = <S2SV_ModStart> -> prof_nsc_rle_decompress_data ) if ( ! rc ) return FALSE ; } { BOOL rc ; <S2SV_ModStart> -> prof_nsc_decode ) rc = <S2SV_ModStart> -> prof_nsc_decode ) if ( ! rc ) return FALSE ; }
"
519,"CWE-399 xmlAttrPtr xsltAttrListTemplateProcess ( xsltTransformContextPtr ctxt , xmlNodePtr target , xmlAttrPtr attrs ) { xmlAttrPtr attr , copy , last ; xmlNodePtr oldInsert , text ; xmlNsPtr origNs = NULL , copyNs = NULL ; const xmlChar * value ; xmlChar * valueAVT ; if ( ( ctxt == NULL ) || ( target == NULL ) || ( attrs == NULL ) ) return ( NULL ) ; oldInsert = ctxt -> insert ; ctxt -> insert = target ; if ( target -> properties ) { last = target -> properties ; while ( last -> next != NULL ) last = last -> next ; } else { last = NULL ; } attr = attrs ; do { # ifdef XSLT_REFACTORED if ( attr -> psvi == xsltXSLTAttrMarker ) { goto next_attribute ; } # else if ( ( attr -> ns != NULL ) && xmlStrEqual ( attr -> ns -> href , XSLT_NAMESPACE ) ) { goto next_attribute ; } # endif if ( attr -> children != NULL ) { if ( ( attr -> children -> type != XML_TEXT_NODE ) || ( attr -> children -> next != NULL ) ) { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>The<S2SV_blank>children<S2SV_blank>of<S2SV_blank>an<S2SV_blank>attribute<S2SV_blank>node<S2SV_blank>of<S2SV_blank>a<S2SV_blank>"" ""literal<S2SV_blank>result<S2SV_blank>element<S2SV_blank>are<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>expected<S2SV_blank>form.\\n"" ) ; goto error ; } value = attr -> children -> content ; if ( value == NULL ) value = xmlDictLookup ( ctxt -> dict , BAD_CAST """" , 0 ) ; } else value = xmlDictLookup ( ctxt -> dict , BAD_CAST """" , 0 ) ; copy = xmlNewDocProp ( target -> doc , attr -> name , NULL ) ; if ( copy == NULL ) { if ( attr -> ns ) { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>attribute<S2SV_blank>\'{%s}%s\'.\\n"" , attr -> ns -> href , attr -> name ) ; } else { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>attribute<S2SV_blank>\'%s\'.\\n"" , attr -> name ) ; } goto error ; } copy -> parent = target ; if ( last == NULL ) { target -> properties = copy ; last = copy ; } else { last -> next = copy ; copy -> prev = last ; last = copy ; } if ( attr -> ns != origNs ) { origNs = attr -> ns ; if ( attr -> ns != NULL ) { # ifdef XSLT_REFACTORED copyNs = xsltGetSpecialNamespace ( ctxt , attr -> parent , attr -> ns -> href , attr -> ns -> prefix , target ) ; # else copyNs = xsltGetNamespace ( ctxt , attr -> parent , attr -> ns , target ) ; # endif if ( copyNs == NULL ) goto error ; } else copyNs = NULL ; } copy -> ns = copyNs ; text = xmlNewText ( NULL ) ; if ( text != NULL ) { copy -> last = copy -> children = text ; text -> parent = ( xmlNodePtr ) copy ; text -> doc = copy -> doc ; if ( attr -> psvi != NULL ) { valueAVT = xsltEvalAVT ( ctxt , attr -> psvi , attr -> parent ) ; if ( valueAVT == NULL ) { if ( attr -> ns ) { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>evaluate<S2SV_blank>the<S2SV_blank>AVT<S2SV_blank>"" ""of<S2SV_blank>attribute<S2SV_blank>\'{%s}%s\'.\\n"" , attr -> ns -> href , attr -> name ) ; } else { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>evaluate<S2SV_blank>the<S2SV_blank>AVT<S2SV_blank>"" ""of<S2SV_blank>attribute<S2SV_blank>\'%s\'.\\n"" , attr -> name ) ; } text -> content = xmlStrdup ( BAD_CAST """" ) ; goto error ; } else { text -> content = valueAVT ; } } else if ( ( ctxt -> internalized ) && ( target -> doc != NULL ) && <S2SV_StartBug> ( target -> doc -> dict == ctxt -> dict ) ) <S2SV_EndBug> { text -> content = ( xmlChar * ) value ; } else { text -> content = xmlStrdup ( value ) ; } if ( ( copy != NULL ) && ( text != NULL ) && ( xmlIsID ( copy -> doc , copy -> parent , copy ) ) ) xmlAddID ( NULL , copy -> doc , text -> content , copy ) ; } next_attribute : attr = attr -> next ; } while ( attr != NULL ) ; attr = attrs ; do { # ifdef XSLT_REFACTORED if ( ( attr -> psvi == xsltXSLTAttrMarker ) && xmlStrEqual ( attr -> name , ( const xmlChar * ) ""use-attribute-sets"" ) ) { xsltApplyAttributeSet ( ctxt , ctxt -> node , ( xmlNodePtr ) attr , NULL ) ; } # else if ( ( attr -> ns != NULL ) && xmlStrEqual ( attr -> name , ( const xmlChar * ) ""use-attribute-sets"" ) && xmlStrEqual ( attr -> ns -> href , XSLT_NAMESPACE ) ) { xsltApplyAttributeSet ( ctxt , ctxt -> node , ( xmlNodePtr ) attr , NULL ) ; } # endif attr = attr -> next ; } while ( attr != NULL ) ; ctxt -> insert = oldInsert ; return ( target -> properties ) ; error : ctxt -> insert = oldInsert ; return ( NULL ) ; }
","<S2SV_ModStart> -> dict ) && xmlDictOwns ( ctxt -> dict , value )
"
520,"CWE-269 static void skel ( const char * homedir , uid_t u , gid_t g ) { char * fname ; if ( ! arg_shell_none && ( strcmp ( cfg . shell , ""/usr/bin/zsh"" ) == 0 || strcmp ( cfg . shell , ""/bin/zsh"" ) == 0 ) ) { if ( asprintf ( & fname , ""%s/.zshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.zshrc"" , & s ) == 0 ) { <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ; } <S2SV_StartBug> } <S2SV_EndBug> else { FILE * fp = fopen ( fname , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , u , g , S_IRUSR | S_IWUSR ) ; fclose ( fp ) ; fs_logger2 ( ""touch"" , fname ) ; <S2SV_StartBug> } <S2SV_EndBug> } free ( fname ) ; } else if ( ! arg_shell_none && strcmp ( cfg . shell , ""/bin/csh"" ) == 0 ) { if ( asprintf ( & fname , ""%s/.cshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) { <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> fs_logger ( ""clone<S2SV_blank>/etc/skel/.cshrc"" ) ; } <S2SV_StartBug> } <S2SV_EndBug> else { FILE * fp = fopen ( fname , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , u , g , S_IRUSR | S_IWUSR ) ; fclose ( fp ) ; fs_logger2 ( ""touch"" , fname ) ; <S2SV_StartBug> } <S2SV_EndBug> } free ( fname ) ; } else { if ( asprintf ( & fname , ""%s/.bashrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.bashrc"" , & s ) == 0 ) { <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" ) ; } <S2SV_StartBug> } <S2SV_EndBug> free ( fname ) ; } }
","<S2SV_ModStart> 0 ) { <S2SV_ModEnd> copy_file ( ""/etc/skel/.zshrc"" <S2SV_ModStart> , 0644 ) ; <S2SV_ModEnd> fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" <S2SV_ModStart> ) ; } else { touch_file_as_user ( fname , u , g , 0644 <S2SV_ModEnd> ) ; fs_logger2 <S2SV_ModStart> fname ) ; <S2SV_ModEnd> } free ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> copy_file ( ""/etc/skel/.cshrc"" <S2SV_ModStart> , 0644 ) ; <S2SV_ModEnd> fs_logger ( ""clone<S2SV_blank>/etc/skel/.cshrc"" <S2SV_ModStart> ) ; } else { touch_file_as_user ( fname , u , g , 0644 <S2SV_ModEnd> ) ; fs_logger2 <S2SV_ModStart> fname ) ; <S2SV_ModEnd> } free ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> copy_file ( ""/etc/skel/.bashrc"" <S2SV_ModStart> , 0644 ) ; <S2SV_ModEnd> fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" <S2SV_ModStart> ) ; } <S2SV_ModEnd> free ( fname
"
521,"CWE-189 static int decode_getacl ( struct xdr_stream * xdr , struct rpc_rqst * req , <S2SV_StartBug> size_t * acl_len ) <S2SV_EndBug> { <S2SV_StartBug> __be32 * savep ; <S2SV_EndBug> uint32_t attrlen , bitmap [ 3 ] = { 0 } ; struct kvec * iov = req -> rq_rcv_buf . head ; int status ; <S2SV_StartBug> * acl_len = 0 ; <S2SV_EndBug> if ( ( status = decode_op_hdr ( xdr , OP_GETATTR ) ) != 0 ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( ( status = decode_attr_bitmap ( xdr , bitmap ) ) != 0 ) goto out ; if ( ( status = decode_attr_length ( xdr , & attrlen , & savep ) ) != 0 ) goto out ; if ( unlikely ( bitmap [ 0 ] & ( FATTR4_WORD0_ACL - 1U ) ) ) return - EIO ; if ( likely ( bitmap [ 0 ] & FATTR4_WORD0_ACL ) ) { size_t hdrlen ; u32 recvd ; <S2SV_StartBug> hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ; <S2SV_EndBug> recvd = req -> rq_rcv_buf . len - hdrlen ; if ( attrlen > recvd ) { <S2SV_StartBug> dprintk ( ""NFS:<S2SV_blank>server<S2SV_blank>cheating<S2SV_blank>in<S2SV_blank>getattr"" <S2SV_EndBug> ""<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\n"" , attrlen , recvd ) ; return - EINVAL ; } xdr_read_pages ( xdr , attrlen ) ; <S2SV_StartBug> * acl_len = attrlen ; <S2SV_EndBug> } else status = - EOPNOTSUPP ; out : return status ; }
","<S2SV_ModStart> * req , struct nfs_getaclres * res <S2SV_ModEnd> ) { __be32 <S2SV_ModStart> __be32 * savep , * bm_p <S2SV_ModStart> int status ; res -> <S2SV_ModEnd> acl_len = 0 <S2SV_ModStart> ) goto out ; bm_p = xdr -> p <S2SV_ModStart> u32 recvd ; xdr -> p = bm_p ; res -> acl_data_offset = be32_to_cpup ( bm_p ) + 2 ; res -> acl_data_offset <<= 2 ; <S2SV_ModStart> iov -> iov_base ; attrlen += res -> acl_data_offset <S2SV_ModStart> recvd ) { if ( res -> acl_flags & NFS4_ACL_LEN_REQUEST ) { res -> acl_len = attrlen ; goto out ; } dprintk ( ""NFS:<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\n"" <S2SV_ModEnd> , attrlen , <S2SV_ModStart> attrlen ) ; res -> <S2SV_ModEnd> acl_len = attrlen
"
522,"CWE-119 static int _FVMenuClose ( FontView * fv ) { int i ; SplineFont * sf = fv -> b . cidmaster ? fv -> b . cidmaster : fv -> b . sf ; if ( ! SFCloseAllInstrs ( fv -> b . sf ) ) return ( false ) ; <S2SV_StartBug> if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) { <S2SV_EndBug> } else if ( SFAnyChanged ( sf ) ) { i = AskChanged ( fv -> b . sf ) ; if ( i == 2 ) return ( false ) ; if ( i == 0 && ! _FVMenuSave ( fv ) ) return ( false ) ; else SFClearAutoSave ( sf ) ; } _FVCloseWindows ( fv ) ; if ( sf -> filename != NULL ) RecentFilesRemember ( sf -> filename ) ; else if ( sf -> origname != NULL ) RecentFilesRemember ( sf -> origname ) ; GDrawDestroyWindow ( fv -> gw ) ; return ( true ) ; }
","<S2SV_ModStart> b ) { } else if ( warn_script_unsaved && fv -> script_unsaved && AskScriptChanged ( ) == 2 ) { return false ;
"
523,"CWE-617 static void pci_populate_msixcap ( struct msixcap * msixcap , int msgnum , int barnum , uint32_t msix_tab_size ) { <S2SV_StartBug> assert ( msix_tab_size % 4096 == 0 ) ; <S2SV_EndBug> bzero ( msixcap , sizeof ( struct msixcap ) ) ; msixcap -> capid = PCIY_MSIX ; msixcap -> msgctrl = msgnum - 1 ; msixcap -> table_info = barnum & PCIM_MSIX_BIR_MASK ; msixcap -> pba_info = msix_tab_size | ( barnum & PCIM_MSIX_BIR_MASK ) ; }
","<S2SV_ModStart> msix_tab_size ) { <S2SV_ModEnd> bzero ( msixcap
"
524,"CWE-189 static int sgi_timer_set ( struct k_itimer * timr , int flags , struct itimerspec * new_setting , struct itimerspec * old_setting ) { unsigned long when , period , irqflags ; int err = 0 ; cnodeid_t nodeid ; struct mmtimer * base ; struct rb_node * n ; if ( old_setting ) sgi_timer_get ( timr , old_setting ) ; sgi_timer_del ( timr ) ; <S2SV_StartBug> when = timespec_to_ns ( new_setting -> it_value ) ; <S2SV_EndBug> <S2SV_StartBug> period = timespec_to_ns ( new_setting -> it_interval ) ; <S2SV_EndBug> if ( when == 0 ) return 0 ; base = kmalloc ( sizeof ( struct mmtimer ) , GFP_KERNEL ) ; if ( base == NULL ) return - ENOMEM ; if ( flags & TIMER_ABSTIME ) { struct timespec n ; unsigned long now ; getnstimeofday ( & n ) ; <S2SV_StartBug> now = timespec_to_ns ( n ) ; <S2SV_EndBug> if ( when > now ) when -= now ; else when = 0 ; } when = ( when + sgi_clock_period - 1 ) / sgi_clock_period + rtc_time ( ) ; period = ( period + sgi_clock_period - 1 ) / sgi_clock_period ; preempt_disable ( ) ; nodeid = cpu_to_node ( smp_processor_id ( ) ) ; spin_lock_irqsave ( & timers [ nodeid ] . lock , irqflags ) ; base -> timer = timr ; base -> cpu = smp_processor_id ( ) ; timr -> it . mmtimer . clock = TIMER_SET ; timr -> it . mmtimer . node = nodeid ; timr -> it . mmtimer . incr = period ; timr -> it . mmtimer . expires = when ; n = timers [ nodeid ] . next ; mmtimer_add_list ( base ) ; if ( timers [ nodeid ] . next == n ) { spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; preempt_enable ( ) ; return err ; } if ( n ) mmtimer_disable_int ( cnodeid_to_nasid ( nodeid ) , COMPARATOR ) ; mmtimer_set_next_timer ( nodeid ) ; spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; preempt_enable ( ) ; return err ; }
","<S2SV_ModStart> = timespec_to_ns ( & <S2SV_ModStart> = timespec_to_ns ( & <S2SV_ModStart> = timespec_to_ns ( &
"
525,"CWE-674 static void Sp_search ( js_State * J ) { js_Regexp * re ; const char * text ; Resub m ; text = checkstring ( J , 0 ) ; if ( js_isregexp ( J , 1 ) ) js_copy ( J , 1 ) ; else if ( js_isundefined ( J , 1 ) ) js_newregexp ( J , """" , 0 ) ; else js_newregexp ( J , js_tostring ( J , 1 ) , 0 ) ; re = js_toregexp ( J , - 1 ) ; <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , 0 ) ) <S2SV_EndBug> js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ; else js_pushnumber ( J , - 1 ) ; }
","<S2SV_ModStart> if ( ! js_doregexec ( J , <S2SV_ModEnd> re -> prog
"
526,"CWE-119 static void intern_rec ( value * dest ) { unsigned int code ; tag_t tag ; mlsize_t size , len , ofs_ind ; value v ; asize_t ofs ; header_t header ; unsigned char digest [ 16 ] ; struct custom_operations * ops ; char * codeptr ; struct intern_item * sp ; sp = intern_stack ; ReadItems ( dest , 1 ) ; while ( sp != intern_stack ) { dest = sp -> dest ; switch ( sp -> op ) { case OFreshOID : <S2SV_StartBug> if ( Int_val ( Field ( ( value ) dest , 1 ) ) >= 0 ) <S2SV_EndBug> caml_set_oo_id ( ( value ) dest ) ; sp -- ; break ; case OShift : * dest += sp -> arg ; sp -- ; break ; case OReadItems : sp -> dest ++ ; if ( -- ( sp -> arg ) == 0 ) sp -- ; code = read8u ( ) ; if ( code >= PREFIX_SMALL_INT ) { if ( code >= PREFIX_SMALL_BLOCK ) { tag = code & 0xF ; size = ( code >> 4 ) & 0x7 ; read_block : if ( size == 0 ) { v = Atom ( tag ) ; } else { v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , tag , intern_color ) ; intern_dest += 1 + size ; if ( tag == Object_tag ) { Assert ( size >= 2 ) ; ReadItems ( & Field ( v , 2 ) , size - 2 ) ; PushItem ( ) ; sp -> op = OFreshOID ; sp -> dest = ( value * ) v ; sp -> arg = 1 ; ReadItems ( & Field ( v , 0 ) , 2 ) ; } else ReadItems ( & Field ( v , 0 ) , size ) ; } } else { v = Val_int ( code & 0x3F ) ; } } else { if ( code >= PREFIX_SMALL_STRING ) { len = ( code & 0x1F ) ; read_string : size = ( len + sizeof ( value ) ) / sizeof ( value ) ; v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , String_tag , intern_color ) ; intern_dest += 1 + size ; Field ( v , size - 1 ) = 0 ; ofs_ind = Bsize_wsize ( size ) - 1 ; Byte ( v , ofs_ind ) = ofs_ind - len ; readblock ( String_val ( v ) , len ) ; } else { switch ( code ) { case CODE_INT8 : v = Val_long ( read8s ( ) ) ; break ; case CODE_INT16 : v = Val_long ( read16s ( ) ) ; break ; case CODE_INT32 : v = Val_long ( read32s ( ) ) ; break ; case CODE_INT64 : # ifdef ARCH_SIXTYFOUR v = Val_long ( read64s ( ) ) ; break ; # else intern_cleanup ( ) ; caml_failwith ( ""input_value:<S2SV_blank>integer<S2SV_blank>too<S2SV_blank>large"" ) ; break ; # endif case CODE_SHARED8 : ofs = read8u ( ) ; read_shared : Assert ( ofs > 0 ) ; Assert ( ofs <= obj_counter ) ; Assert ( intern_obj_table != NULL ) ; v = intern_obj_table [ obj_counter - ofs ] ; break ; case CODE_SHARED16 : ofs = read16u ( ) ; goto read_shared ; case CODE_SHARED32 : ofs = read32u ( ) ; goto read_shared ; case CODE_BLOCK32 : header = ( header_t ) read32u ( ) ; tag = Tag_hd ( header ) ; size = Wosize_hd ( header ) ; goto read_block ; case CODE_BLOCK64 : # ifdef ARCH_SIXTYFOUR header = ( header_t ) read64s ( ) ; tag = Tag_hd ( header ) ; size = Wosize_hd ( header ) ; goto read_block ; # else intern_cleanup ( ) ; caml_failwith ( ""input_value:<S2SV_blank>data<S2SV_blank>block<S2SV_blank>too<S2SV_blank>large"" ) ; break ; # endif case CODE_STRING8 : len = read8u ( ) ; goto read_string ; case CODE_STRING32 : len = read32u ( ) ; goto read_string ; case CODE_DOUBLE_LITTLE : case CODE_DOUBLE_BIG : v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( Double_wosize , Double_tag , intern_color ) ; intern_dest += 1 + Double_wosize ; readfloat ( ( double * ) v , code ) ; break ; case CODE_DOUBLE_ARRAY8_LITTLE : case CODE_DOUBLE_ARRAY8_BIG : len = read8u ( ) ; read_double_array : size = len * Double_wosize ; v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , Double_array_tag , intern_color ) ; intern_dest += 1 + size ; readfloats ( ( double * ) v , len , code ) ; break ; case CODE_DOUBLE_ARRAY32_LITTLE : case CODE_DOUBLE_ARRAY32_BIG : len = read32u ( ) ; goto read_double_array ; case CODE_CODEPOINTER : ofs = read32u ( ) ; readblock ( digest , 16 ) ; codeptr = intern_resolve_code_pointer ( digest , ofs ) ; if ( codeptr != NULL ) { v = ( value ) codeptr ; } else { value * function_placeholder = caml_named_value ( ""Debugger.function_placeholder"" ) ; if ( function_placeholder != NULL ) { v = * function_placeholder ; } else { intern_cleanup ( ) ; intern_bad_code_pointer ( digest ) ; } } break ; case CODE_INFIXPOINTER : ofs = read32u ( ) ; PushItem ( ) ; sp -> dest = dest ; sp -> op = OShift ; sp -> arg = ofs ; ReadItems ( dest , 1 ) ; continue ; case CODE_CUSTOM : ops = caml_find_custom_operations ( ( char * ) intern_src ) ; if ( ops == NULL ) { intern_cleanup ( ) ; caml_failwith ( ""input_value:<S2SV_blank>unknown<S2SV_blank>custom<S2SV_blank>block<S2SV_blank>identifier"" ) ; } while ( * intern_src ++ != 0 ) ; size = ops -> deserialize ( ( void * ) ( intern_dest + 2 ) ) ; size = 1 + ( size + sizeof ( value ) - 1 ) / sizeof ( value ) ; v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , Custom_tag , intern_color ) ; Custom_ops_val ( v ) = ops ; if ( ops -> finalize != NULL && Is_young ( v ) ) { if ( caml_finalize_table . ptr >= caml_finalize_table . limit ) { CAMLassert ( caml_finalize_table . ptr == caml_finalize_table . limit ) ; caml_realloc_ref_table ( & caml_finalize_table ) ; } * caml_finalize_table . ptr ++ = ( value * ) v ; } intern_dest += 1 + size ; break ; default : intern_cleanup ( ) ; caml_failwith ( ""input_value:<S2SV_blank>ill-formed<S2SV_blank>message"" ) ; } } } * dest = v ; break ; default : Assert ( 0 ) ; } } intern_free_stack ( ) ; }
","<S2SV_ModStart> : if ( Long_val <S2SV_ModEnd> ( Field (
"
527,"CWE-770 int server_partial_file_request ( struct httpd * env , struct client * clt , char * path , struct stat * st , char * range_str ) { struct server_config * srv_conf = clt -> clt_srv_conf ; struct http_descriptor * resp = clt -> clt_descresp ; struct http_descriptor * desc = clt -> clt_descreq ; struct media_type * media , multipart_media ; <S2SV_StartBug> struct range * range ; <S2SV_EndBug> struct evbuffer * evb = NULL ; <S2SV_StartBug> size_t content_length ; <S2SV_EndBug> <S2SV_StartBug> int code = 500 , fd = - 1 , i , nranges , ret ; <S2SV_EndBug> uint32_t boundary ; char content_range [ 64 ] ; const char * errstr = NULL ; if ( desc -> http_method != HTTP_METHOD_GET ) return server_file_request ( env , clt , path , st ) ; <S2SV_StartBug> if ( ( range = parse_range ( range_str , st -> st_size , & nranges ) ) == NULL ) { <S2SV_EndBug> code = 416 ; ( void ) snprintf ( content_range , sizeof ( content_range ) , ""bytes<S2SV_blank>*/%lld"" , st -> st_size ) ; errstr = content_range ; goto abort ; } if ( ( fd = open ( path , O_RDONLY ) ) == - 1 ) goto abort ; media = media_find_config ( env , srv_conf , path ) ; <S2SV_StartBug> if ( ( evb = evbuffer_new ( ) ) == NULL ) { <S2SV_EndBug> errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer"" ; goto abort ; } if ( nranges == 1 ) { <S2SV_StartBug> ( void ) snprintf ( content_range , sizeof ( content_range ) , <S2SV_EndBug> ""bytes<S2SV_blank>%lld-%lld/%lld"" , range -> start , range -> end , st -> st_size ) ; if ( kv_add ( & resp -> http_headers , ""Content-Range"" , content_range ) == NULL ) goto abort ; <S2SV_StartBug> content_length = range -> end - range -> start + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( buffer_add_range ( fd , evb , range ) == 0 ) <S2SV_EndBug> goto abort ; } else { <S2SV_StartBug> content_length = 0 ; <S2SV_EndBug> boundary = arc4random ( ) ; while ( nranges -- ) { if ( ( i = evbuffer_add_printf ( evb , ""\\r\\n--%ud\\r\\n"" , boundary ) ) == - 1 ) goto abort ; <S2SV_StartBug> content_length += i ; <S2SV_EndBug> if ( ( i = evbuffer_add_printf ( evb , ""Content-Type:<S2SV_blank>%s/%s\\r\\n"" , media -> media_type , media -> media_subtype ) ) == - 1 ) goto abort ; content_length += i ; if ( ( i = evbuffer_add_printf ( evb , ""Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\r\\n\\r\\n"" , range -> start , range -> end , st -> st_size ) ) == - 1 ) goto abort ; content_length += i ; if ( buffer_add_range ( fd , evb , range ) == 0 ) goto abort ; content_length += range -> end - range -> start + 1 ; <S2SV_StartBug> range ++ ; <S2SV_EndBug> } <S2SV_StartBug> if ( ( i = evbuffer_add_printf ( evb , ""\\r\\n--%ud--\\r\\n"" , <S2SV_EndBug> boundary ) ) == - 1 ) goto abort ; <S2SV_StartBug> content_length += i ; <S2SV_EndBug> ( void ) strlcpy ( multipart_media . media_type , ""multipart"" , sizeof ( multipart_media . media_type ) ) ; ( void ) snprintf ( multipart_media . media_subtype , sizeof ( multipart_media . media_subtype ) , <S2SV_StartBug> ""byteranges;<S2SV_blank>boundary=%ud"" , boundary ) ; <S2SV_EndBug> media = & multipart_media ; } <S2SV_StartBug> close ( fd ) ; <S2SV_EndBug> fd = - 1 ; ret = server_response_http ( clt , 206 , media , content_length , MINIMUM ( time ( NULL ) , st -> st_mtim . tv_sec ) ) ; switch ( ret ) { case - 1 : goto fail ; case 0 : <S2SV_StartBug> goto done ; <S2SV_EndBug> default : break ; } <S2SV_StartBug> if ( server_bufferevent_write_buffer ( clt , evb ) == - 1 ) <S2SV_EndBug> goto fail ; <S2SV_StartBug> bufferevent_enable ( clt -> clt_bev , EV_READ | EV_WRITE ) ; <S2SV_EndBug> <S2SV_StartBug> if ( clt -> clt_persist ) <S2SV_EndBug> clt -> clt_toread = TOREAD_HTTP_HEADER ; else clt -> clt_toread = TOREAD_HTTP_NONE ; clt -> clt_done = 0 ; done : evbuffer_free ( evb ) ; server_reset_http ( clt ) ; return ( 0 ) ; fail : bufferevent_disable ( clt -> clt_bev , EV_READ | EV_WRITE ) ; bufferevent_free ( clt -> clt_bev ) ; clt -> clt_bev = NULL ; abort : <S2SV_StartBug> if ( evb != NULL ) <S2SV_EndBug> evbuffer_free ( evb ) ; if ( fd != - 1 ) close ( fd ) ; if ( errstr == NULL ) errstr = strerror ( errno ) ; server_abort_http ( clt , code , errstr ) ; return ( - 1 ) ; }
","<S2SV_ModStart> multipart_media ; struct range_data * r = & clt -> clt_ranges ; struct range * range <S2SV_ModEnd> ; size_t content_length <S2SV_ModStart> ; size_t content_length = 0 <S2SV_ModStart> nranges , ret <S2SV_ModEnd> ; char content_range <S2SV_ModStart> if ( ( nranges = parse_ranges ( clt , <S2SV_ModEnd> range_str , st <S2SV_ModStart> st -> st_size ) ) < 1 <S2SV_ModEnd> ) { code <S2SV_ModStart> path ) ; r -> range_media = media ; <S2SV_ModEnd> if ( nranges <S2SV_ModStart> 1 ) { range = & r -> range [ 0 ] ; <S2SV_ModStart> goto abort ; range = & r -> range [ 0 ] ; content_length += <S2SV_ModEnd> range -> end <S2SV_ModStart> + 1 ; <S2SV_ModEnd> } else { <S2SV_ModStart> } else { arc4random_buf ( & clt -> clt_boundary , sizeof ( clt -> clt_boundary ) ) ; for ( i = 0 ; i < nranges ; i ++ ) { range = & r -> range [ i ] ; if ( ( ret = snprintf ( NULL , 0 , ""\\r\\n--%llu\\r\\n"" ""Content-Type:<S2SV_blank>%s/%s\\r\\n"" ""Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\r\\n\\r\\n"" , clt -> clt_boundary , media -> media_type , media -> media_subtype , range -> start , range -> end , st -> st_size ) ) < 0 <S2SV_ModEnd> ) goto abort <S2SV_ModStart> ; content_length += ret + <S2SV_ModEnd> range -> end <S2SV_ModStart> + 1 ; <S2SV_ModEnd> } if ( <S2SV_ModStart> if ( ( ret = snprintf ( NULL , 0 , ""\\r\\n--%llu--\\r\\n"" , clt -> clt_boundary ) ) < 0 <S2SV_ModEnd> ) goto abort <S2SV_ModStart> ; content_length += ret <S2SV_ModEnd> ; ( void <S2SV_ModStart> media_subtype ) , ""byteranges;<S2SV_blank>boundary=%llu"" , clt -> clt_boundary <S2SV_ModEnd> ) ; media <S2SV_ModStart> multipart_media ; } r -> range_toread = TOREAD_HTTP_RANGE <S2SV_ModEnd> ; ret = <S2SV_ModStart> case 0 : close ( fd ) ; <S2SV_ModStart> break ; } clt -> clt_fd = fd ; if ( clt -> clt_srvbev != NULL ) bufferevent_free ( clt -> clt_srvbev ) ; clt -> clt_srvbev_throttled = 0 ; clt -> clt_srvbev = bufferevent_new ( clt -> clt_fd , server_read_httprange , server_write , server_file_error , clt ) ; if ( clt -> clt_srvbev == NULL ) { errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer<S2SV_blank>event"" ; <S2SV_ModEnd> goto fail ; <S2SV_ModStart> goto fail ; } bufferevent_setwatermark ( clt -> clt_srvbev , EV_READ , 0 , clt -> clt_sndbufsiz ) ; bufferevent_settimeout ( clt -> clt_srvbev , srv_conf -> timeout . tv_sec , srv_conf -> timeout . tv_sec ) ; bufferevent_enable ( clt -> clt_srvbev , EV_READ ) ; bufferevent_disable ( clt -> clt_bev , EV_READ ) ; done : server_reset_http ( clt ) ; return ( 0 ) ; fail : bufferevent_disable <S2SV_ModEnd> ( clt -> <S2SV_ModStart> EV_WRITE ) ; <S2SV_ModEnd> bufferevent_free ( clt <S2SV_ModStart> ; abort : <S2SV_ModEnd> if ( fd
"
528,"CWE-20 bool_t ksz8851IrqHandler ( NetInterface * interface ) { bool_t flag ; size_t n ; uint16_t ier ; uint16_t isr ; flag = FALSE ; <S2SV_StartBug> ier = ksz8851ReadReg ( interface , KSZ8851_REG_IER ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_IER , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> isr = ksz8851ReadReg ( interface , KSZ8851_REG_ISR ) ; <S2SV_EndBug> if ( ( isr & ISR_LCIS ) != 0 ) { <S2SV_StartBug> ier &= ~ IER_LCIE ; <S2SV_EndBug> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } <S2SV_StartBug> if ( ( isr & ISR_TXIS ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_TXIS ) ; <S2SV_EndBug> <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ; <S2SV_EndBug> if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) { flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ; } } <S2SV_StartBug> if ( ( isr & ISR_RXIS ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> ier &= ~ IER_RXIE ; <S2SV_EndBug> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_IER , ier ) ; <S2SV_EndBug> return flag ; }
","<S2SV_ModStart> ( interface , KSZ8851_IER <S2SV_ModEnd> ) ; ksz8851WriteReg <S2SV_ModStart> ( interface , KSZ8851_IER <S2SV_ModEnd> , 0 ) <S2SV_ModStart> ( interface , KSZ8851_ISR ) ; if ( ( isr & KSZ8851_ISR_LCIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ier &= ~ KSZ8851_IER_LCIE <S2SV_ModEnd> ; interface -> <S2SV_ModStart> ( isr & KSZ8851_ISR_TXIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , KSZ8851_ISR , KSZ8851_ISR_TXIS <S2SV_ModEnd> ) ; n <S2SV_ModStart> ( interface , KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( isr & KSZ8851_ISR_RXIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ier &= ~ KSZ8851_IER_RXIE <S2SV_ModEnd> ; interface -> <S2SV_ModStart> ( interface , KSZ8851_IER <S2SV_ModEnd> , ier )
"
529,"CWE-119 <S2SV_StartBug> static void encode_quantization ( VP9_COMMON * cm , <S2SV_EndBug> <S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> base_qindex , QINDEX_BITS ) ; <S2SV_EndBug> write_delta_q ( wb , cm -> y_dc_delta_q ) ; write_delta_q ( wb , cm -> uv_dc_delta_q ) ; write_delta_q ( wb , cm -> uv_ac_delta_q ) ; }
","<S2SV_ModStart> void encode_quantization ( const VP9_COMMON * const <S2SV_ModEnd> cm , struct <S2SV_ModStart> cm , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) <S2SV_ModStart> wb ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb ,
"
530,"CWE-119 static int cdxl_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) { CDXLVideoContext * c = avctx -> priv_data ; AVFrame * const p = data ; int ret , w , h , encoding , aligned_width , buf_size = pkt -> size ; const uint8_t * buf = pkt -> data ; if ( buf_size < 32 ) return AVERROR_INVALIDDATA ; encoding = buf [ 1 ] & 7 ; c -> format = buf [ 1 ] & 0xE0 ; w = AV_RB16 ( & buf [ 14 ] ) ; h = AV_RB16 ( & buf [ 16 ] ) ; c -> bpp = buf [ 19 ] ; c -> palette_size = AV_RB16 ( & buf [ 20 ] ) ; c -> palette = buf + 32 ; c -> video = c -> palette + c -> palette_size ; c -> video_size = buf_size - c -> palette_size - 32 ; if ( c -> palette_size > 512 ) return AVERROR_INVALIDDATA ; if ( buf_size < c -> palette_size + 32 ) return AVERROR_INVALIDDATA ; if ( c -> bpp < 1 ) return AVERROR_INVALIDDATA ; if ( c -> format != BIT_PLANAR && c -> format != BIT_LINE && c -> format != CHUNKY ) { avpriv_request_sample ( avctx , ""Pixel<S2SV_blank>format<S2SV_blank>0x%0x"" , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_set_dimensions ( avctx , w , h ) ) < 0 ) return ret ; if ( c -> format == CHUNKY ) aligned_width = avctx -> width ; else aligned_width = FFALIGN ( c -> avctx -> width , 16 ) ; c -> padded_bits = aligned_width - c -> avctx -> width ; if ( c -> video_size < aligned_width * avctx -> height * ( int64_t ) c -> bpp / 8 ) return AVERROR_INVALIDDATA ; if ( ! encoding && c -> palette_size && c -> bpp <= 8 && c -> format != CHUNKY ) { avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; <S2SV_StartBug> } else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) { <S2SV_EndBug> if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ; avctx -> pix_fmt = AV_PIX_FMT_BGR24 ; } else if ( ! encoding && c -> bpp == 24 && c -> format == CHUNKY && ! c -> palette_size ) { avctx -> pix_fmt = AV_PIX_FMT_RGB24 ; } else { avpriv_request_sample ( avctx , ""Encoding<S2SV_blank>%d,<S2SV_blank>bpp<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>format<S2SV_blank>0x%x"" , encoding , c -> bpp , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) return ret ; p -> pict_type = AV_PICTURE_TYPE_I ; if ( encoding ) { av_fast_padded_malloc ( & c -> new_video , & c -> new_video_size , h * w + AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! c -> new_video ) return AVERROR ( ENOMEM ) ; if ( c -> bpp == 8 ) cdxl_decode_ham8 ( c , p ) ; else cdxl_decode_ham6 ( c , p ) ; } else if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) { cdxl_decode_rgb ( c , p ) ; } else { cdxl_decode_raw ( c , p ) ; } * got_frame = 1 ; return buf_size ; }
","<S2SV_ModStart> == 8 ) && c -> format != CHUNKY
"
531,"CWE-284 BOOLEAN UIPC_Send ( tUIPC_CH_ID ch_id , UINT16 msg_evt , UINT8 * p_buf , UINT16 msglen ) { UNUSED ( msg_evt ) ; BTIF_TRACE_DEBUG ( ""UIPC_Send<S2SV_blank>:<S2SV_blank>ch_id:%d<S2SV_blank>%d<S2SV_blank>bytes"" , ch_id , msglen ) ; UIPC_LOCK ( ) ; <S2SV_StartBug> if ( write ( uipc_main . ch [ ch_id ] . fd , p_buf , msglen ) < 0 ) <S2SV_EndBug> { BTIF_TRACE_ERROR ( ""failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>(%s)"" , strerror ( errno ) ) ; } UIPC_UNLOCK ( ) ; return FALSE ; }
","<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> p_buf , msglen )
"
532,"CWE-119 static const char * parse_scheme ( struct parse_state * state ) { size_t mb ; const char * tmp = state -> ptr ; do { switch ( * state -> ptr ) { case ':' : state -> url . scheme = & state -> buffer [ 0 ] ; state -> buffer [ state -> offset ++ ] = 0 ; return ++ state -> ptr ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : case '+' : case '-' : case '.' : if ( state -> ptr == tmp ) { <S2SV_StartBug> return tmp ; <S2SV_EndBug> } case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : case 'G' : case 'H' : case 'I' : case 'J' : case 'K' : case 'L' : case 'M' : case 'N' : case 'O' : case 'P' : case 'Q' : case 'R' : case 'S' : case 'T' : case 'U' : case 'V' : case 'W' : case 'X' : case 'Y' : case 'Z' : case 'a' : case 'b' : case 'c' : case 'd' : case 'e' : case 'f' : case 'g' : case 'h' : case 'i' : case 'j' : case 'k' : case 'l' : case 'm' : case 'n' : case 'o' : case 'p' : case 'q' : case 'r' : case 's' : case 't' : case 'u' : case 'v' : case 'w' : case 'x' : case 'y' : case 'z' : state -> buffer [ state -> offset ++ ] = * state -> ptr ; break ; default : if ( ! ( mb = parse_mb ( state , PARSE_SCHEME , state -> ptr , state -> end , tmp , 1 ) ) ) { <S2SV_StartBug> return tmp ; <S2SV_EndBug> } state -> ptr += mb - 1 ; } } while ( ++ state -> ptr != state -> end ) ; <S2SV_StartBug> return state -> ptr = tmp ; <S2SV_EndBug> }
","<S2SV_ModStart> tmp ) { goto softfail <S2SV_ModEnd> ; } case <S2SV_ModStart> ) ) { goto softfail <S2SV_ModEnd> ; } state <S2SV_ModStart> end ) ; softfail : state -> offset = 0 ;
"
533,"CWE-200 static int vivid_fb_ioctl ( struct fb_info * info , unsigned cmd , unsigned long arg ) { struct vivid_dev * dev = ( struct vivid_dev * ) info -> par ; switch ( cmd ) { case FBIOGET_VBLANK : { <S2SV_StartBug> struct fb_vblank vblank ; <S2SV_EndBug> vblank . flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT | FB_VBLANK_HAVE_VSYNC ; vblank . count = 0 ; vblank . vcount = 0 ; vblank . hcount = 0 ; if ( copy_to_user ( ( void __user * ) arg , & vblank , sizeof ( vblank ) ) ) return - EFAULT ; return 0 ; } default : dprintk ( dev , 1 , ""Unknown<S2SV_blank>ioctl<S2SV_blank>%08x\\n"" , cmd ) ; return - EINVAL ; } return 0 ; }
","<S2SV_ModStart> struct fb_vblank vblank ; memset ( & vblank , 0 , sizeof ( vblank ) )
"
534,"CWE-416 static void timerfd_setup_cancel ( struct timerfd_ctx * ctx , int flags ) <S2SV_StartBug> { <S2SV_EndBug> if ( ( ctx -> clockid == CLOCK_REALTIME || ctx -> clockid == CLOCK_REALTIME_ALARM ) && ( flags & TFD_TIMER_ABSTIME ) && ( flags & TFD_TIMER_CANCEL_ON_SET ) ) { if ( ! ctx -> might_cancel ) { ctx -> might_cancel = true ; spin_lock ( & cancel_lock ) ; list_add_rcu ( & ctx -> clist , & cancel_list ) ; spin_unlock ( & cancel_lock ) ; } <S2SV_StartBug> } else if ( ctx -> might_cancel ) { <S2SV_EndBug> timerfd_remove_cancel ( ctx ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> flags ) { spin_lock ( & ctx -> cancel_lock ) ; <S2SV_ModStart> } } else { __timerfd_remove_cancel <S2SV_ModEnd> ( ctx ) <S2SV_ModStart> ) ; } spin_unlock ( & ctx -> cancel_lock ) ;
"
535,"CWE-000 static Curves16Data * CurvesAlloc ( cmsContext ContextID , int nCurves , int nElements , cmsToneCurve * * G ) { int i , j ; Curves16Data * c16 ; c16 = _cmsMallocZero ( ContextID , sizeof ( Curves16Data ) ) ; if ( c16 == NULL ) return NULL ; c16 -> nCurves = nCurves ; c16 -> nElements = nElements ; c16 -> Curves = _cmsCalloc ( ContextID , nCurves , sizeof ( cmsUInt16Number * ) ) ; if ( c16 -> Curves == NULL ) return NULL ; for ( i = 0 ; i < nCurves ; i ++ ) { <S2SV_StartBug> c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ; <S2SV_EndBug> if ( nElements == 256 ) { for ( j = 0 ; j < nElements ; j ++ ) { c16 -> Curves [ i ] [ j ] = cmsEvalToneCurve16 ( G [ i ] , FROM_8_TO_16 ( j ) ) ; } } else { for ( j = 0 ; j < nElements ; j ++ ) { c16 -> Curves [ i ] [ j ] = cmsEvalToneCurve16 ( G [ i ] , ( cmsUInt16Number ) j ) ; } } } return c16 ; }
","<S2SV_ModStart> ) ) ; if ( c16 -> Curves [ i ] == NULL ) { for ( j = 0 ; j < i ; j ++ ) { _cmsFree ( ContextID , c16 -> Curves [ j ] ) ; } _cmsFree ( ContextID , c16 -> Curves ) ; _cmsFree ( ContextID , c16 ) ; return NULL ; }
"
536,"CWE-20 static int tomoyo_mount_acl ( struct tomoyo_request_info * r , char * dev_name , struct path * dir , char * type , unsigned long flags ) { struct path path ; struct file_system_type * fstype = NULL ; const char * requested_type = NULL ; const char * requested_dir_name = NULL ; const char * requested_dev_name = NULL ; struct tomoyo_path_info rtype ; struct tomoyo_path_info rdev ; struct tomoyo_path_info rdir ; int need_dev = 0 ; int error = - ENOMEM ; requested_type = tomoyo_encode ( type ) ; if ( ! requested_type ) goto out ; rtype . name = requested_type ; tomoyo_fill_path_info ( & rtype ) ; requested_dir_name = tomoyo_realpath_from_path ( dir ) ; if ( ! requested_dir_name ) { error = - ENOMEM ; goto out ; } rdir . name = requested_dir_name ; tomoyo_fill_path_info ( & rdir ) ; if ( ! strcmp ( type , TOMOYO_MOUNT_REMOUNT_KEYWORD ) ) { } else if ( ! strcmp ( type , TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SHARED_KEYWORD ) ) { } else if ( ! strcmp ( type , TOMOYO_MOUNT_BIND_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MOVE_KEYWORD ) ) { need_dev = - 1 ; } else { fstype = get_fs_type ( type ) ; if ( ! fstype ) { error = - ENODEV ; goto out ; } if ( fstype -> fs_flags & FS_REQUIRES_DEV ) need_dev = 1 ; } if ( need_dev ) { <S2SV_StartBug> if ( kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) { <S2SV_EndBug> error = - ENOENT ; goto out ; } requested_dev_name = tomoyo_realpath_from_path ( & path ) ; path_put ( & path ) ; if ( ! requested_dev_name ) { error = - ENOENT ; goto out ; } } else { if ( ! dev_name ) dev_name = ""<NULL>"" ; requested_dev_name = tomoyo_encode ( dev_name ) ; if ( ! requested_dev_name ) { error = - ENOMEM ; goto out ; } } rdev . name = requested_dev_name ; tomoyo_fill_path_info ( & rdev ) ; r -> param_type = TOMOYO_TYPE_MOUNT_ACL ; r -> param . mount . need_dev = need_dev ; r -> param . mount . dev = & rdev ; r -> param . mount . dir = & rdir ; r -> param . mount . type = & rtype ; r -> param . mount . flags = flags ; do { tomoyo_check_acl ( r , tomoyo_check_mount_acl ) ; error = tomoyo_audit_mount_log ( r ) ; } while ( error == TOMOYO_RETRY_REQUEST ) ; out : kfree ( requested_dev_name ) ; kfree ( requested_dir_name ) ; if ( fstype ) put_filesystem ( fstype ) ; kfree ( requested_type ) ; return error ; }
","<S2SV_ModStart> { if ( ! dev_name ||
"
537,"CWE-125 int ethertype_print ( netdissect_options * ndo , u_short ether_type , const u_char * p , u_int length , u_int caplen , const struct lladdr_info * src , const struct lladdr_info * dst ) { switch ( ether_type ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ARP : case ETHERTYPE_REVARP : arp_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_DN : decnet_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_ATALK : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""et1<S2SV_blank>"" ) ) ; atalk_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_AARP : aarp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPX : ND_PRINT ( ( ndo , ""(NOV-ETHII)<S2SV_blank>"" ) ) ; ipx_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ISO : if ( length == 0 || caplen == 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|osi]"" ) ) ; return ( 1 ) ; } <S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <S2SV_EndBug> return ( 1 ) ; case ETHERTYPE_PPPOED : case ETHERTYPE_PPPOES : case ETHERTYPE_PPPOED2 : case ETHERTYPE_PPPOES2 : pppoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_EAPOL : eap_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_RRCP : rrcp_print ( ndo , p , length , src , dst ) ; return ( 1 ) ; case ETHERTYPE_PPP : if ( length ) { ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; ppp_print ( ndo , p , length ) ; } return ( 1 ) ; case ETHERTYPE_MPCP : mpcp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_SLOW : slow_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_CFM : case ETHERTYPE_CFM_OLD : cfm_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_LLDP : lldp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_NSH : nsh_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_LOOPBACK : loopback_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_MPLS : case ETHERTYPE_MPLS_MULTI : mpls_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_TIPC : tipc_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_MS_NLB_HB : msnlb_print ( ndo , p ) ; return ( 1 ) ; case ETHERTYPE_GEONET_OLD : case ETHERTYPE_GEONET : geonet_print ( ndo , p , length , src ) ; return ( 1 ) ; case ETHERTYPE_CALM_FAST : calm_fast_print ( ndo , p , length , src ) ; return ( 1 ) ; case ETHERTYPE_AOE : aoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_MEDSA : medsa_print ( ndo , p , length , caplen , src , dst ) ; return ( 1 ) ; case ETHERTYPE_LAT : case ETHERTYPE_SCA : case ETHERTYPE_MOPRC : case ETHERTYPE_MOPDL : case ETHERTYPE_IEEE1905_1 : default : return ( 0 ) ; } }
","<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; return
"
538,"CWE-125 int saa7164_bus_get ( struct saa7164_dev * dev , struct tmComResInfo * msg , void * buf , int peekonly ) { struct tmComResBusInfo * bus = & dev -> bus ; u32 bytes_to_read , write_distance , curr_grp , curr_gwp , new_grp , buf_size , space_rem ; struct tmComResInfo msg_tmp ; int ret = SAA_ERR_BAD_PARAMETER ; saa7164_bus_verify ( dev ) ; if ( msg == NULL ) return ret ; if ( msg -> size > dev -> bus . m_wMaxReqSize ) { printk ( KERN_ERR ""%s()<S2SV_blank>Exceeded<S2SV_blank>dev->bus.m_wMaxReqSize\\n"" , __func__ ) ; return ret ; } if ( ( peekonly == 0 ) && ( msg -> size > 0 ) && ( buf == NULL ) ) { printk ( KERN_ERR ""%s()<S2SV_blank>Missing<S2SV_blank>msg<S2SV_blank>buf,<S2SV_blank>size<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes\\n"" , __func__ , msg -> size ) ; return ret ; } mutex_lock ( & bus -> lock ) ; curr_gwp = saa7164_readl ( bus -> m_dwGetWritePos ) ; curr_grp = saa7164_readl ( bus -> m_dwGetReadPos ) ; if ( curr_gwp == curr_grp ) { ret = SAA_ERR_EMPTY ; goto out ; } bytes_to_read = sizeof ( * msg ) ; write_distance = 0 ; if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ; else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ; if ( bytes_to_read > write_distance ) { printk ( KERN_ERR ""%s()<S2SV_blank>No<S2SV_blank>message/response<S2SV_blank>found\\n"" , __func__ ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } new_grp = curr_grp + bytes_to_read ; if ( new_grp > bus -> m_dwSizeGetRing ) { new_grp -= bus -> m_dwSizeGetRing ; space_rem = bus -> m_dwSizeGetRing - curr_grp ; memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , space_rem ) ; memcpy_fromio ( ( u8 * ) & msg_tmp + space_rem , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } else { memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , bytes_to_read ) ; } msg_tmp . size = le16_to_cpu ( ( __force __le16 ) msg_tmp . size ) ; msg_tmp . command = le32_to_cpu ( ( __force __le32 ) msg_tmp . command ) ; msg_tmp . controlselector = le16_to_cpu ( ( __force __le16 ) msg_tmp . controlselector ) ; <S2SV_StartBug> if ( peekonly ) { <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <S2SV_EndBug> goto peekout ; } if ( ( msg_tmp . id != msg -> id ) || ( msg_tmp . command != msg -> command ) || ( msg_tmp . controlselector != msg -> controlselector ) || ( msg_tmp . seqno != msg -> seqno ) || ( msg_tmp . size != msg -> size ) ) { printk ( KERN_ERR ""%s()<S2SV_blank>Unexpected<S2SV_blank>msg<S2SV_blank>miss-match\\n"" , __func__ ) ; saa7164_bus_dumpmsg ( dev , msg , buf ) ; saa7164_bus_dumpmsg ( dev , & msg_tmp , NULL ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } buf_size = msg -> size ; bytes_to_read = sizeof ( * msg ) + msg -> size ; write_distance = 0 ; if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ; else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ; if ( bytes_to_read > write_distance ) { printk ( KERN_ERR ""%s()<S2SV_blank>Invalid<S2SV_blank>bus<S2SV_blank>state,<S2SV_blank>missing<S2SV_blank>msg<S2SV_blank>or<S2SV_blank>mangled<S2SV_blank>ring,<S2SV_blank>faulty<S2SV_blank>H/W<S2SV_blank>/<S2SV_blank>bad<S2SV_blank>code?\\n"" , __func__ ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } new_grp = curr_grp + bytes_to_read ; if ( new_grp > bus -> m_dwSizeGetRing ) { new_grp -= bus -> m_dwSizeGetRing ; space_rem = bus -> m_dwSizeGetRing - curr_grp ; if ( space_rem < sizeof ( * msg ) ) { <S2SV_StartBug> memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , space_rem ) ; <S2SV_EndBug> memcpy_fromio ( ( u8 * ) msg + space_rem , bus -> m_pdwGetRing , <S2SV_StartBug> sizeof ( * msg ) - space_rem ) ; <S2SV_EndBug> if ( buf ) <S2SV_StartBug> memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) - <S2SV_EndBug> space_rem , buf_size ) ; <S2SV_StartBug> } else if ( space_rem == sizeof ( * msg ) ) { <S2SV_EndBug> memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing , buf_size ) ; } else { memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) { memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , buf_size ) ; } msg -> size = le16_to_cpu ( ( __force __le16 ) msg -> size ) ; msg -> command = le32_to_cpu ( ( __force __le32 ) msg -> command ) ; msg -> controlselector = le16_to_cpu ( ( __force __le16 ) msg -> controlselector ) ; saa7164_writel ( bus -> m_dwGetReadPos , new_grp ) ; peekout : ret = SAA_OK ; out : mutex_unlock ( & bus -> lock ) ; saa7164_bus_verify ( dev ) ; return ret ; }
","<S2SV_ModStart> controlselector ) ; memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <S2SV_ModStart> peekonly ) { <S2SV_ModEnd> goto peekout ; <S2SV_ModStart> ) ) { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd> , bus -> <S2SV_ModStart> -> m_pdwGetRing + sizeof ( * msg ) - space_rem , buf_size ) ; } else if ( space_rem == sizeof ( * msg ) ) { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd> , bus -> <S2SV_ModStart> -> m_pdwGetRing , buf_size ) ; } else { if ( buf ) { <S2SV_ModEnd> memcpy_fromio ( buf <S2SV_ModStart> -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , <S2SV_ModEnd> buf_size ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> saa7164_writel ( bus
"
539,"CWE-190 static void php_html_entities ( INTERNAL_FUNCTION_PARAMETERS , int all ) { char * str , * hint_charset = NULL ; int str_len , hint_charset_len = 0 ; size_t new_len ; long flags = ENT_COMPAT ; char * replaced ; zend_bool double_encode = 1 ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""s|ls!b"" , & str , & str_len , & flags , & hint_charset , & hint_charset_len , & double_encode ) == FAILURE ) { return ; } replaced = php_escape_html_entities_ex ( str , str_len , & new_len , all , ( int ) flags , hint_charset , double_encode TSRMLS_CC ) ; <S2SV_StartBug> RETVAL_STRINGL ( replaced , ( int ) new_len , 0 ) ; <S2SV_EndBug> }
","<S2SV_ModStart> TSRMLS_CC ) ; if ( new_len > INT_MAX ) { efree ( replaced ) ; RETURN_FALSE ; }
"
540,"CWE-639 int ca_validate_pubkey ( struct iked * env , struct iked_static_id * id , void * data , size_t len , struct iked_id * out ) { BIO * rawcert = NULL ; RSA * peerrsa = NULL , * localrsa = NULL ; EC_KEY * peerec = NULL ; EVP_PKEY * peerkey = NULL , * localkey = NULL ; int ret = - 1 ; FILE * fp = NULL ; char idstr [ IKED_ID_SIZE ] ; char file [ PATH_MAX ] ; struct iked_id idp ; switch ( id -> id_type ) { case IKEV2_ID_IPV4 : case IKEV2_ID_FQDN : case IKEV2_ID_UFQDN : case IKEV2_ID_IPV6 : break ; default : log_debug ( ""%s:<S2SV_blank>unsupported<S2SV_blank>public<S2SV_blank>key<S2SV_blank>type<S2SV_blank>%s"" , __func__ , print_map ( id -> id_type , ikev2_id_map ) ) ; return ( - 1 ) ; } bzero ( & idp , sizeof ( idp ) ) ; if ( ( idp . id_buf = ibuf_new ( id -> id_data , id -> id_length ) ) == NULL ) goto done ; idp . id_type = id -> id_type ; idp . id_offset = id -> id_offset ; if ( ikev2_print_id ( & idp , idstr , sizeof ( idstr ) ) == - 1 ) goto done ; if ( len == 0 && data ) { peerkey = ( EVP_PKEY * ) data ; } if ( len > 0 ) { if ( ( rawcert = BIO_new_mem_buf ( data , len ) ) == NULL ) goto done ; if ( ( peerkey = EVP_PKEY_new ( ) ) == NULL ) goto sslerr ; if ( ( peerrsa = d2i_RSAPublicKey_bio ( rawcert , NULL ) ) ) { if ( ! EVP_PKEY_set1_RSA ( peerkey , peerrsa ) ) { goto sslerr ; } } else if ( BIO_reset ( rawcert ) == 1 && ( peerec = d2i_EC_PUBKEY_bio ( rawcert , NULL ) ) ) { if ( ! EVP_PKEY_set1_EC_KEY ( peerkey , peerec ) ) { goto sslerr ; } } else { log_debug ( ""%s:<S2SV_blank>unknown<S2SV_blank>key<S2SV_blank>type<S2SV_blank>received"" , __func__ ) ; goto sslerr ; } } lc_idtype ( idstr ) ; if ( strlcpy ( file , IKED_PUBKEY_DIR , sizeof ( file ) ) >= sizeof ( file ) || strlcat ( file , idstr , sizeof ( file ) ) >= sizeof ( file ) ) { log_debug ( ""%s:<S2SV_blank>public<S2SV_blank>key<S2SV_blank>id<S2SV_blank>too<S2SV_blank>long<S2SV_blank>%s"" , __func__ , idstr ) ; goto done ; } if ( ( fp = fopen ( file , ""r"" ) ) == NULL ) { logit ( len == 0 ? LOG_DEBUG : LOG_INFO , ""%s:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>public<S2SV_blank>key<S2SV_blank>%s"" , __func__ , file ) ; goto done ; } localkey = PEM_read_PUBKEY ( fp , NULL , NULL , NULL ) ; if ( localkey == NULL ) { rewind ( fp ) ; localrsa = PEM_read_RSAPublicKey ( fp , NULL , NULL , NULL ) ; fclose ( fp ) ; if ( localrsa == NULL ) goto sslerr ; if ( ( localkey = EVP_PKEY_new ( ) ) == NULL ) goto sslerr ; if ( ! EVP_PKEY_set1_RSA ( localkey , localrsa ) ) goto sslerr ; } else { fclose ( fp ) ; } if ( localkey == NULL ) goto sslerr ; <S2SV_StartBug> if ( peerkey && ! EVP_PKEY_cmp ( peerkey , localkey ) ) { <S2SV_EndBug> log_debug ( ""%s:<S2SV_blank>public<S2SV_blank>key<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>%s"" , __func__ , file ) ; goto done ; } log_debug ( ""%s:<S2SV_blank>valid<S2SV_blank>public<S2SV_blank>key<S2SV_blank>in<S2SV_blank>file<S2SV_blank>%s"" , __func__ , file ) ; if ( out && ca_pubkey_serialize ( localkey , out ) ) goto done ; ret = 0 ; sslerr : if ( ret != 0 ) ca_sslerror ( __func__ ) ; done : ibuf_release ( idp . id_buf ) ; if ( localkey != NULL ) EVP_PKEY_free ( localkey ) ; if ( peerrsa != NULL ) RSA_free ( peerrsa ) ; if ( peerec != NULL ) EC_KEY_free ( peerec ) ; if ( localrsa != NULL ) RSA_free ( localrsa ) ; if ( rawcert != NULL ) { BIO_free ( rawcert ) ; if ( peerkey != NULL ) EVP_PKEY_free ( peerkey ) ; } return ( ret ) ; }
","<S2SV_ModStart> ( peerkey && <S2SV_ModEnd> EVP_PKEY_cmp ( peerkey <S2SV_ModStart> , localkey ) != 1
"
541,"CWE-119 static void t1_check_unusual_charstring ( void ) { char * p = strstr ( t1_line_array , charstringname ) + strlen ( charstringname ) ; int i ; if ( sscanf ( p , ""%i"" , & i ) != 1 ) { strcpy ( t1_buf_array , t1_line_array ) ; t1_getline ( ) ; <S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> strcpy ( t1_line_array , t1_buf_array ) ; t1_line_ptr = eol ( t1_line_array ) ; } }
","<S2SV_ModStart> ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE
"
542,"CWE-119 static void fill_mode_info_sb ( VP9_COMMON * cm , MACROBLOCK * x , int mi_row , int mi_col , <S2SV_StartBug> BLOCK_SIZE bsize , BLOCK_SIZE subsize ) { <S2SV_EndBug> MACROBLOCKD * xd = & x -> e_mbd ; <S2SV_StartBug> int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; <S2SV_EndBug> <S2SV_StartBug> PARTITION_TYPE partition = partition_lookup [ bsl ] [ subsize ] ; <S2SV_EndBug> assert ( bsize >= BLOCK_8X8 ) ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; switch ( partition ) { case PARTITION_NONE : <S2SV_StartBug> set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; <S2SV_EndBug> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; break ; case PARTITION_VERT : <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ; <S2SV_StartBug> * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; <S2SV_EndBug> <S2SV_StartBug> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; <S2SV_EndBug> if ( mi_col + hbs < cm -> mi_cols ) { <S2SV_StartBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_EndBug> set_modeinfo_offsets ( cm , xd , mi_row , mi_col + hbs ) ; * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; <S2SV_StartBug> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col + hbs , bsize ) ; <S2SV_EndBug> } break ; case PARTITION_HORZ : <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ; <S2SV_StartBug> * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; <S2SV_EndBug> <S2SV_StartBug> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; <S2SV_EndBug> if ( mi_row + hbs < cm -> mi_rows ) { <S2SV_StartBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_EndBug> set_modeinfo_offsets ( cm , xd , mi_row + hbs , mi_col ) ; * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; <S2SV_StartBug> duplicate_mode_info_in_sb ( cm , xd , mi_row + hbs , mi_col , bsize ) ; <S2SV_EndBug> } break ; case PARTITION_SPLIT : <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> fill_mode_info_sb ( cm , x , mi_row , mi_col , subsize , <S2SV_StartBug> * ( get_sb_partitioning ( x , subsize ) ) ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_StartBug> fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize , <S2SV_EndBug> * ( get_sb_partitioning ( x , subsize ) ) ) ; * get_sb_index ( x , subsize ) = 2 ; <S2SV_StartBug> fill_mode_info_sb ( cm , x , mi_row + hbs , mi_col , subsize , <S2SV_EndBug> * ( get_sb_partitioning ( x , subsize ) ) ) ; * get_sb_index ( x , subsize ) = 3 ; fill_mode_info_sb ( cm , x , mi_row + hbs , mi_col + hbs , subsize , * ( get_sb_partitioning ( x , subsize ) ) ) ; <S2SV_StartBug> break ; <S2SV_EndBug> default : break ; } }
","<S2SV_ModStart> BLOCK_SIZE bsize , PC_TREE * pc_tree <S2SV_ModEnd> ) { MACROBLOCKD <S2SV_ModStart> int bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> , hbs = <S2SV_ModStart> PARTITION_TYPE partition = pc_tree -> partitioning ; BLOCK_SIZE subsize = get_subsize ( bsize , partition ) <S2SV_ModEnd> ; assert ( <S2SV_ModStart> case PARTITION_NONE : set_mode_info_offsets ( cm , x <S2SV_ModEnd> , xd , <S2SV_ModStart> ] ) = pc_tree -> none . mic ; * ( x -> mbmi_ext ) = pc_tree -> none . mbmi_ext <S2SV_ModEnd> ; duplicate_mode_info_in_sb ( <S2SV_ModStart> case PARTITION_VERT : set_mode_info_offsets ( cm , x <S2SV_ModEnd> , xd , <S2SV_ModStart> ] ) = pc_tree -> vertical [ 0 ] . mic ; * ( x -> mbmi_ext ) = pc_tree -> vertical [ 0 ] . mbmi_ext ; <S2SV_ModEnd> duplicate_mode_info_in_sb ( cm <S2SV_ModStart> , mi_col , subsize <S2SV_ModEnd> ) ; if <S2SV_ModStart> mi_cols ) { set_mode_info_offsets ( cm , x , xd , mi_row , mi_col + hbs ) ; * ( xd -> mi [ 0 ] ) = pc_tree -> vertical [ 1 ] . mic ; * ( x -> mbmi_ext ) = pc_tree -> vertical [ 1 ] . mbmi_ext ; <S2SV_ModEnd> duplicate_mode_info_in_sb ( cm <S2SV_ModStart> + hbs , subsize <S2SV_ModEnd> ) ; } <S2SV_ModStart> case PARTITION_HORZ : set_mode_info_offsets ( cm , x <S2SV_ModEnd> , xd , <S2SV_ModStart> ] ) = pc_tree -> horizontal [ 0 ] . mic ; * ( x -> mbmi_ext ) = pc_tree -> horizontal [ 0 ] . mbmi_ext ; <S2SV_ModEnd> duplicate_mode_info_in_sb ( cm <S2SV_ModStart> , mi_col , subsize <S2SV_ModEnd> ) ; if <S2SV_ModStart> mi_rows ) { set_mode_info_offsets ( cm , x , xd , mi_row + hbs , mi_col ) ; * ( xd -> mi [ 0 ] ) = pc_tree -> horizontal [ 1 ] . mic ; * ( x -> mbmi_ext ) = pc_tree -> horizontal [ 1 ] . mbmi_ext ; <S2SV_ModEnd> duplicate_mode_info_in_sb ( cm <S2SV_ModStart> , mi_col , subsize <S2SV_ModEnd> ) ; } <S2SV_ModStart> case PARTITION_SPLIT : { <S2SV_ModEnd> fill_mode_info_sb ( cm <S2SV_ModStart> , subsize , pc_tree -> split [ 0 ] ) ; fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize , pc_tree -> split [ 1 ] ) <S2SV_ModEnd> ; fill_mode_info_sb ( <S2SV_ModStart> x , mi_row + hbs , mi_col , subsize , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> ; fill_mode_info_sb ( <S2SV_ModStart> hbs , mi_col + hbs , subsize , pc_tree -> split [ 3 ] <S2SV_ModEnd> ) ; break <S2SV_ModStart> ; break ; }
"
543,"CWE-20 static int fsck_gitmodules_fn ( const char * var , const char * value , void * vdata ) { struct fsck_gitmodules_data * data = vdata ; const char * subsection , * key ; int subsection_len ; char * name ; if ( parse_config_key ( var , ""submodule"" , & subsection , & subsection_len , & key ) < 0 || ! subsection ) return 0 ; name = xmemdupz ( subsection , subsection_len ) ; if ( check_submodule_name ( name ) < 0 ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_NAME , ""disallowed<S2SV_blank>submodule<S2SV_blank>name:<S2SV_blank>%s"" , name ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> name ) ; if ( ! strcmp ( key , ""url"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , ""disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s"" , value ) ;
"
544,"CWE-119 static void rpza_decode_stream ( RpzaContext * s ) { int width = s -> avctx -> width ; int stride = s -> frame . linesize [ 0 ] / 2 ; int row_inc = stride - 4 ; int stream_ptr = 0 ; int chunk_size ; unsigned char opcode ; int n_blocks ; unsigned short colorA = 0 , colorB ; unsigned short color4 [ 4 ] ; unsigned char index , idx ; unsigned short ta , tb ; unsigned short * pixels = ( unsigned short * ) s -> frame . data [ 0 ] ; int row_ptr = 0 ; <S2SV_StartBug> int pixel_ptr = 0 ; <S2SV_EndBug> int block_ptr ; int pixel_x , pixel_y ; int total_blocks ; if ( s -> buf [ stream_ptr ] != 0xe1 ) av_log ( s -> avctx , AV_LOG_ERROR , ""First<S2SV_blank>chunk<S2SV_blank>byte<S2SV_blank>is<S2SV_blank>0x%02x<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>0xe1\\n"" , s -> buf [ stream_ptr ] ) ; chunk_size = AV_RB32 ( & s -> buf [ stream_ptr ] ) & 0x00FFFFFF ; stream_ptr += 4 ; if ( chunk_size != s -> size ) av_log ( s -> avctx , AV_LOG_ERROR , ""MOV<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>!=<S2SV_blank>encoded<S2SV_blank>chunk<S2SV_blank>size;<S2SV_blank>using<S2SV_blank>MOV<S2SV_blank>chunk<S2SV_blank>size\\n"" ) ; chunk_size = s -> size ; total_blocks = ( ( s -> avctx -> width + 3 ) / 4 ) * ( ( s -> avctx -> height + 3 ) / 4 ) ; while ( stream_ptr < chunk_size ) { opcode = s -> buf [ stream_ptr ++ ] ; n_blocks = ( opcode & 0x1f ) + 1 ; if ( ( opcode & 0x80 ) == 0 ) { colorA = ( opcode << 8 ) | ( s -> buf [ stream_ptr ++ ] ) ; opcode = 0 ; if ( ( s -> buf [ stream_ptr ] & 0x80 ) != 0 ) { opcode = 0x20 ; n_blocks = 1 ; } } switch ( opcode & 0xe0 ) { case 0x80 : while ( n_blocks -- ) { ADVANCE_BLOCK ( ) ; } break ; case 0xa0 : colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; while ( n_blocks -- ) { <S2SV_StartBug> block_ptr = row_ptr + pixel_ptr ; <S2SV_EndBug> for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { pixels [ block_ptr ] = colorA ; block_ptr ++ ; } block_ptr += row_inc ; } <S2SV_StartBug> ADVANCE_BLOCK ( ) ; <S2SV_EndBug> } break ; case 0xc0 : colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; case 0x20 : colorB = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; color4 [ 0 ] = colorB ; color4 [ 1 ] = 0 ; color4 [ 2 ] = 0 ; color4 [ 3 ] = colorA ; ta = ( colorA >> 10 ) & 0x1F ; tb = ( colorB >> 10 ) & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 10 ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 10 ; ta = ( colorA >> 5 ) & 0x1F ; tb = ( colorB >> 5 ) & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 5 ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 5 ; ta = colorA & 0x1F ; tb = colorB & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) ; if ( s -> size - stream_ptr < n_blocks * 4 ) return ; while ( n_blocks -- ) { <S2SV_StartBug> block_ptr = row_ptr + pixel_ptr ; <S2SV_EndBug> for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { index = s -> buf [ stream_ptr ++ ] ; for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { idx = ( index >> ( 2 * ( 3 - pixel_x ) ) ) & 0x03 ; pixels [ block_ptr ] = color4 [ idx ] ; block_ptr ++ ; } block_ptr += row_inc ; } <S2SV_StartBug> ADVANCE_BLOCK ( ) ; <S2SV_EndBug> } break ; case 0x00 : if ( s -> size - stream_ptr < 16 ) return ; <S2SV_StartBug> block_ptr = row_ptr + pixel_ptr ; <S2SV_EndBug> for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { if ( ( pixel_y != 0 ) || ( pixel_x != 0 ) ) { colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; } pixels [ block_ptr ] = colorA ; block_ptr ++ ; } block_ptr += row_inc ; } <S2SV_StartBug> ADVANCE_BLOCK ( ) ; <S2SV_EndBug> break ; default : av_log ( s -> avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>opcode<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>rpza<S2SV_blank>chunk."" ""<S2SV_blank>Skip<S2SV_blank>remaining<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>chunk<S2SV_blank>data.\\n"" , opcode , chunk_size - stream_ptr ) ; return ; } } }
","<S2SV_ModStart> int pixel_ptr = - 4 <S2SV_ModEnd> ; int block_ptr <S2SV_ModStart> -- ) { ADVANCE_BLOCK ( ) <S2SV_ModStart> row_inc ; } <S2SV_ModEnd> } break ; <S2SV_ModStart> -- ) { ADVANCE_BLOCK ( ) ; <S2SV_ModStart> row_inc ; } <S2SV_ModEnd> } break ; <S2SV_ModStart> ) return ; ADVANCE_BLOCK ( ) ; <S2SV_ModStart> row_inc ; } <S2SV_ModEnd> break ; default
"
545,"CWE-190 static int mem_read ( jas_stream_obj_t * obj , char * buf , int cnt ) { <S2SV_StartBug> int n ; <S2SV_EndBug> assert ( cnt >= 0 ) ; assert ( buf ) ; JAS_DBGLOG ( 100 , ( ""mem_read(%p,<S2SV_blank>%p,<S2SV_blank>%d)\\n"" , obj , buf , cnt ) ) ; jas_stream_memobj_t * m = ( jas_stream_memobj_t * ) obj ; n = m -> len_ - m -> pos_ ; cnt = JAS_MIN ( n , cnt ) ; memcpy ( buf , & m -> buf_ [ m -> pos_ ] , cnt ) ; m -> pos_ += cnt ; return cnt ; }
","<S2SV_ModStart> cnt ) { ssize_t <S2SV_ModEnd> n ; assert
"
546,"CWE-400 static struct sk_buff * * gre_gro_receive ( struct sk_buff * * head , struct sk_buff * skb ) { struct sk_buff * * pp = NULL ; struct sk_buff * p ; const struct gre_base_hdr * greh ; unsigned int hlen , grehlen ; unsigned int off ; int flush = 1 ; struct packet_offload * ptype ; <S2SV_StartBug> __be16 type ; <S2SV_EndBug> off = skb_gro_offset ( skb ) ; hlen = off + sizeof ( * greh ) ; greh = skb_gro_header_fast ( skb , off ) ; if ( skb_gro_header_hard ( skb , hlen ) ) { greh = skb_gro_header_slow ( skb , hlen , off ) ; if ( unlikely ( ! greh ) ) goto out ; } if ( ( greh -> flags & ~ ( GRE_KEY | GRE_CSUM ) ) != 0 ) goto out ; type = greh -> protocol ; rcu_read_lock ( ) ; ptype = gro_find_receive_by_type ( type ) ; if ( ! ptype ) goto out_unlock ; grehlen = GRE_HEADER_SECTION ; if ( greh -> flags & GRE_KEY ) grehlen += GRE_HEADER_SECTION ; if ( greh -> flags & GRE_CSUM ) grehlen += GRE_HEADER_SECTION ; hlen = off + grehlen ; if ( skb_gro_header_hard ( skb , hlen ) ) { greh = skb_gro_header_slow ( skb , hlen , off ) ; if ( unlikely ( ! greh ) ) goto out_unlock ; } if ( ( greh -> flags & GRE_CSUM ) && ! NAPI_GRO_CB ( skb ) -> flush ) { if ( skb_gro_checksum_simple_validate ( skb ) ) goto out_unlock ; skb_gro_checksum_try_convert ( skb , IPPROTO_GRE , 0 , null_compute_pseudo ) ; } for ( p = * head ; p ; p = p -> next ) { const struct gre_base_hdr * greh2 ; if ( ! NAPI_GRO_CB ( p ) -> same_flow ) continue ; greh2 = ( struct gre_base_hdr * ) ( p -> data + off ) ; if ( greh2 -> flags != greh -> flags || greh2 -> protocol != greh -> protocol ) { NAPI_GRO_CB ( p ) -> same_flow = 0 ; continue ; } if ( greh -> flags & GRE_KEY ) { if ( * ( __be32 * ) ( greh2 + 1 ) != * ( __be32 * ) ( greh + 1 ) ) { NAPI_GRO_CB ( p ) -> same_flow = 0 ; continue ; } } } skb_gro_pull ( skb , grehlen ) ; skb_gro_postpull_rcsum ( skb , greh , grehlen ) ; pp = ptype -> callbacks . gro_receive ( head , skb ) ; flush = 0 ; out_unlock : rcu_read_unlock ( ) ; out : NAPI_GRO_CB ( skb ) -> flush |= flush ; return pp ; }
","<S2SV_ModStart> ; __be16 type ; if ( NAPI_GRO_CB ( skb ) -> encap_mark ) goto out ; NAPI_GRO_CB ( skb ) -> encap_mark = 1
"
547,"CWE-476 jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) { jas_matrix_t * matrix ; int i ; <S2SV_StartBug> if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) { <S2SV_EndBug> return 0 ; } matrix -> flags_ = 0 ; matrix -> numrows_ = numrows ; matrix -> numcols_ = numcols ; matrix -> rows_ = 0 ; matrix -> maxrows_ = numrows ; matrix -> data_ = 0 ; matrix -> datasize_ = numrows * numcols ; if ( matrix -> maxrows_ > 0 ) { if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { jas_matrix_destroy ( matrix ) ; return 0 ; } } if ( matrix -> datasize_ > 0 ) { if ( ! ( matrix -> data_ = jas_alloc2 ( matrix -> datasize_ , sizeof ( jas_seqent_t ) ) ) ) { jas_matrix_destroy ( matrix ) ; return 0 ; } } for ( i = 0 ; i < numrows ; ++ i ) { matrix -> rows_ [ i ] = & matrix -> data_ [ i * matrix -> numcols_ ] ; } for ( i = 0 ; i < matrix -> datasize_ ; ++ i ) { matrix -> data_ [ i ] = 0 ; } matrix -> xstart_ = 0 ; matrix -> ystart_ = 0 ; matrix -> xend_ = matrix -> numcols_ ; matrix -> yend_ = matrix -> numrows_ ; return matrix ; }
","<S2SV_ModStart> ; if ( numrows < 0 || numcols < 0 ) { return 0 ; } if (
"
548,"CWE-522 static TPM_RC StartAuthSession ( TSS2_SYS_CONTEXT * sapi_context , SESSION * session ) { TPM_RC rval ; TPM2B_ENCRYPTED_SECRET key ; char label [ ] = ""ATH"" ; UINT16 bytes ; int i ; key . t . size = 0 ; if ( session -> nonceOlder . t . size == 0 ) { session -> nonceOlder . t . size = GetDigestSize ( TPM_ALG_SHA1 ) ; for ( i = 0 ; i < session -> nonceOlder . t . size ; i ++ ) session -> nonceOlder . t . buffer [ i ] = 0 ; } session -> nonceNewer . t . size = session -> nonceOlder . t . size ; rval = Tss2_Sys_StartAuthSession ( sapi_context , session -> tpmKey , session -> bind , 0 , & ( session -> nonceOlder ) , & ( session -> encryptedSalt ) , session -> sessionType , & ( session -> symmetric ) , session -> authHash , & ( session -> sessionHandle ) , & ( session -> nonceNewer ) , 0 ) ; if ( rval == TPM_RC_SUCCESS ) { if ( session -> tpmKey == TPM_RH_NULL ) session -> salt . t . size = 0 ; if ( session -> bind == TPM_RH_NULL ) session -> authValueBind . t . size = 0 ; if ( session -> tpmKey == TPM_RH_NULL && session -> bind == TPM_RH_NULL ) { session -> sessionKey . b . size = 0 ; } else { bool result = string_bytes_concat_buffer ( ( TPM2B_MAX_BUFFER * ) & key , & ( session -> authValueBind . b ) ) ; if ( ! result ) { return TSS2_SYS_RC_BAD_VALUE ; } result = string_bytes_concat_buffer ( ( TPM2B_MAX_BUFFER * ) & key , & ( session -> salt . b ) ) ; if ( ! result ) { return TSS2_SYS_RC_BAD_VALUE ; } bytes = GetDigestSize ( session -> authHash ) ; if ( key . t . size == 0 ) { session -> sessionKey . t . size = 0 ; } else { <S2SV_StartBug> rval = tpm_kdfa ( sapi_context , session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) , <S2SV_EndBug> & ( session -> nonceOlder . b ) , bytes * 8 , ( TPM2B_MAX_BUFFER * ) & ( session -> sessionKey ) ) ; } if ( rval != TPM_RC_SUCCESS ) { return ( TSS2_APP_RC_CREATE_SESSION_KEY_FAILED ) ; } } session -> nonceTpmDecrypt . b . size = 0 ; session -> nonceTpmEncrypt . b . size = 0 ; session -> nvNameChanged = 0 ; } return rval ; }
","<S2SV_ModStart> = tpm_kdfa ( <S2SV_ModEnd> session -> authHash
"
549,"CWE-476 long keyctl_read_key ( key_serial_t keyid , char __user * buffer , size_t buflen ) { struct key * key ; key_ref_t key_ref ; long ret ; key_ref = lookup_user_key ( keyid , 0 , 0 ) ; if ( IS_ERR ( key_ref ) ) { ret = - ENOKEY ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; <S2SV_StartBug> ret = key_permission ( key_ref , KEY_NEED_READ ) ; <S2SV_EndBug> if ( ret == 0 ) goto can_read_key ; if ( ret != - EACCES ) goto error2 ; if ( ! is_key_possessed ( key_ref ) ) { ret = - EACCES ; goto error2 ; } can_read_key : ret = - EOPNOTSUPP ; if ( key -> type -> read ) { down_read ( & key -> sem ) ; ret = key_validate ( key ) ; if ( ret == 0 ) ret = key -> type -> read ( key , buffer , buflen ) ; up_read ( & key -> sem ) ; } error2 : key_put ( key ) ; error : return ret ; }
","<S2SV_ModStart> key_ref ) ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { ret = - ENOKEY ; goto error2 ; }
"
550,"CWE-172 WORD32 ih264d_video_decode ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; WORD32 i4_err_status = 0 ; UWORD8 * pu1_buf = NULL ; WORD32 buflen ; UWORD32 u4_max_ofst , u4_length_of_start_code = 0 ; UWORD32 bytes_consumed = 0 ; UWORD32 cur_slice_is_nonref = 0 ; UWORD32 u4_next_is_aud ; UWORD32 u4_first_start_code_found = 0 ; WORD32 ret = 0 , api_ret_value = IV_SUCCESS ; WORD32 header_data_left = 0 , frame_data_left = 0 ; UWORD8 * pu1_bitstrm_buf ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; ithread_set_name ( ( void * ) ""Parse_thread"" ) ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } ps_dec -> pv_dec_out = ps_dec_op ; if ( ps_dec -> init_done != 1 ) { return IV_FAIL ; } DATA_SYNC ( ) ; if ( 0 == ps_dec -> u1_flushfrm ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } ps_dec -> u1_pic_decode_done = 0 ; ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec -> ps_out_buffer = NULL ; if ( ps_dec_ip -> u4_size >= offsetof ( ivd_video_decode_ip_t , s_out_buffer ) ) ps_dec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ; ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 0 ; ps_dec -> s_disp_op . u4_error_code = 1 ; ps_dec -> u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS ; if ( 0 == ps_dec -> u4_share_disp_buf && ps_dec -> i4_decode_header == 0 ) { UWORD32 i ; if ( ps_dec -> ps_out_buffer -> u4_num_bufs == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ; return IV_FAIL ; } for ( i = 0 ; i < ps_dec -> ps_out_buffer -> u4_num_bufs ; i ++ ) { if ( ps_dec -> ps_out_buffer -> pu1_bufs [ i ] == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ; return IV_FAIL ; } if ( ps_dec -> ps_out_buffer -> u4_min_out_buf_size [ i ] == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return IV_FAIL ; } } } if ( ps_dec -> u4_total_frames_decoded >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code = ERROR_FRAME_LIMIT_OVER ; return IV_FAIL ; } ps_dec -> u4_ts = ps_dec_ip -> u4_ts ; ps_dec_op -> u4_error_code = 0 ; ps_dec_op -> e_pic_type = - 1 ; ps_dec_op -> u4_output_present = 0 ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; { if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } } ps_dec -> u4_slice_start_code_found = 0 ; if ( ps_dec -> u1_init_dec_flag == 1 && ps_dec -> u4_share_disp_buf == 1 && ps_dec -> u1_flushfrm == 0 ) { UWORD32 i ; WORD32 disp_avail = 0 , free_id ; for ( i = 0 ; i < ps_dec -> u1_pic_bufs ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_mapping [ i ] || 1 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) { disp_avail = 1 ; break ; } } if ( 0 == disp_avail ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } while ( 1 ) { pic_buffer_t * ps_pic_buf ; ps_pic_buf = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & free_id ) ; if ( ps_pic_buf == NULL ) { UWORD32 i , display_queued = 0 ; for ( i = 0 ; i < ( MAX_DISP_BUFS_NEW ) ; i ++ ) { if ( 0 != ps_dec -> u4_disp_buf_mapping [ i ] ) { display_queued = 1 ; break ; } } if ( 1 == display_queued ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } } else { if ( 1 == ps_dec -> u4_disp_buf_mapping [ free_id ] ) { ih264_buf_mgr_set_status ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; } else { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; break ; } } } } if ( ps_dec -> u1_flushfrm && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; ps_dec -> u4_output_present = 1 ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; ps_dec_op -> u4_new_seq = 0 ; ps_dec_op -> u4_output_present = ps_dec -> u4_output_present ; ps_dec_op -> u4_progressive_frame_flag = ps_dec -> s_disp_op . u4_progressive_frame_flag ; ps_dec_op -> e_output_format = ps_dec -> s_disp_op . e_output_format ; ps_dec_op -> s_disp_frm_buf = ps_dec -> s_disp_op . s_disp_frm_buf ; ps_dec_op -> e4_fld_type = ps_dec -> s_disp_op . e4_fld_type ; ps_dec_op -> u4_ts = ps_dec -> s_disp_op . u4_ts ; ps_dec_op -> u4_disp_buf_id = ps_dec -> s_disp_op . u4_disp_buf_id ; ps_dec_op -> u4_is_ref_flag = - 1 ; ps_dec_op -> e_pic_type = IV_NA_FRAME ; ps_dec_op -> u4_frame_decoded_flag = 0 ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { return ( IV_SUCCESS ) ; } else return ( IV_FAIL ) ; } if ( ps_dec -> u1_res_changed == 1 ) { ih264d_init_decoder ( ps_dec ) ; } ps_dec -> u4_prev_nal_skipped = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> cur_dec_mb_num = 0 ; ps_dec -> cur_recon_mb_num = 0 ; ps_dec -> u4_first_slice_in_pic = 2 ; ps_dec -> u1_slice_header_done = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> u4_dec_thread_created = 0 ; ps_dec -> u4_bs_deblk_thread_created = 0 ; ps_dec -> u4_cur_bs_mb_num = 0 ; ps_dec -> u4_start_recon_deblk = 0 ; DEBUG_THREADS_PRINTF ( ""<S2SV_blank>Starting<S2SV_blank>process<S2SV_blank>call\\n"" ) ; ps_dec -> u4_pic_buf_got = 0 ; do { WORD32 buf_size ; pu1_buf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer + ps_dec_op -> u4_num_bytes_consumed ; u4_max_ofst = ps_dec_ip -> u4_num_Bytes - ps_dec_op -> u4_num_bytes_consumed ; if ( ( NULL == ps_dec -> pu1_bits_buf_dynamic ) && ( ps_dec -> i4_header_decoded & 1 ) ) { WORD32 size ; void * pv_buf ; void * pv_mem_ctxt = ps_dec -> pv_mem_ctxt ; size = MAX ( 256000 , ps_dec -> u2_pic_wd * ps_dec -> u2_pic_ht * 3 / 2 ) ; pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size ) ; RETURN_IF ( ( NULL == pv_buf ) , IV_FAIL ) ; ps_dec -> pu1_bits_buf_dynamic = pv_buf ; ps_dec -> u4_dynamic_bits_buf_size = size ; } if ( ps_dec -> pu1_bits_buf_dynamic ) { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_dynamic ; buf_size = ps_dec -> u4_dynamic_bits_buf_size ; } else { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_static ; buf_size = ps_dec -> u4_static_bits_buf_size ; } u4_next_is_aud = 0 ; buflen = ih264d_find_start_code ( pu1_buf , 0 , u4_max_ofst , & u4_length_of_start_code , & u4_next_is_aud ) ; if ( buflen == - 1 ) buflen = 0 ; buflen = MIN ( buflen , buf_size ) ; bytes_consumed = buflen + u4_length_of_start_code ; ps_dec_op -> u4_num_bytes_consumed += bytes_consumed ; { UWORD8 u1_firstbyte , u1_nal_ref_idc ; if ( ps_dec -> i4_app_skip_mode == IVD_SKIP_B ) { u1_firstbyte = * ( pu1_buf + u4_length_of_start_code ) ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_firstbyte ) ) ; if ( u1_nal_ref_idc == 0 ) { cur_slice_is_nonref = 1 ; continue ; } else { if ( 1 == cur_slice_is_nonref ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> e_pic_type = IV_B_FRAME ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } } } } if ( buflen ) { memcpy ( pu1_bitstrm_buf , pu1_buf + u4_length_of_start_code , buflen ) ; if ( ( buflen + 8 ) < buf_size ) { memset ( pu1_bitstrm_buf + buflen , 0 , 8 ) ; } u4_first_start_code_found = 1 ; } else { if ( u4_first_start_code_found == 0 ) { ps_dec -> i4_error_code = ERROR_START_CODE_NOT_FOUND ; ps_dec_op -> u4_error_code |= 1 << IVD_INSUFFICIENTDATA ; if ( ps_dec -> u4_pic_buf_got == 0 ) { ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; ps_dec_op -> u4_error_code = ps_dec -> i4_error_code ; ps_dec_op -> u4_frame_decoded_flag = 0 ; return ( IV_FAIL ) ; } else { ps_dec -> u1_pic_decode_done = 1 ; continue ; } } else { frame_data_left = 0 ; continue ; } } ps_dec -> u4_return_to_app = 0 ; ret = ih264d_parse_nal_unit ( dec_hdl , ps_dec_op , pu1_bitstrm_buf , buflen ) ; if ( ret != OK ) { UWORD32 error = ih264d_map_error ( ret ) ; ps_dec_op -> u4_error_code = error | ret ; api_ret_value = IV_FAIL ; if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) <S2SV_StartBug> || ( ret == ERROR_UNAVAIL_MVBUF_T ) ) <S2SV_EndBug> { break ; } if ( ( ret == ERROR_INCOMPLETE_FRAME ) || ( ret == ERROR_DANGLING_FIELD_IN_PIC ) ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; api_ret_value = IV_FAIL ; break ; } if ( ret == ERROR_IN_LAST_SLICE_OF_PIC ) { api_ret_value = IV_FAIL ; break ; } } if ( ps_dec -> u4_return_to_app ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } header_data_left = ( ( ps_dec -> i4_decode_header == 1 ) && ( ps_dec -> i4_header_decoded != 3 ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; frame_data_left = ( ( ( ps_dec -> i4_decode_header == 0 ) && ( ( ps_dec -> u1_pic_decode_done == 0 ) || ( u4_next_is_aud == 1 ) ) ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; } while ( ( header_data_left == 1 ) || ( frame_data_left == 1 ) ) ; if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ret != IVD_MEM_ALLOC_FAILED ) && ps_dec -> u2_total_mbs_coded < ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { WORD32 num_mb_skipped ; WORD32 prev_slice_err ; pocstruct_t temp_poc ; WORD32 ret1 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u4_pic_buf_got == 0 ) ) prev_slice_err = 1 ; else prev_slice_err = 2 ; ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , & temp_poc , prev_slice_err ) ; if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) ) { return IV_FAIL ; } } if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) <S2SV_StartBug> || ( ret == ERROR_UNAVAIL_MVBUF_T ) ) <S2SV_EndBug> { ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } if ( ret == IVD_RES_CHANGED ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; } return IV_FAIL ; } if ( ps_dec -> u1_separate_parse ) { if ( ps_dec -> u4_num_cores == 2 ) { if ( ( ps_dec -> u4_nmb_deblk == 0 ) && ( ps_dec -> u4_start_recon_deblk == 1 ) && ( ps_dec -> ps_cur_sps -> u1_mb_aff_flag == 0 ) ) { UWORD32 u4_num_mbs , u4_max_addr ; tfr_ctxt_t s_tfr_ctxt ; tfr_ctxt_t * ps_tfr_cxt = & s_tfr_ctxt ; pad_mgr_t * ps_pad_mgr = & ps_dec -> s_pad_mgr ; u4_max_addr = ( ps_dec -> u2_frm_wd_in_mbs * ps_dec -> u2_frm_ht_in_mbs ) - 1 ; ps_dec -> u4_cur_bs_mb_num = u4_max_addr + 1 ; ih264d_init_deblk_tfr_ctxt ( ps_dec , ps_pad_mgr , ps_tfr_cxt , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; u4_num_mbs = u4_max_addr - ps_dec -> u4_cur_deblk_mb_num + 1 ; DEBUG_PERF_PRINTF ( ""mbs<S2SV_blank>left<S2SV_blank>for<S2SV_blank>deblocking=<S2SV_blank>%d<S2SV_blank>\\n"" , u4_num_mbs ) ; if ( u4_num_mbs != 0 ) ih264d_check_mb_map_deblk ( ps_dec , u4_num_mbs , ps_tfr_cxt , 1 ) ; ps_dec -> u4_start_recon_deblk = 0 ; } } ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } } DATA_SYNC ( ) ; if ( ( ps_dec_op -> u4_error_code & 0xff ) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED ) { ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; } if ( ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> i4_decode_header == 1 && ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> u4_prev_nal_skipped ) { ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ERROR_DANGLING_FIELD_IN_PIC != i4_err_status ) ) { if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) { if ( 1 == ps_dec -> ps_cur_slice -> u1_bottom_field_flag ) { ps_dec -> u1_top_bottom_decoded |= BOT_FIELD_ONLY ; } else { ps_dec -> u1_top_bottom_decoded |= TOP_FIELD_ONLY ; } } if ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) { ret = ih264d_deblock_display ( ps_dec ) ; if ( ret != 0 ) { return IV_FAIL ; } } if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ; } if ( ps_dec -> ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_dec -> i4_frametype = IV_IDR_FRAME ; } else if ( ps_dec -> i4_pic_type == B_SLICE ) { ps_dec -> i4_frametype = IV_B_FRAME ; } else if ( ps_dec -> i4_pic_type == P_SLICE ) { ps_dec -> i4_frametype = IV_P_FRAME ; } else if ( ps_dec -> i4_pic_type == I_SLICE ) { ps_dec -> i4_frametype = IV_I_FRAME ; } else { H264_DEC_DEBUG_PRINT ( ""Shouldn\'t<S2SV_blank>come<S2SV_blank>here\\n"" ) ; } ps_dec -> i4_content_type = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded + 2 ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded - ps_dec -> ps_cur_slice -> u1_field_pic_flag ; } if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } { if ( ( IVD_DECODE_FRAME_OUT == ps_dec -> e_frm_out_mode ) && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 1 ; } } ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; if ( ps_dec -> u4_output_present && ( ps_dec -> u4_fmt_conv_cur_row < ps_dec -> s_disp_frame_info . u4_y_ht ) ) { ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht - ps_dec -> u4_fmt_conv_cur_row ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; } if ( ps_dec -> i4_decode_header == 1 && ( ps_dec -> i4_header_decoded & 1 ) == 1 ) { ps_dec_op -> u4_progressive_frame_flag = 1 ; if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { if ( ( 0 == ps_dec -> ps_sps -> u1_frame_mbs_only_flag ) && ( 0 == ps_dec -> ps_sps -> u1_mb_aff_flag ) ) ps_dec_op -> u4_progressive_frame_flag = 0 ; } } DATA_SYNC ( ) ; H264_DEC_DEBUG_PRINT ( ""The<S2SV_blank>num<S2SV_blank>bytes<S2SV_blank>consumed:<S2SV_blank>%d\\n"" , ps_dec_op -> u4_num_bytes_consumed ) ; return api_ret_value ; }
","<S2SV_ModStart> == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) { ps_dec -> u4_slice_start_code_found = 0 ; <S2SV_ModEnd> break ; } <S2SV_ModStart> == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T )
"
551,"CWE-190 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; <S2SV_StartBug> dst_known = tnum_is_const ( dst_reg -> var_off ) ; <S2SV_EndBug> switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }
","<S2SV_ModStart> var_off ) ; if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; }
"
552,"CWE-264 struct dentry * cifs_lookup ( struct inode * parent_dir_inode , struct dentry * direntry , struct nameidata * nd ) { int xid ; int rc = 0 ; __u32 oplock = enable_oplocks ? REQ_OPLOCK : 0 ; __u16 fileHandle = 0 ; bool posix_open = false ; struct cifs_sb_info * cifs_sb ; struct tcon_link * tlink ; struct cifs_tcon * pTcon ; struct cifsFileInfo * cfile ; struct inode * newInode = NULL ; char * full_path = NULL ; struct file * filp ; xid = GetXid ( ) ; cFYI ( 1 , ""parent<S2SV_blank>inode<S2SV_blank>=<S2SV_blank>0x%p<S2SV_blank>name<S2SV_blank>is:<S2SV_blank>%s<S2SV_blank>and<S2SV_blank>dentry<S2SV_blank>=<S2SV_blank>0x%p"" , parent_dir_inode , direntry -> d_name . name , direntry ) ; cifs_sb = CIFS_SB ( parent_dir_inode -> i_sb ) ; tlink = cifs_sb_tlink ( cifs_sb ) ; if ( IS_ERR ( tlink ) ) { FreeXid ( xid ) ; return ( struct dentry * ) tlink ; } pTcon = tlink_tcon ( tlink ) ; if ( ! ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS ) ) { int i ; for ( i = 0 ; i < direntry -> d_name . len ; i ++ ) if ( direntry -> d_name . name [ i ] == '\\\\' ) { cFYI ( 1 , ""Invalid<S2SV_blank>file<S2SV_blank>name"" ) ; rc = - EINVAL ; goto lookup_out ; } } if ( nd && ( nd -> flags & LOOKUP_EXCL ) ) { d_instantiate ( direntry , NULL ) ; rc = 0 ; goto lookup_out ; } full_path = build_path_from_dentry ( direntry ) ; if ( full_path == NULL ) { rc = - ENOMEM ; goto lookup_out ; } if ( direntry -> d_inode != NULL ) { cFYI ( 1 , ""non-NULL<S2SV_blank>inode<S2SV_blank>in<S2SV_blank>lookup"" ) ; } else { cFYI ( 1 , ""NULL<S2SV_blank>inode<S2SV_blank>in<S2SV_blank>lookup"" ) ; } cFYI ( 1 , ""Full<S2SV_blank>path:<S2SV_blank>%s<S2SV_blank>inode<S2SV_blank>=<S2SV_blank>0x%p"" , full_path , direntry -> d_inode ) ; if ( pTcon -> unix_ext ) { if ( nd && ! ( nd -> flags & LOOKUP_DIRECTORY ) && ( nd -> flags & LOOKUP_OPEN ) && ! pTcon -> broken_posix_open && ( nd -> intent . open . file -> f_flags & O_CREAT ) ) { rc = cifs_posix_open ( full_path , & newInode , parent_dir_inode -> i_sb , nd -> intent . open . create_mode , nd -> intent . open . file -> f_flags , & oplock , & fileHandle , xid ) ; <S2SV_StartBug> if ( ( rc == 0 ) || ( rc == - ENOENT ) ) <S2SV_EndBug> posix_open = true ; else if ( ( rc == - EINVAL ) || ( rc != - EOPNOTSUPP ) ) pTcon -> broken_posix_open = true ; } if ( ! posix_open ) rc = cifs_get_inode_info_unix ( & newInode , full_path , parent_dir_inode -> i_sb , xid ) ; } else rc = cifs_get_inode_info ( & newInode , full_path , NULL , parent_dir_inode -> i_sb , xid , NULL ) ; if ( ( rc == 0 ) && ( newInode != NULL ) ) { d_add ( direntry , newInode ) ; if ( posix_open ) { filp = lookup_instantiate_filp ( nd , direntry , generic_file_open ) ; if ( IS_ERR ( filp ) ) { rc = PTR_ERR ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; goto lookup_out ; } cfile = cifs_new_fileinfo ( fileHandle , filp , tlink , oplock ) ; if ( cfile == NULL ) { fput ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; rc = - ENOMEM ; goto lookup_out ; } } renew_parental_timestamps ( direntry ) ; } else if ( rc == - ENOENT ) { rc = 0 ; direntry -> d_time = jiffies ; d_add ( direntry , NULL ) ; } else if ( rc != - EACCES ) { cERROR ( 1 , ""Unexpected<S2SV_blank>lookup<S2SV_blank>error<S2SV_blank>%d"" , rc ) ; } lookup_out : kfree ( full_path ) ; cifs_put_tlink ( tlink ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; }
","<S2SV_ModStart> xid ) ; switch ( rc ) { case 0 : if ( newInode && ! S_ISREG ( newInode -> i_mode ) ) { CIFSSMBClose ( xid , pTcon , fileHandle ) ; break ; } case - ENOENT : posix_open = true ; case - EOPNOTSUPP : break ; default : pTcon -> broken_posix_open = true ; } } if ( ! posix_open ) rc = cifs_get_inode_info_unix ( & newInode , full_path , parent_dir_inode -> i_sb , xid ) ; } else rc = cifs_get_inode_info ( & newInode , full_path , NULL , parent_dir_inode -> i_sb , xid , NULL ) ; <S2SV_ModStart> == 0 ) && ( newInode != NULL ) ) { d_add ( direntry , newInode ) ; if ( posix_open ) { filp = lookup_instantiate_filp ( nd , direntry , generic_file_open ) ; if ( IS_ERR ( filp ) ) { rc = PTR_ERR ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; goto lookup_out ; } cfile = cifs_new_fileinfo ( fileHandle , filp , tlink , oplock ) ; if ( cfile == NULL ) { fput ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; rc = - ENOMEM ; goto lookup_out ; } } renew_parental_timestamps ( direntry ) ; } else if <S2SV_ModEnd> ( rc == <S2SV_ModStart> - ENOENT ) <S2SV_ModEnd> { rc =
"
553,"CWE-190 static long vfio_pci_ioctl ( void * device_data , unsigned int cmd , unsigned long arg ) { struct vfio_pci_device * vdev = device_data ; unsigned long minsz ; if ( cmd == VFIO_DEVICE_GET_INFO ) { struct vfio_device_info info ; minsz = offsetofend ( struct vfio_device_info , num_irqs ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( info . argsz < minsz ) return - EINVAL ; info . flags = VFIO_DEVICE_FLAGS_PCI ; if ( vdev -> reset_works ) info . flags |= VFIO_DEVICE_FLAGS_RESET ; info . num_regions = VFIO_PCI_NUM_REGIONS + vdev -> num_regions ; info . num_irqs = VFIO_PCI_NUM_IRQS ; return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ; } else if ( cmd == VFIO_DEVICE_GET_REGION_INFO ) { struct pci_dev * pdev = vdev -> pdev ; struct vfio_region_info info ; struct vfio_info_cap caps = { . buf = NULL , . size = 0 } ; int i , ret ; minsz = offsetofend ( struct vfio_region_info , offset ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( info . argsz < minsz ) return - EINVAL ; switch ( info . index ) { case VFIO_PCI_CONFIG_REGION_INDEX : info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . size = pdev -> cfg_size ; info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ; break ; case VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX : info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . size = pci_resource_len ( pdev , info . index ) ; if ( ! info . size ) { info . flags = 0 ; break ; } info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ; if ( vdev -> bar_mmap_supported [ info . index ] ) { info . flags |= VFIO_REGION_INFO_FLAG_MMAP ; if ( info . index == vdev -> msix_bar ) { ret = msix_sparse_mmap_cap ( vdev , & caps ) ; if ( ret ) return ret ; } } break ; case VFIO_PCI_ROM_REGION_INDEX : { void __iomem * io ; size_t size ; info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . flags = 0 ; info . size = pci_resource_len ( pdev , info . index ) ; if ( ! info . size ) { if ( pdev -> resource [ PCI_ROM_RESOURCE ] . flags & IORESOURCE_ROM_SHADOW ) info . size = 0x20000 ; else break ; } io = pci_map_rom ( pdev , & size ) ; if ( ! io || ! size ) { info . size = 0 ; break ; } pci_unmap_rom ( pdev , io ) ; info . flags = VFIO_REGION_INFO_FLAG_READ ; break ; } case VFIO_PCI_VGA_REGION_INDEX : if ( ! vdev -> has_vga ) return - EINVAL ; info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . size = 0xc0000 ; info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ; break ; default : if ( info . index >= VFIO_PCI_NUM_REGIONS + vdev -> num_regions ) return - EINVAL ; i = info . index - VFIO_PCI_NUM_REGIONS ; info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . size = vdev -> region [ i ] . size ; info . flags = vdev -> region [ i ] . flags ; ret = region_type_cap ( vdev , & caps , vdev -> region [ i ] . type , vdev -> region [ i ] . subtype ) ; if ( ret ) return ret ; } if ( caps . size ) { info . flags |= VFIO_REGION_INFO_FLAG_CAPS ; if ( info . argsz < sizeof ( info ) + caps . size ) { info . argsz = sizeof ( info ) + caps . size ; info . cap_offset = 0 ; } else { vfio_info_cap_shift ( & caps , sizeof ( info ) ) ; if ( copy_to_user ( ( void __user * ) arg + sizeof ( info ) , caps . buf , caps . size ) ) { kfree ( caps . buf ) ; return - EFAULT ; } info . cap_offset = sizeof ( info ) ; } kfree ( caps . buf ) ; } return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ; } else if ( cmd == VFIO_DEVICE_GET_IRQ_INFO ) { struct vfio_irq_info info ; minsz = offsetofend ( struct vfio_irq_info , count ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( info . argsz < minsz || info . index >= VFIO_PCI_NUM_IRQS ) return - EINVAL ; switch ( info . index ) { case VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX : case VFIO_PCI_REQ_IRQ_INDEX : break ; case VFIO_PCI_ERR_IRQ_INDEX : if ( pci_is_pcie ( vdev -> pdev ) ) break ; default : return - EINVAL ; } info . flags = VFIO_IRQ_INFO_EVENTFD ; info . count = vfio_pci_get_irq_count ( vdev , info . index ) ; if ( info . index == VFIO_PCI_INTX_IRQ_INDEX ) info . flags |= ( VFIO_IRQ_INFO_MASKABLE | VFIO_IRQ_INFO_AUTOMASKED ) ; else info . flags |= VFIO_IRQ_INFO_NORESIZE ; return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ; } else if ( cmd == VFIO_DEVICE_SET_IRQS ) { struct vfio_irq_set hdr ; <S2SV_StartBug> u8 * data = NULL ; <S2SV_EndBug> <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> minsz = offsetofend ( struct vfio_irq_set , count ) ; if ( copy_from_user ( & hdr , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( hdr . argsz < minsz || hdr . index >= VFIO_PCI_NUM_IRQS || <S2SV_StartBug> hdr . flags & ~ ( VFIO_IRQ_SET_DATA_TYPE_MASK | <S2SV_EndBug> VFIO_IRQ_SET_ACTION_TYPE_MASK ) ) return - EINVAL ; <S2SV_StartBug> if ( ! ( hdr . flags & VFIO_IRQ_SET_DATA_NONE ) ) { <S2SV_EndBug> size_t size ; int max = vfio_pci_get_irq_count ( vdev , hdr . index ) ; <S2SV_StartBug> if ( hdr . flags & VFIO_IRQ_SET_DATA_BOOL ) <S2SV_EndBug> size = sizeof ( uint8_t ) ; else if ( hdr . flags & VFIO_IRQ_SET_DATA_EVENTFD ) size = sizeof ( int32_t ) ; else return - EINVAL ; if ( hdr . argsz - minsz < hdr . count * size || <S2SV_StartBug> hdr . start >= max || hdr . start + hdr . count > max ) <S2SV_EndBug> return - EINVAL ; data = memdup_user ( ( void __user * ) ( arg + minsz ) , hdr . count * size ) ; if ( IS_ERR ( data ) ) return PTR_ERR ( data ) ; } mutex_lock ( & vdev -> igate ) ; ret = vfio_pci_set_irqs_ioctl ( vdev , hdr . flags , hdr . index , hdr . start , hdr . count , data ) ; mutex_unlock ( & vdev -> igate ) ; kfree ( data ) ; return ret ; } else if ( cmd == VFIO_DEVICE_RESET ) { return vdev -> reset_works ? pci_try_reset_function ( vdev -> pdev ) : - EINVAL ; } else if ( cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO ) { struct vfio_pci_hot_reset_info hdr ; struct vfio_pci_fill_info fill = { 0 } ; struct vfio_pci_dependent_device * devices = NULL ; bool slot = false ; int ret = 0 ; minsz = offsetofend ( struct vfio_pci_hot_reset_info , count ) ; if ( copy_from_user ( & hdr , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( hdr . argsz < minsz ) return - EINVAL ; hdr . flags = 0 ; if ( ! pci_probe_reset_slot ( vdev -> pdev -> slot ) ) slot = true ; else if ( pci_probe_reset_bus ( vdev -> pdev -> bus ) ) return - ENODEV ; ret = vfio_pci_for_each_slot_or_bus ( vdev -> pdev , vfio_pci_count_devs , & fill . max , slot ) ; if ( ret ) return ret ; WARN_ON ( ! fill . max ) ; if ( hdr . argsz < sizeof ( hdr ) + ( fill . max * sizeof ( * devices ) ) ) { ret = - ENOSPC ; hdr . count = fill . max ; goto reset_info_exit ; } devices = kcalloc ( fill . max , sizeof ( * devices ) , GFP_KERNEL ) ; if ( ! devices ) return - ENOMEM ; fill . devices = devices ; ret = vfio_pci_for_each_slot_or_bus ( vdev -> pdev , vfio_pci_fill_devs , & fill , slot ) ; if ( ! ret ) hdr . count = fill . cur ; reset_info_exit : if ( copy_to_user ( ( void __user * ) arg , & hdr , minsz ) ) ret = - EFAULT ; if ( ! ret ) { if ( copy_to_user ( ( void __user * ) ( arg + minsz ) , devices , hdr . count * sizeof ( * devices ) ) ) ret = - EFAULT ; } kfree ( devices ) ; return ret ; } else if ( cmd == VFIO_DEVICE_PCI_HOT_RESET ) { struct vfio_pci_hot_reset hdr ; int32_t * group_fds ; struct vfio_pci_group_entry * groups ; struct vfio_pci_group_info info ; bool slot = false ; int i , count = 0 , ret = 0 ; minsz = offsetofend ( struct vfio_pci_hot_reset , count ) ; if ( copy_from_user ( & hdr , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( hdr . argsz < minsz || hdr . flags ) return - EINVAL ; if ( ! pci_probe_reset_slot ( vdev -> pdev -> slot ) ) slot = true ; else if ( pci_probe_reset_bus ( vdev -> pdev -> bus ) ) return - ENODEV ; ret = vfio_pci_for_each_slot_or_bus ( vdev -> pdev , vfio_pci_count_devs , & count , slot ) ; if ( ret ) return ret ; if ( ! hdr . count || hdr . count > count ) return - EINVAL ; group_fds = kcalloc ( hdr . count , sizeof ( * group_fds ) , GFP_KERNEL ) ; groups = kcalloc ( hdr . count , sizeof ( * groups ) , GFP_KERNEL ) ; if ( ! group_fds || ! groups ) { kfree ( group_fds ) ; kfree ( groups ) ; return - ENOMEM ; } if ( copy_from_user ( group_fds , ( void __user * ) ( arg + minsz ) , hdr . count * sizeof ( * group_fds ) ) ) { kfree ( group_fds ) ; kfree ( groups ) ; return - EFAULT ; } for ( i = 0 ; i < hdr . count ; i ++ ) { struct vfio_group * group ; struct fd f = fdget ( group_fds [ i ] ) ; if ( ! f . file ) { ret = - EBADF ; break ; } group = vfio_group_get_external_user ( f . file ) ; fdput ( f ) ; if ( IS_ERR ( group ) ) { ret = PTR_ERR ( group ) ; break ; } groups [ i ] . group = group ; groups [ i ] . id = vfio_external_user_iommu_id ( group ) ; } kfree ( group_fds ) ; if ( ret ) goto hot_reset_release ; info . count = hdr . count ; info . groups = groups ; ret = vfio_pci_for_each_slot_or_bus ( vdev -> pdev , vfio_pci_validate_devs , & info , slot ) ; if ( ! ret ) ret = slot ? pci_try_reset_slot ( vdev -> pdev -> slot ) : pci_try_reset_bus ( vdev -> pdev -> bus ) ; hot_reset_release : for ( i -- ; i >= 0 ; i -- ) vfio_group_put_external_user ( groups [ i ] . group ) ; kfree ( groups ) ; return ret ; } return - ENOTTY ; }
","<S2SV_ModStart> vfio_irq_set hdr ; size_t size ; <S2SV_ModStart> NULL ; int max , <S2SV_ModStart> || hdr . count >= ( U32_MAX - hdr . start ) || hdr . <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> max = vfio_pci_get_irq_count <S2SV_ModStart> ; if ( <S2SV_ModEnd> hdr . start <S2SV_ModStart> count > max ) return - EINVAL ; switch ( hdr . flags & VFIO_IRQ_SET_DATA_TYPE_MASK ) { case VFIO_IRQ_SET_DATA_NONE : size = 0 ; break ; case VFIO_IRQ_SET_DATA_BOOL : size = sizeof ( uint8_t ) ; break ; case VFIO_IRQ_SET_DATA_EVENTFD : size = sizeof ( int32_t ) ; break ; default : return - EINVAL ; } if ( size ) { if ( hdr . argsz - minsz < hdr . count * size
"
554,"CWE-200 static int ext4_write_end ( struct file * file , struct address_space * mapping , loff_t pos , unsigned len , unsigned copied , struct page * page , void * fsdata ) { handle_t * handle = ext4_journal_current_handle ( ) ; struct inode * inode = mapping -> host ; loff_t old_size = inode -> i_size ; int ret = 0 , ret2 ; int i_size_changed = 0 ; trace_ext4_write_end ( inode , pos , len , copied ) ; <S2SV_StartBug> if ( ext4_test_inode_state ( inode , EXT4_STATE_ORDERED_MODE ) ) { <S2SV_EndBug> ret = ext4_jbd2_file_inode ( handle , inode ) ; if ( ret ) { unlock_page ( page ) ; put_page ( page ) ; goto errout ; } } if ( ext4_has_inline_data ( inode ) ) { ret = ext4_write_inline_data_end ( inode , pos , len , copied , page ) ; if ( ret < 0 ) goto errout ; copied = ret ; } else copied = block_write_end ( file , mapping , pos , len , copied , page , fsdata ) ; i_size_changed = ext4_update_inode_size ( inode , pos + copied ) ; unlock_page ( page ) ; put_page ( page ) ; if ( old_size < pos ) pagecache_isize_extended ( inode , old_size , pos ) ; if ( i_size_changed ) ext4_mark_inode_dirty ( handle , inode ) ; if ( pos + len > inode -> i_size && ext4_can_truncate ( inode ) ) ext4_orphan_add ( handle , inode ) ; errout : ret2 = ext4_journal_stop ( handle ) ; if ( ! ret ) ret = ret2 ; if ( pos + len > inode -> i_size ) { ext4_truncate_failed_write ( inode ) ; if ( inode -> i_nlink ) ext4_orphan_del ( NULL , inode ) ; } return ret ? ret : copied ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> ext4_has_inline_data ( inode
"
555,"CWE-119 static int http_open ( URLContext * h , const char * uri , int flags , AVDictionary * * options ) { HTTPContext * s = h -> priv_data ; int ret ; if ( s -> seekable == 1 ) h -> is_streamed = 0 ; else h -> is_streamed = 1 ; <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> s -> location = av_strdup ( uri ) ; if ( ! s -> location ) return AVERROR ( ENOMEM ) ; if ( options ) av_dict_copy ( & s -> chained_options , * options , 0 ) ; if ( s -> headers ) { int len = strlen ( s -> headers ) ; if ( len < 2 || strcmp ( ""\\r\\n"" , s -> headers + len - 2 ) ) { av_log ( h , AV_LOG_WARNING , ""No<S2SV_blank>trailing<S2SV_blank>CRLF<S2SV_blank>found<S2SV_blank>in<S2SV_blank>HTTP<S2SV_blank>header.\\n"" ) ; ret = av_reallocp ( & s -> headers , len + 3 ) ; if ( ret < 0 ) return ret ; s -> headers [ len ] = '\\r' ; s -> headers [ len + 1 ] = '\\n' ; s -> headers [ len + 2 ] = '\\0' ; } } if ( s -> listen ) { return http_listen ( h , uri , flags , options ) ; } ret = http_open_cnx ( h , options ) ; if ( ret < 0 ) av_dict_free ( & s -> chained_options ) ; return ret ; }
","<S2SV_ModStart> -> filesize = UINT64_MAX <S2SV_ModEnd> ; s ->
"
556,"CWE-362 struct sock * cookie_v4_check ( struct sock * sk , struct sk_buff * skb , struct ip_options * opt ) { struct tcp_options_received tcp_opt ; u8 * hash_location ; struct inet_request_sock * ireq ; struct tcp_request_sock * treq ; struct tcp_sock * tp = tcp_sk ( sk ) ; const struct tcphdr * th = tcp_hdr ( skb ) ; __u32 cookie = ntohl ( th -> ack_seq ) - 1 ; struct sock * ret = sk ; struct request_sock * req ; int mss ; struct rtable * rt ; __u8 rcv_wscale ; bool ecn_ok ; if ( ! sysctl_tcp_syncookies || ! th -> ack || th -> rst ) goto out ; if ( tcp_synq_no_recent_overflow ( sk ) || ( mss = cookie_check ( skb , cookie ) ) == 0 ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESFAILED ) ; goto out ; } NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESRECV ) ; memset ( & tcp_opt , 0 , sizeof ( tcp_opt ) ) ; tcp_parse_options ( skb , & tcp_opt , & hash_location , 0 ) ; if ( ! cookie_check_timestamp ( & tcp_opt , & ecn_ok ) ) goto out ; ret = NULL ; req = inet_reqsk_alloc ( & tcp_request_sock_ops ) ; if ( ! req ) goto out ; ireq = inet_rsk ( req ) ; treq = tcp_rsk ( req ) ; treq -> rcv_isn = ntohl ( th -> seq ) - 1 ; treq -> snt_isn = cookie ; req -> mss = mss ; ireq -> loc_port = th -> dest ; ireq -> rmt_port = th -> source ; ireq -> loc_addr = ip_hdr ( skb ) -> daddr ; ireq -> rmt_addr = ip_hdr ( skb ) -> saddr ; ireq -> ecn_ok = ecn_ok ; ireq -> snd_wscale = tcp_opt . snd_wscale ; ireq -> sack_ok = tcp_opt . sack_ok ; ireq -> wscale_ok = tcp_opt . wscale_ok ; ireq -> tstamp_ok = tcp_opt . saw_tstamp ; req -> ts_recent = tcp_opt . saw_tstamp ? tcp_opt . rcv_tsval : 0 ; if ( opt && opt -> optlen ) { <S2SV_StartBug> int opt_size = sizeof ( struct ip_options ) + opt -> optlen ; <S2SV_EndBug> ireq -> opt = kmalloc ( opt_size , GFP_ATOMIC ) ; <S2SV_StartBug> if ( ireq -> opt != NULL && ip_options_echo ( ireq -> opt , skb ) ) { <S2SV_EndBug> kfree ( ireq -> opt ) ; ireq -> opt = NULL ; } } if ( security_inet_conn_request ( sk , skb , req ) ) { reqsk_free ( req ) ; goto out ; } req -> expires = 0UL ; req -> retrans = 0 ; { struct flowi4 fl4 ; flowi4_init_output ( & fl4 , 0 , sk -> sk_mark , RT_CONN_FLAGS ( sk ) , RT_SCOPE_UNIVERSE , IPPROTO_TCP , inet_sk_flowi_flags ( sk ) , ( opt && opt -> srr ) ? opt -> faddr : ireq -> rmt_addr , ireq -> loc_addr , th -> source , th -> dest ) ; security_req_classify_flow ( req , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_key ( sock_net ( sk ) , & fl4 ) ; if ( IS_ERR ( rt ) ) { reqsk_free ( req ) ; goto out ; } } req -> window_clamp = tp -> window_clamp ? : dst_metric ( & rt -> dst , RTAX_WINDOW ) ; tcp_select_initial_window ( tcp_full_space ( sk ) , req -> mss , & req -> rcv_wnd , & req -> window_clamp , ireq -> wscale_ok , & rcv_wscale , dst_metric ( & rt -> dst , RTAX_INITRWND ) ) ; ireq -> rcv_wscale = rcv_wscale ; ret = get_cookie_sock ( sk , skb , req , & rt -> dst ) ; out : return ret ; }
","<S2SV_ModStart> sizeof ( struct ip_options_rcu <S2SV_ModEnd> ) + opt <S2SV_ModStart> && ip_options_echo ( & ireq -> opt <S2SV_ModEnd> -> opt ,
"
557,"CWE-119 <S2SV_StartBug> int mutt_b64_decode ( char * out , const char * in ) <S2SV_EndBug> { int len = 0 ; unsigned char digit4 ; do { const unsigned char digit1 = in [ 0 ] ; if ( ( digit1 > 127 ) || ( base64val ( digit1 ) == BAD ) ) return - 1 ; const unsigned char digit2 = in [ 1 ] ; if ( ( digit2 > 127 ) || ( base64val ( digit2 ) == BAD ) ) return - 1 ; const unsigned char digit3 = in [ 2 ] ; if ( ( digit3 > 127 ) || ( ( digit3 != '=' ) && ( base64val ( digit3 ) == BAD ) ) ) return - 1 ; digit4 = in [ 3 ] ; if ( ( digit4 > 127 ) || ( ( digit4 != '=' ) && ( base64val ( digit4 ) == BAD ) ) ) return - 1 ; in += 4 ; <S2SV_StartBug> * out ++ = ( base64val ( digit1 ) << 2 ) | ( base64val ( digit2 ) >> 4 ) ; <S2SV_EndBug> len ++ ; if ( digit3 != '=' ) { <S2SV_StartBug> * out ++ = ( ( base64val ( digit2 ) << 4 ) & 0xf0 ) | ( base64val ( digit3 ) >> 2 ) ; <S2SV_EndBug> len ++ ; if ( digit4 != '=' ) { <S2SV_StartBug> * out ++ = ( ( base64val ( digit3 ) << 6 ) & 0xc0 ) | base64val ( digit4 ) ; <S2SV_EndBug> len ++ ; } } } while ( * in && digit4 != '=' ) ; return len ; }
","<S2SV_ModStart> char * in , size_t olen <S2SV_ModStart> += 4 ; if ( len == olen ) return len ; <S2SV_ModStart> '=' ) { if ( len == olen ) return len ; <S2SV_ModStart> '=' ) { if ( len == olen ) return len ;
"
558,"CWE-415 static int amd_gpio_remove ( struct platform_device * pdev ) { struct amd_gpio * gpio_dev ; gpio_dev = platform_get_drvdata ( pdev ) ; gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_StartBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> gc ) ; <S2SV_ModEnd> return 0 ;
"
559,"CWE-119 static ssize_t cifs_iovec_write ( struct file * file , const struct iovec * iov , unsigned long nr_segs , loff_t * poffset ) { unsigned long nr_pages , i ; <S2SV_StartBug> size_t copied , len , cur_len ; <S2SV_EndBug> ssize_t total_written = 0 ; loff_t offset ; struct iov_iter it ; struct cifsFileInfo * open_file ; struct cifs_tcon * tcon ; struct cifs_sb_info * cifs_sb ; struct cifs_writedata * wdata , * tmp ; struct list_head wdata_list ; int rc ; pid_t pid ; len = iov_length ( iov , nr_segs ) ; if ( ! len ) return 0 ; rc = generic_write_checks ( file , poffset , & len , 0 ) ; if ( rc ) return rc ; INIT_LIST_HEAD ( & wdata_list ) ; cifs_sb = CIFS_SB ( file -> f_path . dentry -> d_sb ) ; open_file = file -> private_data ; tcon = tlink_tcon ( open_file -> tlink ) ; if ( ! tcon -> ses -> server -> ops -> async_writev ) return - ENOSYS ; offset = * poffset ; if ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD ) pid = open_file -> pid ; else pid = current -> tgid ; iov_iter_init ( & it , iov , nr_segs , len , 0 ) ; do { size_t save_len ; nr_pages = get_numpages ( cifs_sb -> wsize , len , & cur_len ) ; wdata = cifs_writedata_alloc ( nr_pages , cifs_uncached_writev_complete ) ; if ( ! wdata ) { rc = - ENOMEM ; break ; } rc = cifs_write_allocate_pages ( wdata -> pages , nr_pages ) ; if ( rc ) { kfree ( wdata ) ; break ; } save_len = cur_len ; for ( i = 0 ; i < nr_pages ; i ++ ) { <S2SV_StartBug> copied = min_t ( const size_t , cur_len , PAGE_SIZE ) ; <S2SV_EndBug> copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it , <S2SV_StartBug> 0 , copied ) ; <S2SV_EndBug> cur_len -= copied ; iov_iter_advance ( & it , copied ) ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> cur_len = save_len - cur_len ; <S2SV_EndBug> wdata -> sync_mode = WB_SYNC_ALL ; wdata -> nr_pages = nr_pages ; wdata -> offset = ( __u64 ) offset ; wdata -> cfile = cifsFileInfo_get ( open_file ) ; wdata -> pid = pid ; wdata -> bytes = cur_len ; wdata -> pagesz = PAGE_SIZE ; wdata -> tailsz = cur_len - ( ( nr_pages - 1 ) * PAGE_SIZE ) ; rc = cifs_uncached_retry_writev ( wdata ) ; if ( rc ) { kref_put ( & wdata -> refcount , cifs_uncached_writedata_release ) ; break ; } list_add_tail ( & wdata -> list , & wdata_list ) ; offset += cur_len ; len -= cur_len ; } while ( len > 0 ) ; if ( ! list_empty ( & wdata_list ) ) rc = 0 ; restart_loop : list_for_each_entry_safe ( wdata , tmp , & wdata_list , list ) { if ( ! rc ) { rc = wait_for_completion_killable ( & wdata -> done ) ; if ( rc ) rc = - EINTR ; else if ( wdata -> result ) rc = wdata -> result ; else total_written += wdata -> bytes ; if ( rc == - EAGAIN ) { rc = cifs_uncached_retry_writev ( wdata ) ; goto restart_loop ; } } list_del_init ( & wdata -> list ) ; kref_put ( & wdata -> refcount , cifs_uncached_writedata_release ) ; } if ( total_written > 0 ) * poffset += total_written ; cifs_stats_bytes_written ( tcon , total_written ) ; return total_written ? total_written : ( ssize_t ) rc ; }
","<S2SV_ModStart> i ; size_t bytes , <S2SV_ModStart> ++ ) { bytes <S2SV_ModEnd> = min_t ( <S2SV_ModStart> , 0 , bytes <S2SV_ModEnd> ) ; cur_len <S2SV_ModStart> copied ) ; if ( copied < bytes ) break ; <S2SV_ModStart> save_len - cur_len ; if ( ! cur_len ) { for ( i = 0 ; i < nr_pages ; i ++ ) put_page ( wdata -> pages [ i ] ) ; kfree ( wdata ) ; rc = - EFAULT ; break ; } for ( ; nr_pages > i + 1 ; nr_pages -- ) put_page ( wdata -> pages [ nr_pages - 1 ] )
"
560,"CWE-000 static __u8 * cp_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { unsigned long quirks = ( unsigned long ) hid_get_drvdata ( hdev ) ; unsigned int i ; <S2SV_StartBug> if ( ! ( quirks & CP_RDESC_SWAPPED_MIN_MAX ) ) <S2SV_EndBug> return rdesc ; for ( i = 0 ; i < * rsize - 4 ; i ++ ) if ( rdesc [ i ] == 0x29 && rdesc [ i + 2 ] == 0x19 ) { rdesc [ i ] = 0x19 ; rdesc [ i + 2 ] = 0x29 ; swap ( rdesc [ i + 3 ] , rdesc [ i + 1 ] ) ; } return rdesc ; }
","<S2SV_ModStart> & CP_RDESC_SWAPPED_MIN_MAX ) ) return rdesc ; if ( * rsize < 4
"
561,"CWE-119 const char * vpx_svc_dump_statistics ( SvcContext * svc_ctx ) { <S2SV_StartBug> int number_of_frames , number_of_keyframes , encode_frame_count ; <S2SV_EndBug> int i , j ; uint32_t bytes_total = 0 ; double scale [ COMPONENTS ] ; double psnr [ COMPONENTS ] ; double mse [ COMPONENTS ] ; double y_scale ; <S2SV_StartBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <S2SV_EndBug> if ( svc_ctx == NULL || si == NULL ) return NULL ; svc_log_reset ( svc_ctx ) ; <S2SV_StartBug> encode_frame_count = si -> encode_frame_count ; <S2SV_EndBug> <S2SV_StartBug> if ( si -> encode_frame_count <= 0 ) return vpx_svc_get_message ( svc_ctx ) ; <S2SV_EndBug> svc_log ( svc_ctx , SVC_LOG_INFO , ""\\n"" ) ; <S2SV_StartBug> number_of_keyframes = encode_frame_count / si -> kf_dist + 1 ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < si -> layers ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> number_of_frames = encode_frame_count ; <S2SV_EndBug> if ( svc_ctx -> encoding_mode == ALT_INTER_LAYER_PREDICTION_IP && ( i == 1 || i == 3 ) ) { number_of_frames -= number_of_keyframes ; } svc_log ( svc_ctx , SVC_LOG_INFO , ""Layer<S2SV_blank>%d<S2SV_blank>Average<S2SV_blank>PSNR=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f],<S2SV_blank>Bytes=[%u]\\n"" , i , ( double ) si -> psnr_sum [ i ] [ 0 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 1 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 2 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 3 ] / number_of_frames , si -> bytes_sum [ i ] ) ; y_scale = si -> width * si -> height * 255.0 * 255.0 * number_of_frames ; scale [ 1 ] = y_scale ; scale [ 2 ] = scale [ 3 ] = y_scale / 4 ; scale [ 0 ] = y_scale * 1.5 ; for ( j = 0 ; j < COMPONENTS ; j ++ ) { psnr [ j ] = calc_psnr ( si -> sse_sum [ i ] [ j ] / scale [ j ] ) ; mse [ j ] = si -> sse_sum [ i ] [ j ] * 255.0 * 255.0 / scale [ j ] ; } svc_log ( svc_ctx , SVC_LOG_INFO , ""Layer<S2SV_blank>%d<S2SV_blank>Overall<S2SV_blank>PSNR=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f]\\n"" , i , psnr [ 0 ] , psnr [ 1 ] , psnr [ 2 ] , psnr [ 3 ] ) ; svc_log ( svc_ctx , SVC_LOG_INFO , ""Layer<S2SV_blank>%d<S2SV_blank>Overall<S2SV_blank>MSE=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f]\\n"" , i , mse [ 0 ] , mse [ 1 ] , mse [ 2 ] , mse [ 3 ] ) ; bytes_total += si -> bytes_sum [ i ] ; si -> bytes_sum [ i ] = 0 ; for ( j = 0 ; j < COMPONENTS ; ++ j ) { si -> psnr_sum [ i ] [ j ] = 0 ; si -> sse_sum [ i ] [ j ] = 0 ; } } <S2SV_StartBug> si -> encode_frame_count = 0 ; <S2SV_EndBug> svc_log ( svc_ctx , SVC_LOG_INFO , ""Total<S2SV_blank>Bytes=[%u]\\n"" , bytes_total ) ; return vpx_svc_get_message ( svc_ctx ) ; }
","<S2SV_ModStart> { int number_of_frames <S2SV_ModEnd> ; int i <S2SV_ModStart> double y_scale ; SvcInternal_t <S2SV_ModEnd> * const si <S2SV_ModStart> svc_ctx ) ; number_of_frames = si -> psnr_pkt_received <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( number_of_frames <S2SV_ModEnd> <= 0 ) <S2SV_ModStart> ""\\n"" ) ; <S2SV_ModEnd> for ( i <S2SV_ModStart> ; i < svc_ctx -> spatial_layers <S2SV_ModEnd> ; ++ i <S2SV_ModStart> i ) { <S2SV_ModEnd> svc_log ( svc_ctx <S2SV_ModStart> } si -> psnr_pkt_received <S2SV_ModEnd> = 0 ;
"
562,"CWE-787 <S2SV_StartBug> static void nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 originalSize ) <S2SV_EndBug> { UINT32 len ; UINT32 left ; BYTE value ; left = originalSize ; while ( left > 4 ) { value = * in ++ ; if ( left == 5 ) { <S2SV_StartBug> * out ++ = value ; <S2SV_EndBug> left -- ; } else if ( value == * in ) { in ++ ; if ( * in < 0xFF ) { len = ( UINT32 ) * in ++ ; len += 2 ; } else { in ++ ; len = * ( ( UINT32 * ) in ) ; in += 4 ; } <S2SV_StartBug> FillMemory ( out , len , value ) ; <S2SV_EndBug> out += len ; left -= len ; } else { <S2SV_StartBug> * out ++ = value ; <S2SV_EndBug> left -- ; } } * ( ( UINT32 * ) out ) = * ( ( UINT32 * ) in ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decode ( BYTE <S2SV_ModStart> BYTE * out , UINT32 outSize <S2SV_ModStart> 5 ) { if ( outSize < 1 ) return FALSE ; outSize -- ; <S2SV_ModStart> 4 ; } if ( outSize < len ) return FALSE ; outSize -= len ; <S2SV_ModStart> } else { if ( outSize < 1 ) return FALSE ; outSize -- ; * out ++ = value ; left -- ; } } if ( ( outSize < 4 ) || ( left < 4 ) ) return FALSE ; memcpy ( out , in , 4 ) ; return TRUE <S2SV_ModEnd> ; } <S2SV_null>
"
563,"CWE-476 static int resize ( int new_rows , int new_cols , VTermPos * delta , void * user ) { VTermScreen * screen = user ; int is_altscreen = ( screen -> buffers [ 1 ] && screen -> buffer == screen -> buffers [ 1 ] ) ; int old_rows = screen -> rows ; int old_cols = screen -> cols ; int first_blank_row ; if ( ! is_altscreen && new_rows < old_rows ) { VTermPos pos = { 0 , 0 } ; VTermPos cursor = screen -> state -> pos ; for ( pos . row = old_rows - 1 ; pos . row >= new_rows ; pos . row -- ) if ( ! vterm_screen_is_eol ( screen , pos ) || cursor . row == pos . row ) break ; first_blank_row = pos . row + 1 ; if ( first_blank_row > new_rows ) { VTermRect rect = { 0 , 0 , 0 , 0 } ; rect . end_row = old_rows ; rect . end_col = old_cols ; scrollrect ( rect , first_blank_row - new_rows , 0 , user ) ; vterm_screen_flush_damage ( screen ) ; delta -> row -= first_blank_row - new_rows ; } } screen -> buffers [ 0 ] = realloc_buffer ( screen , screen -> buffers [ 0 ] , new_rows , new_cols ) ; if ( screen -> buffers [ 1 ] ) screen -> buffers [ 1 ] = realloc_buffer ( screen , screen -> buffers [ 1 ] , new_rows , new_cols ) ; screen -> buffer = is_altscreen ? screen -> buffers [ 1 ] : screen -> buffers [ 0 ] ; screen -> rows = new_rows ; screen -> cols = new_cols ; <S2SV_StartBug> if ( screen -> sb_buffer ) <S2SV_EndBug> vterm_allocator_free ( screen -> vt , screen -> sb_buffer ) ; screen -> sb_buffer = vterm_allocator_malloc ( screen -> vt , sizeof ( VTermScreenCell ) * new_cols ) ; if ( new_cols > old_cols ) { VTermRect rect ; rect . start_row = 0 ; rect . end_row = old_rows ; rect . start_col = old_cols ; rect . end_col = new_cols ; damagerect ( screen , rect ) ; } if ( new_rows > old_rows ) { if ( ! is_altscreen && screen -> callbacks && screen -> callbacks -> sb_popline ) { int rows = new_rows - old_rows ; while ( rows ) { VTermRect rect = { 0 , 0 , 0 , 0 } ; VTermPos pos = { 0 , 0 } ; if ( ! ( screen -> callbacks -> sb_popline ( screen -> cols , screen -> sb_buffer , screen -> cbdata ) ) ) break ; rect . end_row = screen -> rows ; rect . end_col = screen -> cols ; scrollrect ( rect , - 1 , 0 , user ) ; for ( pos . col = 0 ; pos . col < screen -> cols ; pos . col += screen -> sb_buffer [ pos . col ] . width ) vterm_screen_set_cell ( screen , pos , screen -> sb_buffer + pos . col ) ; rect . end_row = 1 ; damagerect ( screen , rect ) ; vterm_screen_flush_damage ( screen ) ; rows -- ; delta -> row ++ ; } } { VTermRect rect ; rect . start_row = old_rows ; rect . end_row = new_rows ; rect . start_col = 0 ; rect . end_col = new_cols ; damagerect ( screen , rect ) ; } } if ( screen -> callbacks && screen -> callbacks -> resize ) return ( * screen -> callbacks -> resize ) ( new_rows , new_cols , screen -> cbdata ) ; return 1 ; }
","<S2SV_ModStart> = new_cols ; <S2SV_ModEnd> vterm_allocator_free ( screen
"
564,"CWE-125 static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { <S2SV_StartBug> const char * literal_start = * str ; <S2SV_EndBug> const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; <S2SV_StartBug> for ( ; * str < end ; ( * str ) ++ ) { <S2SV_EndBug> char ch = * * str ; <S2SV_StartBug> if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && <S2SV_EndBug> * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { <S2SV_StartBug> in_named_escape = 0 ; <S2SV_EndBug> } else if ( ch == '{' || ch == '}' ) { if ( recurse_lvl == 0 ) { <S2SV_StartBug> if ( * str + 1 < end && * ( * str + 1 ) == ch ) { <S2SV_EndBug> literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { <S2SV_StartBug> ast_error ( c , n , ""f-string:<S2SV_blank>single<S2SV_blank>\'}\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed"" ) ; <S2SV_EndBug> return - 1 ; } } <S2SV_StartBug> break ; <S2SV_EndBug> } } <S2SV_StartBug> literal_end = * str ; <S2SV_EndBug> <S2SV_StartBug> assert ( * str <= end ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( * str == end || * * str == '{' || * * str == '}' ) ; <S2SV_EndBug> done : <S2SV_StartBug> if ( literal_start != literal_end ) { <S2SV_EndBug> if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , <S2SV_StartBug> literal_end - literal_start , <S2SV_EndBug> NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , <S2SV_StartBug> literal_end - literal_start ) ; <S2SV_EndBug> if ( ! * literal ) return - 1 ; } return result ; }
","<S2SV_ModStart> const char * s = * str ; const char * literal_start = s <S2SV_ModEnd> ; int result <S2SV_ModStart> NULL ) ; while ( s < end ) { char ch = * s ++ <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( ! raw && ch == '\\\\' && s < end ) { ch = * s ++ ; if ( ch == 'N' ) { if ( s < end && * s ++ == '{' ) { while ( s < end && * s ++ != <S2SV_ModEnd> '}' ) { <S2SV_ModStart> '}' ) { } continue ; } break ; } if ( ch == '{' && warn_invalid_escape_sequence ( c , n , ch ) < 0 ) { return - 1 ; } } <S2SV_ModEnd> if ( ch <S2SV_ModStart> { if ( s < end && * s == ch ) { * str = s + 1 <S2SV_ModEnd> ; result = <S2SV_ModStart> '}' ) { * str = s - 1 ; <S2SV_ModStart> ; } } s -- ; <S2SV_ModStart> ; } } * str = s <S2SV_ModEnd> ; assert ( <S2SV_ModStart> ; assert ( s <S2SV_ModEnd> <= end ) <S2SV_ModStart> ; assert ( s <S2SV_ModEnd> == end || <S2SV_ModStart> end || * s <S2SV_ModEnd> == '{' || <S2SV_ModStart> '{' || * s <S2SV_ModEnd> == '}' ) <S2SV_ModStart> ( literal_start != s <S2SV_ModEnd> ) { if <S2SV_ModStart> ( literal_start , s <S2SV_ModEnd> - literal_start , <S2SV_ModStart> , literal_start , s <S2SV_ModEnd> - literal_start )
"
565,"CWE-190 <S2SV_StartBug> static int mem_resize ( jas_stream_memobj_t * m , int bufsize ) <S2SV_EndBug> { unsigned char * buf ; <S2SV_StartBug> assert ( bufsize >= 0 ) ; <S2SV_EndBug> <S2SV_StartBug> JAS_DBGLOG ( 100 , ( ""mem_resize(%p,<S2SV_blank>%d)\\n"" , m , bufsize ) ) ; <S2SV_EndBug> if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) { JAS_DBGLOG ( 100 , ( ""mem_resize<S2SV_blank>realloc<S2SV_blank>failed\\n"" ) ) ; return - 1 ; } JAS_DBGLOG ( 100 , ( ""mem_resize<S2SV_blank>realloc<S2SV_blank>succeeded\\n"" ) ) ; m -> buf_ = buf ; m -> bufsize_ = bufsize ; return 0 ; }
","<S2SV_ModStart> * m , size_t <S2SV_ModEnd> bufsize ) { <S2SV_ModStart> * buf ; <S2SV_ModEnd> JAS_DBGLOG ( 100 <S2SV_ModStart> 100 , ( ""mem_resize(%p,<S2SV_blank>%zu)\\n"" <S2SV_ModEnd> , m , <S2SV_ModStart> ) ) ; if ( ! bufsize ) { jas_eprintf ( ""mem_resize<S2SV_blank>was<S2SV_blank>not<S2SV_blank>really<S2SV_blank>designed<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>a<S2SV_blank>buffer<S2SV_blank>of<S2SV_blank>size<S2SV_blank>0\\n"" ""This<S2SV_blank>may<S2SV_blank>not<S2SV_blank>work.\\n"" ) ; }
"
566,"CWE-200 char * problem_data_save ( problem_data_t * pd ) { load_abrt_conf ( ) ; <S2SV_StartBug> struct dump_dir * dd = create_dump_dir_from_problem_data ( pd , g_settings_dump_location ) ; <S2SV_EndBug> char * problem_id = NULL ; if ( dd ) { problem_id = xstrdup ( dd -> dd_dirname ) ; dd_close ( dd ) ; } log_info ( ""problem<S2SV_blank>id:<S2SV_blank>\'%s\'"" , problem_id ) ; return problem_id ; }
","<S2SV_ModStart> struct dump_dir * dd = NULL ; if ( g_settings_privatereports ) dd = create_dump_dir_from_problem_data_ext ( pd , g_settings_dump_location , 0 ) ; else
"
567,"CWE-476 static bool ResolveStateAndPredicate ( ExprDef * expr , enum xkb_match_operation * pred_rtrn , xkb_mod_mask_t * mods_rtrn , CompatInfo * info ) { if ( expr == NULL ) { * pred_rtrn = MATCH_ANY_OR_NONE ; * mods_rtrn = MOD_REAL_MASK_ALL ; return true ; } * pred_rtrn = MATCH_EXACTLY ; if ( expr -> expr . op == EXPR_ACTION_DECL ) { const char * pred_txt = xkb_atom_text ( info -> ctx , expr -> action . name ) ; <S2SV_StartBug> if ( ! LookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) ) { <S2SV_EndBug> log_err ( info -> ctx , ""Illegal<S2SV_blank>modifier<S2SV_blank>predicate<S2SV_blank>\\""%s\\"";<S2SV_blank>Ignored\\n"" , pred_txt ) ; return false ; } expr = expr -> action . args ; } else if ( expr -> expr . op == EXPR_IDENT ) { const char * pred_txt = xkb_atom_text ( info -> ctx , expr -> ident . ident ) ; if ( pred_txt && istreq ( pred_txt , ""any"" ) ) { * pred_rtrn = MATCH_ANY ; * mods_rtrn = MOD_REAL_MASK_ALL ; return true ; } } return ExprResolveModMask ( info -> ctx , expr , MOD_REAL , & info -> mods , mods_rtrn ) ; }
","<S2SV_ModStart> , pred_rtrn ) || ! expr -> action . args
"
568,"CWE-763 <S2SV_StartBug> static void pcrypt_free ( struct crypto_instance * inst ) <S2SV_EndBug> { <S2SV_StartBug> struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ; <S2SV_EndBug> crypto_drop_aead ( & ctx -> spawn ) ; kfree ( inst ) ; }
","<S2SV_ModStart> pcrypt_free ( struct aead_instance <S2SV_ModEnd> * inst ) <S2SV_ModStart> * ctx = aead_instance_ctx <S2SV_ModEnd> ( inst )
"
569,"CWE-190 void rfbScaledScreenUpdateRect ( rfbScreenInfoPtr screen , rfbScreenInfoPtr ptr , int x0 , int y0 , int w0 , int h0 ) { int x , y , w , v , z ; int x1 , y1 , w1 , h1 ; int bitsPerPixel , bytesPerPixel , bytesPerLine , areaX , areaY , area2 ; unsigned char * srcptr , * dstptr ; if ( screen == ptr ) return ; x1 = x0 ; y1 = y0 ; w1 = w0 ; h1 = h0 ; rfbScaledCorrection ( screen , ptr , & x1 , & y1 , & w1 , & h1 , ""rfbScaledScreenUpdateRect"" ) ; x0 = ScaleX ( ptr , screen , x1 ) ; y0 = ScaleY ( ptr , screen , y1 ) ; w0 = ScaleX ( ptr , screen , w1 ) ; h0 = ScaleY ( ptr , screen , h1 ) ; bitsPerPixel = screen -> bitsPerPixel ; bytesPerPixel = bitsPerPixel / 8 ; bytesPerLine = w1 * bytesPerPixel ; srcptr = ( unsigned char * ) ( screen -> frameBuffer + ( y0 * screen -> paddedWidthInBytes + x0 * bytesPerPixel ) ) ; dstptr = ( unsigned char * ) ( ptr -> frameBuffer + ( y1 * ptr -> paddedWidthInBytes + x1 * bytesPerPixel ) ) ; areaX = ScaleX ( ptr , screen , 1 ) ; areaY = ScaleY ( ptr , screen , 1 ) ; area2 = areaX * areaY ; if ( ( x1 + w1 ) > ( ptr -> width ) ) { if ( x1 == 0 ) w1 = ptr -> width ; else x1 = ptr -> width - w1 ; } if ( ( y1 + h1 ) > ( ptr -> height ) ) { if ( y1 == 0 ) h1 = ptr -> height ; else y1 = ptr -> height - h1 ; } if ( screen -> serverFormat . trueColour ) { unsigned char * srcptr2 ; unsigned long pixel_value , red , green , blue ; unsigned int redShift = screen -> serverFormat . redShift ; unsigned int greenShift = screen -> serverFormat . greenShift ; unsigned int blueShift = screen -> serverFormat . blueShift ; unsigned long redMax = screen -> serverFormat . redMax ; unsigned long greenMax = screen -> serverFormat . greenMax ; unsigned long blueMax = screen -> serverFormat . blueMax ; for ( y = 0 ; y < h1 ; y ++ ) { for ( x = 0 ; x < w1 ; x ++ ) { red = green = blue = 0 ; for ( w = 0 ; w < areaX ; w ++ ) { for ( v = 0 ; v < areaY ; v ++ ) { srcptr2 = & srcptr [ ( ( ( x * areaX ) + w ) * bytesPerPixel ) + ( v * screen -> paddedWidthInBytes ) ] ; pixel_value = 0 ; switch ( bytesPerPixel ) { case 4 : pixel_value = * ( ( unsigned int * ) srcptr2 ) ; break ; case 2 : pixel_value = * ( ( unsigned short * ) srcptr2 ) ; break ; case 1 : pixel_value = * ( ( unsigned char * ) srcptr2 ) ; break ; default : for ( z = 0 ; z < bytesPerPixel ; z ++ ) <S2SV_StartBug> pixel_value += ( srcptr2 [ z ] << ( 8 * z ) ) ; <S2SV_EndBug> break ; } red += ( ( pixel_value >> redShift ) & redMax ) ; green += ( ( pixel_value >> greenShift ) & greenMax ) ; blue += ( ( pixel_value >> blueShift ) & blueMax ) ; } } red /= area2 ; green /= area2 ; blue /= area2 ; pixel_value = ( ( red & redMax ) << redShift ) | ( ( green & greenMax ) << greenShift ) | ( ( blue & blueMax ) << blueShift ) ; switch ( bytesPerPixel ) { case 4 : * ( ( unsigned int * ) dstptr ) = ( unsigned int ) pixel_value ; break ; case 2 : * ( ( unsigned short * ) dstptr ) = ( unsigned short ) pixel_value ; break ; case 1 : * ( ( unsigned char * ) dstptr ) = ( unsigned char ) pixel_value ; break ; default : for ( z = 0 ; z < bytesPerPixel ; z ++ ) dstptr [ z ] = ( pixel_value >> ( 8 * z ) ) & 0xff ; break ; } dstptr += bytesPerPixel ; } srcptr += ( screen -> paddedWidthInBytes * areaY ) ; dstptr += ( ptr -> paddedWidthInBytes - bytesPerLine ) ; } } else { for ( y = y1 ; y < ( y1 + h1 ) ; y ++ ) { for ( x = x1 ; x < ( x1 + w1 ) ; x ++ ) memcpy ( & ptr -> frameBuffer [ ( y * ptr -> paddedWidthInBytes ) + ( x * bytesPerPixel ) ] , & screen -> frameBuffer [ ( y * areaY * screen -> paddedWidthInBytes ) + ( x * areaX * bytesPerPixel ) ] , bytesPerPixel ) ; } } }
","<S2SV_ModStart> pixel_value += ( ( unsigned long )
"
570,"CWE-125 static Image * ReadSGIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; SGIInfo iris_info ; size_t bytes_per_pixel , quantum ; ssize_t count , y , z ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } iris_info . magic = ReadBlobMSBShort ( image ) ; do { if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ; switch ( iris_info . storage ) { case 0x00 : image -> compression = NoCompression ; break ; case 0x01 : image -> compression = RLECompression ; break ; default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . dimension = ReadBlobMSBShort ( image ) ; iris_info . columns = ReadBlobMSBShort ( image ) ; iris_info . rows = ReadBlobMSBShort ( image ) ; iris_info . depth = ReadBlobMSBShort ( image ) ; if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . minimum_value = ReadBlobMSBLong ( image ) ; iris_info . maximum_value = ReadBlobMSBLong ( image ) ; iris_info . sans = ReadBlobMSBLong ( image ) ; ( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) iris_info . name ) ; iris_info . name [ sizeof ( iris_info . name ) - 1 ] = '\\0' ; if ( * iris_info . name != '\\0' ) ( void ) SetImageProperty ( image , ""label"" , iris_info . name , exception ) ; iris_info . pixel_format = ReadBlobMSBLong ( image ) ; if ( iris_info . pixel_format != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , sizeof ( iris_info . filler ) , iris_info . filler ) ; ( void ) count ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; image -> depth = ( size_t ) MagickMin ( iris_info . depth , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . pixel_format == 0 ) image -> depth = ( size_t ) MagickMin ( ( size_t ) 8 * iris_info . bytes_per_pixel , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . depth < 3 ) { image -> storage_class = PseudoClass ; image -> colors = iris_info . bytes_per_pixel > 1 ? 65535 : 256 ; } <S2SV_StartBug> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) <S2SV_EndBug> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_pixel = ( size_t ) iris_info . bytes_per_pixel ; number_pixels = ( MagickSizeType ) iris_info . columns * iris_info . rows ; if ( ( 4 * bytes_per_pixel * number_pixels ) != ( ( MagickSizeType ) ( size_t ) ( 4 * bytes_per_pixel * number_pixels ) ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( iris_info . columns , iris_info . rows * 4 * bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( int ) iris_info . storage != 0x01 ) { unsigned char * scanline ; scanline = ( unsigned char * ) AcquireQuantumMemory ( iris_info . columns , bytes_per_pixel * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels + bytes_per_pixel * z ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { count = ReadBlob ( image , bytes_per_pixel * iris_info . columns , scanline ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; if ( bytes_per_pixel == 2 ) for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ 2 * x ] ; * ( p + 1 ) = scanline [ 2 * x + 1 ] ; p += 8 ; } else for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ x ] ; p += 4 ; } } } scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; } else { MemoryInfo * packet_info ; size_t * runlength ; ssize_t offset , * offsets ; unsigned char * packets ; unsigned int data_order ; offsets = ( ssize_t * ) AcquireQuantumMemory ( ( size_t ) iris_info . rows , iris_info . depth * sizeof ( * offsets ) ) ; runlength = ( size_t * ) AcquireQuantumMemory ( iris_info . rows , iris_info . depth * sizeof ( * runlength ) ) ; packet_info = AcquireVirtualMemory ( ( size_t ) iris_info . columns + 10UL , 4UL * sizeof ( * packets ) ) ; if ( ( offsets == ( ssize_t * ) NULL ) || ( runlength == ( size_t * ) NULL ) || ( packet_info == ( MemoryInfo * ) NULL ) ) { if ( offsets == ( ssize_t * ) NULL ) offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; if ( runlength == ( size_t * ) NULL ) runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; if ( packet_info == ( MemoryInfo * ) NULL ) packet_info = RelinquishVirtualMemory ( packet_info ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } packets = ( unsigned char * ) GetVirtualMemoryBlob ( packet_info ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) offsets [ i ] = ReadBlobMSBSignedLong ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) { runlength [ i ] = ReadBlobMSBLong ( image ) ; if ( runlength [ i ] > ( 4 * ( size_t ) iris_info . columns + 10 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } offset = 0 ; data_order = 0 ; for ( y = 0 ; ( ( y < ( ssize_t ) iris_info . rows ) && ( data_order == 0 ) ) ; y ++ ) for ( z = 0 ; ( ( z < ( ssize_t ) iris_info . depth ) && ( data_order == 0 ) ) ; z ++ ) { if ( offsets [ y + z * iris_info . rows ] < offset ) data_order = 1 ; offset = offsets [ y + z * iris_info . rows ] ; } offset = ( ssize_t ) TellBlob ( image ) ; if ( data_order == 1 ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } } } else { MagickOffsetType position ; position = TellBlob ( image ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } offset = ( ssize_t ) SeekBlob ( image , position , SEEK_SET ) ; } packet_info = RelinquishVirtualMemory ( packet_info ) ; runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; } image -> alpha_trait = iris_info . depth == 4 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; if ( image -> storage_class == DirectClass ) { if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 0 ) << 8 ) | ( * ( p + 1 ) ) ) ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 2 ) << 8 ) | ( * ( p + 3 ) ) ) ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 4 ) << 8 ) | ( * ( p + 5 ) ) ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 6 ) << 8 ) | ( * ( p + 7 ) ) ) ) , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { quantum = ( * p << 8 ) ; quantum |= ( * ( p + 1 ) ) ; SetPixelIndex ( image , ( Quantum ) quantum , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; iris_info . magic = ReadBlobMSBShort ( image ) ; if ( iris_info . magic == 0x01DA ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( iris_info . magic == 0x01DA ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> } if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if (
"
571,"CWE-17 static void ndisc_router_discovery ( struct sk_buff * skb ) { struct ra_msg * ra_msg = ( struct ra_msg * ) skb_transport_header ( skb ) ; struct neighbour * neigh = NULL ; struct inet6_dev * in6_dev ; struct rt6_info * rt = NULL ; int lifetime ; struct ndisc_options ndopts ; int optlen ; unsigned int pref = 0 ; __u8 * opt = ( __u8 * ) ( ra_msg + 1 ) ; optlen = ( skb_tail_pointer ( skb ) - skb_transport_header ( skb ) ) - sizeof ( struct ra_msg ) ; ND_PRINTK ( 2 , info , ""RA:<S2SV_blank>%s,<S2SV_blank>dev:<S2SV_blank>%s\\n"" , __func__ , skb -> dev -> name ) ; if ( ! ( ipv6_addr_type ( & ipv6_hdr ( skb ) -> saddr ) & IPV6_ADDR_LINKLOCAL ) ) { ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>source<S2SV_blank>address<S2SV_blank>is<S2SV_blank>not<S2SV_blank>link-local\\n"" ) ; return ; } if ( optlen < 0 ) { ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>short\\n"" ) ; return ; } # ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_HOST ) { ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>from<S2SV_blank>host<S2SV_blank>or<S2SV_blank>unauthorized<S2SV_blank>router\\n"" ) ; return ; } # endif in6_dev = __in6_dev_get ( skb -> dev ) ; if ( in6_dev == NULL ) { ND_PRINTK ( 0 , err , ""RA:<S2SV_blank>can\'t<S2SV_blank>find<S2SV_blank>inet6<S2SV_blank>device<S2SV_blank>for<S2SV_blank>%s\\n"" , skb -> dev -> name ) ; return ; } if ( ! ndisc_parse_options ( opt , optlen , & ndopts ) ) { ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>invalid<S2SV_blank>ND<S2SV_blank>options\\n"" ) ; return ; } if ( ! ipv6_accept_ra ( in6_dev ) ) { ND_PRINTK ( 2 , info , ""RA:<S2SV_blank>%s,<S2SV_blank>did<S2SV_blank>not<S2SV_blank>accept<S2SV_blank>ra<S2SV_blank>for<S2SV_blank>dev:<S2SV_blank>%s\\n"" , __func__ , skb -> dev -> name ) ; goto skip_linkparms ; } # ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT ) { ND_PRINTK ( 2 , info , ""RA:<S2SV_blank>%s,<S2SV_blank>nodetype<S2SV_blank>is<S2SV_blank>NODEFAULT,<S2SV_blank>dev:<S2SV_blank>%s\\n"" , __func__ , skb -> dev -> name ) ; goto skip_linkparms ; } # endif if ( in6_dev -> if_flags & IF_RS_SENT ) { in6_dev -> if_flags |= IF_RA_RCVD ; } in6_dev -> if_flags = ( in6_dev -> if_flags & ~ ( IF_RA_MANAGED | IF_RA_OTHERCONF ) ) | ( ra_msg -> icmph . icmp6_addrconf_managed ? IF_RA_MANAGED : 0 ) | ( ra_msg -> icmph . icmp6_addrconf_other ? IF_RA_OTHERCONF : 0 ) ; if ( ! in6_dev -> cnf . accept_ra_defrtr ) { ND_PRINTK ( 2 , info , ""RA:<S2SV_blank>%s,<S2SV_blank>defrtr<S2SV_blank>is<S2SV_blank>false<S2SV_blank>for<S2SV_blank>dev:<S2SV_blank>%s\\n"" , __func__ , skb -> dev -> name ) ; goto skip_defrtr ; } if ( ! in6_dev -> cnf . accept_ra_from_local && ipv6_chk_addr ( dev_net ( in6_dev -> dev ) , & ipv6_hdr ( skb ) -> saddr , NULL , 0 ) ) { ND_PRINTK ( 2 , info , ""RA<S2SV_blank>from<S2SV_blank>local<S2SV_blank>address<S2SV_blank>detected<S2SV_blank>on<S2SV_blank>dev:<S2SV_blank>%s:<S2SV_blank>default<S2SV_blank>router<S2SV_blank>ignored\\n"" , skb -> dev -> name ) ; goto skip_defrtr ; } lifetime = ntohs ( ra_msg -> icmph . icmp6_rt_lifetime ) ; # ifdef CONFIG_IPV6_ROUTER_PREF pref = ra_msg -> icmph . icmp6_router_pref ; if ( pref == ICMPV6_ROUTER_PREF_INVALID || ! in6_dev -> cnf . accept_ra_rtr_pref ) pref = ICMPV6_ROUTER_PREF_MEDIUM ; # endif rt = rt6_get_dflt_router ( & ipv6_hdr ( skb ) -> saddr , skb -> dev ) ; if ( rt ) { neigh = dst_neigh_lookup ( & rt -> dst , & ipv6_hdr ( skb ) -> saddr ) ; if ( ! neigh ) { ND_PRINTK ( 0 , err , ""RA:<S2SV_blank>%s<S2SV_blank>got<S2SV_blank>default<S2SV_blank>router<S2SV_blank>without<S2SV_blank>neighbour\\n"" , __func__ ) ; ip6_rt_put ( rt ) ; return ; } } if ( rt && lifetime == 0 ) { ip6_del_rt ( rt ) ; rt = NULL ; } ND_PRINTK ( 3 , info , ""RA:<S2SV_blank>rt:<S2SV_blank>%p<S2SV_blank><S2SV_blank>lifetime:<S2SV_blank>%d,<S2SV_blank>for<S2SV_blank>dev:<S2SV_blank>%s\\n"" , rt , lifetime , skb -> dev -> name ) ; if ( rt == NULL && lifetime ) { ND_PRINTK ( 3 , info , ""RA:<S2SV_blank>adding<S2SV_blank>default<S2SV_blank>router\\n"" ) ; rt = rt6_add_dflt_router ( & ipv6_hdr ( skb ) -> saddr , skb -> dev , pref ) ; if ( rt == NULL ) { ND_PRINTK ( 0 , err , ""RA:<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>default<S2SV_blank>route\\n"" , __func__ ) ; return ; } neigh = dst_neigh_lookup ( & rt -> dst , & ipv6_hdr ( skb ) -> saddr ) ; if ( neigh == NULL ) { ND_PRINTK ( 0 , err , ""RA:<S2SV_blank>%s<S2SV_blank>got<S2SV_blank>default<S2SV_blank>router<S2SV_blank>without<S2SV_blank>neighbour\\n"" , __func__ ) ; ip6_rt_put ( rt ) ; return ; } neigh -> flags |= NTF_ROUTER ; } else if ( rt ) { rt -> rt6i_flags = ( rt -> rt6i_flags & ~ RTF_PREF_MASK ) | RTF_PREF ( pref ) ; } if ( rt ) rt6_set_expires ( rt , jiffies + ( HZ * lifetime ) ) ; if ( ra_msg -> icmph . icmp6_hop_limit ) { <S2SV_StartBug> in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ; <S2SV_EndBug> if ( rt ) dst_metric_set ( & rt -> dst , RTAX_HOPLIMIT , ra_msg -> icmph . icmp6_hop_limit ) ; } skip_defrtr : if ( in6_dev -> nd_parms ) { unsigned long rtime = ntohl ( ra_msg -> retrans_timer ) ; if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / HZ ) { rtime = ( rtime * HZ ) / 1000 ; if ( rtime < HZ / 10 ) rtime = HZ / 10 ; NEIGH_VAR_SET ( in6_dev -> nd_parms , RETRANS_TIME , rtime ) ; in6_dev -> tstamp = jiffies ; inet6_ifinfo_notify ( RTM_NEWLINK , in6_dev ) ; } rtime = ntohl ( ra_msg -> reachable_time ) ; if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / ( 3 * HZ ) ) { rtime = ( rtime * HZ ) / 1000 ; if ( rtime < HZ / 10 ) rtime = HZ / 10 ; if ( rtime != NEIGH_VAR ( in6_dev -> nd_parms , BASE_REACHABLE_TIME ) ) { NEIGH_VAR_SET ( in6_dev -> nd_parms , BASE_REACHABLE_TIME , rtime ) ; NEIGH_VAR_SET ( in6_dev -> nd_parms , GC_STALETIME , 3 * rtime ) ; in6_dev -> nd_parms -> reachable_time = neigh_rand_reach_time ( rtime ) ; in6_dev -> tstamp = jiffies ; inet6_ifinfo_notify ( RTM_NEWLINK , in6_dev ) ; } } } skip_linkparms : if ( ! neigh ) neigh = __neigh_lookup ( & nd_tbl , & ipv6_hdr ( skb ) -> saddr , skb -> dev , 1 ) ; if ( neigh ) { u8 * lladdr = NULL ; if ( ndopts . nd_opts_src_lladdr ) { lladdr = ndisc_opt_addr_data ( ndopts . nd_opts_src_lladdr , skb -> dev ) ; if ( ! lladdr ) { ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>invalid<S2SV_blank>link-layer<S2SV_blank>address<S2SV_blank>length\\n"" ) ; goto out ; } } neigh_update ( neigh , lladdr , NUD_STALE , NEIGH_UPDATE_F_WEAK_OVERRIDE | NEIGH_UPDATE_F_OVERRIDE | NEIGH_UPDATE_F_OVERRIDE_ISROUTER | NEIGH_UPDATE_F_ISROUTER ) ; } if ( ! ipv6_accept_ra ( in6_dev ) ) { ND_PRINTK ( 2 , info , ""RA:<S2SV_blank>%s,<S2SV_blank>accept_ra<S2SV_blank>is<S2SV_blank>false<S2SV_blank>for<S2SV_blank>dev:<S2SV_blank>%s\\n"" , __func__ , skb -> dev -> name ) ; goto out ; } # ifdef CONFIG_IPV6_ROUTE_INFO if ( ! in6_dev -> cnf . accept_ra_from_local && ipv6_chk_addr ( dev_net ( in6_dev -> dev ) , & ipv6_hdr ( skb ) -> saddr , NULL , 0 ) ) { ND_PRINTK ( 2 , info , ""RA<S2SV_blank>from<S2SV_blank>local<S2SV_blank>address<S2SV_blank>detected<S2SV_blank>on<S2SV_blank>dev:<S2SV_blank>%s:<S2SV_blank>router<S2SV_blank>info<S2SV_blank>ignored.\\n"" , skb -> dev -> name ) ; goto skip_routeinfo ; } if ( in6_dev -> cnf . accept_ra_rtr_pref && ndopts . nd_opts_ri ) { struct nd_opt_hdr * p ; for ( p = ndopts . nd_opts_ri ; p ; p = ndisc_next_option ( p , ndopts . nd_opts_ri_end ) ) { struct route_info * ri = ( struct route_info * ) p ; # ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT && ri -> prefix_len == 0 ) continue ; # endif if ( ri -> prefix_len == 0 && ! in6_dev -> cnf . accept_ra_defrtr ) continue ; if ( ri -> prefix_len > in6_dev -> cnf . accept_ra_rt_info_max_plen ) continue ; rt6_route_rcv ( skb -> dev , ( u8 * ) p , ( p -> nd_opt_len ) << 3 , & ipv6_hdr ( skb ) -> saddr ) ; } } skip_routeinfo : # endif # ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT ) { ND_PRINTK ( 2 , info , ""RA:<S2SV_blank>%s,<S2SV_blank>nodetype<S2SV_blank>is<S2SV_blank>NODEFAULT<S2SV_blank>(interior<S2SV_blank>routes),<S2SV_blank>dev:<S2SV_blank>%s\\n"" , __func__ , skb -> dev -> name ) ; goto out ; } # endif if ( in6_dev -> cnf . accept_ra_pinfo && ndopts . nd_opts_pi ) { struct nd_opt_hdr * p ; for ( p = ndopts . nd_opts_pi ; p ; p = ndisc_next_option ( p , ndopts . nd_opts_pi_end ) ) { addrconf_prefix_rcv ( skb -> dev , ( u8 * ) p , ( p -> nd_opt_len ) << 3 , ndopts . nd_opts_src_lladdr != NULL ) ; } } if ( ndopts . nd_opts_mtu && in6_dev -> cnf . accept_ra_mtu ) { __be32 n ; u32 mtu ; memcpy ( & n , ( ( u8 * ) ( ndopts . nd_opts_mtu + 1 ) ) + 2 , sizeof ( mtu ) ) ; mtu = ntohl ( n ) ; if ( mtu < IPV6_MIN_MTU || mtu > skb -> dev -> mtu ) { ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>invalid<S2SV_blank>mtu:<S2SV_blank>%d\\n"" , mtu ) ; } else if ( in6_dev -> cnf . mtu6 != mtu ) { in6_dev -> cnf . mtu6 = mtu ; if ( rt ) dst_metric_set ( & rt -> dst , RTAX_MTU , mtu ) ; rt6_mtu_change ( skb -> dev , mtu ) ; } } if ( ndopts . nd_useropts ) { struct nd_opt_hdr * p ; for ( p = ndopts . nd_useropts ; p ; p = ndisc_next_useropt ( p , ndopts . nd_useropts_end ) ) { ndisc_ra_useropt ( skb , p ) ; } } if ( ndopts . nd_opts_tgt_lladdr || ndopts . nd_opts_rh ) { ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>invalid<S2SV_blank>RA<S2SV_blank>options\\n"" ) ; } out : ip6_rt_put ( rt ) ; if ( neigh ) neigh_release ( neigh ) ; }
","<S2SV_ModStart> icmp6_hop_limit ) { if ( <S2SV_ModStart> cnf . hop_limit < <S2SV_ModEnd> ra_msg -> icmph <S2SV_ModStart> icmph . icmp6_hop_limit ) { in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ; } else { ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>Got<S2SV_blank>route<S2SV_blank>advertisement<S2SV_blank>with<S2SV_blank>lower<S2SV_blank>hop_limit<S2SV_blank>than<S2SV_blank>current\\n"" ) ; } <S2SV_ModEnd> if ( rt
"
572,"CWE-125 static void <S2SV_StartBug> l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) & L2TP_PROXY_AUTH_ID_MASK ) ) ; }
","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }
"
573,"CWE-200 static inline int xfrm_replay_verify_len ( struct xfrm_replay_state_esn * replay_esn , struct nlattr * rp ) { struct xfrm_replay_state_esn * up ; <S2SV_StartBug> if ( ! replay_esn || ! rp ) <S2SV_EndBug> return 0 ; up = nla_data ( rp ) ; <S2SV_StartBug> if ( xfrm_replay_state_esn_len ( replay_esn ) != <S2SV_EndBug> <S2SV_StartBug> xfrm_replay_state_esn_len ( up ) ) <S2SV_EndBug> return - EINVAL ; return 0 ; }
","<S2SV_ModStart> * up ; int ulen ; <S2SV_ModStart> rp ) ; ulen = xfrm_replay_state_esn_len ( up ) ; if ( nla_len ( rp ) < ulen || <S2SV_ModEnd> xfrm_replay_state_esn_len ( replay_esn <S2SV_ModStart> replay_esn ) != ulen <S2SV_ModEnd> ) return -
"
574,"CWE-190 int perf_cpu_time_max_percent_handler ( struct ctl_table * table , int write , void __user * buffer , size_t * lenp , loff_t * ppos ) { <S2SV_StartBug> int ret = proc_dointvec ( table , write , buffer , lenp , ppos ) ; <S2SV_EndBug> if ( ret || ! write ) return ret ; if ( sysctl_perf_cpu_time_max_percent == 100 || sysctl_perf_cpu_time_max_percent == 0 ) { printk ( KERN_WARNING ""perf:<S2SV_blank>Dynamic<S2SV_blank>interrupt<S2SV_blank>throttling<S2SV_blank>disabled,<S2SV_blank>can<S2SV_blank>hang<S2SV_blank>your<S2SV_blank>system!\\n"" ) ; WRITE_ONCE ( perf_sample_allowed_ns , 0 ) ; } else { update_perf_cpu_limits ( ) ; } return 0 ; }
","<S2SV_ModStart> int ret = proc_dointvec_minmax <S2SV_ModEnd> ( table ,
"
575,"CWE-119 int vp8_full_search_sadx3 ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int sad_per_bit , int distance , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; unsigned char * in_what ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; int mv_stride = pre_stride ; unsigned char * bestaddress ; int_mv * best_mv = & d -> bmi . mv ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int r , c ; unsigned char * check_here ; int ref_row = ref_mv -> as_mv . row ; int ref_col = ref_mv -> as_mv . col ; int row_min = ref_row - distance ; int row_max = ref_row + distance ; int col_min = ref_col - distance ; int col_max = ref_col + distance ; unsigned int sad_array [ 3 ] ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; in_what = base_pre + d -> offset ; bestaddress = in_what + ( ref_row * pre_stride ) + ref_col ; best_mv -> as_mv . row = ref_row ; best_mv -> as_mv . col = ref_col ; bestsad = fn_ptr -> sdf ( what , what_stride , bestaddress , <S2SV_StartBug> in_what_stride , UINT_MAX ) <S2SV_EndBug> + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( col_min < x -> mv_col_min ) col_min = x -> mv_col_min ; if ( col_max > x -> mv_col_max ) col_max = x -> mv_col_max ; if ( row_min < x -> mv_row_min ) row_min = x -> mv_row_min ; if ( row_max > x -> mv_row_max ) row_max = x -> mv_row_max ; for ( r = row_min ; r < row_max ; r ++ ) { this_mv . as_mv . row = r ; check_here = r * mv_stride + in_what + col_min ; c = col_min ; while ( ( c + 2 ) < col_max ) { int i ; fn_ptr -> sdx3f ( what , what_stride , check_here , in_what_stride , sad_array ) ; for ( i = 0 ; i < 3 ; i ++ ) { thissad = sad_array [ i ] ; if ( thissad < bestsad ) { this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } } check_here ++ ; c ++ ; } } while ( c < col_max ) { <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> if ( thissad < bestsad ) { this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } } check_here ++ ; c ++ ; } } this_mv . as_mv . row = best_mv -> as_mv . row << 3 ; this_mv . as_mv . col = best_mv -> as_mv . col << 3 ; return fn_ptr -> vf ( what , what_stride , bestaddress , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }
","<S2SV_ModStart> bestaddress , in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost <S2SV_ModStart> check_here , in_what_stride <S2SV_ModEnd> ) ; if
"
576,"CWE-125 opj_pi_iterator_t * opj_pi_create_decode ( opj_image_t * p_image , opj_cp_t * p_cp , OPJ_UINT32 p_tile_no ) { OPJ_UINT32 pino ; OPJ_UINT32 compno , resno ; OPJ_UINT32 * l_tmp_data ; OPJ_UINT32 * * l_tmp_ptr ; OPJ_UINT32 l_max_res ; OPJ_UINT32 l_max_prec ; OPJ_INT32 l_tx0 , l_tx1 , l_ty0 , l_ty1 ; OPJ_UINT32 l_dx_min , l_dy_min ; OPJ_UINT32 l_bound ; OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ; OPJ_UINT32 l_data_stride ; opj_pi_iterator_t * l_pi = 00 ; opj_tcp_t * l_tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; opj_pi_comp_t * l_current_comp = 00 ; opj_image_comp_t * l_img_comp = 00 ; opj_pi_iterator_t * l_current_pi = 00 ; OPJ_UINT32 * l_encoding_value_ptr = 00 ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( p_tile_no < p_cp -> tw * p_cp -> th ) ; l_tcp = & p_cp -> tcps [ p_tile_no ] ; l_bound = l_tcp -> numpocs + 1 ; l_data_stride = 4 * OPJ_J2K_MAXRLVLS ; l_tmp_data = ( OPJ_UINT32 * ) opj_malloc ( l_data_stride * p_image -> numcomps * sizeof ( OPJ_UINT32 ) ) ; if ( ! l_tmp_data ) { return 00 ; } l_tmp_ptr = ( OPJ_UINT32 * * ) opj_malloc ( p_image -> numcomps * sizeof ( OPJ_UINT32 * ) ) ; if ( ! l_tmp_ptr ) { opj_free ( l_tmp_data ) ; return 00 ; } l_pi = opj_pi_create ( p_image , p_cp , p_tile_no ) ; if ( ! l_pi ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; return 00 ; } l_encoding_value_ptr = l_tmp_data ; for ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) { l_tmp_ptr [ compno ] = l_encoding_value_ptr ; l_encoding_value_ptr += l_data_stride ; } opj_get_all_encoding_parameters ( p_image , p_cp , p_tile_no , & l_tx0 , & l_tx1 , & l_ty0 , & l_ty1 , & l_dx_min , & l_dy_min , & l_max_prec , & l_max_res , l_tmp_ptr ) ; l_step_p = 1 ; l_step_c = l_max_prec * l_step_p ; l_step_r = p_image -> numcomps * l_step_c ; l_step_l = l_max_res * l_step_r ; l_current_pi = l_pi ; <S2SV_StartBug> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if <S2SV_EndBug> ( ! l_current_pi -> include ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; opj_pi_destroy ( l_pi , l_bound ) ; return 00 ; } l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } ++ l_current_pi ; for ( pino = 1 ; pino < l_bound ; ++ pino ) { l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } l_current_pi -> include = ( l_current_pi - 1 ) -> include ; ++ l_current_pi ; } opj_free ( l_tmp_data ) ; l_tmp_data = 00 ; opj_free ( l_tmp_ptr ) ; l_tmp_ptr = 00 ; if ( l_tcp -> POC ) { opj_pi_update_decode_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } else { opj_pi_update_decode_not_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } return l_pi ; }
","<S2SV_ModStart> -> include = 00 ; if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) { l_current_pi -> include = <S2SV_ModStart> ) ) ; }
"
577,"CWE-269 struct crypto_template * crypto_lookup_template ( const char * name ) { <S2SV_StartBug> return try_then_request_module ( __crypto_lookup_template ( name ) , ""%s"" , <S2SV_EndBug> name ) ; }
","<S2SV_ModStart> name ) , ""crypto-%s"" <S2SV_ModEnd> , name )
"
578,"CWE-000 static int kvm_vm_ioctl_set_pit2 ( struct kvm * kvm , struct kvm_pit_state2 * ps ) { <S2SV_StartBug> int start = 0 ; <S2SV_EndBug> u32 prev_legacy , cur_legacy ; mutex_lock ( & kvm -> arch . vpit -> pit_state . lock ) ; prev_legacy = kvm -> arch . vpit -> pit_state . flags & KVM_PIT_FLAGS_HPET_LEGACY ; cur_legacy = ps -> flags & KVM_PIT_FLAGS_HPET_LEGACY ; if ( ! prev_legacy && cur_legacy ) start = 1 ; memcpy ( & kvm -> arch . vpit -> pit_state . channels , & ps -> channels , sizeof ( kvm -> arch . vpit -> pit_state . channels ) ) ; kvm -> arch . vpit -> pit_state . flags = ps -> flags ; <S2SV_StartBug> kvm_pit_load_count ( kvm , 0 , kvm -> arch . vpit -> pit_state . channels [ 0 ] . count , start ) ; <S2SV_EndBug> mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ; return 0 ; }
","<S2SV_ModStart> start = 0 ; int i <S2SV_ModStart> -> flags ; for ( i = 0 ; i < 3 ; i ++ ) <S2SV_ModStart> ( kvm , i <S2SV_ModEnd> , kvm -> <S2SV_ModStart> . channels [ i <S2SV_ModEnd> ] . count
"
579,"CWE-119 <S2SV_StartBug> static void encode_nonrd_sb_row ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> int mi_row , TOKENEXTRA * * tp ) { VP9_COMMON * cm = & cpi -> common ; MACROBLOCKD * xd = & cpi -> mb . e_mbd ; int mi_col ; <S2SV_StartBug> vpx_memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ; <S2SV_EndBug> vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ; <S2SV_StartBug> for ( mi_col = tile -> mi_col_start ; mi_col < tile -> mi_col_end ; <S2SV_EndBug> mi_col += MI_BLOCK_SIZE ) { <S2SV_StartBug> int dummy_rate = 0 ; <S2SV_EndBug> int64_t dummy_dist = 0 ; const int idx_str = cm -> mi_stride * mi_row + mi_col ; <S2SV_StartBug> MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + idx_str ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * prev_mi_8x8 = cm -> prev_mi_grid_visible + idx_str ; <S2SV_EndBug> <S2SV_StartBug> BLOCK_SIZE bsize ; <S2SV_EndBug> cpi -> mb . source_variance = UINT_MAX ; <S2SV_StartBug> vp9_zero ( cpi -> mb . pred_mv ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( cpi -> sf . partition_search_type ) { <S2SV_EndBug> case VAR_BASED_PARTITION : <S2SV_StartBug> choose_partitioning ( cpi , tile , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_EndBug> <S2SV_StartBug> 1 , & dummy_rate , & dummy_dist ) ; <S2SV_EndBug> break ; case SOURCE_VAR_BASED_PARTITION : <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; <S2SV_EndBug> <S2SV_StartBug> set_source_var_based_partition ( cpi , tile , mi_8x8 , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_EndBug> <S2SV_StartBug> 1 , & dummy_rate , & dummy_dist ) ; <S2SV_EndBug> break ; <S2SV_StartBug> case VAR_BASED_FIXED_PARTITION : <S2SV_EndBug> case FIXED_PARTITION : <S2SV_StartBug> bsize = cpi -> sf . partition_search_type == FIXED_PARTITION ? <S2SV_EndBug> cpi -> sf . always_this_block_size : get_nonrd_var_based_fixed_partition ( cpi , mi_row , mi_col ) ; <S2SV_StartBug> set_fixed_partitioning ( cpi , tile , mi_8x8 , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_EndBug> <S2SV_StartBug> 1 , & dummy_rate , & dummy_dist ) ; <S2SV_EndBug> break ; case REFERENCE_PARTITION : <S2SV_StartBug> if ( cpi -> sf . partition_check || sb_has_motion ( cm , prev_mi_8x8 ) ) { <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_partition ( cpi , tile , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_EndBug> <S2SV_StartBug> & dummy_rate , & dummy_dist , 1 , INT64_MAX ) ; <S2SV_EndBug> } else { <S2SV_StartBug> copy_partitioning ( cm , mi_8x8 , prev_mi_8x8 ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> BLOCK_64X64 , 1 , & dummy_rate , & dummy_dist ) ; <S2SV_EndBug> } break ; default : assert ( 0 ) ; <S2SV_StartBug> } <S2SV_EndBug> } }
","<S2SV_ModStart> * cpi , ThreadData * td , TileDataEnc * tile_data , int mi_row , TOKENEXTRA * * tp ) { SPEED_FEATURES * const sf = & cpi -> sf ; VP9_COMMON * const cm = & cpi -> common ; <S2SV_ModEnd> TileInfo * const <S2SV_ModStart> TileInfo * const tile_info = & tile_data -> tile_info ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; int mi_col ; memset ( & xd -> left_context , 0 , sizeof ( <S2SV_ModEnd> xd -> left_context <S2SV_ModStart> xd -> left_context ) ) ; memset ( xd -> left_seg_context <S2SV_ModStart> ( xd -> left_seg_context <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( mi_col = tile_info <S2SV_ModEnd> -> mi_col_start ; <S2SV_ModStart> ; mi_col < tile_info <S2SV_ModEnd> -> mi_col_end ; <S2SV_ModStart> MI_BLOCK_SIZE ) { const struct segmentation * const seg = & cm -> seg ; RD_COST dummy_rdc <S2SV_ModEnd> ; const int <S2SV_ModStart> MODE_INFO * * mi <S2SV_ModEnd> = cm -> <S2SV_ModStart> + idx_str ; PARTITION_SEARCH_TYPE partition_search_type = sf -> partition_search_type <S2SV_ModEnd> ; BLOCK_SIZE bsize <S2SV_ModStart> ; BLOCK_SIZE bsize = BLOCK_64X64 ; int seg_skip = 0 ; x -> <S2SV_ModEnd> source_variance = UINT_MAX <S2SV_ModStart> ; vp9_zero ( x -> <S2SV_ModEnd> pred_mv ) ; <S2SV_ModStart> pred_mv ) ; vp9_rd_cost_init ( & dummy_rdc ) ; x -> color_sensitivity [ 0 ] = 0 ; x -> color_sensitivity [ 1 ] = 0 ; if ( seg -> enabled ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; int segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ; seg_skip = segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ; if ( seg_skip ) { partition_search_type = FIXED_PARTITION ; } } switch ( <S2SV_ModEnd> partition_search_type ) { <S2SV_ModStart> ( cpi , tile_info , x <S2SV_ModEnd> , mi_row , <S2SV_ModStart> ( cpi , td , tile_data , mi <S2SV_ModEnd> , tp , <S2SV_ModStart> , mi_col , BLOCK_64X64 , <S2SV_ModEnd> 1 , & <S2SV_ModStart> 1 , & dummy_rdc , td -> pc_root <S2SV_ModEnd> ) ; break <S2SV_ModStart> case SOURCE_VAR_BASED_PARTITION : <S2SV_ModEnd> set_source_var_based_partition ( cpi <S2SV_ModStart> ( cpi , tile_info , x , mi <S2SV_ModEnd> , mi_row , <S2SV_ModStart> ( cpi , td , tile_data , mi <S2SV_ModEnd> , tp , <S2SV_ModStart> , mi_col , BLOCK_64X64 , <S2SV_ModEnd> 1 , & <S2SV_ModStart> 1 , & dummy_rdc , td -> pc_root <S2SV_ModEnd> ) ; break <S2SV_ModStart> ; break ; <S2SV_ModEnd> case FIXED_PARTITION : <S2SV_ModStart> case FIXED_PARTITION : if ( ! seg_skip ) bsize = sf -> always_this_block_size <S2SV_ModEnd> ; set_fixed_partitioning ( <S2SV_ModStart> ( cpi , tile_info , mi <S2SV_ModEnd> , mi_row , <S2SV_ModStart> ( cpi , td , tile_data , mi <S2SV_ModEnd> , tp , <S2SV_ModStart> , mi_col , BLOCK_64X64 , <S2SV_ModEnd> 1 , & <S2SV_ModStart> 1 , & dummy_rdc , td -> pc_root <S2SV_ModEnd> ) ; break <S2SV_ModStart> case REFERENCE_PARTITION : set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; <S2SV_ModStart> ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled && xd -> mi [ 0 ] -> mbmi . segment_id ) { if ( cm -> width <= 352 && cm -> height <= 288 ) x -> max_partition_size = BLOCK_32X32 ; else x -> max_partition_size = BLOCK_64X64 ; x -> min_partition_size = BLOCK_8X8 ; <S2SV_ModEnd> nonrd_pick_partition ( cpi <S2SV_ModStart> ( cpi , td , tile_data <S2SV_ModEnd> , tp , <S2SV_ModStart> , mi_col , BLOCK_64X64 , & dummy_rdc <S2SV_ModEnd> , 1 , <S2SV_ModStart> 1 , INT64_MAX , td -> pc_root <S2SV_ModStart> } else { choose_partitioning ( cpi , tile_info , x , mi_row , mi_col ) ; if ( cm -> frame_type == KEY_FRAME ) <S2SV_ModEnd> nonrd_use_partition ( cpi <S2SV_ModStart> ( cpi , td , tile_data , mi <S2SV_ModEnd> , tp , <S2SV_ModStart> 1 , & dummy_rdc , td -> pc_root ) ; else nonrd_select_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rdc , td -> pc_root <S2SV_ModEnd> ) ; } <S2SV_ModStart> 0 ) ; break ;
"
580,"CWE-416 static int link_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , i = 0 , nbuf ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( i >= ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) break ; ibuf = ipipe -> bufs + ( ( ipipe -> curbuf + i ) & ( ipipe -> buffers - 1 ) ) ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> obuf = opipe -> bufs + nbuf ; * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; if ( obuf -> len > len ) obuf -> len = len ; opipe -> nrbufs ++ ; ret += obuf -> len ; len -= obuf -> len ; i ++ ; } while ( len ) ; if ( ! ret && ipipe -> waiting_writers && ( flags & SPLICE_F_NONBLOCK ) ) ret = - EAGAIN ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; return ret ; }
","<S2SV_ModStart> 1 ) ; if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> obuf = opipe
"
581,"CWE-20 static bool dccp_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; struct dccp_net * dn ; struct dccp_hdr _dh , * dh ; const char * msg ; u_int8_t state ; <S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> BUG_ON ( dh == NULL ) ; state = dccp_state_table [ CT_DCCP_ROLE_CLIENT ] [ dh -> dccph_type ] [ CT_DCCP_NONE ] ; switch ( state ) { default : dn = dccp_pernet ( net ) ; if ( dn -> dccp_loose == 0 ) { msg = ""nf_ct_dccp:<S2SV_blank>not<S2SV_blank>picking<S2SV_blank>up<S2SV_blank>existing<S2SV_blank>connection<S2SV_blank>"" ; goto out_invalid ; } case CT_DCCP_REQUEST : break ; case CT_DCCP_INVALID : msg = ""nf_ct_dccp:<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>transition<S2SV_blank>"" ; goto out_invalid ; } ct -> proto . dccp . role [ IP_CT_DIR_ORIGINAL ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ IP_CT_DIR_REPLY ] = CT_DCCP_ROLE_SERVER ; ct -> proto . dccp . state = CT_DCCP_NONE ; ct -> proto . dccp . last_pkt = DCCP_PKT_REQUEST ; ct -> proto . dccp . last_dir = IP_CT_DIR_ORIGINAL ; ct -> proto . dccp . handshake_seq = 0 ; return true ; out_invalid : if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , nf_ct_l3num ( ct ) , 0 , skb , NULL , NULL , NULL , ""%s"" , msg ) ; return false ; }
","<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; BUG_ON
"
582,"CWE-284 static int http_RecvPostMessage ( http_parser_t * parser , SOCKINFO * info , char * filename , struct SendInstruction * Instr ) { size_t Data_Buf_Size = 1024 ; char Buf [ 1024 ] ; int Timeout = - 1 ; FILE * Fp ; parse_status_t status = PARSE_OK ; int ok_on_close = FALSE ; size_t entity_offset = 0 ; int num_read = 0 ; int ret_code = HTTP_OK ; if ( Instr && Instr -> IsVirtualFile ) { Fp = ( virtualDirCallback . open ) ( filename , UPNP_WRITE ) ; if ( Fp == NULL ) return HTTP_INTERNAL_SERVER_ERROR ; } else { <S2SV_StartBug> Fp = fopen ( filename , ""wb"" ) ; <S2SV_EndBug> if ( Fp == NULL ) <S2SV_StartBug> return HTTP_UNAUTHORIZED ; <S2SV_EndBug> } parser -> position = POS_ENTITY ; do { if ( parser -> position != POS_COMPLETE ) status = parser_parse_entity ( parser ) ; if ( status == PARSE_INCOMPLETE_ENTITY ) { ok_on_close = TRUE ; } else if ( ( status != PARSE_SUCCESS ) && ( status != PARSE_CONTINUE_1 ) && ( status != PARSE_INCOMPLETE ) ) { ret_code = HTTP_BAD_REQUEST ; goto ExitFunction ; } while ( entity_offset + Data_Buf_Size > parser -> msg . entity . length && parser -> position != POS_COMPLETE ) { num_read = sock_read ( info , Buf , sizeof ( Buf ) , & Timeout ) ; if ( num_read > 0 ) { if ( membuffer_append ( & parser -> msg . msg , Buf , ( size_t ) num_read ) != 0 ) { parser -> http_error_code = HTTP_INTERNAL_SERVER_ERROR ; ret_code = HTTP_INTERNAL_SERVER_ERROR ; goto ExitFunction ; } status = parser_parse_entity ( parser ) ; if ( status == PARSE_INCOMPLETE_ENTITY ) { ok_on_close = TRUE ; } else if ( ( status != PARSE_SUCCESS ) && ( status != PARSE_CONTINUE_1 ) && ( status != PARSE_INCOMPLETE ) ) { ret_code = HTTP_BAD_REQUEST ; goto ExitFunction ; } } else if ( num_read == 0 ) { if ( ok_on_close ) { UpnpPrintf ( UPNP_INFO , HTTP , __FILE__ , __LINE__ , ""<<<<S2SV_blank>(RECVD)<S2SV_blank><<<\\n%s\\n-----------------\\n"" , parser -> msg . msg . buf ) ; print_http_headers ( & parser -> msg ) ; parser -> position = POS_COMPLETE ; } else { parser -> http_error_code = HTTP_BAD_REQUEST ; ret_code = HTTP_BAD_REQUEST ; goto ExitFunction ; } } else { ret_code = HTTP_SERVICE_UNAVAILABLE ; goto ExitFunction ; } } if ( ( entity_offset + Data_Buf_Size ) > parser -> msg . entity . length ) { Data_Buf_Size = parser -> msg . entity . length - entity_offset ; } memcpy ( Buf , & parser -> msg . msg . buf [ parser -> entity_start_position + entity_offset ] , Data_Buf_Size ) ; entity_offset += Data_Buf_Size ; if ( Instr && Instr -> IsVirtualFile ) { int n = virtualDirCallback . write ( Fp , Buf , Data_Buf_Size ) ; if ( n < 0 ) { ret_code = HTTP_INTERNAL_SERVER_ERROR ; goto ExitFunction ; } } else { size_t n = fwrite ( Buf , 1 , Data_Buf_Size , Fp ) ; if ( n != Data_Buf_Size ) { ret_code = HTTP_INTERNAL_SERVER_ERROR ; goto ExitFunction ; } } } while ( parser -> position != POS_COMPLETE || entity_offset != parser -> msg . entity . length ) ; ExitFunction : if ( Instr && Instr -> IsVirtualFile ) { virtualDirCallback . close ( Fp ) ; } else { fclose ( Fp ) ; } return ret_code ; }
","<S2SV_ModStart> } else { # ifdef UPNP_ENABLE_POST_WRITE <S2SV_ModStart> return HTTP_UNAUTHORIZED ; # else return HTTP_NOT_FOUND ; # endif
"
583,"CWE-000 static FILE * pw_tmpfile ( int lockfd ) { FILE * fd ; char * tmpname = NULL ; <S2SV_StartBug> char * dir = ""/etc"" ; <S2SV_EndBug> <S2SV_StartBug> if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) { <S2SV_EndBug> ulckpwdf ( ) ; err ( EXIT_FAILURE , _ ( ""can\'t<S2SV_blank>open<S2SV_blank>temporary<S2SV_blank>file"" ) ) ; } copyfile ( lockfd , fileno ( fd ) ) ; tmp_file = tmpname ; return fd ; }
","<S2SV_ModStart> = NULL ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> & tmpname , ""/etc"" , "".vipw"" <S2SV_ModEnd> ) ) ==
"
584,"CWE-415 int blkcg_init_queue ( struct request_queue * q ) { struct blkcg_gq * new_blkg , * blkg ; bool preloaded ; int ret ; new_blkg = blkg_alloc ( & blkcg_root , q , GFP_KERNEL ) ; if ( ! new_blkg ) return - ENOMEM ; preloaded = ! radix_tree_preload ( GFP_KERNEL ) ; rcu_read_lock ( ) ; spin_lock_irq ( q -> queue_lock ) ; blkg = blkg_create ( & blkcg_root , q , new_blkg ) ; spin_unlock_irq ( q -> queue_lock ) ; rcu_read_unlock ( ) ; if ( preloaded ) radix_tree_preload_end ( ) ; <S2SV_StartBug> if ( IS_ERR ( blkg ) ) { <S2SV_EndBug> blkg_free ( new_blkg ) ; return PTR_ERR ( blkg ) ; <S2SV_StartBug> } <S2SV_EndBug> q -> root_blkg = blkg ; q -> root_rl . blkg = blkg ; ret = blk_throtl_init ( q ) ; if ( ret ) { spin_lock_irq ( q -> queue_lock ) ; blkg_destroy_all ( q ) ; spin_unlock_irq ( q -> queue_lock ) ; } return ret ; }
","<S2SV_ModStart> blkg ) ) <S2SV_ModEnd> return PTR_ERR ( <S2SV_ModStart> blkg ) ; <S2SV_ModEnd> q -> root_blkg
"
585,"CWE-119 static int xwd_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { AVFrame * p = data ; const uint8_t * buf = avpkt -> data ; int i , ret , buf_size = avpkt -> size ; uint32_t version , header_size , vclass , ncolors ; uint32_t xoffset , be , bpp , lsize , rsize ; uint32_t pixformat , pixdepth , bunit , bitorder , bpad ; uint32_t rgb [ 3 ] ; uint8_t * ptr ; GetByteContext gb ; if ( buf_size < XWD_HEADER_SIZE ) return AVERROR_INVALIDDATA ; bytestream2_init ( & gb , buf , buf_size ) ; header_size = bytestream2_get_be32u ( & gb ) ; version = bytestream2_get_be32u ( & gb ) ; if ( version != XWD_VERSION ) { av_log ( avctx , AV_LOG_ERROR , ""unsupported<S2SV_blank>version\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( buf_size < header_size || header_size < XWD_HEADER_SIZE ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>header<S2SV_blank>size\\n"" ) ; return AVERROR_INVALIDDATA ; } pixformat = bytestream2_get_be32u ( & gb ) ; pixdepth = bytestream2_get_be32u ( & gb ) ; avctx -> width = bytestream2_get_be32u ( & gb ) ; avctx -> height = bytestream2_get_be32u ( & gb ) ; xoffset = bytestream2_get_be32u ( & gb ) ; be = bytestream2_get_be32u ( & gb ) ; bunit = bytestream2_get_be32u ( & gb ) ; bitorder = bytestream2_get_be32u ( & gb ) ; bpad = bytestream2_get_be32u ( & gb ) ; bpp = bytestream2_get_be32u ( & gb ) ; lsize = bytestream2_get_be32u ( & gb ) ; vclass = bytestream2_get_be32u ( & gb ) ; rgb [ 0 ] = bytestream2_get_be32u ( & gb ) ; rgb [ 1 ] = bytestream2_get_be32u ( & gb ) ; rgb [ 2 ] = bytestream2_get_be32u ( & gb ) ; bytestream2_skipu ( & gb , 8 ) ; ncolors = bytestream2_get_be32u ( & gb ) ; bytestream2_skipu ( & gb , header_size - ( XWD_HEADER_SIZE - 20 ) ) ; av_log ( avctx , AV_LOG_DEBUG , ""pixformat<S2SV_blank>%"" PRIu32 "",<S2SV_blank>pixdepth<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bunit<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bitorder<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bpad<S2SV_blank>%"" PRIu32 ""\\n"" , pixformat , pixdepth , bunit , bitorder , bpad ) ; av_log ( avctx , AV_LOG_DEBUG , ""vclass<S2SV_blank>%"" PRIu32 "",<S2SV_blank>ncolors<S2SV_blank>%"" PRIu32 "",<S2SV_blank>bpp<S2SV_blank>%"" PRIu32 "",<S2SV_blank>be<S2SV_blank>%"" PRIu32 "",<S2SV_blank>lsize<S2SV_blank>%"" PRIu32 "",<S2SV_blank>xoffset<S2SV_blank>%"" PRIu32 ""\\n"" , vclass , ncolors , bpp , be , lsize , xoffset ) ; av_log ( avctx , AV_LOG_DEBUG , ""red<S2SV_blank>%0"" PRIx32 "",<S2SV_blank>green<S2SV_blank>%0"" PRIx32 "",<S2SV_blank>blue<S2SV_blank>%0"" PRIx32 ""\\n"" , rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; if ( pixformat > XWD_Z_PIXMAP ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>pixmap<S2SV_blank>format\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( pixdepth == 0 || pixdepth > 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>pixmap<S2SV_blank>depth\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( xoffset ) { avpriv_request_sample ( avctx , ""xoffset<S2SV_blank>%"" PRIu32 """" , xoffset ) ; return AVERROR_PATCHWELCOME ; } if ( be > 1 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>byte<S2SV_blank>order\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bitorder > 1 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bitmap<S2SV_blank>bit<S2SV_blank>order\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bunit != 8 && bunit != 16 && bunit != 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bitmap<S2SV_blank>unit\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bpad != 8 && bpad != 16 && bpad != 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bitmap<S2SV_blank>scan-line<S2SV_blank>pad\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bpp == 0 || bpp > 32 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>pixel\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ncolors > 256 ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>entries<S2SV_blank>in<S2SV_blank>colormap\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ( ret = av_image_check_size ( avctx -> width , avctx -> height , 0 , NULL ) ) < 0 ) return ret ; rsize = FFALIGN ( avctx -> width * bpp , bpad ) / 8 ; if ( lsize < rsize ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>scan-line\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( bytestream2_get_bytes_left ( & gb ) < ncolors * XWD_CMAP_SIZE + ( uint64_t ) avctx -> height * lsize ) { av_log ( avctx , AV_LOG_ERROR , ""input<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( pixformat != XWD_Z_PIXMAP ) { avpriv_report_missing_feature ( avctx , ""Pixmap<S2SV_blank>format<S2SV_blank>%"" PRIu32 , pixformat ) ; return AVERROR_PATCHWELCOME ; } avctx -> pix_fmt = AV_PIX_FMT_NONE ; switch ( vclass ) { case XWD_STATIC_GRAY : case XWD_GRAY_SCALE : if ( bpp != 1 && bpp != 8 ) return AVERROR_INVALIDDATA ; <S2SV_StartBug> if ( pixdepth == 1 ) { <S2SV_EndBug> avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ; <S2SV_StartBug> } else if ( pixdepth == 8 ) { <S2SV_EndBug> avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ; } break ; case XWD_STATIC_COLOR : case XWD_PSEUDO_COLOR : if ( bpp == 8 ) avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; break ; case XWD_TRUE_COLOR : case XWD_DIRECT_COLOR : if ( bpp != 16 && bpp != 24 && bpp != 32 ) return AVERROR_INVALIDDATA ; if ( bpp == 16 && pixdepth == 15 ) { if ( rgb [ 0 ] == 0x7C00 && rgb [ 1 ] == 0x3E0 && rgb [ 2 ] == 0x1F ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB555BE : AV_PIX_FMT_RGB555LE ; else if ( rgb [ 0 ] == 0x1F && rgb [ 1 ] == 0x3E0 && rgb [ 2 ] == 0x7C00 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR555BE : AV_PIX_FMT_BGR555LE ; } else if ( bpp == 16 && pixdepth == 16 ) { if ( rgb [ 0 ] == 0xF800 && rgb [ 1 ] == 0x7E0 && rgb [ 2 ] == 0x1F ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB565BE : AV_PIX_FMT_RGB565LE ; else if ( rgb [ 0 ] == 0x1F && rgb [ 1 ] == 0x7E0 && rgb [ 2 ] == 0xF800 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR565BE : AV_PIX_FMT_BGR565LE ; } else if ( bpp == 24 ) { if ( rgb [ 0 ] == 0xFF0000 && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB24 : AV_PIX_FMT_BGR24 ; else if ( rgb [ 0 ] == 0xFF && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF0000 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_RGB24 ; } else if ( bpp == 32 ) { if ( rgb [ 0 ] == 0xFF0000 && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF ) avctx -> pix_fmt = be ? AV_PIX_FMT_ARGB : AV_PIX_FMT_BGRA ; else if ( rgb [ 0 ] == 0xFF && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF0000 ) avctx -> pix_fmt = be ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA ; } bytestream2_skipu ( & gb , ncolors * XWD_CMAP_SIZE ) ; break ; default : av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>visual<S2SV_blank>class\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( avctx -> pix_fmt == AV_PIX_FMT_NONE ) { avpriv_request_sample ( avctx , ""Unknown<S2SV_blank>file:<S2SV_blank>bpp<S2SV_blank>%"" PRIu32 "",<S2SV_blank>pixdepth<S2SV_blank>%"" PRIu32 "",<S2SV_blank>vclass<S2SV_blank>%"" PRIu32 """" , bpp , pixdepth , vclass ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) return ret ; p -> key_frame = 1 ; p -> pict_type = AV_PICTURE_TYPE_I ; if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) { uint32_t * dst = ( uint32_t * ) p -> data [ 1 ] ; uint8_t red , green , blue ; for ( i = 0 ; i < ncolors ; i ++ ) { bytestream2_skipu ( & gb , 4 ) ; red = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 1 ) ; green = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 1 ) ; blue = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 3 ) ; dst [ i ] = red << 16 | green << 8 | blue ; } } ptr = p -> data [ 0 ] ; for ( i = 0 ; i < avctx -> height ; i ++ ) { bytestream2_get_bufferu ( & gb , ptr , rsize ) ; bytestream2_skipu ( & gb , lsize - rsize ) ; ptr += p -> linesize [ 0 ] ; } * got_frame = 1 ; return buf_size ; }
","<S2SV_ModStart> ; if ( bpp == 1 && <S2SV_ModStart> else if ( bpp == 8 &&
"
586,"CWE-295 static krb5_error_code tgs_build_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ * req , KDC_REQ_BODY * b , hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , const krb5_keyblock * replykey , int rk_is_subkey , krb5_ticket * ticket , krb5_data * reply , const char * from , const char * * e_text , AuthorizationData * * auth_data , const struct sockaddr * from_addr ) { krb5_error_code ret ; krb5_principal cp = NULL , sp = NULL , rsp = NULL , tp = NULL , dp = NULL ; krb5_principal krbtgt_out_principal = NULL ; char * spn = NULL , * cpn = NULL , * tpn = NULL , * dpn = NULL , * krbtgt_out_n = NULL ; hdb_entry_ex * server = NULL , * client = NULL , * s4u2self_impersonated_client = NULL ; HDB * clientdb , * s4u2self_impersonated_clientdb ; krb5_realm ref_realm = NULL ; EncTicketPart * tgt = & ticket -> ticket ; krb5_principals spp = NULL ; const EncryptionKey * ekey ; krb5_keyblock sessionkey ; krb5_kvno kvno ; <S2SV_StartBug> krb5_data rspac ; <S2SV_EndBug> const char * our_realm = krb5_principal_get_comp_string ( context , krbtgt -> entry . principal , 1 ) ; char * * capath = NULL ; size_t num_capath = 0 ; hdb_entry_ex * krbtgt_out = NULL ; METHOD_DATA enc_pa_data ; PrincipalName * s ; Realm r ; EncTicketPart adtkt ; char opt_str [ 128 ] ; int signedpath = 0 ; Key * tkey_check ; Key * tkey_sign ; int flags = HDB_F_FOR_TGS_REQ ; memset ( & sessionkey , 0 , sizeof ( sessionkey ) ) ; memset ( & adtkt , 0 , sizeof ( adtkt ) ) ; krb5_data_zero ( & rspac ) ; memset ( & enc_pa_data , 0 , sizeof ( enc_pa_data ) ) ; s = b -> sname ; r = b -> realm ; flags |= HDB_F_CANON ; if ( b -> kdc_options . enc_tkt_in_skey ) { Ticket * t ; hdb_entry_ex * uu ; krb5_principal p ; Key * uukey ; krb5uint32 second_kvno = 0 ; krb5uint32 * kvno_ptr = NULL ; if ( b -> additional_tickets == NULL || b -> additional_tickets -> len == 0 ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , ""No<S2SV_blank>second<S2SV_blank>ticket<S2SV_blank>present<S2SV_blank>in<S2SV_blank>request"" ) ; goto out ; } t = & b -> additional_tickets -> val [ 0 ] ; if ( ! get_krbtgt_realm ( & t -> sname ) ) { kdc_log ( context , config , 0 , ""Additional<S2SV_blank>ticket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>ticket-granting<S2SV_blank>ticket"" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } _krb5_principalname2krb5_principal ( context , & p , t -> sname , t -> realm ) ; if ( t -> enc_part . kvno ) { second_kvno = * t -> enc_part . kvno ; kvno_ptr = & second_kvno ; } ret = _kdc_db_fetch ( context , config , p , HDB_F_GET_KRBTGT , kvno_ptr , NULL , & uu ) ; krb5_free_principal ( context , p ) ; if ( ret ) { if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto out ; } ret = hdb_enctype2key ( context , & uu -> entry , NULL , t -> enc_part . etype , & uukey ) ; if ( ret ) { _kdc_free_ent ( context , uu ) ; ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } ret = krb5_decrypt_ticket ( context , t , & uukey -> key , & adtkt , 0 ) ; _kdc_free_ent ( context , uu ) ; if ( ret ) goto out ; ret = verify_flags ( context , config , & adtkt , spn ) ; if ( ret ) goto out ; s = & adtkt . cname ; r = adtkt . crealm ; } _krb5_principalname2krb5_principal ( context , & sp , * s , r ) ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; _krb5_principalname2krb5_principal ( context , & cp , tgt -> cname , tgt -> crealm ) ; ret = krb5_unparse_name ( context , cp , & cpn ) ; if ( ret ) goto out ; unparse_flags ( KDCOptions2int ( b -> kdc_options ) , asn1_KDCOptions_units ( ) , opt_str , sizeof ( opt_str ) ) ; if ( * opt_str ) kdc_log ( context , config , 0 , ""TGS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>[%s]"" , cpn , from , spn , opt_str ) ; else kdc_log ( context , config , 0 , ""TGS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s"" , cpn , from , spn ) ; server_lookup : ret = _kdc_db_fetch ( context , config , sp , HDB_F_GET_SERVER | flags , NULL , NULL , & server ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { kdc_log ( context , config , 5 , ""target<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy"" , sp ) ; goto out ; } else if ( ret == HDB_ERR_WRONG_REALM ) { free ( ref_realm ) ; ref_realm = strdup ( server -> entry . principal -> realm ) ; if ( ref_realm == NULL ) { ret = krb5_enomem ( context ) ; goto out ; } kdc_log ( context , config , 5 , ""Returning<S2SV_blank>a<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>realm<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>"" ""server<S2SV_blank>%s."" , ref_realm , spn ) ; krb5_free_principal ( context , sp ) ; sp = NULL ; ret = krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , ref_realm , NULL ) ; if ( ret ) goto out ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; goto server_lookup ; } else if ( ret ) { const char * new_rlm , * msg ; Realm req_rlm ; krb5_realm * realms ; if ( ( req_rlm = get_krbtgt_realm ( & sp -> name ) ) != NULL ) { if ( capath == NULL ) { ret = _krb5_find_capath ( context , tgt -> crealm , our_realm , req_rlm , TRUE , & capath , & num_capath ) ; if ( ret ) goto out ; } new_rlm = num_capath > 0 ? capath [ -- num_capath ] : NULL ; if ( new_rlm ) { kdc_log ( context , config , 5 , ""krbtgt<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>"" ""realm<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found,<S2SV_blank>trying<S2SV_blank>%s"" , tgt -> crealm , our_realm , req_rlm , new_rlm ) ; free ( ref_realm ) ; ref_realm = strdup ( new_rlm ) ; if ( ref_realm == NULL ) { ret = krb5_enomem ( context ) ; goto out ; } krb5_free_principal ( context , sp ) ; sp = NULL ; krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , ref_realm , NULL ) ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) goto out ; goto server_lookup ; } } else if ( need_referral ( context , config , & b -> kdc_options , sp , & realms ) ) { if ( strcmp ( realms [ 0 ] , sp -> realm ) != 0 ) { kdc_log ( context , config , 5 , ""Returning<S2SV_blank>a<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>realm<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>"" ""server<S2SV_blank>%s<S2SV_blank>that<S2SV_blank>was<S2SV_blank>not<S2SV_blank>found"" , realms [ 0 ] , spn ) ; krb5_free_principal ( context , sp ) ; sp = NULL ; krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , realms [ 0 ] , NULL ) ; free ( spn ) ; spn = NULL ; ret = krb5_unparse_name ( context , sp , & spn ) ; if ( ret ) { krb5_free_host_realm ( context , realms ) ; goto out ; } free ( ref_realm ) ; ref_realm = strdup ( realms [ 0 ] ) ; krb5_free_host_realm ( context , realms ) ; goto server_lookup ; } krb5_free_host_realm ( context , realms ) ; } msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""Server<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s:<S2SV_blank>%s"" , spn , msg ) ; krb5_free_error_message ( context , msg ) ; if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto out ; } if ( b -> kdc_options . canonicalize ) rsp = server -> entry . principal ; else rsp = sp ; { krb5_enctype etype ; if ( b -> kdc_options . enc_tkt_in_skey ) { size_t i ; ekey = & adtkt . key ; for ( i = 0 ; i < b -> etype . len ; i ++ ) if ( b -> etype . val [ i ] == adtkt . key . keytype ) break ; if ( i == b -> etype . len ) { kdc_log ( context , config , 0 , ""Addition<S2SV_blank>ticket<S2SV_blank>have<S2SV_blank>not<S2SV_blank>matching<S2SV_blank>etypes"" ) ; krb5_clear_error_message ( context ) ; ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } etype = b -> etype . val [ i ] ; kvno = 0 ; } else { Key * skey ; ret = _kdc_find_etype ( context , krb5_principal_is_krbtgt ( context , sp ) ? config -> tgt_use_strongest_session_key : config -> svc_use_strongest_session_key , FALSE , server , b -> etype . val , b -> etype . len , & etype , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Server<S2SV_blank>(%s)<S2SV_blank>has<S2SV_blank>no<S2SV_blank>support<S2SV_blank>for<S2SV_blank>etypes"" , spn ) ; goto out ; } ret = _kdc_get_preferred_key ( context , config , server , spn , NULL , & skey ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Server<S2SV_blank>(%s)<S2SV_blank>has<S2SV_blank>no<S2SV_blank>supported<S2SV_blank>etypes"" , spn ) ; goto out ; } ekey = & skey -> key ; kvno = server -> entry . kvno ; } ret = krb5_generate_random_keyblock ( context , etype , & sessionkey ) ; if ( ret ) goto out ; } ret = hdb_enctype2key ( context , & krbtgt -> entry , NULL , krbtgt_etype , & tkey_check ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>check"" ) ; goto out ; } ret = krb5_make_principal ( context , & krbtgt_out_principal , our_realm , KRB5_TGS_NAME , our_realm , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>krbtgt<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>object<S2SV_blank>for<S2SV_blank>"" ""authz-data<S2SV_blank>signatures"" ) ; goto out ; } ret = krb5_unparse_name ( context , krbtgt_out_principal , & krbtgt_out_n ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>krbtgt<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>object<S2SV_blank>for<S2SV_blank>"" ""authz-data<S2SV_blank>signatures"" ) ; goto out ; } ret = _kdc_db_fetch ( context , config , krbtgt_out_principal , HDB_F_GET_KRBTGT , NULL , NULL , & krbtgt_out ) ; if ( ret ) { char * ktpn = NULL ; ret = krb5_unparse_name ( context , krbtgt -> entry . principal , & ktpn ) ; kdc_log ( context , config , 0 , ""No<S2SV_blank>such<S2SV_blank>principal<S2SV_blank>%s<S2SV_blank>(needed<S2SV_blank>for<S2SV_blank>authz-data<S2SV_blank>signature<S2SV_blank>keys)<S2SV_blank>"" ""while<S2SV_blank>processing<S2SV_blank>TGS-REQ<S2SV_blank>for<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>krbtg<S2SV_blank>%s"" , krbtgt_out_n , spn , ( ret == 0 ) ? ktpn : ""<unknown>"" ) ; free ( ktpn ) ; ret = KRB5KRB_AP_ERR_NOT_US ; goto out ; } if ( strcmp ( krb5_principal_get_realm ( context , server -> entry . principal ) , krb5_principal_get_realm ( context , krbtgt_out -> entry . principal ) ) != 0 ) { char * ktpn ; ret = krb5_unparse_name ( context , krbtgt_out -> entry . principal , & ktpn ) ; kdc_log ( context , config , 0 , ""Request<S2SV_blank>with<S2SV_blank>wrong<S2SV_blank>krbtgt:<S2SV_blank>%s"" , ( ret == 0 ) ? ktpn : ""<unknown>"" ) ; if ( ret == 0 ) free ( ktpn ) ; ret = KRB5KRB_AP_ERR_NOT_US ; goto out ; } ret = _kdc_get_preferred_key ( context , config , krbtgt_out , krbtgt_out_n , NULL , & tkey_sign ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>signature"" ) ; goto out ; } ret = hdb_enctype2key ( context , & krbtgt_out -> entry , NULL , tkey_sign -> key . keytype , & tkey_sign ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>signature"" ) ; goto out ; } ret = _kdc_db_fetch ( context , config , cp , HDB_F_GET_CLIENT | flags , NULL , & clientdb , & client ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { } else if ( ret ) { const char * krbtgt_realm , * msg ; krbtgt_realm = krb5_principal_get_realm ( context , krbtgt_out -> entry . principal ) ; if ( strcmp ( krb5_principal_get_realm ( context , cp ) , krbtgt_realm ) == 0 ) { if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; kdc_log ( context , config , 1 , ""Client<S2SV_blank>no<S2SV_blank>longer<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s"" , cpn ) ; goto out ; } msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 1 , ""Client<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s"" , msg ) ; krb5_free_error_message ( context , msg ) ; } ret = check_PAC ( context , config , cp , NULL , client , server , krbtgt , & tkey_check -> key , ekey , & tkey_sign -> key , tgt , & rspac , & signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""Verify<S2SV_blank>PAC<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s"" , spn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = check_KRB5SignedPath ( context , config , krbtgt , cp , tgt , & spp , & signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""KRB5SignedPath<S2SV_blank>check<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s"" , spn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } tp = cp ; tpn = cpn ; if ( client ) { const PA_DATA * sdata ; int i = 0 ; sdata = _kdc_find_padata ( req , & i , KRB5_PADATA_FOR_USER ) ; if ( sdata ) { krb5_crypto crypto ; krb5_data datack ; PA_S4U2Self self ; const char * str ; ret = decode_PA_S4U2Self ( sdata -> padata_value . data , sdata -> padata_value . length , & self , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>PA-S4U2Self"" ) ; goto out ; } ret = _krb5_s4u2self_to_checksumdata ( context , & self , & datack ) ; if ( ret ) goto out ; ret = krb5_crypto_init ( context , & tgt -> key , 0 , & crypto ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; free_PA_S4U2Self ( & self ) ; krb5_data_free ( & datack ) ; kdc_log ( context , config , 0 , ""krb5_crypto_init<S2SV_blank>failed:<S2SV_blank>%s"" , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = krb5_verify_checksum ( context , crypto , KRB5_KU_OTHER_CKSUM , datack . data , datack . length , & self . cksum ) ; krb5_data_free ( & datack ) ; krb5_crypto_destroy ( context , crypto ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; free_PA_S4U2Self ( & self ) ; kdc_log ( context , config , 0 , ""krb5_verify_checksum<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>S4U2Self:<S2SV_blank>%s"" , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = _krb5_principalname2krb5_principal ( context , & tp , self . name , self . realm ) ; free_PA_S4U2Self ( & self ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , tp , & tpn ) ; if ( ret ) goto out ; if ( rspac . data ) { krb5_pac p = NULL ; krb5_data_free ( & rspac ) ; ret = _kdc_db_fetch ( context , config , tp , HDB_F_GET_CLIENT | flags , NULL , & s4u2self_impersonated_clientdb , & s4u2self_impersonated_client ) ; if ( ret ) { const char * msg ; if ( ret == HDB_ERR_NOENTRY ) ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 1 , ""S2U4Self<S2SV_blank>principal<S2SV_blank>to<S2SV_blank>impersonate<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s"" , tpn , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = _kdc_pac_generate ( context , s4u2self_impersonated_client , & p ) ; if ( ret ) { kdc_log ( context , config , 0 , ""PAC<S2SV_blank>generation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>--<S2SV_blank>%s"" , tpn ) ; goto out ; } if ( p != NULL ) { ret = _krb5_pac_sign ( context , p , ticket -> ticket . authtime , s4u2self_impersonated_client -> entry . principal , ekey , & tkey_sign -> key , & rspac ) ; krb5_pac_free ( context , p ) ; if ( ret ) { kdc_log ( context , config , 0 , ""PAC<S2SV_blank>signing<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>--<S2SV_blank>%s"" , tpn ) ; goto out ; } } } ret = check_s4u2self ( context , config , clientdb , client , sp ) ; if ( ret ) { kdc_log ( context , config , 0 , ""S4U2Self:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>"" ""to<S2SV_blank>impersonate<S2SV_blank>to<S2SV_blank>service<S2SV_blank>"" ""(tried<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>service<S2SV_blank>%s)"" , cpn , tpn , spn ) ; goto out ; } if ( client -> entry . flags . trusted_for_delegation ) { str = ""[forwardable]"" ; } else { b -> kdc_options . forwardable = 0 ; str = """" ; } kdc_log ( context , config , 0 , ""s4u2self<S2SV_blank>%s<S2SV_blank>impersonating<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>"" ""service<S2SV_blank>%s<S2SV_blank>%s"" , cpn , tpn , spn , str ) ; } } if ( client != NULL && b -> additional_tickets != NULL && b -> additional_tickets -> len != 0 && b -> kdc_options . enc_tkt_in_skey == 0 ) { int ad_signedpath = 0 ; Key * clientkey ; Ticket * t ; if ( ! signedpath ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , ""Constrained<S2SV_blank>delegation<S2SV_blank>done<S2SV_blank>on<S2SV_blank>service<S2SV_blank>ticket<S2SV_blank>%s/%s"" , cpn , spn ) ; goto out ; } t = & b -> additional_tickets -> val [ 0 ] ; ret = hdb_enctype2key ( context , & client -> entry , hdb_kvno2keys ( context , & client -> entry , t -> enc_part . kvno ? * t -> enc_part . kvno : 0 ) , t -> enc_part . etype , & clientkey ) ; if ( ret ) { ret = KRB5KDC_ERR_ETYPE_NOSUPP ; goto out ; } ret = krb5_decrypt_ticket ( context , t , & clientkey -> key , & adtkt , 0 ) ; if ( ret ) { kdc_log ( context , config , 0 , ""failed<S2SV_blank>to<S2SV_blank>decrypt<S2SV_blank>ticket<S2SV_blank>for<S2SV_blank>"" ""constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>"" , cpn , spn ) ; goto out ; } ret = _krb5_principalname2krb5_principal ( context , & tp , adtkt . cname , adtkt . crealm ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , tp , & tpn ) ; if ( ret ) goto out ; ret = _krb5_principalname2krb5_principal ( context , & dp , t -> sname , t -> realm ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , dp , & dpn ) ; if ( ret ) goto out ; if ( adtkt . flags . forwardable == 0 ) { kdc_log ( context , config , 0 , ""Missing<S2SV_blank>forwardable<S2SV_blank>flag<S2SV_blank>on<S2SV_blank>ticket<S2SV_blank>for<S2SV_blank>"" ""constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>"" , cpn , dpn , tpn , spn ) ; ret = KRB5KDC_ERR_BADOPTION ; goto out ; } ret = check_constrained_delegation ( context , config , clientdb , client , server , sp ) ; if ( ret ) { kdc_log ( context , config , 0 , ""constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>allowed"" , cpn , dpn , tpn , spn ) ; goto out ; } ret = verify_flags ( context , config , & adtkt , tpn ) ; if ( ret ) { goto out ; } krb5_data_free ( & rspac ) ; ret = check_PAC ( context , config , tp , dp , client , server , krbtgt , & clientkey -> key , ekey , & tkey_sign -> key , & adtkt , & rspac , & ad_signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""Verify<S2SV_blank>delegated<S2SV_blank>PAC<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client"" ""%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s"" , spn , cpn , dpn , tpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } ret = check_KRB5SignedPath ( context , config , krbtgt , cp , & adtkt , NULL , & ad_signedpath ) ; if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""KRB5SignedPath<S2SV_blank>check<S2SV_blank>from<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>"" ""for<S2SV_blank>delegation<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s<S2SV_blank>(%s)"" ""from<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>%s"" , spn , tpn , dpn , cpn , from , msg ) ; krb5_free_error_message ( context , msg ) ; goto out ; } if ( ! ad_signedpath ) { ret = KRB5KDC_ERR_BADOPTION ; kdc_log ( context , config , 0 , ""Ticket<S2SV_blank>not<S2SV_blank>signed<S2SV_blank>with<S2SV_blank>PAC<S2SV_blank>nor<S2SV_blank>SignedPath<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>"" ""for<S2SV_blank>delegation<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s<S2SV_blank>(%s)"" ""from<S2SV_blank>%s"" , spn , tpn , dpn , cpn , from ) ; goto out ; } kdc_log ( context , config , 0 , ""constrained<S2SV_blank>delegation<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>"" ""from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s"" , tpn , cpn , dpn , spn ) ; } ret = kdc_check_flags ( context , config , client , cpn , server , spn , FALSE ) ; if ( ret ) goto out ; if ( ( b -> kdc_options . validate || b -> kdc_options . renew ) && ! krb5_principal_compare ( context , krbtgt -> entry . principal , server -> entry . principal ) ) { kdc_log ( context , config , 0 , ""Inconsistent<S2SV_blank>request."" ) ; ret = KRB5KDC_ERR_SERVER_NOMATCH ; goto out ; } if ( ! _kdc_check_addresses ( context , config , tgt -> caddr , from_addr ) ) { ret = KRB5KRB_AP_ERR_BADADDR ; kdc_log ( context , config , 0 , ""Request<S2SV_blank>from<S2SV_blank>wrong<S2SV_blank>address"" ) ; goto out ; } if ( ref_realm ) { PA_DATA pa ; krb5_crypto crypto ; kdc_log ( context , config , 0 , ""Adding<S2SV_blank>server<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>%s"" , ref_realm ) ; ret = krb5_crypto_init ( context , & sessionkey , 0 , & crypto ) ; if ( ret ) goto out ; ret = build_server_referral ( context , config , crypto , ref_realm , NULL , s , & pa . padata_value ) ; krb5_crypto_destroy ( context , crypto ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Failed<S2SV_blank>building<S2SV_blank>server<S2SV_blank>referral"" ) ; goto out ; } pa . padata_type = KRB5_PADATA_SERVER_REFERRAL ; ret = add_METHOD_DATA ( & enc_pa_data , & pa ) ; krb5_data_free ( & pa . padata_value ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Add<S2SV_blank>server<S2SV_blank>referral<S2SV_blank>METHOD-DATA<S2SV_blank>failed"" ) ; goto out ; } } ret = tgs_make_reply ( context , config , b , tp , tgt , replykey , rk_is_subkey , ekey , & sessionkey , kvno , * auth_data , server , rsp , spn , client , cp , <S2SV_StartBug> krbtgt_out , <S2SV_EndBug> tkey_sign -> key . keytype , spp , & rspac , & enc_pa_data , e_text , reply ) ; out : if ( tpn != cpn ) free ( tpn ) ; free ( spn ) ; free ( cpn ) ; free ( dpn ) ; free ( krbtgt_out_n ) ; _krb5_free_capath ( context , capath ) ; krb5_data_free ( & rspac ) ; krb5_free_keyblock_contents ( context , & sessionkey ) ; if ( krbtgt_out ) _kdc_free_ent ( context , krbtgt_out ) ; if ( server ) _kdc_free_ent ( context , server ) ; if ( client ) _kdc_free_ent ( context , client ) ; if ( s4u2self_impersonated_client ) _kdc_free_ent ( context , s4u2self_impersonated_client ) ; if ( tp && tp != cp ) krb5_free_principal ( context , tp ) ; krb5_free_principal ( context , cp ) ; krb5_free_principal ( context , dp ) ; krb5_free_principal ( context , sp ) ; krb5_free_principal ( context , krbtgt_out_principal ) ; free ( ref_realm ) ; free_METHOD_DATA ( & enc_pa_data ) ; free_EncTicketPart ( & adtkt ) ; return ret ; }
","<S2SV_ModStart> ; krb5_data rspac ; const char * tgt_realm = krb5_principal_get_realm ( context , krbtgt -> entry . principal ) <S2SV_ModStart> , cp , tgt_realm ,
"
587,"CWE-20 static __always_inline int __do_follow_link ( struct path * path , struct nameidata * nd ) { int error ; void * cookie ; struct dentry * dentry = path -> dentry ; touch_atime ( path -> mnt , dentry ) ; nd_set_link ( nd , NULL ) ; if ( path -> mnt != nd -> path . mnt ) { path_to_nameidata ( path , nd ) ; dget ( dentry ) ; } mntget ( path -> mnt ) ; <S2SV_StartBug> cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ; <S2SV_EndBug> error = PTR_ERR ( cookie ) ; if ( ! IS_ERR ( cookie ) ) { char * s = nd_get_link ( nd ) ; error = 0 ; if ( s ) error = __vfs_follow_link ( nd , s ) ; else if ( nd -> last_type == LAST_BIND ) { error = force_reval_path ( & nd -> path , nd ) ; if ( error ) path_put ( & nd -> path ) ; } if ( dentry -> d_inode -> i_op -> put_link ) dentry -> d_inode -> i_op -> put_link ( dentry , nd , cookie ) ; } return error ; }
","<S2SV_ModStart> mnt ) ; nd -> last_type = LAST_BIND ;
"
588,"CWE-200 static int proc_connectinfo ( struct usb_dev_state * ps , void __user * arg ) { <S2SV_StartBug> struct usbdevfs_connectinfo ci = { <S2SV_EndBug> <S2SV_StartBug> . devnum = ps -> dev -> devnum , <S2SV_EndBug> . slow = ps -> dev -> speed == USB_SPEED_LOW <S2SV_StartBug> } ; <S2SV_EndBug> if ( copy_to_user ( arg , & ci , sizeof ( ci ) ) ) return - EFAULT ; return 0 ; }
","<S2SV_ModStart> struct usbdevfs_connectinfo ci ; memset ( & ci , 0 , sizeof ( ci ) ) ; ci <S2SV_ModEnd> . devnum = <S2SV_ModStart> dev -> devnum ; ci <S2SV_ModEnd> . slow = <S2SV_ModStart> speed == USB_SPEED_LOW <S2SV_ModEnd> ; if (
"
589,"CWE-362 <S2SV_StartBug> static int ip_options_get_finish ( struct net * net , struct ip_options * * optp , <S2SV_EndBug> <S2SV_StartBug> struct ip_options * opt , int optlen ) <S2SV_EndBug> { while ( optlen & 3 ) <S2SV_StartBug> opt -> __data [ optlen ++ ] = IPOPT_END ; <S2SV_EndBug> <S2SV_StartBug> opt -> optlen = optlen ; <S2SV_EndBug> <S2SV_StartBug> if ( optlen && ip_options_compile ( net , opt , NULL ) ) { <S2SV_EndBug> kfree ( opt ) ; return - EINVAL ; } kfree ( * optp ) ; * optp = opt ; return 0 ; }
","<S2SV_ModStart> net , struct ip_options_rcu <S2SV_ModEnd> * * optp <S2SV_ModStart> optp , struct ip_options_rcu <S2SV_ModEnd> * opt , <S2SV_ModStart> ) opt -> opt . <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> ( net , & opt ->
"
590,"CWE-19 STATIC int xfs_attr_leaf_addname ( xfs_da_args_t * args ) { xfs_inode_t * dp ; struct xfs_buf * bp ; int retval , error , committed , forkoff ; trace_xfs_attr_leaf_addname ( args ) ; dp = args -> dp ; args -> blkno = 0 ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return error ; retval = xfs_attr3_leaf_lookup_int ( bp , args ) ; if ( ( args -> flags & ATTR_REPLACE ) && ( retval == ENOATTR ) ) { xfs_trans_brelse ( args -> trans , bp ) ; return retval ; } else if ( retval == EEXIST ) { if ( args -> flags & ATTR_CREATE ) { xfs_trans_brelse ( args -> trans , bp ) ; return retval ; } trace_xfs_attr_leaf_replace ( args ) ; args -> op_flags |= XFS_DA_OP_RENAME ; args -> blkno2 = args -> blkno ; args -> index2 = args -> index ; args -> rmtblkno2 = args -> rmtblkno ; args -> rmtblkcnt2 = args -> rmtblkcnt ; <S2SV_StartBug> } <S2SV_EndBug> retval = xfs_attr3_leaf_add ( bp , args ) ; if ( retval == ENOSPC ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_node ( args ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) return ( error ) ; error = xfs_attr_node_addname ( args ) ; return ( error ) ; } error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) return ( error ) ; if ( args -> rmtblkno > 0 ) { error = xfs_attr_rmtval_set ( args ) ; if ( error ) return ( error ) ; } if ( args -> op_flags & XFS_DA_OP_RENAME ) { error = xfs_attr3_leaf_flipflags ( args ) ; if ( error ) return ( error ) ; args -> index = args -> index2 ; args -> blkno = args -> blkno2 ; args -> rmtblkno = args -> rmtblkno2 ; args -> rmtblkcnt = args -> rmtblkcnt2 ; <S2SV_StartBug> if ( args -> rmtblkno ) { <S2SV_EndBug> error = xfs_attr_rmtval_remove ( args ) ; if ( error ) return ( error ) ; } error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return error ; xfs_attr3_leaf_remove ( bp , args ) ; if ( ( forkoff = xfs_attr_shortform_allfit ( bp , dp ) ) ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_shortform ( bp , args , forkoff ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; } error = xfs_trans_roll ( & args -> trans , dp ) ; } else if ( args -> rmtblkno > 0 ) { error = xfs_attr3_leaf_clearflag ( args ) ; } return error ; }
","<S2SV_ModStart> -> rmtblkcnt ; args -> rmtvaluelen2 = args -> rmtvaluelen ; args -> rmtblkno = 0 ; args -> rmtblkcnt = 0 ; args -> rmtvaluelen = 0 ; <S2SV_ModStart> -> rmtblkcnt2 ; args -> rmtvaluelen = args -> rmtvaluelen2 ;
"
591,"CWE-119 NTSTATUS ProcessMainDeviceControlIrp ( PDEVICE_OBJECT DeviceObject , PEXTENSION Extension , PIRP Irp ) { PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation ( Irp ) ; NTSTATUS ntStatus ; switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_DRIVER_VERSION : case TC_IOCTL_LEGACY_GET_DRIVER_VERSION : if ( ValidateIOBufferSize ( Irp , sizeof ( LONG ) , ValidateOutput ) ) { LONG tmp = VERSION_NUM ; memcpy ( Irp -> AssociatedIrp . SystemBuffer , & tmp , 4 ) ; Irp -> IoStatus . Information = sizeof ( LONG ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_GET_DEVICE_REFCOUNT : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DeviceObject -> ReferenceCount ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { LONG deviceObjectCount = 0 ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DriverUnloadDisabled ; if ( IoEnumerateDeviceObjectList ( TCDriverObject , NULL , 0 , & deviceObjectCount ) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1 ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = TRUE ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_ANY_VOLUME_MOUNTED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { int drive ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { if ( GetVirtualVolumeDeviceObject ( drive ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; break ; } } if ( IsBootDriveMounted ( ) ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_OPEN_TEST : { OPEN_TEST_STRUCT * opentest = ( OPEN_TEST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ; ACCESS_MASK access = FILE_READ_ATTRIBUTES ; if ( ! ValidateIOBufferSize ( Irp , sizeof ( OPEN_TEST_STRUCT ) , ValidateInputOutput ) ) break ; EnsureNullTerminatedString ( opentest -> wszFileName , sizeof ( opentest -> wszFileName ) ) ; RtlInitUnicodeString ( & FullFileName , opentest -> wszFileName ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) access |= FILE_READ_DATA ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | access , & ObjectAttributes , & IoStatus , NULL , 0 , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) { opentest -> TCBootLoaderDetected = FALSE ; opentest -> FilesystemDetected = FALSE ; memset ( opentest -> VolumeIDComputed , 0 , sizeof ( opentest -> VolumeIDComputed ) ) ; memset ( opentest -> volumeIDs , 0 , sizeof ( opentest -> volumeIDs ) ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) { byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { ntStatus = STATUS_INSUFFICIENT_RESOURCES ; } else { if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem ) { offset . QuadPart = 0 ; ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { size_t i ; if ( opentest -> bDetectTCBootLoader && IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) { for ( i = 0 ; i < TC_SECTOR_SIZE_BIOS - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { opentest -> TCBootLoaderDetected = TRUE ; break ; } } } if ( opentest -> DetectFilesystem && IoStatus . Information >= sizeof ( int64 ) ) { switch ( BE64 ( * ( uint64 * ) readBuffer ) ) { case 0xEB52904E54465320ULL : case 0xEB3C904D53444F53ULL : case 0xEB58904D53444F53ULL : case 0xEB76904558464154ULL : case 0x0000005265465300ULL : case 0xEB58906D6B66732EULL : case 0xEB58906D6B646F73ULL : case 0xEB3C906D6B66732EULL : case 0xEB3C906D6B646F73ULL : opentest -> FilesystemDetected = TRUE ; break ; case 0x0000000000000000ULL : if ( IsAllZeroes ( readBuffer + 8 , TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8 ) ) opentest -> FilesystemDetected = TRUE ; break ; } } } } if ( opentest -> bComputeVolumeIDs && ( ! opentest -> DetectFilesystem || ! opentest -> FilesystemDetected ) ) { int volumeType ; for ( volumeType = TC_VOLUME_TYPE_NORMAL ; volumeType < TC_VOLUME_TYPE_COUNT ; volumeType ++ ) { switch ( volumeType ) { case TC_VOLUME_TYPE_NORMAL : offset . QuadPart = TC_VOLUME_HEADER_OFFSET ; break ; case TC_VOLUME_TYPE_HIDDEN : offset . QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET ; break ; } ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { sha256 ( opentest -> volumeIDs [ volumeType ] , readBuffer , TC_VOLUME_HEADER_EFFECTIVE_SIZE ) ; opentest -> VolumeIDComputed [ volumeType ] = TRUE ; } } } TCfree ( readBuffer ) ; } } ZwClose ( NtFileHandle ) ; Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>success.\\n"" , opentest -> wszFileName ) ; } else { # if 0 Dump ( ""Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>failed<S2SV_blank>NTSTATUS<S2SV_blank>0x%08x\\n"" , opentest -> wszFileName , ntStatus ) ; # endif } Irp -> IoStatus . Information = NT_SUCCESS ( ntStatus ) ? sizeof ( OPEN_TEST_STRUCT ) : 0 ; Irp -> IoStatus . Status = ntStatus ; } break ; case TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG : { GetSystemDriveConfigurationRequest * request = ( GetSystemDriveConfigurationRequest * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ; <S2SV_StartBug> byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ; <S2SV_EndBug> if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) ) <S2SV_StartBug> break ; <S2SV_EndBug> EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ; RtlInitUnicodeString ( & FullFileName , request -> DevicePath ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | GENERIC_READ , & ObjectAttributes , & IoStatus , NULL , FILE_ATTRIBUTE_NORMAL , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) { <S2SV_StartBug> offset . QuadPart = 0 ; <S2SV_EndBug> ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , <S2SV_StartBug> sizeof ( readBuffer ) , <S2SV_EndBug> & offset , NULL ) ; <S2SV_StartBug> if ( NT_SUCCESS ( ntStatus ) ) <S2SV_EndBug> { size_t i ; request -> DriveIsDynamic = FALSE ; if ( readBuffer [ 510 ] == 0x55 && readBuffer [ 511 ] == 0xaa ) { int i ; for ( i = 0 ; i < 4 ; ++ i ) { if ( readBuffer [ 446 + i * 16 + 4 ] == PARTITION_LDM ) { request -> DriveIsDynamic = TRUE ; break ; } } } request -> BootLoaderVersion = 0 ; request -> Configuration = 0 ; request -> UserConfiguration = 0 ; request -> CustomUserMessage [ 0 ] = 0 ; for ( i = 0 ; i < sizeof ( readBuffer ) - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { request -> BootLoaderVersion = BE16 ( * ( uint16 * ) ( readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET ) ) ; request -> Configuration = readBuffer [ TC_BOOT_SECTOR_CONFIG_OFFSET ] ; if ( request -> BootLoaderVersion != 0 && request -> BootLoaderVersion <= VERSION_NUM ) { request -> UserConfiguration = readBuffer [ TC_BOOT_SECTOR_USER_CONFIG_OFFSET ] ; memcpy ( request -> CustomUserMessage , readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET , TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH ) ; } break ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else { <S2SV_StartBug> Irp -> IoStatus . Status = ntStatus ; <S2SV_EndBug> <S2SV_StartBug> Irp -> IoStatus . Information = 0 ; <S2SV_EndBug> } ZwClose ( NtFileHandle ) ; } else { Irp -> IoStatus . Status = ntStatus ; Irp -> IoStatus . Information = 0 ; } } break ; case TC_IOCTL_WIPE_PASSWORD_CACHE : WipeCache ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : Irp -> IoStatus . Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_SET_PORTABLE_MODE_STATUS : if ( ! UserCanAccessDriveDevice ( ) ) { Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; } else { PortableMode = TRUE ; Dump ( ""Setting<S2SV_blank>portable<S2SV_blank>mode\\n"" ) ; } break ; case TC_IOCTL_GET_PORTABLE_MODE_STATUS : Irp -> IoStatus . Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_LIST_STRUCT ) , ValidateOutput ) ) { MOUNT_LIST_STRUCT * list = ( MOUNT_LIST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice ; int drive ; list -> ulMountedDrives = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { PEXTENSION ListExtension ; ListDevice = GetVirtualVolumeDeviceObject ( drive ) ; if ( ! ListDevice ) continue ; ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { list -> ulMountedDrives |= ( 1 << ListExtension -> nDosDriveNo ) ; RtlStringCbCopyW ( list -> wszVolume [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszVolume [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( list -> wszLabel [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszLabel [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszLabel ) ; memcpy ( list -> volumeID [ ListExtension -> nDosDriveNo ] , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; list -> diskLength [ ListExtension -> nDosDriveNo ] = ListExtension -> DiskLength ; list -> ea [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> ea ; if ( ListExtension -> cryptoInfo -> hiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_HIDDEN ; else if ( ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED ; else if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER ; else list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_NORMAL ; list -> truecryptMode [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> bTrueCryptMode ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( MOUNT_LIST_STRUCT ) ; } break ; case TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( uint32 ) , ValidateOutput ) ) { memset ( Irp -> AssociatedIrp . SystemBuffer , 0 , irpSp -> Parameters . DeviceIoControl . OutputBufferLength ) ; * ( uint32 * ) Irp -> AssociatedIrp . SystemBuffer = 0xffffFFFF ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = irpSp -> Parameters . DeviceIoControl . OutputBufferLength ; } break ; case TC_IOCTL_GET_VOLUME_PROPERTIES : if ( ValidateIOBufferSize ( Irp , sizeof ( VOLUME_PROPERTIES_STRUCT ) , ValidateInputOutput ) ) { VOLUME_PROPERTIES_STRUCT * prop = ( VOLUME_PROPERTIES_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( prop -> driveNo ) ; Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { prop -> uniqueId = ListExtension -> UniqueVolumeId ; RtlStringCbCopyW ( prop -> wszVolume , sizeof ( prop -> wszVolume ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( prop -> wszLabel , sizeof ( prop -> wszLabel ) , ListExtension -> wszLabel ) ; memcpy ( prop -> volumeID , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; prop -> bDriverSetLabel = ListExtension -> bDriverSetLabel ; prop -> diskLength = ListExtension -> DiskLength ; prop -> ea = ListExtension -> cryptoInfo -> ea ; prop -> mode = ListExtension -> cryptoInfo -> mode ; prop -> pkcs5 = ListExtension -> cryptoInfo -> pkcs5 ; prop -> pkcs5Iterations = ListExtension -> cryptoInfo -> noIterations ; prop -> volumePim = ListExtension -> cryptoInfo -> volumePim ; # if 0 prop -> volumeCreationTime = ListExtension -> cryptoInfo -> volume_creation_time ; prop -> headerCreationTime = ListExtension -> cryptoInfo -> header_creation_time ; # endif prop -> volumeHeaderFlags = ListExtension -> cryptoInfo -> HeaderFlags ; prop -> readOnly = ListExtension -> bReadOnly ; prop -> removable = ListExtension -> bRemovable ; prop -> partitionInInactiveSysEncScope = ListExtension -> PartitionInInactiveSysEncScope ; prop -> hiddenVolume = ListExtension -> cryptoInfo -> hiddenVolume ; if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) prop -> hiddenVolProtection = ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE ; else prop -> hiddenVolProtection = HIDVOL_PROT_STATUS_NONE ; prop -> totalBytesRead = ListExtension -> Queue . TotalBytesRead ; prop -> totalBytesWritten = ListExtension -> Queue . TotalBytesWritten ; prop -> volFormatVersion = ListExtension -> cryptoInfo -> LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( VOLUME_PROPERTIES_STRUCT ) ; } } } break ; case TC_IOCTL_GET_RESOLVED_SYMLINK : if ( ValidateIOBufferSize ( Irp , sizeof ( RESOLVE_SYMLINK_STRUCT ) , ValidateInputOutput ) ) { RESOLVE_SYMLINK_STRUCT * resolve = ( RESOLVE_SYMLINK_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( resolve -> symLinkName , sizeof ( resolve -> symLinkName ) ) ; ntStatus = SymbolicLinkToTarget ( resolve -> symLinkName , resolve -> targetName , sizeof ( resolve -> targetName ) ) ; Irp -> IoStatus . Information = sizeof ( RESOLVE_SYMLINK_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_PARTITION_INFO : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_PARTITION_INFO_STRUCT ) , ValidateInputOutput ) ) { DISK_PARTITION_INFO_STRUCT * info = ( DISK_PARTITION_INFO_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { PARTITION_INFORMATION_EX pi ; NTSTATUS ntStatus ; EnsureNullTerminatedString ( info -> deviceName , sizeof ( info -> deviceName ) ) ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO_EX , NULL , 0 , & pi , sizeof ( pi ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = pi . PartitionLength ; info -> partInfo . PartitionNumber = pi . PartitionNumber ; info -> partInfo . StartingOffset = pi . StartingOffset ; if ( pi . PartitionStyle == PARTITION_STYLE_MBR ) { info -> partInfo . PartitionType = pi . Mbr . PartitionType ; info -> partInfo . BootIndicator = pi . Mbr . BootIndicator ; } info -> IsGPT = pi . PartitionStyle == PARTITION_STYLE_GPT ; } else { ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO , NULL , 0 , & info -> partInfo , sizeof ( info -> partInfo ) ) ; info -> IsGPT = FALSE ; } if ( ! NT_SUCCESS ( ntStatus ) ) { GET_LENGTH_INFORMATION lengthInfo ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_LENGTH_INFO , NULL , 0 , & lengthInfo , sizeof ( lengthInfo ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = lengthInfo . Length ; } } info -> IsDynamic = FALSE ; if ( NT_SUCCESS ( ntStatus ) && OsMajorVersion >= 6 ) { # define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE ( IOCTL_VOLUME_BASE , 18 , METHOD_BUFFERED , FILE_ANY_ACCESS ) if ( ! NT_SUCCESS ( TCDeviceIoControl ( info -> deviceName , IOCTL_VOLUME_IS_DYNAMIC , NULL , 0 , & info -> IsDynamic , sizeof ( info -> IsDynamic ) ) ) ) info -> IsDynamic = FALSE ; } Irp -> IoStatus . Information = sizeof ( DISK_PARTITION_INFO_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_GEOMETRY : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_STRUCT * g = ( DISK_GEOMETRY_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & g -> diskGeometry , sizeof ( g -> diskGeometry ) ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case VC_IOCTL_GET_DRIVE_GEOMETRY_EX : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_EX_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_EX_STRUCT * g = ( DISK_GEOMETRY_EX_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; PVOID buffer = TCalloc ( 256 ) ; if ( buffer ) { EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( ""Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY_EX<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY_EX , NULL , 0 , buffer , 256 ) ; if ( NT_SUCCESS ( ntStatus ) ) { PDISK_GEOMETRY_EX pGeo = ( PDISK_GEOMETRY_EX ) buffer ; memcpy ( & g -> diskGeometry , & pGeo -> Geometry , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = pGeo -> DiskSize . QuadPart ; } else { DISK_GEOMETRY dg = { 0 } ; Dump ( ""Failed.<S2SV_blank>Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & dg , sizeof ( dg ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memcpy ( & g -> diskGeometry , & dg , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = dg . Cylinders . QuadPart * dg . SectorsPerTrack * dg . TracksPerCylinder * dg . BytesPerSector ; if ( OsMajorVersion >= 6 ) { STORAGE_READ_CAPACITY storage = { 0 } ; NTSTATUS lStatus ; storage . Version = sizeof ( STORAGE_READ_CAPACITY ) ; Dump ( ""Calling<S2SV_blank>IOCTL_STORAGE_READ_CAPACITY<S2SV_blank>on<S2SV_blank>%ls\\n"" , g -> deviceName ) ; lStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_STORAGE_READ_CAPACITY , NULL , 0 , & storage , sizeof ( STORAGE_READ_CAPACITY ) ) ; if ( NT_SUCCESS ( lStatus ) && ( storage . Size == sizeof ( STORAGE_READ_CAPACITY ) ) ) { g -> DiskSize . QuadPart = storage . DiskLength . QuadPart ; } } } } TCfree ( buffer ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_EX_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } else { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } } } break ; case TC_IOCTL_PROBE_REAL_DRIVE_SIZE : if ( ValidateIOBufferSize ( Irp , sizeof ( ProbeRealDriveSizeRequest ) , ValidateInputOutput ) ) { ProbeRealDriveSizeRequest * request = ( ProbeRealDriveSizeRequest * ) Irp -> AssociatedIrp . SystemBuffer ; NTSTATUS status ; UNICODE_STRING name ; PFILE_OBJECT fileObject ; PDEVICE_OBJECT deviceObject ; EnsureNullTerminatedString ( request -> DeviceName , sizeof ( request -> DeviceName ) ) ; RtlInitUnicodeString ( & name , request -> DeviceName ) ; status = IoGetDeviceObjectPointer ( & name , FILE_READ_ATTRIBUTES , & fileObject , & deviceObject ) ; if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; break ; } status = ProbeRealDriveSize ( deviceObject , & request -> RealDriveSize ) ; ObDereferenceObject ( fileObject ) ; if ( status == STATUS_TIMEOUT ) { request -> TimeOut = TRUE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; } else { request -> TimeOut = FALSE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = status ; } } break ; case TC_IOCTL_MOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_STRUCT ) , ValidateInputOutput ) ) { MOUNT_STRUCT * mount = ( MOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; if ( mount -> VolumePassword . Length > MAX_PASSWORD || mount -> ProtectedHidVolPassword . Length > MAX_PASSWORD || mount -> pkcs5_prf < 0 || mount -> pkcs5_prf > LAST_PRF_ID || mount -> VolumePim < - 1 || mount -> VolumePim == INT_MAX || mount -> ProtectedHidVolPkcs5Prf < 0 || mount -> ProtectedHidVolPkcs5Prf > LAST_PRF_ID || ( mount -> bTrueCryptMode != FALSE && mount -> bTrueCryptMode != TRUE ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } EnsureNullTerminatedString ( mount -> wszVolume , sizeof ( mount -> wszVolume ) ) ; EnsureNullTerminatedString ( mount -> wszLabel , sizeof ( mount -> wszLabel ) ) ; Irp -> IoStatus . Information = sizeof ( MOUNT_STRUCT ) ; Irp -> IoStatus . Status = MountDevice ( DeviceObject , mount ) ; burn ( & mount -> VolumePassword , sizeof ( mount -> VolumePassword ) ) ; burn ( & mount -> ProtectedHidVolPassword , sizeof ( mount -> ProtectedHidVolPassword ) ) ; burn ( & mount -> pkcs5_prf , sizeof ( mount -> pkcs5_prf ) ) ; burn ( & mount -> VolumePim , sizeof ( mount -> VolumePim ) ) ; burn ( & mount -> bTrueCryptMode , sizeof ( mount -> bTrueCryptMode ) ) ; burn ( & mount -> ProtectedHidVolPkcs5Prf , sizeof ( mount -> ProtectedHidVolPkcs5Prf ) ) ; burn ( & mount -> ProtectedHidVolPim , sizeof ( mount -> ProtectedHidVolPim ) ) ; } break ; case TC_IOCTL_DISMOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( unmount -> nDosDriveNo ) ; unmount -> nReturnCode = ERR_DRIVE_NOT_FOUND ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) unmount -> nReturnCode = UnmountDevice ( unmount , ListDevice , unmount -> ignoreOpenFiles ) ; } Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_DISMOUNT_ALL_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; unmount -> nReturnCode = UnmountAllDevices ( unmount , unmount -> ignoreOpenFiles ) ; Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = StartBootEncryptionSetup ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = AbortBootEncryptionSetup ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : GetBootEncryptionStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT : Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = GetSetupResult ( ) ; break ; case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : GetBootDriveVolumeProperties ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_LOADER_VERSION : GetBootLoaderVersion ( Irp , irpSp ) ; break ; case TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER : ReopenBootVolumeHeader ( Irp , irpSp ) ; break ; case VC_IOCTL_GET_BOOT_LOADER_FINGERPRINT : GetBootLoaderFingerprint ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME : GetBootEncryptionAlgorithmName ( Irp , irpSp ) ; break ; case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = IsHiddenSystemRunning ( ) ? 1 : 0 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_START_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = StartDecoySystemWipe ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = AbortDecoySystemWipe ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT : Irp -> IoStatus . Status = GetDecoySystemWipeResult ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS : GetDecoySystemWipeStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR : Irp -> IoStatus . Status = WriteBootDriveSector ( Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_WARNING_FLAGS : if ( ValidateIOBufferSize ( Irp , sizeof ( GetWarningFlagsRequest ) , ValidateOutput ) ) { GetWarningFlagsRequest * flags = ( GetWarningFlagsRequest * ) Irp -> AssociatedIrp . SystemBuffer ; flags -> PagingFileCreationPrevented = PagingFileCreationPrevented ; PagingFileCreationPrevented = FALSE ; flags -> SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty ; SystemFavoriteVolumeDirty = FALSE ; Irp -> IoStatus . Information = sizeof ( GetWarningFlagsRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY : if ( UserCanAccessDriveDevice ( ) ) { SystemFavoriteVolumeDirty = TRUE ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_REREAD_DRIVER_CONFIG : Irp -> IoStatus . Status = ReadRegistryConfigFlags ( FALSE ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG : if ( ( ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveDumpConfigRequest ) , ValidateOutput ) ) && ( Irp -> RequestorMode == KernelMode ) ) { GetSystemDriveDumpConfigRequest * request = ( GetSystemDriveDumpConfigRequest * ) Irp -> AssociatedIrp . SystemBuffer ; request -> BootDriveFilterExtension = GetBootDriveFilterExtension ( ) ; if ( IsBootDriveMounted ( ) && request -> BootDriveFilterExtension ) { request -> HwEncryptionEnabled = IsHwEncryptionEnabled ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } break ; default : return TCCompleteIrp ( Irp , STATUS_INVALID_DEVICE_REQUEST , 0 ) ; } # if defined ( DEBUG ) || defined ( DEBUG_TRACE ) if ( ! NT_SUCCESS ( Irp -> IoStatus . Status ) ) { switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_MOUNTED_VOLUMES : case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : case TC_IOCTL_GET_PORTABLE_MODE_STATUS : case TC_IOCTL_SET_PORTABLE_MODE_STATUS : case TC_IOCTL_OPEN_TEST : case TC_IOCTL_GET_RESOLVED_SYMLINK : case TC_IOCTL_GET_DRIVE_PARTITION_INFO : case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : break ; default : Dump ( ""IOCTL<S2SV_blank>error<S2SV_blank>0x%08x\\n"" , Irp -> IoStatus . Status ) ; } } # endif return TCCompleteIrp ( Irp , Irp -> IoStatus . Status , Irp -> IoStatus . Information ) ; }
","<S2SV_ModStart> LARGE_INTEGER offset ; size_t devicePathLen = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) break ; if ( ! NT_SUCCESS ( RtlUnalignedStringCchLengthW ( request -> DevicePath , TC_MAX_PATH , & devicePathLen ) ) || ( devicePathLen < 28 ) || ( devicePathLen > 30 ) || ( memcmp ( request -> DevicePath , L""\\\\Device\\\\Harddisk"" , 16 * sizeof ( WCHAR ) ) ) || ( memcmp ( & request -> DevicePath [ devicePathLen - 11 ] , L""\\\\Partition0"" , 11 * sizeof ( WCHAR ) ) ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } <S2SV_ModStart> ) ) { byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } else { <S2SV_ModStart> , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE <S2SV_ModEnd> , & offset <S2SV_ModStart> ( ntStatus ) ) { if ( IoStatus . Information >= TC_SECTOR_SIZE_BIOS <S2SV_ModStart> . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } else { Irp -> IoStatus . Status = <S2SV_ModStart> Information = 0 ; } TCfree ( readBuffer )
"
592,"CWE-190 static int on_http_message_complete ( http_parser * parser ) { struct clt_info * info = parser -> data ; ws_svr * svr = ws_svr_from_ses ( info -> ses ) ; info -> request -> version_major = parser -> http_major ; info -> request -> version_minor = parser -> http_minor ; info -> request -> method = parser -> method ; dict_entry * entry ; dict_iterator * iter = dict_get_iterator ( info -> request -> headers ) ; while ( ( entry = dict_next ( iter ) ) != NULL ) { log_trace ( ""Header:<S2SV_blank>%s:<S2SV_blank>%s"" , ( char * ) entry -> key , ( char * ) entry -> val ) ; } dict_release_iterator ( iter ) ; if ( info -> request -> method != HTTP_GET ) goto error ; if ( http_request_get_header ( info -> request , ""Host"" ) == NULL ) goto error ; double version = info -> request -> version_major + info -> request -> version_minor * 0.1 ; if ( version < 1.1 ) goto error ; const char * upgrade = http_request_get_header ( info -> request , ""Upgrade"" ) ; if ( upgrade == NULL || strcasecmp ( upgrade , ""websocket"" ) != 0 ) goto error ; const char * connection = http_request_get_header ( info -> request , ""Connection"" ) ; <S2SV_StartBug> if ( connection == NULL ) <S2SV_EndBug> goto error ; else { bool found_upgrade = false ; int count ; sds * tokens = sdssplitlen ( connection , strlen ( connection ) , "","" , 1 , & count ) ; if ( tokens == NULL ) goto error ; for ( int i = 0 ; i < count ; i ++ ) { sds token = tokens [ i ] ; sdstrim ( token , ""<S2SV_blank>"" ) ; if ( strcasecmp ( token , ""Upgrade"" ) == 0 ) { found_upgrade = true ; break ; } } sdsfreesplitres ( tokens , count ) ; if ( ! found_upgrade ) goto error ; } const char * ws_version = http_request_get_header ( info -> request , ""Sec-WebSocket-Version"" ) ; if ( ws_version == NULL || strcmp ( ws_version , ""13"" ) != 0 ) goto error ; const char * ws_key = http_request_get_header ( info -> request , ""Sec-WebSocket-Key"" ) ; if ( ws_key == NULL ) goto error ; const char * protocol_list = http_request_get_header ( info -> request , ""Sec-WebSocket-Protocol"" ) ; if ( protocol_list && ! is_good_protocol ( protocol_list , svr -> protocol ) ) goto error ; if ( strlen ( svr -> origin ) > 0 ) { const char * origin = http_request_get_header ( info -> request , ""Origin"" ) ; if ( origin == NULL || ! is_good_origin ( origin , svr -> origin ) ) goto error ; } if ( svr -> type . on_privdata_alloc ) { info -> privdata = svr -> type . on_privdata_alloc ( svr ) ; if ( info -> privdata == NULL ) goto error ; } info -> upgrade = true ; info -> remote = sdsnew ( http_get_remote_ip ( info -> ses , info -> request ) ) ; info -> url = sdsnew ( info -> request -> url ) ; if ( svr -> type . on_upgrade ) { svr -> type . on_upgrade ( info -> ses , info -> remote ) ; } if ( protocol_list ) { send_hand_shake_reply ( info -> ses , svr -> protocol , ws_key ) ; } else { send_hand_shake_reply ( info -> ses , NULL , ws_key ) ; } return 0 ; error : ws_svr_close_clt ( ws_svr_from_ses ( info -> ses ) , info -> ses ) ; return - 1 ; }
","<S2SV_ModStart> connection == NULL || strlen ( connection ) > UT_WS_SVR_MAX_HEADER_SIZE
"
593,"CWE-20 static int daemon_msg_findallif_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen ) { char errbuf [ PCAP_ERRBUF_SIZE ] ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; char sendbuf [ RPCAP_NETBUF_SIZE ] ; int sendbufidx = 0 ; pcap_if_t * alldevs = NULL ; pcap_if_t * d ; struct pcap_addr * address ; struct rpcap_findalldevs_if * findalldevs_if ; <S2SV_StartBug> uint16 nif = 0 ; <S2SV_EndBug> if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) { return - 1 ; } if ( pcap_findalldevs ( & alldevs , errmsgbuf ) == - 1 ) goto error ; if ( alldevs == NULL ) { if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_NOREMOTEIF , ""No<S2SV_blank>interfaces<S2SV_blank>found!<S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>libpcap/WinPcap<S2SV_blank>is<S2SV_blank>properly<S2SV_blank>installed"" ""<S2SV_blank>and<S2SV_blank>you<S2SV_blank>have<S2SV_blank>the<S2SV_blank>right<S2SV_blank>to<S2SV_blank>access<S2SV_blank>to<S2SV_blank>the<S2SV_blank>remote<S2SV_blank>device."" , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; } <S2SV_StartBug> for ( d = alldevs ; d != NULL ; d = d -> next ) <S2SV_EndBug> { nif ++ ; if ( d -> description ) <S2SV_StartBug> plen += strlen ( d -> description ) ; <S2SV_EndBug> if ( d -> name ) <S2SV_StartBug> plen += strlen ( d -> name ) ; <S2SV_EndBug> <S2SV_StartBug> plen += sizeof ( struct rpcap_findalldevs_if ) ; <S2SV_EndBug> for ( address = d -> addresses ; address != NULL ; address = address -> next ) { switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif <S2SV_StartBug> plen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ; <S2SV_EndBug> break ; default : break ; } } } if ( sock_bufferize ( NULL , sizeof ( struct rpcap_header ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , <S2SV_StartBug> RPCAP_MSG_FINDALLIF_REPLY , nif , plen ) ; <S2SV_EndBug> for ( d = alldevs ; d != NULL ; d = d -> next ) { uint16 lname , ldescr ; findalldevs_if = ( struct rpcap_findalldevs_if * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_findalldevs_if ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; memset ( findalldevs_if , 0 , sizeof ( struct rpcap_findalldevs_if ) ) ; if ( d -> description ) ldescr = ( short ) strlen ( d -> description ) ; else ldescr = 0 ; if ( d -> name ) lname = ( short ) strlen ( d -> name ) ; else lname = 0 ; findalldevs_if -> desclen = htons ( ldescr ) ; findalldevs_if -> namelen = htons ( lname ) ; findalldevs_if -> flags = htonl ( d -> flags ) ; for ( address = d -> addresses ; address != NULL ; address = address -> next ) { switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif findalldevs_if -> naddr ++ ; break ; default : break ; } } findalldevs_if -> naddr = htons ( findalldevs_if -> naddr ) ; if ( sock_bufferize ( d -> name , lname , sendbuf , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_BUFFERIZE , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; if ( sock_bufferize ( d -> description , ldescr , sendbuf , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_BUFFERIZE , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; for ( address = d -> addresses ; address != NULL ; address = address -> next ) { struct rpcap_sockaddr * sockaddr ; switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> addr , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> netmask , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> broadaddr , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> dstaddr , sockaddr ) ; break ; default : break ; } } } pcap_freealldevs ( alldevs ) ; if ( sock_send ( pars -> sockctrl , sendbuf , sendbufidx , errbuf , PCAP_ERRBUF_SIZE ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; error : if ( alldevs ) pcap_freealldevs ( alldevs ) ; if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_FINDALLIF , errmsgbuf , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , ""Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s"" , errbuf ) ; return - 1 ; } return 0 ; }
","<S2SV_ModStart> * findalldevs_if ; uint32 replylen ; <S2SV_ModStart> 0 ; } replylen = 0 ; <S2SV_ModStart> -> description ) replylen <S2SV_ModEnd> += strlen ( <S2SV_ModStart> -> name ) replylen <S2SV_ModEnd> += strlen ( <S2SV_ModStart> name ) ; replylen <S2SV_ModEnd> += sizeof ( <S2SV_ModStart> : # endif replylen <S2SV_ModEnd> += ( sizeof <S2SV_ModStart> , nif , replylen <S2SV_ModEnd> ) ; for
"
594,"CWE-200 static int create_problem_dir ( GHashTable * problem_info , unsigned pid ) { if ( g_settings_nMaxCrashReportsSize > 0 ) { if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) exit ( 1 ) ; } gchar * dir_basename = g_hash_table_lookup ( problem_info , ""basename"" ) ; if ( ! dir_basename ) dir_basename = g_hash_table_lookup ( problem_info , FILENAME_TYPE ) ; char * path = xasprintf ( ""%s/%s-%s-%u.new"" , g_settings_dump_location , dir_basename , iso_date_string ( NULL ) , pid ) ; g_hash_table_remove ( problem_info , ""basename"" ) ; <S2SV_StartBug> struct dump_dir * dd = dd_create ( path , client_uid , DEFAULT_DUMP_DIR_MODE ) ; <S2SV_EndBug> if ( ! dd ) { error_msg_and_die ( ""Error<S2SV_blank>creating<S2SV_blank>problem<S2SV_blank>directory<S2SV_blank>\'%s\'"" , path ) ; } dd_create_basic_files ( dd , client_uid , NULL ) ; dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; gpointer gpkey = g_hash_table_lookup ( problem_info , FILENAME_CMDLINE ) ; if ( ! gpkey ) { char * cmdline = get_cmdline ( pid ) ; if ( cmdline ) { dd_save_text ( dd , FILENAME_CMDLINE , cmdline ) ; free ( cmdline ) ; } } char uid_str [ sizeof ( long ) * 3 + 2 ] ; sprintf ( uid_str , ""%lu"" , ( long ) client_uid ) ; dd_save_text ( dd , FILENAME_UID , uid_str ) ; GHashTableIter iter ; gpointer gpvalue ; g_hash_table_iter_init ( & iter , problem_info ) ; while ( g_hash_table_iter_next ( & iter , & gpkey , & gpvalue ) ) { dd_save_text ( dd , ( gchar * ) gpkey , ( gchar * ) gpvalue ) ; } dd_close ( dd ) ; g_hash_table_destroy ( problem_info ) ; char * newpath = xstrndup ( path , strlen ( path ) - strlen ( "".new"" ) ) ; if ( rename ( path , newpath ) == 0 ) strcpy ( path , newpath ) ; free ( newpath ) ; log_notice ( ""Saved<S2SV_blank>problem<S2SV_blank>directory<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%u<S2SV_blank>to<S2SV_blank>\'%s\'"" , pid , path ) ; printf ( ""HTTP/1.1<S2SV_blank>201<S2SV_blank>Created\\r\\n\\r\\n"" ) ; fflush ( NULL ) ; close ( STDOUT_FILENO ) ; xdup2 ( STDERR_FILENO , STDOUT_FILENO ) ; if ( g_settings_nMaxCrashReportsSize > 0 ) { trim_problem_dirs ( g_settings_dump_location , g_settings_nMaxCrashReportsSize * ( double ) ( 1024 * 1024 ) , path ) ; } run_post_create ( path ) ; exit ( 0 ) ; }
","<S2SV_ModStart> ( path , g_settings_privatereports ? 0 :
"
595,"CWE-787 static void InsertRow ( unsigned char * p , ssize_t y , Image * image , int bpp ) { ExceptionInfo * exception ; int bit ; ssize_t x ; register PixelPacket * q ; IndexPacket index ; register IndexPacket * indexes ; exception = ( & image -> exception ) ; switch ( bpp ) { case 1 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } case 2 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; <S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) <S2SV_EndBug> { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 ) ; SetPixelIndex ( indexes + x + 1 , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; if ( ( image -> columns % 4 ) >= 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; if ( ( image -> columns % 4 ) >= 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex ( image , ( * p ) & 0x0f ) ; SetPixelIndex ( indexes + x + 1 , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( ( image -> columns % 2 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 8 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } break ; case 24 : q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } }
","<S2SV_ModStart> ; x += 4 <S2SV_ModEnd> ) { index
"
596,"CWE-310 void bn_sqr_comba8 ( BN_ULONG * r , const BN_ULONG * a ) { <S2SV_StartBug> BN_ULONG t1 , t2 ; <S2SV_EndBug> BN_ULONG c1 , c2 , c3 ; c1 = 0 ; c2 = 0 ; c3 = 0 ; sqr_add_c ( a , 0 , c1 , c2 , c3 ) ; r [ 0 ] = c1 ; c1 = 0 ; sqr_add_c2 ( a , 1 , 0 , c2 , c3 , c1 ) ; r [ 1 ] = c2 ; c2 = 0 ; sqr_add_c ( a , 1 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 2 , 0 , c3 , c1 , c2 ) ; r [ 2 ] = c3 ; c3 = 0 ; sqr_add_c2 ( a , 3 , 0 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 2 , 1 , c1 , c2 , c3 ) ; r [ 3 ] = c1 ; c1 = 0 ; sqr_add_c ( a , 2 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 3 , 1 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 4 , 0 , c2 , c3 , c1 ) ; r [ 4 ] = c2 ; c2 = 0 ; sqr_add_c2 ( a , 5 , 0 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 4 , 1 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 3 , 2 , c3 , c1 , c2 ) ; r [ 5 ] = c3 ; c3 = 0 ; sqr_add_c ( a , 3 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 4 , 2 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 5 , 1 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 6 , 0 , c1 , c2 , c3 ) ; r [ 6 ] = c1 ; c1 = 0 ; sqr_add_c2 ( a , 7 , 0 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 6 , 1 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 5 , 2 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 4 , 3 , c2 , c3 , c1 ) ; r [ 7 ] = c2 ; c2 = 0 ; sqr_add_c ( a , 4 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 5 , 3 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 6 , 2 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 7 , 1 , c3 , c1 , c2 ) ; r [ 8 ] = c3 ; c3 = 0 ; sqr_add_c2 ( a , 7 , 2 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 6 , 3 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 5 , 4 , c1 , c2 , c3 ) ; r [ 9 ] = c1 ; c1 = 0 ; sqr_add_c ( a , 5 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 6 , 4 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 7 , 3 , c2 , c3 , c1 ) ; r [ 10 ] = c2 ; c2 = 0 ; sqr_add_c2 ( a , 7 , 4 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 6 , 5 , c3 , c1 , c2 ) ; r [ 11 ] = c3 ; c3 = 0 ; sqr_add_c ( a , 6 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 7 , 5 , c1 , c2 , c3 ) ; r [ 12 ] = c1 ; c1 = 0 ; sqr_add_c2 ( a , 7 , 6 , c2 , c3 , c1 ) ; r [ 13 ] = c2 ; c2 = 0 ; sqr_add_c ( a , 7 , c3 , c1 , c2 ) ; r [ 14 ] = c3 ; r [ 15 ] = c1 ; }
","<S2SV_ModStart> ) { BN_ULONG <S2SV_ModEnd> c1 , c2
"
597,"CWE-125 static void __skb_complete_tx_timestamp ( struct sk_buff * skb , struct sock * sk , <S2SV_StartBug> int tstype ) <S2SV_EndBug> { struct sock_exterr_skb * serr ; <S2SV_StartBug> int err ; <S2SV_EndBug> serr = SKB_EXT_ERR ( skb ) ; memset ( serr , 0 , sizeof ( * serr ) ) ; serr -> ee . ee_errno = ENOMSG ; serr -> ee . ee_origin = SO_EE_ORIGIN_TIMESTAMPING ; <S2SV_StartBug> serr -> ee . ee_info = tstype ; <S2SV_EndBug> if ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) { serr -> ee . ee_data = skb_shinfo ( skb ) -> tskey ; if ( sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) serr -> ee . ee_data -= sk -> sk_tskey ; } err = sock_queue_err_skb ( sk , skb ) ; if ( err ) kfree_skb ( skb ) ; }
","<S2SV_ModStart> , int tstype , bool opt_stats <S2SV_ModStart> ; int err ; BUILD_BUG_ON ( sizeof ( struct sock_exterr_skb ) > sizeof ( skb -> cb ) ) <S2SV_ModStart> ee_info = tstype ; serr -> opt_stats = opt_stats
"
598,"CWE-119 static Image * ReadDDSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status , cubemap = MagickFalse , volume = MagickFalse , matte ; CompressionType compression ; DDSInfo dds_info ; DDSDecoder * decoder ; size_t n , num_images ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) { ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ; if ( dds_info . ddscaps2 & DDSCAPS2_VOLUME && dds_info . depth > 0 ) volume = MagickTrue ; ( void ) SeekBlob ( image , 128 , SEEK_SET ) ; if ( dds_info . pixelformat . flags & DDPF_RGB ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { matte = MagickTrue ; decoder = ReadUncompressedRGBA ; } else { matte = MagickTrue ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_LUMINANCE ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } else { matte = MagickFalse ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_FOURCC ) { switch ( dds_info . pixelformat . fourcc ) { case FOURCC_DXT1 : { matte = MagickFalse ; compression = DXT1Compression ; decoder = ReadDXT1 ; break ; } case FOURCC_DXT3 : { matte = MagickTrue ; compression = DXT3Compression ; decoder = ReadDXT3 ; break ; } case FOURCC_DXT5 : { matte = MagickTrue ; compression = DXT5Compression ; decoder = ReadDXT5 ; break ; } default : { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } } } else { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } num_images = 1 ; if ( cubemap ) { num_images = 0 ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) num_images ++ ; } if ( volume ) num_images = dds_info . depth ; for ( n = 0 ; n < num_images ; n ++ ) { if ( n != 0 ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } image -> matte = matte ; image -> compression = compression ; image -> columns = dds_info . width ; image -> rows = dds_info . height ; image -> storage_class = DirectClass ; image -> endian = LSBEndian ; image -> depth = 8 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } <S2SV_StartBug> if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue ) <S2SV_EndBug> { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } } if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
"
599,"CWE-125 void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknown<S2SV_blank>type<S2SV_blank>(%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u,<S2SV_blank>%s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "",<S2SV_blank>(ttl<S2SV_blank>%u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>vrid<S2SV_blank>%u,<S2SV_blank>prio<S2SV_blank>%u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "",<S2SV_blank>authtype<S2SV_blank>%s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>intvl<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>%u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "",<S2SV_blank>intvl<S2SV_blank>%ucs,<S2SV_blank>length<S2SV_blank>%u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; <S2SV_StartBug> if ( in_cksum ( vec , 1 ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , "",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)"" , <S2SV_StartBug> EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; <S2SV_EndBug> } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , "",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , "",<S2SV_blank>addrs"" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , ""(%d)"" , naddrs ) ) ; ND_PRINT ( ( ndo , "":"" ) ) ; c = '<S2SV_blank>' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , ""%c%s"" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>auth<S2SV_blank>\\"""" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|vrrp]"" ) ) ; }
","<S2SV_ModStart> 1 ) ) { ND_TCHECK_16BITS ( & bp [ 6 ] ) ; <S2SV_ModStart> ) ) ; }
"
600,"CWE-190 static void test_burl_normalize ( void ) { buffer * psrc = buffer_init ( ) ; buffer * ptmp = buffer_init ( ) ; int flags ; flags = HTTP_PARSEOPT_URL_NORMALIZE_UNRESERVED ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""no-slash"" ) , CONST_STR_LEN ( ""no-slash"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/"" ) , CONST_STR_LEN ( ""/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc"" ) , CONST_STR_LEN ( ""/abc"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc/"" ) , CONST_STR_LEN ( ""/abc/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc/def"" ) , CONST_STR_LEN ( ""/abc/def"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?"" ) , CONST_STR_LEN ( ""/abc?"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d"" ) , CONST_STR_LEN ( ""/abc?d"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d="" ) , CONST_STR_LEN ( ""/abc?d="" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e"" ) , CONST_STR_LEN ( ""/abc?d=e"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&"" ) , CONST_STR_LEN ( ""/abc?d=e&"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f"" ) , CONST_STR_LEN ( ""/abc?d=e&f"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g#"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g#any"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2F"" ) , CONST_STR_LEN ( ""/%2F"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2f"" ) , CONST_STR_LEN ( ""/%2F"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%20"" ) , CONST_STR_LEN ( ""/%20"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2b"" ) , CONST_STR_LEN ( ""/%2B"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2B"" ) , CONST_STR_LEN ( ""/%2B"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%3a"" ) , CONST_STR_LEN ( ""/%3A"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%3A"" ) , CONST_STR_LEN ( ""/%3A"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/~test%20ä_"" ) , CONST_STR_LEN ( ""/~test%20%C3%A4_"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\375"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\376"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\377"" ) , """" , ( size_t ) - 2 ) ; flags = HTTP_PARSEOPT_URL_NORMALIZE_REQUIRED ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/"" ) , CONST_STR_LEN ( ""/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc"" ) , CONST_STR_LEN ( ""/abc"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc/"" ) , CONST_STR_LEN ( ""/abc/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc/def"" ) , CONST_STR_LEN ( ""/abc/def"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?"" ) , CONST_STR_LEN ( ""/abc?"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d"" ) , CONST_STR_LEN ( ""/abc?d"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d="" ) , CONST_STR_LEN ( ""/abc?d="" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e"" ) , CONST_STR_LEN ( ""/abc?d=e"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&"" ) , CONST_STR_LEN ( ""/abc?d=e&"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f"" ) , CONST_STR_LEN ( ""/abc?d=e&f"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g#"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g#any"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2F"" ) , CONST_STR_LEN ( ""/%2F"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2f"" ) , CONST_STR_LEN ( ""/%2F"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%20"" ) , CONST_STR_LEN ( ""/%20"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2b"" ) , CONST_STR_LEN ( ""/+"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2B"" ) , CONST_STR_LEN ( ""/+"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%3a"" ) , CONST_STR_LEN ( ""/:"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%3A"" ) , CONST_STR_LEN ( ""/:"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/~test%20ä_"" ) , CONST_STR_LEN ( ""/~test%20%C3%A4_"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\375"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\376"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\377"" ) , """" , ( size_t ) - 2 ) ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\a"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\t"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\r"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\177"" ) , """" , ( size_t ) - 2 ) ; # if defined ( __WIN32 ) || defined ( __CYGWIN__ ) flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_BACKSLASH_TRANS ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a\\\\b"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; # endif flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b?c=/"" ) , CONST_STR_LEN ( ""/a/b?c=/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b?c=%2f"" ) , CONST_STR_LEN ( ""/a/b?c=/"" ) ) ; <S2SV_StartBug> run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; <S2SV_EndBug> run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2Fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb?c=/"" ) , CONST_STR_LEN ( ""/a/b?c=/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb?c=%2f"" ) , CONST_STR_LEN ( ""/a/b?c=/"" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2Fb"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b?c=%2f"" ) , CONST_STR_LEN ( ""/a/b?c=/"" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""./a/b"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""../a/b"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/./b"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/../b"" ) , CONST_STR_LEN ( ""/b"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b/."" ) , CONST_STR_LEN ( ""/a/b/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b/.."" ) , CONST_STR_LEN ( ""/a/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/../b/.."" ) , CONST_STR_LEN ( ""/"" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""./a/b"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""../a/b"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/./b"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/../b"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b/."" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b/.."" ) , """" , ( size_t ) - 2 ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b?c=d+e"" ) , CONST_STR_LEN ( ""/a/b?c=d+e"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b?c=d%20e"" ) , CONST_STR_LEN ( ""/a/b?c=d+e"" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS ; buffer_free ( psrc ) ; buffer_free ( ptmp ) ; }
","<S2SV_ModStart> , CONST_STR_LEN ( ""%2f?"" ) , CONST_STR_LEN ( ""/?"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2f?"" ) , CONST_STR_LEN ( ""//?"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN (
"
601,"CWE-264 static int __ptrace_may_access ( struct task_struct * task , unsigned int mode ) { const struct cred * cred = current_cred ( ) , * tcred ; int dumpable = 0 ; if ( same_thread_group ( task , current ) ) return 0 ; rcu_read_lock ( ) ; tcred = __task_cred ( task ) ; if ( uid_eq ( cred -> uid , tcred -> euid ) && uid_eq ( cred -> uid , tcred -> suid ) && uid_eq ( cred -> uid , tcred -> uid ) && gid_eq ( cred -> gid , tcred -> egid ) && gid_eq ( cred -> gid , tcred -> sgid ) && gid_eq ( cred -> gid , tcred -> gid ) ) goto ok ; if ( ptrace_has_cap ( tcred -> user_ns , mode ) ) goto ok ; rcu_read_unlock ( ) ; return - EPERM ; ok : rcu_read_unlock ( ) ; smp_rmb ( ) ; if ( task -> mm ) dumpable = get_dumpable ( task -> mm ) ; rcu_read_lock ( ) ; <S2SV_StartBug> if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) { <S2SV_EndBug> rcu_read_unlock ( ) ; return - EPERM ; } rcu_read_unlock ( ) ; return security_ptrace_access_check ( task , mode ) ; }
","<S2SV_ModStart> ; if ( dumpable != SUID_DUMP_USER && <S2SV_ModEnd> ! ptrace_has_cap (
"
602,"CWE-189 static void add_bytes_l2_c ( uint8_t * dst , uint8_t * src1 , uint8_t * src2 , int w ) { long i ; <S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> long a = * ( long * ) ( src1 + i ) ; long b = * ( long * ) ( src2 + i ) ; * ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i ] = src1 [ i ] + src2 [ i ] ; }
","<S2SV_ModStart> <= w - ( int )
"
603,"CWE-200 static void * __dma_alloc_coherent ( struct device * dev , size_t size , dma_addr_t * dma_handle , gfp_t flags , struct dma_attrs * attrs ) { if ( dev == NULL ) { WARN_ONCE ( 1 , ""Use<S2SV_blank>an<S2SV_blank>actual<S2SV_blank>device<S2SV_blank>structure<S2SV_blank>for<S2SV_blank>DMA<S2SV_blank>allocation\\n"" ) ; return NULL ; } if ( IS_ENABLED ( CONFIG_ZONE_DMA ) && dev -> coherent_dma_mask <= DMA_BIT_MASK ( 32 ) ) flags |= GFP_DMA ; if ( IS_ENABLED ( CONFIG_DMA_CMA ) && ( flags & __GFP_WAIT ) ) { struct page * page ; void * addr ; size = PAGE_ALIGN ( size ) ; page = dma_alloc_from_contiguous ( dev , size >> PAGE_SHIFT , get_order ( size ) ) ; if ( ! page ) return NULL ; * dma_handle = phys_to_dma ( dev , page_to_phys ( page ) ) ; addr = page_address ( page ) ; <S2SV_StartBug> if ( flags & __GFP_ZERO ) <S2SV_EndBug> memset ( addr , 0 , size ) ; return addr ; } else { return swiotlb_alloc_coherent ( dev , size , dma_handle , flags ) ; } }
","<S2SV_ModStart> page ) ; <S2SV_ModEnd> memset ( addr
"
604,"CWE-190 void jas_matrix_clip ( jas_matrix_t * matrix , jas_seqent_t minval , jas_seqent_t maxval ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; jas_seqent_t v ; jas_seqent_t * rowstart ; jas_seqent_t * data ; <S2SV_StartBug> int rowstep ; <S2SV_EndBug> if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) { assert ( matrix -> rows_ ) ; rowstep = jas_matrix_rowstep ( matrix ) ; for ( i = matrix -> numrows_ , rowstart = matrix -> rows_ [ 0 ] ; i > 0 ; -- i , rowstart += rowstep ) { data = rowstart ; for ( j = matrix -> numcols_ , data = rowstart ; j > 0 ; -- j , ++ data ) { v = * data ; if ( v < minval ) { * data = minval ; } else if ( v > maxval ) { * data = maxval ; } } } } }
","<S2SV_ModStart> maxval ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t <S2SV_ModStart> * data ; jas_matind_t <S2SV_ModEnd> rowstep ; if
"
605,"CWE-190 void ihevcd_parse_sei_payload ( codec_t * ps_codec , UWORD32 u4_payload_type , UWORD32 u4_payload_size , WORD8 i1_nal_type ) { parse_ctxt_t * ps_parse = & ps_codec -> s_parse ; bitstrm_t * ps_bitstrm = & ps_parse -> s_bitstrm ; WORD32 payload_bits_remaining = 0 ; sps_t * ps_sps ; UWORD32 i ; for ( i = 0 ; i < MAX_SPS_CNT ; i ++ ) { ps_sps = ps_codec -> ps_sps_base + i ; if ( ps_sps -> i1_sps_valid ) { break ; } } if ( NULL == ps_sps ) { return ; } if ( NAL_PREFIX_SEI == i1_nal_type ) { switch ( u4_payload_type ) { case SEI_BUFFERING_PERIOD : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_buffering_period_sei ( ps_codec , ps_sps ) ; break ; case SEI_PICTURE_TIMING : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_pic_timing_sei ( ps_codec , ps_sps ) ; break ; case SEI_TIME_CODE : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_time_code_sei ( ps_codec ) ; break ; case SEI_MASTERING_DISPLAY_COLOUR_VOLUME : ps_parse -> s_sei_params . i4_sei_mastering_disp_colour_vol_params_present_flags = 1 ; ihevcd_parse_mastering_disp_params_sei ( ps_codec ) ; break ; case SEI_USER_DATA_REGISTERED_ITU_T_T35 : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; <S2SV_StartBug> ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , <S2SV_EndBug> <S2SV_StartBug> u4_payload_size ) ; <S2SV_EndBug> break ; default : for ( i = 0 ; i < u4_payload_size ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 8 ) ; } break ; } } else { switch ( u4_payload_type ) { case SEI_USER_DATA_REGISTERED_ITU_T_T35 : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; <S2SV_StartBug> ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , <S2SV_EndBug> <S2SV_StartBug> u4_payload_size ) ; <S2SV_EndBug> break ; default : for ( i = 0 ; i < u4_payload_size ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 8 ) ; } break ; } } payload_bits_remaining = ihevcd_bits_num_bits_remaining ( ps_bitstrm ) ; if ( payload_bits_remaining ) { WORD32 final_bits ; WORD32 final_payload_bits = 0 ; WORD32 mask = 0xFF ; UWORD32 u4_dummy ; UWORD32 u4_reserved_payload_extension_data ; UNUSED ( u4_dummy ) ; UNUSED ( u4_reserved_payload_extension_data ) ; while ( payload_bits_remaining > 9 ) { BITS_PARSE ( ""reserved_payload_extension_data"" , u4_reserved_payload_extension_data , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } final_bits = ihevcd_bits_nxt ( ps_bitstrm , payload_bits_remaining ) ; while ( final_bits & ( mask >> final_payload_bits ) ) { final_payload_bits ++ ; continue ; } while ( payload_bits_remaining > ( 9 - final_payload_bits ) ) { BITS_PARSE ( ""reserved_payload_extension_data"" , u4_reserved_payload_extension_data , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } BITS_PARSE ( ""payload_bit_equal_to_one"" , u4_dummy , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; while ( payload_bits_remaining ) { BITS_PARSE ( ""payload_bit_equal_to_zero"" , u4_dummy , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } } return ; }
","<S2SV_ModStart> = 1 ; if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) { for ( i = 0 ; i < u4_payload_size / 4 ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ; } ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ; } else { <S2SV_ModStart> u4_payload_size ) ; } <S2SV_ModStart> = 1 ; if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) { for ( i = 0 ; i < u4_payload_size / 4 ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ; } ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ; } else { <S2SV_ModStart> u4_payload_size ) ; }
"
606,"CWE-000 static int cypress_generic_port_probe ( struct usb_serial_port * port ) { struct usb_serial * serial = port -> serial ; struct cypress_private * priv ; <S2SV_StartBug> priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! priv ) return - ENOMEM ; priv -> comm_is_ok = ! 0 ; spin_lock_init ( & priv -> lock ) ; if ( kfifo_alloc ( & priv -> write_fifo , CYPRESS_BUF_SIZE , GFP_KERNEL ) ) { kfree ( priv ) ; return - ENOMEM ; } if ( ! is_frwd ( serial -> dev ) ) usb_reset_configuration ( serial -> dev ) ; priv -> cmd_ctrl = 0 ; priv -> line_control = 0 ; priv -> termios_initialized = 0 ; priv -> rx_flags = 0 ; if ( port -> interrupt_out_size > 9 ) priv -> pkt_fmt = packet_format_1 ; else priv -> pkt_fmt = packet_format_2 ; if ( interval > 0 ) { priv -> write_urb_interval = interval ; priv -> read_urb_interval = interval ; dev_dbg ( & port -> dev , ""%s<S2SV_blank>-<S2SV_blank>read<S2SV_blank>&<S2SV_blank>write<S2SV_blank>intervals<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>%d\\n"" , __func__ , interval ) ; } else { priv -> write_urb_interval = port -> interrupt_out_urb -> interval ; priv -> read_urb_interval = port -> interrupt_in_urb -> interval ; dev_dbg ( & port -> dev , ""%s<S2SV_blank>-<S2SV_blank>intervals:<S2SV_blank>read=%d<S2SV_blank>write=%d\\n"" , __func__ , priv -> read_urb_interval , priv -> write_urb_interval ) ; } usb_set_serial_port_data ( port , priv ) ; port -> port . drain_delay = 256 ; return 0 ; }
","<S2SV_ModStart> * priv ; if ( ! port -> interrupt_out_urb || ! port -> interrupt_in_urb ) { dev_err ( & port -> dev , ""required<S2SV_blank>endpoint<S2SV_blank>is<S2SV_blank>missing\\n"" ) ; return - ENODEV ; }
"
607,"CWE-401 int sdma_init ( struct hfi1_devdata * dd , u8 port ) { unsigned this_idx ; struct sdma_engine * sde ; struct rhashtable * tmp_sdma_rht ; u16 descq_cnt ; void * curr_head ; struct hfi1_pportdata * ppd = dd -> pport + port ; u32 per_sdma_credits ; uint idle_cnt = sdma_idle_cnt ; size_t num_engines = chip_sdma_engines ( dd ) ; int ret = - ENOMEM ; if ( ! HFI1_CAP_IS_KSET ( SDMA ) ) { HFI1_CAP_CLEAR ( SDMA_AHG ) ; return 0 ; } if ( mod_num_sdma && mod_num_sdma <= chip_sdma_engines ( dd ) && mod_num_sdma >= num_vls ) num_engines = mod_num_sdma ; dd_dev_info ( dd , ""SDMA<S2SV_blank>mod_num_sdma:<S2SV_blank>%u\\n"" , mod_num_sdma ) ; dd_dev_info ( dd , ""SDMA<S2SV_blank>chip_sdma_engines:<S2SV_blank>%u\\n"" , chip_sdma_engines ( dd ) ) ; dd_dev_info ( dd , ""SDMA<S2SV_blank>chip_sdma_mem_size:<S2SV_blank>%u\\n"" , chip_sdma_mem_size ( dd ) ) ; per_sdma_credits = chip_sdma_mem_size ( dd ) / ( num_engines * SDMA_BLOCK_SIZE ) ; init_waitqueue_head ( & dd -> sdma_unfreeze_wq ) ; atomic_set ( & dd -> sdma_unfreeze_count , 0 ) ; descq_cnt = sdma_get_descq_cnt ( ) ; dd_dev_info ( dd , ""SDMA<S2SV_blank>engines<S2SV_blank>%zu<S2SV_blank>descq_cnt<S2SV_blank>%u\\n"" , num_engines , descq_cnt ) ; dd -> per_sdma = kcalloc_node ( num_engines , sizeof ( * dd -> per_sdma ) , GFP_KERNEL , dd -> node ) ; if ( ! dd -> per_sdma ) return ret ; idle_cnt = ns_to_cclock ( dd , idle_cnt ) ; if ( idle_cnt ) dd -> default_desc1 = SDMA_DESC1_HEAD_TO_HOST_FLAG ; else dd -> default_desc1 = SDMA_DESC1_INT_REQ_FLAG ; if ( ! sdma_desct_intr ) sdma_desct_intr = SDMA_DESC_INTR ; for ( this_idx = 0 ; this_idx < num_engines ; ++ this_idx ) { sde = & dd -> per_sdma [ this_idx ] ; sde -> dd = dd ; sde -> ppd = ppd ; sde -> this_idx = this_idx ; sde -> descq_cnt = descq_cnt ; sde -> desc_avail = sdma_descq_freecnt ( sde ) ; sde -> sdma_shift = ilog2 ( descq_cnt ) ; sde -> sdma_mask = ( 1 << sde -> sdma_shift ) - 1 ; sde -> int_mask = ( u64 ) 1 << ( 0 * TXE_NUM_SDMA_ENGINES + this_idx ) ; sde -> progress_mask = ( u64 ) 1 << ( 1 * TXE_NUM_SDMA_ENGINES + this_idx ) ; sde -> idle_mask = ( u64 ) 1 << ( 2 * TXE_NUM_SDMA_ENGINES + this_idx ) ; sde -> imask = sde -> int_mask | sde -> progress_mask | sde -> idle_mask ; spin_lock_init ( & sde -> tail_lock ) ; seqlock_init ( & sde -> head_lock ) ; spin_lock_init ( & sde -> senddmactrl_lock ) ; spin_lock_init ( & sde -> flushlist_lock ) ; seqlock_init ( & sde -> waitlock ) ; sde -> ahg_bits = 0xfffffffe00000000ULL ; sdma_set_state ( sde , sdma_state_s00_hw_down ) ; kref_init ( & sde -> state . kref ) ; init_completion ( & sde -> state . comp ) ; INIT_LIST_HEAD ( & sde -> flushlist ) ; INIT_LIST_HEAD ( & sde -> dmawait ) ; sde -> tail_csr = get_kctxt_csr_addr ( dd , this_idx , SD ( TAIL ) ) ; tasklet_init ( & sde -> sdma_hw_clean_up_task , sdma_hw_clean_up_task , ( unsigned long ) sde ) ; tasklet_init ( & sde -> sdma_sw_clean_up_task , sdma_sw_clean_up_task , ( unsigned long ) sde ) ; INIT_WORK ( & sde -> err_halt_worker , sdma_err_halt_wait ) ; INIT_WORK ( & sde -> flush_worker , sdma_field_flush ) ; sde -> progress_check_head = 0 ; timer_setup ( & sde -> err_progress_check_timer , sdma_err_progress_check , 0 ) ; sde -> descq = dma_alloc_coherent ( & dd -> pcidev -> dev , descq_cnt * sizeof ( u64 [ 2 ] ) , & sde -> descq_phys , GFP_KERNEL ) ; if ( ! sde -> descq ) goto bail ; sde -> tx_ring = kvzalloc_node ( array_size ( descq_cnt , sizeof ( struct sdma_txreq * ) ) , GFP_KERNEL , dd -> node ) ; if ( ! sde -> tx_ring ) goto bail ; } dd -> sdma_heads_size = L1_CACHE_BYTES * num_engines ; dd -> sdma_heads_dma = dma_alloc_coherent ( & dd -> pcidev -> dev , dd -> sdma_heads_size , & dd -> sdma_heads_phys , GFP_KERNEL ) ; if ( ! dd -> sdma_heads_dma ) { dd_dev_err ( dd , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>SendDMA<S2SV_blank>head<S2SV_blank>memory\\n"" ) ; goto bail ; } dd -> sdma_pad_dma = dma_alloc_coherent ( & dd -> pcidev -> dev , sizeof ( u32 ) , & dd -> sdma_pad_phys , GFP_KERNEL ) ; if ( ! dd -> sdma_pad_dma ) { dd_dev_err ( dd , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>SendDMA<S2SV_blank>pad<S2SV_blank>memory\\n"" ) ; goto bail ; } curr_head = ( void * ) dd -> sdma_heads_dma ; for ( this_idx = 0 ; this_idx < num_engines ; ++ this_idx ) { unsigned long phys_offset ; sde = & dd -> per_sdma [ this_idx ] ; sde -> head_dma = curr_head ; curr_head += L1_CACHE_BYTES ; phys_offset = ( unsigned long ) sde -> head_dma - ( unsigned long ) dd -> sdma_heads_dma ; sde -> head_phys = dd -> sdma_heads_phys + phys_offset ; init_sdma_regs ( sde , per_sdma_credits , idle_cnt ) ; } dd -> flags |= HFI1_HAS_SEND_DMA ; dd -> flags |= idle_cnt ? HFI1_HAS_SDMA_TIMEOUT : 0 ; dd -> num_sdma = num_engines ; ret = sdma_map_init ( dd , port , ppd -> vls_operational , NULL ) ; if ( ret < 0 ) goto bail ; tmp_sdma_rht = kzalloc ( sizeof ( * tmp_sdma_rht ) , GFP_KERNEL ) ; if ( ! tmp_sdma_rht ) { ret = - ENOMEM ; goto bail ; } ret = rhashtable_init ( tmp_sdma_rht , & sdma_rht_params ) ; <S2SV_StartBug> if ( ret < 0 ) <S2SV_EndBug> goto bail ; <S2SV_StartBug> dd -> sdma_rht = tmp_sdma_rht ; <S2SV_EndBug> dd_dev_info ( dd , ""SDMA<S2SV_blank>num_sdma:<S2SV_blank>%u\\n"" , dd -> num_sdma ) ; return 0 ; bail : sdma_clean ( dd , num_engines ) ; return ret ; }
","<S2SV_ModStart> < 0 ) { kfree ( tmp_sdma_rht ) ; <S2SV_ModStart> goto bail ; }
"
608,"CWE-416 static int snd_seq_device_dev_free ( struct snd_device * device ) { struct snd_seq_device * dev = device -> device_data ; <S2SV_StartBug> put_device ( & dev -> dev ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> -> device_data ; cancel_autoload_drivers ( ) ;
"
609,"CWE-362 int mi_repair_parallel ( MI_CHECK * param , register MI_INFO * info , <S2SV_StartBug> const char * name , int rep_quick ) <S2SV_EndBug> { int got_error ; uint i , key , total_key_length , istep ; ulong rec_length ; ha_rows start_records ; my_off_t new_header_length , del ; File new_file ; MI_SORT_PARAM * sort_param = 0 ; MYISAM_SHARE * share = info -> s ; ulong * rec_per_key_part ; HA_KEYSEG * keyseg ; char llbuff [ 22 ] ; IO_CACHE new_data_cache ; IO_CACHE_SHARE io_share ; SORT_INFO sort_info ; ulonglong UNINIT_VAR ( key_map ) ; pthread_attr_t thr_attr ; ulong max_pack_reclength ; int error ; DBUG_ENTER ( ""mi_repair_parallel"" ) ; start_records = info -> state -> records ; got_error = 1 ; new_file = - 1 ; new_header_length = ( param -> testflag & T_UNPACK ) ? 0 : share -> pack . header_length ; if ( ! ( param -> testflag & T_SILENT ) ) { printf ( ""-<S2SV_blank>parallel<S2SV_blank>recovering<S2SV_blank>(with<S2SV_blank>sort)<S2SV_blank>MyISAM-table<S2SV_blank>\'%s\'\\n"" , name ) ; printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\n"" , llstr ( start_records , llbuff ) ) ; } param -> testflag |= T_REP ; if ( info -> s -> options & ( HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD ) ) param -> testflag |= T_CALC_CHECKSUM ; DBUG_PRINT ( ""info"" , ( ""is<S2SV_blank>quick<S2SV_blank>repair:<S2SV_blank>%d"" , rep_quick ) ) ; bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ; mysql_mutex_init ( mi_key_mutex_MI_SORT_INFO_mutex , & sort_info . mutex , MY_MUTEX_INIT_FAST ) ; mysql_cond_init ( mi_key_cond_MI_SORT_INFO_cond , & sort_info . cond , 0 ) ; mysql_mutex_init ( mi_key_mutex_MI_CHECK_print_msg , & param -> print_msg_mutex , MY_MUTEX_INIT_FAST ) ; param -> need_print_msg_lock = 1 ; if ( ! ( sort_info . key_block = alloc_key_blocks ( param , ( uint ) param -> sort_key_blocks , share -> base . max_key_block_length ) ) || init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , READ_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME ) ) || ( ! rep_quick && ( init_io_cache ( & info -> rec_cache , info -> dfile , ( uint ) param -> write_buffer_length , WRITE_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_WAIT_IF_FULL ) & param -> myf_rw ) || init_io_cache ( & new_data_cache , - 1 , ( uint ) param -> write_buffer_length , READ_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_DONT_CHECK_FILESIZE ) ) ) ) ) goto err ; sort_info . key_block_end = sort_info . key_block + param -> sort_key_blocks ; info -> opt_flag |= WRITE_CACHE_USED ; info -> rec_cache . file = info -> dfile ; if ( ! rep_quick ) { if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) { mi_check_print_error ( param , ""Can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>tempfile:<S2SV_blank>\'%s\'"" , param -> temp_filename ) ; goto err ; } if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , ""datafile-header"" ) ) goto err ; if ( param -> testflag & T_UNPACK ) { share -> options &= ~ HA_OPTION_COMPRESS_RECORD ; mi_int2store ( share -> state . header . options , share -> options ) ; } share -> state . dellink = HA_OFFSET_ERROR ; info -> rec_cache . file = new_file ; } info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ; mi_drop_all_indexes ( param , info , FALSE ) ; key_map = share -> state . key_map ; if ( param -> testflag & T_CREATE_MISSING_KEYS ) { key_map = ~ key_map ; } sort_info . info = info ; sort_info . param = param ; set_data_file_type ( & sort_info , share ) ; sort_info . dupp = 0 ; sort_info . buff = 0 ; param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( param -> read_cache . file , 0L , MY_SEEK_END , MYF ( 0 ) ) ; if ( share -> data_file_type == DYNAMIC_RECORD ) rec_length = max ( share -> base . min_pack_length + 1 , share -> base . min_block_length ) ; else if ( share -> data_file_type == COMPRESSED_RECORD ) rec_length = share -> base . min_block_length ; else rec_length = share -> base . pack_reclength ; sort_info . max_records = ( ( param -> testflag & T_CREATE_MISSING_KEYS ) ? info -> state -> records + 1 : ( ha_rows ) ( sort_info . filelength / rec_length + 1 ) ) ; del = info -> state -> del ; param -> glob_crc = 0 ; max_pack_reclength = share -> base . pack_reclength ; if ( share -> options & HA_OPTION_COMPRESS_RECORD ) set_if_bigger ( max_pack_reclength , share -> max_pack_length ) ; if ( ! ( sort_param = ( MI_SORT_PARAM * ) my_malloc ( ( uint ) share -> base . keys * ( sizeof ( MI_SORT_PARAM ) + max_pack_reclength ) , MYF ( MY_ZEROFILL ) ) ) ) { mi_check_print_error ( param , ""Not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>key!"" ) ; goto err ; } total_key_length = 0 ; rec_per_key_part = param -> rec_per_key_part ; info -> state -> records = info -> state -> del = share -> state . split = 0 ; info -> state -> empty = 0 ; for ( i = key = 0 , istep = 1 ; key < share -> base . keys ; rec_per_key_part += sort_param [ i ] . keyinfo -> keysegs , i += istep , key ++ ) { sort_param [ i ] . key = key ; sort_param [ i ] . keyinfo = share -> keyinfo + key ; sort_param [ i ] . seg = sort_param [ i ] . keyinfo -> seg ; if ( ! mi_is_key_active ( key_map , key ) ) { memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param [ i ] . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ; istep = 0 ; continue ; } istep = 1 ; if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( ""-<S2SV_blank>Fixing<S2SV_blank>index<S2SV_blank>%d\\n"" , key + 1 ) ; if ( sort_param [ i ] . keyinfo -> flag & HA_FULLTEXT ) { sort_param [ i ] . key_read = sort_ft_key_read ; sort_param [ i ] . key_write = sort_ft_key_write ; } else { sort_param [ i ] . key_read = sort_key_read ; sort_param [ i ] . key_write = sort_key_write ; } sort_param [ i ] . key_cmp = sort_key_cmp ; sort_param [ i ] . lock_in_memory = lock_memory ; sort_param [ i ] . tmpdir = param -> tmpdir ; sort_param [ i ] . sort_info = & sort_info ; sort_param [ i ] . master = 0 ; sort_param [ i ] . fix_datafile = 0 ; sort_param [ i ] . calc_checksum = 0 ; sort_param [ i ] . filepos = new_header_length ; sort_param [ i ] . max_pos = sort_param [ i ] . pos = share -> pack . header_length ; sort_param [ i ] . record = ( ( ( uchar * ) ( sort_param + share -> base . keys ) ) + ( max_pack_reclength * i ) ) ; if ( ! mi_alloc_rec_buff ( info , - 1 , & sort_param [ i ] . rec_buff ) ) { mi_check_print_error ( param , ""Not<S2SV_blank>enough<S2SV_blank>memory!"" ) ; goto err ; } sort_param [ i ] . key_length = share -> rec_reflength ; for ( keyseg = sort_param [ i ] . seg ; keyseg -> type != HA_KEYTYPE_END ; keyseg ++ ) { sort_param [ i ] . key_length += keyseg -> length ; if ( keyseg -> flag & HA_SPACE_PACK ) sort_param [ i ] . key_length += get_pack_length ( keyseg -> length ) ; if ( keyseg -> flag & ( HA_BLOB_PART | HA_VAR_LENGTH_PART ) ) sort_param [ i ] . key_length += 2 + test ( keyseg -> length >= 127 ) ; if ( keyseg -> flag & HA_NULL_PART ) sort_param [ i ] . key_length ++ ; } total_key_length += sort_param [ i ] . key_length ; if ( sort_param [ i ] . keyinfo -> flag & HA_FULLTEXT ) { uint ft_max_word_len_for_sort = FT_MAX_WORD_LEN_FOR_SORT * sort_param [ i ] . keyinfo -> seg -> charset -> mbmaxlen ; sort_param [ i ] . key_length += ft_max_word_len_for_sort - HA_FT_MAXBYTELEN ; init_alloc_root ( & sort_param [ i ] . wordroot , FTPARSER_MEMROOT_ALLOC_SIZE , 0 ) ; } } sort_info . total_keys = i ; sort_param [ 0 ] . master = 1 ; sort_param [ 0 ] . fix_datafile = ( my_bool ) ( ! rep_quick ) ; sort_param [ 0 ] . calc_checksum = test ( param -> testflag & T_CALC_CHECKSUM ) ; if ( ! ftparser_alloc_param ( info ) ) goto err ; sort_info . got_error = 0 ; mysql_mutex_lock ( & sort_info . mutex ) ; if ( i > 1 ) { if ( rep_quick ) init_io_cache_share ( & param -> read_cache , & io_share , NULL , i ) ; else init_io_cache_share ( & new_data_cache , & io_share , & info -> rec_cache , i ) ; } else io_share . total_threads = 0 ; ( void ) pthread_attr_init ( & thr_attr ) ; ( void ) pthread_attr_setdetachstate ( & thr_attr , PTHREAD_CREATE_DETACHED ) ; for ( i = 0 ; i < sort_info . total_keys ; i ++ ) { sort_param [ i ] . read_cache = ( ( rep_quick || ! i ) ? param -> read_cache : new_data_cache ) ; DBUG_PRINT ( ""io_cache_share"" , ( ""thread:<S2SV_blank>%u<S2SV_blank><S2SV_blank>read_cache:<S2SV_blank>0x%lx"" , i , ( long ) & sort_param [ i ] . read_cache ) ) ; sort_param [ i ] . sortbuff_size = # ifndef USING_SECOND_APPROACH param -> sort_buffer_length / sort_info . total_keys ; # else param -> sort_buffer_length * sort_param [ i ] . key_length / total_key_length ; # endif if ( ( error = mysql_thread_create ( mi_key_thread_find_all_keys , & sort_param [ i ] . thr , & thr_attr , thr_find_all_keys , ( void * ) ( sort_param + i ) ) ) ) { mi_check_print_error ( param , ""Cannot<S2SV_blank>start<S2SV_blank>a<S2SV_blank>repair<S2SV_blank>thread<S2SV_blank>(errno=<S2SV_blank>%d)"" , error ) ; if ( io_share . total_threads ) remove_io_thread ( & sort_param [ i ] . read_cache ) ; DBUG_PRINT ( ""error"" , ( ""Cannot<S2SV_blank>start<S2SV_blank>a<S2SV_blank>repair<S2SV_blank>thread"" ) ) ; sort_info . got_error = 1 ; } else sort_info . threads_running ++ ; } ( void ) pthread_attr_destroy ( & thr_attr ) ; while ( sort_info . threads_running ) mysql_cond_wait ( & sort_info . cond , & sort_info . mutex ) ; mysql_mutex_unlock ( & sort_info . mutex ) ; if ( ( got_error = thr_write_keys ( sort_param ) ) ) { param -> retry_repair = 1 ; goto err ; } got_error = 1 ; if ( sort_param [ 0 ] . fix_datafile ) { if ( write_data_suffix ( & sort_info , 1 ) || end_io_cache ( & info -> rec_cache ) ) goto err ; if ( param -> testflag & T_SAFE_REPAIR ) { if ( info -> state -> records + 1 < start_records ) { info -> state -> records = start_records ; goto err ; } } share -> state . state . data_file_length = info -> state -> data_file_length = sort_param -> filepos ; share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ; mysql_file_close ( info -> dfile , MYF ( 0 ) ) ; info -> dfile = new_file ; share -> data_file_type = sort_info . new_data_file_type ; share -> pack . header_length = ( ulong ) new_header_length ; } else info -> state -> data_file_length = sort_param -> max_pos ; if ( rep_quick && del + sort_info . dupp != info -> state -> del ) { mi_check_print_error ( param , ""Couldn\'t<S2SV_blank>fix<S2SV_blank>table<S2SV_blank>with<S2SV_blank>quick<S2SV_blank>recovery:<S2SV_blank>Found<S2SV_blank>wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>deleted<S2SV_blank>records"" ) ; mi_check_print_error ( param , ""Run<S2SV_blank>recovery<S2SV_blank>again<S2SV_blank>without<S2SV_blank>-q"" ) ; param -> retry_repair = 1 ; param -> testflag |= T_RETRY_WITHOUT_QUICK ; goto err ; } if ( rep_quick & T_FORCE_UNIQUENESS ) { my_off_t skr = info -> state -> data_file_length + ( share -> options & HA_OPTION_COMPRESS_RECORD ? MEMMAP_EXTRA_MARGIN : 0 ) ; # ifdef USE_RELOC if ( share -> data_file_type == STATIC_RECORD && skr < share -> base . reloc * share -> base . min_pack_length ) skr = share -> base . reloc * share -> base . min_pack_length ; # endif if ( skr != sort_info . filelength ) if ( mysql_file_chsize ( info -> dfile , skr , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>datafile,<S2SV_blank><S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ; } if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ; if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>indexfile,<S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ; if ( ! ( param -> testflag & T_SILENT ) ) { if ( start_records != info -> state -> records ) printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\n"" , llstr ( info -> state -> records , llbuff ) ) ; if ( sort_info . dupp ) mi_check_print_warning ( param , ""%s<S2SV_blank>records<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed"" , llstr ( sort_info . dupp , llbuff ) ) ; } got_error = 0 ; if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ; err : got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ; ( void ) end_io_cache ( & info -> rec_cache ) ; if ( ! rep_quick ) ( void ) end_io_cache ( & new_data_cache ) ; if ( ! got_error ) { if ( new_file >= 0 ) { <S2SV_StartBug> mysql_file_close ( new_file , MYF ( 0 ) ) ; <S2SV_EndBug> info -> dfile = new_file = - 1 ; if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT , <S2SV_StartBug> ( param -> testflag & T_BACKUP_DATA ? <S2SV_EndBug> MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ; } } if ( got_error ) { if ( ! param -> error_printed ) mi_check_print_error ( param , ""%d<S2SV_blank>when<S2SV_blank>fixing<S2SV_blank>table"" , my_errno ) ; if ( new_file >= 0 ) { ( void ) mysql_file_close ( new_file , MYF ( 0 ) ) ; ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , MYF ( MY_WME ) ) ; if ( info -> dfile == new_file ) if ( unlikely ( mi_open_datafile ( info , share , name , - 1 ) ) ) param -> retry_repair = 0 ; } mi_mark_crashed_on_repair ( info ) ; } else if ( key_map == share -> state . key_map ) share -> state . changed &= ~ STATE_NOT_OPTIMIZED_KEYS ; share -> state . changed |= STATE_NOT_SORTED_PAGES ; mysql_cond_destroy ( & sort_info . cond ) ; mysql_mutex_destroy ( & sort_info . mutex ) ; mysql_mutex_destroy ( & param -> print_msg_mutex ) ; param -> need_print_msg_lock = 0 ; my_free ( sort_info . ft_buf ) ; my_free ( sort_info . key_block ) ; my_free ( sort_param ) ; my_free ( sort_info . buff ) ; ( void ) end_io_cache ( & param -> read_cache ) ; info -> opt_flag &= ~ ( READ_CACHE_USED | WRITE_CACHE_USED ) ; if ( ! got_error && ( param -> testflag & T_UNPACK ) ) { share -> state . header . options [ 0 ] &= ( uchar ) ~ HA_OPTION_COMPRESS_RECORD ; share -> pack . header_length = 0 ; } DBUG_RETURN ( got_error ) ; }
","<S2SV_ModStart> , int rep_quick , my_bool no_copy_stat <S2SV_ModStart> 0 ) { myf flags = 0 ; if ( param -> testflag & T_BACKUP_DATA ) flags |= MY_REDEL_MAKE_BACKUP ; if ( no_copy_stat ) flags |= MY_REDEL_NO_COPY_STAT ; <S2SV_ModStart> , DATA_TMP_EXT , flags <S2SV_ModEnd> ) || mi_open_datafile
"
610,"CWE-000 Image * AutoResizeImage ( const Image * image , const char * option , MagickOffsetType * count , ExceptionInfo * exception ) { # define MAX_SIZES 16 char * q ; const char * p ; Image * resized , * images ; register ssize_t i ; size_t sizes [ MAX_SIZES ] = { 256 , 192 , 128 , 96 , 64 , 48 , 40 , 32 , 24 , 16 } ; images = NULL ; * count = 0 ; i = 0 ; p = option ; while ( * p != '\\0' && i < MAX_SIZES ) { size_t size ; while ( ( isspace ( ( int ) ( ( unsigned char ) * p ) ) != 0 ) ) p ++ ; size = ( size_t ) strtol ( p , & q , 10 ) ; <S2SV_StartBug> if ( p == q || size < 16 || size > 256 ) <S2SV_EndBug> return ( ( Image * ) NULL ) ; p = q ; sizes [ i ++ ] = size ; while ( ( isspace ( ( int ) ( ( unsigned char ) * p ) ) != 0 ) || ( * p == ',' ) ) p ++ ; } if ( i == 0 ) i = 10 ; * count = i ; for ( i = 0 ; i < * count ; i ++ ) { resized = ResizeImage ( image , sizes [ i ] , sizes [ i ] , image -> filter , exception ) ; if ( resized == ( Image * ) NULL ) return ( DestroyImageList ( images ) ) ; if ( images == ( Image * ) NULL ) images = resized ; else AppendImageToList ( & images , resized ) ; } return ( images ) ; }
","<S2SV_ModStart> ; if ( ( <S2SV_ModStart> p == q ) || ( <S2SV_ModEnd> size < 16 <S2SV_ModStart> size < 16 ) || ( <S2SV_ModEnd> size > 256 <S2SV_ModStart> size > 256 )
"
611,"CWE-19 STATIC int xfs_attr_calc_size ( struct xfs_inode * ip , int namelen , int valuelen , int * local ) { struct xfs_mount * mp = ip -> i_mount ; int size ; int nblks ; size = xfs_attr_leaf_newentsize ( namelen , valuelen , mp -> m_sb . sb_blocksize , local ) ; nblks = XFS_DAENTER_SPACE_RES ( mp , XFS_ATTR_FORK ) ; if ( * local ) { if ( size > ( mp -> m_sb . sb_blocksize >> 1 ) ) { nblks *= 2 ; } } else { <S2SV_StartBug> uint dblocks = XFS_B_TO_FSB ( mp , valuelen ) ; <S2SV_EndBug> nblks += dblocks ; nblks += XFS_NEXTENTADD_SPACE_RES ( mp , dblocks , XFS_ATTR_FORK ) ; } return nblks ; }
","<S2SV_ModStart> uint dblocks = xfs_attr3_rmt_blocks <S2SV_ModEnd> ( mp ,
"
612,"CWE-189 Datum hstore_recv ( PG_FUNCTION_ARGS ) { int32 buflen ; HStore * out ; Pairs * pairs ; int32 i ; int32 pcount ; StringInfo buf = ( StringInfo ) PG_GETARG_POINTER ( 0 ) ; pcount = pq_getmsgint ( buf , 4 ) ; if ( pcount == 0 ) { out = hstorePairs ( NULL , 0 , 0 ) ; PG_RETURN_POINTER ( out ) ; } <S2SV_StartBug> pairs = palloc ( pcount * sizeof ( Pairs ) ) ; <S2SV_EndBug> for ( i = 0 ; i < pcount ; ++ i ) { int rawlen = pq_getmsgint ( buf , 4 ) ; int len ; if ( rawlen < 0 ) ereport ( ERROR , ( errcode ( ERRCODE_NULL_VALUE_NOT_ALLOWED ) , errmsg ( ""null<S2SV_blank>value<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>hstore<S2SV_blank>key"" ) ) ) ; pairs [ i ] . key = pq_getmsgtext ( buf , rawlen , & len ) ; pairs [ i ] . keylen = hstoreCheckKeyLen ( len ) ; pairs [ i ] . needfree = true ; rawlen = pq_getmsgint ( buf , 4 ) ; if ( rawlen < 0 ) { pairs [ i ] . val = NULL ; pairs [ i ] . vallen = 0 ; pairs [ i ] . isnull = true ; } else { pairs [ i ] . val = pq_getmsgtext ( buf , rawlen , & len ) ; pairs [ i ] . vallen = hstoreCheckValLen ( len ) ; pairs [ i ] . isnull = false ; } } pcount = hstoreUniquePairs ( pairs , pcount , & buflen ) ; out = hstorePairs ( pairs , pcount , buflen ) ; PG_RETURN_POINTER ( out ) ; }
","<S2SV_ModStart> ) ; } if ( pcount < 0 || pcount > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , pcount , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;
"
613,"CWE-476 static void parserule ( struct scanner * s , struct environment * env ) { struct rule * r ; char * var ; struct evalstring * val ; bool hascommand = false , hasrspfile = false , hasrspcontent = false ; r = mkrule ( scanname ( s ) ) ; scannewline ( s ) ; while ( scanindent ( s ) ) { var = scanname ( s ) ; parselet ( s , & val ) ; <S2SV_StartBug> ruleaddvar ( r , var , val ) ; <S2SV_EndBug> if ( strcmp ( var , ""command"" ) == 0 ) hascommand = true ; else if ( strcmp ( var , ""rspfile"" ) == 0 ) hasrspfile = true ; else if ( strcmp ( var , ""rspfile_content"" ) == 0 ) hasrspcontent = true ; } if ( ! hascommand ) fatal ( ""rule<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>no<S2SV_blank>command"" , r -> name ) ; if ( hasrspfile != hasrspcontent ) fatal ( ""rule<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>rspfile<S2SV_blank>and<S2SV_blank>no<S2SV_blank>rspfile_content<S2SV_blank>or<S2SV_blank>vice<S2SV_blank>versa"" , r -> name ) ; envaddrule ( env , r ) ; }
","<S2SV_ModStart> , val ) ; if ( ! val ) continue
"
614,"CWE-476 int read_escaped_char ( yyscan_t yyscanner , uint8_t * escaped_char ) { char text [ 4 ] = { 0 , 0 , 0 , 0 } ; text [ 0 ] = '\\\\' ; text [ 1 ] = RE_YY_INPUT ( yyscanner ) ; <S2SV_StartBug> if ( text [ 1 ] == EOF ) <S2SV_EndBug> return 0 ; if ( text [ 1 ] == 'x' ) { text [ 2 ] = RE_YY_INPUT ( yyscanner ) ; <S2SV_StartBug> if ( text [ 2 ] == EOF ) <S2SV_EndBug> return 0 ; text [ 3 ] = RE_YY_INPUT ( yyscanner ) ; <S2SV_StartBug> if ( text [ 3 ] == EOF ) <S2SV_EndBug> return 0 ; } * escaped_char = escaped_char_value ( text ) ; return 1 ; }
","<S2SV_ModStart> ] == EOF || text [ 1 ] == 0 <S2SV_ModStart> ; if ( ! isxdigit ( <S2SV_ModStart> [ 2 ] ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ; if ( ! isxdigit ( <S2SV_ModStart> [ 3 ] ) <S2SV_ModEnd> ) return 0
"
615,"CWE-444 static HeadReturn con_header_read ( agooCon c , size_t * mlenp ) { char * hend = strstr ( c -> buf , ""\\r\\n\\r\\n"" ) ; agooMethod method ; struct _agooSeg path ; char * query = NULL ; char * qend ; char * b ; size_t clen = 0 ; long mlen ; agooHook hook = NULL ; agooPage p ; struct _agooErr err = AGOO_ERR_INIT ; if ( NULL == hend ) { if ( sizeof ( c -> buf ) - 1 <= c -> bcnt ) { return bad_request ( c , 431 , __LINE__ ) ; } return HEAD_AGAIN ; } if ( agoo_req_cat . on ) { * hend = '\\0' ; agoo_log_cat ( & agoo_req_cat , ""%s<S2SV_blank>%llu:<S2SV_blank>%s"" , agoo_con_kind_str ( c -> bind -> kind ) , ( unsigned long long ) c -> id , c -> buf ) ; * hend = '\\r' ; } for ( b = c -> buf ; '<S2SV_blank>' != * b ; b ++ ) { if ( '\\0' == * b ) { return bad_request ( c , 400 , __LINE__ ) ; } } switch ( toupper ( * c -> buf ) ) { case 'G' : if ( 3 != b - c -> buf || 0 != strncmp ( ""GET"" , c -> buf , 3 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_GET ; break ; case 'P' : { const char * v ; int vlen = 0 ; char * vend ; if ( 3 == b - c -> buf && 0 == strncmp ( ""PUT"" , c -> buf , 3 ) ) { method = AGOO_PUT ; } else if ( 4 == b - c -> buf && 0 == strncmp ( ""POST"" , c -> buf , 4 ) ) { method = AGOO_POST ; } else { return bad_request ( c , 400 , __LINE__ ) ; } if ( NULL == ( v = agoo_con_header_value ( c -> buf , ( int ) ( hend - c -> buf ) , ""Content-Length"" , & vlen ) ) ) { return bad_request ( c , 411 , __LINE__ ) ; } clen = ( size_t ) strtoul ( v , & vend , 10 ) ; if ( vend != v + vlen ) { return bad_request ( c , 411 , __LINE__ ) ; } break ; } case 'D' : if ( 6 != b - c -> buf || 0 != strncmp ( ""DELETE"" , c -> buf , 6 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_DELETE ; break ; case 'H' : if ( 4 != b - c -> buf || 0 != strncmp ( ""HEAD"" , c -> buf , 4 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_HEAD ; break ; case 'O' : if ( 7 != b - c -> buf || 0 != strncmp ( ""OPTIONS"" , c -> buf , 7 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_OPTIONS ; break ; case 'C' : if ( 7 != b - c -> buf || 0 != strncmp ( ""CONNECT"" , c -> buf , 7 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_CONNECT ; break ; default : return bad_request ( c , 400 , __LINE__ ) ; } for ( ; '<S2SV_blank>' == * b ; b ++ ) { if ( '\\0' == * b ) { return bad_request ( c , 400 , __LINE__ ) ; } } path . start = b ; for ( ; '<S2SV_blank>' != * b ; b ++ ) { switch ( * b ) { case '?' : path . end = b ; query = b + 1 ; break ; case '\\0' : return bad_request ( c , 400 , __LINE__ ) ; default : break ; } } if ( NULL == query ) { path . end = b ; query = b ; qend = b ; } else { qend = b ; } mlen = hend - c -> buf + 4 + clen ; * mlenp = mlen ; if ( AGOO_GET == method ) { char root_buf [ 20148 ] ; const char * root = NULL ; if ( NULL != ( p = agoo_group_get ( & err , path . start , ( int ) ( path . end - path . start ) ) ) ) { if ( page_response ( c , p , hend ) ) { return bad_request ( c , 500 , __LINE__ ) ; } return HEAD_HANDLED ; } if ( agoo_domain_use ( ) ) { const char * host ; int vlen = 0 ; if ( NULL == ( host = agoo_con_header_value ( c -> buf , ( int ) ( hend - c -> buf ) , ""Host"" , & vlen ) ) ) { return bad_request ( c , 411 , __LINE__ ) ; } ( ( char * ) host ) [ vlen ] = '\\0' ; root = agoo_domain_resolve ( host , root_buf , sizeof ( root_buf ) ) ; ( ( char * ) host ) [ vlen ] = '\\r' ; } if ( agoo_server . root_first && NULL != ( p = agoo_page_get ( & err , path . start , ( int ) ( path . end - path . start ) , root ) ) ) { if ( page_response ( c , p , hend ) ) { return bad_request ( c , 500 , __LINE__ ) ; } return HEAD_HANDLED ; } if ( NULL == ( hook = agoo_hook_find ( agoo_server . hooks , method , & path ) ) ) { if ( NULL != ( p = agoo_page_get ( & err , path . start , ( int ) ( path . end - path . start ) , root ) ) ) { if ( page_response ( c , p , hend ) ) { return bad_request ( c , 500 , __LINE__ ) ; } return HEAD_HANDLED ; } if ( NULL == agoo_server . hook404 ) { return bad_request ( c , 404 , __LINE__ ) ; } hook = agoo_server . hook404 ; } } else if ( NULL == ( hook = agoo_hook_find ( agoo_server . hooks , method , & path ) ) ) { return bad_request ( c , 404 , __LINE__ ) ; } if ( NULL == ( c -> req = agoo_req_create ( mlen ) ) ) { return bad_request ( c , 413 , __LINE__ ) ; } if ( ( long ) c -> bcnt <= mlen ) { memcpy ( c -> req -> msg , c -> buf , c -> bcnt ) ; if ( ( long ) c -> bcnt < mlen ) { memset ( c -> req -> msg + c -> bcnt , 0 , mlen - c -> bcnt ) ; } } else { memcpy ( c -> req -> msg , c -> buf , mlen ) ; } c -> req -> msg [ mlen ] = '\\0' ; c -> req -> method = method ; c -> req -> upgrade = AGOO_UP_NONE ; c -> req -> up = NULL ; <S2SV_StartBug> c -> req -> path . start = c -> req -> msg + ( path . start - c -> buf ) ; <S2SV_EndBug> c -> req -> path . len = ( int ) ( path . end - path . start ) ; c -> req -> query . start = c -> req -> msg + ( query - c -> buf ) ; c -> req -> query . len = ( int ) ( qend - query ) ; c -> req -> query . start [ c -> req -> query . len ] = '\\0' ; c -> req -> body . start = c -> req -> msg + ( hend - c -> buf + 4 ) ; c -> req -> body . len = ( unsigned int ) clen ; b = strstr ( b , ""\\r\\n"" ) ; c -> req -> header . start = c -> req -> msg + ( b + 2 - c -> buf ) ; if ( b < hend ) { c -> req -> header . len = ( unsigned int ) ( hend - b - 2 ) ; } else { c -> req -> header . len = 0 ; } c -> req -> res = NULL ; c -> req -> hook = hook ; return HEAD_OK ; }
","<S2SV_ModStart> = NULL ; memcpy ( c -> req -> remote , c -> remote , sizeof ( c -> remote ) ) ;
"
616,"CWE-119 <S2SV_StartBug> void vp9_fht16x16_c ( const int16_t * input , int16_t * output , <S2SV_EndBug> int stride , int tx_type ) { if ( tx_type == DCT_DCT ) { <S2SV_StartBug> vp9_fdct16x16_c ( input , output , stride ) ; <S2SV_EndBug> } else { <S2SV_StartBug> int16_t out [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = & out [ 0 ] ; <S2SV_EndBug> int i , j ; <S2SV_StartBug> int16_t temp_in [ 16 ] , temp_out [ 16 ] ; <S2SV_EndBug> const transform_2d ht = FHT_16 [ tx_type ] ; for ( i = 0 ; i < 16 ; ++ i ) { for ( j = 0 ; j < 16 ; ++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ; ht . cols ( temp_in , temp_out ) ; for ( j = 0 ; j < 16 ; ++ j ) <S2SV_StartBug> outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ; <S2SV_EndBug> } for ( i = 0 ; i < 16 ; ++ i ) { for ( j = 0 ; j < 16 ; ++ j ) temp_in [ j ] = out [ j + i * 16 ] ; ht . rows ( temp_in , temp_out ) ; for ( j = 0 ; j < 16 ; ++ j ) output [ j + i * 16 ] = temp_out [ j ] ; } } }
","<S2SV_ModStart> * input , tran_low_t <S2SV_ModEnd> * output , <S2SV_ModStart> DCT_DCT ) { vpx_fdct16x16_c <S2SV_ModEnd> ( input , <S2SV_ModStart> } else { tran_low_t <S2SV_ModEnd> out [ 256 <S2SV_ModStart> 256 ] ; <S2SV_ModEnd> int i , <S2SV_ModStart> , j ; tran_low_t <S2SV_ModEnd> temp_in [ 16 <S2SV_ModStart> ++ j ) out <S2SV_ModEnd> [ j *
"
617,"CWE-74 static gboolean export_desktop_file ( const char * app , const char * branch , const char * arch , GKeyFile * metadata , const char * const * previous_ids , int parent_fd , const char * name , struct stat * stat_buf , char * * target , GCancellable * cancellable , GError * * error ) { gboolean ret = FALSE ; glnx_autofd int desktop_fd = - 1 ; g_autofree char * tmpfile_name = g_strdup_printf ( ""export-desktop-XXXXXX"" ) ; g_autoptr ( GOutputStream ) out_stream = NULL ; g_autofree gchar * data = NULL ; gsize data_len ; g_autofree gchar * new_data = NULL ; gsize new_data_len ; g_autoptr ( GKeyFile ) keyfile = NULL ; g_autofree gchar * old_exec = NULL ; gint old_argc ; g_auto ( GStrv ) old_argv = NULL ; g_auto ( GStrv ) groups = NULL ; GString * new_exec = NULL ; g_autofree char * escaped_app = maybe_quote ( app ) ; g_autofree char * escaped_branch = maybe_quote ( branch ) ; g_autofree char * escaped_arch = maybe_quote ( arch ) ; int i ; if ( ! flatpak_openat_noatime ( parent_fd , name , & desktop_fd , cancellable , error ) ) goto out ; if ( ! read_fd ( desktop_fd , stat_buf , & data , & data_len , error ) ) goto out ; keyfile = g_key_file_new ( ) ; if ( ! g_key_file_load_from_data ( keyfile , data , data_len , G_KEY_FILE_KEEP_TRANSLATIONS , error ) ) goto out ; if ( g_str_has_suffix ( name , "".service"" ) ) { g_autofree gchar * dbus_name = NULL ; g_autofree gchar * expected_dbus_name = g_strndup ( name , strlen ( name ) - strlen ( "".service"" ) ) ; dbus_name = g_key_file_get_string ( keyfile , ""D-BUS<S2SV_blank>Service"" , ""Name"" , NULL ) ; if ( dbus_name == NULL || strcmp ( dbus_name , expected_dbus_name ) != 0 ) { return flatpak_fail_error ( error , FLATPAK_ERROR_EXPORT_FAILED , _ ( ""D-Bus<S2SV_blank>service<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>name"" ) , name ) ; } } if ( g_str_has_suffix ( name , "".desktop"" ) ) { gsize length ; g_auto ( GStrv ) tags = g_key_file_get_string_list ( metadata , ""Application"" , ""tags"" , & length , NULL ) ; if ( tags != NULL ) { g_key_file_set_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , ""X-Flatpak-Tags"" , ( const char * const * ) tags , length ) ; } g_key_file_set_string ( keyfile , G_KEY_FILE_DESKTOP_GROUP , ""X-Flatpak"" , app ) ; if ( previous_ids != NULL ) { const char * X_FLATPAK_RENAMED_FROM = ""X-Flatpak-RenamedFrom"" ; g_auto ( GStrv ) renamed_from = g_key_file_get_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , X_FLATPAK_RENAMED_FROM , NULL , NULL ) ; g_autoptr ( GPtrArray ) merged = g_ptr_array_new_with_free_func ( g_free ) ; g_autoptr ( GHashTable ) seen = g_hash_table_new ( g_str_hash , g_str_equal ) ; const char * new_suffix ; for ( i = 0 ; renamed_from != NULL && renamed_from [ i ] != NULL ; i ++ ) { if ( ! g_hash_table_contains ( seen , renamed_from [ i ] ) ) { gchar * copy = g_strdup ( renamed_from [ i ] ) ; g_hash_table_insert ( seen , copy , copy ) ; g_ptr_array_add ( merged , g_steal_pointer ( & copy ) ) ; } } g_assert ( g_str_has_prefix ( name , app ) ) ; new_suffix = name + strlen ( app ) ; for ( i = 0 ; previous_ids [ i ] != NULL ; i ++ ) { g_autofree gchar * previous_desktop = g_strconcat ( previous_ids [ i ] , new_suffix , NULL ) ; if ( ! g_hash_table_contains ( seen , previous_desktop ) ) { g_hash_table_insert ( seen , previous_desktop , previous_desktop ) ; g_ptr_array_add ( merged , g_steal_pointer ( & previous_desktop ) ) ; } } if ( merged -> len > 0 ) { g_ptr_array_add ( merged , NULL ) ; g_key_file_set_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , X_FLATPAK_RENAMED_FROM , ( const char * const * ) merged -> pdata , merged -> len - 1 ) ; } } } groups = g_key_file_get_groups ( keyfile , NULL ) ; for ( i = 0 ; groups [ i ] != NULL ; i ++ ) { g_auto ( GStrv ) flatpak_run_opts = g_key_file_get_string_list ( keyfile , groups [ i ] , ""X-Flatpak-RunOptions"" , NULL , NULL ) ; g_autofree char * flatpak_run_args = format_flatpak_run_args_from_run_opts ( flatpak_run_opts ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""X-Flatpak-RunOptions"" , NULL ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""TryExec"" , NULL ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""X-GNOME-Bugzilla-ExtraInfoScript"" , NULL ) ; new_exec = g_string_new ( """" ) ; g_string_append_printf ( new_exec , FLATPAK_BINDIR ""/flatpak<S2SV_blank>run<S2SV_blank>--branch=%s<S2SV_blank>--arch=%s"" , escaped_branch , escaped_arch ) ; if ( flatpak_run_args != NULL ) g_string_append_printf ( new_exec , ""%s"" , flatpak_run_args ) ; old_exec = g_key_file_get_string ( keyfile , groups [ i ] , ""Exec"" , NULL ) ; if ( old_exec && g_shell_parse_argv ( old_exec , & old_argc , & old_argv , NULL ) && old_argc >= 1 ) { int j ; g_autofree char * command = maybe_quote ( old_argv [ 0 ] ) ; g_string_append_printf ( new_exec , ""<S2SV_blank>--command=%s"" , command ) ; for ( j = 1 ; j < old_argc ; j ++ ) { if ( strcasecmp ( old_argv [ j ] , ""%f"" ) == 0 || strcasecmp ( old_argv [ j ] , ""%u"" ) == 0 ) { g_string_append ( new_exec , ""<S2SV_blank>--file-forwarding"" ) ; break ; } } g_string_append ( new_exec , ""<S2SV_blank>"" ) ; g_string_append ( new_exec , escaped_app ) ; for ( j = 1 ; j < old_argc ; j ++ ) { g_autofree char * arg = maybe_quote ( old_argv [ j ] ) ; if ( strcasecmp ( arg , ""%f"" ) == 0 ) g_string_append_printf ( new_exec , ""<S2SV_blank>@@<S2SV_blank>%s<S2SV_blank>@@"" , arg ) ; else if ( strcasecmp ( arg , ""%u"" ) == 0 ) g_string_append_printf ( new_exec , ""<S2SV_blank>@@u<S2SV_blank>%s<S2SV_blank>@@"" , arg ) ; else if ( g_str_has_prefix ( arg , ""@@"" ) ) <S2SV_StartBug> g_print ( _ ( ""Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\n"" ) , arg ) ; <S2SV_EndBug> else g_string_append_printf ( new_exec , ""<S2SV_blank>%s"" , arg ) ; } } else { g_string_append ( new_exec , ""<S2SV_blank>"" ) ; g_string_append ( new_exec , escaped_app ) ; } g_key_file_set_string ( keyfile , groups [ i ] , G_KEY_FILE_DESKTOP_KEY_EXEC , new_exec -> str ) ; } new_data = g_key_file_to_data ( keyfile , & new_data_len , error ) ; if ( new_data == NULL ) goto out ; if ( ! flatpak_open_in_tmpdir_at ( parent_fd , 0755 , tmpfile_name , & out_stream , cancellable , error ) ) goto out ; if ( ! g_output_stream_write_all ( out_stream , new_data , new_data_len , NULL , cancellable , error ) ) goto out ; if ( ! g_output_stream_close ( out_stream , cancellable , error ) ) goto out ; if ( target ) * target = g_steal_pointer ( & tmpfile_name ) ; ret = TRUE ; out : if ( new_exec != NULL ) g_string_free ( new_exec , TRUE ) ; return ret ; }
","<S2SV_ModStart> ""@@"" ) ) { flatpak_fail_error ( error , FLATPAK_ERROR_EXPORT_FAILED , _ ( ""Invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s"" <S2SV_ModEnd> ) , arg <S2SV_ModStart> arg ) ; goto out ; }
"
618,"CWE-284 static __be32 nfsd3_proc_setacl ( struct svc_rqst * rqstp , struct nfsd3_setaclargs * argp , struct nfsd3_attrstat * resp ) { struct inode * inode ; svc_fh * fh ; __be32 nfserr = 0 ; int error ; fh = fh_copy ( & resp -> fh , & argp -> fh ) ; nfserr = fh_verify ( rqstp , & resp -> fh , 0 , NFSD_MAY_SATTR ) ; if ( nfserr ) goto out ; inode = d_inode ( fh -> fh_dentry ) ; <S2SV_StartBug> if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) { <S2SV_EndBug> error = - EOPNOTSUPP ; goto out_errno ; <S2SV_StartBug> } <S2SV_EndBug> error = fh_want_write ( fh ) ; if ( error ) <S2SV_StartBug> goto out_errno ; <S2SV_EndBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ; if ( error ) goto out_drop_write ; <S2SV_StartBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_default , <S2SV_EndBug> ACL_TYPE_DEFAULT ) ; out_drop_write : fh_drop_write ( fh ) ; out_errno : nfserr = nfserrno ( error ) ; out : posix_acl_release ( argp -> acl_access ) ; posix_acl_release ( argp -> acl_default ) ; RETURN_STATUS ( nfserr ) ; }
","<S2SV_ModStart> fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error ) <S2SV_ModEnd> goto out_errno ; <S2SV_ModStart> goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access <S2SV_ModEnd> ) ; if <S2SV_ModStart> error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT <S2SV_ModEnd> , argp -> <S2SV_ModStart> argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ; <S2SV_ModEnd> fh_drop_write ( fh
"
619,"CWE-125 size_t compile_tree ( struct filter_op * * fop ) { int i = 1 ; struct filter_op * array = NULL ; struct unfold_elm * ue ; <S2SV_StartBug> BUG_IF ( tree_root == NULL ) ; <S2SV_EndBug> fprintf ( stdout , ""<S2SV_blank>Unfolding<S2SV_blank>the<S2SV_blank>meta-tree<S2SV_blank>"" ) ; fflush ( stdout ) ; unfold_blk ( & tree_root ) ; fprintf ( stdout , ""<S2SV_blank>done.\\n\\n"" ) ; labels_to_offsets ( ) ; TAILQ_FOREACH ( ue , & unfolded_tree , next ) { if ( ue -> label == 0 ) { SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ; memcpy ( & array [ i - 1 ] , & ue -> fop , sizeof ( struct filter_op ) ) ; i ++ ; } } SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ; array [ i - 1 ] . opcode = FOP_EXIT ; * fop = array ; return ( i ) ; }
","<S2SV_ModStart> * ue ; if <S2SV_ModEnd> ( tree_root == <S2SV_ModStart> == NULL ) return 0
"
620,"CWE-284 bool config_save ( const config_t * config , const char * filename ) { assert ( config != NULL ) ; assert ( filename != NULL ) ; assert ( * filename != '\\0' ) ; <S2SV_StartBug> char * temp_filename = osi_calloc ( strlen ( filename ) + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! temp_filename ) { <S2SV_EndBug> LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>filename."" , __func__ ) ; return false ; } strcpy ( temp_filename , filename ) ; strcat ( temp_filename , "".new"" ) ; FILE * fp = fopen ( temp_filename , ""wt"" ) ; if ( ! fp ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } for ( const list_node_t * node = list_begin ( config -> sections ) ; node != list_end ( config -> sections ) ; node = list_next ( node ) ) { const section_t * section = ( const section_t * ) list_node ( node ) ; <S2SV_StartBug> fprintf ( fp , ""[%s]\\n"" , section -> name ) ; <S2SV_EndBug> for ( const list_node_t * enode = list_begin ( section -> entries ) ; enode != list_end ( section -> entries ) ; enode = list_next ( enode ) ) { const entry_t * entry = ( const entry_t * ) list_node ( enode ) ; <S2SV_StartBug> fprintf ( fp , ""%s<S2SV_blank>=<S2SV_blank>%s\\n"" , entry -> key , entry -> value ) ; <S2SV_EndBug> } if ( list_next ( node ) != list_end ( config -> sections ) ) <S2SV_StartBug> fputc ( '\\n' , fp ) ; <S2SV_EndBug> } fflush ( fp ) ; <S2SV_StartBug> fclose ( fp ) ; <S2SV_EndBug> if ( chmod ( temp_filename , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>change<S2SV_blank>file<S2SV_blank>permissions<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , filename , strerror ( errno ) ) ; goto error ; } if ( rename ( temp_filename , filename ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>commit<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , filename , strerror ( errno ) ) ; goto error ; } <S2SV_StartBug> osi_free ( temp_filename ) ; <S2SV_EndBug> return true ; <S2SV_StartBug> error : ; <S2SV_EndBug> unlink ( temp_filename ) ; <S2SV_StartBug> osi_free ( temp_filename ) ; <S2SV_EndBug> return false ; }
","<S2SV_ModStart> '\\0' ) ; int dir_fd = - 1 ; FILE * fp = NULL ; static const char * temp_file_ext = "".new"" ; const int filename_len = strlen ( filename ) ; const int temp_filename_len = filename_len + strlen ( temp_file_ext ) + 1 ; char * <S2SV_ModEnd> temp_filename = osi_calloc <S2SV_ModStart> = osi_calloc ( temp_filename_len ) ; snprintf ( temp_filename , temp_filename_len , ""%s%s"" , filename , temp_file_ext ) ; char * temp_dirname = osi_strdup ( filename ) ; const char * directoryname = dirname ( temp_dirname <S2SV_ModEnd> ) ; if <S2SV_ModStart> if ( ! directoryname ) { LOG_ERROR ( ""%s<S2SV_blank>error<S2SV_blank>extracting<S2SV_blank>directory<S2SV_blank>from<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , filename , strerror ( errno ) ) ; goto error ; } dir_fd = TEMP_FAILURE_RETRY ( open ( directoryname , O_RDONLY ) ) ; if ( dir_fd < 0 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> fp = fopen <S2SV_ModStart> node ) ; if ( <S2SV_ModStart> -> name ) < 0 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> for ( const <S2SV_ModStart> enode ) ; if ( <S2SV_ModStart> -> value ) < 0 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> } if ( <S2SV_ModStart> sections ) ) { if ( <S2SV_ModStart> , fp ) == EOF ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } } } if ( fsync ( fileno ( fp ) ) < 0 ) { LOG_WARN ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>fsync<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; } if ( <S2SV_ModEnd> fclose ( fp <S2SV_ModStart> ( fp ) == EOF ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>close<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } fp = NULL <S2SV_ModStart> error ; } if ( fsync ( dir_fd ) < 0 ) { LOG_WARN ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>fsync<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ; } if ( close ( dir_fd ) < 0 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>close<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ; goto error ; } <S2SV_ModStart> osi_free ( temp_filename ) ; osi_free ( temp_dirname <S2SV_ModStart> ; error : <S2SV_ModEnd> unlink ( temp_filename <S2SV_ModStart> temp_filename ) ; if ( fp ) fclose ( fp ) ; if ( dir_fd != - 1 ) close ( dir_fd ) ; <S2SV_ModStart> osi_free ( temp_filename ) ; osi_free ( temp_dirname
"
621,"CWE-000 static int udf_pc_to_char ( struct super_block * sb , unsigned char * from , int fromlen , unsigned char * to , int tolen ) { struct pathComponent * pc ; int elen = 0 ; int comp_len ; unsigned char * p = to ; tolen -- ; while ( elen < fromlen ) { pc = ( struct pathComponent * ) ( from + elen ) ; <S2SV_StartBug> switch ( pc -> componentType ) { <S2SV_EndBug> case 1 : if ( pc -> lengthComponentIdent > 0 ) <S2SV_StartBug> break ; <S2SV_EndBug> case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ; p = to ; * p ++ = '/' ; tolen -- ; break ; case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ; memcpy ( p , ""../"" , 3 ) ; p += 3 ; tolen -= 3 ; break ; case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ; memcpy ( p , ""./"" , 2 ) ; p += 2 ; tolen -= 2 ; break ; <S2SV_StartBug> case 5 : <S2SV_EndBug> comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ; p += comp_len ; tolen -= comp_len ; if ( tolen == 0 ) return - ENAMETOOLONG ; * p ++ = '/' ; tolen -- ; break ; } <S2SV_StartBug> elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ; <S2SV_EndBug> } if ( p > to + 1 ) p [ - 1 ] = '\\0' ; else p [ 0 ] = '\\0' ; return 0 ; }
","<S2SV_ModStart> elen ) ; elen += sizeof ( struct pathComponent ) ; <S2SV_ModStart> > 0 ) { elen += pc -> lengthComponentIdent ; break ; } <S2SV_ModEnd> case 2 : <S2SV_ModStart> case 5 : elen += pc -> lengthComponentIdent ; if ( elen > fromlen ) return - EIO ; <S2SV_ModStart> break ; } <S2SV_ModEnd> } if (
"
622,"CWE-125 void nfsreq_print_noaddr ( netdissect_options * ndo , register const u_char * bp , u_int length , register const u_char * bp2 ) { register const struct sunrpc_msg * rp ; register const uint32_t * dp ; nfs_type type ; int v3 ; uint32_t proc ; uint32_t access_flags ; struct nfsv3_sattr sa3 ; ND_PRINT ( ( ndo , ""%d"" , length ) ) ; nfserr = 0 ; rp = ( const struct sunrpc_msg * ) bp ; if ( ! xid_map_enter ( ndo , rp , bp2 ) ) goto trunc ; v3 = ( EXTRACT_32BITS ( & rp -> rm_call . cb_vers ) == NFS_VER3 ) ; proc = EXTRACT_32BITS ( & rp -> rm_call . cb_proc ) ; if ( ! v3 && proc < NFS_NPROCS ) proc = nfsv3_procid [ proc ] ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( nfsproc_str , ""proc-%u"" , proc ) ) ) ; switch ( proc ) { case NFSPROC_GETATTR : case NFSPROC_SETATTR : case NFSPROC_READLINK : case NFSPROC_FSSTAT : case NFSPROC_FSINFO : case NFSPROC_PATHCONF : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && parsefh ( ndo , dp , v3 ) != NULL ) return ; break ; case NFSPROC_LOOKUP : case NFSPROC_CREATE : case NFSPROC_MKDIR : case NFSPROC_REMOVE : case NFSPROC_RMDIR : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && parsefhn ( ndo , dp , v3 ) != NULL ) return ; break ; case NFSPROC_ACCESS : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 0 ] ) ; access_flags = EXTRACT_32BITS ( & dp [ 0 ] ) ; if ( access_flags & ~ NFSV3ACCESS_FULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>%04x"" , access_flags ) ) ; } else if ( ( access_flags & NFSV3ACCESS_FULL ) == NFSV3ACCESS_FULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>NFS_ACCESS_FULL"" ) ) ; } else { char separator = '<S2SV_blank>' ; if ( access_flags & NFSV3ACCESS_READ ) { ND_PRINT ( ( ndo , ""<S2SV_blank>NFS_ACCESS_READ"" ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_LOOKUP ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_LOOKUP"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_MODIFY ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_MODIFY"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_EXTEND ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_EXTEND"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_DELETE ) { ND_PRINT ( ( ndo , ""%cNFS_ACCESS_DELETE"" , separator ) ) ; separator = '|' ; } if ( access_flags & NFSV3ACCESS_EXECUTE ) ND_PRINT ( ( ndo , ""%cNFS_ACCESS_EXECUTE"" , separator ) ) ; } return ; } break ; case NFSPROC_READ : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) { ND_TCHECK ( dp [ 2 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; } else { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_WRITE : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) { <S2SV_StartBug> ND_TCHECK ( dp [ 2 ] ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) { <S2SV_StartBug> dp += 3 ; <S2SV_EndBug> ND_TCHECK ( dp [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( dp ) ) ) ) ; } } else { ND_TCHECK ( dp [ 3 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%u<S2SV_blank>(%u)"" , EXTRACT_32BITS ( & dp [ 3 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_SYMLINK : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( v3 && ( dp = parse_sattr3 ( ndo , dp , & sa3 ) ) == NULL ) break ; if ( parsefn ( ndo , dp ) == NULL ) break ; if ( v3 && ndo -> ndo_vflag ) print_sattr3 ( ndo , & sa3 , ndo -> ndo_vflag ) ; return ; } break ; case NFSPROC_MKNOD : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( * dp ) ; type = ( nfs_type ) EXTRACT_32BITS ( dp ) ; dp ++ ; if ( ( dp = parse_sattr3 ( ndo , dp , & sa3 ) ) == NULL ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( type2str , ""unk-ft<S2SV_blank>%d"" , type ) ) ) ; if ( ndo -> ndo_vflag && ( type == NFCHR || type == NFBLK ) ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%u"" , EXTRACT_32BITS ( & dp [ 0 ] ) , EXTRACT_32BITS ( & dp [ 1 ] ) ) ) ; dp += 2 ; } if ( ndo -> ndo_vflag ) print_sattr3 ( ndo , & sa3 , ndo -> ndo_vflag ) ; return ; } break ; case NFSPROC_RENAME : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefhn ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( parsefhn ( ndo , dp , v3 ) != NULL ) return ; } break ; case NFSPROC_LINK : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_PRINT ( ( ndo , ""<S2SV_blank>->"" ) ) ; if ( parsefhn ( ndo , dp , v3 ) != NULL ) return ; } break ; case NFSPROC_READDIR : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { if ( v3 ) { ND_TCHECK ( dp [ 4 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRId64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>verf<S2SV_blank>%08x%08x"" , dp [ 2 ] , dp [ 3 ] ) ) ; } else { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%d"" , EXTRACT_32BITS ( & dp [ 1 ] ) , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } return ; } break ; case NFSPROC_READDIRPLUS : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 4 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRId64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 5 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>verf<S2SV_blank>%08x%08x"" , EXTRACT_32BITS ( & dp [ 5 ] ) , dp [ 2 ] , dp [ 3 ] ) ) ; } return ; } break ; case NFSPROC_COMMIT : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && ( dp = parsefh ( ndo , dp , v3 ) ) != NULL ) { ND_TCHECK ( dp [ 2 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ; return ; } break ; default : return ; } trunc : if ( ! nfserr ) ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }
","<S2SV_ModStart> ( dp [ 4 <S2SV_ModEnd> ] ) ; <S2SV_ModStart> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 3 ] <S2SV_ModEnd> ) ) )
"
623,"CWE-125 void vtp_print ( netdissect_options * ndo , const u_char * pptr , u_int length ) { int type , len , tlv_len , tlv_value , mgmtd_len ; const u_char * tptr ; const struct vtp_vlan_ * vtp_vlan ; if ( length < VTP_HEADER_LEN ) goto trunc ; tptr = pptr ; ND_TCHECK2 ( * tptr , VTP_HEADER_LEN ) ; type = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""VTPv%u,<S2SV_blank>Message<S2SV_blank>%s<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , * tptr , tok2str ( vtp_message_type_values , ""Unknown<S2SV_blank>message<S2SV_blank>type"" , type ) , type , length ) ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\tDomain<S2SV_blank>name:<S2SV_blank>"" ) ) ; mgmtd_len = * ( tptr + 3 ) ; if ( mgmtd_len < 1 || mgmtd_len > 32 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>MgmtD<S2SV_blank>Len<S2SV_blank>%d]"" , mgmtd_len ) ) ; return ; } fn_printzp ( ndo , tptr + 4 , mgmtd_len , NULL ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s:<S2SV_blank>%u"" , tok2str ( vtp_header_values , ""Unknown"" , type ) , * ( tptr + 2 ) ) ) ; tptr += VTP_HEADER_LEN ; switch ( type ) { case VTP_SUMMARY_ADV : ND_TCHECK2 ( * tptr , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x,<S2SV_blank>Updater<S2SV_blank>%s"" , EXTRACT_32BITS ( tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; tptr += 8 ; ND_TCHECK2 ( * tptr , VTP_UPDATE_TIMESTAMP_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Timestamp<S2SV_blank>0x%08x<S2SV_blank>0x%08x<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) ) ) ; tptr += VTP_UPDATE_TIMESTAMP_LEN ; ND_TCHECK2 ( * tptr , VTP_MD5_DIGEST_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>MD5<S2SV_blank>digest:<S2SV_blank>%08x%08x%08x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , EXTRACT_32BITS ( tptr + 12 ) ) ) ; tptr += VTP_MD5_DIGEST_LEN ; break ; case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr += 4 ; while ( tptr < ( pptr + length ) ) { ND_TCHECK_8BITS ( tptr ) ; len = * tptr ; if ( len == 0 ) break ; ND_TCHECK2 ( * tptr , len ) ; vtp_vlan = ( const struct vtp_vlan_ * ) tptr ; <S2SV_StartBug> ND_TCHECK ( * vtp_vlan ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\tVLAN<S2SV_blank>info<S2SV_blank>status<S2SV_blank>%s,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>VLAN-id<S2SV_blank>%u,<S2SV_blank>MTU<S2SV_blank>%u,<S2SV_blank>SAID<S2SV_blank>0x%08x,<S2SV_blank>Name<S2SV_blank>"" , tok2str ( vtp_vlan_status , ""Unknown"" , vtp_vlan -> status ) , tok2str ( vtp_vlan_type_values , ""Unknown"" , vtp_vlan -> type ) , EXTRACT_16BITS ( & vtp_vlan -> vlanid ) , EXTRACT_16BITS ( & vtp_vlan -> mtu ) , EXTRACT_32BITS ( & vtp_vlan -> index ) ) ) ; <S2SV_StartBug> fn_printzp ( ndo , tptr + VTP_VLAN_INFO_OFFSET , vtp_vlan -> name_len , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; <S2SV_EndBug> <S2SV_StartBug> tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; <S2SV_EndBug> while ( len > 0 ) { <S2SV_StartBug> type = * tptr ; <S2SV_EndBug> tlv_len = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t%s<S2SV_blank>(0x%04x)<S2SV_blank>TLV"" , tok2str ( vtp_vlan_tlv_values , ""Unknown"" , type ) , type ) ) ; <S2SV_StartBug> if ( type == 0 || tlv_len == 0 ) { <S2SV_EndBug> return ; } <S2SV_StartBug> ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ; <S2SV_EndBug> tlv_value = EXTRACT_16BITS ( tptr + 2 ) ; switch ( type ) { case VTP_VLAN_STE_HOP_COUNT : ND_PRINT ( ( ndo , "",<S2SV_blank>%u"" , tlv_value ) ) ; break ; case VTP_VLAN_PRUNING : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""Enabled"" : ""Disabled"" , tlv_value ) ) ; break ; case VTP_VLAN_STP_TYPE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( vtp_stp_type_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; break ; case VTP_VLAN_BRIDGE_TYPE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""SRB"" : ""SRT"" , tlv_value ) ) ; break ; case VTP_VLAN_BACKUP_CRF_MODE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""Backup"" : ""Not<S2SV_blank>backup"" , tlv_value ) ) ; break ; case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER : case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER : case VTP_VLAN_PARENT_VLAN : case VTP_VLAN_TRANS_BRIDGED_VLAN : case VTP_VLAN_ARP_HOP_COUNT : default : print_unknown_data ( ndo , tptr , ""\\n\\t\\t<S2SV_blank><S2SV_blank>"" , 2 + tlv_len * 2 ) ; break ; } <S2SV_StartBug> len -= 2 + tlv_len * 2 ; <S2SV_EndBug> tptr += 2 + tlv_len * 2 ; } } break ; case VTP_ADV_REQUEST : ND_TCHECK2 ( * tptr , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\tStart<S2SV_blank>value:<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case VTP_JOIN_MESSAGE : break ; default : break ; } return ; trunc : ND_PRINT ( ( ndo , ""[|vtp]"" ) ) ; }
","<S2SV_ModStart> ) tptr ; if ( len < VTP_VLAN_INFO_FIXED_PART_LEN ) goto trunc ; <S2SV_ModStart> ) ) ; len -= VTP_VLAN_INFO_FIXED_PART_LEN ; tptr += VTP_VLAN_INFO_FIXED_PART_LEN ; if ( len < 4 * ( ( <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len + 3 ) / 4 ) ) goto trunc ; ND_TCHECK2 ( * tptr , <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len ) ; fn_printzp ( ndo , tptr , <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len , NULL ) ; len -= 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; tptr += 4 * ( ( vtp_vlan -> name_len <S2SV_ModStart> 0 ) { if ( len < 2 ) goto trunc ; ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> ; if ( len < tlv_len * 2 + 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(TLV<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>packet)"" ) ) ; <S2SV_ModEnd> return ; } <S2SV_ModStart> 2 ) ; if ( tlv_len != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>TLV<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>1)"" , tlv_len ) ) ; return ; } else { <S2SV_ModStart> break ; } }
"
624,"CWE-000 void xmlParsePI ( xmlParserCtxtPtr ctxt ) { xmlChar * buf = NULL ; int len = 0 ; int size = XML_PARSER_BUFFER_SIZE ; int cur , l ; const xmlChar * target ; xmlParserInputState state ; int count = 0 ; if ( ( RAW == '<' ) && ( NXT ( 1 ) == '?' ) ) { xmlParserInputPtr input = ctxt -> input ; state = ctxt -> instate ; ctxt -> instate = XML_PARSER_PI ; SKIP ( 2 ) ; SHRINK ; target = xmlParsePITarget ( ctxt ) ; if ( target != NULL ) { if ( ( RAW == '?' ) && ( NXT ( 1 ) == '>' ) ) { if ( input != ctxt -> input ) { xmlFatalErrMsg ( ctxt , XML_ERR_ENTITY_BOUNDARY , ""PI<S2SV_blank>declaration<S2SV_blank>doesn\'t<S2SV_blank>start<S2SV_blank>and<S2SV_blank>stop<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>entity\\n"" ) ; } SKIP ( 2 ) ; if ( ( ctxt -> sax ) && ( ! ctxt -> disableSAX ) && ( ctxt -> sax -> processingInstruction != NULL ) ) ctxt -> sax -> processingInstruction ( ctxt -> userData , <S2SV_StartBug> target , NULL ) ; <S2SV_EndBug> ctxt -> instate = state ; return ; } buf = ( xmlChar * ) xmlMallocAtomic ( size * sizeof ( xmlChar ) ) ; if ( buf == NULL ) { xmlErrMemory ( ctxt , NULL ) ; ctxt -> instate = state ; return ; } cur = CUR ; if ( ! IS_BLANK ( cur ) ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_SPACE_REQUIRED , ""ParsePI:<S2SV_blank>PI<S2SV_blank>%s<S2SV_blank>space<S2SV_blank>expected\\n"" , target ) ; } SKIP_BLANKS ; cur = CUR_CHAR ( l ) ; while ( IS_CHAR ( cur ) && ( ( cur != '?' ) || ( NXT ( 1 ) != '>' ) ) ) { if ( len + 5 >= size ) { xmlChar * tmp ; size *= 2 ; tmp = ( xmlChar * ) xmlRealloc ( buf , size * sizeof ( xmlChar ) ) ; if ( tmp == NULL ) { xmlErrMemory ( ctxt , NULL ) ; xmlFree ( buf ) ; ctxt -> instate = state ; return ; } buf = tmp ; } count ++ ; if ( count > 50 ) { GROW ; count = 0 ; } COPY_BUF ( l , buf , len , cur ) ; NEXTL ( l ) ; cur = CUR_CHAR ( l ) ; if ( cur == 0 ) { SHRINK ; GROW ; cur = CUR_CHAR ( l ) ; } } buf [ len ] = 0 ; if ( cur != '?' ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_PI_NOT_FINISHED , ""ParsePI:<S2SV_blank>PI<S2SV_blank>%s<S2SV_blank>never<S2SV_blank>end<S2SV_blank>...\\n"" , target ) ; } else { if ( input != ctxt -> input ) { xmlFatalErrMsg ( ctxt , XML_ERR_SPACE_REQUIRED , ""PI<S2SV_blank>declaration<S2SV_blank>doesn\'t<S2SV_blank>start<S2SV_blank>and<S2SV_blank>stop<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>entity\\n"" ) ; } SKIP ( 2 ) ; # ifdef LIBXML_CATALOG_ENABLED if ( ( ( state == XML_PARSER_MISC ) || ( state == XML_PARSER_START ) ) && ( xmlStrEqual ( target , XML_CATALOG_PI ) ) ) { xmlCatalogAllow allow = xmlCatalogGetDefaults ( ) ; if ( ( allow == XML_CATA_ALLOW_DOCUMENT ) || ( allow == XML_CATA_ALLOW_ALL ) ) xmlParseCatalogPI ( ctxt , buf ) ; } # endif if ( ( ctxt -> sax ) && ( ! ctxt -> disableSAX ) && ( ctxt -> sax -> processingInstruction != NULL ) ) ctxt -> sax -> processingInstruction ( ctxt -> userData , target , buf ) ; } xmlFree ( buf ) ; } else { xmlFatalErr ( ctxt , XML_ERR_PI_NOT_STARTED , NULL ) ; } <S2SV_StartBug> ctxt -> instate = state ; <S2SV_EndBug> } }
","<S2SV_ModStart> NULL ) ; if ( ctxt -> instate != XML_PARSER_EOF ) <S2SV_ModStart> ) ; } if ( <S2SV_ModStart> ctxt -> instate != XML_PARSER_EOF ) ctxt -> instate
"
625,"CWE-200 int udp_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; <S2SV_StartBug> bool slow ; <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( * sin ) ; if ( flags & MSG_ERRQUEUE ) return ip_recv_error ( sk , msg , len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov , copied ) ; else { err = skb_copy_and_csum_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udp_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = udp_hdr ( skb ) -> source ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } unlock_sock_fast ( sk , slow ) ; if ( noblock ) return - EAGAIN ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }
","<S2SV_ModStart> ; bool slow <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ;
"
626,"CWE-125 void rpki_rtr_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { <S2SV_StartBug> u_int tlen , pdu_type , pdu_len ; <S2SV_EndBug> const u_char * tptr ; const rpki_rtr_pdu * pdu_header ; tptr = pptr ; tlen = len ; if ( ! ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "",<S2SV_blank>RPKI-RTR"" ) ) ; return ; } <S2SV_StartBug> while ( tlen >= sizeof ( rpki_rtr_pdu ) ) { <S2SV_EndBug> ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ; pdu_header = ( const rpki_rtr_pdu * ) tptr ; pdu_type = pdu_header -> pdu_type ; pdu_len = EXTRACT_32BITS ( pdu_header -> length ) ; ND_TCHECK2 ( * tptr , pdu_len ) ; if ( ! pdu_type || ! pdu_len ) { break ; } if ( tlen < pdu_len ) { goto trunc ; } <S2SV_StartBug> if ( rpki_rtr_pdu_print ( ndo , tptr , 8 ) ) <S2SV_EndBug> goto trunc ; tlen -= pdu_len ; <S2SV_StartBug> tptr += pdu_len ; <S2SV_EndBug> } <S2SV_StartBug> return ; <S2SV_EndBug> trunc : ND_PRINT ( ( ndo , ""\\n\\t%s"" , tstr ) ) ; }
","<S2SV_ModStart> len ) { <S2SV_ModEnd> if ( ! <S2SV_ModStart> } while ( len ) { u_int pdu_len = <S2SV_ModEnd> rpki_rtr_pdu_print ( ndo <S2SV_ModStart> ( ndo , pptr , len , 1 <S2SV_ModEnd> , 8 ) <S2SV_ModStart> , 8 ) ; len <S2SV_ModEnd> -= pdu_len ; <S2SV_ModStart> -= pdu_len ; pptr <S2SV_ModEnd> += pdu_len ; <S2SV_ModStart> pdu_len ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
627,"CWE-119 RD_BOOL cssp_read_tsrequest ( STREAM token , STREAM pubkey ) { STREAM s ; int length ; int tagval ; <S2SV_StartBug> s = tcp_recv ( NULL , 4 ) ; <S2SV_EndBug> if ( s == NULL ) return False ; if ( s -> p [ 0 ] != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) { logger ( Protocol , Error , ""cssp_read_tsrequest(),<S2SV_blank>expected<S2SV_blank>BER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED,<S2SV_blank>got<S2SV_blank>%x"" , s -> p [ 0 ] ) ; return False ; } if ( s -> p [ 1 ] < 0x80 ) length = s -> p [ 1 ] - 2 ; else if ( s -> p [ 1 ] == 0x81 ) length = s -> p [ 2 ] - 1 ; else if ( s -> p [ 1 ] == 0x82 ) length = ( s -> p [ 2 ] << 8 ) | s -> p [ 3 ] ; else return False ; s = tcp_recv ( s , length ) ; <S2SV_StartBug> if ( ! ber_in_header ( s , & tagval , & length ) || <S2SV_EndBug> tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ; <S2SV_StartBug> in_uint8s ( s , length ) ; <S2SV_EndBug> if ( token ) { if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != BER_TAG_OCTET_STRING ) return False ; <S2SV_StartBug> token -> end = token -> p = token -> data ; <S2SV_EndBug> out_uint8p ( token , s -> p , length ) ; s_mark_end ( token ) ; } if ( pubkey ) { if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != BER_TAG_OCTET_STRING ) return False ; pubkey -> data = pubkey -> p = s -> p ; pubkey -> end = pubkey -> data + length ; pubkey -> size = length ; } return True ; }
","<S2SV_ModStart> int tagval ; struct stream packet ; <S2SV_ModStart> length ) ; packet = * s ; <S2SV_ModStart> return False ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>version<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } <S2SV_ModStart> return False ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>token<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } s_realloc ( token , length ) ; s_reset ( token ) <S2SV_ModEnd> ; out_uint8p (
"
628,"CWE-835 const u_char * ns_nprint ( netdissect_options * ndo , register const u_char * cp , register const u_char * bp ) { register u_int i , l ; register const u_char * rp = NULL ; register int compress = 0 ; <S2SV_StartBug> int chars_processed ; <S2SV_EndBug> int elt ; <S2SV_StartBug> int data_size = ndo -> ndo_snapend - bp ; <S2SV_EndBug> if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; <S2SV_StartBug> chars_processed = 1 ; <S2SV_EndBug> if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) { compress = 0 ; rp = cp + l ; } if ( i != 0 ) while ( i && cp < ndo -> ndo_snapend ) { if ( ( i & INDIR_MASK ) == INDIR_MASK ) { if ( ! compress ) { rp = cp + 1 ; compress = 1 ; } if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; <S2SV_StartBug> cp = bp + ( ( ( i << 8 ) | * cp ) & 0x3fff ) ; <S2SV_EndBug> if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; i = * cp ++ ; <S2SV_StartBug> chars_processed ++ ; <S2SV_EndBug> if ( chars_processed >= data_size ) { ND_PRINT ( ( ndo , ""<LOOP>"" ) ) ; return ( NULL ) ; } continue ; } if ( ( i & INDIR_MASK ) == EDNS0_MASK ) { elt = ( i & ~ INDIR_MASK ) ; switch ( elt ) { case EDNS0_ELT_BITLABEL : if ( blabel_print ( ndo , cp ) == NULL ) return ( NULL ) ; break ; default : ND_PRINT ( ( ndo , ""<ELT<S2SV_blank>%d>"" , elt ) ) ; return ( NULL ) ; } } else { if ( fn_printn ( ndo , cp , l , ndo -> ndo_snapend ) ) return ( NULL ) ; } cp += l ; <S2SV_StartBug> chars_processed += l ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""."" ) ) ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; i = * cp ++ ; <S2SV_StartBug> chars_processed ++ ; <S2SV_EndBug> if ( ! compress ) rp += l + 1 ; } else ND_PRINT ( ( ndo , ""."" ) ) ; return ( rp ) ; }
","<S2SV_ModStart> 0 ; int elt ; u_int offset , max_offset ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; max_offset = ( u_int ) ( cp - bp ) ; if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) { compress = 0 ; rp = cp + l ; } if ( i != 0 ) while ( i && cp < <S2SV_ModEnd> ndo -> ndo_snapend <S2SV_ModStart> ndo -> ndo_snapend ) { if ( ( i & INDIR_MASK ) == INDIR_MASK ) { if ( ! compress ) { rp = cp + 1 ; compress = 1 ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> NULL ) ; offset = ( ( ( i << 8 ) | * cp ) & 0x3fff ) ; if ( offset >= max_offset ) { ND_PRINT ( ( ndo , ""<BAD<S2SV_blank>PTR>"" ) ) ; return ( NULL ) ; } max_offset = offset ; cp = bp + offset ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> NULL ) ; <S2SV_ModEnd> i = * <S2SV_ModStart> cp ++ ; <S2SV_ModEnd> continue ; } <S2SV_ModStart> += l ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> cp ++ ; <S2SV_ModEnd> if ( !
"
629,"CWE-19 int xfs_attr_rmtval_set ( struct xfs_da_args * args ) { struct xfs_inode * dp = args -> dp ; struct xfs_mount * mp = dp -> i_mount ; struct xfs_bmbt_irec map ; xfs_dablk_t lblkno ; xfs_fileoff_t lfileoff = 0 ; __uint8_t * src = args -> value ; int blkcnt ; int valuelen ; int nmap ; int error ; int offset = 0 ; trace_xfs_attr_rmtval_set ( args ) ; <S2SV_StartBug> blkcnt = xfs_attr3_rmt_blocks ( mp , args -> valuelen ) ; <S2SV_EndBug> error = xfs_bmap_first_unused ( args -> trans , args -> dp , blkcnt , & lfileoff , XFS_ATTR_FORK ) ; if ( error ) return error ; args -> rmtblkno = lblkno = ( xfs_dablk_t ) lfileoff ; args -> rmtblkcnt = blkcnt ; while ( blkcnt > 0 ) { int committed ; xfs_bmap_init ( args -> flist , args -> firstblock ) ; nmap = 1 ; error = xfs_bmapi_write ( args -> trans , dp , ( xfs_fileoff_t ) lblkno , blkcnt , XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA , args -> firstblock , args -> total , & map , & nmap , args -> flist ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; ASSERT ( nmap == 1 ) ; ASSERT ( ( map . br_startblock != DELAYSTARTBLOCK ) && ( map . br_startblock != HOLESTARTBLOCK ) ) ; lblkno += map . br_blockcount ; blkcnt -= map . br_blockcount ; error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) return ( error ) ; } lblkno = args -> rmtblkno ; blkcnt = args -> rmtblkcnt ; <S2SV_StartBug> valuelen = args -> valuelen ; <S2SV_EndBug> while ( valuelen > 0 ) { struct xfs_buf * bp ; xfs_daddr_t dblkno ; int dblkcnt ; ASSERT ( blkcnt > 0 ) ; xfs_bmap_init ( args -> flist , args -> firstblock ) ; nmap = 1 ; error = xfs_bmapi_read ( dp , ( xfs_fileoff_t ) lblkno , blkcnt , & map , & nmap , XFS_BMAPI_ATTRFORK ) ; if ( error ) return ( error ) ; ASSERT ( nmap == 1 ) ; ASSERT ( ( map . br_startblock != DELAYSTARTBLOCK ) && ( map . br_startblock != HOLESTARTBLOCK ) ) ; dblkno = XFS_FSB_TO_DADDR ( mp , map . br_startblock ) , dblkcnt = XFS_FSB_TO_BB ( mp , map . br_blockcount ) ; bp = xfs_buf_get ( mp -> m_ddev_targp , dblkno , dblkcnt , 0 ) ; if ( ! bp ) return ENOMEM ; bp -> b_ops = & xfs_attr3_rmt_buf_ops ; xfs_attr_rmtval_copyin ( mp , bp , args -> dp -> i_ino , & offset , & valuelen , & src ) ; error = xfs_bwrite ( bp ) ; xfs_buf_relse ( bp ) ; if ( error ) return error ; lblkno += map . br_blockcount ; blkcnt -= map . br_blockcount ; } ASSERT ( valuelen == 0 ) ; return 0 ; }
","<S2SV_ModStart> , args -> rmtvaluelen <S2SV_ModEnd> ) ; error <S2SV_ModStart> = args -> rmtvaluelen <S2SV_ModEnd> ; while (
"
630,"CWE-352 static void _send ( Socket_T S , const char * request , StringBuffer_T data ) { _argument ( data , ""format"" , ""text"" ) ; char * _auth = _getBasicAuthHeader ( ) ; <S2SV_StartBug> int rv = Socket_print ( S , <S2SV_EndBug> ""POST<S2SV_blank>%s<S2SV_blank>HTTP/1.0\\r\\n"" ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n"" <S2SV_StartBug> ""Content-Length:<S2SV_blank>%d\\r\\n"" <S2SV_EndBug> ""%s"" ""\\r\\n"" ""%s"" , <S2SV_StartBug> request , <S2SV_EndBug> StringBuffer_length ( data ) , _auth ? _auth : """" , StringBuffer_toString ( data ) ) ; FREE ( _auth ) ; if ( rv < 0 ) THROW ( IOException , ""Monit:<S2SV_blank>cannot<S2SV_blank>send<S2SV_blank>command<S2SV_blank>to<S2SV_blank>the<S2SV_blank>monit<S2SV_blank>daemon<S2SV_blank>--<S2SV_blank>%s"" , STRERROR ) ; }
","<S2SV_ModStart> ( ) ; MD_T token ; StringBuffer_append ( data , ""%ssecuritytoken=%s"" , StringBuffer_length ( data ) > 0 ? ""&"" : """" , Util_getToken ( token ) ) ; <S2SV_ModStart> , ""POST<S2SV_blank>%s<S2SV_blank>HTTP/1.0\\r\\n"" ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n"" ""Cookie:<S2SV_blank>securitytoken=%s\\r\\n"" <S2SV_ModStart> ""%s"" , request , token
"
631,"CWE-269 static void copy_asoundrc ( void ) { char * src = RUN_ASOUNDRC_FILE ; char * dest ; if ( asprintf ( & dest , ""%s/.asoundrc"" , cfg . homedir ) == - 1 ) errExit ( ""asprintf"" ) ; if ( is_link ( dest ) ) { fprintf ( stderr , ""Error:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link\\n"" , dest ) ; exit ( 1 ) ; } <S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> if ( child < 0 ) errExit ( ""fork"" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; <S2SV_StartBug> int rv = copy_file ( src , dest ) ; <S2SV_EndBug> if ( rv ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\n"" ) ; else { fs_logger2 ( ""clone"" , dest ) ; } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; <S2SV_StartBug> if ( chown ( dest , getuid ( ) , getgid ( ) ) < 0 ) <S2SV_EndBug> errExit ( ""chown"" ) ; <S2SV_StartBug> if ( chmod ( dest , S_IRUSR | S_IWUSR ) < 0 ) <S2SV_EndBug> errExit ( ""chmod"" ) ; unlink ( src ) ; }
","<S2SV_ModStart> ) ; } copy_file_as_user <S2SV_ModEnd> ( src , <S2SV_ModStart> ( src , <S2SV_ModEnd> dest , getuid <S2SV_ModStart> getgid ( ) <S2SV_ModEnd> , S_IRUSR | <S2SV_ModStart> | S_IWUSR ) ; fs_logger2 ( ""clone"" , dest <S2SV_ModEnd> ) ; unlink
"
632,"CWE-401 static struct fc_host_statistics * bfad_im_get_stats ( struct Scsi_Host * shost ) { struct bfad_im_port_s * im_port = ( struct bfad_im_port_s * ) shost -> hostdata [ 0 ] ; struct bfad_s * bfad = im_port -> bfad ; struct bfad_hal_comp fcomp ; union bfa_port_stats_u * fcstats ; struct fc_host_statistics * hstats ; bfa_status_t rc ; unsigned long flags ; fcstats = kzalloc ( sizeof ( union bfa_port_stats_u ) , GFP_KERNEL ) ; if ( fcstats == NULL ) return NULL ; hstats = & bfad -> link_stats ; init_completion ( & fcomp . comp ) ; spin_lock_irqsave ( & bfad -> bfad_lock , flags ) ; memset ( hstats , 0 , sizeof ( struct fc_host_statistics ) ) ; rc = bfa_port_get_stats ( BFA_FCPORT ( & bfad -> bfa ) , fcstats , bfad_hcb_comp , & fcomp ) ; spin_unlock_irqrestore ( & bfad -> bfad_lock , flags ) ; <S2SV_StartBug> if ( rc != BFA_STATUS_OK ) <S2SV_EndBug> return NULL ; <S2SV_StartBug> wait_for_completion ( & fcomp . comp ) ; <S2SV_EndBug> hstats -> seconds_since_last_reset = fcstats -> fc . secs_reset ; hstats -> tx_frames = fcstats -> fc . tx_frames ; hstats -> tx_words = fcstats -> fc . tx_words ; hstats -> rx_frames = fcstats -> fc . rx_frames ; hstats -> rx_words = fcstats -> fc . rx_words ; hstats -> lip_count = fcstats -> fc . lip_count ; hstats -> nos_count = fcstats -> fc . nos_count ; hstats -> error_frames = fcstats -> fc . error_frames ; hstats -> dumped_frames = fcstats -> fc . dropped_frames ; hstats -> link_failure_count = fcstats -> fc . link_failures ; hstats -> loss_of_sync_count = fcstats -> fc . loss_of_syncs ; hstats -> loss_of_signal_count = fcstats -> fc . loss_of_signals ; hstats -> prim_seq_protocol_err_count = fcstats -> fc . primseq_errs ; hstats -> invalid_crc_count = fcstats -> fc . invalid_crcs ; kfree ( fcstats ) ; return hstats ; }
","<S2SV_ModStart> != BFA_STATUS_OK ) { kfree ( fcstats ) ; <S2SV_ModStart> return NULL ; }
"
633,"CWE-20 static inline void VectorClamp3 ( DDSVector3 * value ) { <S2SV_StartBug> value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> -> x = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> y = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> z = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f ,
"
634,"CWE-476 int git_pkt_parse_line ( git_pkt * * head , const char * line , const char * * out , size_t bufflen ) { int ret ; int32_t len ; if ( bufflen > 0 && bufflen < PKT_LEN_SIZE ) return GIT_EBUFS ; len = parse_len ( line ) ; if ( len < 0 ) { if ( bufflen >= 4 && ! git__prefixcmp ( line , ""PACK"" ) ) { giterr_clear ( ) ; * out = line ; return pack_pkt ( head ) ; } return ( int ) len ; } if ( bufflen > 0 && bufflen < ( size_t ) len ) return GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ; line += PKT_LEN_SIZE ; if ( len == PKT_LEN_SIZE ) { <S2SV_StartBug> * head = NULL ; <S2SV_EndBug> * out = line ; return 0 ; } if ( len == 0 ) { * out = line ; return flush_pkt ( head ) ; } len -= PKT_LEN_SIZE ; if ( * line == GIT_SIDE_BAND_DATA ) ret = data_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_PROGRESS ) ret = sideband_progress_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_ERROR ) ret = sideband_error_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ACK"" ) ) ret = ack_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""NAK"" ) ) ret = nak_pkt ( head ) ; else if ( ! git__prefixcmp ( line , ""ERR<S2SV_blank>"" ) ) ret = err_pkt ( head , line , len ) ; else if ( * line == '#' ) ret = comment_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ok"" ) ) ret = ok_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ng"" ) ) ret = ng_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""unpack"" ) ) ret = unpack_pkt ( head , line , len ) ; else ret = ref_pkt ( head , line , len ) ; * out = line + len ; return ret ; }
","<S2SV_ModStart> PKT_LEN_SIZE ) { giterr_set_str ( GITERR_NET , ""Invalid<S2SV_blank>empty<S2SV_blank>packet"" ) ; return GIT_ERROR <S2SV_ModEnd> ; } if
"
635,"CWE-20 static int do_anonymous_page ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long address , pte_t * page_table , pmd_t * pmd , unsigned int flags ) { struct mem_cgroup * memcg ; struct page * page ; spinlock_t * ptl ; pte_t entry ; pte_unmap ( page_table ) ; <S2SV_StartBug> if ( check_stack_guard_page ( vma , address ) < 0 ) <S2SV_EndBug> return VM_FAULT_SIGSEGV ; if ( ! ( flags & FAULT_FLAG_WRITE ) && ! mm_forbids_zeropage ( mm ) ) { entry = pte_mkspecial ( pfn_pte ( my_zero_pfn ( address ) , vma -> vm_page_prot ) ) ; page_table = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; if ( ! pte_none ( * page_table ) ) goto unlock ; goto setpte ; } if ( unlikely ( anon_vma_prepare ( vma ) ) ) goto oom ; page = alloc_zeroed_user_highpage_movable ( vma , address ) ; if ( ! page ) goto oom ; if ( mem_cgroup_try_charge ( page , mm , GFP_KERNEL , & memcg ) ) goto oom_free_page ; __SetPageUptodate ( page ) ; entry = mk_pte ( page , vma -> vm_page_prot ) ; if ( vma -> vm_flags & VM_WRITE ) entry = pte_mkwrite ( pte_mkdirty ( entry ) ) ; page_table = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; if ( ! pte_none ( * page_table ) ) goto release ; inc_mm_counter_fast ( mm , MM_ANONPAGES ) ; page_add_new_anon_rmap ( page , vma , address ) ; mem_cgroup_commit_charge ( page , memcg , false ) ; lru_cache_add_active_or_unevictable ( page , vma ) ; setpte : set_pte_at ( mm , address , page_table , entry ) ; update_mmu_cache ( vma , address , page_table ) ; unlock : pte_unmap_unlock ( page_table , ptl ) ; return 0 ; release : mem_cgroup_cancel_charge ( page , memcg ) ; page_cache_release ( page ) ; goto unlock ; oom_free_page : page_cache_release ( page ) ; oom : return VM_FAULT_OOM ; }
","<S2SV_ModStart> ; if ( vma -> vm_flags & VM_SHARED ) return VM_FAULT_SIGBUS ; if (
"
636,"CWE-416 static void sig_server_connect_copy ( SERVER_CONNECT_REC * * dest , IRC_SERVER_CONNECT_REC * src ) { IRC_SERVER_CONNECT_REC * rec ; g_return_if_fail ( dest != NULL ) ; if ( ! IS_IRC_SERVER_CONNECT ( src ) ) return ; rec = g_new0 ( IRC_SERVER_CONNECT_REC , 1 ) ; rec -> chat_type = IRC_PROTOCOL ; rec -> max_cmds_at_once = src -> max_cmds_at_once ; rec -> cmd_queue_speed = src -> cmd_queue_speed ; rec -> max_query_chans = src -> max_query_chans ; rec -> max_kicks = src -> max_kicks ; rec -> max_modes = src -> max_modes ; rec -> max_msgs = src -> max_msgs ; rec -> max_whois = src -> max_whois ; rec -> usermode = g_strdup ( src -> usermode ) ; rec -> alternate_nick = g_strdup ( src -> alternate_nick ) ; rec -> sasl_mechanism = src -> sasl_mechanism ; <S2SV_StartBug> rec -> sasl_username = src -> sasl_username ; <S2SV_EndBug> <S2SV_StartBug> rec -> sasl_password = src -> sasl_password ; <S2SV_EndBug> * dest = ( SERVER_CONNECT_REC * ) rec ; }
","<S2SV_ModStart> -> sasl_username = g_strdup ( <S2SV_ModStart> src -> sasl_username ) <S2SV_ModStart> -> sasl_password = g_strdup ( <S2SV_ModStart> src -> sasl_password )
"
637,"CWE-20 static int adjust_insn_aux_data ( struct bpf_verifier_env * env , u32 prog_len , u32 off , u32 cnt ) { <S2SV_StartBug> struct bpf_insn_aux_data * new_data , * old_data = env -> insn_aux_data ; <S2SV_EndBug> if ( cnt == 1 ) return 0 ; new_data = vzalloc ( sizeof ( struct bpf_insn_aux_data ) * prog_len ) ; if ( ! new_data ) return - ENOMEM ; memcpy ( new_data , old_data , sizeof ( struct bpf_insn_aux_data ) * off ) ; memcpy ( new_data + off + cnt - 1 , old_data + off , sizeof ( struct bpf_insn_aux_data ) * ( prog_len - off - cnt + 1 ) ) ; <S2SV_StartBug> env -> insn_aux_data = new_data ; <S2SV_EndBug> vfree ( old_data ) ; return 0 ; }
","<S2SV_ModStart> env -> insn_aux_data ; int i <S2SV_ModStart> ) ) ; for ( i = off ; i < off + cnt - 1 ; i ++ ) new_data [ i ] . seen = true ;
"
638,"CWE-125 int frag6_print ( netdissect_options * ndo , register const u_char * bp , register const u_char * bp2 ) { register const struct ip6_frag * dp ; register const struct ip6_hdr * ip6 ; dp = ( const struct ip6_frag * ) bp ; ip6 = ( const struct ip6_hdr * ) bp2 ; <S2SV_StartBug> ND_TCHECK ( dp -> ip6f_offlg ) ; <S2SV_EndBug> if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""frag<S2SV_blank>(0x%08x:%d|%ld)"" , EXTRACT_32BITS ( & dp -> ip6f_ident ) , EXTRACT_16BITS ( & dp -> ip6f_offlg ) & IP6F_OFF_MASK , sizeof ( struct ip6_hdr ) + EXTRACT_16BITS ( & ip6 -> ip6_plen ) - ( long ) ( bp - bp2 ) - sizeof ( struct ip6_frag ) ) ) ; } else { ND_PRINT ( ( ndo , ""frag<S2SV_blank>(%d|%ld)"" , EXTRACT_16BITS ( & dp -> ip6f_offlg ) & IP6F_OFF_MASK , sizeof ( struct ip6_hdr ) + EXTRACT_16BITS ( & ip6 -> ip6_plen ) - ( long ) ( bp - bp2 ) - sizeof ( struct ip6_frag ) ) ) ; } if ( ( EXTRACT_16BITS ( & dp -> ip6f_offlg ) & IP6F_OFF_MASK ) != 0 ) return - 1 ; else { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; return sizeof ( struct ip6_frag ) ; } trunc : ND_PRINT ( ( ndo , ""[|frag]"" ) ) ; return - 1 ; }
","<S2SV_ModStart> ; ND_TCHECK ( * dp <S2SV_ModEnd> ) ; if
"
639,"CWE-125 static int mobility_opt_print ( netdissect_options * ndo , const u_char * bp , const unsigned len ) { unsigned i , optlen ; for ( i = 0 ; i < len ; i += optlen ) { ND_TCHECK ( bp [ i ] ) ; if ( bp [ i ] == IP6MOPT_PAD1 ) optlen = 1 ; else { if ( i + 1 < len ) { ND_TCHECK ( bp [ i + 1 ] ) ; optlen = bp [ i + 1 ] + 2 ; } else goto trunc ; } if ( i + optlen > len ) goto trunc ; ND_TCHECK ( bp [ i + optlen ] ) ; switch ( bp [ i ] ) { case IP6MOPT_PAD1 : ND_PRINT ( ( ndo , ""(pad1)"" ) ) ; break ; case IP6MOPT_PADN : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(padn:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(padn)"" ) ) ; break ; case IP6MOPT_REFRESH : if ( len - i < IP6MOPT_REFRESH_MINLEN ) { ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } <S2SV_StartBug> ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>%u)"" , <S2SV_EndBug> EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ; break ; case IP6MOPT_ALTCOA : if ( len - i < IP6MOPT_ALTCOA_MINLEN ) { ND_PRINT ( ( ndo , ""(altcoa:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(alt-CoA:<S2SV_blank>%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ; break ; case IP6MOPT_NONCEID : if ( len - i < IP6MOPT_NONCEID_MINLEN ) { ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>ho=0x%04x<S2SV_blank>co=0x%04x)"" , EXTRACT_16BITS ( & bp [ i + 2 ] ) , EXTRACT_16BITS ( & bp [ i + 4 ] ) ) ) ; break ; case IP6MOPT_AUTH : if ( len - i < IP6MOPT_AUTH_MINLEN ) { ND_PRINT ( ( ndo , ""(auth:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(auth)"" ) ) ; break ; default : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(sopt_type<S2SV_blank>%u:<S2SV_blank>trunc)"" , bp [ i ] ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(type-0x%02x:<S2SV_blank>len=%u)"" , bp [ i ] , bp [ i + 1 ] ) ) ; break ; } } return 0 ; trunc : return 1 ; }
","<S2SV_ModStart> trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;
"
640,"CWE-119 static void update_alt_ref_frame_stats ( VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; if ( ! cpi -> auto_gold ) cpi -> frames_till_gf_update_due = DEFAULT_GF_INTERVAL ; if ( ( cpi -> pass != 2 ) && cpi -> frames_till_gf_update_due ) { cpi -> current_gf_interval = cpi -> frames_till_gf_update_due ; cpi -> gf_overspend_bits += cpi -> projected_frame_size ; cpi -> non_gf_bitrate_adjustment = cpi -> gf_overspend_bits / cpi -> frames_till_gf_update_due ; } <S2SV_StartBug> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug> cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; cpi -> frames_since_golden = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> source_alt_ref_active = 1 ; }
","<S2SV_ModStart> frames_till_gf_update_due ; } memset <S2SV_ModEnd> ( cpi ->
"
641,"CWE-119 static int PredictorDecodeTile ( TIFF * tif , uint8 * op0 , tmsize_t occ0 , uint16 s ) { TIFFPredictorState * sp = PredictorState ( tif ) ; assert ( sp != NULL ) ; assert ( sp -> decodetile != NULL ) ; if ( ( * sp -> decodetile ) ( tif , op0 , occ0 , s ) ) { tmsize_t rowsize = sp -> rowsize ; assert ( rowsize > 0 ) ; <S2SV_StartBug> assert ( ( occ0 % rowsize ) == 0 ) ; <S2SV_EndBug> assert ( sp -> decodepfunc != NULL ) ; while ( occ0 > 0 ) { <S2SV_StartBug> ( * sp -> decodepfunc ) ( tif , op0 , rowsize ) ; <S2SV_EndBug> occ0 -= rowsize ; op0 += rowsize ; } return 1 ; } else return 0 ; }
","<S2SV_ModStart> 0 ) ; if <S2SV_ModEnd> ( ( occ0 <S2SV_ModStart> % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""PredictorDecodeTile"" , ""%s"" , ""occ0%rowsize<S2SV_blank>!=<S2SV_blank>0"" ) ; return 0 ; } <S2SV_ModEnd> assert ( sp <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , rowsize ) ) return 0
"
642,"CWE-400 static void exif_mnote_data_canon_load ( ExifMnoteData * ne , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataCanon * n = ( ExifMnoteDataCanon * ) ne ; ExifShort c ; <S2SV_StartBug> size_t i , tcount , o , datao ; <S2SV_EndBug> if ( ! n || ! buf || ! buf_size ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } datao = 6 + n -> offset ; if ( CHECKOVERFLOW ( datao , buf_size , 2 ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } c = exif_get_short ( buf + datao , n -> order ) ; datao += 2 ; exif_mnote_data_canon_clear ( n ) ; n -> entries = exif_mem_alloc ( ne -> mem , sizeof ( MnoteCanonEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( ne -> log , ""ExifMnoteCanon"" , sizeof ( MnoteCanonEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ; memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteCanonEntry ) ) ; if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Short<S2SV_blank>MakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteCanon"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_canon_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( n -> entries [ tcount ] . format ) , n -> entries [ tcount ] . components ) ; continue ; } s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( ! s ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Invalid<S2SV_blank>zero-length<S2SV_blank>tag<S2SV_blank>size"" ) ; continue ; } else { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteCanon"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( ne -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( ne -> log , ""ExifMnoteCanon"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } <S2SV_StartBug> ++ tcount ; <S2SV_EndBug> } n -> count = tcount ; }
","<S2SV_ModStart> o , datao ; long failsafe_size = 0 <S2SV_ModStart> ) ; } failsafe_size += mnote_canon_entry_count_values ( & n -> entries [ tcount ] ) ; if ( failsafe_size > FAILSAFE_SIZE_MAX ) { exif_mem_free ( ne -> mem , n -> entries [ tcount ] . data ) ; exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Failsafe<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>(%lu<S2SV_blank>><S2SV_blank>%ld)"" , failsafe_size , FAILSAFE_SIZE_MAX ) ; break ; }
"
643,"CWE-000 OM_uint32 kg_unseal_iov ( OM_uint32 * minor_status , gss_ctx_id_t context_handle , int * conf_state , gss_qop_t * qop_state , gss_iov_buffer_desc * iov , int iov_count , int toktype ) { krb5_gss_ctx_id_rec * ctx ; OM_uint32 code ; ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; <S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug> * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; } if ( kg_locate_iov ( iov , iov_count , GSS_IOV_BUFFER_TYPE_STREAM ) != NULL ) { code = kg_unseal_stream_iov ( minor_status , ctx , conf_state , qop_state , iov , iov_count , toktype ) ; } else { code = kg_unseal_iov_token ( minor_status , ctx , conf_state , qop_state , iov , iov_count , toktype ) ; } return code ; }
","<S2SV_ModStart> ; if ( ctx -> terminated ||
"
644,"CWE-399 static void hugetlbfs_put_super ( struct super_block * sb ) { struct hugetlbfs_sb_info * sbi = HUGETLBFS_SB ( sb ) ; if ( sbi ) { sb -> s_fs_info = NULL ; <S2SV_StartBug> kfree ( sbi ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> = NULL ; if ( sbi -> spool ) hugepage_put_subpool ( sbi -> spool ) ;
"
645,"CWE-362 static int myisamchk ( MI_CHECK * param , char * filename ) { int error , lock_type , recreate ; int rep_quick = param -> testflag & ( T_QUICK | T_FORCE_UNIQUENESS ) ; MI_INFO * info ; File datafile ; char llbuff [ 22 ] , llbuff2 [ 22 ] ; my_bool state_updated = 0 ; MYISAM_SHARE * share ; DBUG_ENTER ( ""myisamchk"" ) ; param -> out_flag = error = param -> warning_printed = param -> error_printed = recreate = 0 ; datafile = 0 ; param -> isam_file_name = filename ; if ( ! ( info = mi_open ( filename , ( param -> testflag & ( T_DESCRIPT | T_READONLY ) ) ? O_RDONLY : O_RDWR , HA_OPEN_FOR_REPAIR | ( ( param -> testflag & T_WAIT_FOREVER ) ? HA_OPEN_WAIT_IF_LOCKED : ( param -> testflag & T_DESCRIPT ) ? HA_OPEN_IGNORE_IF_LOCKED : HA_OPEN_ABORT_IF_LOCKED ) ) ) ) { param -> error_printed = 1 ; switch ( my_errno ) { case HA_ERR_CRASHED : mi_check_print_error ( param , ""\'%s\'<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>a<S2SV_blank>correct<S2SV_blank>index<S2SV_blank>definition.<S2SV_blank>You<S2SV_blank>need<S2SV_blank>to<S2SV_blank>recreate<S2SV_blank>it<S2SV_blank>before<S2SV_blank>you<S2SV_blank>can<S2SV_blank>do<S2SV_blank>a<S2SV_blank>repair"" , filename ) ; break ; case HA_ERR_NOT_A_TABLE : mi_check_print_error ( param , ""\'%s\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>MyISAM-table"" , filename ) ; break ; case HA_ERR_CRASHED_ON_USAGE : mi_check_print_error ( param , ""\'%s\'<S2SV_blank>is<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>crashed"" , filename ) ; break ; case HA_ERR_CRASHED_ON_REPAIR : mi_check_print_error ( param , ""\'%s\'<S2SV_blank>is<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>crashed<S2SV_blank>after<S2SV_blank>last<S2SV_blank>repair"" , filename ) ; break ; case HA_ERR_OLD_FILE : mi_check_print_error ( param , ""\'%s\'<S2SV_blank>is<S2SV_blank>an<S2SV_blank>old<S2SV_blank>type<S2SV_blank>of<S2SV_blank>MyISAM-table"" , filename ) ; break ; case HA_ERR_END_OF_FILE : mi_check_print_error ( param , ""Couldn\'t<S2SV_blank>read<S2SV_blank>complete<S2SV_blank>header<S2SV_blank>from<S2SV_blank>\'%s\'"" , filename ) ; break ; case EAGAIN : mi_check_print_error ( param , ""\'%s\'<S2SV_blank>is<S2SV_blank>locked.<S2SV_blank>Use<S2SV_blank>-w<S2SV_blank>to<S2SV_blank>wait<S2SV_blank>until<S2SV_blank>unlocked"" , filename ) ; break ; case ENOENT : mi_check_print_error ( param , ""File<S2SV_blank>\'%s\'<S2SV_blank>doesn\'t<S2SV_blank>exist"" , filename ) ; break ; case EACCES : mi_check_print_error ( param , ""You<S2SV_blank>don\'t<S2SV_blank>have<S2SV_blank>permission<S2SV_blank>to<S2SV_blank>use<S2SV_blank>\'%s\'"" , filename ) ; break ; default : mi_check_print_error ( param , ""%d<S2SV_blank>when<S2SV_blank>opening<S2SV_blank>MyISAM-table<S2SV_blank>\'%s\'"" , my_errno , filename ) ; break ; } DBUG_RETURN ( 1 ) ; } share = info -> s ; share -> options &= ~ HA_OPTION_READ_ONLY_DATA ; share -> tot_locks -= share -> r_locks ; share -> r_locks = 0 ; if ( param -> testflag & ( T_FAST | T_CHECK_ONLY_CHANGED ) ) { my_bool need_to_check = mi_is_crashed ( info ) || share -> state . open_count != 0 ; if ( ( param -> testflag & ( T_REP_ANY | T_SORT_RECORDS ) ) && ( ( share -> state . changed & ( STATE_CHANGED | STATE_CRASHED | STATE_CRASHED_ON_REPAIR ) || ! ( param -> testflag & T_CHECK_ONLY_CHANGED ) ) ) ) need_to_check = 1 ; if ( info -> s -> base . keys && info -> state -> records ) { if ( ( param -> testflag & T_STATISTICS ) && ( share -> state . changed & STATE_NOT_ANALYZED ) ) need_to_check = 1 ; if ( ( param -> testflag & T_SORT_INDEX ) && ( share -> state . changed & STATE_NOT_SORTED_PAGES ) ) need_to_check = 1 ; if ( ( param -> testflag & T_REP_BY_SORT ) && ( share -> state . changed & STATE_NOT_OPTIMIZED_KEYS ) ) need_to_check = 1 ; } if ( ( param -> testflag & T_CHECK_ONLY_CHANGED ) && ( share -> state . changed & ( STATE_CHANGED | STATE_CRASHED | STATE_CRASHED_ON_REPAIR ) ) ) need_to_check = 1 ; if ( ! need_to_check ) { if ( ! ( param -> testflag & T_SILENT ) || param -> testflag & T_INFO ) printf ( ""MyISAM<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>already<S2SV_blank>checked\\n"" , filename ) ; if ( mi_close ( info ) ) { mi_check_print_error ( param , ""%d<S2SV_blank>when<S2SV_blank>closing<S2SV_blank>MyISAM-table<S2SV_blank>\'%s\'"" , my_errno , filename ) ; DBUG_RETURN ( 1 ) ; } DBUG_RETURN ( 0 ) ; } } if ( ( param -> testflag & ( T_REP_ANY | T_STATISTICS | T_SORT_RECORDS | T_SORT_INDEX ) ) && ( ( ( param -> testflag & T_UNPACK ) && share -> data_file_type == COMPRESSED_RECORD ) || mi_uint2korr ( share -> state . header . state_info_length ) != MI_STATE_INFO_SIZE || mi_uint2korr ( share -> state . header . base_info_length ) != MI_BASE_INFO_SIZE || mi_is_any_intersect_keys_active ( param -> keys_in_use , share -> base . keys , ~ share -> state . key_map ) || test_if_almost_full ( info ) || info -> s -> state . header . file_version [ 3 ] != myisam_file_magic [ 3 ] || ( set_collation && set_collation -> number != share -> state . header . language ) || myisam_block_size != MI_KEY_BLOCK_LENGTH ) ) { if ( set_collation ) param -> language = set_collation -> number ; if ( recreate_table ( param , & info , filename ) ) { ( void ) fprintf ( stderr , ""MyISAM-table<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>fixed<S2SV_blank>because<S2SV_blank>of<S2SV_blank>errors\\n"" , filename ) ; return ( - 1 ) ; } recreate = 1 ; if ( ! ( param -> testflag & T_REP_ANY ) ) { param -> testflag |= T_REP_BY_SORT ; if ( ! ( param -> testflag & T_SILENT ) ) printf ( ""-<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>old<S2SV_blank>table-format.<S2SV_blank>Recreating<S2SV_blank>index\\n"" , filename ) ; rep_quick |= T_QUICK ; } share = info -> s ; share -> tot_locks -= share -> r_locks ; share -> r_locks = 0 ; } if ( param -> testflag & T_DESCRIPT ) { param -> total_files ++ ; param -> total_records += info -> state -> records ; param -> total_deleted += info -> state -> del ; descript ( param , info , filename ) ; } else { if ( ! stopwords_inited ++ ) ft_init_stopwords ( ) ; if ( ! ( param -> testflag & T_READONLY ) ) lock_type = F_WRLCK ; else lock_type = F_RDLCK ; if ( info -> lock_type == F_RDLCK ) info -> lock_type = F_UNLCK ; if ( _mi_readinfo ( info , lock_type , 0 ) ) { mi_check_print_error ( param , ""Can\'t<S2SV_blank>lock<S2SV_blank>indexfile<S2SV_blank>of<S2SV_blank>\'%s\',<S2SV_blank>error:<S2SV_blank>%d"" , filename , my_errno ) ; param -> error_printed = 0 ; goto end2 ; } mi_lock_database ( info , F_EXTRA_LCK ) ; datafile = info -> dfile ; if ( param -> testflag & ( T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX ) ) { if ( param -> testflag & T_REP_ANY ) { ulonglong tmp = share -> state . key_map ; mi_copy_keys_active ( share -> state . key_map , share -> base . keys , param -> keys_in_use ) ; if ( tmp != share -> state . key_map ) info -> update |= HA_STATE_CHANGED ; } if ( rep_quick && chk_del ( param , info , param -> testflag & ~ T_VERBOSE ) ) { if ( param -> testflag & T_FORCE_CREATE ) { rep_quick = 0 ; mi_check_print_info ( param , ""Creating<S2SV_blank>new<S2SV_blank>data<S2SV_blank>file\\n"" ) ; } else { error = 1 ; mi_check_print_error ( param , ""Quick-recover<S2SV_blank>aborted;<S2SV_blank>Run<S2SV_blank>recovery<S2SV_blank>without<S2SV_blank>switch<S2SV_blank>\'q\'"" ) ; } } if ( ! error ) { if ( ( param -> testflag & ( T_REP_BY_SORT | T_REP_PARALLEL ) ) && ( mi_is_any_key_active ( share -> state . key_map ) || ( rep_quick && ! param -> keys_in_use && ! recreate ) ) && mi_test_if_sort_rep ( info , info -> state -> records , info -> s -> state . key_map , param -> force_sort ) ) { if ( param -> testflag & T_REP_BY_SORT ) <S2SV_StartBug> error = mi_repair_by_sort ( param , info , filename , rep_quick ) ; <S2SV_EndBug> else <S2SV_StartBug> error = mi_repair_parallel ( param , info , filename , rep_quick ) ; <S2SV_EndBug> state_updated = 1 ; } else if ( param -> testflag & T_REP_ANY ) <S2SV_StartBug> error = mi_repair ( param , info , filename , rep_quick ) ; <S2SV_EndBug> } if ( ! error && param -> testflag & T_SORT_RECORDS ) { # ifndef TO_BE_REMOVED if ( param -> out_flag & O_NEW_DATA ) { ( void ) my_close ( info -> dfile , MYF ( MY_WME ) ) ; error |= change_to_newfile ( filename , MI_NAME_DEXT , DATA_TMP_EXT , MYF ( 0 ) ) ; if ( mi_open_datafile ( info , info -> s , NULL , - 1 ) ) error = 1 ; param -> out_flag &= ~ O_NEW_DATA ; param -> read_cache . file = info -> dfile ; } # endif if ( ! error ) { uint key ; my_bool update_index = 1 ; for ( key = 0 ; key < share -> base . keys ; key ++ ) if ( share -> keyinfo [ key ] . flag & ( HA_BINARY_PACK_KEY | HA_FULLTEXT ) ) update_index = 0 ; error = mi_sort_records ( param , info , filename , param -> opt_sort_key , ( my_bool ) ! ( param -> testflag & T_REP ) , update_index ) ; datafile = info -> dfile ; if ( ! error && ! update_index ) { if ( param -> verbose ) puts ( ""Table<S2SV_blank>had<S2SV_blank>a<S2SV_blank>compressed<S2SV_blank>index;<S2SV_blank><S2SV_blank>We<S2SV_blank>must<S2SV_blank>now<S2SV_blank>recreate<S2SV_blank>the<S2SV_blank>index"" ) ; <S2SV_StartBug> error = mi_repair_by_sort ( param , info , filename , 1 ) ; <S2SV_EndBug> } } } if ( ! error && param -> testflag & T_SORT_INDEX ) <S2SV_StartBug> error = mi_sort_index ( param , info , filename ) ; <S2SV_EndBug> if ( ! error ) share -> state . changed &= ~ ( STATE_CHANGED | STATE_CRASHED | STATE_CRASHED_ON_REPAIR ) ; else mi_mark_crashed ( info ) ; } else if ( ( param -> testflag & T_CHECK ) || ! ( param -> testflag & T_AUTO_INC ) ) { if ( ! ( param -> testflag & T_SILENT ) || param -> testflag & T_INFO ) printf ( ""Checking<S2SV_blank>MyISAM<S2SV_blank>file:<S2SV_blank>%s\\n"" , filename ) ; if ( ! ( param -> testflag & T_SILENT ) ) printf ( ""Data<S2SV_blank>records:<S2SV_blank>%7s<S2SV_blank><S2SV_blank><S2SV_blank>Deleted<S2SV_blank>blocks:<S2SV_blank>%7s\\n"" , llstr ( info -> state -> records , llbuff ) , llstr ( info -> state -> del , llbuff2 ) ) ; error = chk_status ( param , info ) ; mi_intersect_keys_active ( share -> state . key_map , param -> keys_in_use ) ; error = chk_size ( param , info ) ; if ( ! error || ! ( param -> testflag & ( T_FAST | T_FORCE_CREATE ) ) ) error |= chk_del ( param , info , param -> testflag ) ; if ( ( ! error || ( ! ( param -> testflag & ( T_FAST | T_FORCE_CREATE ) ) && ! param -> start_check_pos ) ) ) { error |= chk_key ( param , info ) ; if ( ! error && ( param -> testflag & ( T_STATISTICS | T_AUTO_INC ) ) ) error = update_state_info ( param , info , ( ( param -> testflag & T_STATISTICS ) ? UPDATE_STAT : 0 ) | ( ( param -> testflag & T_AUTO_INC ) ? UPDATE_AUTO_INC : 0 ) ) ; } if ( ( ! rep_quick && ! error ) || ! ( param -> testflag & ( T_FAST | T_FORCE_CREATE ) ) ) { if ( param -> testflag & ( T_EXTEND | T_MEDIUM ) ) ( void ) init_key_cache ( dflt_key_cache , opt_key_cache_block_size , param -> use_buffers , 0 , 0 ) ; ( void ) init_io_cache ( & param -> read_cache , datafile , ( uint ) param -> read_buffer_length , READ_CACHE , ( param -> start_check_pos ? param -> start_check_pos : share -> pack . header_length ) , 1 , MYF ( MY_WME ) ) ; lock_memory ( param ) ; if ( ( info -> s -> options & ( HA_OPTION_PACK_RECORD | HA_OPTION_COMPRESS_RECORD ) ) || ( param -> testflag & ( T_EXTEND | T_MEDIUM ) ) ) error |= chk_data_link ( param , info , param -> testflag & T_EXTEND ) ; error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ; ( void ) end_io_cache ( & param -> read_cache ) ; } if ( ! error ) { if ( ( share -> state . changed & STATE_CHANGED ) && ( param -> testflag & T_UPDATE_STATE ) ) info -> update |= HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ; share -> state . changed &= ~ ( STATE_CHANGED | STATE_CRASHED | STATE_CRASHED_ON_REPAIR ) ; } else if ( ! mi_is_crashed ( info ) && ( param -> testflag & T_UPDATE_STATE ) ) { mi_mark_crashed ( info ) ; info -> update |= HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ; } } } if ( ( param -> testflag & T_AUTO_INC ) || ( ( param -> testflag & T_REP_ANY ) && info -> s -> base . auto_key ) ) update_auto_increment_key ( param , info , ( my_bool ) ! test ( param -> testflag & T_AUTO_INC ) ) ; if ( ! ( param -> testflag & T_DESCRIPT ) ) { if ( info -> update & HA_STATE_CHANGED && ! ( param -> testflag & T_READONLY ) ) error |= update_state_info ( param , info , UPDATE_OPEN_COUNT | ( ( ( param -> testflag & T_REP_ANY ) ? UPDATE_TIME : 0 ) | ( state_updated ? UPDATE_STAT : 0 ) | ( ( param -> testflag & T_SORT_RECORDS ) ? UPDATE_SORT : 0 ) ) ) ; ( void ) lock_file ( param , share -> kfile , 0L , F_UNLCK , ""indexfile"" , filename ) ; info -> update &= ~ HA_STATE_CHANGED ; } mi_lock_database ( info , F_UNLCK ) ; end2 : if ( mi_close ( info ) ) { mi_check_print_error ( param , ""%d<S2SV_blank>when<S2SV_blank>closing<S2SV_blank>MyISAM-table<S2SV_blank>\'%s\'"" , my_errno , filename ) ; DBUG_RETURN ( 1 ) ; } if ( error == 0 ) { if ( param -> out_flag & O_NEW_DATA ) error |= change_to_newfile ( filename , MI_NAME_DEXT , DATA_TMP_EXT , ( ( param -> testflag & T_BACKUP_DATA ) ? MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) ; if ( param -> out_flag & O_NEW_INDEX ) error |= change_to_newfile ( filename , MI_NAME_IEXT , INDEX_TMP_EXT , MYF ( 0 ) ) ; } ( void ) fflush ( stdout ) ; ( void ) fflush ( stderr ) ; if ( param -> error_printed ) { if ( param -> testflag & ( T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX ) ) { ( void ) fprintf ( stderr , ""MyISAM-table<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>fixed<S2SV_blank>because<S2SV_blank>of<S2SV_blank>errors\\n"" , filename ) ; if ( param -> testflag & T_REP_ANY ) ( void ) fprintf ( stderr , ""Try<S2SV_blank>fixing<S2SV_blank>it<S2SV_blank>by<S2SV_blank>using<S2SV_blank>the<S2SV_blank>--safe-recover<S2SV_blank>(-o),<S2SV_blank>the<S2SV_blank>--force<S2SV_blank>(-f)<S2SV_blank>option<S2SV_blank>or<S2SV_blank>by<S2SV_blank>not<S2SV_blank>using<S2SV_blank>the<S2SV_blank>--quick<S2SV_blank>(-q)<S2SV_blank>flag\\n"" ) ; } else if ( ! ( param -> error_printed & 2 ) && ! ( param -> testflag & T_FORCE_CREATE ) ) ( void ) fprintf ( stderr , ""MyISAM-table<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>corrupted\\nFix<S2SV_blank>it<S2SV_blank>using<S2SV_blank>switch<S2SV_blank>\\""-r\\""<S2SV_blank>or<S2SV_blank>\\""-o\\""\\n"" , filename ) ; } else if ( param -> warning_printed && ! ( param -> testflag & ( T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX | T_FORCE_CREATE ) ) ) ( void ) fprintf ( stderr , ""MyISAM-table<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>usable<S2SV_blank>but<S2SV_blank>should<S2SV_blank>be<S2SV_blank>fixed\\n"" , filename ) ; ( void ) fflush ( stderr ) ; DBUG_RETURN ( error ) ; }
","<S2SV_ModStart> filename , rep_quick , FALSE <S2SV_ModStart> filename , rep_quick , FALSE <S2SV_ModStart> filename , rep_quick , FALSE <S2SV_ModStart> filename , 1 , FALSE <S2SV_ModStart> info , filename , FALSE
"
646,"CWE-89 char * curl_easy_unescape ( CURL * handle , const char * string , int length , int * olen ) { <S2SV_StartBug> int alloc = ( length ? length : ( int ) strlen ( string ) ) + 1 ; <S2SV_EndBug> char * ns = malloc ( alloc ) ; unsigned char in ; int strindex = 0 ; unsigned long hex ; <S2SV_StartBug> CURLcode res ; <S2SV_EndBug> if ( ! ns ) return NULL ; while ( -- alloc > 0 ) { in = * string ; if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { char hexstr [ 3 ] ; char * ptr ; hexstr [ 0 ] = string [ 1 ] ; hexstr [ 1 ] = string [ 2 ] ; hexstr [ 2 ] = 0 ; hex = strtoul ( hexstr , & ptr , 16 ) ; in = curlx_ultouc ( hex ) ; <S2SV_StartBug> res = Curl_convert_from_network ( handle , & in , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( res ) { <S2SV_EndBug> free ( ns ) ; return NULL ; } string += 2 ; alloc -= 2 ; } ns [ strindex ++ ] = in ; string ++ ; } ns [ strindex ] = 0 ; if ( olen ) <S2SV_StartBug> * olen = strindex ; <S2SV_EndBug> return ns ; }
","<S2SV_ModStart> olen ) { char * str = NULL ; size_t inputlen = length ; size_t outputlen <S2SV_ModEnd> ; CURLcode res <S2SV_ModStart> ; CURLcode res = Curl_urldecode <S2SV_ModEnd> ( handle , <S2SV_ModStart> ( handle , string , inputlen , & str , & outputlen , FALSE <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( res ) return NULL <S2SV_ModEnd> ; if ( <S2SV_ModStart> * olen = curlx_uztosi ( outputlen ) ; return str <S2SV_ModEnd> ; } <S2SV_null>
"
647,"CWE-416 INST_HANDLER ( cpse ) { int r = ( buf [ 0 ] & 0xf ) | ( ( buf [ 1 ] & 0x2 ) << 3 ) ; int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; <S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( ""r%d,r%d,^,!,"" , r , d ) ; ESIL_A ( ""?{,%"" PFMT64d "",pc,=,},"" , op -> jump ) ; }
","<S2SV_ModStart> ; RAnalOp next_op = { 0 }
"
648,"CWE-20 static ssize_t generic_perform_write ( struct file * file , struct iov_iter * i , loff_t pos ) { struct address_space * mapping = file -> f_mapping ; const struct address_space_operations * a_ops = mapping -> a_ops ; long status = 0 ; ssize_t written = 0 ; unsigned int flags = 0 ; if ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) flags |= AOP_FLAG_UNINTERRUPTIBLE ; do { struct page * page ; pgoff_t index ; unsigned long offset ; unsigned long bytes ; size_t copied ; void * fsdata ; offset = ( pos & ( PAGE_CACHE_SIZE - 1 ) ) ; index = pos >> PAGE_CACHE_SHIFT ; bytes = min_t ( unsigned long , PAGE_CACHE_SIZE - offset , iov_iter_count ( i ) ) ; again : if ( unlikely ( iov_iter_fault_in_readable ( i , bytes ) ) ) { status = - EFAULT ; break ; } status = a_ops -> write_begin ( file , mapping , pos , bytes , flags , & page , & fsdata ) ; if ( unlikely ( status ) ) break ; pagefault_disable ( ) ; copied = iov_iter_copy_from_user_atomic ( page , i , offset , bytes ) ; pagefault_enable ( ) ; flush_dcache_page ( page ) ; status = a_ops -> write_end ( file , mapping , pos , bytes , copied , page , fsdata ) ; if ( unlikely ( status < 0 ) ) break ; copied = status ; cond_resched ( ) ; <S2SV_StartBug> if ( unlikely ( copied == 0 ) ) { <S2SV_EndBug> bytes = min_t ( unsigned long , PAGE_CACHE_SIZE - offset , iov_iter_single_seg_count ( i ) ) ; goto again ; } <S2SV_StartBug> iov_iter_advance ( i , copied ) ; <S2SV_EndBug> pos += copied ; written += copied ; balance_dirty_pages_ratelimited ( mapping ) ; } while ( iov_iter_count ( i ) ) ; return written ? written : status ; }
","<S2SV_ModStart> ( ) ; iov_iter_advance ( i , copied ) ; <S2SV_ModStart> again ; } <S2SV_ModEnd> pos += copied
"
649,"CWE-119 static void dma_rx ( struct b43_dmaring * ring , int * slot ) { const struct b43_dma_ops * ops = ring -> ops ; struct b43_dmadesc_generic * desc ; struct b43_dmadesc_meta * meta ; struct b43_rxhdr_fw4 * rxhdr ; struct sk_buff * skb ; u16 len ; int err ; dma_addr_t dmaaddr ; desc = ops -> idx2desc ( ring , * slot , & meta ) ; sync_descbuffer_for_cpu ( ring , meta -> dmaaddr , ring -> rx_buffersize ) ; skb = meta -> skb ; rxhdr = ( struct b43_rxhdr_fw4 * ) skb -> data ; len = le16_to_cpu ( rxhdr -> frame_len ) ; if ( len == 0 ) { int i = 0 ; do { udelay ( 2 ) ; barrier ( ) ; len = le16_to_cpu ( rxhdr -> frame_len ) ; } while ( len == 0 && i ++ < 5 ) ; if ( unlikely ( len == 0 ) ) { dmaaddr = meta -> dmaaddr ; goto drop_recycle_buffer ; } } if ( unlikely ( b43_rx_buffer_is_poisoned ( ring , skb ) ) ) { b43dbg ( ring -> dev -> wl , ""DMA<S2SV_blank>RX:<S2SV_blank>Dropping<S2SV_blank>poisoned<S2SV_blank>buffer.\\n"" ) ; dmaaddr = meta -> dmaaddr ; goto drop_recycle_buffer ; } <S2SV_StartBug> if ( unlikely ( len > ring -> rx_buffersize ) ) { <S2SV_EndBug> int cnt = 0 ; s32 tmp = len ; while ( 1 ) { desc = ops -> idx2desc ( ring , * slot , & meta ) ; b43_poison_rx_buffer ( ring , meta -> skb ) ; sync_descbuffer_for_device ( ring , meta -> dmaaddr , ring -> rx_buffersize ) ; * slot = next_slot ( ring , * slot ) ; cnt ++ ; tmp -= ring -> rx_buffersize ; if ( tmp <= 0 ) break ; } b43err ( ring -> dev -> wl , ""DMA<S2SV_blank>RX<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small<S2SV_blank>"" ""(len:<S2SV_blank>%u,<S2SV_blank>buffer:<S2SV_blank>%u,<S2SV_blank>nr-dropped:<S2SV_blank>%d)\\n"" , len , ring -> rx_buffersize , cnt ) ; goto drop ; } dmaaddr = meta -> dmaaddr ; err = setup_rx_descbuffer ( ring , desc , meta , GFP_ATOMIC ) ; if ( unlikely ( err ) ) { b43dbg ( ring -> dev -> wl , ""DMA<S2SV_blank>RX:<S2SV_blank>setup_rx_descbuffer()<S2SV_blank>failed\\n"" ) ; goto drop_recycle_buffer ; } unmap_descbuffer ( ring , dmaaddr , ring -> rx_buffersize , 0 ) ; skb_put ( skb , len + ring -> frameoffset ) ; skb_pull ( skb , ring -> frameoffset ) ; b43_rx ( ring -> dev , skb , rxhdr ) ; drop : return ; drop_recycle_buffer : b43_poison_rx_buffer ( ring , skb ) ; sync_descbuffer_for_device ( ring , dmaaddr , ring -> rx_buffersize ) ; }
","<S2SV_ModStart> unlikely ( len + ring -> frameoffset
"
650,"CWE-415 void init_usm ( void ) { struct snmp_secmod_def * def ; char * type ; DEBUGMSGTL ( ( ""init_usm"" , ""unit_usm:<S2SV_blank>%"" NETSNMP_PRIo ""u<S2SV_blank>%"" NETSNMP_PRIo ""u\\n"" , usmNoPrivProtocol [ 0 ] , usmNoPrivProtocol [ 1 ] ) ) ; sc_init ( ) ; def = SNMP_MALLOC_STRUCT ( snmp_secmod_def ) ; if ( def == NULL ) return ; def -> encode_reverse = usm_secmod_rgenerate_out_msg ; def -> encode_forward = usm_secmod_generate_out_msg ; def -> decode = usm_secmod_process_in_msg ; <S2SV_StartBug> def -> pdu_free_state_ref = usm_free_usmStateReference ; <S2SV_EndBug> def -> session_setup = usm_session_init ; def -> handle_report = usm_handle_report ; def -> probe_engineid = usm_discover_engineid ; def -> post_probe_engineid = usm_create_user_from_session_hook ; if ( register_sec_mod ( USM_SEC_MODEL_NUMBER , ""usm"" , def ) != SNMPERR_SUCCESS ) { SNMP_FREE ( def ) ; snmp_log ( LOG_ERR , ""could<S2SV_blank>not<S2SV_blank>register<S2SV_blank>usm<S2SV_blank>sec<S2SV_blank>mod\\n"" ) ; return ; } snmp_register_callback ( SNMP_CALLBACK_LIBRARY , SNMP_CALLBACK_POST_PREMIB_READ_CONFIG , init_usm_post_config , NULL ) ; snmp_register_callback ( SNMP_CALLBACK_LIBRARY , SNMP_CALLBACK_SHUTDOWN , deinit_usm_post_config , NULL ) ; snmp_register_callback ( SNMP_CALLBACK_LIBRARY , SNMP_CALLBACK_SHUTDOWN , free_engineID , NULL ) ; register_config_handler ( ""snmp"" , ""defAuthType"" , snmpv3_authtype_conf , NULL , ""MD5|SHA|SHA-512|SHA-384|SHA-256|SHA-224"" ) ; register_config_handler ( ""snmp"" , ""defPrivType"" , snmpv3_privtype_conf , NULL , ""DES"" # ifdef HAVE_AES ""|AES|AES-128"" # ifdef NETSNMP_DRAFT_BLUMENTHAL_AES_04 ""|AES-192|AES-256"" # endif # else ""<S2SV_blank>(AES<S2SV_blank>support<S2SV_blank>not<S2SV_blank>available)"" # endif ) ; snmp_register_callback ( SNMP_CALLBACK_LIBRARY , SNMP_CALLBACK_SHUTDOWN , free_enginetime_on_shutdown , NULL ) ; type = netsnmp_ds_get_string ( NETSNMP_DS_LIBRARY_ID , NETSNMP_DS_LIB_APPTYPE ) ; register_config_handler ( type , ""userSetAuthPass"" , usm_set_password , NULL , NULL ) ; register_config_handler ( type , ""userSetPrivPass"" , usm_set_password , NULL , NULL ) ; register_config_handler ( type , ""userSetAuthKey"" , usm_set_password , NULL , NULL ) ; register_config_handler ( type , ""userSetPrivKey"" , usm_set_password , NULL , NULL ) ; register_config_handler ( type , ""userSetAuthLocalKey"" , usm_set_password , NULL , NULL ) ; register_config_handler ( type , ""userSetPrivLocalKey"" , usm_set_password , NULL , NULL ) ; }
","<S2SV_ModStart> ; def -> pdu_clone = usm_clone ; def ->
"
651,"CWE-119 void traverse_commit_list ( struct rev_info * revs , show_commit_fn show_commit , show_object_fn show_object , void * data ) { int i ; struct commit * commit ; struct strbuf base ; strbuf_init ( & base , PATH_MAX ) ; while ( ( commit = get_revision ( revs ) ) != NULL ) { if ( commit -> tree ) add_pending_tree ( revs , commit -> tree ) ; show_commit ( commit , data ) ; } for ( i = 0 ; i < revs -> pending . nr ; i ++ ) { struct object_array_entry * pending = revs -> pending . objects + i ; struct object * obj = pending -> item ; const char * name = pending -> name ; const char * path = pending -> path ; if ( obj -> flags & ( UNINTERESTING | SEEN ) ) continue ; if ( obj -> type == OBJ_TAG ) { obj -> flags |= SEEN ; <S2SV_StartBug> show_object ( obj , NULL , name , data ) ; <S2SV_EndBug> continue ; } if ( ! path ) path = """" ; if ( obj -> type == OBJ_TREE ) { process_tree ( revs , ( struct tree * ) obj , show_object , & base , path , data ) ; continue ; } if ( obj -> type == OBJ_BLOB ) { process_blob ( revs , ( struct blob * ) obj , show_object , <S2SV_StartBug> NULL , path , data ) ; <S2SV_EndBug> continue ; } die ( ""unknown<S2SV_blank>pending<S2SV_blank>object<S2SV_blank>%s<S2SV_blank>(%s)"" , oid_to_hex ( & obj -> oid ) , name ) ; } object_array_clear ( & revs -> pending ) ; strbuf_release ( & base ) ; }
","<S2SV_ModStart> ( obj , <S2SV_ModEnd> name , data <S2SV_ModStart> , show_object , & base <S2SV_ModEnd> , path ,
"
652,"CWE-674 int regexec ( Reprog * prog , const char * sp , Resub * sub , int eflags ) { Resub scratch ; int i ; if ( ! sub ) sub = & scratch ; sub -> nsub = prog -> nsub ; for ( i = 0 ; i < MAXSUB ; ++ i ) sub -> sub [ i ] . sp = sub -> sub [ i ] . ep = NULL ; <S2SV_StartBug> return ! match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ; <S2SV_EndBug> }
","<S2SV_ModStart> NULL ; return <S2SV_ModEnd> match ( prog <S2SV_ModStart> eflags , sub , 0
"
653,"CWE-119 static int kempf_decode_tile ( G2MContext * c , int tile_x , int tile_y , const uint8_t * src , int src_size ) { int width , height ; int hdr , zsize , npal , tidx = - 1 , ret ; int i , j ; const uint8_t * src_end = src + src_size ; uint8_t pal [ 768 ] , transp [ 3 ] ; uLongf dlen = ( c -> tile_width + 1 ) * c -> tile_height ; int sub_type ; int nblocks , cblocks , bstride ; int bits , bitbuf , coded ; uint8_t * dst = c -> framebuf + tile_x * c -> tile_width * 3 + tile_y * c -> tile_height * c -> framebuf_stride ; if ( src_size < 2 ) return AVERROR_INVALIDDATA ; width = FFMIN ( c -> width - tile_x * c -> tile_width , c -> tile_width ) ; height = FFMIN ( c -> height - tile_y * c -> tile_height , c -> tile_height ) ; hdr = * src ++ ; sub_type = hdr >> 5 ; if ( sub_type == 0 ) { int j ; memcpy ( transp , src , 3 ) ; src += 3 ; for ( j = 0 ; j < height ; j ++ , dst += c -> framebuf_stride ) for ( i = 0 ; i < width ; i ++ ) memcpy ( dst + i * 3 , transp , 3 ) ; return 0 ; } else if ( sub_type == 1 ) { return jpg_decode_data ( & c -> jc , width , height , src , src_end - src , dst , c -> framebuf_stride , NULL , 0 , 0 , 0 ) ; } if ( sub_type != 2 ) { memcpy ( transp , src , 3 ) ; src += 3 ; } npal = * src ++ + 1 ; memcpy ( pal , src , npal * 3 ) ; src += npal * 3 ; if ( sub_type != 2 ) { for ( i = 0 ; i < npal ; i ++ ) { if ( ! memcmp ( pal + i * 3 , transp , 3 ) ) { tidx = i ; break ; } } } if ( src_end - src < 2 ) return 0 ; zsize = ( src [ 0 ] << 8 ) | src [ 1 ] ; src += 2 ; <S2SV_StartBug> if ( src_end - src < zsize ) <S2SV_EndBug> return AVERROR_INVALIDDATA ; ret = uncompress ( c -> kempf_buf , & dlen , src , zsize ) ; if ( ret ) return AVERROR_INVALIDDATA ; src += zsize ; if ( sub_type == 2 ) { kempf_restore_buf ( c -> kempf_buf , dlen , dst , c -> framebuf_stride , NULL , 0 , width , height , pal , npal , tidx ) ; return 0 ; } nblocks = * src ++ + 1 ; cblocks = 0 ; bstride = FFALIGN ( width , 16 ) >> 4 ; bits = 0 ; for ( i = 0 ; i < ( FFALIGN ( height , 16 ) >> 4 ) ; i ++ ) { for ( j = 0 ; j < ( FFALIGN ( width , 16 ) >> 4 ) ; j ++ ) { if ( ! bits ) { <S2SV_StartBug> bitbuf = * src ++ ; <S2SV_EndBug> bits = 8 ; } coded = bitbuf & 1 ; bits -- ; bitbuf >>= 1 ; cblocks += coded ; if ( cblocks > nblocks ) return AVERROR_INVALIDDATA ; c -> kempf_flags [ j + i * bstride ] = coded ; } } memset ( c -> jpeg_tile , 0 , c -> tile_stride * height ) ; jpg_decode_data ( & c -> jc , width , height , src , src_end - src , c -> jpeg_tile , c -> tile_stride , c -> kempf_flags , bstride , nblocks , 0 ) ; kempf_restore_buf ( c -> kempf_buf , dlen , dst , c -> framebuf_stride , c -> jpeg_tile , c -> tile_stride , width , height , pal , npal , tidx ) ; return 0 ; }
","<S2SV_ModStart> src < zsize + ( sub_type != 2 ) <S2SV_ModStart> bits ) { if ( src >= src_end ) return AVERROR_INVALIDDATA ;
"
654,"CWE-119 static void unqueue_me_pi ( struct futex_q * q ) { WARN_ON ( plist_node_empty ( & q -> list ) ) ; plist_del ( & q -> list , & q -> list . plist ) ; BUG_ON ( ! q -> pi_state ) ; free_pi_state ( q -> pi_state ) ; q -> pi_state = NULL ; spin_unlock ( q -> lock_ptr ) ; <S2SV_StartBug> drop_futex_key_refs ( & q -> key ) ; <S2SV_EndBug> }
","<S2SV_ModStart> lock_ptr ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
655,"CWE-269 int fixExec2Error ( int action , u_char * var_val , u_char var_val_type , size_t var_val_len , u_char * statP , oid * name , size_t name_len ) { netsnmp_old_extend * exten = NULL ; unsigned int idx ; idx = name [ name_len - 1 ] - 1 ; exten = & compatability_entries [ idx ] ; <S2SV_StartBug> # ifndef NETSNMP_NO_WRITE_SUPPORT <S2SV_EndBug> switch ( action ) { case MODE_SET_RESERVE1 : if ( var_val_type != ASN_INTEGER ) { snmp_log ( LOG_ERR , ""Wrong<S2SV_blank>type<S2SV_blank>!=<S2SV_blank>int\\n"" ) ; return SNMP_ERR_WRONGTYPE ; } idx = * ( ( long * ) var_val ) ; if ( idx != 1 ) { snmp_log ( LOG_ERR , ""Wrong<S2SV_blank>value<S2SV_blank>!=<S2SV_blank>1\\n"" ) ; return SNMP_ERR_WRONGVALUE ; } if ( ! exten || ! exten -> efix_entry ) { snmp_log ( LOG_ERR , ""No<S2SV_blank>command<S2SV_blank>to<S2SV_blank>run\\n"" ) ; return SNMP_ERR_GENERR ; } return SNMP_ERR_NOERROR ; case MODE_SET_COMMIT : netsnmp_cache_check_and_reload ( exten -> efix_entry -> cache ) ; } # endif return SNMP_ERR_NOERROR ; }
","<S2SV_ModStart> ] ; # if ! defined ( NETSNMP_NO_WRITE_SUPPORT ) && ENABLE_EXTEND_WRITE_ACCESS <S2SV_ModEnd> switch ( action
"
656,"CWE-125 static ssize_t DecodePSDPixels ( const size_t number_compact_pixels , const unsigned char * compact_pixels , const ssize_t depth , const size_t number_pixels , unsigned char * pixels ) { # define CheckNumberCompactPixels if ( packets == 0 ) return ( i ) ; packets -- # define CheckNumberPixels ( count ) if ( ( ( ssize_t ) i + count ) > ( ssize_t ) number_pixels ) return ( i ) ; i += count int pixel ; register ssize_t i , j ; size_t length ; ssize_t packets ; packets = ( ssize_t ) number_compact_pixels ; for ( i = 0 ; ( packets > 1 ) && ( i < ( ssize_t ) number_pixels ) ; ) { packets -- ; length = ( size_t ) ( * compact_pixels ++ ) ; if ( length == 128 ) continue ; if ( length > 128 ) { length = 256 - length + 1 ; CheckNumberCompactPixels ; pixel = ( * compact_pixels ++ ) ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { switch ( depth ) { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( pixel >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 6 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 2 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x03 ) & 0x03 ) ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0xff ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x0f ) & 0xff ) ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( unsigned char ) pixel ; break ; } } } continue ; } length ++ ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { <S2SV_StartBug> switch ( depth ) <S2SV_EndBug> { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( * compact_pixels >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( * compact_pixels >> 6 ) & 0x03 ; * pixels ++ = ( * compact_pixels >> 4 ) & 0x03 ; * pixels ++ = ( * compact_pixels >> 2 ) & 0x03 ; * pixels ++ = ( * compact_pixels & 0x03 ) & 0x03 ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( * compact_pixels >> 4 ) & 0xff ; * pixels ++ = ( * compact_pixels & 0x0f ) & 0xff ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( * compact_pixels ) ; break ; } } <S2SV_StartBug> CheckNumberCompactPixels ; <S2SV_EndBug> compact_pixels ++ ; } } return ( i ) ; }
","<S2SV_ModStart> ++ ) { CheckNumberCompactPixels ; <S2SV_ModStart> ; } } <S2SV_ModEnd> compact_pixels ++ ;
"
657,"CWE-20 int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; <S2SV_StartBug> list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , <S2SV_EndBug> open_list ) { <S2SV_StartBug> spin_lock_irq ( & slave_active_lock ) ; <S2SV_EndBug> _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; <S2SV_StartBug> spin_unlock_irq ( & slave_active_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
","<S2SV_ModStart> timer ) ; spin_lock_irq ( & slave_active_lock ) ; spin_lock ( & timer -> lock ) ; <S2SV_ModStart> open_list ) { <S2SV_ModEnd> list_move_tail ( & <S2SV_ModStart> = NULL ; list_del_init ( & slave -> ack_list ) ; list_del_init ( & slave -> active_list ) ; } spin_unlock ( & timer -> lock ) ; <S2SV_ModStart> slave_active_lock ) ; <S2SV_ModEnd> mutex_unlock ( &
"
658,"CWE-125 static int print_ccp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)"" , tok2str ( ccpconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( ccpconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; switch ( opt ) { case CCPOPT_BSDCOMP : if ( len < 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>3)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>Version:<S2SV_blank>%u,<S2SV_blank>Dictionary<S2SV_blank>Bits:<S2SV_blank>%u"" , p [ 2 ] >> 5 , p [ 2 ] & 0x1f ) ) ; break ; case CCPOPT_MVRCA : if ( len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>Features:<S2SV_blank>%u,<S2SV_blank>PxP:<S2SV_blank>%s,<S2SV_blank>History:<S2SV_blank>%u,<S2SV_blank>#CTX-ID:<S2SV_blank>%u"" , ( p [ 2 ] & 0xc0 ) >> 6 , ( p [ 2 ] & 0x20 ) ? ""Enabled"" : ""Disabled"" , p [ 2 ] & 0x1f , p [ 3 ] ) ) ; break ; case CCPOPT_DEFLATE : if ( len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>Window:<S2SV_blank>%uK,<S2SV_blank>Method:<S2SV_blank>%s<S2SV_blank>(0x%x),<S2SV_blank>MBZ:<S2SV_blank>%u,<S2SV_blank>CHK:<S2SV_blank>%u"" , ( p [ 2 ] & 0xf0 ) >> 4 , ( ( p [ 2 ] & 0x0f ) == 8 ) ? ""zlib"" : ""unknown"" , p [ 2 ] & 0x0f , ( p [ 3 ] & 0xfc ) >> 2 , p [ 3 ] & 0x03 ) ) ; break ; # if 0 case CCPOPT_OUI : case CCPOPT_PRED1 : case CCPOPT_PRED2 : case CCPOPT_PJUMP : case CCPOPT_HPPPC : case CCPOPT_STACLZS : case CCPOPT_MPPC : case CCPOPT_GFZA : case CCPOPT_V42BIS : case CCPOPT_LZSDCP : case CCPOPT_DEC : case CCPOPT_RESV : break ; # endif default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , ""[|ccp]"" ) ) ; return 0 ; }
","<S2SV_ModStart> len ; } ND_TCHECK ( p [ 2 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT
"
659,"CWE-416 R_API int r_core_bin_set_env ( RCore * r , RBinFile * binfile ) { RBinObject * binobj = binfile ? binfile -> o : NULL ; RBinInfo * info = binobj ? binobj -> info : NULL ; if ( info ) { int va = info -> has_va ; <S2SV_StartBug> const char * arch = info -> arch ; <S2SV_EndBug> ut16 bits = info -> bits ; ut64 baseaddr = r_bin_get_baddr ( r -> bin ) ; r_config_set_i ( r -> config , ""io.va"" , ( binobj -> info ) ? binobj -> info -> has_va : 0 ) ; r_config_set_i ( r -> config , ""bin.baddr"" , baseaddr ) ; r_config_set ( r -> config , ""asm.arch"" , arch ) ; r_config_set_i ( r -> config , ""asm.bits"" , bits ) ; r_config_set ( r -> config , ""anal.arch"" , arch ) ; <S2SV_StartBug> if ( info -> cpu && * info -> cpu ) { <S2SV_EndBug> <S2SV_StartBug> r_config_set ( r -> config , ""anal.cpu"" , info -> cpu ) ; <S2SV_EndBug> } else { r_config_set ( r -> config , ""anal.cpu"" , arch ) ; } r_asm_use ( r -> assembler , arch ) ; r_core_bin_info ( r , R_CORE_BIN_ACC_ALL , R_CORE_BIN_SET , va , NULL , NULL ) ; <S2SV_StartBug> r_core_bin_set_cur ( r , binfile ) ; <S2SV_EndBug> return true ; } return false ; }
","<S2SV_ModStart> -> has_va ; <S2SV_ModEnd> char * arch <S2SV_ModStart> * arch = strdup ( info -> arch ) ; char * cpu = info -> cpu ? strdup ( info -> cpu ) : NULL <S2SV_ModEnd> ; ut16 bits <S2SV_ModStart> ; if ( <S2SV_ModEnd> cpu && * <S2SV_ModStart> cpu && * <S2SV_ModEnd> cpu ) { <S2SV_ModStart> , ""anal.cpu"" , <S2SV_ModEnd> cpu ) ; <S2SV_ModStart> r , binfile ) ; free ( cpu ) ; free ( arch
"
660,"CWE-000 <S2SV_StartBug> static void sas_probe_devices ( struct work_struct * work ) <S2SV_EndBug> { <S2SV_StartBug> struct domain_device * dev , * n ; <S2SV_EndBug> struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ; struct asd_sas_port * port = ev -> port ; clear_bit ( DISCE_PROBE , & port -> disc . pending ) ; list_for_each_entry ( dev , & port -> disco_list , disco_list_node ) { spin_lock_irq ( & port -> dev_list_lock ) ; list_add_tail ( & dev -> dev_list_node , & port -> dev_list ) ; spin_unlock_irq ( & port -> dev_list_lock ) ; } sas_probe_sata ( port ) ; list_for_each_entry_safe ( dev , n , & port -> disco_list , disco_list_node ) { int err ; err = sas_rphy_add ( dev -> rphy ) ; if ( err ) sas_fail_probe ( dev , __func__ , err ) ; else list_del_init ( & dev -> disco_list_node ) ; } }
","<S2SV_ModStart> sas_probe_devices ( struct asd_sas_port * port <S2SV_ModEnd> ) { struct <S2SV_ModStart> , * n <S2SV_ModEnd> ; list_for_each_entry (
"
661,"CWE-119 WORD32 ih264d_parse_islice ( dec_struct_t * ps_dec , UWORD16 u2_first_mb_in_slice ) { dec_pic_params_t * ps_pps = ps_dec -> ps_cur_pps ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_dec -> ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_dec -> ps_bitstrm -> u4_ofst ; UWORD32 u4_temp ; WORD32 i_temp ; WORD32 ret ; if ( ps_slice -> u1_nal_ref_idc != 0 ) { if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) <S2SV_StartBug> ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( <S2SV_EndBug> ps_dec ) ; else ps_dec -> ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ; } i_temp = ps_pps -> u1_pic_init_qp + ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ( i_temp < 0 ) || ( i_temp > 51 ) ) return ERROR_INV_RANGE_QP_T ; ps_slice -> u1_slice_qp = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_qp_delta"" , ps_slice -> u1_slice_qp - ps_pps -> u1_pic_init_qp ) ; if ( ps_pps -> u1_deblocking_filter_parameters_present_flag == 1 ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>disable_deblocking_filter_idc"" , u4_temp ) ; if ( u4_temp > SLICE_BOUNDARY_DBLK_DISABLED ) { return ERROR_INV_SLICE_HDR_T ; } ps_slice -> u1_disable_dblk_filter_idc = u4_temp ; if ( u4_temp != 1 ) { i_temp = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) << 1 ; if ( ( MIN_DBLK_FIL_OFF > i_temp ) || ( i_temp > MAX_DBLK_FIL_OFF ) ) { return ERROR_INV_SLICE_HDR_T ; } ps_slice -> i1_slice_alpha_c0_offset = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_alpha_c0_offset_div2"" , ps_slice -> i1_slice_alpha_c0_offset >> 1 ) ; i_temp = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) << 1 ; if ( ( MIN_DBLK_FIL_OFF > i_temp ) || ( i_temp > MAX_DBLK_FIL_OFF ) ) { return ERROR_INV_SLICE_HDR_T ; } ps_slice -> i1_slice_beta_offset = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_beta_offset_div2"" , ps_slice -> i1_slice_beta_offset >> 1 ) ; } else { ps_slice -> i1_slice_alpha_c0_offset = 0 ; ps_slice -> i1_slice_beta_offset = 0 ; } } else { ps_slice -> u1_disable_dblk_filter_idc = 0 ; ps_slice -> i1_slice_alpha_c0_offset = 0 ; ps_slice -> i1_slice_beta_offset = 0 ; } ps_dec -> u2_mv_2mb [ 0 ] = 0 ; ps_dec -> u2_mv_2mb [ 1 ] = 0 ; ps_dec -> u1_slice_header_done = 2 ; if ( ps_pps -> u1_entropy_coding_mode ) { SWITCHOFFTRACE ; SWITCHONTRACECABAC ; if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ) { ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff ; } else ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff ; ret = ih264d_parse_islice_data_cabac ( ps_dec , ps_slice , u2_first_mb_in_slice ) ; if ( ret != OK ) return ret ; SWITCHONTRACE ; SWITCHOFFTRACECABAC ; } else { if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ) { ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff ; } else ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff ; ret = ih264d_parse_islice_data_cavlc ( ps_dec , ps_slice , u2_first_mb_in_slice ) ; if ( ret != OK ) return ret ; } return OK ; }
","<S2SV_ModStart> -> u1_dpb_commands_read ) { i_temp = ih264d_read_mmco_commands ( ps_dec ) ; if ( i_temp < 0 ) { return ERROR_DBP_MANAGER_T ; } <S2SV_ModStart> -> u4_bitoffset = i_temp ; } <S2SV_ModEnd> else ps_dec ->
"
662,"CWE-20 static gboolean netscreen_read ( wtap * wth , int * err , gchar * * err_info , gint64 * data_offset ) { gint64 offset ; <S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> char line [ NETSCREEN_LINE_LENGTH ] ; <S2SV_EndBug> char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; gboolean cap_dir ; char cap_dst [ 13 ] ; offset = netscreen_seek_next_packet ( wth , err , err_info , line ) ; if ( offset < 0 ) return FALSE ; <S2SV_StartBug> pkt_len = parse_netscreen_rec_hdr ( & wth -> phdr , line , cap_int , & cap_dir , <S2SV_EndBug> cap_dst , err , err_info ) ; if ( pkt_len == - 1 ) return FALSE ; <S2SV_StartBug> if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int , <S2SV_EndBug> <S2SV_StartBug> cap_dst , & wth -> phdr , wth -> frame_buffer , err , err_info ) ) <S2SV_EndBug> return FALSE ; if ( wth -> file_encap == WTAP_ENCAP_UNKNOWN ) wth -> file_encap = wth -> phdr . pkt_encap ; else { if ( wth -> file_encap != wth -> phdr . pkt_encap ) wth -> file_encap = WTAP_ENCAP_PER_PACKET ; } * data_offset = offset ; return TRUE ; }
","<S2SV_ModStart> gint64 offset ; <S2SV_ModEnd> char line [ <S2SV_ModStart> line [ NETSCREEN_LINE_LENGTH <S2SV_ModEnd> ] ; offset <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! parse_netscreen_packet <S2SV_ModEnd> ( wth -> <S2SV_ModStart> wth -> fh <S2SV_ModEnd> , & wth <S2SV_ModStart> wth -> frame_buffer , line
"
663,"CWE-119 static int dtls1_process_buffered_records ( SSL * s ) { pitem * item ; item = pqueue_peek ( s -> d1 -> unprocessed_rcds . q ) ; if ( item ) { if ( s -> d1 -> unprocessed_rcds . epoch != s -> d1 -> r_epoch ) return ( 1 ) ; while ( pqueue_peek ( s -> d1 -> unprocessed_rcds . q ) ) { dtls1_get_unprocessed_record ( s ) ; if ( ! dtls1_process_record ( s ) ) return ( 0 ) ; <S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> processed_rcds ) , <S2SV_EndBug> <S2SV_StartBug> s -> s3 -> rrec . seq_num ) ; <S2SV_EndBug> } } s -> d1 -> processed_rcds . epoch = s -> d1 -> r_epoch ; s -> d1 -> unprocessed_rcds . epoch = s -> d1 -> r_epoch + 1 ; return ( 1 ) ; }
","<S2SV_ModStart> 0 ) ; if ( <S2SV_ModStart> . seq_num ) < 0 ) return - 1
"
664,"CWE-415 void DDGifSlurp ( GifInfo * info , bool decode , bool exitAfterFrame ) { GifRecordType RecordType ; GifByteType * ExtData ; int ExtFunction ; GifFileType * gifFilePtr ; gifFilePtr = info -> gifFilePtr ; uint_fast32_t lastAllocatedGCBIndex = 0 ; do { if ( DGifGetRecordType ( gifFilePtr , & RecordType ) == GIF_ERROR ) { break ; } bool isInitialPass = ! decode && ! exitAfterFrame ; switch ( RecordType ) { case IMAGE_DESC_RECORD_TYPE : if ( DGifGetImageDesc ( gifFilePtr , isInitialPass ) == GIF_ERROR ) { break ; } if ( isInitialPass ) { int_fast32_t widthOverflow = gifFilePtr -> Image . Width - gifFilePtr -> SWidth ; int_fast32_t heightOverflow = gifFilePtr -> Image . Height - gifFilePtr -> SHeight ; if ( widthOverflow > 0 || heightOverflow > 0 ) { gifFilePtr -> SWidth += widthOverflow ; gifFilePtr -> SHeight += heightOverflow ; } SavedImage * sp = & gifFilePtr -> SavedImages [ gifFilePtr -> ImageCount - 1 ] ; int_fast32_t topOverflow = gifFilePtr -> Image . Top + gifFilePtr -> Image . Height - gifFilePtr -> SHeight ; if ( topOverflow > 0 ) { sp -> ImageDesc . Top -= topOverflow ; } int_fast32_t leftOverflow = gifFilePtr -> Image . Left + gifFilePtr -> Image . Width - gifFilePtr -> SWidth ; if ( leftOverflow > 0 ) { sp -> ImageDesc . Left -= leftOverflow ; } if ( ! updateGCB ( info , & lastAllocatedGCBIndex ) ) { break ; } } if ( decode ) { <S2SV_StartBug> int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ; <S2SV_EndBug> int_fast32_t heightOverflow = gifFilePtr -> Image . Height - info -> originalHeight ; <S2SV_StartBug> const uint_fast32_t newRasterSize = gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ; <S2SV_EndBug> if ( newRasterSize > info -> rasterSize || widthOverflow > 0 || heightOverflow > 0 ) { void * tmpRasterBits = reallocarray ( info -> rasterBits , newRasterSize , sizeof ( GifPixelType ) ) ; if ( tmpRasterBits == NULL ) { gifFilePtr -> Error = D_GIF_ERR_NOT_ENOUGH_MEM ; break ; } info -> rasterBits = tmpRasterBits ; info -> rasterSize = newRasterSize ; } if ( gifFilePtr -> Image . Interlace ) { uint_fast16_t i , j ; uint_fast8_t InterlacedOffset [ ] = { 0 , 4 , 2 , 1 } ; uint_fast8_t InterlacedJumps [ ] = { 8 , 8 , 4 , 2 } ; for ( i = 0 ; i < 4 ; i ++ ) for ( j = InterlacedOffset [ i ] ; j < gifFilePtr -> Image . Height ; j += InterlacedJumps [ i ] ) { if ( DGifGetLine ( gifFilePtr , info -> rasterBits + j * gifFilePtr -> Image . Width , gifFilePtr -> Image . Width ) == GIF_ERROR ) break ; } } else { if ( DGifGetLine ( gifFilePtr , info -> rasterBits , gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ) == GIF_ERROR ) { break ; } } if ( info -> sampleSize > 1 ) { unsigned char * dst = info -> rasterBits ; unsigned char * src = info -> rasterBits ; unsigned char * const srcEndImage = info -> rasterBits + gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ; do { unsigned char * srcNextLineStart = src + gifFilePtr -> Image . Width * info -> sampleSize ; unsigned char * const srcEndLine = src + gifFilePtr -> Image . Width ; unsigned char * dstEndLine = dst + gifFilePtr -> Image . Width / info -> sampleSize ; do { * dst = * src ; dst ++ ; src += info -> sampleSize ; } while ( src < srcEndLine ) ; dst = dstEndLine ; src = srcNextLineStart ; } while ( src < srcEndImage ) ; } return ; } else { do { if ( DGifGetCodeNext ( gifFilePtr , & ExtData ) == GIF_ERROR ) { break ; } } while ( ExtData != NULL ) ; if ( exitAfterFrame ) { return ; } } break ; case EXTENSION_RECORD_TYPE : if ( DGifGetExtension ( gifFilePtr , & ExtFunction , & ExtData ) == GIF_ERROR ) { break ; } if ( isInitialPass ) { updateGCB ( info , & lastAllocatedGCBIndex ) ; if ( readExtensions ( ExtFunction , ExtData , info ) == GIF_ERROR ) { break ; } } while ( ExtData != NULL ) { if ( DGifGetExtensionNext ( gifFilePtr , & ExtData ) == GIF_ERROR ) { break ; } if ( isInitialPass && readExtensions ( ExtFunction , ExtData , info ) == GIF_ERROR ) { break ; } } break ; case TERMINATE_RECORD_TYPE : break ; default : break ; } } while ( RecordType != TERMINATE_RECORD_TYPE ) ; info -> rewindFunction ( info ) ; }
","<S2SV_ModStart> decode ) { <S2SV_ModEnd> const uint_fast32_t newRasterSize <S2SV_ModStart> Image . Height ; if ( newRasterSize == 0 ) { free ( info -> rasterBits ) ; info -> rasterBits = NULL ; info -> rasterSize = newRasterSize ; return ; } const int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ; const int_fast32_t heightOverflow = gifFilePtr -> Image . Height - info -> originalHeight
"
665,"CWE-362 long keyctl_read_key ( key_serial_t keyid , char __user * buffer , size_t buflen ) { struct key * key ; key_ref_t key_ref ; long ret ; key_ref = lookup_user_key ( keyid , 0 , 0 ) ; if ( IS_ERR ( key_ref ) ) { ret = - ENOKEY ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; ret = key_permission ( key_ref , KEY_NEED_READ ) ; if ( ret == 0 ) goto can_read_key ; if ( ret != - EACCES ) goto error ; if ( ! is_key_possessed ( key_ref ) ) { ret = - EACCES ; goto error2 ; } can_read_key : <S2SV_StartBug> ret = key_validate ( key ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret == 0 ) { <S2SV_EndBug> ret = - EOPNOTSUPP ; <S2SV_StartBug> if ( key -> type -> read ) { <S2SV_EndBug> down_read ( & key -> sem ) ; <S2SV_StartBug> ret = key -> type -> read ( key , buffer , buflen ) ; <S2SV_EndBug> up_read ( & key -> sem ) ; } } error2 : key_put ( key ) ; error : return ret ; }
","<S2SV_ModStart> : ret = - EOPNOTSUPP ; if ( key -> type -> read ) { down_read ( & key -> sem ) ; ret = <S2SV_ModStart> == 0 ) ret = <S2SV_ModEnd> key -> type <S2SV_ModStart> type -> read ( key , buffer , buflen ) ; up_read <S2SV_ModEnd> ( & key <S2SV_ModStart> sem ) ; <S2SV_ModEnd> } error2 :
"
666,"CWE-287 ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <S2SV_StartBug> cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <S2SV_EndBug> return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree<S2SV_blank>search<S2SV_blank>(%s):<S2SV_blank>done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access<S2SV_blank>to<S2SV_blank>use<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>been<S2SV_blank>granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
","<S2SV_ModStart> -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )
"
667,"CWE-252 static Image * ReadPICTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char geometry [ MagickPathExtent ] , header_ole [ 4 ] ; Image * image , * tile_image ; ImageInfo * read_info ; int c , code ; MagickBooleanType jpeg , status ; PICTRectangle frame ; PICTPixmap pixmap ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t extent , length ; ssize_t count , flags , j , version , y ; StringInfo * profile ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } read_info = ( ImageInfo * ) NULL ; tile_image = ( Image * ) NULL ; pixmap . bits_per_pixel = 0 ; pixmap . component_count = 0 ; header_ole [ 0 ] = ReadBlobByte ( image ) ; header_ole [ 1 ] = ReadBlobByte ( image ) ; header_ole [ 2 ] = ReadBlobByte ( image ) ; header_ole [ 3 ] = ReadBlobByte ( image ) ; if ( ! ( ( header_ole [ 0 ] == 0x50 ) && ( header_ole [ 1 ] == 0x49 ) && ( header_ole [ 2 ] == 0x43 ) && ( header_ole [ 3 ] == 0x54 ) ) ) for ( i = 0 ; i < 508 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; while ( ( c = ReadBlobByte ( image ) ) == 0 ) ; if ( c != 0x11 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; version = ( ssize_t ) ReadBlobByte ( image ) ; if ( version == 2 ) { c = ReadBlobByte ( image ) ; if ( c != 0xff ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; } else if ( version != 1 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( frame . left < 0 ) || ( frame . right < 0 ) || ( frame . top < 0 ) || ( frame . bottom < 0 ) || ( frame . left >= frame . right ) || ( frame . top >= frame . bottom ) ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; flags = 0 ; image -> depth = 8 ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; image -> resolution . x = DefaultResolution ; image -> resolution . y = DefaultResolution ; image -> units = UndefinedResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; jpeg = MagickFalse ; for ( code = 0 ; EOFBlob ( image ) == MagickFalse ; ) { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( ( version == 1 ) || ( ( TellBlob ( image ) % 2 ) != 0 ) ) code = ReadBlobByte ( image ) ; if ( version == 2 ) code = ReadBlobMSBSignedShort ( image ) ; if ( code < 0 ) break ; if ( code == 0 ) continue ; if ( code > 0xa1 ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""%04X:"" , code ) ; } else { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>%04X<S2SV_blank>%s:<S2SV_blank>%s"" , code , codes [ code ] . name , codes [ code ] . description ) ; switch ( code ) { case 0x01 : { length = ReadBlobMSBShort ( image ) ; if ( length != 0x000a ) { for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( ( frame . left & 0x8000 ) != 0 ) || ( ( frame . top & 0x8000 ) != 0 ) ) break ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; break ; } case 0x12 : case 0x13 : case 0x14 : { ssize_t pattern ; size_t height , width ; pattern = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < 8 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; if ( pattern == 2 ) { for ( i = 0 ; i < 5 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( pattern != 1 ) ThrowPICTException ( CorruptImageError , ""UnknownPatternType"" ) ; length = ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> depth = ( size_t ) pixmap . component_size ; image -> resolution . x = 1.0 * pixmap . horizontal_resolution ; image -> resolution . y = 1.0 * pixmap . vertical_resolution ; image -> units = PixelsPerInchResolution ; ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i <= ( ssize_t ) length ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; width = ( size_t ) ( frame . bottom - frame . top ) ; height = ( size_t ) ( frame . right - frame . left ) ; if ( pixmap . bits_per_pixel <= 8 ) length &= 0x7fff ; if ( pixmap . bits_per_pixel == 16 ) width <<= 1 ; if ( length == 0 ) length = width ; if ( length < 8 ) { for ( i = 0 ; i < ( ssize_t ) ( length * height ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( i = 0 ; i < ( ssize_t ) height ; i ++ ) { if ( EOFBlob ( image ) != MagickFalse ) break ; if ( length > 200 ) { for ( j = 0 ; j < ( ssize_t ) ReadBlobMSBShort ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( j = 0 ; j < ( ssize_t ) ReadBlobByte ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } break ; } case 0x1b : { image -> background_color . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; break ; } case 0x70 : case 0x71 : case 0x72 : case 0x73 : case 0x74 : case 0x75 : case 0x76 : case 0x77 : { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } case 0x90 : case 0x91 : case 0x98 : case 0x99 : case 0x9a : case 0x9b : { PICTRectangle source , destination ; register unsigned char * p ; size_t j ; ssize_t bytes_per_line ; unsigned char * pixels ; bytes_per_line = 0 ; if ( ( code != 0x9a ) && ( code != 0x9b ) ) bytes_per_line = ( ssize_t ) ReadBlobMSBShort ( image ) ; else { ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; tile_image = CloneImage ( image , ( size_t ) ( frame . right - frame . left ) , ( size_t ) ( frame . bottom - frame . top ) , MagickTrue , exception ) ; if ( tile_image == ( Image * ) NULL ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) { if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; tile_image -> depth = ( size_t ) pixmap . component_size ; tile_image -> alpha_trait = pixmap . component_count == 4 ? BlendPixelTrait : UndefinedPixelTrait ; tile_image -> resolution . x = ( double ) pixmap . horizontal_resolution ; tile_image -> resolution . y = ( double ) pixmap . vertical_resolution ; tile_image -> units = PixelsPerInchResolution ; if ( tile_image -> alpha_trait != UndefinedPixelTrait ) ( void ) SetImageAlpha ( tile_image , OpaqueAlpha , exception ) ; } if ( ( code != 0x9a ) && ( code != 0x9b ) ) { tile_image -> colors = 2 ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; tile_image -> colors = 1UL * ReadBlobMSBShort ( image ) + 1 ; } status = AcquireImageColormap ( tile_image , tile_image -> colors , exception ) ; if ( status == MagickFalse ) ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { j = ReadBlobMSBShort ( image ) % tile_image -> colors ; if ( ( flags & 0x8000 ) != 0 ) j = ( size_t ) i ; tile_image -> colormap [ j ] . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; } } else { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { tile_image -> colormap [ i ] . red = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . red ) ; tile_image -> colormap [ i ] . green = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . green ) ; tile_image -> colormap [ i ] . blue = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . blue ) ; } } } if ( EOFBlob ( image ) != MagickFalse ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ReadRectangle ( image , & source ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ReadRectangle ( image , & destination ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; ( void ) ReadBlobMSBShort ( image ) ; if ( ( code == 0x91 ) || ( code == 0x99 ) || ( code == 0x9b ) ) { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } if ( ( code != 0x9a ) && ( code != 0x9b ) && ( bytes_per_line & 0x8000 ) == 0 ) pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , 1 , & extent ) ; else pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , ( unsigned int ) pixmap . bits_per_pixel , & extent ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowPICTException ( CorruptImageError , ""UnableToUncompressImage"" ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) { if ( p > ( pixels + extent + image -> columns ) ) { pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; } q = QueueAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { if ( tile_image -> storage_class == PseudoClass ) { index = ( Quantum ) ConstrainColormapIndex ( tile_image , ( ssize_t ) * p , exception ) ; SetPixelIndex ( tile_image , index , q ) ; SetPixelRed ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . red , q ) ; SetPixelGreen ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . green , q ) ; SetPixelBlue ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . blue , q ) ; } else { if ( pixmap . bits_per_pixel == 16 ) { i = ( ssize_t ) ( * p ++ ) ; j = ( size_t ) ( * p ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( i & 0x7c ) << 1 ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( ( i & 0x03 ) << 6 ) | ( ( j & 0xe0 ) >> 2 ) ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( j & 0x1f ) << 3 ) ) , q ) ; } else if ( tile_image -> alpha_trait == UndefinedPixelTrait ) { if ( p > ( pixels + extent + 2 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; } else { if ( p > ( pixels + extent + 3 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; SetPixelAlpha ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 3 * tile_image -> columns ) ) , q ) ; } } p ++ ; q += GetPixelChannels ( tile_image ) ; } if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ; if ( ( tile_image -> storage_class == DirectClass ) && ( pixmap . bits_per_pixel != 16 ) ) { p += ( pixmap . component_count - 1 ) * tile_image -> columns ; if ( p < pixels ) break ; } status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , tile_image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( ( jpeg == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) destination . left , ( ssize_t ) destination . top , exception ) ; tile_image = DestroyImage ( tile_image ) ; break ; } case 0xa1 : { unsigned char * info ; size_t type ; type = ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; if ( length == 0 ) break ; ( void ) ReadBlobMSBLong ( image ) ; length -= MagickMin ( length , 4 ) ; if ( length == 0 ) break ; info = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) break ; count = ReadBlob ( image , length , info ) ; if ( count != ( ssize_t ) length ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""UnableToReadImageData"" ) ; } switch ( type ) { case 0xe0 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , ""icc"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case 0x1f2 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , ""iptc"" , profile , exception ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } profile = DestroyStringInfo ( profile ) ; break ; } default : break ; } info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; break ; } default : { if ( codes [ code ] . length == - 1 ) ( void ) ReadBlobMSBShort ( image ) ; else for ( i = 0 ; i < ( ssize_t ) codes [ code ] . length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } } } if ( code == 0xc00 ) { for ( i = 0 ; i < 24 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( ( code >= 0xb0 ) && ( code <= 0xcf ) ) || ( ( code >= 0x8000 ) && ( code <= 0x80ff ) ) ) continue ; if ( code == 0x8200 ) { char filename [ MaxTextExtent ] ; FILE * file ; int unique_file ; jpeg = MagickTrue ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""jpeg:%s"" , filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ( void ) CopyMagickString ( image -> filename , read_info -> filename , MagickPathExtent ) ; ThrowPICTException ( FileOpenError , ""UnableToCreateTemporaryFile"" ) ; } length = ReadBlobMSBLong ( image ) ; if ( length > 154 ) { for ( i = 0 ; i < 6 ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) { ( void ) fclose ( file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; } for ( i = 0 ; i < 122 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; for ( i = 0 ; i < ( ssize_t ) ( length - 154 ) ; i ++ ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> } } ( void ) fclose ( file ) ; ( void ) close ( unique_file ) ; tile_image = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( tile_image == ( Image * ) NULL ) continue ; ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%.20gx%.20g"" , ( double ) MagickMax ( image -> columns , tile_image -> columns ) , ( double ) MagickMax ( image -> rows , tile_image -> rows ) ) ; ( void ) SetImageExtent ( image , MagickMax ( image -> columns , tile_image -> columns ) , MagickMax ( image -> rows , tile_image -> rows ) , exception ) ; ( void ) TransformImageColorspace ( image , tile_image -> colorspace , exception ) ; ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) frame . left , ( ssize_t ) frame . right , exception ) ; image -> compression = tile_image -> compression ; tile_image = DestroyImage ( tile_image ) ; continue ; } if ( ( code == 0xff ) || ( code == 0xffff ) ) break ; if ( ( ( code >= 0xd0 ) && ( code <= 0xfe ) ) || ( ( code >= 0x8100 ) && ( code <= 0xffff ) ) ) { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( code >= 0x100 ) && ( code <= 0x7fff ) ) { length = ( size_t ) ( ( code >> 7 ) & 0xff ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( tile_image <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char geometry [ <S2SV_ModStart> ) break ; if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break
"
668,"CWE-190 static int jas_iccgetsint32 ( jas_stream_t * in , jas_iccsint32_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ; <S2SV_StartBug> * val = ( tmp & 0x80000000 ) ? ( - JAS_CAST ( longlong , ( ( ( ~ tmp ) & <S2SV_EndBug> <S2SV_StartBug> 0x7fffffff ) + 1 ) ) ) : JAS_CAST ( longlong , tmp ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if <S2SV_ModStart> - JAS_CAST ( jas_longlong <S2SV_ModEnd> , ( ( <S2SV_ModStart> : JAS_CAST ( jas_longlong <S2SV_ModEnd> , tmp )
"
669,"CWE-476 int rds_cmsg_atomic ( struct rds_sock * rs , struct rds_message * rm , struct cmsghdr * cmsg ) { struct page * page = NULL ; struct rds_atomic_args * args ; int ret = 0 ; if ( cmsg -> cmsg_len < CMSG_LEN ( sizeof ( struct rds_atomic_args ) ) || rm -> atomic . op_active ) return - EINVAL ; args = CMSG_DATA ( cmsg ) ; switch ( cmsg -> cmsg_type ) { case RDS_CMSG_ATOMIC_FADD : rm -> atomic . op_type = RDS_ATOMIC_TYPE_FADD ; rm -> atomic . op_m_fadd . add = args -> fadd . add ; rm -> atomic . op_m_fadd . nocarry_mask = 0 ; break ; case RDS_CMSG_MASKED_ATOMIC_FADD : rm -> atomic . op_type = RDS_ATOMIC_TYPE_FADD ; rm -> atomic . op_m_fadd . add = args -> m_fadd . add ; rm -> atomic . op_m_fadd . nocarry_mask = args -> m_fadd . nocarry_mask ; break ; case RDS_CMSG_ATOMIC_CSWP : rm -> atomic . op_type = RDS_ATOMIC_TYPE_CSWP ; rm -> atomic . op_m_cswp . compare = args -> cswp . compare ; rm -> atomic . op_m_cswp . swap = args -> cswp . swap ; rm -> atomic . op_m_cswp . compare_mask = ~ 0 ; rm -> atomic . op_m_cswp . swap_mask = ~ 0 ; break ; case RDS_CMSG_MASKED_ATOMIC_CSWP : rm -> atomic . op_type = RDS_ATOMIC_TYPE_CSWP ; rm -> atomic . op_m_cswp . compare = args -> m_cswp . compare ; rm -> atomic . op_m_cswp . swap = args -> m_cswp . swap ; rm -> atomic . op_m_cswp . compare_mask = args -> m_cswp . compare_mask ; rm -> atomic . op_m_cswp . swap_mask = args -> m_cswp . swap_mask ; break ; default : BUG ( ) ; } rm -> atomic . op_notify = ! ! ( args -> flags & RDS_RDMA_NOTIFY_ME ) ; rm -> atomic . op_silent = ! ! ( args -> flags & RDS_RDMA_SILENT ) ; rm -> atomic . op_active = 1 ; rm -> atomic . op_recverr = rs -> rs_recverr ; rm -> atomic . op_sg = rds_message_alloc_sgs ( rm , 1 ) ; if ( ! rm -> atomic . op_sg ) { ret = - ENOMEM ; goto err ; } if ( args -> local_addr & 0x7 ) { ret = - EFAULT ; goto err ; } ret = rds_pin_pages ( args -> local_addr , 1 , & page , 1 ) ; if ( ret != 1 ) goto err ; ret = 0 ; sg_set_page ( rm -> atomic . op_sg , page , 8 , offset_in_page ( args -> local_addr ) ) ; if ( rm -> atomic . op_notify || rm -> atomic . op_recverr ) { rm -> atomic . op_notifier = kmalloc ( sizeof ( * rm -> atomic . op_notifier ) , GFP_KERNEL ) ; if ( ! rm -> atomic . op_notifier ) { ret = - ENOMEM ; goto err ; } rm -> atomic . op_notifier -> n_user_token = args -> user_token ; rm -> atomic . op_notifier -> n_status = RDS_RDMA_SUCCESS ; } rm -> atomic . op_rkey = rds_rdma_cookie_key ( args -> cookie ) ; rm -> atomic . op_remote_addr = args -> remote_addr + rds_rdma_cookie_offset ( args -> cookie ) ; return ret ; err : if ( page ) put_page ( page ) ; <S2SV_StartBug> kfree ( rm -> atomic . op_notifier ) ; <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> page ) ; rm -> atomic . op_active = 0 ;
"
670,"CWE-617 void pci_lintr_release ( struct pci_vdev * dev ) { struct businfo * bi ; struct slotinfo * si ; int pin ; bi = pci_businfo [ dev -> bus ] ; <S2SV_StartBug> assert ( bi != NULL ) ; <S2SV_EndBug> si = & bi -> slotinfo [ dev -> slot ] ; for ( pin = 1 ; pin < 4 ; pin ++ ) { si -> si_intpins [ pin ] . ii_count = 0 ; si -> si_intpins [ pin ] . ii_pirq_pin = 0 ; si -> si_intpins [ pin ] . ii_ioapic_irq = 0 ; } }
","<S2SV_ModStart> bus ] ; if ( bi == NULL ) { pr_err ( ""%s:<S2SV_blank>pci<S2SV_blank>[%s]<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>bus<S2SV_blank>%d<S2SV_blank>info!\\n"" , __func__ , dev -> name , dev -> bus ) ; return ; } <S2SV_ModEnd> si = &
"
671,"CWE-20 int rds_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int msg_flags ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; long timeo ; int ret = 0 , nonblock = msg_flags & MSG_DONTWAIT ; struct sockaddr_in * sin ; struct rds_incoming * inc = NULL ; timeo = sock_rcvtimeo ( sk , nonblock ) ; <S2SV_StartBug> rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , size , msg_flags , timeo ) ; <S2SV_EndBug> msg -> msg_namelen = 0 ; if ( msg_flags & MSG_OOB ) goto out ; while ( 1 ) { if ( ! list_empty ( & rs -> rs_notify_queue ) ) { ret = rds_notify_queue_get ( rs , msg ) ; break ; } if ( rs -> rs_cong_notify ) { ret = rds_notify_cong ( rs , msg ) ; break ; } if ( ! rds_next_incoming ( rs , & inc ) ) { if ( nonblock ) { ret = - EAGAIN ; break ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , ( ! list_empty ( & rs -> rs_notify_queue ) || rs -> rs_cong_notify || rds_next_incoming ( rs , & inc ) ) , timeo ) ; rdsdebug ( ""recvmsg<S2SV_blank>woke<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , inc , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; break ; } rdsdebug ( ""copying<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>from<S2SV_blank>%pI4:%u<S2SV_blank>to<S2SV_blank>user\\n"" , inc , & inc -> i_conn -> c_faddr , ntohs ( inc -> i_hdr . h_sport ) ) ; ret = inc -> i_conn -> c_trans -> inc_copy_to_user ( inc , msg -> msg_iov , size ) ; if ( ret < 0 ) break ; if ( ! rds_still_queued ( rs , inc , ! ( msg_flags & MSG_PEEK ) ) ) { rds_inc_put ( inc ) ; inc = NULL ; rds_stats_inc ( s_recv_deliver_raced ) ; continue ; } if ( ret < be32_to_cpu ( inc -> i_hdr . h_len ) ) { if ( msg_flags & MSG_TRUNC ) ret = be32_to_cpu ( inc -> i_hdr . h_len ) ; msg -> msg_flags |= MSG_TRUNC ; } if ( rds_cmsg_recv ( inc , msg ) ) { ret = - EFAULT ; goto out ; } rds_stats_inc ( s_recv_delivered ) ; sin = ( struct sockaddr_in * ) msg -> msg_name ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = inc -> i_hdr . h_sport ; sin -> sin_addr . s_addr = inc -> i_saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; msg -> msg_namelen = sizeof ( * sin ) ; } break ; } if ( inc ) rds_inc_put ( inc ) ; out : return ret ; }
","<S2SV_ModStart> , timeo ) <S2SV_ModEnd> ; if (
"
672,"CWE-22 int set_interface_var ( const char * iface , const char * var , const char * name , uint32_t val ) { FILE * fp ; char spath [ 64 + IFNAMSIZ ] ; <S2SV_StartBug> if ( snprintf ( spath , sizeof ( spath ) , var , iface ) >= sizeof ( spath ) ) <S2SV_EndBug> return - 1 ; if ( access ( spath , F_OK ) != 0 ) return - 1 ; fp = fopen ( spath , ""w"" ) ; if ( ! fp ) { if ( name ) flog ( LOG_ERR , ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , name , val , iface , strerror ( errno ) ) ; return - 1 ; } fprintf ( fp , ""%u"" , val ) ; fclose ( fp ) ; return 0 ; }
","<S2SV_ModStart> sizeof ( spath ) ) return - 1 ; if ( strstr ( name , "".."" ) || strchr ( name , '/'
"
673,"CWE-119 static void t1mac_output_ascii ( char * s , int len ) { if ( blocktyp == POST_BINARY ) { output_current_post ( ) ; blocktyp = POST_ASCII ; } if ( len > 0 && s [ len - 1 ] == '\\n' ) s [ len - 1 ] = '\\r' ; t1mac_output_data ( ( byte * ) s , len ) ; if ( strncmp ( s , ""/FontName"" , 9 ) == 0 ) { <S2SV_StartBug> for ( s += 9 ; isspace ( * s ) ; s ++ ) ; <S2SV_EndBug> if ( * s == '/' ) { const char * t = ++ s ; <S2SV_StartBug> while ( * t && ! isspace ( * t ) ) t ++ ; <S2SV_EndBug> free ( font_name ) ; font_name = ( char * ) malloc ( t - s + 1 ) ; memcpy ( font_name , s , t - s ) ; font_name [ t - s ] = 0 ; } } }
","<S2SV_ModStart> ; isspace ( ( unsigned char ) <S2SV_ModStart> ! isspace ( ( unsigned char )
"
674,"CWE-22 static int pop_sync_mailbox ( struct Context * ctx , int * index_hint ) { int i , j , ret = 0 ; char buf [ LONG_STRING ] ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct Progress progress ; # ifdef USE_HCACHE header_cache_t * hc = NULL ; # endif pop_data -> check_time = 0 ; while ( true ) { if ( pop_reconnect ( ctx ) < 0 ) return - 1 ; mutt_progress_init ( & progress , _ ( ""Marking<S2SV_blank>messages<S2SV_blank>deleted..."" ) , MUTT_PROGRESS_MSG , WriteInc , ctx -> deleted ) ; # ifdef USE_HCACHE hc = pop_hcache_open ( pop_data , ctx -> path ) ; # endif for ( i = 0 , j = 0 , ret = 0 ; ret == 0 && i < ctx -> msgcount ; i ++ ) { if ( ctx -> hdrs [ i ] -> deleted && ctx -> hdrs [ i ] -> refno != - 1 ) { j ++ ; if ( ! ctx -> quiet ) mutt_progress_update ( & progress , j , - 1 ) ; snprintf ( buf , sizeof ( buf ) , ""DELE<S2SV_blank>%d\\r\\n"" , ctx -> hdrs [ i ] -> refno ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; if ( ret == 0 ) { <S2SV_StartBug> mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <S2SV_EndBug> # ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; # endif } } # ifdef USE_HCACHE if ( ctx -> hdrs [ i ] -> changed ) { mutt_hcache_store ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) , ctx -> hdrs [ i ] , 0 ) ; } # endif } # ifdef USE_HCACHE mutt_hcache_close ( hc ) ; # endif if ( ret == 0 ) { mutt_str_strfcpy ( buf , ""QUIT\\r\\n"" , sizeof ( buf ) ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; } if ( ret == 0 ) { pop_data -> clear_cache = true ; pop_clear_cache ( pop_data ) ; pop_data -> status = POP_DISCONNECTED ; return 0 ; } if ( ret == - 2 ) { mutt_error ( ""%s"" , pop_data -> err_msg ) ; return - 1 ; } } }
","<S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> ] -> data )
"
675,"CWE-000 bool_t xdr_krb5_principal ( XDR * xdrs , krb5_principal * objp ) { int ret ; char * p = NULL ; krb5_principal pr = NULL ; static krb5_context context = NULL ; if ( ! context && kadm5_init_krb5_context ( & context ) ) return ( FALSE ) ; switch ( xdrs -> x_op ) { case XDR_ENCODE : if ( * objp ) { if ( ( ret = krb5_unparse_name ( context , * objp , & p ) ) != 0 ) return FALSE ; } if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) free ( p ) ; break ; case XDR_DECODE : if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) { ret = krb5_parse_name ( context , p , & pr ) ; if ( ret != 0 ) return FALSE ; * objp = pr ; free ( p ) ; } else * objp = NULL ; break ; case XDR_FREE : if ( * objp != NULL ) krb5_free_principal ( context , * objp ) ; <S2SV_StartBug> break ; <S2SV_EndBug> } return TRUE ; }
","<S2SV_ModStart> objp ) ; * objp = NULL ;
"
676,"CWE-284 static void uipc_read_task ( void * arg ) { int ch_id ; int result ; UNUSED ( arg ) ; prctl ( PR_SET_NAME , ( unsigned long ) ""uipc-main"" , 0 , 0 , 0 ) ; raise_priority_a2dp ( TASK_UIPC_READ ) ; while ( uipc_main . running ) { uipc_main . read_set = uipc_main . active_set ; <S2SV_StartBug> result = select ( uipc_main . max_fd + 1 , & uipc_main . read_set , NULL , NULL , NULL ) ; <S2SV_EndBug> if ( result == 0 ) { BTIF_TRACE_EVENT ( ""select<S2SV_blank>timeout"" ) ; continue ; } else if ( result < 0 ) { BTIF_TRACE_EVENT ( ""select<S2SV_blank>failed<S2SV_blank>%s"" , strerror ( errno ) ) ; continue ; } UIPC_LOCK ( ) ; uipc_check_interrupt_locked ( ) ; uipc_check_task_flags_locked ( ) ; uipc_check_fd_locked ( UIPC_CH_ID_AV_AUDIO ) ; for ( ch_id = 0 ; ch_id < UIPC_CH_NUM ; ch_id ++ ) { if ( ch_id != UIPC_CH_ID_AV_AUDIO ) uipc_check_fd_locked ( ch_id ) ; } UIPC_UNLOCK ( ) ; } BTIF_TRACE_EVENT ( ""UIPC<S2SV_blank>READ<S2SV_blank>THREAD<S2SV_blank>EXITING"" ) ; uipc_main_cleanup ( ) ; uipc_main . tid = 0 ; BTIF_TRACE_EVENT ( ""UIPC<S2SV_blank>READ<S2SV_blank>THREAD<S2SV_blank>DONE"" ) ; }
","<S2SV_ModStart> ; result = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , NULL ) )
"
677,"CWE-415 int dccp_rcv_state_process ( struct sock * sk , struct sk_buff * skb , struct dccp_hdr * dh , unsigned int len ) { struct dccp_sock * dp = dccp_sk ( sk ) ; struct dccp_skb_cb * dcb = DCCP_SKB_CB ( skb ) ; const int old_state = sk -> sk_state ; int queued = 0 ; if ( sk -> sk_state == DCCP_LISTEN ) { if ( dh -> dccph_type == DCCP_PKT_REQUEST ) { if ( inet_csk ( sk ) -> icsk_af_ops -> conn_request ( sk , skb ) < 0 ) return 1 ; <S2SV_StartBug> goto discard ; <S2SV_EndBug> } if ( dh -> dccph_type == DCCP_PKT_RESET ) goto discard ; dcb -> dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION ; return 1 ; } else if ( sk -> sk_state == DCCP_CLOSED ) { dcb -> dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION ; return 1 ; } if ( sk -> sk_state != DCCP_REQUESTING && dccp_check_seqno ( sk , skb ) ) goto discard ; if ( ( dp -> dccps_role != DCCP_ROLE_CLIENT && dh -> dccph_type == DCCP_PKT_RESPONSE ) || ( dp -> dccps_role == DCCP_ROLE_CLIENT && dh -> dccph_type == DCCP_PKT_REQUEST ) || ( sk -> sk_state == DCCP_RESPOND && dh -> dccph_type == DCCP_PKT_DATA ) ) { dccp_send_sync ( sk , dcb -> dccpd_seq , DCCP_PKT_SYNC ) ; goto discard ; } if ( dccp_parse_options ( sk , NULL , skb ) ) return 1 ; if ( dh -> dccph_type == DCCP_PKT_RESET ) { dccp_rcv_reset ( sk , skb ) ; return 0 ; } else if ( dh -> dccph_type == DCCP_PKT_CLOSEREQ ) { if ( dccp_rcv_closereq ( sk , skb ) ) return 0 ; goto discard ; } else if ( dh -> dccph_type == DCCP_PKT_CLOSE ) { if ( dccp_rcv_close ( sk , skb ) ) return 0 ; goto discard ; } switch ( sk -> sk_state ) { case DCCP_REQUESTING : queued = dccp_rcv_request_sent_state_process ( sk , skb , dh , len ) ; if ( queued >= 0 ) return queued ; __kfree_skb ( skb ) ; return 0 ; case DCCP_PARTOPEN : dccp_handle_ackvec_processing ( sk , skb ) ; dccp_deliver_input_to_ccids ( sk , skb ) ; case DCCP_RESPOND : queued = dccp_rcv_respond_partopen_state_process ( sk , skb , dh , len ) ; break ; } if ( dh -> dccph_type == DCCP_PKT_ACK || dh -> dccph_type == DCCP_PKT_DATAACK ) { switch ( old_state ) { case DCCP_PARTOPEN : sk -> sk_state_change ( sk ) ; sk_wake_async ( sk , SOCK_WAKE_IO , POLL_OUT ) ; break ; } } else if ( unlikely ( dh -> dccph_type == DCCP_PKT_SYNC ) ) { dccp_send_sync ( sk , dcb -> dccpd_seq , DCCP_PKT_SYNCACK ) ; goto discard ; } if ( ! queued ) { discard : __kfree_skb ( skb ) ; } return 0 ; }
","<S2SV_ModStart> return 1 ; consume_skb ( skb ) ; return 0 <S2SV_ModEnd> ; } if
"
678,"CWE-617 int pci_emul_add_msixcap ( struct pci_vdev * dev , int msgnum , int barnum ) { uint32_t tab_size ; struct msixcap msixcap ; <S2SV_StartBug> assert ( msgnum >= 1 && msgnum <= MAX_MSIX_TABLE_ENTRIES ) ; <S2SV_EndBug> assert ( barnum >= 0 && barnum <= PCIR_MAX_BAR_0 ) ; tab_size = msgnum * MSIX_TABLE_ENTRY_SIZE ; tab_size = roundup2 ( tab_size , 4096 ) ; dev -> msix . table_bar = barnum ; dev -> msix . pba_bar = barnum ; dev -> msix . table_offset = 0 ; dev -> msix . table_count = msgnum ; dev -> msix . pba_offset = tab_size ; dev -> msix . pba_size = PBA_SIZE ( msgnum ) ; <S2SV_StartBug> pci_msix_table_init ( dev , msgnum ) ; <S2SV_EndBug> pci_populate_msixcap ( & msixcap , msgnum , barnum , tab_size ) ; pci_emul_alloc_bar ( dev , barnum , PCIBAR_MEM32 , tab_size + dev -> msix . pba_size ) ; return ( pci_emul_add_capability ( dev , ( u_char * ) & msixcap , sizeof ( msixcap ) ) ) ; }
","<S2SV_ModStart> msixcap msixcap ; if ( msgnum > MAX_MSIX_TABLE_ENTRIES ) { pr_err ( ""%s:<S2SV_blank>Too<S2SV_blank>many<S2SV_blank>entries!\\n"" , __func__ ) ; return - 1 ; } <S2SV_ModEnd> tab_size = msgnum <S2SV_ModStart> msgnum ) ; if ( <S2SV_ModStart> , msgnum ) != 0 ) return - 1
"
679,"CWE-264 int ovl_setattr ( struct dentry * dentry , struct iattr * attr ) { int err ; struct dentry * upperdentry ; err = ovl_want_write ( dentry ) ; if ( err ) goto out ; <S2SV_StartBug> upperdentry = ovl_dentry_upper ( dentry ) ; <S2SV_EndBug> <S2SV_StartBug> if ( upperdentry ) { <S2SV_EndBug> mutex_lock ( & upperdentry -> d_inode -> i_mutex ) ; err = notify_change ( upperdentry , attr , NULL ) ; mutex_unlock ( & upperdentry -> d_inode -> i_mutex ) ; <S2SV_StartBug> } else { <S2SV_EndBug> err = ovl_copy_up_last ( dentry , attr , false ) ; } ovl_drop_write ( dentry ) ; out : return err ; }
","<S2SV_ModStart> goto out ; err = ovl_copy_up ( dentry ) ; if ( ! err ) { <S2SV_ModStart> dentry ) ; <S2SV_ModEnd> mutex_lock ( & <S2SV_ModStart> ) ; } <S2SV_ModEnd> ovl_drop_write ( dentry
"
680,"CWE-119 static int check_line_charstring ( void ) { char * p = line ; <S2SV_StartBug> while ( isspace ( * p ) ) <S2SV_EndBug> p ++ ; return ( * p == '/' || ( p [ 0 ] == 'd' && p [ 1 ] == 'u' && p [ 2 ] == 'p' ) ) ; }
","<S2SV_ModStart> ( isspace ( ( unsigned char )
"
681,"CWE-200 static int userauth_hostbased ( struct ssh * ssh ) { Authctxt * authctxt = ssh -> authctxt ; struct sshbuf * b ; struct sshkey * key = NULL ; char * pkalg , * cuser , * chost ; u_char * pkblob , * sig ; size_t alen , blen , slen ; int r , pktype , authenticated = 0 ; <S2SV_StartBug> if ( ! authctxt -> valid ) { <S2SV_EndBug> debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; return 0 ; } if ( ( r = sshpkt_get_cstring ( ssh , & pkalg , & alen ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & chost , NULL ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & cuser , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 ) fatal ( ""%s:<S2SV_blank>packet<S2SV_blank>parsing:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; debug ( ""%s:<S2SV_blank>cuser<S2SV_blank>%s<S2SV_blank>chost<S2SV_blank>%s<S2SV_blank>pkalg<S2SV_blank>%s<S2SV_blank>slen<S2SV_blank>%zu"" , __func__ , cuser , chost , pkalg , slen ) ; # ifdef DEBUG_PK debug ( ""signature:"" ) ; sshbuf_dump_data ( sig , siglen , stderr ) ; # endif pktype = sshkey_type_from_name ( pkalg ) ; if ( pktype == KEY_UNSPEC ) { logit ( ""%s:<S2SV_blank>unsupported<S2SV_blank>public<S2SV_blank>key<S2SV_blank>algorithm:<S2SV_blank>%s"" , __func__ , pkalg ) ; goto done ; } if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) { error ( ""%s:<S2SV_blank>key_from_blob:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; goto done ; } if ( key == NULL ) { error ( ""%s:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>key:<S2SV_blank>%s"" , __func__ , pkalg ) ; goto done ; } if ( key -> type != pktype ) { error ( ""%s:<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>decoded<S2SV_blank>key<S2SV_blank>"" ""(received<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%d)"" , __func__ , key -> type , pktype ) ; goto done ; } if ( sshkey_type_plain ( key -> type ) == KEY_RSA && ( ssh -> compat & SSH_BUG_RSASIGMD5 ) != 0 ) { error ( ""Refusing<S2SV_blank>RSA<S2SV_blank>key<S2SV_blank>because<S2SV_blank>peer<S2SV_blank>uses<S2SV_blank>unsafe<S2SV_blank>"" ""signature<S2SV_blank>format"" ) ; goto done ; } if ( match_pattern_list ( pkalg , options . hostbased_key_types , 0 ) != 1 ) { logit ( ""%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>in<S2SV_blank>HostbasedAcceptedKeyTypes"" , __func__ , sshkey_type ( key ) ) ; goto done ; } <S2SV_StartBug> if ( ( b = sshbuf_new ( ) ) == NULL ) <S2SV_EndBug> fatal ( ""%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed"" , __func__ ) ; if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 || ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> user ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , ""hostbased"" ) ) != 0 || ( r = sshbuf_put_string ( b , pkalg , alen ) ) != 0 || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 || ( r = sshbuf_put_cstring ( b , chost ) ) != 0 || ( r = sshbuf_put_cstring ( b , cuser ) ) != 0 ) fatal ( ""%s:<S2SV_blank>buffer<S2SV_blank>error:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; # ifdef DEBUG_PK sshbuf_dump ( b , stderr ) ; # endif auth2_record_info ( authctxt , ""client<S2SV_blank>user<S2SV_blank>\\""%.100s\\"",<S2SV_blank>client<S2SV_blank>host<S2SV_blank>\\""%.100s\\"""" , cuser , chost ) ; authenticated = 0 ; if ( PRIVSEP ( hostbased_key_allowed ( authctxt -> pw , cuser , chost , key ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , pkalg , ssh -> compat ) ) == 0 ) authenticated = 1 ; auth2_record_key ( authctxt , authenticated , key ) ; sshbuf_free ( b ) ; done : debug2 ( ""%s:<S2SV_blank>authenticated<S2SV_blank>%d"" , __func__ , authenticated ) ; sshkey_free ( key ) ; free ( pkalg ) ; free ( pkblob ) ; free ( cuser ) ; free ( chost ) ; free ( sig ) ; return authenticated ; }
","<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> } if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; goto done ; } if (
"
682,"CWE-119 <S2SV_StartBug> static int decode_unsigned_max ( struct vp9_read_bit_buffer * rb , int max ) { <S2SV_EndBug> <S2SV_StartBug> const int data = vp9_rb_read_literal ( rb , get_unsigned_bits ( max ) ) ; <S2SV_EndBug> return data > max ? max : data ; }
","<S2SV_ModStart> decode_unsigned_max ( struct vpx_read_bit_buffer <S2SV_ModEnd> * rb , <S2SV_ModStart> int data = vpx_rb_read_literal <S2SV_ModEnd> ( rb ,
"
683,"CWE-824 static int fetch_uidl ( char * line , void * data ) { int i , index ; struct Context * ctx = ( struct Context * ) data ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; char * endp = NULL ; errno = 0 ; index = strtol ( line , & endp , 10 ) ; if ( errno ) return - 1 ; while ( * endp == '<S2SV_blank>' ) endp ++ ; memmove ( line , endp , strlen ( endp ) + 1 ) ; <S2SV_StartBug> for ( i = 0 ; i < ctx -> msgcount ; i ++ ) <S2SV_EndBug> if ( mutt_str_strcmp ( line , ctx -> hdrs [ i ] -> data ) == 0 ) break ; if ( i == ctx -> msgcount ) { mutt_debug ( 1 , ""new<S2SV_blank>header<S2SV_blank>%d<S2SV_blank>%s\\n"" , index , line ) ; if ( i >= ctx -> hdrmax ) mx_alloc_memory ( ctx ) ; ctx -> msgcount ++ ; ctx -> hdrs [ i ] = mutt_header_new ( ) ; ctx -> hdrs [ i ] -> data = mutt_str_strdup ( line ) ; } else if ( ctx -> hdrs [ i ] -> index != index - 1 ) pop_data -> clear_cache = true ; ctx -> hdrs [ i ] -> refno = index ; ctx -> hdrs [ i ] -> index = index - 1 ; return 0 ; }
","<S2SV_ModStart> 1 ) ; if ( strlen ( line ) == 0 ) return - 1 ;
"
684,"CWE-000 krb5_error_code pkinit_check_kdc_pkid ( krb5_context context , pkinit_plg_crypto_context plg_cryptoctx , pkinit_req_crypto_context req_cryptoctx , pkinit_identity_crypto_context id_cryptoctx , unsigned char * pdid_buf , unsigned int pkid_len , int * valid_kdcPkId ) { krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED ; PKCS7_ISSUER_AND_SERIAL * is = NULL ; const unsigned char * p = pdid_buf ; int status = 1 ; X509 * kdc_cert = sk_X509_value ( id_cryptoctx -> my_certs , id_cryptoctx -> cert_index ) ; * valid_kdcPkId = 0 ; pkiDebug ( ""found<S2SV_blank>kdcPkId<S2SV_blank>in<S2SV_blank>AS<S2SV_blank>REQ\\n"" ) ; is = d2i_PKCS7_ISSUER_AND_SERIAL ( NULL , & p , ( int ) pkid_len ) ; if ( is == NULL ) <S2SV_StartBug> goto cleanup ; <S2SV_EndBug> status = X509_NAME_cmp ( X509_get_issuer_name ( kdc_cert ) , is -> issuer ) ; if ( ! status ) { status = ASN1_INTEGER_cmp ( X509_get_serialNumber ( kdc_cert ) , is -> serial ) ; if ( ! status ) * valid_kdcPkId = 1 ; } retval = 0 ; <S2SV_StartBug> cleanup : <S2SV_EndBug> X509_NAME_free ( is -> issuer ) ; ASN1_INTEGER_free ( is -> serial ) ; free ( is ) ; return retval ; }
","<S2SV_ModStart> == NULL ) return retval <S2SV_ModEnd> ; status = <S2SV_ModStart> = 0 ; <S2SV_ModEnd> X509_NAME_free ( is
"
685,"CWE-000 void ff_jpeg2000_cleanup ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty ) { int reslevelno , bandno , precno ; for ( reslevelno = 0 ; comp -> reslevel && reslevelno < codsty -> nreslevels ; reslevelno ++ ) { Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ ) { Jpeg2000Band * band = reslevel -> band + bandno ; for ( precno = 0 ; precno < reslevel -> num_precincts_x * reslevel -> num_precincts_y ; precno ++ ) { <S2SV_StartBug> Jpeg2000Prec * prec = band -> prec + precno ; <S2SV_EndBug> av_freep ( & prec -> zerobits ) ; av_freep ( & prec -> cblkincl ) ; av_freep ( & prec -> cblk ) ; } <S2SV_StartBug> av_freep ( & band -> prec ) ; <S2SV_EndBug> } av_freep ( & reslevel -> band ) ; } ff_dwt_destroy ( & comp -> dwt ) ; av_freep ( & comp -> reslevel ) ; av_freep ( & comp -> i_data ) ; av_freep ( & comp -> f_data ) ; }
","<S2SV_ModStart> ++ ) { if ( band -> prec ) { <S2SV_ModStart> ) ; } }
"
686,"CWE-835 void xmlParsePEReference ( xmlParserCtxtPtr ctxt ) { const xmlChar * name ; xmlEntityPtr entity = NULL ; xmlParserInputPtr input ; if ( RAW != '%' ) return ; NEXT ; name = xmlParseName ( ctxt ) ; if ( name == NULL ) { xmlFatalErrMsg ( ctxt , XML_ERR_PEREF_NO_NAME , ""PEReference:<S2SV_blank>no<S2SV_blank>name\\n"" ) ; return ; } if ( xmlParserDebugEntities ) xmlGenericError ( xmlGenericErrorContext , ""PEReference:<S2SV_blank>%s\\n"" , name ) ; if ( RAW != ';' ) { xmlFatalErr ( ctxt , XML_ERR_PEREF_SEMICOL_MISSING , NULL ) ; return ; } NEXT ; ctxt -> nbentities ++ ; if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> getParameterEntity != NULL ) ) entity = ctxt -> sax -> getParameterEntity ( ctxt -> userData , name ) ; if ( ctxt -> instate == XML_PARSER_EOF ) return ; if ( entity == NULL ) { if ( ( ctxt -> standalone == 1 ) || ( ( ctxt -> hasExternalSubset == 0 ) && ( ctxt -> hasPErefs == 0 ) ) ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_UNDECLARED_ENTITY , ""PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\n"" , name ) ; } else { if ( ( ctxt -> validate ) && ( ctxt -> vctxt . error != NULL ) ) { xmlValidityError ( ctxt , XML_WAR_UNDECLARED_ENTITY , ""PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\n"" , name , NULL ) ; } else xmlWarningMsg ( ctxt , XML_WAR_UNDECLARED_ENTITY , ""PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\n"" , name , NULL ) ; ctxt -> valid = 0 ; } xmlParserEntityCheck ( ctxt , 0 , NULL , 0 ) ; } else { if ( ( entity -> etype != XML_INTERNAL_PARAMETER_ENTITY ) && ( entity -> etype != XML_EXTERNAL_PARAMETER_ENTITY ) ) { xmlWarningMsg ( ctxt , XML_WAR_UNDECLARED_ENTITY , ""Internal:<S2SV_blank>%%%s;<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>parameter<S2SV_blank>entity\\n"" , name , NULL ) ; } else { xmlChar start [ 4 ] ; xmlCharEncoding enc ; if ( ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) && ( ( ctxt -> options & XML_PARSE_NOENT ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDVALID ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDLOAD ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDATTR ) == 0 ) && ( ctxt -> replaceEntities == 0 ) && ( ctxt -> validate == 0 ) ) return ; input = xmlNewEntityInputStream ( ctxt , entity ) ; <S2SV_StartBug> if ( xmlPushInput ( ctxt , input ) < 0 ) <S2SV_EndBug> return ; if ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) { GROW if ( ctxt -> instate == XML_PARSER_EOF ) return ; if ( ( ctxt -> input -> end - ctxt -> input -> cur ) >= 4 ) { start [ 0 ] = RAW ; start [ 1 ] = NXT ( 1 ) ; start [ 2 ] = NXT ( 2 ) ; start [ 3 ] = NXT ( 3 ) ; enc = xmlDetectCharEncoding ( start , 4 ) ; if ( enc != XML_CHAR_ENCODING_NONE ) { xmlSwitchEncoding ( ctxt , enc ) ; } } if ( ( CMP5 ( CUR_PTR , '<' , '?' , 'x' , 'm' , 'l' ) ) && ( IS_BLANK_CH ( NXT ( 5 ) ) ) ) { xmlParseTextDecl ( ctxt ) ; } } } } ctxt -> hasPErefs = 1 ; }
","<S2SV_ModStart> < 0 ) { xmlFreeInputStream ( input ) ; return ; } <S2SV_ModEnd> if ( entity
"
687,"CWE-264 static int dccp_v6_send_response ( const struct sock * sk , struct request_sock * req ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sk_buff * skb ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; int err = - 1 ; struct dst_entry * dst ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_DCCP ; fl6 . daddr = ireq -> ir_v6_rmt_addr ; fl6 . saddr = ireq -> ir_v6_loc_addr ; fl6 . flowlabel = 0 ; fl6 . flowi6_oif = ireq -> ir_iif ; fl6 . fl6_dport = ireq -> ir_rmt_port ; fl6 . fl6_sport = htons ( ireq -> ir_num ) ; security_req_classify_flow ( req , flowi6_to_flowi ( & fl6 ) ) ; <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; dst = NULL ; goto done ; } skb = dccp_make_response ( sk , dst , req ) ; if ( skb != NULL ) { struct dccp_hdr * dh = dccp_hdr ( skb ) ; dh -> dccph_checksum = dccp_v6_csum_finish ( skb , & ireq -> ir_v6_loc_addr , & ireq -> ir_v6_rmt_addr ) ; fl6 . daddr = ireq -> ir_v6_rmt_addr ; <S2SV_StartBug> err = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> err = net_xmit_eval ( err ) ; } done : dst_release ( dst ) ; return err ; }
","<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> , & final ) ; rcu_read_unlock ( <S2SV_ModStart> -> ir_v6_rmt_addr ; rcu_read_lock ( ) ; <S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) , <S2SV_ModEnd> np -> tclass <S2SV_ModStart> np -> tclass ) ; rcu_read_unlock (
"
688,"CWE-119 <S2SV_StartBug> static TX_MODE select_tx_mode ( const VP9_COMP * cpi ) { <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . lossless ) { <S2SV_EndBug> return ONLY_4X4 ; <S2SV_StartBug> } else if ( cpi -> common . current_video_frame == 0 ) { <S2SV_EndBug> return TX_MODE_SELECT ; } else { <S2SV_StartBug> if ( cpi -> sf . tx_size_search_method == USE_LARGESTALL ) { <S2SV_EndBug> return ALLOW_32X32 ; <S2SV_StartBug> } else if ( cpi -> sf . tx_size_search_method == USE_FULL_RD ) { <S2SV_EndBug> const MV_REFERENCE_FRAME frame_type = get_frame_type ( cpi ) ; return cpi -> rd_tx_select_threshes [ frame_type ] [ ALLOW_32X32 ] > cpi -> rd_tx_select_threshes [ frame_type ] [ TX_MODE_SELECT ] ? ALLOW_32X32 : TX_MODE_SELECT ; } else { unsigned int total = 0 ; int i ; for ( i = 0 ; i < TX_SIZES ; ++ i ) total += cpi -> tx_stepdown_count [ i ] ; if ( total ) { const double fraction = ( double ) cpi -> tx_stepdown_count [ 0 ] / total ; return fraction > 0.90 ? ALLOW_32X32 : TX_MODE_SELECT ; } else { return cpi -> common . tx_mode ; } <S2SV_StartBug> } <S2SV_EndBug> } }
","<S2SV_ModStart> VP9_COMP * cpi , MACROBLOCKD * const xd <S2SV_ModStart> { if ( xd -> lossless ) <S2SV_ModEnd> return ONLY_4X4 ; <S2SV_ModStart> return ONLY_4X4 ; <S2SV_ModEnd> if ( cpi <S2SV_ModStart> -> common . frame_type == KEY_FRAME && cpi -> sf . use_nonrd_pick_mode ) return ALLOW_16X16 ; <S2SV_ModEnd> if ( cpi <S2SV_ModStart> == USE_LARGESTALL ) <S2SV_ModEnd> return ALLOW_32X32 ; <S2SV_ModStart> return ALLOW_32X32 ; <S2SV_ModEnd> else if ( <S2SV_ModStart> tx_size_search_method == USE_FULL_RD || cpi -> sf . tx_size_search_method == USE_TX_8X8 ) return TX_MODE_SELECT ; else <S2SV_ModEnd> return cpi -> <S2SV_ModStart> tx_mode ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
"
689,"CWE-119 <S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) <S2SV_EndBug> { <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( u32 size , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; } <S2SV_ModEnd> return malloc ( <S2SV_ModStart> malloc ( size * num
"
690,"CWE-134 int print_calc ( image_desc_t * im ) { long i , ii , validsteps ; double printval ; struct tm tmvdef ; int graphelement = 0 ; long vidx ; int max_ii ; double magfact = - 1 ; char * si_symb = """" ; char * percent_s ; int prline_cnt = 0 ; time_t now = time ( NULL ) ; localtime_r ( & now , & tmvdef ) ; for ( i = 0 ; i < im -> gdes_c ; i ++ ) { vidx = im -> gdes [ i ] . vidx ; switch ( im -> gdes [ i ] . gf ) { case GF_PRINT : case GF_GPRINT : if ( im -> gdes [ vidx ] . gf == GF_VDEF ) { printval = im -> gdes [ vidx ] . vf . val ; localtime_r ( & im -> gdes [ vidx ] . vf . when , & tmvdef ) ; } else { max_ii = ( ( im -> gdes [ vidx ] . end - im -> gdes [ vidx ] . start ) / im -> gdes [ vidx ] . step * im -> gdes [ vidx ] . ds_cnt ) ; printval = DNAN ; validsteps = 0 ; for ( ii = im -> gdes [ vidx ] . ds ; ii < max_ii ; ii += im -> gdes [ vidx ] . ds_cnt ) { if ( ! finite ( im -> gdes [ vidx ] . data [ ii ] ) ) continue ; if ( isnan ( printval ) ) { printval = im -> gdes [ vidx ] . data [ ii ] ; validsteps ++ ; continue ; } switch ( im -> gdes [ i ] . cf ) { case CF_HWPREDICT : case CF_MHWPREDICT : case CF_DEVPREDICT : case CF_DEVSEASONAL : case CF_SEASONAL : case CF_AVERAGE : validsteps ++ ; printval += im -> gdes [ vidx ] . data [ ii ] ; break ; case CF_MINIMUM : printval = min ( printval , im -> gdes [ vidx ] . data [ ii ] ) ; break ; case CF_FAILURES : case CF_MAXIMUM : printval = max ( printval , im -> gdes [ vidx ] . data [ ii ] ) ; break ; case CF_LAST : printval = im -> gdes [ vidx ] . data [ ii ] ; } } if ( im -> gdes [ i ] . cf == CF_AVERAGE || im -> gdes [ i ] . cf > CF_LAST ) { if ( validsteps > 1 ) { printval = ( printval / validsteps ) ; } } } if ( ! im -> gdes [ i ] . strftm && ( percent_s = strstr ( im -> gdes [ i ] . format , ""%S"" ) ) != NULL ) { if ( magfact < 0.0 ) { auto_scale ( im , & printval , & si_symb , & magfact ) ; if ( printval == 0.0 ) magfact = - 1.0 ; } else { printval /= magfact ; } * ( ++ percent_s ) = 's' ; } else if ( ! im -> gdes [ i ] . strftm && strstr ( im -> gdes [ i ] . format , ""%s"" ) != NULL ) { auto_scale ( im , & printval , & si_symb , & magfact ) ; } if ( im -> gdes [ i ] . gf == GF_PRINT ) { rrd_infoval_t prline ; if ( im -> gdes [ i ] . strftm ) { prline . u_str = ( char * ) malloc ( ( FMT_LEG_LEN + 2 ) * sizeof ( char ) ) ; if ( im -> gdes [ vidx ] . vf . never == 1 ) { time_clean ( prline . u_str , im -> gdes [ i ] . format ) ; } else { strftime ( prline . u_str , FMT_LEG_LEN , im -> gdes [ i ] . format , & tmvdef ) ; } <S2SV_StartBug> } else if ( bad_format ( im -> gdes [ i ] . format ) ) { <S2SV_EndBug> <S2SV_StartBug> rrd_set_error <S2SV_EndBug> ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>PRINT<S2SV_blank>in<S2SV_blank>\'%s\'"" , im -> gdes [ i ] . format ) ; return - 1 ; } else { prline . u_str = sprintf_alloc ( im -> gdes [ i ] . format , printval , si_symb ) ; } grinfo_push ( im , sprintf_alloc ( ""print[%ld]"" , prline_cnt ++ ) , RD_I_STR , prline ) ; free ( prline . u_str ) ; } else { if ( im -> gdes [ i ] . strftm ) { if ( im -> gdes [ vidx ] . vf . never == 1 ) { time_clean ( im -> gdes [ i ] . legend , im -> gdes [ i ] . format ) ; } else { strftime ( im -> gdes [ i ] . legend , FMT_LEG_LEN , im -> gdes [ i ] . format , & tmvdef ) ; } } else { <S2SV_StartBug> if ( bad_format ( im -> gdes [ i ] . format ) ) { <S2SV_EndBug> <S2SV_StartBug> rrd_set_error <S2SV_EndBug> ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>GPRINT<S2SV_blank>in<S2SV_blank>\'%s\'"" , im -> gdes [ i ] . format ) ; return - 1 ; } snprintf ( im -> gdes [ i ] . legend , FMT_LEG_LEN - 2 , im -> gdes [ i ] . format , printval , si_symb ) ; } graphelement = 1 ; } break ; case GF_LINE : case GF_AREA : case GF_GRAD : case GF_TICK : graphelement = 1 ; break ; case GF_HRULE : if ( isnan ( im -> gdes [ i ] . yrule ) ) { im -> gdes [ i ] . yrule = im -> gdes [ vidx ] . vf . val ; } ; graphelement = 1 ; break ; case GF_VRULE : if ( im -> gdes [ i ] . xrule == 0 ) { im -> gdes [ i ] . xrule = im -> gdes [ vidx ] . vf . when ; } ; graphelement = 1 ; break ; case GF_COMMENT : case GF_TEXTALIGN : case GF_DEF : case GF_CDEF : case GF_VDEF : # ifdef WITH_PIECHART case GF_PART : # endif case GF_SHIFT : case GF_XPORT : break ; case GF_STACK : rrd_set_error ( ""STACK<S2SV_blank>should<S2SV_blank>already<S2SV_blank>be<S2SV_blank>turned<S2SV_blank>into<S2SV_blank>LINE<S2SV_blank>or<S2SV_blank>AREA<S2SV_blank>here"" ) ; return - 1 ; break ; case GF_XAXIS : case GF_YAXIS : break ; } } return graphelement ; }
","<S2SV_ModStart> else if ( bad_format_print <S2SV_ModEnd> ( im -> <S2SV_ModStart> ) ) { <S2SV_ModEnd> return - 1 <S2SV_ModStart> { if ( bad_format_print <S2SV_ModEnd> ( im -> <S2SV_ModStart> ) ) { <S2SV_ModEnd> return - 1
"
691,"CWE-119 static Sdb * store_versioninfo_gnu_verneed ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { ut8 * end , * need = NULL ; const char * section_name = """" ; Elf_ ( Shdr ) * link_shdr = NULL ; const char * link_section_name = """" ; Sdb * sdb_vernaux = NULL ; Sdb * sdb_version = NULL ; Sdb * sdb = NULL ; int i , cnt ; if ( ! bin || ! bin -> dynstr ) { return NULL ; } if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return NULL ; } <S2SV_StartBug> if ( shdr -> sh_size < 1 ) { <S2SV_EndBug> return NULL ; } sdb = sdb_new0 ( ) ; if ( ! sdb ) { return NULL ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! ( need = ( ut8 * ) calloc ( R_MAX ( 1 , shdr -> sh_size ) , sizeof ( ut8 ) ) ) ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Elf_(Verneed)\\n"" ) ; goto beach ; } end = need + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""num_entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ; if ( shdr -> sh_offset > bin -> size || shdr -> sh_offset + shdr -> sh_size > bin -> size ) { goto beach ; } if ( shdr -> sh_offset + shdr -> sh_size < shdr -> sh_size ) { goto beach ; } i = r_buf_read_at ( bin -> b , shdr -> sh_offset , need , shdr -> sh_size ) ; if ( i < 0 ) goto beach ; for ( i = 0 , cnt = 0 ; cnt < shdr -> sh_info ; ++ cnt ) { int j , isum ; ut8 * vstart = need + i ; Elf_ ( Verneed ) vvn = { 0 } ; if ( vstart + sizeof ( Elf_ ( Verneed ) ) > end ) { goto beach ; } Elf_ ( Verneed ) * entry = & vvn ; char key [ 32 ] = { 0 } ; sdb_version = sdb_new0 ( ) ; if ( ! sdb_version ) { goto beach ; } j = 0 ; vvn . vn_version = READ16 ( vstart , j ) vvn . vn_cnt = READ16 ( vstart , j ) vvn . vn_file = READ32 ( vstart , j ) vvn . vn_aux = READ32 ( vstart , j ) vvn . vn_next = READ32 ( vstart , j ) sdb_num_set ( sdb_version , ""vn_version"" , entry -> vn_version , 0 ) ; sdb_num_set ( sdb_version , ""idx"" , i , 0 ) ; if ( entry -> vn_file > bin -> dynstr_size ) { goto beach ; } { char * s = r_str_ndup ( & bin -> dynstr [ entry -> vn_file ] , 16 ) ; sdb_set ( sdb_version , ""file_name"" , s , 0 ) ; free ( s ) ; } sdb_num_set ( sdb_version , ""cnt"" , entry -> vn_cnt , 0 ) ; st32 vnaux = entry -> vn_aux ; if ( vnaux < 1 ) { goto beach ; } vstart += vnaux ; for ( j = 0 , isum = i + entry -> vn_aux ; j < entry -> vn_cnt && vstart + sizeof ( Elf_ ( Vernaux ) ) <= end ; ++ j ) { int k ; Elf_ ( Vernaux ) * aux = NULL ; Elf_ ( Vernaux ) vaux = { 0 } ; sdb_vernaux = sdb_new0 ( ) ; if ( ! sdb_vernaux ) { goto beach ; } aux = ( Elf_ ( Vernaux ) * ) & vaux ; k = 0 ; vaux . vna_hash = READ32 ( vstart , k ) vaux . vna_flags = READ16 ( vstart , k ) vaux . vna_other = READ16 ( vstart , k ) vaux . vna_name = READ32 ( vstart , k ) vaux . vna_next = READ32 ( vstart , k ) if ( aux -> vna_name > bin -> dynstr_size ) { goto beach ; } sdb_num_set ( sdb_vernaux , ""idx"" , isum , 0 ) ; if ( aux -> vna_name > 0 && aux -> vna_name + 8 < bin -> dynstr_size ) { char name [ 16 ] ; strncpy ( name , & bin -> dynstr [ aux -> vna_name ] , sizeof ( name ) - 1 ) ; name [ sizeof ( name ) - 1 ] = 0 ; sdb_set ( sdb_vernaux , ""name"" , name , 0 ) ; } sdb_set ( sdb_vernaux , ""flags"" , get_ver_flags ( aux -> vna_flags ) , 0 ) ; sdb_num_set ( sdb_vernaux , ""version"" , aux -> vna_other , 0 ) ; isum += aux -> vna_next ; vstart += aux -> vna_next ; snprintf ( key , sizeof ( key ) , ""vernaux%d"" , j ) ; sdb_ns_set ( sdb_version , key , sdb_vernaux ) ; } if ( ( int ) entry -> vn_next < 0 ) { bprintf ( ""Invalid<S2SV_blank>vn_next\\n"" ) ; break ; } i += entry -> vn_next ; snprintf ( key , sizeof ( key ) , ""version%d"" , cnt ) ; sdb_ns_set ( sdb , key , sdb_version ) ; if ( ! entry -> vn_next ) { break ; } } free ( need ) ; return sdb ; beach : free ( need ) ; sdb_free ( sdb_vernaux ) ; sdb_free ( sdb_version ) ; sdb_free ( sdb ) ; return NULL ; }
","<S2SV_ModStart> sh_size < 1 || shdr -> sh_size > SIZE_MAX
"
692,"CWE-119 static int compare_tile_buffers ( const void * a , const void * b ) { const TileBuffer * const buf1 = ( const TileBuffer * ) a ; const TileBuffer * const buf2 = ( const TileBuffer * ) b ; <S2SV_StartBug> if ( buf1 -> size < buf2 -> size ) { <S2SV_EndBug> return 1 ; } else if ( buf1 -> size == buf2 -> size ) { return 0 ; } else { return - 1 ; } }
","<S2SV_ModStart> ) b ; return ( int ) ( buf2 -> size - <S2SV_ModEnd> buf1 -> size <S2SV_ModStart> buf1 -> size ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
"
693,"CWE-119 protected int file_trycdf ( struct magic_set * ms , int fd , const unsigned char * buf , size_t nbytes ) { cdf_info_t info ; cdf_header_t h ; cdf_sat_t sat , ssat ; cdf_stream_t sst , scn ; cdf_dir_t dir ; int i ; const char * expn = """" ; const char * corrupt = ""corrupt:<S2SV_blank>"" ; info . i_fd = fd ; info . i_buf = buf ; info . i_len = nbytes ; if ( ms -> flags & MAGIC_APPLE ) return 0 ; if ( cdf_read_header ( & info , & h ) == - 1 ) return 0 ; # ifdef CDF_DEBUG cdf_dump_header ( & h ) ; # endif if ( ( i = cdf_read_sat ( & info , & h , & sat ) ) == - 1 ) { expn = ""Can\'t<S2SV_blank>read<S2SV_blank>SAT"" ; goto out0 ; } # ifdef CDF_DEBUG cdf_dump_sat ( ""SAT"" , & sat , CDF_SEC_SIZE ( & h ) ) ; # endif if ( ( i = cdf_read_ssat ( & info , & h , & sat , & ssat ) ) == - 1 ) { expn = ""Can\'t<S2SV_blank>read<S2SV_blank>SSAT"" ; goto out1 ; } # ifdef CDF_DEBUG cdf_dump_sat ( ""SSAT"" , & ssat , CDF_SHORT_SEC_SIZE ( & h ) ) ; # endif if ( ( i = cdf_read_dir ( & info , & h , & sat , & dir ) ) == - 1 ) { expn = ""Can\'t<S2SV_blank>read<S2SV_blank>directory"" ; goto out2 ; } const cdf_directory_t * root_storage ; if ( ( i = cdf_read_short_stream ( & info , & h , & sat , & dir , & sst , & root_storage ) ) == - 1 ) { expn = ""Cannot<S2SV_blank>read<S2SV_blank>short<S2SV_blank>stream"" ; goto out3 ; } # ifdef CDF_DEBUG cdf_dump_dir ( & info , & h , & sat , & ssat , & sst , & dir ) ; # endif # ifdef notdef if ( root_storage ) { if ( NOTMIME ( ms ) ) { char clsbuf [ 128 ] ; if ( file_printf ( ms , ""CLSID<S2SV_blank>%s,<S2SV_blank>"" , format_clsid ( clsbuf , sizeof ( clsbuf ) , root_storage -> d_storage_uuid ) ) == - 1 ) return - 1 ; } } # endif if ( ( i = cdf_read_summary_info ( & info , & h , & sat , & ssat , & sst , & dir , & scn ) ) == - 1 ) { if ( errno == ESRCH ) { corrupt = expn ; expn = ""No<S2SV_blank>summary<S2SV_blank>info"" ; } else { expn = ""Cannot<S2SV_blank>read<S2SV_blank>summary<S2SV_blank>info"" ; } goto out4 ; } # ifdef CDF_DEBUG cdf_dump_summary_info ( & h , & scn ) ; # endif if ( ( i = cdf_file_summary_info ( ms , & h , & scn , <S2SV_StartBug> root_storage -> d_storage_uuid ) ) < 0 ) <S2SV_EndBug> expn = ""Can\'t<S2SV_blank>expand<S2SV_blank>summary_info"" ; if ( i == 0 ) { const char * str = NULL ; cdf_directory_t * d ; char name [ __arraycount ( d -> d_name ) ] ; size_t j , k ; for ( j = 0 ; str == NULL && j < dir . dir_len ; j ++ ) { d = & dir . dir_tab [ j ] ; for ( k = 0 ; k < sizeof ( name ) ; k ++ ) name [ k ] = ( char ) cdf_tole2 ( d -> d_name [ k ] ) ; str = cdf_app_to_mime ( name , NOTMIME ( ms ) ? name2desc : name2mime ) ; } if ( NOTMIME ( ms ) ) { if ( str != NULL ) { if ( file_printf ( ms , ""%s"" , str ) == - 1 ) return - 1 ; i = 1 ; } } else { if ( str == NULL ) str = ""vnd.ms-office"" ; if ( file_printf ( ms , ""application/%s"" , str ) == - 1 ) return - 1 ; i = 1 ; } } free ( scn . sst_tab ) ; out4 : free ( sst . sst_tab ) ; out3 : free ( dir . dir_tab ) ; out2 : free ( ssat . sat_tab ) ; out1 : free ( sat . sat_tab ) ; out0 : if ( i == - 1 ) { if ( NOTMIME ( ms ) ) { if ( file_printf ( ms , ""Composite<S2SV_blank>Document<S2SV_blank>File<S2SV_blank>V2<S2SV_blank>Document"" ) == - 1 ) return - 1 ; if ( * expn ) if ( file_printf ( ms , "",<S2SV_blank>%s%s"" , corrupt , expn ) == - 1 ) return - 1 ; } else { if ( file_printf ( ms , ""application/CDFV2-corrupt"" ) == - 1 ) return - 1 ; } i = 1 ; } return i ; }
","<S2SV_ModStart> scn , root_storage <S2SV_ModEnd> ) ) <
"
694,"CWE-189 struct xt_table_info * xt_alloc_table_info ( unsigned int size ) { struct xt_table_info * info = NULL ; <S2SV_StartBug> size_t sz = sizeof ( * info ) + size ; <S2SV_EndBug> if ( ( SMP_ALIGN ( size ) >> PAGE_SHIFT ) + 2 > totalram_pages ) return NULL ; if ( sz <= ( PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER ) ) info = kmalloc ( sz , GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY ) ; if ( ! info ) { info = vmalloc ( sz ) ; if ( ! info ) return NULL ; } memset ( info , 0 , sizeof ( * info ) ) ; info -> size = size ; return info ; }
","<S2SV_ModStart> ) + size ; if ( sz < sizeof ( * info ) ) return NULL
"
695,"CWE-400 static inline int add_post_vars ( zval * arr , post_var_data_t * vars , zend_bool eof TSRMLS_DC ) { uint64_t max_vars = PG ( max_input_vars ) ; vars -> ptr = vars -> str . c ; vars -> end = vars -> str . c + vars -> str . len ; while ( add_post_var ( arr , vars , eof TSRMLS_CC ) ) { if ( ++ vars -> cnt > max_vars ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Input<S2SV_blank>variables<S2SV_blank>exceeded<S2SV_blank>%"" PRIu64 "".<S2SV_blank>"" ""To<S2SV_blank>increase<S2SV_blank>the<S2SV_blank>limit<S2SV_blank>change<S2SV_blank>max_input_vars<S2SV_blank>in<S2SV_blank>php.ini."" , max_vars ) ; return FAILURE ; } } <S2SV_StartBug> if ( ! eof ) { <S2SV_EndBug> memmove ( vars -> str . c , vars -> ptr , vars -> str . len = vars -> end - vars -> ptr ) ; } return SUCCESS ; }
","<S2SV_ModStart> ( ! eof && vars -> str . c != vars -> ptr
"
696,"CWE-000 static int ax25_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct sock * sk ; ax25_cb * ax25 ; <S2SV_StartBug> if ( ! net_eq ( net , & init_net ) ) <S2SV_EndBug> return - EAFNOSUPPORT ; switch ( sock -> type ) { case SOCK_DGRAM : if ( protocol == 0 || protocol == PF_AX25 ) protocol = AX25_P_TEXT ; break ; case SOCK_SEQPACKET : switch ( protocol ) { case 0 : case PF_AX25 : protocol = AX25_P_TEXT ; break ; case AX25_P_SEGMENT : # ifdef CONFIG_INET case AX25_P_ARP : case AX25_P_IP : # endif # ifdef CONFIG_NETROM case AX25_P_NETROM : # endif # ifdef CONFIG_ROSE case AX25_P_ROSE : # endif return - ESOCKTNOSUPPORT ; # ifdef CONFIG_NETROM_MODULE case AX25_P_NETROM : if ( ax25_protocol_is_registered ( AX25_P_NETROM ) ) return - ESOCKTNOSUPPORT ; break ; # endif # ifdef CONFIG_ROSE_MODULE case AX25_P_ROSE : if ( ax25_protocol_is_registered ( AX25_P_ROSE ) ) return - ESOCKTNOSUPPORT ; # endif default : break ; } break ; case SOCK_RAW : break ; default : return - ESOCKTNOSUPPORT ; } sk = sk_alloc ( net , PF_AX25 , GFP_ATOMIC , & ax25_proto , kern ) ; if ( sk == NULL ) return - ENOMEM ; ax25 = ax25_sk ( sk ) -> cb = ax25_create_cb ( ) ; if ( ! ax25 ) { sk_free ( sk ) ; return - ENOMEM ; } sock_init_data ( sock , sk ) ; sk -> sk_destruct = ax25_free_sock ; sock -> ops = & ax25_proto_ops ; sk -> sk_protocol = protocol ; ax25 -> sk = sk ; return 0 ; }
","<S2SV_ModStart> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if (
"
697,"CWE-400 asmlinkage void do_page_fault ( struct pt_regs * regs , unsigned long writeaccess , unsigned long textaccess , unsigned long address ) { struct task_struct * tsk ; struct mm_struct * mm ; struct vm_area_struct * vma ; const struct exception_table_entry * fixup ; pte_t * pte ; int fault ; tsk = current ; mm = tsk -> mm ; local_irq_enable ( ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> if ( in_atomic ( ) || ! mm ) goto no_context ; down_read ( & mm -> mmap_sem ) ; vma = find_vma ( mm , address ) ; if ( ! vma ) { # ifdef DEBUG_FAULT print_task ( tsk ) ; printk ( ""%s:%d<S2SV_blank>fault,<S2SV_blank>address<S2SV_blank>is<S2SV_blank>0x%08x<S2SV_blank>PC<S2SV_blank>%016Lx<S2SV_blank>textaccess<S2SV_blank>%d<S2SV_blank>writeaccess<S2SV_blank>%d\\n"" , __func__ , __LINE__ , address , regs -> pc , textaccess , writeaccess ) ; show_regs ( regs ) ; # endif goto bad_area ; } if ( vma -> vm_start <= address ) { goto good_area ; } if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) { # ifdef DEBUG_FAULT print_task ( tsk ) ; printk ( ""%s:%d<S2SV_blank>fault,<S2SV_blank>address<S2SV_blank>is<S2SV_blank>0x%08x<S2SV_blank>PC<S2SV_blank>%016Lx<S2SV_blank>textaccess<S2SV_blank>%d<S2SV_blank>writeaccess<S2SV_blank>%d\\n"" , __func__ , __LINE__ , address , regs -> pc , textaccess , writeaccess ) ; show_regs ( regs ) ; print_vma ( vma ) ; # endif goto bad_area ; } if ( expand_stack ( vma , address ) ) { # ifdef DEBUG_FAULT print_task ( tsk ) ; printk ( ""%s:%d<S2SV_blank>fault,<S2SV_blank>address<S2SV_blank>is<S2SV_blank>0x%08x<S2SV_blank>PC<S2SV_blank>%016Lx<S2SV_blank>textaccess<S2SV_blank>%d<S2SV_blank>writeaccess<S2SV_blank>%d\\n"" , __func__ , __LINE__ , address , regs -> pc , textaccess , writeaccess ) ; show_regs ( regs ) ; # endif goto bad_area ; } good_area : if ( textaccess ) { if ( ! ( vma -> vm_flags & VM_EXEC ) ) goto bad_area ; } else { if ( writeaccess ) { if ( ! ( vma -> vm_flags & VM_WRITE ) ) goto bad_area ; } else { if ( ! ( vma -> vm_flags & VM_READ ) ) goto bad_area ; } } fault = handle_mm_fault ( mm , vma , address , writeaccess ? FAULT_FLAG_WRITE : 0 ) ; if ( unlikely ( fault & VM_FAULT_ERROR ) ) { if ( fault & VM_FAULT_OOM ) goto out_of_memory ; else if ( fault & VM_FAULT_SIGBUS ) goto do_sigbus ; BUG ( ) ; } if ( fault & VM_FAULT_MAJOR ) { tsk -> maj_flt ++ ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> regs , address ) ; } else { tsk -> min_flt ++ ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug> regs , address ) ; } pte = lookup_pte ( mm , address ) ; if ( ! pte ) { goto no_pte ; } __do_tlb_refill ( address , textaccess , pte ) ; no_pte : up_read ( & mm -> mmap_sem ) ; return ; bad_area : # ifdef DEBUG_FAULT printk ( ""fault:bad<S2SV_blank>area\\n"" ) ; # endif up_read ( & mm -> mmap_sem ) ; if ( user_mode ( regs ) ) { static int count = 0 ; siginfo_t info ; if ( count < 4 ) { count ++ ; printk ( ""user<S2SV_blank>mode<S2SV_blank>bad_area<S2SV_blank>address=%08lx<S2SV_blank>pid=%d<S2SV_blank>(%s)<S2SV_blank>pc=%08lx\\n"" , address , task_pid_nr ( current ) , current -> comm , ( unsigned long ) regs -> pc ) ; # if 0 show_regs ( regs ) ; # endif } if ( is_global_init ( tsk ) ) { panic ( ""INIT<S2SV_blank>had<S2SV_blank>user<S2SV_blank>mode<S2SV_blank>bad_area\\n"" ) ; } tsk -> thread . address = address ; tsk -> thread . error_code = writeaccess ; info . si_signo = SIGSEGV ; info . si_errno = 0 ; info . si_addr = ( void * ) address ; force_sig_info ( SIGSEGV , & info , tsk ) ; return ; } no_context : # ifdef DEBUG_FAULT printk ( ""fault:No<S2SV_blank>context\\n"" ) ; # endif fixup = search_exception_tables ( regs -> pc ) ; if ( fixup ) { regs -> pc = fixup -> fixup ; return ; } if ( address < PAGE_SIZE ) printk ( KERN_ALERT ""Unable<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>kernel<S2SV_blank>NULL<S2SV_blank>pointer<S2SV_blank>dereference"" ) ; else printk ( KERN_ALERT ""Unable<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>kernel<S2SV_blank>paging<S2SV_blank>request"" ) ; printk ( ""<S2SV_blank>at<S2SV_blank>virtual<S2SV_blank>address<S2SV_blank>%08lx\\n"" , address ) ; printk ( KERN_ALERT ""pc<S2SV_blank>=<S2SV_blank>%08Lx%08Lx\\n"" , regs -> pc >> 32 , regs -> pc & 0xffffffff ) ; die ( ""Oops"" , regs , writeaccess ) ; do_exit ( SIGKILL ) ; out_of_memory : up_read ( & mm -> mmap_sem ) ; if ( ! user_mode ( regs ) ) goto no_context ; pagefault_out_of_memory ( ) ; return ; do_sigbus : printk ( ""fault:Do<S2SV_blank>sigbus\\n"" ) ; up_read ( & mm -> mmap_sem ) ; tsk -> thread . address = address ; tsk -> thread . error_code = writeaccess ; tsk -> thread . trap_no = 14 ; force_sig ( SIGBUS , tsk ) ; if ( ! user_mode ( regs ) ) goto no_context ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 <S2SV_ModEnd> , regs ,
"
698,"CWE-000 static int em_grp45 ( struct x86_emulate_ctxt * ctxt ) { int rc = X86EMUL_CONTINUE ; switch ( ctxt -> modrm_reg ) { case 2 : { long int old_eip ; old_eip = ctxt -> _eip ; <S2SV_StartBug> ctxt -> _eip = ctxt -> src . val ; <S2SV_EndBug> ctxt -> src . val = old_eip ; rc = em_push ( ctxt ) ; break ; } case 4 : <S2SV_StartBug> ctxt -> _eip = ctxt -> src . val ; <S2SV_EndBug> break ; case 5 : rc = em_jmp_far ( ctxt ) ; break ; case 6 : rc = em_push ( ctxt ) ; break ; } return rc ; }
","<S2SV_ModStart> -> _eip ; rc = assign_eip_near ( ctxt , <S2SV_ModEnd> ctxt -> src <S2SV_ModStart> src . val ) ; if ( rc != X86EMUL_CONTINUE ) break <S2SV_ModStart> case 4 : rc = assign_eip_near ( ctxt , <S2SV_ModEnd> ctxt -> src <S2SV_ModStart> src . val )
"
699,"CWE-77 static void cmd_parse_lsub ( struct ImapData * idata , char * s ) { char buf [ STRING ] ; char errstr [ STRING ] ; struct Buffer err , token ; struct Url url ; struct ImapList list ; if ( idata -> cmddata && idata -> cmdtype == IMAP_CT_LIST ) { cmd_parse_list ( idata , s ) ; return ; } if ( ! ImapCheckSubscribed ) return ; idata -> cmdtype = IMAP_CT_LIST ; idata -> cmddata = & list ; cmd_parse_list ( idata , s ) ; idata -> cmddata = NULL ; if ( ! list . name || list . noselect ) return ; mutt_debug ( 3 , ""Subscribing<S2SV_blank>to<S2SV_blank>%s\\n"" , list . name ) ; mutt_str_strfcpy ( buf , ""mailboxes<S2SV_blank>\\"""" , sizeof ( buf ) ) ; mutt_account_tourl ( & idata -> conn -> account , & url ) ; <S2SV_StartBug> imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ; <S2SV_EndBug> url . path = errstr + 1 ; url . path [ strlen ( url . path ) - 1 ] = '\\0' ; if ( mutt_str_strcmp ( url . user , ImapUser ) == 0 ) url . user = NULL ; url_tostring ( & url , buf + 11 , sizeof ( buf ) - 11 , 0 ) ; mutt_str_strcat ( buf , sizeof ( buf ) , ""\\"""" ) ; mutt_buffer_init ( & token ) ; mutt_buffer_init ( & err ) ; err . data = errstr ; err . dsize = sizeof ( errstr ) ; if ( mutt_parse_rc_line ( buf , & token , & err ) ) mutt_debug ( 1 , ""Error<S2SV_blank>adding<S2SV_blank>subscribed<S2SV_blank>mailbox:<S2SV_blank>%s\\n"" , errstr ) ; FREE ( & token . data ) ; }
","<S2SV_ModStart> list . name , true
"
700,"CWE-399 static int process_one_ticket ( struct ceph_auth_client * ac , struct ceph_crypto_key * secret , <S2SV_StartBug> void * * p , void * end , <S2SV_EndBug> void * dbuf , void * ticket_buf ) { struct ceph_x_info * xi = ac -> private ; int type ; u8 tkt_struct_v , blob_struct_v ; struct ceph_x_ticket_handler * th ; <S2SV_StartBug> void * dp , * dend ; <S2SV_EndBug> int dlen ; char is_enc ; struct timespec validity ; <S2SV_StartBug> struct ceph_crypto_key old_key ; <S2SV_EndBug> void * tp , * tpend ; struct ceph_timespec new_validity ; struct ceph_crypto_key new_session_key ; struct ceph_buffer * new_ticket_blob ; unsigned long new_expires , new_renew_after ; u64 new_secret_id ; int ret ; ceph_decode_need ( p , end , sizeof ( u32 ) + 1 , bad ) ; type = ceph_decode_32 ( p ) ; dout ( ""<S2SV_blank>ticket<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>%s\\n"" , type , ceph_entity_type_name ( type ) ) ; tkt_struct_v = ceph_decode_8 ( p ) ; if ( tkt_struct_v != 1 ) goto bad ; th = get_ticket_handler ( ac , type ) ; if ( IS_ERR ( th ) ) { ret = PTR_ERR ( th ) ; goto out ; } <S2SV_StartBug> dlen = ceph_x_decrypt ( secret , p , end , dbuf , <S2SV_EndBug> TEMP_TICKET_BUF_LEN ) ; if ( dlen <= 0 ) { ret = dlen ; goto out ; } dout ( ""<S2SV_blank>decrypted<S2SV_blank>%d<S2SV_blank>bytes\\n"" , dlen ) ; dp = dbuf ; dend = dp + dlen ; tkt_struct_v = ceph_decode_8 ( & dp ) ; if ( tkt_struct_v != 1 ) goto bad ; memcpy ( & old_key , & th -> session_key , sizeof ( old_key ) ) ; ret = ceph_crypto_key_decode ( & new_session_key , & dp , dend ) ; if ( ret ) goto out ; ceph_decode_copy ( & dp , & new_validity , sizeof ( new_validity ) ) ; ceph_decode_timespec ( & validity , & new_validity ) ; new_expires = get_seconds ( ) + validity . tv_sec ; new_renew_after = new_expires - ( validity . tv_sec / 4 ) ; dout ( ""<S2SV_blank>expires=%lu<S2SV_blank>renew_after=%lu\\n"" , new_expires , new_renew_after ) ; ceph_decode_8_safe ( p , end , is_enc , bad ) ; <S2SV_StartBug> tp = ticket_buf ; <S2SV_EndBug> if ( is_enc ) { dout ( ""<S2SV_blank>encrypted<S2SV_blank>ticket\\n"" ) ; dlen = ceph_x_decrypt ( & old_key , p , end , ticket_buf , TEMP_TICKET_BUF_LEN ) ; if ( dlen < 0 ) { ret = dlen ; goto out ; <S2SV_StartBug> } <S2SV_EndBug> dlen = ceph_decode_32 ( & tp ) ; } else { ceph_decode_32_safe ( p , end , dlen , bad ) ; <S2SV_StartBug> ceph_decode_need ( p , end , dlen , bad ) ; <S2SV_EndBug> ceph_decode_copy ( p , ticket_buf , dlen ) ; } tpend = tp + dlen ; dout ( ""<S2SV_blank>ticket<S2SV_blank>blob<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes\\n"" , dlen ) ; ceph_decode_need ( & tp , tpend , 1 + sizeof ( u64 ) , bad ) ; blob_struct_v = ceph_decode_8 ( & tp ) ; new_secret_id = ceph_decode_64 ( & tp ) ; ret = ceph_decode_buffer ( & new_ticket_blob , & tp , tpend ) ; if ( ret ) goto out ; ceph_crypto_key_destroy ( & th -> session_key ) ; if ( th -> ticket_blob ) ceph_buffer_put ( th -> ticket_blob ) ; th -> session_key = new_session_key ; th -> ticket_blob = new_ticket_blob ; th -> validity = new_validity ; th -> secret_id = new_secret_id ; th -> expires = new_expires ; th -> renew_after = new_renew_after ; dout ( ""<S2SV_blank>got<S2SV_blank>ticket<S2SV_blank>service<S2SV_blank>%d<S2SV_blank>(%s)<S2SV_blank>secret_id<S2SV_blank>%lld<S2SV_blank>len<S2SV_blank>%d\\n"" , type , ceph_entity_type_name ( type ) , th -> secret_id , ( int ) th -> ticket_blob -> vec . iov_len ) ; xi -> have_keys |= th -> service ; out : <S2SV_StartBug> return ret ; <S2SV_EndBug> bad : ret = - EINVAL ; goto out ; }
","<S2SV_ModStart> void * end <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; void * dbuf = NULL ; void * <S2SV_ModStart> struct ceph_crypto_key old_key ; void * ticket_buf = NULL <S2SV_ModStart> , end , & dbuf , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> bad ) ; if ( is_enc ) { dout ( ""<S2SV_blank>encrypted<S2SV_blank>ticket\\n"" ) ; dlen = ceph_x_decrypt ( & old_key , p , end , & ticket_buf , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> out ; } tp = ticket_buf ; <S2SV_ModStart> bad ) ; ticket_buf = kmalloc ( dlen , GFP_NOFS ) ; if ( ! ticket_buf ) { ret = - ENOMEM ; goto out ; } tp = ticket_buf ; <S2SV_ModStart> ; out : kfree ( ticket_buf ) ; kfree ( dbuf ) ;
"
701,"CWE-189 Datum hstore_from_array ( PG_FUNCTION_ARGS ) { ArrayType * in_array = PG_GETARG_ARRAYTYPE_P ( 0 ) ; int ndims = ARR_NDIM ( in_array ) ; int count ; int32 buflen ; HStore * out ; Pairs * pairs ; Datum * in_datums ; bool * in_nulls ; int in_count ; int i ; Assert ( ARR_ELEMTYPE ( in_array ) == TEXTOID ) ; switch ( ndims ) { case 0 : out = hstorePairs ( NULL , 0 , 0 ) ; PG_RETURN_POINTER ( out ) ; case 1 : if ( ( ARR_DIMS ( in_array ) [ 0 ] ) % 2 ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( ""array<S2SV_blank>must<S2SV_blank>have<S2SV_blank>even<S2SV_blank>number<S2SV_blank>of<S2SV_blank>elements"" ) ) ) ; break ; case 2 : if ( ( ARR_DIMS ( in_array ) [ 1 ] ) != 2 ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( ""array<S2SV_blank>must<S2SV_blank>have<S2SV_blank>two<S2SV_blank>columns"" ) ) ) ; break ; default : ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( ""wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>array<S2SV_blank>subscripts"" ) ) ) ; } deconstruct_array ( in_array , TEXTOID , - 1 , false , 'i' , & in_datums , & in_nulls , & in_count ) ; count = in_count / 2 ; <S2SV_StartBug> pairs = palloc ( count * sizeof ( Pairs ) ) ; <S2SV_EndBug> for ( i = 0 ; i < count ; ++ i ) { if ( in_nulls [ i * 2 ] ) ereport ( ERROR , ( errcode ( ERRCODE_NULL_VALUE_NOT_ALLOWED ) , errmsg ( ""null<S2SV_blank>value<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>hstore<S2SV_blank>key"" ) ) ) ; if ( in_nulls [ i * 2 + 1 ] ) { pairs [ i ] . key = VARDATA_ANY ( in_datums [ i * 2 ] ) ; pairs [ i ] . val = NULL ; pairs [ i ] . keylen = hstoreCheckKeyLen ( VARSIZE_ANY_EXHDR ( in_datums [ i * 2 ] ) ) ; pairs [ i ] . vallen = 4 ; pairs [ i ] . isnull = true ; pairs [ i ] . needfree = false ; } else { pairs [ i ] . key = VARDATA_ANY ( in_datums [ i * 2 ] ) ; pairs [ i ] . val = VARDATA_ANY ( in_datums [ i * 2 + 1 ] ) ; pairs [ i ] . keylen = hstoreCheckKeyLen ( VARSIZE_ANY_EXHDR ( in_datums [ i * 2 ] ) ) ; pairs [ i ] . vallen = hstoreCheckValLen ( VARSIZE_ANY_EXHDR ( in_datums [ i * 2 + 1 ] ) ) ; pairs [ i ] . isnull = false ; pairs [ i ] . needfree = false ; } } count = hstoreUniquePairs ( pairs , count , & buflen ) ; out = hstorePairs ( pairs , count , buflen ) ; PG_RETURN_POINTER ( out ) ; }
","<S2SV_ModStart> / 2 ; if ( count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;
"
702,"CWE-000 static void put_prev_task ( struct rq * rq , struct task_struct * prev ) { if ( prev -> se . on_rq ) update_rq_clock ( rq ) ; <S2SV_StartBug> rq -> skip_clock_update = 0 ; <S2SV_EndBug> prev -> sched_class -> put_prev_task ( rq , prev ) ; }
","<S2SV_ModStart> rq ) ; <S2SV_ModEnd> prev -> sched_class
"
703,"CWE-362 int ssl3_get_new_session_ticket ( SSL * s ) { int ok , al , ret = 0 , ticklen ; long n ; const unsigned char * p ; unsigned char * d ; n = s -> method -> ssl_get_message ( s , SSL3_ST_CR_SESSION_TICKET_A , SSL3_ST_CR_SESSION_TICKET_B , SSL3_MT_NEWSESSION_TICKET , 16384 , & ok ) ; if ( ! ok ) return ( ( int ) n ) ; if ( n < 6 ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , SSL_R_LENGTH_MISMATCH ) ; goto f_err ; } p = d = ( unsigned char * ) s -> init_msg ; <S2SV_StartBug> n2l ( p , s -> session -> tlsext_tick_lifetime_hint ) ; <S2SV_EndBug> n2s ( p , ticklen ) ; if ( ticklen + 6 != n ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , SSL_R_LENGTH_MISMATCH ) ; goto f_err ; } OPENSSL_free ( s -> session -> tlsext_tick ) ; s -> session -> tlsext_ticklen = 0 ; s -> session -> tlsext_tick = OPENSSL_malloc ( ticklen ) ; if ( ! s -> session -> tlsext_tick ) { SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , ERR_R_MALLOC_FAILURE ) ; goto err ; } memcpy ( s -> session -> tlsext_tick , p , ticklen ) ; s -> session -> tlsext_ticklen = ticklen ; EVP_Digest ( p , ticklen , s -> session -> session_id , & s -> session -> session_id_length , EVP_sha256 ( ) , NULL ) ; ret = 1 ; return ( ret ) ; f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; err : s -> state = SSL_ST_ERR ; return ( - 1 ) ; }
","<S2SV_ModStart> -> init_msg ; if ( s -> session -> session_id_length > 0 ) { int i = s -> session_ctx -> session_cache_mode ; SSL_SESSION * new_sess ; if ( i & SSL_SESS_CACHE_CLIENT ) { if ( i & SSL_SESS_CACHE_NO_INTERNAL_STORE ) { if ( s -> session_ctx -> remove_session_cb != NULL ) s -> session_ctx -> remove_session_cb ( s -> session_ctx , s -> session ) ; } else { SSL_CTX_remove_session ( s -> session_ctx , s -> session ) ; } } if ( ( new_sess = ssl_session_dup ( s -> session , 0 ) ) == 0 ) { al = SSL_AD_INTERNAL_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , ERR_R_MALLOC_FAILURE ) ; goto f_err ; } SSL_SESSION_free ( s -> session ) ; s -> session = new_sess ; }
"
704,"CWE-772 int button_open ( Button * b ) { char * p , name [ 256 ] ; int r ; assert ( b ) ; b -> fd = safe_close ( b -> fd ) ; p = strjoina ( ""/dev/input/"" , b -> name ) ; b -> fd = open ( p , O_RDWR | O_CLOEXEC | O_NOCTTY | O_NONBLOCK ) ; if ( b -> fd < 0 ) return log_warning_errno ( errno , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%m"" , p ) ; r = button_suitable ( b ) ; if ( r < 0 ) return log_warning_errno ( r , ""Failed<S2SV_blank>to<S2SV_blank>determine<S2SV_blank>whether<S2SV_blank>input<S2SV_blank>device<S2SV_blank>is<S2SV_blank>relevant<S2SV_blank>to<S2SV_blank>us:<S2SV_blank>%m"" ) ; if ( r == 0 ) return log_debug_errno ( SYNTHETIC_ERRNO ( EADDRNOTAVAIL ) , ""Device<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>expose<S2SV_blank>keys<S2SV_blank>or<S2SV_blank>switches<S2SV_blank>relevant<S2SV_blank>to<S2SV_blank>us,<S2SV_blank>ignoring."" , p ) ; if ( ioctl ( b -> fd , EVIOCGNAME ( sizeof ( name ) ) , name ) < 0 ) { r = log_error_errno ( errno , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>input<S2SV_blank>name:<S2SV_blank>%m"" ) ; goto fail ; } ( void ) button_set_mask ( b ) ; <S2SV_StartBug> r = sd_event_add_io ( b -> manager -> event , & b -> io_event_source , b -> fd , EPOLLIN , button_dispatch , b ) ; <S2SV_EndBug> if ( r < 0 ) { log_error_errno ( r , ""Failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>button<S2SV_blank>event:<S2SV_blank>%m"" ) ; goto fail ; } log_info ( ""Watching<S2SV_blank>system<S2SV_blank>buttons<S2SV_blank>on<S2SV_blank>/dev/input/%s<S2SV_blank>(%s)"" , b -> name , name ) ; return 0 ; fail : b -> fd = safe_close ( b -> fd ) ; return r ; }
","<S2SV_ModStart> b ) ; b -> io_event_source = sd_event_source_unref ( b -> io_event_source ) ;
"
705,"CWE-119 int test ( char * URL ) { int errors = 0 ; ( void ) URL ; errors += test_weird_arguments ( ) ; errors += test_unsigned_short_formatting ( ) ; errors += test_signed_short_formatting ( ) ; errors += test_unsigned_int_formatting ( ) ; errors += test_signed_int_formatting ( ) ; errors += test_unsigned_long_formatting ( ) ; errors += test_signed_long_formatting ( ) ; errors += test_curl_off_t_formatting ( ) ; errors += test_string_formatting ( ) ; <S2SV_StartBug> if ( errors ) <S2SV_EndBug> return TEST_ERR_MAJOR_BAD ; else return 0 ; }
","<S2SV_ModStart> ( ) ; errors += test_float_formatting ( ) ;
"
706,"CWE-476 bool ExprResolveLhs ( struct xkb_context * ctx , const ExprDef * expr , const char * * elem_rtrn , const char * * field_rtrn , ExprDef * * index_rtrn ) { switch ( expr -> expr . op ) { case EXPR_IDENT : * elem_rtrn = NULL ; * field_rtrn = xkb_atom_text ( ctx , expr -> ident . ident ) ; * index_rtrn = NULL ; return ( * field_rtrn != NULL ) ; case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> field_ref . field ) ; * index_rtrn = NULL ; <S2SV_StartBug> return true ; <S2SV_EndBug> case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> array_ref . field ) ; * index_rtrn = expr -> array_ref . entry ; <S2SV_StartBug> return true ; <S2SV_EndBug> default : break ; } log_wsgo ( ctx , ""Unexpected<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveLhs\\n"" , expr -> expr . op ) ; return false ; }
","<S2SV_ModStart> NULL ; return ( * elem_rtrn != NULL && * field_rtrn != NULL ) <S2SV_ModEnd> ; case EXPR_ARRAY_REF <S2SV_ModStart> . entry ; if ( expr -> array_ref . element != XKB_ATOM_NONE && * elem_rtrn == NULL ) return false ; if ( * field_rtrn == NULL ) return false ;
"
707,"CWE-000 static void sas_scsi_clear_queue_lu ( struct list_head * error_q , struct scsi_cmnd * my_cmd ) { struct scsi_cmnd * cmd , * n ; list_for_each_entry_safe ( cmd , n , error_q , eh_entry ) { if ( cmd -> device -> sdev_target == my_cmd -> device -> sdev_target && cmd -> device -> lun == my_cmd -> device -> lun ) <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> -> lun ) sas_eh_finish_cmd <S2SV_ModEnd> ( cmd )
"
708,"CWE-125 static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n0 , asdl_seq * decorator_seq , bool is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; int end_lineno , end_col_offset ; <S2SV_StartBug> REQ ( n , funcdef ) ; <S2SV_EndBug> name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } <S2SV_StartBug> body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; <S2SV_EndBug> if ( ! body ) return NULL ; get_last_end_pos ( body , & end_lineno , & end_col_offset ) ; <S2SV_StartBug> if ( is_async ) <S2SV_EndBug> <S2SV_StartBug> return AsyncFunctionDef ( name , args , body , decorator_seq , returns , <S2SV_EndBug> LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; else <S2SV_StartBug> return FunctionDef ( name , args , body , decorator_seq , returns , <S2SV_EndBug> LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; }
","<S2SV_ModStart> , end_col_offset ; node * tc ; string type_comment = NULL ; <S2SV_ModStart> 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; if ( ! type_comment ) return NULL ; name_i += 1 ; } <S2SV_ModStart> ; if ( NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) { if ( type_comment != NULL ) { ast_error ( c , n , ""Cannot<S2SV_blank>have<S2SV_blank>two<S2SV_blank>type<S2SV_blank>comments<S2SV_blank>on<S2SV_blank>def"" ) ; return NULL ; } type_comment = NEW_TYPE_COMMENT ( tc ) ; if ( ! type_comment ) return NULL ; } } if ( <S2SV_ModStart> decorator_seq , returns , type_comment <S2SV_ModStart> , returns , type_comment ,
"
709,"CWE-416 int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
","<S2SV_ModStart> err = 0 ; if ( ! net_eq ( current -> nsproxy -> net_ns , sock_net ( sk ) ) ) return - EINVAL
"
710,"CWE-20 static int encrypt ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) { struct blkcipher_walk walk ; struct crypto_blkcipher * tfm = desc -> tfm ; struct salsa20_ctx * ctx = crypto_blkcipher_ctx ( tfm ) ; int err ; blkcipher_walk_init ( & walk , dst , src , nbytes ) ; err = blkcipher_walk_virt_block ( desc , & walk , 64 ) ; salsa20_ivsetup ( ctx , walk . iv ) ; <S2SV_StartBug> if ( likely ( walk . nbytes == nbytes ) ) <S2SV_EndBug> { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , nbytes ) ; return blkcipher_walk_done ( desc , & walk , 0 ) ; } while ( walk . nbytes >= 64 ) { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , walk . nbytes - ( walk . nbytes % 64 ) ) ; err = blkcipher_walk_done ( desc , & walk , walk . nbytes % 64 ) ; } if ( walk . nbytes ) { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , walk . nbytes ) ; err = blkcipher_walk_done ( desc , & walk , 0 ) ; } return err ; }
","<S2SV_ModStart> iv ) ; <S2SV_ModEnd> while ( walk
"
711,"CWE-200 static int vsock_stream_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk ; struct vsock_sock * vsk ; int err ; size_t target ; ssize_t copied ; long timeout ; struct vsock_transport_recv_notify_data recv_data ; DEFINE_WAIT ( wait ) ; sk = sock -> sk ; vsk = vsock_sk ( sk ) ; err = 0 ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> if ( sk -> sk_state != SS_CONNECTED ) { if ( sock_flag ( sk , SOCK_DONE ) ) err = 0 ; else err = - ENOTCONN ; goto out ; } if ( flags & MSG_OOB ) { err = - EOPNOTSUPP ; goto out ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { err = 0 ; goto out ; } if ( ! len ) { err = 0 ; goto out ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; if ( target >= transport -> stream_rcvhiwat ( vsk ) ) { err = - ENOMEM ; goto out ; } timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; copied = 0 ; err = transport -> notify_recv_init ( vsk , target , & recv_data ) ; if ( err < 0 ) goto out ; prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; while ( 1 ) { s64 ready = vsock_stream_has_data ( vsk ) ; if ( ready < 0 ) { err = - ENOMEM ; goto out_wait ; } else if ( ready > 0 ) { ssize_t read ; err = transport -> notify_recv_pre_dequeue ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; read = transport -> stream_dequeue ( vsk , msg -> msg_iov , len - copied , flags ) ; if ( read < 0 ) { err = - ENOMEM ; break ; } copied += read ; err = transport -> notify_recv_post_dequeue ( vsk , target , read , ! ( flags & MSG_PEEK ) , & recv_data ) ; if ( err < 0 ) goto out_wait ; if ( read >= target || flags & MSG_PEEK ) break ; target -= read ; } else { if ( sk -> sk_err != 0 || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || ( vsk -> peer_shutdown & SEND_SHUTDOWN ) ) { break ; } if ( timeout == 0 ) { err = - EAGAIN ; break ; } err = transport -> notify_recv_pre_block ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; release_sock ( sk ) ; timeout = schedule_timeout ( timeout ) ; lock_sock ( sk ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeout ) ; break ; } else if ( timeout == 0 ) { err = - EAGAIN ; break ; } prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; } } if ( sk -> sk_err ) err = - sk -> sk_err ; else if ( sk -> sk_shutdown & RCV_SHUTDOWN ) err = 0 ; if ( copied > 0 ) { if ( ! ( flags & MSG_PEEK ) ) { if ( vsk -> peer_shutdown & SEND_SHUTDOWN ) { if ( vsock_stream_has_data ( vsk ) <= 0 ) { sk -> sk_state = SS_UNCONNECTED ; sock_set_flag ( sk , SOCK_DONE ) ; sk -> sk_state_change ( sk ) ; } } } err = copied ; } out_wait : finish_wait ( sk_sleep ( sk ) , & wait ) ; out : release_sock ( sk ) ; return err ; }
","<S2SV_ModStart> = 0 ; msg -> msg_namelen = 0 ;
"
712,"CWE-119 int my_csr_reader ( const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , REALTYPE * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , ""r"" ) ; if ( l_csr_file_handle == NULL ) { fprintf ( stderr , ""cannot<S2SV_blank>open<S2SV_blank>CSR<S2SV_blank>file!\\n"" ) ; return - 1 ; } while ( fgets ( l_line , l_line_length , l_csr_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>file<S2SV_blank>length!\\n"" ) ; return - 1 ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { <S2SV_StartBug> if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; * o_values = ( REALTYPE * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_row_idx_id = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count ) ) ; if ( ( * o_row_idx == NULL ) || ( * o_column_idx == NULL ) || ( * o_values == NULL ) || ( l_row_idx_id == NULL ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>sp<S2SV_blank>data!\\n"" ) ; return - 1 ; } memset ( * o_row_idx , 0 , sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; memset ( * o_column_idx , 0 , sizeof ( unsigned int ) * ( * o_element_count ) ) ; memset ( * o_values , 0 , sizeof ( double ) * ( * o_element_count ) ) ; memset ( l_row_idx_id , 0 , sizeof ( unsigned int ) * ( * o_row_count ) ) ; for ( l_i = 0 ; l_i < ( * o_row_count + 1 ) ; l_i ++ ) ( * o_row_idx ) [ l_i ] = ( * o_element_count ) ; ( * o_row_idx ) [ 0 ] = 0 ; l_i = 0 ; l_header_read = 1 ; } else { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>csr<S2SV_blank>description!\\n"" ) ; return - 1 ; } } else { unsigned int l_row , l_column ; REALTYPE l_value ; if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%lf"" , & l_row , & l_column , & l_value ) != 3 ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>element!\\n"" ) ; return - 1 ; } l_row -- ; l_column -- ; ( * o_column_idx ) [ l_i ] = l_column ; ( * o_values ) [ l_i ] = l_value ; l_i ++ ; l_row_idx_id [ l_row ] = 1 ; ( * o_row_idx ) [ l_row + 1 ] = l_i ; } } } fclose ( l_csr_file_handle ) ; if ( l_i != ( * o_element_count ) ) { fprintf ( stderr , ""we<S2SV_blank>were<S2SV_blank>not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>read<S2SV_blank>all<S2SV_blank>elements!\\n"" ) ; return - 1 ; } for ( l_i = 0 ; l_i < ( * o_row_count ) ; l_i ++ ) { if ( l_row_idx_id [ l_i ] == 0 ) { ( * o_row_idx ) [ l_i + 1 ] = ( * o_row_idx ) [ l_i ] ; } } if ( l_row_idx_id != NULL ) { free ( l_row_idx_id ) ; } return 0 ; }
","<S2SV_ModStart> { if ( 3 == <S2SV_ModStart> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> { * o_column_idx
"
713,"CWE-787 static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; one = 1 ; image = AcquireImage ( image_info , exception ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , ""EncryptedWPGImageFileNotSupported"" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> resolution . x = BitmapHeader1 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> resolution . x = BitmapHeader2 . HorzRes / 470.0 ; image -> resolution . y = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; UnpackRaster : if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; <S2SV_StartBug> image -> columns = image -> rows = 0 ; <S2SV_EndBug> image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; image -> rows = Bitmap2Header1 . Height ; if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { size_t one ; one = 1 ; image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( image , BImgBuff , i , bpp , exception ) ; } if ( BImgBuff ) <S2SV_StartBug> BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ; <S2SV_EndBug> break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ( void ) RemoveLastImageFromList ( & image ) ; AppendImageToList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image , exception ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; } } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , ""ImageFileDoesNotContainAnyImageData"" ) ; return ( image ) ; }
","<S2SV_ModStart> -> rows = 1 <S2SV_ModEnd> ; image -> <S2SV_ModStart> ( BImgBuff ) <S2SV_ModEnd> ; break ;
"
714,"CWE-264 static int em_loop ( struct x86_emulate_ctxt * ctxt ) <S2SV_StartBug> { <S2SV_EndBug> register_address_increment ( ctxt , reg_rmw ( ctxt , VCPU_REGS_RCX ) , - 1 ) ; if ( ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) != 0 ) && ( ctxt -> b == 0xe2 || test_cc ( ctxt -> b ^ 0x5 , ctxt -> eflags ) ) ) <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> }
","<S2SV_ModStart> ctxt ) { int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> ) ) ) rc = <S2SV_ModStart> ) ; return rc <S2SV_ModEnd> ; } <S2SV_null>
"
715,"CWE-119 void cJSON_AddItemReferenceToArray ( cJSON * array , cJSON * item ) { cJSON_AddItemToArray ( array , create_reference ( item ) ) ; }
","
"
716,"CWE-476 static int hi3660_stub_clk_probe ( struct platform_device * pdev ) { struct device * dev = & pdev -> dev ; struct resource * res ; unsigned int i ; int ret ; stub_clk_chan . cl . dev = dev ; stub_clk_chan . cl . tx_done = NULL ; stub_clk_chan . cl . tx_block = false ; stub_clk_chan . cl . knows_txdone = false ; stub_clk_chan . mbox = mbox_request_channel ( & stub_clk_chan . cl , 0 ) ; if ( IS_ERR ( stub_clk_chan . mbox ) ) return PTR_ERR ( stub_clk_chan . mbox ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; <S2SV_StartBug> freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ; <S2SV_EndBug> if ( ! freq_reg ) return - ENOMEM ; freq_reg += HI3660_STUB_CLOCK_DATA ; for ( i = 0 ; i < HI3660_CLK_STUB_NUM ; i ++ ) { ret = devm_clk_hw_register ( & pdev -> dev , & hi3660_stub_clks [ i ] . hw ) ; if ( ret ) return ret ; } return devm_of_clk_add_hw_provider ( & pdev -> dev , hi3660_stub_clk_hw_get , hi3660_stub_clks ) ; }
","<S2SV_ModStart> 0 ) ; if ( ! res ) return - EINVAL ;
"
717,"CWE-119 static void header_seek ( SF_PRIVATE * psf , sf_count_t position , int whence ) { switch ( whence ) { case SEEK_SET : <S2SV_StartBug> if ( position > SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> { psf_fseek ( psf , position , whence ) ; return ; } ; <S2SV_StartBug> if ( position > psf -> headend ) <S2SV_EndBug> <S2SV_StartBug> psf -> headend += psf_fread ( psf -> header + psf -> headend , 1 , position - psf -> headend , psf ) ; <S2SV_EndBug> psf -> headindex = position ; break ; case SEEK_CUR : <S2SV_StartBug> if ( psf -> headindex + position < 0 ) <S2SV_EndBug> break ; <S2SV_StartBug> if ( psf -> headindex >= SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> { psf_fseek ( psf , position , whence ) ; return ; } ; <S2SV_StartBug> if ( psf -> headindex + position <= psf -> headend ) <S2SV_EndBug> { psf -> headindex += position ; break ; } ; <S2SV_StartBug> if ( psf -> headindex + position > SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> { <S2SV_StartBug> psf -> headindex = psf -> headend ; <S2SV_EndBug> psf_fseek ( psf , position , SEEK_CUR ) ; break ; } ; <S2SV_StartBug> psf -> headend += psf_fread ( psf -> header + psf -> headend , 1 , position - ( psf -> headend - psf -> headindex ) , psf ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex = psf -> headend ; <S2SV_EndBug> break ; case SEEK_END : default : psf_log_printf ( psf , ""Bad<S2SV_blank>whence<S2SV_blank>param<S2SV_blank>in<S2SV_blank>header_seek().\\n"" ) ; break ; } ; return ; }
","<S2SV_ModStart> : if ( psf -> header . indx + position >= psf -> header . len ) psf_bump_header_allocation ( psf , position ) ; if ( position > psf -> header . len <S2SV_ModEnd> ) { psf_fseek <S2SV_ModStart> > psf -> header . end ) psf -> header . end <S2SV_ModEnd> += psf_fread ( <S2SV_ModStart> psf -> header . ptr + psf -> header . end <S2SV_ModEnd> , 1 , <S2SV_ModStart> - psf -> header . end , psf ) ; psf -> header . indx <S2SV_ModEnd> = position ; <S2SV_ModStart> ( psf -> header . indx + position >= psf -> header . len ) psf_bump_header_allocation ( psf , position ) ; if ( psf -> header . indx <S2SV_ModEnd> + position < <S2SV_ModStart> ( psf -> header . indx >= psf -> header . len <S2SV_ModEnd> ) { psf_fseek <S2SV_ModStart> ( psf -> header . indx <S2SV_ModEnd> + position <= <S2SV_ModStart> <= psf -> header . end ) { psf -> header . indx <S2SV_ModEnd> += position ; <S2SV_ModStart> ( psf -> header . indx <S2SV_ModEnd> + position > <S2SV_ModStart> + position > psf -> header . len ) { psf -> header . indx <S2SV_ModEnd> = psf -> <S2SV_ModStart> = psf -> header . end <S2SV_ModEnd> ; psf_fseek ( <S2SV_ModStart> ; psf -> header . end <S2SV_ModEnd> += psf_fread ( <S2SV_ModStart> psf -> header . ptr + psf -> header . end <S2SV_ModEnd> , 1 , <S2SV_ModStart> ( psf -> header . end <S2SV_ModEnd> - psf -> <S2SV_ModStart> - psf -> header . indx ) , psf ) ; psf -> header . indx <S2SV_ModEnd> = psf -> <S2SV_ModStart> = psf -> header . end <S2SV_ModEnd> ; break ;
"
718,"CWE-362 int ext4_collapse_range ( struct inode * inode , loff_t offset , loff_t len ) { struct super_block * sb = inode -> i_sb ; ext4_lblk_t punch_start , punch_stop ; handle_t * handle ; unsigned int credits ; loff_t new_size , ioffset ; int ret ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) return - EOPNOTSUPP ; if ( offset & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) || len & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) ) return - EINVAL ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; trace_ext4_collapse_range ( inode , offset , len ) ; punch_start = offset >> EXT4_BLOCK_SIZE_BITS ( sb ) ; punch_stop = ( offset + len ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } ioffset = round_down ( offset , PAGE_SIZE ) ; ret = filemap_write_and_wait_range ( inode -> i_mapping , ioffset , LLONG_MAX ) ; if ( ret ) return ret ; mutex_lock ( & inode -> i_mutex ) ; if ( offset + len >= i_size_read ( inode ) ) { ret = - EINVAL ; goto out_mutex ; } if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } <S2SV_StartBug> truncate_pagecache ( inode , ioffset ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> inode_dio_wait ( inode ) ; credits = ext4_writepage_trans_blocks ( inode ) ; handle = ext4_journal_start ( inode , EXT4_HT_TRUNCATE , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; <S2SV_StartBug> goto out_dio ; <S2SV_EndBug> } down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_discard_preallocations ( inode ) ; ret = ext4_es_remove_extent ( inode , punch_start , EXT_MAX_BLOCKS - punch_start ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } ret = ext4_ext_remove_space ( inode , punch_start , punch_stop - 1 ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } ext4_discard_preallocations ( inode ) ; ret = ext4_ext_shift_extents ( inode , handle , punch_stop , punch_stop - punch_start , SHIFT_LEFT ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } new_size = i_size_read ( inode ) - len ; i_size_write ( inode , new_size ) ; EXT4_I ( inode ) -> i_disksize = new_size ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ext4_mark_inode_dirty ( handle , inode ) ; out_stop : ext4_journal_stop ( handle ) ; <S2SV_StartBug> out_dio : <S2SV_EndBug> ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }
","<S2SV_ModStart> out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ioffset ) ; <S2SV_ModEnd> credits = ext4_writepage_trans_blocks <S2SV_ModStart> ) ; goto out_mmap <S2SV_ModEnd> ; } down_write <S2SV_ModStart> handle ) ; out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModEnd> ext4_inode_resume_unlocked_dio ( inode
"
719,"CWE-125 struct _mdi * _WM_ParseNewMidi ( uint8_t * midi_data , uint32_t midi_size ) { struct _mdi * mdi ; uint32_t tmp_val ; uint32_t midi_type ; <S2SV_StartBug> uint32_t track_size ; <S2SV_EndBug> uint8_t * * tracks ; uint32_t end_of_tracks = 0 ; uint32_t no_tracks ; uint32_t i ; uint32_t divisions = 96 ; uint32_t tempo = 500000 ; float samples_per_delta_f = 0.0 ; uint32_t sample_count = 0 ; float sample_count_f = 0.0 ; float sample_remainder = 0.0 ; uint8_t * sysex_store = NULL ; uint32_t * track_delta ; uint8_t * track_end ; uint32_t smallest_delta = 0 ; uint32_t subtract_delta = 0 ; uint8_t * running_event ; uint32_t setup_ret = 0 ; if ( midi_size < 14 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; return ( NULL ) ; } if ( ! memcmp ( midi_data , ""RIFF"" , 4 ) ) { if ( midi_size < 34 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; return ( NULL ) ; } midi_data += 20 ; midi_size -= 20 ; } if ( memcmp ( midi_data , ""MThd"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MIDI , NULL , 0 ) ; return ( NULL ) ; } midi_data += 4 ; midi_size -= 4 ; tmp_val = * midi_data ++ << 24 ; tmp_val |= * midi_data ++ << 16 ; tmp_val |= * midi_data ++ << 8 ; tmp_val |= * midi_data ++ ; midi_size -= 4 ; if ( tmp_val != 6 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , NULL , 0 ) ; return ( NULL ) ; } tmp_val = * midi_data ++ << 8 ; tmp_val |= * midi_data ++ ; midi_size -= 2 ; if ( tmp_val > 2 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_INVALID , NULL , 0 ) ; return ( NULL ) ; } midi_type = tmp_val ; tmp_val = * midi_data ++ << 8 ; tmp_val |= * midi_data ++ ; midi_size -= 2 ; if ( tmp_val < 1 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(no<S2SV_blank>tracks)"" , 0 ) ; return ( NULL ) ; } no_tracks = tmp_val ; if ( ( midi_type == 0 ) && ( no_tracks > 1 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_INVALID , ""(expected<S2SV_blank>1<S2SV_blank>track<S2SV_blank>for<S2SV_blank>type<S2SV_blank>0<S2SV_blank>midi<S2SV_blank>file,<S2SV_blank>found<S2SV_blank>more)"" , 0 ) ; return ( NULL ) ; } divisions = * midi_data ++ << 8 ; divisions |= * midi_data ++ ; midi_size -= 2 ; if ( divisions & 0x00008000 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_INVALID , NULL , 0 ) ; return ( NULL ) ; } samples_per_delta_f = _WM_GetSamplesPerTick ( divisions , tempo ) ; mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( mdi , divisions ) ; tracks = malloc ( sizeof ( uint8_t * ) * no_tracks ) ; <S2SV_StartBug> track_delta = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_EndBug> track_end = malloc ( sizeof ( uint8_t ) * no_tracks ) ; running_event = malloc ( sizeof ( uint8_t ) * no_tracks ) ; smallest_delta = 0xffffffff ; for ( i = 0 ; i < no_tracks ; i ++ ) { if ( midi_size < 8 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } if ( memcmp ( midi_data , ""MTrk"" , 4 ) != 0 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>track<S2SV_blank>header)"" , 0 ) ; goto _end ; } midi_data += 4 ; midi_size -= 4 ; <S2SV_StartBug> track_size = * midi_data ++ << 24 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ << 16 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ << 8 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ ; <S2SV_EndBug> midi_size -= 4 ; <S2SV_StartBug> if ( midi_size < track_size ) { <S2SV_EndBug> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_StartBug> if ( track_size < 3 ) { <S2SV_EndBug> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(bad<S2SV_blank>track<S2SV_blank>size)"" , 0 ) ; goto _end ; } <S2SV_StartBug> if ( ( midi_data [ track_size - 3 ] != 0xFF ) <S2SV_EndBug> <S2SV_StartBug> || ( midi_data [ track_size - 2 ] != 0x2F ) <S2SV_EndBug> <S2SV_StartBug> || ( midi_data [ track_size - 1 ] != 0x00 ) ) { <S2SV_EndBug> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>EOT)"" , 0 ) ; goto _end ; } tracks [ i ] = midi_data ; <S2SV_StartBug> midi_data += track_size ; <S2SV_EndBug> <S2SV_StartBug> midi_size -= track_size ; <S2SV_EndBug> track_end [ i ] = 0 ; running_event [ i ] = 0 ; track_delta [ i ] = 0 ; while ( * tracks [ i ] > 0x7F ) { track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; tracks [ i ] ++ ; <S2SV_StartBug> } <S2SV_EndBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> if ( midi_type == 1 ) { if ( track_delta [ i ] < smallest_delta ) { smallest_delta = track_delta [ i ] ; } } else { if ( i == 0 ) smallest_delta = track_delta [ i ] ; } } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mdi -> events [ mdi -> event_count - 1 ] . samples_to_next += sample_count ; mdi -> extra_info . approx_total_samples += sample_count ; if ( midi_type == 1 ) { while ( end_of_tracks != no_tracks ) { smallest_delta = 0 ; for ( i = 0 ; i < no_tracks ; i ++ ) { if ( track_end [ i ] ) continue ; if ( track_delta [ i ] ) { track_delta [ i ] -= subtract_delta ; if ( track_delta [ i ] ) { if ( ( ! smallest_delta ) || ( smallest_delta > track_delta [ i ] ) ) { smallest_delta = track_delta [ i ] ; } continue ; } } do { <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <S2SV_EndBug> if ( setup_ret == 0 ) { goto _end ; } if ( tracks [ i ] [ 0 ] > 0x7f ) { if ( tracks [ i ] [ 0 ] < 0xf0 ) { running_event [ i ] = tracks [ i ] [ 0 ] ; } else if ( ( tracks [ i ] [ 0 ] == 0xf0 ) || ( tracks [ i ] [ 0 ] == 0xf7 ) ) { running_event [ i ] = 0 ; } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x2f ) && ( tracks [ i ] [ 2 ] == 0x00 ) ) { end_of_tracks ++ ; track_end [ i ] = 1 ; tracks [ i ] += 3 ; <S2SV_StartBug> goto NEXT_TRACK ; <S2SV_EndBug> } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x51 ) && ( tracks [ i ] [ 2 ] == 0x03 ) ) { tempo = ( tracks [ i ] [ 3 ] << 16 ) + ( tracks [ i ] [ 4 ] << 8 ) + tracks [ i ] [ 5 ] ; if ( ! tempo ) tempo = 500000 ; samples_per_delta_f = _WM_GetSamplesPerTick ( divisions , tempo ) ; } } tracks [ i ] += setup_ret ; <S2SV_StartBug> if ( * tracks [ i ] > 0x7f ) { <S2SV_EndBug> do { <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> tracks [ i ] ++ ; <S2SV_StartBug> } while ( * tracks [ i ] > 0x7f ) ; <S2SV_EndBug> } <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> } while ( ! track_delta [ i ] ) ; if ( ( ! smallest_delta ) || ( smallest_delta > track_delta [ i ] ) ) { smallest_delta = track_delta [ i ] ; } NEXT_TRACK : continue ; } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mdi -> events [ mdi -> event_count - 1 ] . samples_to_next += sample_count ; mdi -> extra_info . approx_total_samples += sample_count ; } } else { if ( midi_type == 2 ) { mdi -> is_type2 = 1 ; } sample_remainder = 0.0 ; for ( i = 0 ; i < no_tracks ; i ++ ) { running_event [ i ] = 0 ; do { <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <S2SV_EndBug> if ( setup_ret == 0 ) { goto _end ; } if ( tracks [ i ] [ 0 ] > 0x7f ) { if ( tracks [ i ] [ 0 ] < 0xf0 ) { running_event [ i ] = tracks [ i ] [ 0 ] ; } else if ( ( tracks [ i ] [ 0 ] == 0xf0 ) || ( tracks [ i ] [ 0 ] == 0xf7 ) ) { running_event [ i ] = 0 ; } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x2f ) && ( tracks [ i ] [ 2 ] == 0x00 ) ) { track_end [ i ] = 1 ; goto NEXT_TRACK2 ; } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x51 ) && ( tracks [ i ] [ 2 ] == 0x03 ) ) { tempo = ( tracks [ i ] [ 3 ] << 16 ) + ( tracks [ i ] [ 4 ] << 8 ) + tracks [ i ] [ 5 ] ; if ( ! tempo ) tempo = 500000 ; samples_per_delta_f = _WM_GetSamplesPerTick ( divisions , tempo ) ; } } tracks [ i ] += setup_ret ; <S2SV_StartBug> track_delta [ i ] = 0 ; <S2SV_EndBug> if ( * tracks [ i ] > 0x7f ) { do { <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> tracks [ i ] ++ ; <S2SV_StartBug> } while ( * tracks [ i ] > 0x7f ) ; <S2SV_EndBug> } <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> sample_count_f = ( ( ( float ) track_delta [ i ] * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mdi -> events [ mdi -> event_count - 1 ] . samples_to_next += sample_count ; mdi -> extra_info . approx_total_samples += sample_count ; NEXT_TRACK2 : smallest_delta = track_delta [ i ] ; UNUSED ( smallest_delta ) ; } while ( track_end [ i ] == 0 ) ; } } if ( ( mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""to<S2SV_blank>init<S2SV_blank>reverb"" , 0 ) ; goto _end ; } mdi -> extra_info . current_sample = 0 ; mdi -> current_event = & mdi -> events [ 0 ] ; mdi -> samples_to_mix = 0 ; mdi -> note = NULL ; _WM_ResetToStart ( mdi ) ; _end : free ( sysex_store ) ; free ( track_end ) ; free ( track_delta ) ; free ( running_event ) ; free ( tracks ) ; <S2SV_StartBug> if ( mdi -> reverb ) return ( mdi ) ; <S2SV_EndBug> _WM_freeMDI ( mdi ) ; return ( NULL ) ; }
","<S2SV_ModStart> uint32_t midi_type ; uint8_t * * tracks ; uint32_t * track_size <S2SV_ModEnd> ; uint32_t end_of_tracks <S2SV_ModStart> no_tracks ) ; track_size = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_ModStart> -= 4 ; tmp_val <S2SV_ModEnd> = * midi_data <S2SV_ModStart> << 24 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 16 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 8 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> ( midi_size < tmp_val <S2SV_ModEnd> ) { _WM_GLOBAL_ERROR <S2SV_ModStart> } if ( tmp_val <S2SV_ModEnd> < 3 ) <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 3 ] <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 2 ] <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 1 ] <S2SV_ModStart> = midi_data ; track_size [ i ] = tmp_val ; midi_data += tmp_val <S2SV_ModEnd> ; midi_size -= <S2SV_ModStart> ; midi_size -= tmp_val <S2SV_ModEnd> ; track_end [ <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> i ] , track_size [ i ] , <S2SV_ModStart> += 3 ; track_size [ i ] -= 3 ; <S2SV_ModStart> += setup_ret ; track_size [ i ] -= setup_ret ; <S2SV_ModStart> { do { if ( ! track_size [ i ] ) break ; <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> ) ; } if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> i ] , track_size [ i ] , <S2SV_ModStart> += setup_ret ; track_size [ i ] -= setup_ret ; <S2SV_ModStart> { do { if ( ! track_size [ i ] ) break ; <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> ) ; } if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> tracks ) ; free ( track_size ) ;
"
720,"CWE-119 int sock_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , unsigned int optlen ) { struct sock * sk = sock -> sk ; int val ; int valbool ; struct linger ling ; int ret = 0 ; if ( optname == SO_BINDTODEVICE ) return sock_setbindtodevice ( sk , optval , optlen ) ; if ( optlen < sizeof ( int ) ) return - EINVAL ; if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; valbool = val ? 1 : 0 ; lock_sock ( sk ) ; switch ( optname ) { case SO_DEBUG : if ( val && ! capable ( CAP_NET_ADMIN ) ) ret = - EACCES ; else sock_valbool_flag ( sk , SOCK_DBG , valbool ) ; break ; case SO_REUSEADDR : sk -> sk_reuse = ( valbool ? SK_CAN_REUSE : SK_NO_REUSE ) ; break ; case SO_REUSEPORT : sk -> sk_reuseport = valbool ; break ; case SO_TYPE : case SO_PROTOCOL : case SO_DOMAIN : case SO_ERROR : ret = - ENOPROTOOPT ; break ; case SO_DONTROUTE : sock_valbool_flag ( sk , SOCK_LOCALROUTE , valbool ) ; break ; case SO_BROADCAST : sock_valbool_flag ( sk , SOCK_BROADCAST , valbool ) ; break ; case SO_SNDBUF : val = min_t ( u32 , val , sysctl_wmem_max ) ; set_sndbuf : sk -> sk_userlocks |= SOCK_SNDBUF_LOCK ; <S2SV_StartBug> sk -> sk_sndbuf = max_t ( u32 , val * 2 , SOCK_MIN_SNDBUF ) ; <S2SV_EndBug> sk -> sk_write_space ( sk ) ; break ; case SO_SNDBUFFORCE : if ( ! capable ( CAP_NET_ADMIN ) ) { ret = - EPERM ; break ; } goto set_sndbuf ; case SO_RCVBUF : val = min_t ( u32 , val , sysctl_rmem_max ) ; set_rcvbuf : sk -> sk_userlocks |= SOCK_RCVBUF_LOCK ; <S2SV_StartBug> sk -> sk_rcvbuf = max_t ( u32 , val * 2 , SOCK_MIN_RCVBUF ) ; <S2SV_EndBug> break ; case SO_RCVBUFFORCE : if ( ! capable ( CAP_NET_ADMIN ) ) { ret = - EPERM ; break ; } goto set_rcvbuf ; case SO_KEEPALIVE : # ifdef CONFIG_INET if ( sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) tcp_set_keepalive ( sk , valbool ) ; # endif sock_valbool_flag ( sk , SOCK_KEEPOPEN , valbool ) ; break ; case SO_OOBINLINE : sock_valbool_flag ( sk , SOCK_URGINLINE , valbool ) ; break ; case SO_NO_CHECK : sk -> sk_no_check_tx = valbool ; break ; case SO_PRIORITY : if ( ( val >= 0 && val <= 6 ) || ns_capable ( sock_net ( sk ) -> user_ns , CAP_NET_ADMIN ) ) sk -> sk_priority = val ; else ret = - EPERM ; break ; case SO_LINGER : if ( optlen < sizeof ( ling ) ) { ret = - EINVAL ; break ; } if ( copy_from_user ( & ling , optval , sizeof ( ling ) ) ) { ret = - EFAULT ; break ; } if ( ! ling . l_onoff ) sock_reset_flag ( sk , SOCK_LINGER ) ; else { # if ( BITS_PER_LONG == 32 ) if ( ( unsigned int ) ling . l_linger >= MAX_SCHEDULE_TIMEOUT / HZ ) sk -> sk_lingertime = MAX_SCHEDULE_TIMEOUT ; else # endif sk -> sk_lingertime = ( unsigned int ) ling . l_linger * HZ ; sock_set_flag ( sk , SOCK_LINGER ) ; } break ; case SO_BSDCOMPAT : sock_warn_obsolete_bsdism ( ""setsockopt"" ) ; break ; case SO_PASSCRED : if ( valbool ) set_bit ( SOCK_PASSCRED , & sock -> flags ) ; else clear_bit ( SOCK_PASSCRED , & sock -> flags ) ; break ; case SO_TIMESTAMP : case SO_TIMESTAMPNS : if ( valbool ) { if ( optname == SO_TIMESTAMP ) sock_reset_flag ( sk , SOCK_RCVTSTAMPNS ) ; else sock_set_flag ( sk , SOCK_RCVTSTAMPNS ) ; sock_set_flag ( sk , SOCK_RCVTSTAMP ) ; sock_enable_timestamp ( sk , SOCK_TIMESTAMP ) ; } else { sock_reset_flag ( sk , SOCK_RCVTSTAMP ) ; sock_reset_flag ( sk , SOCK_RCVTSTAMPNS ) ; } break ; case SO_TIMESTAMPING : if ( val & ~ SOF_TIMESTAMPING_MASK ) { ret = - EINVAL ; break ; } if ( val & SOF_TIMESTAMPING_OPT_ID && ! ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) ) { if ( sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) { if ( ( 1 << sk -> sk_state ) & ( TCPF_CLOSE | TCPF_LISTEN ) ) { ret = - EINVAL ; break ; } sk -> sk_tskey = tcp_sk ( sk ) -> snd_una ; } else { sk -> sk_tskey = 0 ; } } sk -> sk_tsflags = val ; if ( val & SOF_TIMESTAMPING_RX_SOFTWARE ) sock_enable_timestamp ( sk , SOCK_TIMESTAMPING_RX_SOFTWARE ) ; else sock_disable_timestamp ( sk , ( 1UL << SOCK_TIMESTAMPING_RX_SOFTWARE ) ) ; break ; case SO_RCVLOWAT : if ( val < 0 ) val = INT_MAX ; sk -> sk_rcvlowat = val ? : 1 ; break ; case SO_RCVTIMEO : ret = sock_set_timeout ( & sk -> sk_rcvtimeo , optval , optlen ) ; break ; case SO_SNDTIMEO : ret = sock_set_timeout ( & sk -> sk_sndtimeo , optval , optlen ) ; break ; case SO_ATTACH_FILTER : ret = - EINVAL ; if ( optlen == sizeof ( struct sock_fprog ) ) { struct sock_fprog fprog ; ret = - EFAULT ; if ( copy_from_user ( & fprog , optval , sizeof ( fprog ) ) ) break ; ret = sk_attach_filter ( & fprog , sk ) ; } break ; case SO_ATTACH_BPF : ret = - EINVAL ; if ( optlen == sizeof ( u32 ) ) { u32 ufd ; ret = - EFAULT ; if ( copy_from_user ( & ufd , optval , sizeof ( ufd ) ) ) break ; ret = sk_attach_bpf ( ufd , sk ) ; } break ; case SO_ATTACH_REUSEPORT_CBPF : ret = - EINVAL ; if ( optlen == sizeof ( struct sock_fprog ) ) { struct sock_fprog fprog ; ret = - EFAULT ; if ( copy_from_user ( & fprog , optval , sizeof ( fprog ) ) ) break ; ret = sk_reuseport_attach_filter ( & fprog , sk ) ; } break ; case SO_ATTACH_REUSEPORT_EBPF : ret = - EINVAL ; if ( optlen == sizeof ( u32 ) ) { u32 ufd ; ret = - EFAULT ; if ( copy_from_user ( & ufd , optval , sizeof ( ufd ) ) ) break ; ret = sk_reuseport_attach_bpf ( ufd , sk ) ; } break ; case SO_DETACH_FILTER : ret = sk_detach_filter ( sk ) ; break ; case SO_LOCK_FILTER : if ( sock_flag ( sk , SOCK_FILTER_LOCKED ) && ! valbool ) ret = - EPERM ; else sock_valbool_flag ( sk , SOCK_FILTER_LOCKED , valbool ) ; break ; case SO_PASSSEC : if ( valbool ) set_bit ( SOCK_PASSSEC , & sock -> flags ) ; else clear_bit ( SOCK_PASSSEC , & sock -> flags ) ; break ; case SO_MARK : if ( ! ns_capable ( sock_net ( sk ) -> user_ns , CAP_NET_ADMIN ) ) ret = - EPERM ; else sk -> sk_mark = val ; break ; case SO_RXQ_OVFL : sock_valbool_flag ( sk , SOCK_RXQ_OVFL , valbool ) ; break ; case SO_WIFI_STATUS : sock_valbool_flag ( sk , SOCK_WIFI_STATUS , valbool ) ; break ; case SO_PEEK_OFF : if ( sock -> ops -> set_peek_off ) ret = sock -> ops -> set_peek_off ( sk , val ) ; else ret = - EOPNOTSUPP ; break ; case SO_NOFCS : sock_valbool_flag ( sk , SOCK_NOFCS , valbool ) ; break ; case SO_SELECT_ERR_QUEUE : sock_valbool_flag ( sk , SOCK_SELECT_ERR_QUEUE , valbool ) ; break ; # ifdef CONFIG_NET_RX_BUSY_POLL case SO_BUSY_POLL : if ( ( val > sk -> sk_ll_usec ) && ! capable ( CAP_NET_ADMIN ) ) ret = - EPERM ; else { if ( val < 0 ) ret = - EINVAL ; else sk -> sk_ll_usec = val ; } break ; # endif case SO_MAX_PACING_RATE : sk -> sk_max_pacing_rate = val ; sk -> sk_pacing_rate = min ( sk -> sk_pacing_rate , sk -> sk_max_pacing_rate ) ; break ; case SO_INCOMING_CPU : sk -> sk_incoming_cpu = val ; break ; case SO_CNX_ADVICE : if ( val == 1 ) dst_negative_advice ( sk ) ; break ; default : ret = - ENOPROTOOPT ; break ; } release_sock ( sk ) ; return ret ; }
","<S2SV_ModStart> = max_t ( int <S2SV_ModEnd> , val * <S2SV_ModStart> = max_t ( int <S2SV_ModEnd> , val *
"
721,"CWE-119 static int udf_load_logicalvol ( struct super_block * sb , sector_t block , struct kernel_lb_addr * fileset ) { struct logicalVolDesc * lvd ; int i , j , offset ; uint8_t type ; struct udf_sb_info * sbi = UDF_SB ( sb ) ; struct genericPartitionMap * gpm ; uint16_t ident ; struct buffer_head * bh ; <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> bh = udf_read_tagged ( sb , block , block , & ident ) ; if ( ! bh ) return 1 ; BUG_ON ( ident != TAG_IDENT_LVD ) ; <S2SV_StartBug> lvd = ( struct logicalVolDesc * ) bh -> b_data ; <S2SV_EndBug> ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ; if ( ret ) goto out_bh ; for ( i = 0 , offset = 0 ; <S2SV_StartBug> i < sbi -> s_partitions && offset < le32_to_cpu ( lvd -> mapTableLength ) ; <S2SV_EndBug> i ++ , offset += gpm -> partitionMapLength ) { struct udf_part_map * map = & sbi -> s_partmaps [ i ] ; gpm = ( struct genericPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; type = gpm -> partitionMapType ; if ( type == 1 ) { struct genericPartitionMap1 * gpm1 = ( struct genericPartitionMap1 * ) gpm ; map -> s_partition_type = UDF_TYPE1_MAP15 ; map -> s_volumeseqnum = le16_to_cpu ( gpm1 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( gpm1 -> partitionNum ) ; map -> s_partition_func = NULL ; } else if ( type == 2 ) { struct udfPartitionMap2 * upm2 = ( struct udfPartitionMap2 * ) gpm ; if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_VIRTUAL , strlen ( UDF_ID_VIRTUAL ) ) ) { u16 suf = le16_to_cpu ( ( ( __le16 * ) upm2 -> partIdent . identSuffix ) [ 0 ] ) ; if ( suf < 0x0200 ) { map -> s_partition_type = UDF_VIRTUAL_MAP15 ; map -> s_partition_func = udf_get_pblock_virt15 ; } else { map -> s_partition_type = UDF_VIRTUAL_MAP20 ; map -> s_partition_func = udf_get_pblock_virt20 ; } } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_SPARABLE , strlen ( UDF_ID_SPARABLE ) ) ) { uint32_t loc ; struct sparingTable * st ; struct sparablePartitionMap * spm = ( struct sparablePartitionMap * ) gpm ; map -> s_partition_type = UDF_SPARABLE_MAP15 ; map -> s_type_specific . s_sparing . s_packet_len = le16_to_cpu ( spm -> packetLength ) ; for ( j = 0 ; j < spm -> numSparingTables ; j ++ ) { struct buffer_head * bh2 ; loc = le32_to_cpu ( spm -> locSparingTable [ j ] ) ; bh2 = udf_read_tagged ( sb , loc , loc , & ident ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = bh2 ; if ( bh2 == NULL ) continue ; st = ( struct sparingTable * ) bh2 -> b_data ; if ( ident != 0 || strncmp ( st -> sparingIdent . ident , UDF_ID_SPARING , strlen ( UDF_ID_SPARING ) ) ) { brelse ( bh2 ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = NULL ; } } map -> s_partition_func = udf_get_pblock_spar15 ; } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_METADATA , strlen ( UDF_ID_METADATA ) ) ) { struct udf_meta_data * mdata = & map -> s_type_specific . s_metadata ; struct metadataPartitionMap * mdm = ( struct metadataPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; udf_debug ( ""Parsing<S2SV_blank>Logical<S2SV_blank>vol<S2SV_blank>part<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank><S2SV_blank>id=%s\\n"" , i , type , UDF_ID_METADATA ) ; map -> s_partition_type = UDF_METADATA_MAP25 ; map -> s_partition_func = udf_get_pblock_meta25 ; mdata -> s_meta_file_loc = le32_to_cpu ( mdm -> metadataFileLoc ) ; mdata -> s_mirror_file_loc = le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ; mdata -> s_bitmap_file_loc = le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ; mdata -> s_alloc_unit_size = le32_to_cpu ( mdm -> allocUnitSize ) ; mdata -> s_align_unit_size = le16_to_cpu ( mdm -> alignUnitSize ) ; if ( mdm -> flags & 0x01 ) mdata -> s_flags |= MF_DUPLICATE_MD ; udf_debug ( ""Metadata<S2SV_blank>Ident<S2SV_blank>suffix=0x%x\\n"" , le16_to_cpu ( * ( __le16 * ) mdm -> partIdent . identSuffix ) ) ; udf_debug ( ""Metadata<S2SV_blank>part<S2SV_blank>num=%d\\n"" , le16_to_cpu ( mdm -> partitionNum ) ) ; udf_debug ( ""Metadata<S2SV_blank>part<S2SV_blank>alloc<S2SV_blank>unit<S2SV_blank>size=%d\\n"" , le32_to_cpu ( mdm -> allocUnitSize ) ) ; udf_debug ( ""Metadata<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataFileLoc ) ) ; udf_debug ( ""Mirror<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ) ; udf_debug ( ""Bitmap<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ) ; udf_debug ( ""Flags:<S2SV_blank>%d<S2SV_blank>%d\\n"" , mdata -> s_flags , mdm -> flags ) ; } else { udf_debug ( ""Unknown<S2SV_blank>ident:<S2SV_blank>%s\\n"" , upm2 -> partIdent . ident ) ; continue ; } map -> s_volumeseqnum = le16_to_cpu ( upm2 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( upm2 -> partitionNum ) ; } udf_debug ( ""Partition<S2SV_blank>(%d:%d)<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>on<S2SV_blank>volume<S2SV_blank>%d\\n"" , i , map -> s_partition_num , type , map -> s_volumeseqnum ) ; } if ( fileset ) { struct long_ad * la = ( struct long_ad * ) & ( lvd -> logicalVolContentsUse [ 0 ] ) ; * fileset = lelb_to_cpu ( la -> extLocation ) ; udf_debug ( ""FileSet<S2SV_blank>found<S2SV_blank>in<S2SV_blank>LogicalVolDesc<S2SV_blank>at<S2SV_blank>block=%d,<S2SV_blank>partition=%d\\n"" , fileset -> logicalBlockNum , fileset -> partitionReferenceNum ) ; } if ( lvd -> integritySeqExt . extLength ) udf_load_logicalvolint ( sb , leea_to_cpu ( lvd -> integritySeqExt ) ) ; out_bh : brelse ( bh ) ; return ret ; }
","<S2SV_ModStart> * bh ; unsigned int table_len ; <S2SV_ModStart> -> b_data ; table_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) { udf_err ( sb , ""error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>"" ""Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\n"" , table_len , sb -> s_blocksize - sizeof ( * lvd ) ) ; goto out_bh ; } <S2SV_ModStart> && offset < table_len <S2SV_ModEnd> ; i ++
"
722,"CWE-476 jas_image_t * bmp_decode ( jas_stream_t * in , char * optstr ) { jas_image_t * image ; bmp_hdr_t hdr ; bmp_info_t * info ; uint_fast16_t cmptno ; jas_image_cmptparm_t cmptparms [ 3 ] ; jas_image_cmptparm_t * cmptparm ; uint_fast16_t numcmpts ; long n ; <S2SV_StartBug> if ( optstr ) { <S2SV_EndBug> jas_eprintf ( ""warning:<S2SV_blank>ignoring<S2SV_blank>BMP<S2SV_blank>decoder<S2SV_blank>options\\n"" ) ; } jas_eprintf ( ""THE<S2SV_blank>BMP<S2SV_blank>FORMAT<S2SV_blank>IS<S2SV_blank>NOT<S2SV_blank>FULLY<S2SV_blank>SUPPORTED!\\n"" ""THAT<S2SV_blank>IS,<S2SV_blank>THE<S2SV_blank>JASPER<S2SV_blank>SOFTWARE<S2SV_blank>CANNOT<S2SV_blank>DECODE<S2SV_blank>ALL<S2SV_blank>TYPES<S2SV_blank>OF<S2SV_blank>BMP<S2SV_blank>DATA.\\n"" ""IF<S2SV_blank>YOU<S2SV_blank>HAVE<S2SV_blank>ANY<S2SV_blank>PROBLEMS,<S2SV_blank>PLEASE<S2SV_blank>TRY<S2SV_blank>CONVERTING<S2SV_blank>YOUR<S2SV_blank>IMAGE<S2SV_blank>DATA\\n"" ""TO<S2SV_blank>THE<S2SV_blank>PNM<S2SV_blank>FORMAT,<S2SV_blank>AND<S2SV_blank>USING<S2SV_blank>THIS<S2SV_blank>FORMAT<S2SV_blank>INSTEAD.\\n"" ) ; if ( bmp_gethdr ( in , & hdr ) ) { jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>header\\n"" ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\n"" , hdr . magic , hdr . siz , hdr . reserved1 , hdr . reserved2 , hdr . off ) ) ; if ( ! ( info = bmp_getinfo ( in ) ) ) { jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>info\\n"" ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } JAS_DBGLOG ( 1 , <S2SV_StartBug> ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" <S2SV_EndBug> ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%d;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>hres<S2SV_blank>%d;<S2SV_blank>vres<S2SV_blank>%d;<S2SV_blank>numcolors<S2SV_blank>%d;<S2SV_blank>"" <S2SV_StartBug> ""mincolors<S2SV_blank>%d\\n"" , info -> len , info -> width , info -> height , info -> numplanes , <S2SV_EndBug> <S2SV_StartBug> info -> depth , info -> enctype , info -> siz , info -> hres , info -> vres , <S2SV_EndBug> <S2SV_StartBug> info -> numcolors , info -> mincolors ) ) ; <S2SV_EndBug> if ( ! bmp_issupported ( & hdr , info ) ) { jas_eprintf ( ""error:<S2SV_blank>unsupported<S2SV_blank>BMP<S2SV_blank>encoding\\n"" ) ; <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> return 0 ; } if ( ( n = hdr . off - ( BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN ( info ) ) ) < 0 ) { jas_eprintf ( ""error:<S2SV_blank>possibly<S2SV_blank>bad<S2SV_blank>bitmap<S2SV_blank>offset?\\n"" ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } if ( n > 0 ) { jas_eprintf ( ""skipping<S2SV_blank>unknown<S2SV_blank>data<S2SV_blank>in<S2SV_blank>BMP<S2SV_blank>file\\n"" ) ; if ( bmp_gobble ( in , n ) ) { <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> return 0 ; } } numcmpts = bmp_numcmpts ( info ) ; for ( cmptno = 0 , cmptparm = cmptparms ; cmptno < numcmpts ; ++ cmptno , ++ cmptparm ) { cmptparm -> tlx = 0 ; cmptparm -> tly = 0 ; cmptparm -> hstep = 1 ; cmptparm -> vstep = 1 ; cmptparm -> width = info -> width ; cmptparm -> height = info -> height ; cmptparm -> prec = 8 ; cmptparm -> sgnd = false ; } if ( ! ( image = jas_image_create ( numcmpts , cmptparms , JAS_CLRSPC_UNKNOWN ) ) ) { <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> return 0 ; } if ( numcmpts == 3 ) { jas_image_setclrspc ( image , JAS_CLRSPC_SRGB ) ; jas_image_setcmpttype ( image , 0 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_R ) ) ; jas_image_setcmpttype ( image , 1 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_G ) ) ; jas_image_setcmpttype ( image , 2 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_B ) ) ; } else { jas_image_setclrspc ( image , JAS_CLRSPC_SGRAY ) ; jas_image_setcmpttype ( image , 0 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_GRAY_Y ) ) ; } if ( bmp_getdata ( in , info , image ) ) { <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> <S2SV_StartBug> jas_image_destroy ( image ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> } <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> return image ; }
","<S2SV_ModStart> long n ; image = 0 ; info = 0 ; <S2SV_ModStart> ""cannot<S2SV_blank>get<S2SV_blank>header\\n"" ) ; goto error <S2SV_ModEnd> ; } JAS_DBGLOG <S2SV_ModStart> ""cannot<S2SV_blank>get<S2SV_blank>info\\n"" ) ; goto error <S2SV_ModEnd> ; } JAS_DBGLOG <S2SV_ModStart> 1 , ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%ld;<S2SV_blank>width<S2SV_blank>%ld;<S2SV_blank>height<S2SV_blank>%ld;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%ld;<S2SV_blank>siz<S2SV_blank>%ld;<S2SV_blank>hres<S2SV_blank>%ld;<S2SV_blank>vres<S2SV_blank>%ld;<S2SV_blank>numcolors<S2SV_blank>%ld;<S2SV_blank>"" ""mincolors<S2SV_blank>%ld\\n"" , JAS_CAST ( long <S2SV_ModEnd> , info -> <S2SV_ModStart> info -> len ) , JAS_CAST ( long <S2SV_ModStart> info -> width ) , JAS_CAST ( long <S2SV_ModStart> info -> height ) , JAS_CAST ( long <S2SV_ModStart> info -> numplanes ) , JAS_CAST ( long , <S2SV_ModEnd> info -> depth <S2SV_ModStart> info -> depth ) , JAS_CAST ( long <S2SV_ModStart> info -> enctype ) , JAS_CAST ( long <S2SV_ModStart> info -> siz ) , JAS_CAST ( long <S2SV_ModStart> info -> hres ) , JAS_CAST ( long <S2SV_ModStart> info -> vres ) , JAS_CAST ( long , <S2SV_ModEnd> info -> numcolors <S2SV_ModStart> info -> numcolors ) , JAS_CAST ( long <S2SV_ModStart> mincolors ) ) ) ; if ( info -> width < 0 || info -> height < 0 || info -> numplanes < 0 || info -> depth < 0 || info -> siz < 0 || info -> hres < 0 || info -> vres < 0 ) { jas_eprintf ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\n"" ) ; goto error ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> ""error:<S2SV_blank>unsupported<S2SV_blank>BMP<S2SV_blank>encoding\\n"" ) ; goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> ""error:<S2SV_blank>possibly<S2SV_blank>bad<S2SV_blank>bitmap<S2SV_blank>offset?\\n"" ) ; goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } } <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto error ; } <S2SV_ModStart> info ) ; return image ; error : if ( info ) { bmp_info_destroy ( info ) ; } if ( image ) { <S2SV_ModStart> image ) ; } <S2SV_ModStart> 0 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
"
723,"CWE-125 void qedi_dbg_notice ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_NOTICE ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , <S2SV_StartBug> dev_name ( & qedi -> pdev -> dev ) , nfunc , line , <S2SV_EndBug> qedi -> host_no , & vaf ) ; else <S2SV_StartBug> pr_notice ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
","<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func <S2SV_ModEnd> , line ,
"
724,"CWE-119 IHEVCD_ERROR_T ihevcd_cabac_init ( cab_ctxt_t * ps_cabac , bitstrm_t * ps_bitstrm , WORD32 qp , WORD32 cabac_init_idc , const UWORD8 * pu1_init_ctxt ) { ASSERT ( ps_cabac != NULL ) ; ASSERT ( ps_bitstrm != NULL ) ; ASSERT ( ( qp >= 0 ) && ( qp < 52 ) ) ; ASSERT ( ( cabac_init_idc >= 0 ) && ( cabac_init_idc < 3 ) ) ; UNUSED ( qp ) ; UNUSED ( cabac_init_idc ) ; # if FULLRANGE ps_cabac -> u4_range = ( UWORD32 ) 510 << RANGE_SHIFT ; BITS_GET ( ps_cabac -> u4_ofst , ps_bitstrm -> pu4_buf , ps_bitstrm -> u4_bit_ofst , ps_bitstrm -> u4_cur_word , ps_bitstrm -> u4_nxt_word , ( 9 + RANGE_SHIFT ) ) ; # else ps_cabac -> u4_range = ( UWORD32 ) 510 ; BITS_GET ( ps_cabac -> u4_ofst , ps_bitstrm -> pu4_buf , ps_bitstrm -> u4_bit_ofst , ps_bitstrm -> u4_cur_word , ps_bitstrm -> u4_nxt_word , 9 ) ; # endif memcpy ( ps_cabac -> au1_ctxt_models , pu1_init_ctxt , IHEVC_CAB_CTXT_END ) ; DEBUG_RANGE_OFST ( ""init"" , ps_cabac -> u4_range , ps_cabac -> u4_ofst ) ; <S2SV_StartBug> return ( ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) ; <S2SV_EndBug> }
","<S2SV_ModStart> u4_ofst ) ; if ( ps_cabac -> u4_ofst >= ps_cabac -> u4_range ) { return ( ( IHEVCD_ERROR_T ) IHEVCD_FAIL ) ; }
"
725,"CWE-200 static void on_page_prepare ( GtkNotebook * assistant , GtkWidget * page , gpointer user_data ) { if ( ! is_processing_finished ( ) ) { show_next_step_button ( ) ; clear_warnings ( ) ; } gtk_widget_hide ( g_btn_detail ) ; gtk_widget_hide ( g_btn_onfail ) ; if ( ! g_expert_mode ) gtk_widget_hide ( g_btn_repeat ) ; save_items_from_notepad ( ) ; <S2SV_StartBug> save_text_from_text_view ( g_tv_comment , FILENAME_COMMENT ) ; <S2SV_EndBug> if ( pages [ PAGENO_SUMMARY ] . page_widget == page ) { if ( ! g_expert_mode ) { int n = select_next_page_no ( pages [ PAGENO_SUMMARY ] . page_no , NULL ) ; log_info ( ""switching<S2SV_blank>to<S2SV_blank>page_no:%d"" , n ) ; gtk_notebook_set_current_page ( assistant , n ) ; return ; } } if ( pages [ PAGENO_EDIT_ELEMENTS ] . page_widget == page ) { if ( highlight_forbidden ( ) ) { add_sensitive_data_warning ( ) ; show_warnings ( ) ; gtk_expander_set_expanded ( g_exp_search , TRUE ) ; } else gtk_toggle_button_set_active ( GTK_TOGGLE_BUTTON ( g_rb_custom_search ) , TRUE ) ; show_warnings ( ) ; } if ( pages [ PAGENO_REVIEW_DATA ] . page_widget == page ) { update_ls_details_checkboxes ( g_event_selected ) ; gtk_widget_set_sensitive ( g_btn_next , gtk_toggle_button_get_active ( g_tb_approve_bt ) ) ; } if ( pages [ PAGENO_EDIT_COMMENT ] . page_widget == page ) { gtk_widget_show ( g_btn_detail ) ; gtk_widget_set_sensitive ( g_btn_next , false ) ; on_comment_changed ( gtk_text_view_get_buffer ( g_tv_comment ) , NULL ) ; } if ( pages [ PAGENO_EVENT_PROGRESS ] . page_widget == page ) { log_info ( ""g_event_selected:\'%s\'"" , g_event_selected ) ; if ( g_event_selected && g_event_selected [ 0 ] ) { clear_warnings ( ) ; start_event_run ( g_event_selected ) ; } } if ( pages [ PAGENO_EVENT_SELECTOR ] . page_widget == page ) { if ( ! g_expert_mode && ! g_auto_event_list ) hide_next_step_button ( ) ; } }
","<S2SV_ModStart> g_tv_comment , FILENAME_COMMENT ) ; problem_data_reload_from_dump_dir ( ) ; update_gui_state_from_problem_data ( 0
"
726,"CWE-200 static long __media_device_enum_links ( struct media_device * mdev , struct media_links_enum * links ) { struct media_entity * entity ; entity = find_entity ( mdev , links -> entity ) ; if ( entity == NULL ) return - EINVAL ; if ( links -> pads ) { unsigned int p ; for ( p = 0 ; p < entity -> num_pads ; p ++ ) { struct media_pad_desc pad ; <S2SV_StartBug> media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ; <S2SV_EndBug> if ( copy_to_user ( & links -> pads [ p ] , & pad , sizeof ( pad ) ) ) return - EFAULT ; } } if ( links -> links ) { struct media_link_desc __user * ulink ; unsigned int l ; for ( l = 0 , ulink = links -> links ; l < entity -> num_links ; l ++ ) { struct media_link_desc link ; if ( entity -> links [ l ] . source -> entity != entity ) continue ; <S2SV_StartBug> media_device_kpad_to_upad ( entity -> links [ l ] . source , <S2SV_EndBug> & link . source ) ; media_device_kpad_to_upad ( entity -> links [ l ] . sink , & link . sink ) ; link . flags = entity -> links [ l ] . flags ; if ( copy_to_user ( ulink , & link , sizeof ( * ulink ) ) ) return - EFAULT ; ulink ++ ; } } return 0 ; }
","<S2SV_ModStart> media_pad_desc pad ; memset ( & pad , 0 , sizeof ( pad ) ) ; <S2SV_ModStart> ) continue ; memset ( & link , 0 , sizeof ( link ) ) ;
"
727,"CWE-908 static int md_analyze_line ( MD_CTX * ctx , OFF beg , OFF * p_end , const MD_LINE_ANALYSIS * pivot_line , MD_LINE_ANALYSIS * line ) { unsigned total_indent = 0 ; int n_parents = 0 ; int n_brothers = 0 ; int n_children = 0 ; MD_CONTAINER container = { 0 } ; int prev_line_has_list_loosening_effect = ctx -> last_line_has_list_loosening_effect ; OFF off = beg ; OFF hr_killer = 0 ; int ret = 0 ; line -> indent = md_line_indentation ( ctx , total_indent , off , & off ) ; total_indent += line -> indent ; line -> beg = off ; while ( n_parents < ctx -> n_containers ) { MD_CONTAINER * c = & ctx -> containers [ n_parents ] ; if ( c -> ch == _T ( '>' ) && line -> indent < ctx -> code_indent_offset && off < ctx -> size && CH ( off ) == _T ( '>' ) ) { off ++ ; total_indent ++ ; line -> indent = md_line_indentation ( ctx , total_indent , off , & off ) ; total_indent += line -> indent ; if ( line -> indent > 0 ) line -> indent -- ; line -> beg = off ; } else if ( c -> ch != _T ( '>' ) && line -> indent >= c -> contents_indent ) { line -> indent -= c -> contents_indent ; } else { break ; } n_parents ++ ; } if ( off >= ctx -> size || ISNEWLINE ( off ) ) { if ( n_brothers + n_children == 0 ) { while ( n_parents < ctx -> n_containers && ctx -> containers [ n_parents ] . ch != _T ( '>' ) ) n_parents ++ ; } } while ( TRUE ) { if ( pivot_line -> type == MD_LINE_FENCEDCODE ) { line -> beg = off ; if ( line -> indent < ctx -> code_indent_offset ) { if ( md_is_closing_code_fence ( ctx , CH ( pivot_line -> beg ) , off , & off ) ) { line -> type = MD_LINE_BLANK ; ctx -> last_line_has_list_loosening_effect = FALSE ; break ; } } if ( n_parents == ctx -> n_containers ) { if ( line -> indent > pivot_line -> indent ) line -> indent -= pivot_line -> indent ; else line -> indent = 0 ; line -> type = MD_LINE_FENCEDCODE ; break ; } } if ( pivot_line -> type == MD_LINE_HTML && ctx -> html_block_type > 0 ) { if ( n_parents < ctx -> n_containers ) { ctx -> html_block_type = 0 ; } else { int html_block_type ; html_block_type = md_is_html_block_end_condition ( ctx , off , & off ) ; if ( html_block_type > 0 ) { MD_ASSERT ( html_block_type == ctx -> html_block_type ) ; ctx -> html_block_type = 0 ; if ( html_block_type == 6 || html_block_type == 7 ) { line -> type = MD_LINE_BLANK ; line -> indent = 0 ; break ; } } line -> type = MD_LINE_HTML ; n_parents = ctx -> n_containers ; break ; } } if ( off >= ctx -> size || ISNEWLINE ( off ) ) { if ( pivot_line -> type == MD_LINE_INDENTEDCODE && n_parents == ctx -> n_containers ) { line -> type = MD_LINE_INDENTEDCODE ; if ( line -> indent > ctx -> code_indent_offset ) line -> indent -= ctx -> code_indent_offset ; else line -> indent = 0 ; ctx -> last_line_has_list_loosening_effect = FALSE ; } else { line -> type = MD_LINE_BLANK ; ctx -> last_line_has_list_loosening_effect = ( n_parents > 0 && n_brothers + n_children == 0 && ctx -> containers [ n_parents - 1 ] . ch != _T ( '>' ) ) ; # if 1 if ( n_parents > 0 && ctx -> containers [ n_parents - 1 ] . ch != _T ( '>' ) && n_brothers + n_children == 0 && ctx -> current_block == NULL && ctx -> n_block_bytes > ( int ) sizeof ( MD_BLOCK ) ) { MD_BLOCK * top_block = ( MD_BLOCK * ) ( ( char * ) ctx -> block_bytes + ctx -> n_block_bytes - sizeof ( MD_BLOCK ) ) ; if ( top_block -> type == MD_BLOCK_LI ) ctx -> last_list_item_starts_with_two_blank_lines = TRUE ; } # endif } break ; } else { # if 1 ctx -> last_line_has_list_loosening_effect = FALSE ; if ( ctx -> last_list_item_starts_with_two_blank_lines ) { if ( n_parents > 0 && ctx -> containers [ n_parents - 1 ] . ch != _T ( '>' ) && n_brothers + n_children == 0 && ctx -> current_block == NULL && ctx -> n_block_bytes > ( int ) sizeof ( MD_BLOCK ) ) { MD_BLOCK * top_block = ( MD_BLOCK * ) ( ( char * ) ctx -> block_bytes + ctx -> n_block_bytes - sizeof ( MD_BLOCK ) ) ; if ( top_block -> type == MD_BLOCK_LI ) n_parents -- ; } ctx -> last_list_item_starts_with_two_blank_lines = FALSE ; } # endif } if ( line -> indent < ctx -> code_indent_offset && pivot_line -> type == MD_LINE_TEXT <S2SV_StartBug> && ( CH ( off ) == _T ( '=' ) || CH ( off ) == _T ( '-' ) ) <S2SV_EndBug> && ( n_parents == ctx -> n_containers ) ) { unsigned level ; if ( md_is_setext_underline ( ctx , off , & off , & level ) ) { line -> type = MD_LINE_SETEXTUNDERLINE ; line -> data = level ; break ; } } <S2SV_StartBug> if ( line -> indent < ctx -> code_indent_offset && ISANYOF ( off , _T ( ""-_*"" ) ) && off >= hr_killer ) { <S2SV_EndBug> if ( md_is_hr_line ( ctx , off , & off , & hr_killer ) ) { line -> type = MD_LINE_HR ; break ; } } if ( n_parents < ctx -> n_containers && n_brothers + n_children == 0 ) { OFF tmp ; if ( md_is_container_mark ( ctx , line -> indent , off , & tmp , & container ) && md_is_container_compatible ( & ctx -> containers [ n_parents ] , & container ) ) { pivot_line = & md_dummy_blank_line ; off = tmp ; total_indent += container . contents_indent - container . mark_indent ; line -> indent = md_line_indentation ( ctx , total_indent , off , & off ) ; total_indent += line -> indent ; line -> beg = off ; if ( off >= ctx -> size || ISNEWLINE ( off ) ) { container . contents_indent ++ ; } else if ( line -> indent <= ctx -> code_indent_offset ) { container . contents_indent += line -> indent ; line -> indent = 0 ; } else { container . contents_indent += 1 ; line -> indent -- ; } ctx -> containers [ n_parents ] . mark_indent = container . mark_indent ; ctx -> containers [ n_parents ] . contents_indent = container . contents_indent ; n_brothers ++ ; continue ; } } if ( line -> indent >= ctx -> code_indent_offset && ( pivot_line -> type == MD_LINE_BLANK || pivot_line -> type == MD_LINE_INDENTEDCODE ) ) { line -> type = MD_LINE_INDENTEDCODE ; MD_ASSERT ( line -> indent >= ctx -> code_indent_offset ) ; line -> indent -= ctx -> code_indent_offset ; line -> data = 0 ; break ; } if ( line -> indent < ctx -> code_indent_offset && md_is_container_mark ( ctx , line -> indent , off , & off , & container ) ) { if ( pivot_line -> type == MD_LINE_TEXT && n_parents == ctx -> n_containers && ( off >= ctx -> size || ISNEWLINE ( off ) ) && container . ch != _T ( '>' ) ) { } else if ( pivot_line -> type == MD_LINE_TEXT && n_parents == ctx -> n_containers && <S2SV_StartBug> ( container . ch == _T ( '.' ) || container . ch == _T ( ')' ) ) && container . start != 1 ) <S2SV_EndBug> { } else { total_indent += container . contents_indent - container . mark_indent ; line -> indent = md_line_indentation ( ctx , total_indent , off , & off ) ; total_indent += line -> indent ; line -> beg = off ; line -> data = container . ch ; if ( off >= ctx -> size || ISNEWLINE ( off ) ) { container . contents_indent ++ ; } else if ( line -> indent <= ctx -> code_indent_offset ) { container . contents_indent += line -> indent ; line -> indent = 0 ; } else { container . contents_indent += 1 ; line -> indent -- ; } if ( n_brothers + n_children == 0 ) pivot_line = & md_dummy_blank_line ; if ( n_children == 0 ) MD_CHECK ( md_leave_child_containers ( ctx , n_parents + n_brothers ) ) ; n_children ++ ; MD_CHECK ( md_push_container ( ctx , & container ) ) ; continue ; } } if ( pivot_line -> type == MD_LINE_TABLE && n_parents == ctx -> n_containers ) { line -> type = MD_LINE_TABLE ; break ; } <S2SV_StartBug> if ( line -> indent < ctx -> code_indent_offset && CH ( off ) == _T ( '#' ) ) { <S2SV_EndBug> unsigned level ; if ( md_is_atxheader_line ( ctx , off , & line -> beg , & off , & level ) ) { line -> type = MD_LINE_ATXHEADER ; line -> data = level ; break ; } } <S2SV_StartBug> if ( CH ( off ) == _T ( '`' ) || CH ( off ) == _T ( '~' ) ) { <S2SV_EndBug> if ( md_is_opening_code_fence ( ctx , off , & off ) ) { line -> type = MD_LINE_FENCEDCODE ; line -> data = 1 ; break ; } } if ( CH ( off ) == _T ( '<' ) && ! ( ctx -> parser . flags & MD_FLAG_NOHTMLBLOCKS ) ) { ctx -> html_block_type = md_is_html_block_start_condition ( ctx , off ) ; if ( ctx -> html_block_type == 7 && pivot_line -> type == MD_LINE_TEXT ) ctx -> html_block_type = 0 ; if ( ctx -> html_block_type > 0 ) { if ( md_is_html_block_end_condition ( ctx , off , & off ) == ctx -> html_block_type ) { ctx -> html_block_type = 0 ; } line -> type = MD_LINE_HTML ; break ; } } <S2SV_StartBug> if ( ( ctx -> parser . flags & MD_FLAG_TABLES ) && pivot_line -> type == MD_LINE_TEXT && <S2SV_EndBug> <S2SV_StartBug> ( CH ( off ) == _T ( '|' ) || CH ( off ) == _T ( '-' ) || CH ( off ) == _T ( ':' ) ) && <S2SV_EndBug> n_parents == ctx -> n_containers ) { unsigned col_count ; if ( ctx -> current_block != NULL && ctx -> current_block -> n_lines == 1 && md_is_table_underline ( ctx , off , & off , & col_count ) ) { line -> data = col_count ; line -> type = MD_LINE_TABLEUNDERLINE ; break ; } } line -> type = MD_LINE_TEXT ; if ( pivot_line -> type == MD_LINE_TEXT && n_brothers + n_children == 0 ) { n_parents = ctx -> n_containers ; } if ( ( ctx -> parser . flags & MD_FLAG_TASKLISTS ) && n_brothers + n_children > 0 && ISANYOF_ ( ctx -> containers [ ctx -> n_containers - 1 ] . ch , _T ( ""-+*.)"" ) ) ) { OFF tmp = off ; while ( tmp < ctx -> size && tmp < off + 3 && ISBLANK ( tmp ) ) tmp ++ ; if ( tmp + 2 < ctx -> size && CH ( tmp ) == _T ( '[' ) && ISANYOF ( tmp + 1 , _T ( ""xX<S2SV_blank>"" ) ) && CH ( tmp + 2 ) == _T ( ']' ) && ( tmp + 3 == ctx -> size || ISBLANK ( tmp + 3 ) || ISNEWLINE ( tmp + 3 ) ) ) { MD_CONTAINER * task_container = ( n_children > 0 ? & ctx -> containers [ ctx -> n_containers - 1 ] : & container ) ; task_container -> is_task = TRUE ; task_container -> task_mark_off = tmp + 1 ; off = tmp + 3 ; while ( ISWHITESPACE ( off ) ) off ++ ; line -> beg = off ; } } break ; } # if defined __linux__ && ! defined MD4C_USE_UTF16 if ( ctx -> doc_ends_with_newline && off < ctx -> size ) { while ( TRUE ) { off += ( OFF ) strcspn ( STR ( off ) , ""\\r\\n"" ) ; if ( CH ( off ) == _T ( '\\0' ) ) off ++ ; else break ; } } else # endif { while ( off + 3 < ctx -> size && ! ISNEWLINE ( off + 0 ) && ! ISNEWLINE ( off + 1 ) && ! ISNEWLINE ( off + 2 ) && ! ISNEWLINE ( off + 3 ) ) off += 4 ; while ( off < ctx -> size && ! ISNEWLINE ( off ) ) off ++ ; } line -> end = off ; if ( line -> type == MD_LINE_ATXHEADER ) { OFF tmp = line -> end ; while ( tmp > line -> beg && CH ( tmp - 1 ) == _T ( '<S2SV_blank>' ) ) tmp -- ; while ( tmp > line -> beg && CH ( tmp - 1 ) == _T ( '#' ) ) tmp -- ; if ( tmp == line -> beg || CH ( tmp - 1 ) == _T ( '<S2SV_blank>' ) || ( ctx -> parser . flags & MD_FLAG_PERMISSIVEATXHEADERS ) ) line -> end = tmp ; } if ( line -> type != MD_LINE_INDENTEDCODE && line -> type != MD_LINE_FENCEDCODE ) { while ( line -> end > line -> beg && CH ( line -> end - 1 ) == _T ( '<S2SV_blank>' ) ) line -> end -- ; } if ( off < ctx -> size && CH ( off ) == _T ( '\\r' ) ) off ++ ; if ( off < ctx -> size && CH ( off ) == _T ( '\\n' ) ) off ++ ; * p_end = off ; if ( prev_line_has_list_loosening_effect && line -> type != MD_LINE_BLANK && n_parents + n_brothers > 0 ) { MD_CONTAINER * c = & ctx -> containers [ n_parents + n_brothers - 1 ] ; if ( c -> ch != _T ( '>' ) ) { MD_BLOCK * block = ( MD_BLOCK * ) ( ( ( char * ) ctx -> block_bytes ) + c -> block_byte_off ) ; block -> flags |= MD_BLOCK_LOOSE_LIST ; } } if ( n_children == 0 && n_parents + n_brothers < ctx -> n_containers ) MD_CHECK ( md_leave_child_containers ( ctx , n_parents + n_brothers ) ) ; if ( n_brothers > 0 ) { MD_ASSERT ( n_brothers == 1 ) ; MD_CHECK ( md_push_container_bytes ( ctx , MD_BLOCK_LI , ctx -> containers [ n_parents ] . task_mark_off , ( ctx -> containers [ n_parents ] . is_task ? CH ( ctx -> containers [ n_parents ] . task_mark_off ) : 0 ) , MD_BLOCK_CONTAINER_CLOSER ) ) ; MD_CHECK ( md_push_container_bytes ( ctx , MD_BLOCK_LI , container . task_mark_off , ( container . is_task ? CH ( container . task_mark_off ) : 0 ) , MD_BLOCK_CONTAINER_OPENER ) ) ; ctx -> containers [ n_parents ] . is_task = container . is_task ; ctx -> containers [ n_parents ] . task_mark_off = container . task_mark_off ; } if ( n_children > 0 ) MD_CHECK ( md_enter_child_containers ( ctx , n_children ) ) ; abort : return ret ; }
","<S2SV_ModStart> == MD_LINE_TEXT && off < ctx -> size && ISANYOF2 ( off , <S2SV_ModEnd> _T ( '=' <S2SV_ModStart> ( '=' ) , <S2SV_ModEnd> _T ( '-' <S2SV_ModStart> ctx -> code_indent_offset && off < ctx -> size <S2SV_ModEnd> && off >= <S2SV_ModStart> off >= hr_killer && ISANYOF ( off , _T ( ""-_*"" ) ) ) <S2SV_ModEnd> { if ( <S2SV_ModStart> -> n_containers && ISANYOF2_ <S2SV_ModStart> container . ch , <S2SV_ModEnd> _T ( '.' <S2SV_ModStart> ( '.' ) , <S2SV_ModEnd> _T ( ')' <S2SV_ModStart> -> code_indent_offset && off < ctx -> size && <S2SV_ModStart> } if ( off < ctx -> size && ISANYOF2 ( off , _T ( '`' ) , _T ( '~' ) ) ) { if ( md_is_opening_code_fence ( ctx , off , & off ) ) { line -> type = MD_LINE_FENCEDCODE ; line -> data = 1 ; break ; } } if ( off < ctx -> size && <S2SV_ModStart> == _T ( <S2SV_ModEnd> '<' ) && <S2SV_ModStart> type == MD_LINE_TEXT && off < ctx -> size && ISANYOF3 ( off , <S2SV_ModEnd> _T ( '|' <S2SV_ModStart> ( '|' ) , <S2SV_ModEnd> _T ( '-' <S2SV_ModStart> ( '-' ) , <S2SV_ModEnd> _T ( ':' <S2SV_ModStart> ':' ) ) && <S2SV_ModEnd> n_parents == ctx
"
728,"CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , <S2SV_StartBug> height , <S2SV_EndBug> length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth ) > ( 8 * sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; else { if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; } sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { <S2SV_StartBug> if ( bytes_per_line == 0 ) <S2SV_EndBug> <S2SV_StartBug> bytes_per_line = image -> columns ; <S2SV_EndBug> <S2SV_StartBug> length = image -> rows * ( image -> columns + image -> columns % 2 ) ; <S2SV_EndBug> if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> SetPixelIndex ( image , * p ++ , q ) ; <S2SV_EndBug> q += GetPixelChannels ( image ) ; } <S2SV_StartBug> if ( ( image -> columns % 2 ) != 0 ) <S2SV_EndBug> p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> extent , height <S2SV_ModEnd> ; ssize_t count <S2SV_ModStart> PseudoClass ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( <S2SV_ModEnd> image -> columns <S2SV_ModStart> % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns <S2SV_ModEnd> ; for ( <S2SV_ModStart> ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( <S2SV_ModEnd> * p ++ <S2SV_ModStart> * p ++ ) <S2SV_ModStart> q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } <S2SV_ModStart> if ( ( <S2SV_ModEnd> ( bytes_per_pixel *
"
729,"CWE-295 static krb5_error_code tgs_make_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ_BODY * b , krb5_const_principal tgt_name , const EncTicketPart * tgt , const krb5_keyblock * replykey , int rk_is_subkey , const EncryptionKey * serverkey , const krb5_keyblock * sessionkey , krb5_kvno kvno , AuthorizationData * auth_data , hdb_entry_ex * server , krb5_principal server_principal , const char * server_name , hdb_entry_ex * client , <S2SV_StartBug> krb5_principal client_principal , <S2SV_EndBug> hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , krb5_principals spp , const krb5_data * rspac , const METHOD_DATA * enc_pa_data , const char * * e_text , krb5_data * reply ) { KDC_REP rep ; EncKDCRepPart ek ; EncTicketPart et ; KDCOptions f = b -> kdc_options ; krb5_error_code ret ; int is_weak = 0 ; memset ( & rep , 0 , sizeof ( rep ) ) ; memset ( & et , 0 , sizeof ( et ) ) ; memset ( & ek , 0 , sizeof ( ek ) ) ; rep . pvno = 5 ; rep . msg_type = krb_tgs_rep ; et . authtime = tgt -> authtime ; _kdc_fix_time ( & b -> till ) ; et . endtime = min ( tgt -> endtime , * b -> till ) ; ALLOC ( et . starttime ) ; * et . starttime = kdc_time ; ret = check_tgs_flags ( context , config , b , tgt , & et ) ; if ( ret ) goto out ; # define GLOBAL_FORCE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_CHECK ) # define GLOBAL_ALLOW_PER_PRINCIPAL ( config -> trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL ) # define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST ) # define PRINCIPAL_FORCE_TRANSITED_CHECK ( P ) 0 # define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( P ) 0 ret = fix_transited_encoding ( context , config , ! f . disable_transited_check || GLOBAL_FORCE_TRANSITED_CHECK || PRINCIPAL_FORCE_TRANSITED_CHECK ( server ) || ! ( ( GLOBAL_ALLOW_PER_PRINCIPAL && PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( server ) ) || GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ) , & tgt -> transited , & et , krb5_principal_get_realm ( context , client_principal ) , krb5_principal_get_realm ( context , server -> entry . principal ) , <S2SV_StartBug> krb5_principal_get_realm ( context , krbtgt -> entry . principal ) ) ; <S2SV_EndBug> if ( ret ) goto out ; copy_Realm ( & server_principal -> realm , & rep . ticket . realm ) ; _krb5_principal2principalname ( & rep . ticket . sname , server_principal ) ; copy_Realm ( & tgt_name -> realm , & rep . crealm ) ; copy_PrincipalName ( & tgt_name -> name , & rep . cname ) ; rep . ticket . tkt_vno = 5 ; ek . caddr = et . caddr ; { time_t life ; life = et . endtime - * et . starttime ; if ( client && client -> entry . max_life ) life = min ( life , * client -> entry . max_life ) ; if ( server -> entry . max_life ) life = min ( life , * server -> entry . max_life ) ; et . endtime = * et . starttime + life ; } if ( f . renewable_ok && tgt -> flags . renewable && et . renew_till == NULL && et . endtime < * b -> till && tgt -> renew_till != NULL ) { et . flags . renewable = 1 ; ALLOC ( et . renew_till ) ; * et . renew_till = * b -> till ; } if ( et . renew_till ) { time_t renew ; renew = * et . renew_till - * et . starttime ; if ( client && client -> entry . max_renew ) renew = min ( renew , * client -> entry . max_renew ) ; if ( server -> entry . max_renew ) renew = min ( renew , * server -> entry . max_renew ) ; * et . renew_till = * et . starttime + renew ; } if ( et . renew_till ) { * et . renew_till = min ( * et . renew_till , * tgt -> renew_till ) ; * et . starttime = min ( * et . starttime , * et . renew_till ) ; et . endtime = min ( et . endtime , * et . renew_till ) ; } * et . starttime = min ( * et . starttime , et . endtime ) ; if ( * et . starttime == et . endtime ) { ret = KRB5KDC_ERR_NEVER_VALID ; goto out ; } if ( et . renew_till && et . endtime == * et . renew_till ) { free ( et . renew_till ) ; et . renew_till = NULL ; et . flags . renewable = 0 ; } et . flags . pre_authent = tgt -> flags . pre_authent ; et . flags . hw_authent = tgt -> flags . hw_authent ; et . flags . anonymous = tgt -> flags . anonymous ; et . flags . ok_as_delegate = server -> entry . flags . ok_as_delegate ; if ( rspac -> length ) { ret = _kdc_tkt_add_if_relevant_ad ( context , & et , KRB5_AUTHDATA_WIN2K_PAC , rspac ) ; if ( ret ) goto out ; } if ( auth_data ) { unsigned int i = 0 ; if ( et . authorization_data == NULL ) { et . authorization_data = calloc ( 1 , sizeof ( * et . authorization_data ) ) ; if ( et . authorization_data == NULL ) { ret = ENOMEM ; krb5_set_error_message ( context , ret , ""malloc:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory"" ) ; goto out ; } } for ( i = 0 ; i < auth_data -> len ; i ++ ) { ret = add_AuthorizationData ( et . authorization_data , & auth_data -> val [ i ] ) ; if ( ret ) { krb5_set_error_message ( context , ret , ""malloc:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory"" ) ; goto out ; } } ret = find_KRB5SignedPath ( context , et . authorization_data , NULL ) ; if ( ret == 0 ) { if ( et . authorization_data -> len == 1 ) { free_AuthorizationData ( et . authorization_data ) ; free ( et . authorization_data ) ; et . authorization_data = NULL ; } else { AuthorizationData * ad = et . authorization_data ; free_AuthorizationDataElement ( & ad -> val [ ad -> len - 1 ] ) ; ad -> len -- ; } } } ret = krb5_copy_keyblock_contents ( context , sessionkey , & et . key ) ; if ( ret ) goto out ; et . crealm = tgt_name -> realm ; et . cname = tgt_name -> name ; ek . key = et . key ; ek . last_req . val = calloc ( 1 , sizeof ( * ek . last_req . val ) ) ; if ( ek . last_req . val == NULL ) { ret = ENOMEM ; goto out ; } ek . last_req . len = 1 ; ek . nonce = b -> nonce ; ek . flags = et . flags ; ek . authtime = et . authtime ; ek . starttime = et . starttime ; ek . endtime = et . endtime ; ek . renew_till = et . renew_till ; ek . srealm = rep . ticket . realm ; ek . sname = rep . ticket . sname ; _kdc_log_timestamp ( context , config , ""TGS-REQ"" , et . authtime , et . starttime , et . endtime , et . renew_till ) ; { char * r = get_krbtgt_realm ( & ek . sname ) ; if ( r == NULL || strcmp ( r , ek . srealm ) == 0 ) { ret = _kdc_add_KRB5SignedPath ( context , config , krbtgt , krbtgt_etype , client_principal , NULL , spp , & et ) ; if ( ret ) goto out ; } } if ( enc_pa_data -> len ) { rep . padata = calloc ( 1 , sizeof ( * rep . padata ) ) ; if ( rep . padata == NULL ) { ret = ENOMEM ; goto out ; } ret = copy_METHOD_DATA ( enc_pa_data , rep . padata ) ; if ( ret ) goto out ; } if ( krb5_enctype_valid ( context , serverkey -> keytype ) != 0 && _kdc_is_weak_exception ( server -> entry . principal , serverkey -> keytype ) ) { krb5_enctype_enable ( context , serverkey -> keytype ) ; is_weak = 1 ; } ret = _kdc_encode_reply ( context , config , NULL , 0 , & rep , & et , & ek , serverkey -> keytype , kvno , serverkey , 0 , replykey , rk_is_subkey , e_text , reply ) ; if ( is_weak ) krb5_enctype_disable ( context , serverkey -> keytype ) ; out : free_TGS_REP ( & rep ) ; free_TransitedEncoding ( & et . transited ) ; if ( et . starttime ) free ( et . starttime ) ; if ( et . renew_till ) free ( et . renew_till ) ; if ( et . authorization_data ) { free_AuthorizationData ( et . authorization_data ) ; free ( et . authorization_data ) ; } free_LastReq ( & ek . last_req ) ; memset ( et . key . keyvalue . data , 0 , et . key . keyvalue . length ) ; free_EncryptionKey ( & et . key ) ; return ret ; }
","<S2SV_ModStart> , krb5_principal client_principal , const char * tgt_realm <S2SV_ModStart> principal ) , tgt_realm <S2SV_ModEnd> ) ; if
"
730,"CWE-835 static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { BMPInfo bmp_info ; Image * image ; MagickBooleanType status ; MagickOffsetType offset , start_position ; MemoryInfo * pixel_info ; Quantum index ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bit , bytes_per_line , length ; ssize_t count , y ; unsigned char magick [ 12 ] , * pixels ; unsigned int blue , green , offset_bits , red ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; bmp_info . ba_offset = 0 ; start_position = 0 ; offset_bits = 0 ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { PixelInfo quantum_bits ; PixelPacket shift ; start_position = TellBlob ( image ) - 2 ; bmp_info . ba_offset = 0 ; while ( LocaleNCompare ( ( char * ) magick , ""BA"" , 2 ) == 0 ) { bmp_info . file_size = ReadBlobLSBLong ( image ) ; bmp_info . ba_offset = ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) break ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Magick:<S2SV_blank>%c%c"" , magick [ 0 ] , magick [ 1 ] ) ; if ( ( count != 2 ) || ( ( LocaleNCompare ( ( char * ) magick , ""BM"" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , ""CI"" , 2 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bmp_info . file_size = ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; bmp_info . size = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>BMP<S2SV_blank>size:<S2SV_blank>%u"" , bmp_info . size ) ; if ( bmp_info . size == 12 ) { ( void ) CopyMagickString ( image -> magick , ""BMP2"" , MagickPathExtent ) ; bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . x_pixels = 0 ; bmp_info . y_pixels = 0 ; bmp_info . number_colors = 0 ; bmp_info . compression = BI_RGB ; bmp_info . image_size = 0 ; bmp_info . alpha_mask = 0 ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>OS/2<S2SV_blank>Bitmap"" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; } } else { if ( bmp_info . size < 40 ) ThrowReaderException ( CorruptImageError , ""NonOS2HeaderSizeError"" ) ; bmp_info . width = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . height = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . compression = ReadBlobLSBLong ( image ) ; bmp_info . image_size = ReadBlobLSBLong ( image ) ; bmp_info . x_pixels = ReadBlobLSBLong ( image ) ; bmp_info . y_pixels = ReadBlobLSBLong ( image ) ; bmp_info . number_colors = ReadBlobLSBLong ( image ) ; <S2SV_StartBug> if ( bmp_info . number_colors > GetBlobSize ( image ) ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; bmp_info . colors_important = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>MS<S2SV_blank>Windows<S2SV_blank>bitmap"" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Bits<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%.20g"" , ( double ) bmp_info . bits_per_pixel ) ; switch ( bmp_info . compression ) { case BI_RGB : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RGB"" ) ; break ; } case BI_RLE4 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE4"" ) ; break ; } case BI_RLE8 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE8"" ) ; break ; } case BI_BITFIELDS : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_BITFIELDS"" ) ; break ; } case BI_PNG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_PNG"" ) ; break ; } case BI_JPEG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_JPEG"" ) ; break ; } default : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>UNKNOWN<S2SV_blank>(%u)"" , bmp_info . compression ) ; } } ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%u"" , bmp_info . number_colors ) ; } bmp_info . red_mask = ReadBlobLSBLong ( image ) ; bmp_info . green_mask = ReadBlobLSBLong ( image ) ; bmp_info . blue_mask = ReadBlobLSBLong ( image ) ; if ( bmp_info . size > 40 ) { double gamma ; bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ; bmp_info . colorspace = ReadBlobLSBSignedLong ( image ) ; # define BMP_DENOM ( ( double ) 0x40000000 ) bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; gamma = bmp_info . red_primary . x + bmp_info . red_primary . y + bmp_info . red_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . red_primary . x *= gamma ; bmp_info . red_primary . y *= gamma ; image -> chromaticity . red_primary . x = bmp_info . red_primary . x ; image -> chromaticity . red_primary . y = bmp_info . red_primary . y ; gamma = bmp_info . green_primary . x + bmp_info . green_primary . y + bmp_info . green_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . green_primary . x *= gamma ; bmp_info . green_primary . y *= gamma ; image -> chromaticity . green_primary . x = bmp_info . green_primary . x ; image -> chromaticity . green_primary . y = bmp_info . green_primary . y ; gamma = bmp_info . blue_primary . x + bmp_info . blue_primary . y + bmp_info . blue_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . blue_primary . x *= gamma ; bmp_info . blue_primary . y *= gamma ; image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ; image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ; bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + bmp_info . gamma_scale . z ) / 3.0 ; } else ( void ) CopyMagickString ( image -> magick , ""BMP3"" , MagickPathExtent ) ; if ( bmp_info . size > 108 ) { size_t intent ; intent = ReadBlobLSBLong ( image ) ; switch ( ( int ) intent ) { case LCS_GM_BUSINESS : { image -> rendering_intent = SaturationIntent ; break ; } case LCS_GM_GRAPHICS : { image -> rendering_intent = RelativeIntent ; break ; } case LCS_GM_IMAGES : { image -> rendering_intent = PerceptualIntent ; break ; } case LCS_GM_ABS_COLORIMETRIC : { image -> rendering_intent = AbsoluteIntent ; break ; } } ( void ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; } } if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""LengthAndFilesizeDoNotMatch"" , ""`%s\'"" , image -> filename ) ; else if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""LengthAndFilesizeDoNotMatch"" , ""`%s\'"" , image -> filename ) ; if ( bmp_info . width <= 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; if ( bmp_info . height == 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; if ( bmp_info . planes != 1 ) ThrowReaderException ( CorruptImageError , ""StaticPlanesValueNotEqualToOne"" ) ; if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( bmp_info . bits_per_pixel < 16 && bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedNumberOfColors"" ) ; if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; switch ( bmp_info . compression ) { case BI_RGB : image -> compression = NoCompression ; break ; case BI_RLE8 : case BI_RLE4 : image -> compression = RLECompression ; break ; case BI_BITFIELDS : break ; case BI_JPEG : ThrowReaderException ( CoderError , ""JPEGCompressNotSupported"" ) ; case BI_PNG : ThrowReaderException ( CoderError , ""PNGCompressNotSupported"" ) ; default : ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ; image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ; image -> alpha_trait = ( ( bmp_info . alpha_mask != 0 ) && ( bmp_info . compression == BI_BITFIELDS ) ) ? BlendPixelTrait : UndefinedPixelTrait ; if ( bmp_info . bits_per_pixel < 16 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = bmp_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << bmp_info . bits_per_pixel ; } image -> resolution . x = ( double ) bmp_info . x_pixels / 100.0 ; image -> resolution . y = ( double ) bmp_info . y_pixels / 100.0 ; image -> units = PixelsPerCentimeterResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> storage_class == PseudoClass ) { unsigned char * bmp_colormap ; size_t packet_size ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>colormap<S2SV_blank>of<S2SV_blank>%.20g<S2SV_blank>colors"" , ( double ) image -> colors ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4 * sizeof ( * bmp_colormap ) ) ; if ( bmp_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) packet_size = 3 ; else packet_size = 4 ; offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ; if ( offset < 0 ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } p = bmp_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; } if ( bmp_info . offset_bits == offset_bits ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; offset_bits = bmp_info . offset_bits ; offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( bmp_info . compression == BI_RLE4 ) bmp_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ; length = ( size_t ) bytes_per_line * image -> rows ; if ( ( bmp_info . compression == BI_RGB ) || ( bmp_info . compression == BI_BITFIELDS ) ) { if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>pixels<S2SV_blank>(%.20g<S2SV_blank>bytes)"" , ( double ) length ) ; count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } } else { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; status = DecodeImage ( image , bmp_info . compression , pixels , image -> columns * image -> rows ) ; if ( status == MagickFalse ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToRunlengthDecodeImage"" ) ; } } if ( bmp_info . compression == BI_RGB ) { if ( ( image -> alpha_trait == UndefinedPixelTrait ) && ( bmp_info . size == 40 ) && ( bmp_info . bits_per_pixel == 32 ) ) { bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( * ( p + 3 ) != 0 ) { image -> alpha_trait = BlendPixelTrait ; y = - 1 ; break ; } p += 4 ; } } } bmp_info . alpha_mask = image -> alpha_trait != UndefinedPixelTrait ? 0xff000000U : 0U ; bmp_info . red_mask = 0x00ff0000U ; bmp_info . green_mask = 0x0000ff00U ; bmp_info . blue_mask = 0x000000ffU ; if ( bmp_info . bits_per_pixel == 16 ) { bmp_info . red_mask = 0x00007c00U ; bmp_info . green_mask = 0x000003e0U ; bmp_info . blue_mask = 0x0000001fU ; } } ( void ) memset ( & shift , 0 , sizeof ( shift ) ) ; ( void ) memset ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ; if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) { register unsigned int sample ; if ( bmp_info . red_mask != 0 ) while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) { shift . red ++ ; if ( shift . red >= 32U ) break ; } if ( bmp_info . green_mask != 0 ) while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) { shift . green ++ ; if ( shift . green >= 32U ) break ; } if ( bmp_info . blue_mask != 0 ) while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) { shift . blue ++ ; if ( shift . blue >= 32U ) break ; } if ( bmp_info . alpha_mask != 0 ) while ( ( ( bmp_info . alpha_mask << shift . alpha ) & 0x80000000UL ) == 0 ) { shift . alpha ++ ; if ( shift . alpha >= 32U ) break ; } sample = shift . red ; while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . red = ( MagickRealType ) ( sample - shift . red ) ; sample = shift . green ; while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . green = ( MagickRealType ) ( sample - shift . green ) ; sample = shift . blue ; while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . blue = ( MagickRealType ) ( sample - shift . blue ) ; sample = shift . alpha ; while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . alpha = ( MagickRealType ) ( sample - shift . alpha ) ; } switch ( bmp_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; ValidateColormapValue ( image , ( ssize_t ) ( * p & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0xf ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; x ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 8 : { if ( ( bmp_info . compression == BI_RLE8 ) || ( bmp_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = ( ssize_t ) image -> columns ; x != 0 ; -- x ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 16 : { unsigned int alpha , pixel ; if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ; image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( * p ++ ) << 8 ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 5 ) red |= ( ( red & 0xe000 ) >> 5 ) ; if ( quantum_bits . red <= 8 ) red |= ( ( red & 0xff00 ) >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 5 ) green |= ( ( green & 0xe000 ) >> 5 ) ; if ( quantum_bits . green == 6 ) green |= ( ( green & 0xc000 ) >> 6 ) ; if ( quantum_bits . green <= 8 ) green |= ( ( green & 0xff00 ) >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 5 ) blue |= ( ( blue & 0xe000 ) >> 5 ) ; if ( quantum_bits . blue <= 8 ) blue |= ( ( blue & 0xff00 ) >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha <= 8 ) alpha |= ( ( alpha & 0xff00 ) >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : { bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 32 : { if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { unsigned int alpha , pixel ; p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( ( unsigned int ) * p ++ << 8 ) ; pixel |= ( ( unsigned int ) * p ++ << 16 ) ; pixel |= ( ( unsigned int ) * p ++ << 24 ) ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 8 ) red |= ( red >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 8 ) green |= ( green >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 8 ) blue |= ( blue >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha == 8 ) alpha |= ( alpha >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( y > 0 ) break ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( bmp_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; ReplaceImageInList ( & image , flipped_image ) ; image = flipped_image ; } } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> * magick = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> if ( bmp_info . ba_offset != 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> offset = SeekBlob ( image , ( MagickOffsetType ) bmp_info . ba_offset , SEEK_SET ) ; <S2SV_StartBug> if ( offset < 0 ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_StartBug> } <S2SV_EndBug> count = ReadBlob ( image , 2 , magick ) ; if ( ( count == 2 ) && ( IsBMP ( magick , 2 ) != MagickFalse ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( IsBMP ( magick , 2 ) != MagickFalse ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ; if ( ( MagickSizeType ) <S2SV_ModStart> ) break ; offset = ( MagickOffsetType ) <S2SV_ModEnd> bmp_info . ba_offset <S2SV_ModStart> bmp_info . ba_offset ; if ( offset <S2SV_ModStart> != 0 ) if ( <S2SV_ModEnd> ( offset < <S2SV_ModStart> ( offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) <S2SV_ModEnd> ) ThrowReaderException ( <S2SV_ModStart> ""ImproperImageHeader"" ) ; * magick = '\\0' ; <S2SV_ModEnd> count = ReadBlob
"
731,"CWE-362 struct sock * dccp_v4_request_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet_request_sock * ireq ; struct inet_sock * newinet ; struct sock * newsk ; if ( sk_acceptq_is_full ( sk ) ) goto exit_overflow ; if ( dst == NULL && ( dst = inet_csk_route_req ( sk , req ) ) == NULL ) goto exit ; newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto exit_nonewsk ; sk_setup_caps ( newsk , dst ) ; newinet = inet_sk ( newsk ) ; ireq = inet_rsk ( req ) ; newinet -> inet_daddr = ireq -> rmt_addr ; newinet -> inet_rcv_saddr = ireq -> loc_addr ; newinet -> inet_saddr = ireq -> loc_addr ; <S2SV_StartBug> newinet -> opt = ireq -> opt ; <S2SV_EndBug> ireq -> opt = NULL ; newinet -> mc_index = inet_iif ( skb ) ; newinet -> mc_ttl = ip_hdr ( skb ) -> ttl ; newinet -> inet_id = jiffies ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto exit ; } __inet_hash_nolisten ( newsk , NULL ) ; return newsk ; exit_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; exit_nonewsk : dst_release ( dst ) ; exit : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }
","<S2SV_ModStart> ; newinet -> inet_opt <S2SV_ModEnd> = ireq ->
"
732,"CWE-119 void ParseNameValue ( const char * buffer , int bufsize , struct NameValueParserData * data ) { struct xmlparser parser ; <S2SV_StartBug> data -> l_head = NULL ; <S2SV_EndBug> data -> portListing = NULL ; data -> portListingLength = 0 ; parser . xmlstart = buffer ; parser . xmlsize = bufsize ; parser . data = data ; parser . starteltfunc = NameValueParserStartElt ; parser . endeltfunc = NameValueParserEndElt ; parser . datafunc = NameValueParserGetData ; parser . attfunc = 0 ; parsexml ( & parser ) ; }
","<S2SV_ModStart> xmlparser parser ; memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> ; parser .
"
733,"CWE-125 static void ip_cmsg_recv_checksum ( struct msghdr * msg , struct sk_buff * skb , int tlen , int offset ) { __wsum csum = skb -> csum ; if ( skb -> ip_summed != CHECKSUM_COMPLETE ) return ; <S2SV_StartBug> if ( offset != 0 ) <S2SV_EndBug> csum = csum_sub ( csum , <S2SV_StartBug> csum_partial ( skb_transport_header ( skb ) + tlen , <S2SV_EndBug> <S2SV_StartBug> offset , 0 ) ) ; <S2SV_EndBug> put_cmsg ( msg , SOL_IP , IP_CHECKSUM , sizeof ( __wsum ) , & csum ) ; }
","<S2SV_ModStart> != 0 ) { int tend_off = skb_transport_offset ( skb ) + tlen ; <S2SV_ModStart> ( csum , skb_checksum ( skb , tend_off , <S2SV_ModEnd> offset , 0 <S2SV_ModStart> ) ) ; }
"
734,"CWE-189 int kvm_iommu_map_pages ( struct kvm * kvm , struct kvm_memory_slot * slot ) { gfn_t gfn , end_gfn ; pfn_t pfn ; int r = 0 ; struct iommu_domain * domain = kvm -> arch . iommu_domain ; int flags ; if ( ! domain ) return 0 ; gfn = slot -> base_gfn ; end_gfn = gfn + slot -> npages ; flags = IOMMU_READ ; if ( ! ( slot -> flags & KVM_MEM_READONLY ) ) flags |= IOMMU_WRITE ; if ( ! kvm -> arch . iommu_noncoherent ) flags |= IOMMU_CACHE ; while ( gfn < end_gfn ) { unsigned long page_size ; if ( iommu_iova_to_phys ( domain , gfn_to_gpa ( gfn ) ) ) { gfn += 1 ; continue ; } page_size = kvm_host_page_size ( kvm , gfn ) ; while ( ( gfn + ( page_size >> PAGE_SHIFT ) ) > end_gfn ) page_size >>= 1 ; while ( ( gfn << PAGE_SHIFT ) & ( page_size - 1 ) ) page_size >>= 1 ; while ( __gfn_to_hva_memslot ( slot , gfn ) & ( page_size - 1 ) ) page_size >>= 1 ; pfn = kvm_pin_pages ( slot , gfn , page_size ) ; if ( is_error_noslot_pfn ( pfn ) ) { gfn += 1 ; continue ; } r = iommu_map ( domain , gfn_to_gpa ( gfn ) , pfn_to_hpa ( pfn ) , page_size , flags ) ; if ( r ) { printk ( KERN_ERR ""kvm_iommu_map_address:"" ""iommu<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>map<S2SV_blank>pfn=%llx\\n"" , pfn ) ; <S2SV_StartBug> goto unmap_pages ; <S2SV_EndBug> } gfn += page_size >> PAGE_SHIFT ; } return 0 ; unmap_pages : <S2SV_StartBug> kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn ) ; <S2SV_EndBug> return r ; }
","<S2SV_ModStart> pfn ) ; kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_ModStart> base_gfn , gfn - slot -> base_gfn
"
735,"CWE-119 static int ttusbdecfe_dvbs_diseqc_send_master_cmd ( struct dvb_frontend * fe , struct dvb_diseqc_master_cmd * cmd ) { struct ttusbdecfe_state * state = ( struct ttusbdecfe_state * ) fe -> demodulator_priv ; u8 b [ ] = { 0x00 , 0xff , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 } ; <S2SV_StartBug> memcpy ( & b [ 4 ] , cmd -> msg , cmd -> msg_len ) ; <S2SV_EndBug> state -> config -> send_command ( fe , 0x72 , sizeof ( b ) - ( 6 - cmd -> msg_len ) , b , NULL , NULL ) ; return 0 ; }
","<S2SV_ModStart> 0x00 } ; if ( cmd -> msg_len > sizeof ( b ) - 4 ) return - EINVAL ;
"
736,"CWE-264 void perf_event_disable ( struct perf_event * event ) { <S2SV_StartBug> struct perf_event_context * ctx = event -> ctx ; <S2SV_EndBug> struct task_struct * task = ctx -> task ; if ( ! task ) { cpu_function_call ( event -> cpu , __perf_event_disable , event ) ; return ; } retry : if ( ! task_function_call ( task , __perf_event_disable , event ) ) return ; raw_spin_lock_irq ( & ctx -> lock ) ; if ( event -> state == PERF_EVENT_STATE_ACTIVE ) { raw_spin_unlock_irq ( & ctx -> lock ) ; task = ctx -> task ; goto retry ; } if ( event -> state == PERF_EVENT_STATE_INACTIVE ) { update_group_times ( event ) ; <S2SV_StartBug> event -> state = PERF_EVENT_STATE_OFF ; <S2SV_EndBug> } raw_spin_unlock_irq ( & ctx -> lock ) ; }
","<S2SV_ModStart> perf_event_context * ctx ; ctx = perf_event_ctx_lock <S2SV_ModEnd> ( event ) <S2SV_ModStart> event ) ; _perf_event_disable ( event ) ; perf_event_ctx_unlock ( event , ctx <S2SV_ModEnd> ) ; }
"
737,"CWE-125 static inline unsigned int ReadPropertyUnsignedLong ( const EndianType endian , const unsigned char * buffer ) { unsigned int value ; if ( endian == LSBEndian ) { <S2SV_StartBug> value = ( unsigned int ) ( ( buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) | <S2SV_EndBug> <S2SV_StartBug> ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned int ) ( value & 0xffffffff ) ) ; <S2SV_EndBug> } <S2SV_StartBug> value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ) | ( buffer [ 1 ] << 16 ) | <S2SV_EndBug> <S2SV_StartBug> ( buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned int ) ( value & 0xffffffff ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> unsigned int ) <S2SV_ModEnd> buffer [ 3 <S2SV_ModStart> ] << 24 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 2 <S2SV_ModStart> ] << 16 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 8 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ; return ( <S2SV_ModStart> ; return ( <S2SV_ModEnd> value & 0xffffffff <S2SV_ModStart> value & 0xffffffff <S2SV_ModEnd> ) ; } <S2SV_ModStart> unsigned int ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> ] << 24 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 16 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 2 <S2SV_ModStart> ] << 8 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 3 <S2SV_ModStart> [ 3 ] ; return <S2SV_ModEnd> ( value & <S2SV_ModStart> & 0xffffffff ) <S2SV_ModEnd> ; } <S2SV_null>
"
738,"CWE-362 static bool add_free_nid ( struct f2fs_sb_info * sbi , nid_t nid , bool build ) { struct f2fs_nm_info * nm_i = NM_I ( sbi ) ; <S2SV_StartBug> struct free_nid * i ; <S2SV_EndBug> struct nat_entry * ne ; <S2SV_StartBug> int err ; <S2SV_EndBug> if ( unlikely ( nid == 0 ) ) return false ; <S2SV_StartBug> if ( build ) { <S2SV_EndBug> ne = __lookup_nat_cache ( nm_i , nid ) ; if ( ne && ( ! get_nat_flag ( ne , IS_CHECKPOINTED ) || nat_get_blkaddr ( ne ) != NULL_ADDR ) ) <S2SV_StartBug> return false ; <S2SV_EndBug> } i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) { kmem_cache_free ( free_nid_slab , i ) ; return true ; } spin_lock ( & nm_i -> nid_list_lock ) ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; if ( err ) { kmem_cache_free ( free_nid_slab , i ) ; return true ; } return true ; }
","<S2SV_ModStart> free_nid * i , * e <S2SV_ModStart> ; int err = - EINVAL ; bool ret = false <S2SV_ModStart> return false ; i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) goto err ; spin_lock ( & nm_i -> nid_list_lock ) ; <S2SV_ModStart> NULL_ADDR ) ) goto err_out ; e = __lookup_free_nid_list ( nm_i , nid ) ; if ( e ) { if ( e -> state == NID_NEW ) ret = true ; goto err_out ; } } ret = true ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; err_out : spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; err : if ( err ) kmem_cache_free ( free_nid_slab , i ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
"
739,"CWE-119 static void set_ppflags ( const vpx_codec_alg_priv_t * ctx , vp9_ppflags_t * flags ) { flags -> post_proc_flag = <S2SV_StartBug> # if CONFIG_POSTPROC_VISUALIZER <S2SV_EndBug> ( ctx -> dbg_color_ref_frame_flag ? VP9D_DEBUG_CLR_FRM_REF_BLKS : 0 ) | ( ctx -> dbg_color_mb_modes_flag ? VP9D_DEBUG_CLR_BLK_MODES : 0 ) | ( ctx -> dbg_color_b_modes_flag ? VP9D_DEBUG_CLR_BLK_MODES : 0 ) | ( ctx -> dbg_display_mv_flag ? VP9D_DEBUG_DRAW_MV : 0 ) | # endif ctx -> postproc_cfg . post_proc_flag ; flags -> deblocking_level = ctx -> postproc_cfg . deblocking_level ; flags -> noise_level = ctx -> postproc_cfg . noise_level ; <S2SV_StartBug> # if CONFIG_POSTPROC_VISUALIZER <S2SV_EndBug> flags -> display_ref_frame_flag = ctx -> dbg_color_ref_frame_flag ; flags -> display_mb_modes_flag = ctx -> dbg_color_mb_modes_flag ; flags -> display_b_modes_flag = ctx -> dbg_color_b_modes_flag ; flags -> display_mv_flag = ctx -> dbg_display_mv_flag ; # endif }
","<S2SV_ModStart> -> post_proc_flag = <S2SV_ModEnd> ctx -> postproc_cfg <S2SV_ModStart> . noise_level ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
740,"CWE-20 static int xen_netbk_get_extras ( struct xenvif * vif , struct xen_netif_extra_info * extras , int work_to_do ) { struct xen_netif_extra_info extra ; RING_IDX cons = vif -> tx . req_cons ; do { if ( unlikely ( work_to_do -- <= 0 ) ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Missing<S2SV_blank>extra<S2SV_blank>info\\n"" ) ; <S2SV_EndBug> return - EBADR ; } memcpy ( & extra , RING_GET_REQUEST ( & vif -> tx , cons ) , sizeof ( extra ) ) ; if ( unlikely ( ! extra . type || extra . type >= XEN_NETIF_EXTRA_TYPE_MAX ) ) { vif -> tx . req_cons = ++ cons ; <S2SV_StartBug> netdev_dbg ( vif -> dev , <S2SV_EndBug> <S2SV_StartBug> ""Invalid<S2SV_blank>extra<S2SV_blank>type:<S2SV_blank>%d\\n"" , extra . type ) ; <S2SV_EndBug> return - EINVAL ; } memcpy ( & extras [ extra . type - 1 ] , & extra , sizeof ( extra ) ) ; vif -> tx . req_cons = ++ cons ; } while ( extra . flags & XEN_NETIF_EXTRA_FLAG_MORE ) ; return work_to_do ; }
","<S2SV_ModStart> ) ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev , ""Missing<S2SV_blank>extra<S2SV_blank>info\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> ++ cons ; netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> extra . type ) ; netbk_fatal_tx_err ( vif
"
741,"CWE-119 static int key_notify_policy_flush ( const struct km_event * c ) { struct sk_buff * skb_out ; struct sadb_msg * hdr ; skb_out = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , GFP_ATOMIC ) ; if ( ! skb_out ) return - ENOBUFS ; hdr = ( struct sadb_msg * ) skb_put ( skb_out , sizeof ( struct sadb_msg ) ) ; hdr -> sadb_msg_type = SADB_X_SPDFLUSH ; hdr -> sadb_msg_seq = c -> seq ; hdr -> sadb_msg_pid = c -> portid ; hdr -> sadb_msg_version = PF_KEY_V2 ; hdr -> sadb_msg_errno = ( uint8_t ) 0 ; hdr -> sadb_msg_satype = SADB_SATYPE_UNSPEC ; hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; <S2SV_StartBug> pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> ) ) ; hdr -> sadb_msg_reserved = 0 ;
"
742,"CWE-200 static void snd_timer_user_ccallback ( struct snd_timer_instance * timeri , int event , struct timespec * tstamp , unsigned long resolution ) { struct snd_timer_user * tu = timeri -> callback_data ; struct snd_timer_tread r1 ; unsigned long flags ; if ( event >= SNDRV_TIMER_EVENT_START && event <= SNDRV_TIMER_EVENT_PAUSE ) tu -> tstamp = * tstamp ; if ( ( tu -> filter & ( 1 << event ) ) == 0 || ! tu -> tread ) return ; <S2SV_StartBug> r1 . event = event ; <S2SV_EndBug> r1 . tstamp = * tstamp ; r1 . val = resolution ; spin_lock_irqsave ( & tu -> qlock , flags ) ; snd_timer_user_append_to_tqueue ( tu , & r1 ) ; spin_unlock_irqrestore ( & tu -> qlock , flags ) ; kill_fasync ( & tu -> fasync , SIGIO , POLL_IN ) ; wake_up ( & tu -> qchange_sleep ) ; }
","<S2SV_ModStart> ) return ; memset ( & r1 , 0 , sizeof ( r1 ) ) ;
"
743,"CWE-190 static int b_unpack ( lua_State * L ) { Header h ; const char * fmt = luaL_checkstring ( L , 1 ) ; size_t ld ; const char * data = luaL_checklstring ( L , 2 , & ld ) ; size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ; <S2SV_StartBug> defaultoptions ( & h ) ; <S2SV_EndBug> lua_settop ( L , 2 ) ; while ( * fmt ) { int opt = * fmt ++ ; size_t size = optsize ( L , opt , & fmt ) ; pos += gettoalign ( pos , & h , opt , size ) ; luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; <S2SV_StartBug> luaL_checkstack ( L , 1 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ; <S2SV_EndBug> switch ( opt ) { case 'b' : case 'B' : case 'h' : case 'H' : case 'l' : case 'L' : case 'T' : case 'i' : case 'I' : { int issigned = islower ( opt ) ; lua_Number res = getinteger ( data + pos , h . endian , issigned , size ) ; <S2SV_StartBug> lua_pushnumber ( L , res ) ; <S2SV_EndBug> break ; } case 'x' : { break ; } case 'f' : { float f ; memcpy ( & f , data + pos , size ) ; correctbytes ( ( char * ) & f , sizeof ( f ) , h . endian ) ; <S2SV_StartBug> lua_pushnumber ( L , f ) ; <S2SV_EndBug> break ; } case 'd' : { double d ; memcpy ( & d , data + pos , size ) ; correctbytes ( ( char * ) & d , sizeof ( d ) , h . endian ) ; <S2SV_StartBug> lua_pushnumber ( L , d ) ; <S2SV_EndBug> break ; } case 'c' : { if ( size == 0 ) { <S2SV_StartBug> if ( ! lua_isnumber ( L , - 1 ) ) <S2SV_EndBug> <S2SV_StartBug> luaL_error ( L , ""format<S2SV_blank>`c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" ) ; <S2SV_EndBug> size = lua_tonumber ( L , - 1 ) ; <S2SV_StartBug> lua_pop ( L , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; <S2SV_EndBug> } <S2SV_StartBug> lua_pushlstring ( L , data + pos , size ) ; <S2SV_EndBug> break ; } case 's' : { const char * e = ( const char * ) memchr ( data + pos , '\\0' , ld - pos ) ; if ( e == NULL ) luaL_error ( L , ""unfinished<S2SV_blank>string<S2SV_blank>in<S2SV_blank>data"" ) ; size = ( e - ( data + pos ) ) + 1 ; <S2SV_StartBug> lua_pushlstring ( L , data + pos , size - 1 ) ; <S2SV_EndBug> break ; } default : controloptions ( L , opt , & fmt , & h ) ; } pos += size ; } lua_pushinteger ( L , pos + 1 ) ; <S2SV_StartBug> return lua_gettop ( L ) - 2 ; <S2SV_EndBug> }
","<S2SV_ModStart> - 1 ; int n = 0 ; <S2SV_ModStart> ( & h <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( L , 2 <S2SV_ModEnd> , ""too<S2SV_blank>many<S2SV_blank>results"" ) <S2SV_ModStart> res ) ; n ++ ; <S2SV_ModStart> f ) ; n ++ ; <S2SV_ModStart> d ) ; n ++ ; <S2SV_ModStart> { if ( n == 0 || <S2SV_ModStart> ( L , ""format<S2SV_blank>\'c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" <S2SV_ModEnd> ) ; size <S2SV_ModStart> 1 ) ; n -- ; <S2SV_ModStart> ( L , <S2SV_ModEnd> size <= ld <S2SV_ModStart> size <= ld && pos <= ld - size , <S2SV_ModEnd> 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" <S2SV_ModStart> , size ) ; n ++ <S2SV_ModStart> 1 ) ; n ++ ; <S2SV_ModStart> ) ; return n + 1 <S2SV_ModEnd> ; } <S2SV_null>
"
744,"CWE-125 void olsr_print ( netdissect_options * ndo , const u_char * pptr , u_int length , int is_ipv6 ) { union { const struct olsr_common * common ; const struct olsr_msg4 * msg4 ; const struct olsr_msg6 * msg6 ; const struct olsr_hello * hello ; const struct olsr_hello_link * hello_link ; const struct olsr_tc * tc ; const struct olsr_hna4 * hna ; } ptr ; u_int msg_type , msg_len , msg_tlen , hello_len ; uint16_t name_entry_type , name_entry_len ; u_int name_entry_padding ; uint8_t link_type , neighbor_type ; const u_char * tptr , * msg_data ; tptr = pptr ; if ( length < sizeof ( struct olsr_common ) ) { goto trunc ; } ND_TCHECK2 ( * tptr , sizeof ( struct olsr_common ) ) ; ptr . common = ( const struct olsr_common * ) tptr ; length = min ( length , EXTRACT_16BITS ( ptr . common -> packet_len ) ) ; ND_PRINT ( ( ndo , ""OLSRv%i,<S2SV_blank>seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u"" , ( is_ipv6 == 0 ) ? 4 : 6 , EXTRACT_16BITS ( ptr . common -> packet_seq ) , length ) ) ; tptr += sizeof ( struct olsr_common ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } while ( tptr < ( pptr + length ) ) { union { const struct olsr_msg4 * v4 ; const struct olsr_msg6 * v6 ; } msgptr ; int msg_len_valid = 0 ; <S2SV_StartBug> ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_EndBug> if ( is_ipv6 ) { msgptr . v6 = ( const struct olsr_msg6 * ) tptr ; msg_type = msgptr . v6 -> msg_type ; msg_len = EXTRACT_16BITS ( msgptr . v6 -> msg_len ) ; if ( ( msg_len >= sizeof ( struct olsr_msg6 ) ) && ( msg_len <= length ) ) msg_len_valid = 1 ; if ( msg_type == 0 || msg_len == 0 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>Message<S2SV_blank>(%#04x),<S2SV_blank>originator<S2SV_blank>%s,<S2SV_blank>ttl<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank>vtime<S2SV_blank>%.3fs,<S2SV_blank>msg-seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u%s"" , tok2str ( olsr_msg_values , ""Unknown"" , msg_type ) , msg_type , ip6addr_string ( ndo , msgptr . v6 -> originator ) , msgptr . v6 -> ttl , msgptr . v6 -> hopcount , ME_TO_DOUBLE ( msgptr . v6 -> vtime ) , EXTRACT_16BITS ( msgptr . v6 -> msg_seq ) , msg_len , ( msg_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( ! msg_len_valid ) { return ; } msg_tlen = msg_len - sizeof ( struct olsr_msg6 ) ; msg_data = tptr + sizeof ( struct olsr_msg6 ) ; } else <S2SV_StartBug> { <S2SV_EndBug> msgptr . v4 = ( const struct olsr_msg4 * ) tptr ; msg_type = msgptr . v4 -> msg_type ; msg_len = EXTRACT_16BITS ( msgptr . v4 -> msg_len ) ; if ( ( msg_len >= sizeof ( struct olsr_msg4 ) ) && ( msg_len <= length ) ) msg_len_valid = 1 ; if ( msg_type == 0 || msg_len == 0 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\t%s<S2SV_blank>Message<S2SV_blank>(%#04x),<S2SV_blank>originator<S2SV_blank>%s,<S2SV_blank>ttl<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank>vtime<S2SV_blank>%.3fs,<S2SV_blank>msg-seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u%s"" , tok2str ( olsr_msg_values , ""Unknown"" , msg_type ) , msg_type , ipaddr_string ( ndo , msgptr . v4 -> originator ) , msgptr . v4 -> ttl , msgptr . v4 -> hopcount , ME_TO_DOUBLE ( msgptr . v4 -> vtime ) , EXTRACT_16BITS ( msgptr . v4 -> msg_seq ) , msg_len , ( msg_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( ! msg_len_valid ) { return ; } msg_tlen = msg_len - sizeof ( struct olsr_msg4 ) ; msg_data = tptr + sizeof ( struct olsr_msg4 ) ; } switch ( msg_type ) { case OLSR_HELLO_MSG : case OLSR_HELLO_LQ_MSG : if ( msg_tlen < sizeof ( struct olsr_hello ) ) goto trunc ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hello ) ) ; ptr . hello = ( const struct olsr_hello * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>hello-time<S2SV_blank>%.3fs,<S2SV_blank>MPR<S2SV_blank>willingness<S2SV_blank>%u"" , ME_TO_DOUBLE ( ptr . hello -> htime ) , ptr . hello -> will ) ) ; msg_data += sizeof ( struct olsr_hello ) ; msg_tlen -= sizeof ( struct olsr_hello ) ; while ( msg_tlen >= sizeof ( struct olsr_hello_link ) ) { int hello_len_valid = 0 ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hello_link ) ) ; ptr . hello_link = ( const struct olsr_hello_link * ) msg_data ; hello_len = EXTRACT_16BITS ( ptr . hello_link -> len ) ; link_type = OLSR_EXTRACT_LINK_TYPE ( ptr . hello_link -> link_code ) ; neighbor_type = OLSR_EXTRACT_NEIGHBOR_TYPE ( ptr . hello_link -> link_code ) ; if ( ( hello_len <= msg_tlen ) && ( hello_len >= sizeof ( struct olsr_hello_link ) ) ) hello_len_valid = 1 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>link-type<S2SV_blank>%s,<S2SV_blank>neighbor-type<S2SV_blank>%s,<S2SV_blank>len<S2SV_blank>%u%s"" , tok2str ( olsr_link_type_values , ""Unknown"" , link_type ) , tok2str ( olsr_neighbor_type_values , ""Unknown"" , neighbor_type ) , hello_len , ( hello_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( hello_len_valid == 0 ) break ; msg_data += sizeof ( struct olsr_hello_link ) ; msg_tlen -= sizeof ( struct olsr_hello_link ) ; hello_len -= sizeof ( struct olsr_hello_link ) ; ND_TCHECK2 ( * msg_data , hello_len ) ; if ( msg_type == OLSR_HELLO_MSG ) { if ( olsr_print_neighbor ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } else { if ( is_ipv6 ) { if ( olsr_print_lq_neighbor6 ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } else { if ( olsr_print_lq_neighbor4 ( ndo , msg_data , hello_len ) == - 1 ) goto trunc ; } } msg_data += hello_len ; msg_tlen -= hello_len ; } break ; case OLSR_TC_MSG : case OLSR_TC_LQ_MSG : if ( msg_tlen < sizeof ( struct olsr_tc ) ) goto trunc ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_tc ) ) ; ptr . tc = ( const struct olsr_tc * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>advertised<S2SV_blank>neighbor<S2SV_blank>seq<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( ptr . tc -> ans_seq ) ) ) ; msg_data += sizeof ( struct olsr_tc ) ; msg_tlen -= sizeof ( struct olsr_tc ) ; if ( msg_type == OLSR_TC_MSG ) { if ( olsr_print_neighbor ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } else { if ( is_ipv6 ) { if ( olsr_print_lq_neighbor6 ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } else { if ( olsr_print_lq_neighbor4 ( ndo , msg_data , msg_tlen ) == - 1 ) goto trunc ; } } break ; case OLSR_MID_MSG : { size_t addr_size = sizeof ( struct in_addr ) ; if ( is_ipv6 ) addr_size = sizeof ( struct in6_addr ) ; while ( msg_tlen >= addr_size ) { ND_TCHECK2 ( * msg_data , addr_size ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>interface<S2SV_blank>address<S2SV_blank>%s"" , is_ipv6 ? ip6addr_string ( ndo , msg_data ) : ipaddr_string ( ndo , msg_data ) ) ) ; msg_data += addr_size ; msg_tlen -= addr_size ; } break ; } case OLSR_HNA_MSG : if ( is_ipv6 ) { int i = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertised<S2SV_blank>networks<S2SV_blank>(total<S2SV_blank>%u)"" , ( unsigned int ) ( msg_tlen / sizeof ( struct olsr_hna6 ) ) ) ) ; while ( msg_tlen >= sizeof ( struct olsr_hna6 ) ) { const struct olsr_hna6 * hna6 ; ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hna6 ) ) ; hna6 = ( const struct olsr_hna6 * ) msg_data ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#%i:<S2SV_blank>%s/%u"" , i , ip6addr_string ( ndo , hna6 -> network ) , mask62plen ( hna6 -> mask ) ) ) ; msg_data += sizeof ( struct olsr_hna6 ) ; msg_tlen -= sizeof ( struct olsr_hna6 ) ; } } else { int col = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Advertised<S2SV_blank>networks<S2SV_blank>(total<S2SV_blank>%u)"" , ( unsigned int ) ( msg_tlen / sizeof ( struct olsr_hna4 ) ) ) ) ; while ( msg_tlen >= sizeof ( struct olsr_hna4 ) ) { ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hna4 ) ) ; ptr . hna = ( const struct olsr_hna4 * ) msg_data ; if ( ! ptr . hna -> network [ 0 ] && ! ptr . hna -> network [ 1 ] && ! ptr . hna -> network [ 2 ] && ! ptr . hna -> network [ 3 ] && ! ptr . hna -> mask [ GW_HNA_PAD ] && ptr . hna -> mask [ GW_HNA_FLAGS ] ) { ND_PRINT ( ( ndo , ""%sSmart-Gateway:%s%s%s%s%s<S2SV_blank>%u/%u"" , col == 0 ? ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" : "",<S2SV_blank>"" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? ""<S2SV_blank>LINKSPEED"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV4 ) ? ""<S2SV_blank>IPV4"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV4_NAT ) ? ""<S2SV_blank>IPV4-NAT"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV6 ) ? ""<S2SV_blank>IPV6"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_IPV6PREFIX ) ? ""<S2SV_blank>IPv6-PREFIX"" : """" , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? deserialize_gw_speed ( ptr . hna -> mask [ GW_HNA_UPLINK ] ) : 0 , ( ptr . hna -> mask [ GW_HNA_FLAGS ] & GW_HNA_FLAG_LINKSPEED ) ? deserialize_gw_speed ( ptr . hna -> mask [ GW_HNA_DOWNLINK ] ) : 0 ) ) ; } else { ND_PRINT ( ( ndo , ""%s%s/%u"" , col == 0 ? ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" : "",<S2SV_blank>"" , ipaddr_string ( ndo , ptr . hna -> network ) , mask2plen ( EXTRACT_32BITS ( ptr . hna -> mask ) ) ) ) ; } msg_data += sizeof ( struct olsr_hna4 ) ; msg_tlen -= sizeof ( struct olsr_hna4 ) ; col = ( col + 1 ) % 4 ; } } break ; case OLSR_NAMESERVICE_MSG : { <S2SV_StartBug> u_int name_entries = EXTRACT_16BITS ( msg_data + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> u_int addr_size = 4 ; <S2SV_EndBug> <S2SV_StartBug> int name_entries_valid = 0 ; <S2SV_EndBug> u_int i ; if ( is_ipv6 ) addr_size = 16 ; if ( ( name_entries > 0 ) && ( ( name_entries * ( 4 + addr_size ) ) <= msg_tlen ) ) <S2SV_StartBug> name_entries_valid = 1 ; <S2SV_EndBug> if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Version<S2SV_blank>%u,<S2SV_blank>Entries<S2SV_blank>%u%s"" , EXTRACT_16BITS ( msg_data ) , name_entries , ( name_entries_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( name_entries_valid == 0 ) break ; msg_data += 4 ; msg_tlen -= 4 ; for ( i = 0 ; i < name_entries ; i ++ ) { int name_entry_len_valid = 0 ; if ( msg_tlen < 4 ) break ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entry_type = EXTRACT_16BITS ( msg_data ) ; name_entry_len = EXTRACT_16BITS ( msg_data + 2 ) ; msg_data += 4 ; msg_tlen -= 4 ; if ( ( name_entry_len > 0 ) && ( ( addr_size + name_entry_len ) <= msg_tlen ) ) name_entry_len_valid = 1 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#%u:<S2SV_blank>type<S2SV_blank>%#06x,<S2SV_blank>length<S2SV_blank>%u%s"" , ( unsigned int ) i , name_entry_type , name_entry_len , ( name_entry_len_valid == 0 ) ? ""<S2SV_blank>(invalid)"" : """" ) ) ; if ( name_entry_len_valid == 0 ) break ; name_entry_padding = 0 ; if ( name_entry_len % 4 != 0 ) name_entry_padding = 4 - ( name_entry_len % 4 ) ; if ( msg_tlen < addr_size + name_entry_len + name_entry_padding ) goto trunc ; ND_TCHECK2 ( * msg_data , addr_size + name_entry_len + name_entry_padding ) ; if ( is_ipv6 ) ND_PRINT ( ( ndo , "",<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>name<S2SV_blank>\\"""" , ip6addr_string ( ndo , msg_data ) ) ) ; else ND_PRINT ( ( ndo , "",<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>name<S2SV_blank>\\"""" , ipaddr_string ( ndo , msg_data ) ) ) ; ( void ) fn_printn ( ndo , msg_data + addr_size , name_entry_len , NULL ) ; ND_PRINT ( ( ndo , ""\\"""" ) ) ; msg_data += addr_size + name_entry_len + name_entry_padding ; msg_tlen -= addr_size + name_entry_len + name_entry_padding ; } break ; } case OLSR_POWERINFO_MSG : default : print_unknown_data ( ndo , msg_data , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , msg_tlen ) ; break ; } tptr += msg_len ; } return ; trunc : ND_PRINT ( ( ndo , ""[|olsr]"" ) ) ; }
","<S2SV_ModStart> = 0 ; if ( is_ipv6 ) { <S2SV_ModStart> sizeof ( struct olsr_msg6 ) ) ; <S2SV_ModEnd> msgptr . v6 <S2SV_ModStart> } else { ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_ModStart> { u_int name_entries ; u_int addr_size ; int name_entries_valid ; u_int i ; if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entries <S2SV_ModStart> 2 ) ; <S2SV_ModEnd> addr_size = 4 <S2SV_ModStart> = 4 ; if ( is_ipv6 ) addr_size = 16 ; <S2SV_ModEnd> name_entries_valid = 0 <S2SV_ModStart> name_entries_valid = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> name_entries_valid = 1 <S2SV_ModEnd> ; ND_PRINT (
"
745,"CWE-119 static void oz_usb_handle_ep_data ( struct oz_usb_ctx * usb_ctx , struct oz_usb_hdr * usb_hdr , int len ) { struct oz_data * data_hdr = ( struct oz_data * ) usb_hdr ; switch ( data_hdr -> format ) { case OZ_DATA_F_MULTIPLE_FIXED : { struct oz_multiple_fixed * body = ( struct oz_multiple_fixed * ) data_hdr ; u8 * data = body -> data ; <S2SV_StartBug> int n ; <S2SV_EndBug> <S2SV_StartBug> if ( ! body -> unit_size ) <S2SV_EndBug> break ; <S2SV_StartBug> n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) <S2SV_EndBug> / body -> unit_size ; while ( n -- ) { oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint , data , body -> unit_size ) ; data += body -> unit_size ; } } break ; case OZ_DATA_F_ISOC_FIXED : { struct oz_isoc_fixed * body = ( struct oz_isoc_fixed * ) data_hdr ; int data_len = len - sizeof ( struct oz_isoc_fixed ) + 1 ; int unit_size = body -> unit_size ; u8 * data = body -> data ; int count ; int i ; if ( ! unit_size ) break ; count = data_len / unit_size ; for ( i = 0 ; i < count ; i ++ ) { oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint , data , unit_size ) ; data += unit_size ; } } break ; } }
","<S2SV_ModStart> -> data ; unsigned <S2SV_ModStart> body -> unit_size || len < sizeof ( struct oz_multiple_fixed ) - 1 <S2SV_ModStart> ( len - ( <S2SV_ModStart> struct oz_multiple_fixed ) - 1 ) <S2SV_ModEnd> ) / body
"
746,"CWE-119 int vp8_receive_raw_frame ( VP8_COMP * cpi , unsigned int frame_flags , YV12_BUFFER_CONFIG * sd , int64_t time_stamp , int64_t end_time ) { <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> int64_t store_reg [ 8 ] ; # if CONFIG_RUNTIME_CPU_DETECT VP8_COMMON * cm = & cpi -> common ; # endif # endif struct vpx_usec_timer timer ; int res = 0 ; <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( store_reg ) ; } # endif vpx_usec_timer_start ( & timer ) ; if ( sd -> y_width != cpi -> oxcf . Width || sd -> y_height != cpi -> oxcf . Height ) { assert ( cpi -> oxcf . lag_in_frames < 2 ) ; dealloc_raw_frame_buffers ( cpi ) ; alloc_raw_frame_buffers ( cpi ) ; } if ( vp8_lookahead_push ( cpi -> lookahead , sd , time_stamp , end_time , frame_flags , cpi -> active_map_enabled ? cpi -> active_map : NULL ) ) res = - 1 ; vpx_usec_timer_mark ( & timer ) ; cpi -> time_receive_data += vpx_usec_timer_elapsed ( & timer ) ; <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif return res ; }
","<S2SV_ModStart> end_time ) { <S2SV_ModEnd> struct vpx_usec_timer timer <S2SV_ModStart> = 0 ; <S2SV_ModEnd> vpx_usec_timer_start ( & <S2SV_ModStart> timer ) ; <S2SV_ModEnd> return res ;
"
747,"CWE-269 static int store_xauthority ( void ) { fs_build_mnt_dir ( ) ; char * src ; char * dest = RUN_XAUTHORITY_FILE ; FILE * fp = fopen ( dest , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , getuid ( ) , getgid ( ) , 0600 ) ; fclose ( fp ) ; } if ( asprintf ( & src , ""%s/.Xauthority"" , cfg . homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( src , & s ) == 0 ) { if ( is_link ( src ) ) { <S2SV_StartBug> fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\n"" ) ; <S2SV_EndBug> exit ( 1 ) ; } pid_t child = fork ( ) ; if ( child < 0 ) errExit ( ""fork"" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; <S2SV_StartBug> int rv = copy_file ( src , dest ) ; <S2SV_EndBug> if ( rv ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.Xauthority<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\n"" ) ; else { fs_logger2 ( ""clone"" , dest ) ; } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; <S2SV_StartBug> if ( chown ( dest , getuid ( ) , getgid ( ) ) == - 1 ) <S2SV_EndBug> errExit ( ""fchown"" ) ; if ( chmod ( dest , 0600 ) == - 1 ) errExit ( ""fchmod"" ) ; return 1 ; } return 0 ; }
","<S2SV_ModStart> ( stderr , ""Warning:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\n"" ) ; return 0 ; } copy_file_as_user <S2SV_ModEnd> ( src , <S2SV_ModStart> ( src , <S2SV_ModEnd> dest , getuid <S2SV_ModStart> getgid ( ) , 0600 ) ; fs_logger2 ( ""clone"" , dest <S2SV_ModEnd> ) ; return
"
748,"CWE-20 static void cmd_parse_status ( struct ImapData * idata , char * s ) { char * value = NULL ; struct Buffy * inc = NULL ; struct ImapMbox mx ; struct ImapStatus * status = NULL ; unsigned int olduv , oldun ; unsigned int litlen ; short new = 0 ; short new_msg_count = 0 ; char * mailbox = imap_next_word ( s ) ; if ( imap_get_literal_count ( mailbox , & litlen ) == 0 ) { if ( imap_cmd_step ( idata ) != IMAP_CMD_CONTINUE ) { <S2SV_StartBug> idata -> status = IMAP_FATAL ; <S2SV_EndBug> return ; } mailbox = idata -> buf ; s = mailbox + litlen ; * s = '\\0' ; s ++ ; SKIPWS ( s ) ; } else { s = imap_next_word ( mailbox ) ; * ( s - 1 ) = '\\0' ; imap_unmunge_mbox_name ( idata , mailbox ) ; } status = imap_mboxcache_get ( idata , mailbox , 1 ) ; olduv = status -> uidvalidity ; oldun = status -> uidnext ; if ( * s ++ != '(' ) { mutt_debug ( 1 , ""Error<S2SV_blank>parsing<S2SV_blank>STATUS\\n"" ) ; return ; } while ( * s && * s != ')' ) { value = imap_next_word ( s ) ; errno = 0 ; const unsigned long ulcount = strtoul ( value , & value , 10 ) ; if ( ( ( errno == ERANGE ) && ( ulcount == ULONG_MAX ) ) || ( ( unsigned int ) ulcount != ulcount ) ) { mutt_debug ( 1 , ""Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>number\\n"" ) ; return ; } const unsigned int count = ( unsigned int ) ulcount ; if ( mutt_str_strncmp ( ""MESSAGES"" , s , 8 ) == 0 ) { status -> messages = count ; new_msg_count = 1 ; } else if ( mutt_str_strncmp ( ""RECENT"" , s , 6 ) == 0 ) status -> recent = count ; else if ( mutt_str_strncmp ( ""UIDNEXT"" , s , 7 ) == 0 ) status -> uidnext = count ; else if ( mutt_str_strncmp ( ""UIDVALIDITY"" , s , 11 ) == 0 ) status -> uidvalidity = count ; else if ( mutt_str_strncmp ( ""UNSEEN"" , s , 6 ) == 0 ) status -> unseen = count ; s = value ; if ( * s && * s != ')' ) s = imap_next_word ( s ) ; } mutt_debug ( 3 , ""%s<S2SV_blank>(UIDVALIDITY:<S2SV_blank>%u,<S2SV_blank>UIDNEXT:<S2SV_blank>%u)<S2SV_blank>%d<S2SV_blank>messages,<S2SV_blank>%d<S2SV_blank>recent,<S2SV_blank>%d<S2SV_blank>unseen\\n"" , status -> name , status -> uidvalidity , status -> uidnext , status -> messages , status -> recent , status -> unseen ) ; if ( idata -> cmddata && idata -> cmdtype == IMAP_CT_STATUS ) { memcpy ( idata -> cmddata , status , sizeof ( struct ImapStatus ) ) ; return ; } mutt_debug ( 3 , ""Running<S2SV_blank>default<S2SV_blank>STATUS<S2SV_blank>handler\\n"" ) ; for ( inc = Incoming ; inc ; inc = inc -> next ) { if ( inc -> magic != MUTT_IMAP ) continue ; if ( imap_parse_path ( inc -> path , & mx ) < 0 ) { mutt_debug ( 1 , ""Error<S2SV_blank>parsing<S2SV_blank>mailbox<S2SV_blank>%s,<S2SV_blank>skipping\\n"" , inc -> path ) ; continue ; } if ( imap_account_match ( & idata -> conn -> account , & mx . account ) ) { if ( mx . mbox ) { value = mutt_str_strdup ( mx . mbox ) ; imap_fix_path ( idata , mx . mbox , value , mutt_str_strlen ( value ) + 1 ) ; FREE ( & mx . mbox ) ; } else value = mutt_str_strdup ( ""INBOX"" ) ; if ( value && ( imap_mxcmp ( mailbox , value ) == 0 ) ) { mutt_debug ( 3 , ""Found<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>buffy<S2SV_blank>list<S2SV_blank>(OV:<S2SV_blank>%u<S2SV_blank>ON:<S2SV_blank>%u<S2SV_blank>U:<S2SV_blank>%d)\\n"" , mailbox , olduv , oldun , status -> unseen ) ; if ( MailCheckRecent ) { if ( olduv && olduv == status -> uidvalidity ) { if ( oldun < status -> uidnext ) new = ( status -> unseen > 0 ) ; } else if ( ! olduv && ! oldun ) { new = ( status -> recent > 0 ) ; } else new = ( status -> unseen > 0 ) ; } else new = ( status -> unseen > 0 ) ; # ifdef USE_SIDEBAR if ( ( inc -> new != new ) || ( inc -> msg_count != status -> messages ) || ( inc -> msg_unread != status -> unseen ) ) { mutt_menu_set_current_redraw ( REDRAW_SIDEBAR ) ; } # endif inc -> new = new ; if ( new_msg_count ) inc -> msg_count = status -> messages ; inc -> msg_unread = status -> unseen ; if ( inc -> new ) { status -> uidnext = oldun ; } FREE ( & value ) ; return ; } FREE ( & value ) ; } FREE ( & mx . mbox ) ; } }
","<S2SV_ModStart> status = IMAP_FATAL ; return ; } if ( strlen ( idata -> buf ) < litlen ) { mutt_debug ( 1 , ""Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>mailbox\\n"" )
"
749,"CWE-000 int sas_discover_end_dev ( struct domain_device * dev ) { int res ; res = sas_notify_lldd_dev_found ( dev ) ; if ( res ) return res ; <S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_PROBE ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> return res ; <S2SV_ModEnd> return 0 ;
"
750,"CWE-908 static int ext4_ext_split ( handle_t * handle , struct inode * inode , unsigned int flags , struct ext4_ext_path * path , struct ext4_extent * newext , int at ) { struct buffer_head * bh = NULL ; int depth = ext_depth ( inode ) ; struct ext4_extent_header * neh ; struct ext4_extent_idx * fidx ; int i = at , k , m , a ; ext4_fsblk_t newblock , oldblock ; __le32 border ; ext4_fsblk_t * ablocks = NULL ; int err = 0 ; <S2SV_StartBug> if ( unlikely ( path [ depth ] . p_ext > EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) ) { <S2SV_EndBug> EXT4_ERROR_INODE ( inode , ""p_ext<S2SV_blank>><S2SV_blank>EXT_MAX_EXTENT!"" ) ; return - EFSCORRUPTED ; } if ( path [ depth ] . p_ext != EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) { border = path [ depth ] . p_ext [ 1 ] . ee_block ; ext_debug ( ""leaf<S2SV_blank>will<S2SV_blank>be<S2SV_blank>split."" ""<S2SV_blank>next<S2SV_blank>leaf<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\n"" , le32_to_cpu ( border ) ) ; } else { border = newext -> ee_block ; ext_debug ( ""leaf<S2SV_blank>will<S2SV_blank>be<S2SV_blank>added."" ""<S2SV_blank>next<S2SV_blank>leaf<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\n"" , le32_to_cpu ( border ) ) ; } ablocks = kcalloc ( depth , sizeof ( ext4_fsblk_t ) , GFP_NOFS ) ; if ( ! ablocks ) return - ENOMEM ; ext_debug ( ""allocate<S2SV_blank>%d<S2SV_blank>blocks<S2SV_blank>for<S2SV_blank>indexes/leaf\\n"" , depth - at ) ; for ( a = 0 ; a < depth - at ; a ++ ) { newblock = ext4_ext_new_meta_block ( handle , inode , path , newext , & err , flags ) ; if ( newblock == 0 ) goto cleanup ; ablocks [ a ] = newblock ; } newblock = ablocks [ -- a ] ; if ( unlikely ( newblock == 0 ) ) { EXT4_ERROR_INODE ( inode , ""newblock<S2SV_blank>==<S2SV_blank>0!"" ) ; err = - EFSCORRUPTED ; goto cleanup ; } bh = sb_getblk_gfp ( inode -> i_sb , newblock , __GFP_MOVABLE | GFP_NOFS ) ; if ( unlikely ( ! bh ) ) { err = - ENOMEM ; goto cleanup ; } lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) goto cleanup ; neh = ext_block_hdr ( bh ) ; neh -> eh_entries = 0 ; neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block ( inode , 0 ) ) ; neh -> eh_magic = EXT4_EXT_MAGIC ; neh -> eh_depth = 0 ; if ( unlikely ( path [ depth ] . p_hdr -> eh_entries != path [ depth ] . p_hdr -> eh_max ) ) { EXT4_ERROR_INODE ( inode , ""eh_entries<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>eh_max<S2SV_blank>%d!"" , path [ depth ] . p_hdr -> eh_entries , path [ depth ] . p_hdr -> eh_max ) ; err = - EFSCORRUPTED ; goto cleanup ; } m = EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) - path [ depth ] . p_ext ++ ; ext4_ext_show_move ( inode , path , newblock , depth ) ; if ( m ) { struct ext4_extent * ex ; ex = EXT_FIRST_EXTENT ( neh ) ; memmove ( ex , path [ depth ] . p_ext , sizeof ( struct ext4_extent ) * m ) ; le16_add_cpu ( & neh -> eh_entries , m ) ; } <S2SV_StartBug> ext4_extent_block_csum_set ( inode , neh ) ; <S2SV_EndBug> set_buffer_uptodate ( bh ) ; unlock_buffer ( bh ) ; err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; if ( err ) goto cleanup ; brelse ( bh ) ; bh = NULL ; if ( m ) { err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto cleanup ; le16_add_cpu ( & path [ depth ] . p_hdr -> eh_entries , - m ) ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; if ( err ) goto cleanup ; } k = depth - at - 1 ; if ( unlikely ( k < 0 ) ) { EXT4_ERROR_INODE ( inode , ""k<S2SV_blank>%d<S2SV_blank><<S2SV_blank>0!"" , k ) ; err = - EFSCORRUPTED ; goto cleanup ; } if ( k ) ext_debug ( ""create<S2SV_blank>%d<S2SV_blank>intermediate<S2SV_blank>indices\\n"" , k ) ; i = depth - 1 ; while ( k -- ) { oldblock = newblock ; newblock = ablocks [ -- a ] ; bh = sb_getblk ( inode -> i_sb , newblock ) ; if ( unlikely ( ! bh ) ) { err = - ENOMEM ; goto cleanup ; } lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) goto cleanup ; neh = ext_block_hdr ( bh ) ; neh -> eh_entries = cpu_to_le16 ( 1 ) ; neh -> eh_magic = EXT4_EXT_MAGIC ; neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block_idx ( inode , 0 ) ) ; neh -> eh_depth = cpu_to_le16 ( depth - i ) ; fidx = EXT_FIRST_INDEX ( neh ) ; fidx -> ei_block = border ; ext4_idx_store_pblock ( fidx , oldblock ) ; ext_debug ( ""int.index<S2SV_blank>at<S2SV_blank>%d<S2SV_blank>(block<S2SV_blank>%llu):<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%llu\\n"" , i , newblock , le32_to_cpu ( border ) , oldblock ) ; if ( unlikely ( EXT_MAX_INDEX ( path [ i ] . p_hdr ) != EXT_LAST_INDEX ( path [ i ] . p_hdr ) ) ) { EXT4_ERROR_INODE ( inode , ""EXT_MAX_INDEX<S2SV_blank>!=<S2SV_blank>EXT_LAST_INDEX<S2SV_blank>ee_block<S2SV_blank>%d!"" , le32_to_cpu ( path [ i ] . p_ext -> ee_block ) ) ; err = - EFSCORRUPTED ; goto cleanup ; } m = EXT_MAX_INDEX ( path [ i ] . p_hdr ) - path [ i ] . p_idx ++ ; ext_debug ( ""cur<S2SV_blank>0x%p,<S2SV_blank>last<S2SV_blank>0x%p\\n"" , path [ i ] . p_idx , EXT_MAX_INDEX ( path [ i ] . p_hdr ) ) ; ext4_ext_show_move ( inode , path , newblock , i ) ; if ( m ) { memmove ( ++ fidx , path [ i ] . p_idx , sizeof ( struct ext4_extent_idx ) * m ) ; le16_add_cpu ( & neh -> eh_entries , m ) ; } <S2SV_StartBug> ext4_extent_block_csum_set ( inode , neh ) ; <S2SV_EndBug> set_buffer_uptodate ( bh ) ; unlock_buffer ( bh ) ; err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; if ( err ) goto cleanup ; brelse ( bh ) ; bh = NULL ; if ( m ) { err = ext4_ext_get_access ( handle , inode , path + i ) ; if ( err ) goto cleanup ; le16_add_cpu ( & path [ i ] . p_hdr -> eh_entries , - m ) ; err = ext4_ext_dirty ( handle , inode , path + i ) ; if ( err ) goto cleanup ; } i -- ; } err = ext4_ext_insert_index ( handle , inode , path + at , le32_to_cpu ( border ) , newblock ) ; cleanup : if ( bh ) { if ( buffer_locked ( bh ) ) unlock_buffer ( bh ) ; brelse ( bh ) ; } if ( err ) { for ( i = 0 ; i < depth ; i ++ ) { if ( ! ablocks [ i ] ) continue ; ext4_free_blocks ( handle , inode , NULL , ablocks [ i ] , 1 , EXT4_FREE_BLOCKS_METADATA ) ; } } kfree ( ablocks ) ; return err ; }
","<S2SV_ModStart> = 0 ; size_t ext_size = 0 ; <S2SV_ModStart> ) ; } ext_size = sizeof ( struct ext4_extent_header ) + sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ; <S2SV_ModStart> ) ; } ext_size = sizeof ( struct ext4_extent_header ) + ( sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ;
"
751,"CWE-787 WORD32 ixheaacd_qmf_hbe_data_reinit ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer , WORD16 * p_freq_band_tab [ 2 ] , WORD16 * p_num_sfb , WORD32 upsamp_4_flag ) { WORD32 synth_size , sfb , patch , stop_patch ; if ( ptr_hbe_txposer != NULL ) { ptr_hbe_txposer -> start_band = p_freq_band_tab [ LOW ] [ 0 ] ; ptr_hbe_txposer -> end_band = p_freq_band_tab [ LOW ] [ p_num_sfb [ LOW ] ] ; ptr_hbe_txposer -> synth_size = 4 * ( ( ptr_hbe_txposer -> start_band + 4 ) / 8 + 1 ) ; ptr_hbe_txposer -> k_start = ixheaacd_start_subband2kL_tbl [ ptr_hbe_txposer -> start_band ] ; ptr_hbe_txposer -> upsamp_4_flag = upsamp_4_flag ; if ( upsamp_4_flag ) { if ( ptr_hbe_txposer -> k_start + ptr_hbe_txposer -> synth_size > 16 ) ptr_hbe_txposer -> k_start = 16 - ptr_hbe_txposer -> synth_size ; } else if ( ptr_hbe_txposer -> core_frame_length == 768 ) { if ( ptr_hbe_txposer -> k_start + ptr_hbe_txposer -> synth_size > 24 ) ptr_hbe_txposer -> k_start = 24 - ptr_hbe_txposer -> synth_size ; } memset ( ptr_hbe_txposer -> synth_buf , 0 , 1280 * sizeof ( FLOAT32 ) ) ; synth_size = ptr_hbe_txposer -> synth_size ; ptr_hbe_txposer -> synth_buf_offset = 18 * synth_size ; switch ( synth_size ) { case 4 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_4 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_8 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 8 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_8 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_16 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 12 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_12 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_24 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p3 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p3 ; <S2SV_EndBug> break ; case 16 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_16 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_32 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 20 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_20 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_40 ; break ; default : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_4 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_8 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> } ptr_hbe_txposer -> synth_wind_coeff = ixheaacd_map_prot_filter ( synth_size ) ; memset ( ptr_hbe_txposer -> analy_buf , 0 , 640 * sizeof ( FLOAT32 ) ) ; synth_size = 2 * ptr_hbe_txposer -> synth_size ; ptr_hbe_txposer -> analy_wind_coeff = ixheaacd_map_prot_filter ( synth_size ) ; memset ( ptr_hbe_txposer -> x_over_qmf , 0 , MAX_NUM_PATCHES * sizeof ( WORD32 ) ) ; sfb = 0 ; if ( upsamp_4_flag ) { stop_patch = MAX_NUM_PATCHES ; ptr_hbe_txposer -> max_stretch = MAX_STRETCH ; } else { stop_patch = MAX_STRETCH ; } for ( patch = 1 ; patch <= stop_patch ; patch ++ ) { while ( sfb <= p_num_sfb [ LOW ] && p_freq_band_tab [ LOW ] [ sfb ] <= patch * ptr_hbe_txposer -> start_band ) sfb ++ ; if ( sfb <= p_num_sfb [ LOW ] ) { if ( ( patch * ptr_hbe_txposer -> start_band - p_freq_band_tab [ LOW ] [ sfb - 1 ] ) <= 3 ) { ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = p_freq_band_tab [ LOW ] [ sfb - 1 ] ; } else { WORD32 sfb = 0 ; while ( sfb <= p_num_sfb [ HIGH ] && p_freq_band_tab [ HIGH ] [ sfb ] <= patch * ptr_hbe_txposer -> start_band ) sfb ++ ; ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = p_freq_band_tab [ HIGH ] [ sfb - 1 ] ; } } else { ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = ptr_hbe_txposer -> end_band ; ptr_hbe_txposer -> max_stretch = min ( patch , MAX_STRETCH ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> } } if ( ptr_hbe_txposer -> k_start < 0 ) { return - 1 ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_8 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_16 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_24 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p3 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_32 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_8 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ; break ; <S2SV_ModEnd> } } if <S2SV_ModStart> 1 ; } }
"
752,"CWE-787 static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; <S2SV_StartBug> cmap_len = get_ushort ( & tga [ 5 ] ) ; <S2SV_EndBug> cmap_entry_size = tga [ 7 ] ; # if 0 <S2SV_StartBug> x_origin = get_ushort ( & tga [ 8 ] ) ; <S2SV_EndBug> <S2SV_StartBug> y_origin = get_ushort ( & tga [ 10 ] ) ; <S2SV_EndBug> # endif <S2SV_StartBug> image_w = get_ushort ( & tga [ 12 ] ) ; <S2SV_EndBug> <S2SV_StartBug> image_h = get_ushort ( & tga [ 14 ] ) ; <S2SV_EndBug> pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader:<S2SV_blank>memory<S2SV_blank>out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry,<S2SV_blank>compressed<S2SV_blank>tga<S2SV_blank>files<S2SV_blank>are<S2SV_blank>not<S2SV_blank>currently<S2SV_blank>supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>palette<S2SV_blank>-<S2SV_blank>not<S2SV_blank>yet<S2SV_blank>supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
","<S2SV_ModStart> ; cmap_len = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> 0 x_origin = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; y_origin = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> endif image_w = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; image_h = get_tga_ushort <S2SV_ModEnd> ( & tga
"
753,"CWE-264 static ssize_t ucma_write ( struct file * filp , const char __user * buf , size_t len , loff_t * pos ) { struct ucma_file * file = filp -> private_data ; struct rdma_ucm_cmd_hdr hdr ; <S2SV_StartBug> ssize_t ret ; <S2SV_EndBug> if ( len < sizeof ( hdr ) ) return - EINVAL ; if ( copy_from_user ( & hdr , buf , sizeof ( hdr ) ) ) return - EFAULT ; if ( hdr . cmd >= ARRAY_SIZE ( ucma_cmd_table ) ) return - EINVAL ; if ( hdr . in + sizeof ( hdr ) > len ) return - EINVAL ; if ( ! ucma_cmd_table [ hdr . cmd ] ) return - ENOSYS ; ret = ucma_cmd_table [ hdr . cmd ] ( file , buf + sizeof ( hdr ) , hdr . in , hdr . out ) ; if ( ! ret ) ret = len ; return ret ; }
","<S2SV_ModStart> ; ssize_t ret ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES
"
754,"CWE-189 static void sample_to_timespec ( const clockid_t which_clock , union cpu_time_count cpu , struct timespec * tp ) { <S2SV_StartBug> if ( CPUCLOCK_WHICH ( which_clock ) == CPUCLOCK_SCHED ) { <S2SV_EndBug> <S2SV_StartBug> tp -> tv_sec = div_long_long_rem ( cpu . sched , <S2SV_EndBug> NSEC_PER_SEC , & tp -> tv_nsec ) ; } else { cputime_to_timespec ( cpu . cpu , tp ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> == CPUCLOCK_SCHED ) * tp = ns_to_timespec <S2SV_ModEnd> ( cpu . <S2SV_ModStart> cpu . sched ) ; else <S2SV_ModEnd> cputime_to_timespec ( cpu <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
"
755,"CWE-125 uint32 TIFFNumberOfStrips ( TIFF * tif ) { TIFFDirectory * td = & tif -> tif_dir ; <S2SV_StartBug> uint32 nstrips ; <S2SV_EndBug> if ( td -> td_nstrips ) return td -> td_nstrips ; nstrips = ( td -> td_rowsperstrip == ( uint32 ) - 1 ? 1 : TIFFhowmany_32 ( td -> td_imagelength , td -> td_rowsperstrip ) ) ; if ( td -> td_planarconfig == PLANARCONFIG_SEPARATE ) nstrips = _TIFFMultiply32 ( tif , nstrips , ( uint32 ) td -> td_samplesperpixel , ""TIFFNumberOfStrips"" ) ; return ( nstrips ) ; }
","<S2SV_ModStart> ; uint32 nstrips <S2SV_ModEnd> ; nstrips =
"
756,"CWE-20 int rds_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int msg_flags ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; long timeo ; int ret = 0 , nonblock = msg_flags & MSG_DONTWAIT ; struct sockaddr_in * sin ; struct rds_incoming * inc = NULL ; timeo = sock_rcvtimeo ( sk , nonblock ) ; <S2SV_StartBug> rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , size , msg_flags , timeo ) ; <S2SV_EndBug> msg -> msg_namelen = 0 ; if ( msg_flags & MSG_OOB ) goto out ; while ( 1 ) { if ( ! list_empty ( & rs -> rs_notify_queue ) ) { ret = rds_notify_queue_get ( rs , msg ) ; break ; } if ( rs -> rs_cong_notify ) { ret = rds_notify_cong ( rs , msg ) ; break ; } if ( ! rds_next_incoming ( rs , & inc ) ) { if ( nonblock ) { ret = - EAGAIN ; break ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , ( ! list_empty ( & rs -> rs_notify_queue ) || rs -> rs_cong_notify || rds_next_incoming ( rs , & inc ) ) , timeo ) ; rdsdebug ( ""recvmsg<S2SV_blank>woke<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , inc , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; break ; } rdsdebug ( ""copying<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>from<S2SV_blank>%pI4:%u<S2SV_blank>to<S2SV_blank>user\\n"" , inc , & inc -> i_conn -> c_faddr , ntohs ( inc -> i_hdr . h_sport ) ) ; ret = inc -> i_conn -> c_trans -> inc_copy_to_user ( inc , msg -> msg_iov , size ) ; if ( ret < 0 ) break ; if ( ! rds_still_queued ( rs , inc , ! ( msg_flags & MSG_PEEK ) ) ) { rds_inc_put ( inc ) ; inc = NULL ; rds_stats_inc ( s_recv_deliver_raced ) ; continue ; } if ( ret < be32_to_cpu ( inc -> i_hdr . h_len ) ) { if ( msg_flags & MSG_TRUNC ) ret = be32_to_cpu ( inc -> i_hdr . h_len ) ; msg -> msg_flags |= MSG_TRUNC ; } if ( rds_cmsg_recv ( inc , msg ) ) { ret = - EFAULT ; goto out ; } rds_stats_inc ( s_recv_delivered ) ; sin = ( struct sockaddr_in * ) msg -> msg_name ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = inc -> i_hdr . h_sport ; sin -> sin_addr . s_addr = inc -> i_saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; msg -> msg_namelen = sizeof ( * sin ) ; } break ; } if ( inc ) rds_inc_put ( inc ) ; out : return ret ; }
","<S2SV_ModStart> , timeo ) <S2SV_ModEnd> ; if (
"
757,"CWE-264 static authz_status lua_authz_check ( request_rec * r , const char * require_line , const void * parsed_require_line ) { apr_pool_t * pool ; ap_lua_vm_spec * spec ; lua_State * L ; ap_lua_server_cfg * server_cfg = ap_get_module_config ( r -> server -> module_config , & lua_module ) ; const ap_lua_dir_cfg * cfg = ap_get_module_config ( r -> per_dir_config , & lua_module ) ; <S2SV_StartBug> const lua_authz_provider_spec * prov_spec = parsed_require_line ; <S2SV_EndBug> int result ; int nargs = 0 ; spec = create_vm_spec ( & pool , r , cfg , server_cfg , prov_spec -> file_name , NULL , 0 , prov_spec -> function_name , ""authz<S2SV_blank>provider"" ) ; L = ap_lua_get_lua_state ( pool , spec , r ) ; if ( L == NULL ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02314 ) ""Unable<S2SV_blank>to<S2SV_blank>compile<S2SV_blank>VM<S2SV_blank>for<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s"" , prov_spec -> name ) ; return AUTHZ_GENERAL_ERROR ; } lua_getglobal ( L , prov_spec -> function_name ) ; if ( ! lua_isfunction ( L , - 1 ) ) { ap_log_rerror ( APLOG_MARK , APLOG_CRIT , 0 , r , APLOGNO ( 02319 ) ""Unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>entry<S2SV_blank>function<S2SV_blank>\'%s\'<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>function)"" , prov_spec -> function_name , prov_spec -> file_name ) ; ap_lua_release_state ( L , spec , r ) ; return AUTHZ_GENERAL_ERROR ; } ap_lua_run_lua_request ( L , r ) ; <S2SV_StartBug> if ( prov_spec -> args ) { <S2SV_EndBug> int i ; <S2SV_StartBug> if ( ! lua_checkstack ( L , prov_spec -> args -> nelts ) ) { <S2SV_EndBug> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02315 ) ""Error:<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>arguments"" , prov_spec -> name ) ; ap_lua_release_state ( L , spec , r ) ; return AUTHZ_GENERAL_ERROR ; } <S2SV_StartBug> for ( i = 0 ; i < prov_spec -> args -> nelts ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> const char * arg = APR_ARRAY_IDX ( prov_spec -> args , i , const char * ) ; <S2SV_EndBug> lua_pushstring ( L , arg ) ; } <S2SV_StartBug> nargs = prov_spec -> args -> nelts ; <S2SV_EndBug> } if ( lua_pcall ( L , 1 + nargs , 1 , 0 ) ) { const char * err = lua_tostring ( L , - 1 ) ; ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02316 ) ""Error<S2SV_blank>executing<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s:<S2SV_blank>%s"" , prov_spec -> name , err ) ; ap_lua_release_state ( L , spec , r ) ; return AUTHZ_GENERAL_ERROR ; } if ( ! lua_isnumber ( L , - 1 ) ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02317 ) ""Error:<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s<S2SV_blank>did<S2SV_blank>not<S2SV_blank>return<S2SV_blank>integer"" , prov_spec -> name ) ; ap_lua_release_state ( L , spec , r ) ; return AUTHZ_GENERAL_ERROR ; } result = lua_tointeger ( L , - 1 ) ; ap_lua_release_state ( L , spec , r ) ; switch ( result ) { case AUTHZ_DENIED : case AUTHZ_GRANTED : case AUTHZ_NEUTRAL : case AUTHZ_GENERAL_ERROR : case AUTHZ_DENIED_NO_USER : return result ; default : ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02318 ) ""Error:<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s:<S2SV_blank>invalid<S2SV_blank>return<S2SV_blank>value<S2SV_blank>%d"" , prov_spec -> name , result ) ; } return AUTHZ_GENERAL_ERROR ; }
","<S2SV_ModStart> ) ; const lua_authz_provider_func * prov_func = parsed_require_line ; const <S2SV_ModStart> * prov_spec = prov_func -> spec <S2SV_ModEnd> ; int result <S2SV_ModStart> ; if ( prov_func <S2SV_ModEnd> -> args ) <S2SV_ModStart> ( L , prov_func <S2SV_ModEnd> -> args -> <S2SV_ModStart> ; i < prov_func <S2SV_ModEnd> -> args -> <S2SV_ModStart> = APR_ARRAY_IDX ( prov_func <S2SV_ModEnd> -> args , <S2SV_ModStart> } nargs = prov_func <S2SV_ModEnd> -> args ->
"
758,"CWE-476 int expand_downwards ( struct vm_area_struct * vma , unsigned long address ) { struct mm_struct * mm = vma -> vm_mm ; struct vm_area_struct * prev ; <S2SV_StartBug> int error ; <S2SV_EndBug> address &= PAGE_MASK ; <S2SV_StartBug> error = security_mmap_addr ( address ) ; <S2SV_EndBug> if ( error ) return error ; prev = vma -> vm_prev ; if ( prev && ! ( prev -> vm_flags & VM_GROWSDOWN ) && ( prev -> vm_flags & ( VM_WRITE | VM_READ | VM_EXEC ) ) ) { if ( address - prev -> vm_end < stack_guard_gap ) return - ENOMEM ; } if ( unlikely ( anon_vma_prepare ( vma ) ) ) return - ENOMEM ; anon_vma_lock_write ( vma -> anon_vma ) ; if ( address < vma -> vm_start ) { unsigned long size , grow ; size = vma -> vm_end - address ; grow = ( vma -> vm_start - address ) >> PAGE_SHIFT ; error = - ENOMEM ; if ( grow <= vma -> vm_pgoff ) { error = acct_stack_growth ( vma , size , grow ) ; if ( ! error ) { spin_lock ( & mm -> page_table_lock ) ; if ( vma -> vm_flags & VM_LOCKED ) mm -> locked_vm += grow ; vm_stat_account ( mm , vma -> vm_flags , grow ) ; anon_vma_interval_tree_pre_update_vma ( vma ) ; vma -> vm_start = address ; vma -> vm_pgoff -= grow ; anon_vma_interval_tree_post_update_vma ( vma ) ; vma_gap_update ( vma ) ; spin_unlock ( & mm -> page_table_lock ) ; perf_event_mmap ( vma ) ; } } } anon_vma_unlock_write ( vma -> anon_vma ) ; khugepaged_enter_vma_merge ( vma , vma -> vm_flags ) ; validate_mm ( mm ) ; return error ; }
","<S2SV_ModStart> ; int error = 0 <S2SV_ModStart> &= PAGE_MASK ; if ( address < mmap_min_addr ) return - EPERM <S2SV_ModEnd> ; prev =
"
759,"CWE-285 int xfs_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error = 0 ; if ( ! acl ) goto set_acl ; error = - E2BIG ; if ( acl -> a_count > XFS_ACL_MAX_ENTRIES ( XFS_M ( inode -> i_sb ) ) ) return error ; if ( type == ACL_TYPE_ACCESS ) { <S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error <= 0 ) { <S2SV_EndBug> acl = NULL ; if ( error < 0 ) return error ; <S2SV_StartBug> } <S2SV_EndBug> error = xfs_set_mode ( inode , mode ) ; if ( error ) return error ; } set_acl : return __xfs_set_acl ( inode , type , acl ) ; }
","<S2SV_ModStart> { umode_t mode <S2SV_ModEnd> ; error = <S2SV_ModStart> ; error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & mode <S2SV_ModStart> , & mode , & acl <S2SV_ModStart> if ( error <S2SV_ModEnd> ) return error <S2SV_ModStart> return error ; <S2SV_ModEnd> error = xfs_set_mode
"
760,"CWE-59 static int mount_entry ( const char * fsname , const char * target , const char * fstype , unsigned long mountflags , <S2SV_StartBug> const char * data , int optional ) <S2SV_EndBug> { # ifdef HAVE_STATVFS struct statvfs sb ; # endif <S2SV_StartBug> if ( mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data ) ) { <S2SV_EndBug> if ( optional ) { INFO ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'<S2SV_blank>(optional):<S2SV_blank>%s"" , fsname , target , strerror ( errno ) ) ; return 0 ; } else { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'"" , fsname , target ) ; return - 1 ; } } if ( ( mountflags & MS_REMOUNT ) || ( mountflags & MS_BIND ) ) { DEBUG ( ""remounting<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>respect<S2SV_blank>bind<S2SV_blank>or<S2SV_blank>remount<S2SV_blank>options"" , fsname ? fsname : ""(none)"" , target ? target : ""(none)"" ) ; unsigned long rqd_flags = 0 ; if ( mountflags & MS_RDONLY ) rqd_flags |= MS_RDONLY ; # ifdef HAVE_STATVFS if ( statvfs ( fsname , & sb ) == 0 ) { unsigned long required_flags = rqd_flags ; if ( sb . f_flag & MS_NOSUID ) required_flags |= MS_NOSUID ; if ( sb . f_flag & MS_NODEV ) required_flags |= MS_NODEV ; if ( sb . f_flag & MS_RDONLY ) required_flags |= MS_RDONLY ; if ( sb . f_flag & MS_NOEXEC ) required_flags |= MS_NOEXEC ; DEBUG ( ""(at<S2SV_blank>remount)<S2SV_blank>flags<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>was<S2SV_blank>%lu,<S2SV_blank>required<S2SV_blank>extra<S2SV_blank>flags<S2SV_blank>are<S2SV_blank>%lu"" , fsname , sb . f_flag , required_flags ) ; if ( ! ( mountflags & MS_REMOUNT ) ) { if ( ! ( required_flags & ~ mountflags ) && rqd_flags == 0 ) { DEBUG ( ""mountflags<S2SV_blank>already<S2SV_blank>was<S2SV_blank>%lu,<S2SV_blank>skipping<S2SV_blank>remount"" , mountflags ) ; goto skipremount ; } } mountflags |= required_flags ; } # endif if ( mount ( fsname , target , fstype , <S2SV_StartBug> mountflags | MS_REMOUNT , data ) ) { <S2SV_EndBug> if ( optional ) { INFO ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'<S2SV_blank>(optional):<S2SV_blank>%s"" , fsname , target , strerror ( errno ) ) ; return 0 ; } else { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'"" , fsname , target ) ; return - 1 ; } } } # ifdef HAVE_STATVFS skipremount : # endif DEBUG ( ""mounted<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\',<S2SV_blank>type<S2SV_blank>\'%s\'"" , fsname , target , fstype ) ; return 0 ; }
","<S2SV_ModStart> , int optional , const char * rootfs <S2SV_ModStart> endif if ( safe_mount <S2SV_ModEnd> ( fsname , <S2SV_ModStart> MS_REMOUNT , data , rootfs <S2SV_ModStart> , data ) < 0
"
761,"CWE-119 static Image * ReadDPXImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char magick [ 4 ] , value [ MaxTextExtent ] ; DPXInfo dpx ; Image * image ; MagickBooleanType status ; MagickOffsetType offset ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; size_t extent , samples_per_pixel ; ssize_t count , n , row , y ; unsigned char component_type ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } offset = 0 ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; offset += count ; if ( ( count != 4 ) || ( ( LocaleNCompare ( magick , ""SDPX"" , 4 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , ""XPDS"" , 4 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> endian = LSBEndian ; if ( LocaleNCompare ( magick , ""SDPX"" , 4 ) == 0 ) image -> endian = MSBEndian ; ( void ) ResetMagickMemory ( & dpx , 0 , sizeof ( dpx ) ) ; dpx . file . image_offset = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( dpx . file . version ) , ( unsigned char * ) dpx . file . version ) ; ( void ) FormatImageProperty ( image , ""dpx:file.version"" , ""%.8s"" , dpx . file . version ) ; dpx . file . file_size = ReadBlobLong ( image ) ; offset += 4 ; dpx . file . ditto_key = ReadBlobLong ( image ) ; offset += 4 ; if ( dpx . file . ditto_key != ~ 0U ) ( void ) FormatImageProperty ( image , ""dpx:file.ditto.key"" , ""%u"" , dpx . file . ditto_key ) ; dpx . file . generic_size = ReadBlobLong ( image ) ; offset += 4 ; dpx . file . industry_size = ReadBlobLong ( image ) ; offset += 4 ; dpx . file . user_size = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( dpx . file . filename ) , ( unsigned char * ) dpx . file . filename ) ; ( void ) FormatImageProperty ( image , ""dpx:file.filename"" , ""%.100s"" , dpx . file . filename ) ; ( void ) FormatImageProperty ( image , ""document"" , ""%.100s"" , dpx . file . filename ) ; offset += ReadBlob ( image , sizeof ( dpx . file . timestamp ) , ( unsigned char * ) dpx . file . timestamp ) ; if ( * dpx . file . timestamp != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:file.timestamp"" , ""%.24s"" , dpx . file . timestamp ) ; offset += ReadBlob ( image , sizeof ( dpx . file . creator ) , ( unsigned char * ) dpx . file . creator ) ; if ( * dpx . file . creator == '\\0' ) { ( void ) FormatImageProperty ( image , ""dpx:file.creator"" , ""%.100s"" , GetMagickVersion ( ( size_t * ) NULL ) ) ; ( void ) FormatImageProperty ( image , ""software"" , ""%.100s"" , GetMagickVersion ( ( size_t * ) NULL ) ) ; } else { ( void ) FormatImageProperty ( image , ""dpx:file.creator"" , ""%.100s"" , dpx . file . creator ) ; ( void ) FormatImageProperty ( image , ""software"" , ""%.100s"" , dpx . file . creator ) ; } offset += ReadBlob ( image , sizeof ( dpx . file . project ) , ( unsigned char * ) dpx . file . project ) ; if ( * dpx . file . project != '\\0' ) { ( void ) FormatImageProperty ( image , ""dpx:file.project"" , ""%.200s"" , dpx . file . project ) ; ( void ) FormatImageProperty ( image , ""comment"" , ""%.100s"" , dpx . file . project ) ; } offset += ReadBlob ( image , sizeof ( dpx . file . copyright ) , ( unsigned char * ) dpx . file . copyright ) ; if ( * dpx . file . copyright != '\\0' ) { ( void ) FormatImageProperty ( image , ""dpx:file.copyright"" , ""%.200s"" , dpx . file . copyright ) ; ( void ) FormatImageProperty ( image , ""copyright"" , ""%.100s"" , dpx . file . copyright ) ; } dpx . file . encrypt_key = ReadBlobLong ( image ) ; offset += 4 ; if ( dpx . file . encrypt_key != ~ 0U ) ( void ) FormatImageProperty ( image , ""dpx:file.encrypt_key"" , ""%u"" , dpx . file . encrypt_key ) ; offset += ReadBlob ( image , sizeof ( dpx . file . reserve ) , ( unsigned char * ) dpx . file . reserve ) ; dpx . image . orientation = ReadBlobShort ( image ) ; if ( dpx . image . orientation > 7 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; offset += 2 ; if ( dpx . image . orientation != ( unsigned short ) ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:image.orientation"" , ""%d"" , dpx . image . orientation ) ; switch ( dpx . image . orientation ) { default : case 0 : image -> orientation = TopLeftOrientation ; break ; case 1 : image -> orientation = TopRightOrientation ; break ; case 2 : image -> orientation = BottomLeftOrientation ; break ; case 3 : image -> orientation = BottomRightOrientation ; break ; case 4 : image -> orientation = LeftTopOrientation ; break ; case 5 : image -> orientation = RightTopOrientation ; break ; case 6 : image -> orientation = LeftBottomOrientation ; break ; case 7 : image -> orientation = RightBottomOrientation ; break ; } dpx . image . number_elements = ReadBlobShort ( image ) ; if ( dpx . image . number_elements > MaxNumberImageElements ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; offset += 2 ; dpx . image . pixels_per_line = ReadBlobLong ( image ) ; offset += 4 ; image -> columns = dpx . image . pixels_per_line ; dpx . image . lines_per_element = ReadBlobLong ( image ) ; offset += 4 ; image -> rows = dpx . image . lines_per_element ; for ( i = 0 ; i < 8 ; i ++ ) { char property [ MaxTextExtent ] ; dpx . image . image_element [ i ] . data_sign = ReadBlobLong ( image ) ; offset += 4 ; dpx . image . image_element [ i ] . low_data = ReadBlobLong ( image ) ; offset += 4 ; dpx . image . image_element [ i ] . low_quantity = ReadBlobFloat ( image ) ; offset += 4 ; dpx . image . image_element [ i ] . high_data = ReadBlobLong ( image ) ; offset += 4 ; dpx . image . image_element [ i ] . high_quantity = ReadBlobFloat ( image ) ; offset += 4 ; dpx . image . image_element [ i ] . descriptor = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; dpx . image . image_element [ i ] . transfer_characteristic = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) FormatLocaleString ( property , MaxTextExtent , ""dpx:image.element[%lu].transfer-characteristic"" , ( long ) i ) ; ( void ) FormatImageProperty ( image , property , ""%s"" , GetImageTransferCharacteristic ( ( DPXTransferCharacteristic ) dpx . image . image_element [ i ] . transfer_characteristic ) ) ; offset ++ ; dpx . image . image_element [ i ] . colorimetric = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; dpx . image . image_element [ i ] . bit_size = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; dpx . image . image_element [ i ] . packing = ReadBlobShort ( image ) ; offset += 2 ; dpx . image . image_element [ i ] . encoding = ReadBlobShort ( image ) ; offset += 2 ; dpx . image . image_element [ i ] . data_offset = ReadBlobLong ( image ) ; offset += 4 ; dpx . image . image_element [ i ] . end_of_line_padding = ReadBlobLong ( image ) ; offset += 4 ; dpx . image . image_element [ i ] . end_of_image_padding = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( dpx . image . image_element [ i ] . description ) , ( unsigned char * ) dpx . image . image_element [ i ] . description ) ; } ( void ) SetImageColorspace ( image , RGBColorspace ) ; offset += ReadBlob ( image , sizeof ( dpx . image . reserve ) , ( unsigned char * ) dpx . image . reserve ) ; if ( dpx . file . image_offset >= 1664U ) { dpx . orientation . x_offset = ReadBlobLong ( image ) ; offset += 4 ; if ( dpx . orientation . x_offset != ~ 0U ) ( void ) FormatImageProperty ( image , ""dpx:orientation.x_offset"" , ""%u"" , dpx . orientation . x_offset ) ; dpx . orientation . y_offset = ReadBlobLong ( image ) ; offset += 4 ; if ( dpx . orientation . y_offset != ~ 0U ) ( void ) FormatImageProperty ( image , ""dpx:orientation.y_offset"" , ""%u"" , dpx . orientation . y_offset ) ; dpx . orientation . x_center = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . orientation . x_center ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:orientation.x_center"" , ""%g"" , dpx . orientation . x_center ) ; dpx . orientation . y_center = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . orientation . y_center ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:orientation.y_center"" , ""%g"" , dpx . orientation . y_center ) ; dpx . orientation . x_size = ReadBlobLong ( image ) ; offset += 4 ; if ( dpx . orientation . x_size != ~ 0U ) ( void ) FormatImageProperty ( image , ""dpx:orientation.x_size"" , ""%u"" , dpx . orientation . x_size ) ; dpx . orientation . y_size = ReadBlobLong ( image ) ; offset += 4 ; if ( dpx . orientation . y_size != ~ 0U ) ( void ) FormatImageProperty ( image , ""dpx:orientation.y_size"" , ""%u"" , dpx . orientation . y_size ) ; offset += ReadBlob ( image , sizeof ( dpx . orientation . filename ) , ( unsigned char * ) dpx . orientation . filename ) ; if ( * dpx . orientation . filename != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:orientation.filename"" , ""%.100s"" , dpx . orientation . filename ) ; offset += ReadBlob ( image , sizeof ( dpx . orientation . timestamp ) , ( unsigned char * ) dpx . orientation . timestamp ) ; if ( * dpx . orientation . timestamp != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:orientation.timestamp"" , ""%.24s"" , dpx . orientation . timestamp ) ; offset += ReadBlob ( image , sizeof ( dpx . orientation . device ) , ( unsigned char * ) dpx . orientation . device ) ; if ( * dpx . orientation . device != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:orientation.device"" , ""%.32s"" , dpx . orientation . device ) ; offset += ReadBlob ( image , sizeof ( dpx . orientation . serial ) , ( unsigned char * ) dpx . orientation . serial ) ; if ( * dpx . orientation . serial != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:orientation.serial"" , ""%.32s"" , dpx . orientation . serial ) ; for ( i = 0 ; i < 4 ; i ++ ) { dpx . orientation . border [ i ] = ReadBlobShort ( image ) ; offset += 2 ; } if ( ( dpx . orientation . border [ 0 ] != ( unsigned short ) ( ~ 0 ) ) && ( dpx . orientation . border [ 1 ] != ( unsigned short ) ( ~ 0 ) ) ) ( void ) FormatImageProperty ( image , ""dpx:orientation.border"" , ""%dx%d%+d%+d"" , dpx . orientation . border [ 0 ] , dpx . orientation . border [ 1 ] , dpx . orientation . border [ 2 ] , dpx . orientation . border [ 3 ] ) ; for ( i = 0 ; i < 2 ; i ++ ) { dpx . orientation . aspect_ratio [ i ] = ReadBlobLong ( image ) ; offset += 4 ; } if ( ( dpx . orientation . aspect_ratio [ 0 ] != ~ 0U ) && ( dpx . orientation . aspect_ratio [ 1 ] != ~ 0U ) ) ( void ) FormatImageProperty ( image , ""dpx:orientation.aspect_ratio"" , ""%ux%u"" , dpx . orientation . aspect_ratio [ 0 ] , dpx . orientation . aspect_ratio [ 1 ] ) ; offset += ReadBlob ( image , sizeof ( dpx . orientation . reserve ) , ( unsigned char * ) dpx . orientation . reserve ) ; } if ( dpx . file . image_offset >= 1920U ) { offset += ReadBlob ( image , sizeof ( dpx . film . id ) , ( unsigned char * ) dpx . film . id ) ; if ( * dpx . film . id != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:film.id"" , ""%.2s"" , dpx . film . id ) ; offset += ReadBlob ( image , sizeof ( dpx . film . type ) , ( unsigned char * ) dpx . film . type ) ; if ( * dpx . film . type != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:film.type"" , ""%.2s"" , dpx . film . type ) ; offset += ReadBlob ( image , sizeof ( dpx . film . offset ) , ( unsigned char * ) dpx . film . offset ) ; if ( * dpx . film . offset != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:film.offset"" , ""%.2s"" , dpx . film . offset ) ; offset += ReadBlob ( image , sizeof ( dpx . film . prefix ) , ( unsigned char * ) dpx . film . prefix ) ; if ( * dpx . film . prefix != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:film.prefix"" , ""%.6s"" , dpx . film . prefix ) ; offset += ReadBlob ( image , sizeof ( dpx . film . count ) , ( unsigned char * ) dpx . film . count ) ; if ( * dpx . film . count != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:film.count"" , ""%.4s"" , dpx . film . count ) ; offset += ReadBlob ( image , sizeof ( dpx . film . format ) , ( unsigned char * ) dpx . film . format ) ; if ( * dpx . film . format != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:film.format"" , ""%.4s"" , dpx . film . format ) ; dpx . film . frame_position = ReadBlobLong ( image ) ; offset += 4 ; if ( dpx . film . frame_position != ~ 0U ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_position"" , ""%u"" , dpx . film . frame_position ) ; dpx . film . sequence_extent = ReadBlobLong ( image ) ; offset += 4 ; if ( dpx . film . sequence_extent != ~ 0U ) ( void ) FormatImageProperty ( image , ""dpx:film.sequence_extent"" , ""%u"" , dpx . film . sequence_extent ) ; dpx . film . held_count = ReadBlobLong ( image ) ; offset += 4 ; if ( dpx . film . held_count != ~ 0U ) ( void ) FormatImageProperty ( image , ""dpx:film.held_count"" , ""%u"" , dpx . film . held_count ) ; dpx . film . frame_rate = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . film . frame_rate ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_rate"" , ""%g"" , dpx . film . frame_rate ) ; dpx . film . shutter_angle = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . film . shutter_angle ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:film.shutter_angle"" , ""%g"" , dpx . film . shutter_angle ) ; offset += ReadBlob ( image , sizeof ( dpx . film . frame_id ) , ( unsigned char * ) dpx . film . frame_id ) ; if ( * dpx . film . frame_id != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_id"" , ""%.32s"" , dpx . film . frame_id ) ; offset += ReadBlob ( image , sizeof ( dpx . film . slate ) , ( unsigned char * ) dpx . film . slate ) ; if ( * dpx . film . slate != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:film.slate"" , ""%.100s"" , dpx . film . slate ) ; offset += ReadBlob ( image , sizeof ( dpx . film . reserve ) , ( unsigned char * ) dpx . film . reserve ) ; } if ( dpx . file . image_offset >= 2048U ) { dpx . television . time_code = ( unsigned int ) ReadBlobLong ( image ) ; offset += 4 ; TimeCodeToString ( dpx . television . time_code , value ) ; ( void ) SetImageProperty ( image , ""dpx:television.time.code"" , value ) ; dpx . television . user_bits = ( unsigned int ) ReadBlobLong ( image ) ; offset += 4 ; TimeCodeToString ( dpx . television . user_bits , value ) ; ( void ) SetImageProperty ( image , ""dpx:television.user.bits"" , value ) ; dpx . television . interlace = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; if ( dpx . television . interlace != 0 ) ( void ) FormatImageProperty ( image , ""dpx:television.interlace"" , ""%.20g"" , ( double ) dpx . television . interlace ) ; dpx . television . field_number = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; if ( dpx . television . field_number != 0 ) ( void ) FormatImageProperty ( image , ""dpx:television.field_number"" , ""%.20g"" , ( double ) dpx . television . field_number ) ; dpx . television . video_signal = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; if ( dpx . television . video_signal != 0 ) ( void ) FormatImageProperty ( image , ""dpx:television.video_signal"" , ""%.20g"" , ( double ) dpx . television . video_signal ) ; dpx . television . padding = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; if ( dpx . television . padding != 0 ) ( void ) FormatImageProperty ( image , ""dpx:television.padding"" , ""%d"" , dpx . television . padding ) ; dpx . television . horizontal_sample_rate = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . television . horizontal_sample_rate ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:television.horizontal_sample_rate"" , ""%g"" , dpx . television . horizontal_sample_rate ) ; dpx . television . vertical_sample_rate = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . television . vertical_sample_rate ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:television.vertical_sample_rate"" , ""%g"" , dpx . television . vertical_sample_rate ) ; dpx . television . frame_rate = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . television . frame_rate ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:television.frame_rate"" , ""%g"" , dpx . television . frame_rate ) ; dpx . television . time_offset = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . television . time_offset ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:television.time_offset"" , ""%g"" , dpx . television . time_offset ) ; dpx . television . gamma = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . television . gamma ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:television.gamma"" , ""%g"" , dpx . television . gamma ) ; dpx . television . black_level = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . television . black_level ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:television.black_level"" , ""%g"" , dpx . television . black_level ) ; dpx . television . black_gain = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . television . black_gain ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:television.black_gain"" , ""%g"" , dpx . television . black_gain ) ; dpx . television . break_point = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . television . break_point ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:television.break_point"" , ""%g"" , dpx . television . break_point ) ; dpx . television . white_level = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . television . white_level ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:television.white_level"" , ""%g"" , dpx . television . white_level ) ; dpx . television . integration_times = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( dpx . television . integration_times ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:television.integration_times"" , ""%g"" , dpx . television . integration_times ) ; offset += ReadBlob ( image , sizeof ( dpx . television . reserve ) , ( unsigned char * ) dpx . television . reserve ) ; } if ( dpx . file . image_offset > 2080U ) { offset += ReadBlob ( image , sizeof ( dpx . user . id ) , ( unsigned char * ) dpx . user . id ) ; if ( * dpx . user . id != '\\0' ) ( void ) FormatImageProperty ( image , ""dpx:user.id"" , ""%.32s"" , dpx . user . id ) ; if ( ( dpx . file . user_size != ~ 0U ) && ( ( size_t ) dpx . file . user_size > sizeof ( dpx . user . id ) ) ) { StringInfo * profile ; profile = BlobToStringInfo ( ( const void * ) NULL , dpx . file . user_size - sizeof ( dpx . user . id ) ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; offset += ReadBlob ( image , GetStringInfoLength ( profile ) , GetStringInfoDatum ( profile ) ) ; ( void ) SetImageProfile ( image , ""dpx:user-data"" , profile ) ; profile = DestroyStringInfo ( profile ) ; } } for ( ; offset < ( MagickOffsetType ) dpx . file . image_offset ; offset ++ ) ( void ) ReadBlobByte ( image ) ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; <S2SV_StartBug> return ( GetFirstImageInList ( image ) ) ; <S2SV_EndBug> } for ( n = 0 ; n < ( ssize_t ) dpx . image . number_elements ; n ++ ) { if ( ( dpx . image . image_element [ n ] . data_offset != ~ 0U ) && ( dpx . image . image_element [ n ] . data_offset != 0U ) ) { MagickOffsetType data_offset ; data_offset = ( MagickOffsetType ) dpx . image . image_element [ n ] . data_offset ; if ( data_offset < offset ) offset = SeekBlob ( image , data_offset , SEEK_SET ) ; else for ( ; offset < data_offset ; offset ++ ) ( void ) ReadBlobByte ( image ) ; if ( offset != data_offset ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } SetPrimaryChromaticity ( ( DPXColorimetric ) dpx . image . image_element [ n ] . colorimetric , & image -> chromaticity ) ; image -> depth = dpx . image . image_element [ n ] . bit_size ; samples_per_pixel = 1 ; quantum_type = GrayQuantum ; component_type = dpx . image . image_element [ n ] . descriptor ; switch ( component_type ) { case CbYCrY422ComponentType : { samples_per_pixel = 2 ; quantum_type = CbYCrYQuantum ; break ; } case CbYACrYA4224ComponentType : case CbYCr444ComponentType : { samples_per_pixel = 3 ; quantum_type = CbYCrQuantum ; break ; } case RGBComponentType : { samples_per_pixel = 3 ; quantum_type = RGBQuantum ; break ; } case ABGRComponentType : case RGBAComponentType : { image -> matte = MagickTrue ; samples_per_pixel = 4 ; quantum_type = RGBAQuantum ; break ; } default : break ; } switch ( component_type ) { case CbYCrY422ComponentType : case CbYACrYA4224ComponentType : case CbYCr444ComponentType : { ( void ) SetImageColorspace ( image , Rec709YCbCrColorspace ) ; break ; } case LumaComponentType : { ( void ) SetImageColorspace ( image , GRAYColorspace ) ; break ; } default : { ( void ) SetImageColorspace ( image , RGBColorspace ) ; if ( dpx . image . image_element [ n ] . transfer_characteristic == LogarithmicColorimetric ) ( void ) SetImageColorspace ( image , LogColorspace ) ; if ( dpx . image . image_element [ n ] . transfer_characteristic == PrintingDensityColorimetric ) ( void ) SetImageColorspace ( image , LogColorspace ) ; break ; } } extent = GetBytesPerRow ( image -> columns , samples_per_pixel , image -> depth , dpx . image . image_element [ n ] . packing == 0 ? MagickFalse : MagickTrue ) ; status = MagickTrue ; row = 0 ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; SetQuantumQuantum ( quantum_info , 32 ) ; SetQuantumPack ( quantum_info , dpx . image . image_element [ n ] . packing == 0 ? MagickTrue : MagickFalse ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { MagickBooleanType sync ; register PixelPacket * q ; size_t length ; ssize_t count , offset ; unsigned char * pixels ; if ( status == MagickFalse ) continue ; pixels = GetQuantumPixels ( quantum_info ) ; { count = ReadBlob ( image , extent , pixels ) ; if ( ( image -> progress_monitor != ( MagickProgressMonitor ) NULL ) && ( image -> previous == ( Image * ) NULL ) ) { MagickBooleanType proceed ; proceed = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) row , image -> rows ) ; if ( proceed == MagickFalse ) status = MagickFalse ; } offset = row ++ ; } if ( count != ( ssize_t ) extent ) status = MagickFalse ; q = QueueAuthenticPixels ( image , 0 , offset , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { status = MagickFalse ; continue ; } length = ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; ( void ) length ; sync = SyncAuthenticPixels ( image , exception ) ; if ( sync == MagickFalse ) status = MagickFalse ; } quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; SetQuantumImageType ( image , quantum_type ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList
"
762,"CWE-190 void posixtimer_rearm ( struct siginfo * info ) { struct k_itimer * timr ; unsigned long flags ; timr = lock_timer ( info -> si_tid , & flags ) ; if ( ! timr ) return ; if ( timr -> it_requeue_pending == info -> si_sys_private ) { timr -> kclock -> timer_rearm ( timr ) ; timr -> it_active = 1 ; timr -> it_overrun_last = timr -> it_overrun ; <S2SV_StartBug> timr -> it_overrun = - 1 ; <S2SV_EndBug> ++ timr -> it_requeue_pending ; <S2SV_StartBug> info -> si_overrun += timr -> it_overrun_last ; <S2SV_EndBug> } unlock_timer ( timr , flags ) ; }
","<S2SV_ModStart> it_overrun = - 1LL <S2SV_ModEnd> ; ++ timr <S2SV_ModStart> info -> si_overrun = timer_overrun_to_int ( timr , info -> si_overrun ) <S2SV_ModEnd> ; } unlock_timer
"
763,"CWE-522 int credential_from_url_gently ( struct credential * c , const char * url , int quiet ) { const char * at , * colon , * cp , * slash , * host , * proto_end ; credential_clear ( c ) ; proto_end = strstr ( url , ""://"" ) ; <S2SV_StartBug> if ( ! proto_end ) <S2SV_EndBug> return 0 ; cp = proto_end + 3 ; at = strchr ( cp , '@' ) ; colon = strchr ( cp , ':' ) ; slash = strchrnul ( cp , '/' ) ; if ( ! at || slash <= at ) { host = cp ; } else if ( ! colon || at <= colon ) { c -> username = url_decode_mem ( cp , at - cp ) ; host = at + 1 ; } else { c -> username = url_decode_mem ( cp , colon - cp ) ; c -> password = url_decode_mem ( colon + 1 , at - ( colon + 1 ) ) ; host = at + 1 ; } if ( proto_end - url > 0 ) c -> protocol = xmemdupz ( url , proto_end - url ) ; c -> host = url_decode_mem ( host , slash - host ) ; while ( * slash == '/' ) slash ++ ; if ( * slash ) { char * p ; c -> path = url_decode ( slash ) ; p = c -> path + strlen ( c -> path ) - 1 ; while ( p > c -> path && * p == '/' ) * p -- = '\\0' ; } if ( check_url_component ( url , quiet , ""username"" , c -> username ) < 0 || check_url_component ( url , quiet , ""password"" , c -> password ) < 0 || check_url_component ( url , quiet , ""protocol"" , c -> protocol ) < 0 || check_url_component ( url , quiet , ""host"" , c -> host ) < 0 || check_url_component ( url , quiet , ""path"" , c -> path ) < 0 ) return - 1 ; return 0 ; }
","<S2SV_ModStart> ! proto_end ) { if ( ! quiet ) warning ( _ ( ""url<S2SV_blank>has<S2SV_blank>no<S2SV_blank>scheme:<S2SV_blank>%s"" ) , url ) ; return - 1 ; } <S2SV_ModEnd> cp = proto_end
"
764,"CWE-200 bool __net_get_random_once ( void * buf , int nbytes , bool * done , <S2SV_StartBug> struct static_key * done_key ) <S2SV_EndBug> { static DEFINE_SPINLOCK ( lock ) ; unsigned long flags ; spin_lock_irqsave ( & lock , flags ) ; if ( * done ) { spin_unlock_irqrestore ( & lock , flags ) ; return false ; } get_random_bytes ( buf , nbytes ) ; * done = true ; spin_unlock_irqrestore ( & lock , flags ) ; <S2SV_StartBug> __net_random_once_disable_jump ( done_key ) ; <S2SV_EndBug> return true ; }
","<S2SV_ModStart> struct static_key * once_key <S2SV_ModEnd> ) { static <S2SV_ModStart> ; __net_random_once_disable_jump ( once_key <S2SV_ModEnd> ) ; return
"
765,"CWE-416 static void ffs_user_copy_worker ( struct work_struct * work ) { struct ffs_io_data * io_data = container_of ( work , struct ffs_io_data , work ) ; int ret = io_data -> req -> status ? io_data -> req -> status : io_data -> req -> actual ; <S2SV_StartBug> if ( io_data -> read && ret > 0 ) { <S2SV_EndBug> use_mm ( io_data -> mm ) ; ret = copy_to_iter ( io_data -> buf , ret , & io_data -> data ) ; if ( iov_iter_count ( & io_data -> data ) ) ret = - EFAULT ; unuse_mm ( io_data -> mm ) ; } io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ; if ( io_data -> ffs -> ffs_eventfd && <S2SV_StartBug> ! ( io_data -> kiocb -> ki_flags & IOCB_EVENTFD ) ) <S2SV_EndBug> eventfd_signal ( io_data -> ffs -> ffs_eventfd , 1 ) ; <S2SV_StartBug> usb_ep_free_request ( io_data -> ep , io_data -> req ) ; <S2SV_EndBug> io_data -> kiocb -> private = NULL ; if ( io_data -> read ) kfree ( io_data -> to_free ) ; kfree ( io_data -> buf ) ; kfree ( io_data ) ; }
","<S2SV_ModStart> -> actual ; bool kiocb_has_eventfd = <S2SV_ModEnd> io_data -> kiocb <S2SV_ModStart> ki_flags & IOCB_EVENTFD ; if ( io_data -> read && ret > 0 ) { use_mm ( io_data -> mm ) ; ret = copy_to_iter ( io_data -> buf , ret , & io_data -> data ) ; if ( iov_iter_count ( & io_data -> data ) ) ret = - EFAULT ; unuse_mm ( io_data -> mm ) ; } io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ; if ( io_data -> ffs -> ffs_eventfd && ! kiocb_has_eventfd <S2SV_ModEnd> ) eventfd_signal ( <S2SV_ModStart> -> req ) <S2SV_ModEnd> ; if (
"
766,"CWE-17 int ip_forward ( struct sk_buff * skb ) { u32 mtu ; struct iphdr * iph ; struct rtable * rt ; struct ip_options * opt = & ( IPCB ( skb ) -> opt ) ; if ( skb -> pkt_type != PACKET_HOST ) goto drop ; if ( skb_warn_if_lro ( skb ) ) goto drop ; if ( ! xfrm4_policy_check ( NULL , XFRM_POLICY_FWD , skb ) ) goto drop ; if ( IPCB ( skb ) -> opt . router_alert && ip_call_ra_chain ( skb ) ) return NET_RX_SUCCESS ; skb_forward_csum ( skb ) ; if ( ip_hdr ( skb ) -> ttl <= 1 ) goto too_many_hops ; if ( ! xfrm4_route_forward ( skb ) ) goto drop ; rt = skb_rtable ( skb ) ; if ( opt -> is_strictroute && rt -> rt_uses_gateway ) goto sr_failed ; IPCB ( skb ) -> flags |= IPSKB_FORWARDED ; mtu = ip_dst_mtu_maybe_forward ( & rt -> dst , true ) ; if ( ! ip_may_fragment ( skb ) && ip_exceeds_mtu ( skb , mtu ) ) { IP_INC_STATS ( dev_net ( rt -> dst . dev ) , IPSTATS_MIB_FRAGFAILS ) ; icmp_send ( skb , ICMP_DEST_UNREACH , ICMP_FRAG_NEEDED , htonl ( mtu ) ) ; goto drop ; } if ( skb_cow ( skb , LL_RESERVED_SPACE ( rt -> dst . dev ) + rt -> dst . header_len ) ) goto drop ; iph = ip_hdr ( skb ) ; ip_decrease_ttl ( iph ) ; <S2SV_StartBug> if ( rt -> rt_flags & RTCF_DOREDIRECT && ! opt -> srr && ! skb_sec_path ( skb ) ) <S2SV_EndBug> ip_rt_send_redirect ( skb ) ; skb -> priority = rt_tos2priority ( iph -> tos ) ; return NF_HOOK ( NFPROTO_IPV4 , NF_INET_FORWARD , skb , skb -> dev , rt -> dst . dev , ip_forward_finish ) ; sr_failed : icmp_send ( skb , ICMP_DEST_UNREACH , ICMP_SR_FAILED , 0 ) ; goto drop ; too_many_hops : IP_INC_STATS_BH ( dev_net ( skb_dst ( skb ) -> dev ) , IPSTATS_MIB_INHDRERRORS ) ; icmp_send ( skb , ICMP_TIME_EXCEEDED , ICMP_EXC_TTL , 0 ) ; drop : kfree_skb ( skb ) ; return NET_RX_DROP ; }
","<S2SV_ModStart> ; if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT <S2SV_ModEnd> && ! opt
"
767,"CWE-20 static void ikev2_parent_inR1outI2_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct dh_continuation * dh = ( struct dh_continuation * ) pcrc ; struct msg_digest * md = dh -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( ""ikev2<S2SV_blank>parent<S2SV_blank>inR1outI2:<S2SV_blank>calculating<S2SV_blank>g^{xy},<S2SV_blank>sending<S2SV_blank>I2"" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , ""%s:<S2SV_blank>Request<S2SV_blank>was<S2SV_blank>disconnected<S2SV_blank>from<S2SV_blank>state"" , __FUNCTION__ ) ; if ( dh -> md ) release_md ( dh -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == dh -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_inR1outI2_tail ( pcrc , r ) ; if ( dh -> md != NULL ) { complete_v2_state_transition ( & dh -> md , e ) ; if ( dh -> md ) release_md ( dh -> md ) ; } reset_globals ( ) ; <S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
768,"CWE-264 static int trusted_update ( struct key * key , struct key_preparsed_payload * prep ) { <S2SV_StartBug> struct trusted_key_payload * p = key -> payload . data [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> struct trusted_key_payload * new_p ; <S2SV_EndBug> struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( ! p -> migratable ) return - EPERM ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; datablob = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! datablob ) return - ENOMEM ; new_o = trusted_options_alloc ( ) ; if ( ! new_o ) { ret = - ENOMEM ; goto out ; } new_p = trusted_payload_alloc ( key ) ; if ( ! new_p ) { ret = - ENOMEM ; goto out ; } memcpy ( datablob , prep -> data , datalen ) ; datablob [ datalen ] = '\\0' ; ret = datablob_parse ( datablob , new_p , new_o ) ; if ( ret != Opt_update ) { ret = - EINVAL ; kfree ( new_p ) ; goto out ; } if ( ! new_o -> keyhandle ) { ret = - EINVAL ; kfree ( new_p ) ; goto out ; } new_p -> migratable = p -> migratable ; new_p -> key_len = p -> key_len ; memcpy ( new_p -> key , p -> key , p -> key_len ) ; dump_payload ( p ) ; dump_payload ( new_p ) ; ret = key_seal ( new_p , new_o ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:<S2SV_blank>key_seal<S2SV_blank>failed<S2SV_blank>(%d)\\n"" , ret ) ; kfree ( new_p ) ; goto out ; } if ( new_o -> pcrlock ) { ret = pcrlock ( new_o -> pcrlock ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:<S2SV_blank>pcrlock<S2SV_blank>failed<S2SV_blank>(%d)\\n"" , ret ) ; kfree ( new_p ) ; goto out ; } } rcu_assign_keypointer ( key , new_p ) ; call_rcu ( & p -> rcu , trusted_rcu_free ) ; out : kfree ( datablob ) ; kfree ( new_o ) ; return ret ; }
","<S2SV_ModStart> struct trusted_key_payload * p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY ; <S2SV_ModStart> 0 ] ; <S2SV_ModEnd> if ( !
"
769,"CWE-476 static int bmp_getint32 ( jas_stream_t * in , int_fast32_t * val ) { int n ; uint_fast32_t v ; int c ; for ( n = 4 , v = 0 ; ; ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { return - 1 ; } <S2SV_StartBug> v |= ( c << 24 ) ; <S2SV_EndBug> if ( -- n <= 0 ) { break ; } v >>= 8 ; } if ( val ) { * val = v ; } return 0 ; }
","<S2SV_ModStart> v |= ( JAS_CAST ( uint_fast32_t , c ) <S2SV_ModEnd> << 24 )
"
770,"CWE-20 static void rose_loopback_timer ( unsigned long param ) { struct sk_buff * skb ; struct net_device * dev ; rose_address * dest ; struct sock * sk ; unsigned short frametype ; unsigned int lci_i , lci_o ; <S2SV_StartBug> while ( ( skb = skb_dequeue ( & loopback_queue ) ) != NULL ) { <S2SV_EndBug> lci_i = ( ( skb -> data [ 0 ] << 8 ) & 0xF00 ) + ( ( skb -> data [ 1 ] << 0 ) & 0x0FF ) ; frametype = skb -> data [ 2 ] ; <S2SV_StartBug> dest = ( rose_address * ) ( skb -> data + 4 ) ; <S2SV_EndBug> lci_o = ROSE_DEFAULT_MAXVC + 1 - lci_i ; skb_reset_transport_header ( skb ) ; sk = rose_find_socket ( lci_o , rose_loopback_neigh ) ; if ( sk ) { if ( rose_process_rx_frame ( sk , skb ) == 0 ) kfree_skb ( skb ) ; continue ; } if ( frametype == ROSE_CALL_REQUEST ) { if ( ( dev = rose_dev_get ( dest ) ) != NULL ) { if ( rose_rx_call_request ( skb , dev , rose_loopback_neigh , lci_o ) == 0 ) kfree_skb ( skb ) ; } else { kfree_skb ( skb ) ; } } else { kfree_skb ( skb ) ; } } }
","<S2SV_ModStart> NULL ) { if ( skb -> len < ROSE_MIN_LEN ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> 2 ] ; if ( frametype == ROSE_CALL_REQUEST && ( skb -> len <= ROSE_CALL_REQ_FACILITIES_OFF || skb -> data [ ROSE_CALL_REQ_ADDR_LEN_OFF ] != ROSE_CALL_REQ_ADDR_LEN_VAL ) ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> -> data + ROSE_CALL_REQ_DEST_ADDR_OFF <S2SV_ModEnd> ) ; lci_o
"
771,"CWE-399 int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; struct kvm_memory_slot * memslot , * slot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; if ( ! npages && ! old . npages ) goto out_free ; r = - EEXIST ; kvm_for_each_memslot ( slot , kvm -> memslots ) { if ( slot -> id >= KVM_MEMORY_SLOTS || slot == memslot ) continue ; if ( ! ( ( base_gfn + npages <= slot -> base_gfn ) || ( base_gfn >= slot -> base_gfn + slot -> npages ) ) ) goto out_free ; } if ( ! ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) ) new . dirty_bitmap = NULL ; r = - ENOMEM ; if ( ! old . npages ) { new . user_alloc = user_alloc ; new . userspace_addr = mem -> userspace_addr ; if ( kvm_arch_create_memslot ( & new , npages ) ) goto out_free ; } else if ( npages && mem -> userspace_addr != old . userspace_addr ) { r = - EINVAL ; goto out_free ; } if ( ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) && ! new . dirty_bitmap ) { if ( kvm_create_dirty_bitmap ( & new ) < 0 ) goto out_free ; } if ( ! npages || base_gfn != old . base_gfn ) { struct kvm_memory_slot * slot ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; slot = id_to_memslot ( slots , mem -> slot ) ; slot -> flags |= KVM_MEMSLOT_INVALID ; update_memslots ( slots , NULL ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; <S2SV_StartBug> kvm_arch_flush_shadow_memslot ( kvm , slot ) ; <S2SV_EndBug> kfree ( old_memslots ) ; } r = kvm_arch_prepare_memory_region ( kvm , & new , old , mem , user_alloc ) ; if ( r ) <S2SV_StartBug> goto out_free ; <S2SV_EndBug> if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; <S2SV_StartBug> if ( ! npages ) { <S2SV_EndBug> new . dirty_bitmap = NULL ; memset ( & new . arch , 0 , sizeof ( new . arch ) ) ; } update_memslots ( slots , & new ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_commit_memory_region ( kvm , mem , old , user_alloc ) ; kvm_free_physmem_slot ( & old , & new ) ; kfree ( old_memslots ) ; return 0 ; <S2SV_StartBug> out_free : <S2SV_EndBug> kvm_free_physmem_slot ( & new , & old ) ; out : return r ; }
","<S2SV_ModStart> srcu ) ; kvm_iommu_unmap_pages ( kvm , & old ) ; <S2SV_ModStart> ) goto out_free <S2SV_ModEnd> ; r = <S2SV_ModStart> ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_slots ; } if ( <S2SV_ModStart> return 0 ; out_slots : kfree ( slots ) ;
"
772,"CWE-000 unsigned int nf_nat_redirect_ipv4 ( struct sk_buff * skb , const struct nf_nat_ipv4_multi_range_compat * mr , unsigned int hooknum ) { struct nf_conn * ct ; enum ip_conntrack_info ctinfo ; __be32 newdst ; struct nf_nat_range newrange ; NF_CT_ASSERT ( hooknum == NF_INET_PRE_ROUTING || hooknum == NF_INET_LOCAL_OUT ) ; ct = nf_ct_get ( skb , & ctinfo ) ; NF_CT_ASSERT ( ct && ( ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED ) ) ; if ( hooknum == NF_INET_LOCAL_OUT ) { newdst = htonl ( 0x7F000001 ) ; } else { struct in_device * indev ; struct in_ifaddr * ifa ; newdst = 0 ; rcu_read_lock ( ) ; indev = __in_dev_get_rcu ( skb -> dev ) ; <S2SV_StartBug> if ( indev != NULL ) { <S2SV_EndBug> ifa = indev -> ifa_list ; newdst = ifa -> ifa_local ; } rcu_read_unlock ( ) ; if ( ! newdst ) return NF_DROP ; } memset ( & newrange . min_addr , 0 , sizeof ( newrange . min_addr ) ) ; memset ( & newrange . max_addr , 0 , sizeof ( newrange . max_addr ) ) ; newrange . flags = mr -> range [ 0 ] . flags | NF_NAT_RANGE_MAP_IPS ; newrange . min_addr . ip = newdst ; newrange . max_addr . ip = newdst ; newrange . min_proto = mr -> range [ 0 ] . min ; newrange . max_proto = mr -> range [ 0 ] . max ; return nf_nat_setup_info ( ct , & newrange , NF_NAT_MANIP_DST ) ; }
","<S2SV_ModStart> if ( indev && indev -> ifa_list <S2SV_ModEnd> ) { ifa
"
773,"CWE-000 int fdt_find_regions ( const void * fdt , char * const inc [ ] , int inc_count , char * const exc_prop [ ] , int exc_prop_count , struct fdt_region region [ ] , int max_regions , char * path , int path_len , int add_string_tab ) { int stack [ FDT_MAX_DEPTH ] = { 0 } ; char * end ; int nextoffset = 0 ; uint32_t tag ; int count = 0 ; int start = - 1 ; int depth = - 1 ; int want = 0 ; int base = fdt_off_dt_struct ( fdt ) ; <S2SV_StartBug> end = path ; <S2SV_EndBug> * end = '\\0' ; do { const struct fdt_property * prop ; const char * name ; const char * str ; int include = 0 ; int stop_at = 0 ; int offset ; int len ; offset = nextoffset ; tag = fdt_next_tag ( fdt , offset , & nextoffset ) ; stop_at = nextoffset ; <S2SV_StartBug> switch ( tag ) { <S2SV_EndBug> case FDT_PROP : include = want >= 2 ; stop_at = offset ; prop = fdt_get_property_by_offset ( fdt , offset , NULL ) ; str = fdt_string ( fdt , fdt32_to_cpu ( prop -> nameoff ) ) ; if ( ! str ) return - FDT_ERR_BADSTRUCTURE ; if ( str_in_list ( str , exc_prop , exc_prop_count ) ) include = 0 ; break ; case FDT_NOP : include = want >= 2 ; stop_at = offset ; break ; case FDT_BEGIN_NODE : depth ++ ; if ( depth == FDT_MAX_DEPTH ) return - FDT_ERR_BADSTRUCTURE ; <S2SV_StartBug> name = fdt_get_name ( fdt , offset , & len ) ; <S2SV_EndBug> if ( end - path + 2 + len >= path_len ) return - FDT_ERR_NOSPACE ; if ( end != path + 1 ) * end ++ = '/' ; strcpy ( end , name ) ; end += len ; stack [ depth ] = want ; if ( want == 1 ) stop_at = offset ; if ( str_in_list ( path , inc , inc_count ) ) want = 2 ; else if ( want ) want -- ; else stop_at = offset ; include = want ; break ; case FDT_END_NODE : if ( depth < 0 ) return - FDT_ERR_BADSTRUCTURE ; include = want ; want = stack [ depth -- ] ; while ( end > path && * -- end != '/' ) ; * end = '\\0' ; <S2SV_StartBug> break ; <S2SV_EndBug> case FDT_END : include = 1 ; break ; } if ( include && start == - 1 ) { if ( count && count <= max_regions && offset == region [ count - 1 ] . offset + region [ count - 1 ] . size - base ) start = region [ -- count ] . offset - base ; else start = offset ; } if ( ! include && start != - 1 ) { if ( count < max_regions ) { region [ count ] . offset = base + start ; region [ count ] . size = stop_at - start ; } count ++ ; start = - 1 ; } } while ( tag != FDT_END ) ; if ( nextoffset != fdt_size_dt_struct ( fdt ) ) return - FDT_ERR_BADLAYOUT ; if ( count < max_regions ) { region [ count ] . offset = base + start ; region [ count ] . size = nextoffset - start ; if ( add_string_tab ) region [ count ] . size += fdt_size_dt_strings ( fdt ) ; } count ++ ; return count ; }
","<S2SV_ModStart> fdt ) ; bool expect_end = false ; <S2SV_ModStart> = nextoffset ; if ( expect_end && tag != FDT_END ) return - FDT_ERR_BADLAYOUT ; <S2SV_ModStart> & len ) ; if ( ! depth && * name ) return - FDT_ERR_BADLAYOUT <S2SV_ModStart> = '\\0' ; if ( depth == - 1 ) expect_end = true ;
"
774,"CWE-787 int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file<S2SV_blank>(by<S2SV_blank>total<S2SV_blank>size)!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""file<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( ""chunk<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , ""FVER"" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , ""L"" ) ; if ( debug_logging_mode ) error_line ( ""dsdiff<S2SV_blank>file<S2SV_blank>version<S2SV_blank>=<S2SV_blank>0x%08x"" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""PROP"" , 4 ) ) { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total"" , ( int ) dff_chunk_header . ckDataSize ) ; prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , ""SND<S2SV_blank>"" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; uint16_t numChannels , chansSpecified , chanMask = 0 ; uint32_t sampleRate ; while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( eptr - cptr >= dff_chunk_header . ckDataSize ) { if ( ! strncmp ( dff_chunk_header . ckID , ""FS<S2SV_blank><S2SV_blank>"" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , ""L"" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>Hz"" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CHNL"" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , ""S"" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ; while ( chansSpecified -- ) { if ( ! strncmp ( cptr , ""SLFT"" , 4 ) || ! strncmp ( cptr , ""MLFT"" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , ""SRGT"" , 4 ) || ! strncmp ( cptr , ""MRGT"" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , ""LS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , ""RS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , ""C<S2SV_blank><S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , ""LFE<S2SV_blank>"" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( ""undefined<S2SV_blank>channel<S2SV_blank>ID<S2SV_blank>%c%c%c%c"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( ""%d<S2SV_blank>channels,<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>0x%08x"" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CMPR"" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""DSDIFF<S2SV_blank>files<S2SV_blank>must<S2SV_blank>be<S2SV_blank>uncompressed,<S2SV_blank>not<S2SV_blank>\\""%c%c%c%c\\""!"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP/SND<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>DSDIFF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>unknown<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""DSD<S2SV_blank>"" , 4 ) ) { total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; <S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( ""setting<S2SV_blank>configuration<S2SV_blank>with<S2SV_blank>%lld<S2SV_blank>samples"" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
","<S2SV_ModStart> char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff
"
775,"CWE-000 BIO * PKCS7_dataDecode ( PKCS7 * p7 , EVP_PKEY * pkey , BIO * in_bio , X509 * pcert ) { int i , j ; BIO * out = NULL , * btmp = NULL , * etmp = NULL , * bio = NULL ; X509_ALGOR * xa ; ASN1_OCTET_STRING * data_body = NULL ; const EVP_MD * evp_md ; const EVP_CIPHER * evp_cipher = NULL ; EVP_CIPHER_CTX * evp_ctx = NULL ; X509_ALGOR * enc_alg = NULL ; STACK_OF ( X509_ALGOR ) * md_sk = NULL ; STACK_OF ( PKCS7_RECIP_INFO ) * rsk = NULL ; PKCS7_RECIP_INFO * ri = NULL ; unsigned char * ek = NULL , * tkey = NULL ; int eklen = 0 , tkeylen = 0 ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_NULL_POINTER ) ; return NULL ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; return NULL ; } i = OBJ_obj2nid ( p7 -> type ) ; p7 -> state = PKCS7_S_HEADER ; switch ( i ) { case NID_pkcs7_signed : data_body = PKCS7_get_octet_string ( p7 -> d . sign -> contents ) ; if ( ! PKCS7_is_detached ( p7 ) && data_body == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_SIGNED_DATA_TYPE ) ; goto err ; } md_sk = p7 -> d . sign -> md_algs ; break ; case NID_pkcs7_signedAndEnveloped : rsk = p7 -> d . signed_and_enveloped -> recipientinfo ; md_sk = p7 -> d . signed_and_enveloped -> md_algs ; data_body = p7 -> d . signed_and_enveloped -> enc_data -> enc_data ; enc_alg = p7 -> d . signed_and_enveloped -> enc_data -> algorithm ; evp_cipher = EVP_get_cipherbyobj ( enc_alg -> algorithm ) ; if ( evp_cipher == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CIPHER_TYPE ) ; goto err ; } break ; case NID_pkcs7_enveloped : rsk = p7 -> d . enveloped -> recipientinfo ; enc_alg = p7 -> d . enveloped -> enc_data -> algorithm ; data_body = p7 -> d . enveloped -> enc_data -> enc_data ; evp_cipher = EVP_get_cipherbyobj ( enc_alg -> algorithm ) ; if ( evp_cipher == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CIPHER_TYPE ) ; goto err ; } break ; default : PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CONTENT_TYPE ) ; goto err ; } <S2SV_StartBug> if ( md_sk != NULL ) { <S2SV_EndBug> for ( i = 0 ; i < sk_X509_ALGOR_num ( md_sk ) ; i ++ ) { xa = sk_X509_ALGOR_value ( md_sk , i ) ; if ( ( btmp = BIO_new ( BIO_f_md ( ) ) ) == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , ERR_R_BIO_LIB ) ; goto err ; } j = OBJ_obj2nid ( xa -> algorithm ) ; evp_md = EVP_get_digestbynid ( j ) ; if ( evp_md == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNKNOWN_DIGEST_TYPE ) ; goto err ; } BIO_set_md ( btmp , evp_md ) ; if ( out == NULL ) out = btmp ; else BIO_push ( out , btmp ) ; btmp = NULL ; } } if ( evp_cipher != NULL ) { if ( ( etmp = BIO_new ( BIO_f_cipher ( ) ) ) == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , ERR_R_BIO_LIB ) ; goto err ; } if ( pcert ) { for ( i = 0 ; i < sk_PKCS7_RECIP_INFO_num ( rsk ) ; i ++ ) { ri = sk_PKCS7_RECIP_INFO_value ( rsk , i ) ; if ( ! pkcs7_cmp_ri ( ri , pcert ) ) break ; ri = NULL ; } if ( ri == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE ) ; goto err ; } } if ( pcert == NULL ) { for ( i = 0 ; i < sk_PKCS7_RECIP_INFO_num ( rsk ) ; i ++ ) { ri = sk_PKCS7_RECIP_INFO_value ( rsk , i ) ; if ( pkcs7_decrypt_rinfo ( & ek , & eklen , ri , pkey ) < 0 ) goto err ; ERR_clear_error ( ) ; } } else { if ( pkcs7_decrypt_rinfo ( & ek , & eklen , ri , pkey ) < 0 ) goto err ; ERR_clear_error ( ) ; } evp_ctx = NULL ; BIO_get_cipher_ctx ( etmp , & evp_ctx ) ; if ( EVP_CipherInit_ex ( evp_ctx , evp_cipher , NULL , NULL , NULL , 0 ) <= 0 ) goto err ; if ( EVP_CIPHER_asn1_to_param ( evp_ctx , enc_alg -> parameter ) < 0 ) goto err ; tkeylen = EVP_CIPHER_CTX_key_length ( evp_ctx ) ; tkey = OPENSSL_malloc ( tkeylen ) ; if ( ! tkey ) goto err ; if ( EVP_CIPHER_CTX_rand_key ( evp_ctx , tkey ) <= 0 ) goto err ; if ( ek == NULL ) { ek = tkey ; eklen = tkeylen ; tkey = NULL ; } if ( eklen != EVP_CIPHER_CTX_key_length ( evp_ctx ) ) { if ( ! EVP_CIPHER_CTX_set_key_length ( evp_ctx , eklen ) ) { OPENSSL_clear_free ( ek , eklen ) ; ek = tkey ; eklen = tkeylen ; tkey = NULL ; } } ERR_clear_error ( ) ; if ( EVP_CipherInit_ex ( evp_ctx , NULL , NULL , ek , NULL , 0 ) <= 0 ) goto err ; OPENSSL_clear_free ( ek , eklen ) ; ek = NULL ; OPENSSL_clear_free ( tkey , tkeylen ) ; tkey = NULL ; if ( out == NULL ) out = etmp ; else BIO_push ( out , etmp ) ; etmp = NULL ; } <S2SV_StartBug> if ( PKCS7_is_detached ( p7 ) || ( in_bio != NULL ) ) { <S2SV_EndBug> bio = in_bio ; } else { if ( data_body -> length > 0 ) bio = BIO_new_mem_buf ( data_body -> data , data_body -> length ) ; else { bio = BIO_new ( BIO_s_mem ( ) ) ; BIO_set_mem_eof_return ( bio , 0 ) ; } if ( bio == NULL ) goto err ; } BIO_push ( out , bio ) ; bio = NULL ; return out ; err : OPENSSL_clear_free ( ek , eklen ) ; OPENSSL_clear_free ( tkey , tkeylen ) ; BIO_free_all ( out ) ; BIO_free_all ( btmp ) ; BIO_free_all ( etmp ) ; BIO_free_all ( bio ) ; return NULL ; }
","<S2SV_ModStart> } if ( data_body == NULL && in_bio == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; goto err ; } if ( <S2SV_ModStart> } if ( <S2SV_ModEnd> in_bio != NULL <S2SV_ModStart> != NULL ) <S2SV_ModEnd> { bio =
"
776,"CWE-20 int serverCron ( struct aeEventLoop * eventLoop , long long id , void * clientData ) { int j , loops = server . cronloops ++ ; REDIS_NOTUSED ( eventLoop ) ; REDIS_NOTUSED ( id ) ; REDIS_NOTUSED ( clientData ) ; server . unixtime = time ( NULL ) ; updateLRUClock ( ) ; if ( server . shutdown_asap ) { if ( prepareForShutdown ( ) == REDIS_OK ) exit ( 0 ) ; redisLog ( REDIS_WARNING , ""SIGTERM<S2SV_blank>received<S2SV_blank>but<S2SV_blank>errors<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>shut<S2SV_blank>down<S2SV_blank>the<S2SV_blank>server,<S2SV_blank>check<S2SV_blank>the<S2SV_blank>logs<S2SV_blank>for<S2SV_blank>more<S2SV_blank>information"" ) ; } for ( j = 0 ; j < server . dbnum ; j ++ ) { long long size , used , vkeys ; size = dictSlots ( server . db [ j ] . dict ) ; used = dictSize ( server . db [ j ] . dict ) ; vkeys = dictSize ( server . db [ j ] . expires ) ; if ( ! ( loops % 50 ) && ( used || vkeys ) ) { redisLog ( REDIS_VERBOSE , ""DB<S2SV_blank>%d:<S2SV_blank>%lld<S2SV_blank>keys<S2SV_blank>(%lld<S2SV_blank>volatile)<S2SV_blank>in<S2SV_blank>%lld<S2SV_blank>slots<S2SV_blank>HT."" , j , used , vkeys , size ) ; } } if ( server . bgsavechildpid == - 1 && server . bgrewritechildpid == - 1 ) { if ( ! ( loops % 10 ) ) tryResizeHashTables ( ) ; if ( server . activerehashing ) incrementallyRehash ( ) ; } if ( ! ( loops % 50 ) ) { redisLog ( REDIS_VERBOSE , ""%d<S2SV_blank>clients<S2SV_blank>connected<S2SV_blank>(%d<S2SV_blank>slaves),<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>use"" , listLength ( server . clients ) - listLength ( server . slaves ) , listLength ( server . slaves ) , zmalloc_used_memory ( ) ) ; } if ( ( server . maxidletime && ! ( loops % 100 ) ) || server . bpop_blocked_clients ) closeTimedoutClients ( ) ; if ( server . bgsavechildpid != - 1 || server . bgrewritechildpid != - 1 ) { int statloc ; pid_t pid ; if ( ( pid = wait3 ( & statloc , WNOHANG , NULL ) ) != 0 ) { if ( pid == server . bgsavechildpid ) { backgroundSaveDoneHandler ( statloc ) ; } else { backgroundRewriteDoneHandler ( statloc ) ; } updateDictResizePolicy ( ) ; } } else { time_t now = time ( NULL ) ; for ( j = 0 ; j < server . saveparamslen ; j ++ ) { struct saveparam * sp = server . saveparams + j ; if ( server . dirty >= sp -> changes && now - server . lastsave > sp -> seconds ) { redisLog ( REDIS_NOTICE , ""%d<S2SV_blank>changes<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>seconds.<S2SV_blank>Saving..."" , sp -> changes , sp -> seconds ) ; rdbSaveBackground ( server . dbfilename ) ; break ; } } } if ( server . masterhost == NULL ) activeExpireCycle ( ) ; <S2SV_StartBug> if ( vmCanSwapOut ( ) ) { <S2SV_EndBug> <S2SV_StartBug> while ( server . vm_enabled && zmalloc_used_memory ( ) > <S2SV_EndBug> <S2SV_StartBug> server . vm_max_memory ) <S2SV_EndBug> { int retval = ( server . vm_max_threads == 0 ) ? vmSwapOneObjectBlocking ( ) : vmSwapOneObjectThreaded ( ) ; if ( retval == REDIS_ERR && ! ( loops % 300 ) && zmalloc_used_memory ( ) > ( server . vm_max_memory + server . vm_max_memory / 10 ) ) { redisLog ( REDIS_WARNING , ""WARNING:<S2SV_blank>vm-max-memory<S2SV_blank>limit<S2SV_blank>exceeded<S2SV_blank>by<S2SV_blank>more<S2SV_blank>than<S2SV_blank>10%%<S2SV_blank>but<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>swap<S2SV_blank>more<S2SV_blank>objects<S2SV_blank>out!"" ) ; } if ( retval == REDIS_ERR || server . vm_max_threads > 0 ) break ; } } if ( ! ( loops % 10 ) ) replicationCron ( ) ; return 100 ; }
","<S2SV_ModStart> ( ) ; <S2SV_ModEnd> while ( server <S2SV_ModStart> ( server . ds_enabled <S2SV_ModEnd> && zmalloc_used_memory ( <S2SV_ModStart> > server . cache_max_memory ) { cacheFreeOneEntry ( ) ; <S2SV_ModEnd> } if (
"
777,"CWE-264 static void uv__process_child_init ( const uv_process_options_t * options , int stdio_count , int ( * pipes ) [ 2 ] , int error_fd ) { int close_fd ; int use_fd ; int fd ; if ( options -> flags & UV_PROCESS_DETACHED ) setsid ( ) ; for ( fd = 0 ; fd < stdio_count ; fd ++ ) { close_fd = pipes [ fd ] [ 0 ] ; use_fd = pipes [ fd ] [ 1 ] ; if ( use_fd < 0 ) { if ( fd >= 3 ) continue ; else { use_fd = open ( ""/dev/null"" , fd == 0 ? O_RDONLY : O_RDWR ) ; close_fd = use_fd ; if ( use_fd == - 1 ) { uv__write_int ( error_fd , - errno ) ; perror ( ""failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>stdio"" ) ; _exit ( 127 ) ; } } } if ( fd == use_fd ) uv__cloexec ( use_fd , 0 ) ; else dup2 ( use_fd , fd ) ; if ( fd <= 2 ) uv__nonblock ( fd , 0 ) ; if ( close_fd != - 1 ) uv__close ( close_fd ) ; } for ( fd = 0 ; fd < stdio_count ; fd ++ ) { use_fd = pipes [ fd ] [ 1 ] ; if ( use_fd >= 0 && fd != use_fd ) close ( use_fd ) ; } if ( options -> cwd != NULL && chdir ( options -> cwd ) ) { uv__write_int ( error_fd , - errno ) ; perror ( ""chdir()"" ) ; _exit ( 127 ) ; } <S2SV_StartBug> if ( ( options -> flags & UV_PROCESS_SETGID ) && setgid ( options -> gid ) ) { <S2SV_EndBug> uv__write_int ( error_fd , - errno ) ; perror ( ""setgid()"" ) ; _exit ( 127 ) ; } if ( ( options -> flags & UV_PROCESS_SETUID ) && setuid ( options -> uid ) ) { uv__write_int ( error_fd , - errno ) ; perror ( ""setuid()"" ) ; _exit ( 127 ) ; } if ( options -> env != NULL ) { environ = options -> env ; } execvp ( options -> file , options -> args ) ; uv__write_int ( error_fd , - errno ) ; perror ( ""execvp()"" ) ; _exit ( 127 ) ; }
","<S2SV_ModStart> } if ( options -> flags & ( UV_PROCESS_SETUID | UV_PROCESS_SETGID ) ) { SAVE_ERRNO ( setgroups ( 0 , NULL ) ) ; } if (
"
778,"CWE-119 static int cxusb_ctrl_msg ( struct dvb_usb_device * d , u8 cmd , u8 * wbuf , int wlen , u8 * rbuf , int rlen ) { struct cxusb_state * st = d -> priv ; <S2SV_StartBug> int ret , wo ; <S2SV_EndBug> if ( 1 + wlen > MAX_XFER_SIZE ) { warn ( ""i2c<S2SV_blank>wr:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\n"" , wlen ) ; return - EOPNOTSUPP ; } <S2SV_StartBug> wo = ( rbuf == NULL || rlen == 0 ) ; <S2SV_EndBug> mutex_lock ( & d -> data_mutex ) ; st -> data [ 0 ] = cmd ; memcpy ( & st -> data [ 1 ] , wbuf , wlen ) ; <S2SV_StartBug> if ( wo ) <S2SV_EndBug> ret = dvb_usb_generic_write ( d , st -> data , 1 + wlen ) ; else ret = dvb_usb_generic_rw ( d , st -> data , 1 + wlen , <S2SV_StartBug> rbuf , rlen , 0 ) ; <S2SV_EndBug> mutex_unlock ( & d -> data_mutex ) ; return ret ; }
","<S2SV_ModStart> ; int ret <S2SV_ModEnd> ; if ( <S2SV_ModStart> EOPNOTSUPP ; } if ( rlen > MAX_XFER_SIZE ) { warn ( ""i2c<S2SV_blank>rd:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\n"" , rlen ) ; return - EOPNOTSUPP ; } <S2SV_ModEnd> mutex_lock ( & <S2SV_ModStart> wlen ) ; <S2SV_ModEnd> ret = dvb_usb_generic_rw <S2SV_ModStart> + wlen , st -> data <S2SV_ModEnd> , rlen , <S2SV_ModStart> rlen , 0 ) ; if ( ! ret && rbuf && rlen ) memcpy ( rbuf , st -> data , rlen
"
779,"CWE-835 static void setup_connection ( GsmXSMPClient * client ) { GIOChannel * channel ; int fd ; g_debug ( ""GsmXSMPClient:<S2SV_blank>Setting<S2SV_blank>up<S2SV_blank>new<S2SV_blank>connection"" ) ; fd = IceConnectionNumber ( client -> priv -> ice_connection ) ; fcntl ( fd , F_SETFD , fcntl ( fd , F_GETFD , 0 ) | FD_CLOEXEC ) ; channel = g_io_channel_unix_new ( fd ) ; client -> priv -> watch_id = g_io_add_watch ( channel , G_IO_IN | G_IO_ERR , ( GIOFunc ) client_iochannel_watch , client ) ; g_io_channel_unref ( channel ) ; <S2SV_StartBug> client -> priv -> protocol_timeout = g_timeout_add_seconds ( 5 , <S2SV_EndBug> ( GSourceFunc ) _client_protocol_timeout , client ) ; set_description ( client ) ; g_debug ( ""GsmXSMPClient:<S2SV_blank>New<S2SV_blank>client<S2SV_blank>\'%s\'"" , client -> priv -> description ) ; }
","<S2SV_ModStart> channel ) ; <S2SV_ModEnd> set_description ( client
"
780,"CWE-200 long vorbis_book_decodev_add ( codebook * book , ogg_int32_t * a , oggpack_buffer * b , int n , int point ) { if ( book -> used_entries > 0 ) { ogg_int32_t * v = book -> dec_buf ; int i , j ; if ( ! v ) return - 1 ; for ( i = 0 ; i < n ; ) { if ( decode_map ( book , b , v , point ) ) return - 1 ; <S2SV_StartBug> for ( j = 0 ; j < book -> dim ; j ++ ) <S2SV_EndBug> a [ i ++ ] += v [ j ] ; } } return 0 ; }
","<S2SV_ModStart> book -> dim && i < n
"
781,"CWE-20 void BezierCircle ( double r , char * action ) <S2SV_StartBug> { <S2SV_EndBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>m<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\n"" , - r , - r , r * BzK , - r * BzK , r , r ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>c\\n"" , r * BzK , r , r , r * BzK , r ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\n"" , r , - r * BzK , r * BzK , - r , - r ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>c<S2SV_blank>%s\\n"" , - r * BzK , - r , - r , - r * BzK , - r , action ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> action ) { char * outpos = outputbuffer ; <S2SV_ModStart> action ) ; sendClean ( outputbuffer ) ;
"
782,"CWE-310 static noinline int create_pending_snapshot ( struct btrfs_trans_handle * trans , struct btrfs_fs_info * fs_info , struct btrfs_pending_snapshot * pending ) { struct btrfs_key key ; struct btrfs_root_item * new_root_item ; struct btrfs_root * tree_root = fs_info -> tree_root ; struct btrfs_root * root = pending -> root ; struct btrfs_root * parent_root ; struct btrfs_block_rsv * rsv ; struct inode * parent_inode ; struct btrfs_path * path ; struct btrfs_dir_item * dir_item ; struct dentry * parent ; struct dentry * dentry ; struct extent_buffer * tmp ; struct extent_buffer * old ; struct timespec cur_time = CURRENT_TIME ; int ret ; u64 to_reserve = 0 ; u64 index = 0 ; u64 objectid ; u64 root_flags ; uuid_le new_uuid ; path = btrfs_alloc_path ( ) ; if ( ! path ) { ret = pending -> error = - ENOMEM ; goto path_alloc_fail ; } new_root_item = kmalloc ( sizeof ( * new_root_item ) , GFP_NOFS ) ; if ( ! new_root_item ) { ret = pending -> error = - ENOMEM ; goto root_item_alloc_fail ; } ret = btrfs_find_free_objectid ( tree_root , & objectid ) ; if ( ret ) { pending -> error = ret ; goto no_free_objectid ; } btrfs_reloc_pre_snapshot ( trans , pending , & to_reserve ) ; if ( to_reserve > 0 ) { ret = btrfs_block_rsv_add ( root , & pending -> block_rsv , to_reserve , BTRFS_RESERVE_NO_FLUSH ) ; if ( ret ) { pending -> error = ret ; goto no_free_objectid ; } } ret = btrfs_qgroup_inherit ( trans , fs_info , root -> root_key . objectid , objectid , pending -> inherit ) ; if ( ret ) { pending -> error = ret ; goto no_free_objectid ; } key . objectid = objectid ; key . offset = ( u64 ) - 1 ; key . type = BTRFS_ROOT_ITEM_KEY ; rsv = trans -> block_rsv ; trans -> block_rsv = & pending -> block_rsv ; dentry = pending -> dentry ; parent = dget_parent ( dentry ) ; parent_inode = parent -> d_inode ; parent_root = BTRFS_I ( parent_inode ) -> root ; record_root_in_trans ( trans , parent_root ) ; ret = btrfs_set_inode_index ( parent_inode , & index ) ; BUG_ON ( ret ) ; dir_item = btrfs_lookup_dir_item ( NULL , parent_root , path , btrfs_ino ( parent_inode ) , dentry -> d_name . name , dentry -> d_name . len , 0 ) ; if ( dir_item != NULL && ! IS_ERR ( dir_item ) ) { pending -> error = - EEXIST ; goto fail ; } else if ( IS_ERR ( dir_item ) ) { ret = PTR_ERR ( dir_item ) ; btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } btrfs_release_path ( path ) ; ret = btrfs_run_delayed_items ( trans , root ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } record_root_in_trans ( trans , root ) ; btrfs_set_root_last_snapshot ( & root -> root_item , trans -> transid ) ; memcpy ( new_root_item , & root -> root_item , sizeof ( * new_root_item ) ) ; btrfs_check_and_init_root_item ( new_root_item ) ; root_flags = btrfs_root_flags ( new_root_item ) ; if ( pending -> readonly ) root_flags |= BTRFS_ROOT_SUBVOL_RDONLY ; else root_flags &= ~ BTRFS_ROOT_SUBVOL_RDONLY ; btrfs_set_root_flags ( new_root_item , root_flags ) ; btrfs_set_root_generation_v2 ( new_root_item , trans -> transid ) ; uuid_le_gen ( & new_uuid ) ; memcpy ( new_root_item -> uuid , new_uuid . b , BTRFS_UUID_SIZE ) ; memcpy ( new_root_item -> parent_uuid , root -> root_item . uuid , BTRFS_UUID_SIZE ) ; new_root_item -> otime . sec = cpu_to_le64 ( cur_time . tv_sec ) ; new_root_item -> otime . nsec = cpu_to_le32 ( cur_time . tv_nsec ) ; btrfs_set_root_otransid ( new_root_item , trans -> transid ) ; memset ( & new_root_item -> stime , 0 , sizeof ( new_root_item -> stime ) ) ; memset ( & new_root_item -> rtime , 0 , sizeof ( new_root_item -> rtime ) ) ; btrfs_set_root_stransid ( new_root_item , 0 ) ; btrfs_set_root_rtransid ( new_root_item , 0 ) ; old = btrfs_lock_root_node ( root ) ; ret = btrfs_cow_block ( trans , root , old , NULL , 0 , & old ) ; if ( ret ) { btrfs_tree_unlock ( old ) ; free_extent_buffer ( old ) ; btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } btrfs_set_lock_blocking ( old ) ; ret = btrfs_copy_root ( trans , root , old , & tmp , objectid ) ; btrfs_tree_unlock ( old ) ; free_extent_buffer ( old ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } root -> force_cow = 1 ; smp_wmb ( ) ; btrfs_set_root_node ( new_root_item , tmp ) ; key . offset = trans -> transid ; ret = btrfs_insert_root ( trans , tree_root , & key , new_root_item ) ; btrfs_tree_unlock ( tmp ) ; free_extent_buffer ( tmp ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } ret = btrfs_add_root_ref ( trans , tree_root , objectid , parent_root -> root_key . objectid , btrfs_ino ( parent_inode ) , index , dentry -> d_name . name , dentry -> d_name . len ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } key . offset = ( u64 ) - 1 ; pending -> snap = btrfs_read_fs_root_no_name ( root -> fs_info , & key ) ; if ( IS_ERR ( pending -> snap ) ) { ret = PTR_ERR ( pending -> snap ) ; btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } ret = btrfs_reloc_post_snapshot ( trans , pending ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } ret = btrfs_run_delayed_refs ( trans , root , ( unsigned long ) - 1 ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } ret = btrfs_insert_dir_item ( trans , parent_root , dentry -> d_name . name , dentry -> d_name . len , parent_inode , & key , BTRFS_FT_DIR , index ) ; <S2SV_StartBug> BUG_ON ( ret == - EEXIST ) ; <S2SV_EndBug> if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto fail ; } btrfs_i_size_write ( parent_inode , parent_inode -> i_size + dentry -> d_name . len * 2 ) ; parent_inode -> i_mtime = parent_inode -> i_ctime = CURRENT_TIME ; ret = btrfs_update_inode_fallback ( trans , parent_root , parent_inode ) ; if ( ret ) btrfs_abort_transaction ( trans , root , ret ) ; fail : dput ( parent ) ; trans -> block_rsv = rsv ; no_free_objectid : kfree ( new_root_item ) ; root_item_alloc_fail : btrfs_free_path ( path ) ; path_alloc_fail : btrfs_block_rsv_release ( root , & pending -> block_rsv , ( u64 ) - 1 ) ; return ret ; }
","<S2SV_ModStart> == - EEXIST || ret == - EOVERFLOW
"
783,"CWE-119 void unix_notinflight ( struct file * fp ) { struct sock * s = unix_get_socket ( fp ) ; <S2SV_StartBug> if ( s ) { <S2SV_EndBug> <S2SV_StartBug> struct unix_sock * u = unix_sk ( s ) ; <S2SV_EndBug> spin_lock ( & unix_gc_lock ) ; BUG_ON ( list_empty ( & u -> link ) ) ; if ( atomic_long_dec_and_test ( & u -> inflight ) ) list_del_init ( & u -> link ) ; unix_tot_inflight -- ; <S2SV_StartBug> spin_unlock ( & unix_gc_lock ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> fp ) ; spin_lock ( & unix_gc_lock ) ; <S2SV_ModStart> unix_sk ( s <S2SV_ModEnd> ) ; BUG_ON <S2SV_ModStart> unix_tot_inflight -- ; } fp -> f_cred -> user -> unix_inflight -- ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
"
784,"CWE-119 static int aiff_read_chanmap ( SF_PRIVATE * psf , unsigned dword ) { const AIFF_CAF_CHANNEL_MAP * map_info ; unsigned channel_bitmap , channel_decriptions , bytesread ; int layout_tag ; bytesread = psf_binheader_readf ( psf , ""444"" , & layout_tag , & channel_bitmap , & channel_decriptions ) ; if ( ( map_info = aiff_caf_of_channel_layout_tag ( layout_tag ) ) == NULL ) return 0 ; psf_log_printf ( psf , ""<S2SV_blank><S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank>%x\\n"" , layout_tag ) ; if ( map_info ) psf_log_printf ( psf , ""<S2SV_blank><S2SV_blank>Layout<S2SV_blank>:<S2SV_blank>%s\\n"" , map_info -> name ) ; if ( bytesread < dword ) psf_binheader_readf ( psf , ""j"" , dword - bytesread ) ; if ( map_info -> channel_map != NULL ) <S2SV_StartBug> { size_t chanmap_size = psf -> sf . channels * sizeof ( psf -> channel_map [ 0 ] ) ; <S2SV_EndBug> free ( psf -> channel_map ) ; if ( ( psf -> channel_map = malloc ( chanmap_size ) ) == NULL ) return SFE_MALLOC_FAILED ; memcpy ( psf -> channel_map , map_info -> channel_map , chanmap_size ) ; } ; return 0 ; }
","<S2SV_ModStart> size_t chanmap_size = SF_MIN ( <S2SV_ModStart> sf . channels , layout_tag & 0xffff )
"
785,"CWE-119 void vp9_setup_scale_factors_for_frame ( struct scale_factors * sf , int other_w , int other_h , int this_w , int this_h ) { <S2SV_StartBug> if ( ! check_scale_factors ( other_w , other_h , this_w , this_h ) ) { <S2SV_EndBug> sf -> x_scale_fp = REF_INVALID_SCALE ; sf -> y_scale_fp = REF_INVALID_SCALE ; return ; } sf -> x_scale_fp = get_fixed_point_scale_factor ( other_w , this_w ) ; sf -> y_scale_fp = get_fixed_point_scale_factor ( other_h , this_h ) ; sf -> x_step_q4 = scaled_x ( 16 , sf ) ; sf -> y_step_q4 = scaled_y ( 16 , sf ) ; if ( vp9_is_scaled ( sf ) ) { sf -> scale_value_x = scaled_x ; sf -> scale_value_y = scaled_y ; } else { sf -> scale_value_x = unscaled_value ; sf -> scale_value_y = unscaled_value ; } if ( sf -> x_step_q4 == 16 ) { if ( sf -> y_step_q4 == 16 ) { <S2SV_StartBug> sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve_copy ; <S2SV_EndBug> sf -> predict [ 0 ] [ 0 ] [ 1 ] = vp9_convolve_avg ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vp9_convolve8_vert ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vp9_convolve8_avg_vert ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vp9_convolve8_horiz ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vp9_convolve8_avg_horiz ; } else { <S2SV_StartBug> sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve8_vert ; <S2SV_EndBug> sf -> predict [ 0 ] [ 0 ] [ 1 ] = vp9_convolve8_avg_vert ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vp9_convolve8_vert ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vp9_convolve8_avg_vert ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vp9_convolve8 ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vp9_convolve8_avg ; } } else { if ( sf -> y_step_q4 == 16 ) { <S2SV_StartBug> sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve8_horiz ; <S2SV_EndBug> sf -> predict [ 0 ] [ 0 ] [ 1 ] = vp9_convolve8_avg_horiz ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vp9_convolve8 ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vp9_convolve8_avg ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vp9_convolve8_horiz ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vp9_convolve8_avg_horiz ; } else { <S2SV_StartBug> sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve8 ; <S2SV_EndBug> sf -> predict [ 0 ] [ 0 ] [ 1 ] = vp9_convolve8_avg ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vp9_convolve8 ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vp9_convolve8_avg ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vp9_convolve8 ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vp9_convolve8_avg ; } } sf -> predict [ 1 ] [ 1 ] [ 0 ] = vp9_convolve8 ; sf -> predict [ 1 ] [ 1 ] [ 1 ] = vp9_convolve8_avg ; }
","<S2SV_ModStart> this_h ) { # endif <S2SV_ModStart> if ( ! valid_ref_frame_size <S2SV_ModEnd> ( other_w , <S2SV_ModStart> 0 ] = vpx_convolve_copy ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_convolve_avg ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_convolve8_vert ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_convolve8_avg_vert ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_convolve8_horiz ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_convolve8_avg_horiz <S2SV_ModEnd> ; } else <S2SV_ModStart> 0 ] = vpx_scaled_vert ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_vert ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_vert ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_vert ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d <S2SV_ModEnd> ; } } <S2SV_ModStart> 0 ] = vpx_scaled_horiz ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_horiz ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_horiz ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_horiz <S2SV_ModEnd> ; } else <S2SV_ModStart> 0 ] = vpx_scaled_2d ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d ; } } if ( ( sf -> x_step_q4 != 16 ) || ( sf -> y_step_q4 != 16 ) ) { sf -> predict [ 1 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; } else { sf -> predict [ 1 ] [ 1 ] [ 0 ] = vpx_convolve8 ; sf -> predict [ 1 ] [ 1 ] [ 1 ] = vpx_convolve8_avg ; } # if CONFIG_VP9_HIGHBITDEPTH if ( use_highbd ) { if ( sf -> x_step_q4 == 16 ) { if ( sf -> y_step_q4 == 16 ) { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve_copy ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve_avg ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; } else { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; } } else { if ( sf -> y_step_q4 == 16 ) { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; } else { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; } } sf -> highbd_predict [ 1 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; } # endif <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
"
786,"CWE-787 GPMF_ERR IsValidSize ( GPMF_stream * ms , uint32_t size ) { if ( ms ) { <S2SV_StartBug> int32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ; <S2SV_EndBug> if ( nestsize == 0 && ms -> nest_level == 0 ) nestsize = ms -> buffer_size_longs ; if ( size + 2 <= nestsize ) return GPMF_OK ; } return GPMF_ERROR_BAD_STRUCTURE ; }
","<S2SV_ModStart> ms ) { uint32_t <S2SV_ModEnd> nestsize = ( <S2SV_ModStart> nestsize = ( uint32_t <S2SV_ModEnd> ) ms ->
"
787,"CWE-399 int handle_unaligned_access ( insn_size_t instruction , struct pt_regs * regs , struct mem_access * ma , int expected , unsigned long address ) { u_int rm ; int ret , index ; if ( instruction_size ( instruction ) != 2 ) return - EINVAL ; index = ( instruction >> 8 ) & 15 ; rm = regs -> regs [ index ] ; if ( ! expected ) { unaligned_fixups_notify ( current , instruction , regs ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , <S2SV_EndBug> regs , address ) ; } ret = - EFAULT ; switch ( instruction & 0xF000 ) { case 0x0000 : if ( instruction == 0x000B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc = regs -> pr ; } else if ( ( instruction & 0x00FF ) == 0x0023 ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc += rm + 4 ; } else if ( ( instruction & 0x00FF ) == 0x0003 ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc += rm + 4 ; } } else { goto simple ; } break ; case 0x1000 : goto simple ; case 0x2000 : goto simple ; case 0x4000 : if ( ( instruction & 0x00FF ) == 0x002B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc = rm ; } else if ( ( instruction & 0x00FF ) == 0x000B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc = rm ; } } else { goto simple ; } break ; case 0x5000 : goto simple ; case 0x6000 : goto simple ; case 0x8000 : switch ( instruction & 0x0F00 ) { case 0x0100 : goto simple ; case 0x0500 : goto simple ; case 0x0B00 : break ; case 0x0F00 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { # if defined ( CONFIG_CPU_SH4 ) || defined ( CONFIG_SH7705_CACHE_32KB ) if ( ( regs -> sr & 0x00000001 ) != 0 ) regs -> pc += 4 ; else # endif regs -> pc += SH_PC_8BIT_OFFSET ( instruction ) ; } break ; case 0x0900 : break ; case 0x0D00 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { # if defined ( CONFIG_CPU_SH4 ) || defined ( CONFIG_SH7705_CACHE_32KB ) if ( ( regs -> sr & 0x00000001 ) == 0 ) regs -> pc += 4 ; else # endif regs -> pc += SH_PC_8BIT_OFFSET ( instruction ) ; } break ; } break ; case 0xA000 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc += SH_PC_12BIT_OFFSET ( instruction ) ; break ; case 0xB000 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc += SH_PC_12BIT_OFFSET ( instruction ) ; } break ; } return ret ; simple : ret = handle_unaligned_ins ( instruction , regs , ma ) ; if ( ret == 0 ) regs -> pc += instruction_size ( instruction ) ; return ret ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
"
788,"CWE-119 static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_INET_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct ip6t_entry * e = ( struct ip6t_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) ip6t_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { pr_err ( ""iptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n"" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_INET_NUMHOOKS ) ) ; <S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ip6t_entry ) && <S2SV_EndBug> ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && <S2SV_StartBug> t -> verdict < 0 && <S2SV_EndBug> unconditional ( & e -> ipv6 ) ) || visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( ""mark_source_chains:<S2SV_blank>bad<S2SV_blank>"" ""negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_INET_NUMHOOKS ) ; # ifdef DEBUG_IP_FIREWALL_USER if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { duprintf ( ""Back<S2SV_blank>unset<S2SV_blank>"" ""on<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>"" ""rule<S2SV_blank>%u\\n"" , hook , pos ) ; } # endif oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct ip6t_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct ip6t_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct ip6t_entry ) ) { duprintf ( ""mark_source_chains:<S2SV_blank>"" ""bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , newpos ) ; return 0 ; } duprintf ( ""Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n"" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct ip6t_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( ""Finished<S2SV_blank>chain<S2SV_blank>%u\\n"" , hook ) ; } return 1 ; }
","<S2SV_ModStart> if ( ( unconditional ( e <S2SV_ModEnd> ) && ( <S2SV_ModStart> verdict < 0 <S2SV_ModEnd> ) || visited
"
789,"CWE-787 int pdf_load_xrefs ( FILE * fp , pdf_t * pdf ) { int i , ver , is_linear ; long pos , pos_count ; char x , * c , buf [ 256 ] ; c = NULL ; pdf -> n_xrefs = 0 ; fseek ( fp , 0 , SEEK_SET ) ; while ( get_next_eof ( fp ) >= 0 ) ++ pdf -> n_xrefs ; if ( ! pdf -> n_xrefs ) return 0 ; fseek ( fp , 0 , SEEK_SET ) ; <S2SV_StartBug> pdf -> xrefs = calloc ( 1 , sizeof ( xref_t ) * pdf -> n_xrefs ) ; <S2SV_EndBug> ver = 1 ; for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( ( pos = get_next_eof ( fp ) ) < 0 ) break ; pdf -> xrefs [ i ] . version = ver ++ ; pos_count = 0 ; while ( SAFE_F ( fp , ( ( x = fgetc ( fp ) ) != 'f' ) ) ) fseek ( fp , pos - ( ++ pos_count ) , SEEK_SET ) ; if ( pos_count >= sizeof ( buf ) ) { ERR ( ""Failed<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>the<S2SV_blank>startxref<S2SV_blank>token.<S2SV_blank>"" ""This<S2SV_blank>might<S2SV_blank>be<S2SV_blank>a<S2SV_blank>corrupt<S2SV_blank>PDF.\\n"" ) ; return - 1 ; } memset ( buf , 0 , sizeof ( buf ) ) ; SAFE_E ( fread ( buf , 1 , pos_count , fp ) , pos_count , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>startxref.\\n"" ) ; c = buf ; while ( * c == '<S2SV_blank>' || * c == '\\n' || * c == '\\r' ) ++ c ; pdf -> xrefs [ i ] . start = atol ( c ) ; if ( pdf -> xrefs [ i ] . start == 0 ) get_xref_linear_skipped ( fp , & pdf -> xrefs [ i ] ) ; else { pos = ftell ( fp ) ; fseek ( fp , pdf -> xrefs [ i ] . start , SEEK_SET ) ; pdf -> xrefs [ i ] . end = get_next_eof ( fp ) ; fseek ( fp , pos , SEEK_SET ) ; } if ( ! is_valid_xref ( fp , pdf , & pdf -> xrefs [ i ] ) ) { is_linear = pdf -> xrefs [ i ] . is_linear ; memset ( & pdf -> xrefs [ i ] , 0 , sizeof ( xref_t ) ) ; pdf -> xrefs [ i ] . is_linear = is_linear ; rewind ( fp ) ; get_next_eof ( fp ) ; continue ; } load_xref_entries ( fp , & pdf -> xrefs [ i ] ) ; } if ( pdf -> xrefs [ 0 ] . is_linear ) resolve_linearized_pdf ( pdf ) ; load_creator ( fp , pdf ) ; return pdf -> n_xrefs ; }
","<S2SV_ModStart> -> xrefs = safe_calloc ( <S2SV_ModEnd> sizeof ( xref_t
"
790,"CWE-552 static ssize_t _hostsock_recv ( oe_fd_t * sock_ , void * buf , size_t count , int flags ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_errno = 0 ; <S2SV_StartBug> if ( ! sock || ( count && ! buf ) ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( buf ) { if ( oe_memset_s ( buf , count , 0 , count ) != OE_OK ) OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( oe_syscall_recv_ocall ( & ret , sock -> host_fd , buf , count , flags ) != OE_OK ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> done : <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> ! buf ) || count > OE_SSIZE_MAX <S2SV_ModStart> OE_EINVAL ) ; if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
"
791,"CWE-416 void inet6_destroy_sock ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sk_buff * skb ; struct ipv6_txoptions * opt ; skb = xchg ( & np -> pktoptions , NULL ) ; if ( skb ) kfree_skb ( skb ) ; skb = xchg ( & np -> rxpmtu , NULL ) ; if ( skb ) kfree_skb ( skb ) ; fl6_free_socklist ( sk ) ; <S2SV_StartBug> opt = xchg ( & np -> opt , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt ) <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> = xchg ( ( __force struct ipv6_txoptions * * ) <S2SV_ModStart> ( opt ) { atomic_sub ( <S2SV_ModEnd> opt -> tot_len <S2SV_ModStart> opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt <S2SV_ModStart> ) ; } }
"
792,"CWE-399 int CMS_verify ( CMS_ContentInfo * cms , STACK_OF ( X509 ) * certs , X509_STORE * store , BIO * dcont , BIO * out , unsigned int flags ) { CMS_SignerInfo * si ; STACK_OF ( CMS_SignerInfo ) * sinfos ; STACK_OF ( X509 ) * cms_certs = NULL ; STACK_OF ( X509_CRL ) * crls = NULL ; X509 * signer ; int i , scount = 0 , ret = 0 ; <S2SV_StartBug> BIO * cmsbio = NULL , * tmpin = NULL ; <S2SV_EndBug> if ( ! dcont && ! check_content ( cms ) ) return 0 ; sinfos = CMS_get0_SignerInfos ( cms ) ; if ( sk_CMS_SignerInfo_num ( sinfos ) <= 0 ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_NO_SIGNERS ) ; goto err ; } for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; CMS_SignerInfo_get0_algs ( si , NULL , & signer , NULL , NULL ) ; if ( signer ) scount ++ ; } if ( scount != sk_CMS_SignerInfo_num ( sinfos ) ) scount += CMS_set1_signers_certs ( cms , certs , flags ) ; if ( scount != sk_CMS_SignerInfo_num ( sinfos ) ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SIGNER_CERTIFICATE_NOT_FOUND ) ; goto err ; } if ( ! ( flags & CMS_NO_SIGNER_CERT_VERIFY ) ) { cms_certs = CMS_get1_certs ( cms ) ; if ( ! ( flags & CMS_NOCRL ) ) crls = CMS_get1_crls ( cms ) ; for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; if ( ! cms_signerinfo_verify_cert ( si , store , cms_certs , crls , flags ) ) goto err ; } } if ( ! ( flags & CMS_NO_ATTR_VERIFY ) ) { for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; if ( CMS_signed_get_attr_count ( si ) < 0 ) continue ; if ( CMS_SignerInfo_verify ( si ) <= 0 ) goto err ; } } if ( dcont && ( BIO_method_type ( dcont ) == BIO_TYPE_MEM ) ) { char * ptr ; long len ; len = BIO_get_mem_data ( dcont , & ptr ) ; tmpin = BIO_new_mem_buf ( ptr , len ) ; if ( tmpin == NULL ) { CMSerr ( CMS_F_CMS_VERIFY , ERR_R_MALLOC_FAILURE ) ; return 0 ; } } else tmpin = dcont ; <S2SV_StartBug> cmsbio = CMS_dataInit ( cms , tmpin ) ; <S2SV_EndBug> if ( ! cmsbio ) goto err ; if ( ! cms_copy_content ( out , cmsbio , flags ) ) <S2SV_StartBug> goto err ; <S2SV_EndBug> if ( ! ( flags & CMS_NO_CONTENT_VERIFY ) ) { for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; if ( CMS_SignerInfo_verify_content ( si , cmsbio ) <= 0 ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_CONTENT_VERIFY_ERROR ) ; goto err ; } } } ret = 1 ; err : <S2SV_StartBug> if ( dcont && ( tmpin == dcont ) ) <S2SV_EndBug> do_free_upto ( cmsbio , dcont ) ; else BIO_free_all ( cmsbio ) ; <S2SV_StartBug> if ( cms_certs ) <S2SV_EndBug> sk_X509_pop_free ( cms_certs , X509_free ) ; if ( crls ) sk_X509_CRL_pop_free ( crls , X509_CRL_free ) ; return ret ; }
","<S2SV_ModStart> , * tmpin = NULL , * tmpout <S2SV_ModStart> = dcont ; if ( ! ( flags & SMIME_BINARY ) && dcont ) { tmpout = cms_get_text_bio ( out , flags ) ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } <S2SV_ModStart> ( cms , tmpout ) ; if ( ! cmsbio ) goto err ; SMIME_crlf_copy ( dcont , cmsbio , flags & ~ SMIME_TEXT ) ; if ( flags & CMS_TEXT ) { if ( ! SMIME_text ( tmpout , out ) ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SMIME_TEXT_ERROR ) ; goto err ; } } } else { cmsbio = CMS_dataInit ( cms , <S2SV_ModStart> goto err ; } <S2SV_ModStart> : if ( ! ( flags & SMIME_BINARY ) && dcont ) { do_free_upto ( cmsbio , tmpout ) ; if ( tmpin != dcont ) BIO_free ( tmpin ) ; } else { if ( <S2SV_ModStart> cmsbio ) ; } if ( tmpout && out != tmpout ) BIO_free_all ( tmpout ) ;
"
793,"CWE-416 static int do_ipv6_getsockopt ( struct sock * sk , int level , int optname , char __user * optval , int __user * optlen , unsigned int flags ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; int len ; int val ; if ( ip6_mroute_opt ( optname ) ) return ip6_mroute_getsockopt ( sk , optname , optval , optlen ) ; if ( get_user ( len , optlen ) ) return - EFAULT ; switch ( optname ) { case IPV6_ADDRFORM : if ( sk -> sk_protocol != IPPROTO_UDP && sk -> sk_protocol != IPPROTO_UDPLITE && sk -> sk_protocol != IPPROTO_TCP ) return - ENOPROTOOPT ; if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ; val = sk -> sk_family ; break ; case MCAST_MSFILTER : { struct group_filter gsf ; int err ; if ( len < GROUP_FILTER_SIZE ( 0 ) ) return - EINVAL ; if ( copy_from_user ( & gsf , optval , GROUP_FILTER_SIZE ( 0 ) ) ) return - EFAULT ; if ( gsf . gf_group . ss_family != AF_INET6 ) return - EADDRNOTAVAIL ; lock_sock ( sk ) ; err = ip6_mc_msfget ( sk , & gsf , ( struct group_filter __user * ) optval , optlen ) ; release_sock ( sk ) ; return err ; } case IPV6_2292PKTOPTIONS : { struct msghdr msg ; struct sk_buff * skb ; if ( sk -> sk_type != SOCK_STREAM ) return - ENOPROTOOPT ; msg . msg_control = optval ; msg . msg_controllen = len ; msg . msg_flags = flags ; lock_sock ( sk ) ; skb = np -> pktoptions ; if ( skb ) ip6_datagram_recv_ctl ( sk , & msg , skb ) ; release_sock ( sk ) ; if ( ! skb ) { if ( np -> rxopt . bits . rxinfo ) { struct in6_pktinfo src_info ; src_info . ipi6_ifindex = np -> mcast_oif ? np -> mcast_oif : np -> sticky_pktinfo . ipi6_ifindex ; src_info . ipi6_addr = np -> mcast_oif ? sk -> sk_v6_daddr : np -> sticky_pktinfo . ipi6_addr ; put_cmsg ( & msg , SOL_IPV6 , IPV6_PKTINFO , sizeof ( src_info ) , & src_info ) ; } if ( np -> rxopt . bits . rxhlim ) { int hlim = np -> mcast_hops ; put_cmsg ( & msg , SOL_IPV6 , IPV6_HOPLIMIT , sizeof ( hlim ) , & hlim ) ; } if ( np -> rxopt . bits . rxtclass ) { int tclass = ( int ) ip6_tclass ( np -> rcv_flowinfo ) ; put_cmsg ( & msg , SOL_IPV6 , IPV6_TCLASS , sizeof ( tclass ) , & tclass ) ; } if ( np -> rxopt . bits . rxoinfo ) { struct in6_pktinfo src_info ; src_info . ipi6_ifindex = np -> mcast_oif ? np -> mcast_oif : np -> sticky_pktinfo . ipi6_ifindex ; src_info . ipi6_addr = np -> mcast_oif ? sk -> sk_v6_daddr : np -> sticky_pktinfo . ipi6_addr ; put_cmsg ( & msg , SOL_IPV6 , IPV6_2292PKTINFO , sizeof ( src_info ) , & src_info ) ; } if ( np -> rxopt . bits . rxohlim ) { int hlim = np -> mcast_hops ; put_cmsg ( & msg , SOL_IPV6 , IPV6_2292HOPLIMIT , sizeof ( hlim ) , & hlim ) ; } if ( np -> rxopt . bits . rxflow ) { __be32 flowinfo = np -> rcv_flowinfo ; put_cmsg ( & msg , SOL_IPV6 , IPV6_FLOWINFO , sizeof ( flowinfo ) , & flowinfo ) ; } } len -= msg . msg_controllen ; return put_user ( len , optlen ) ; } case IPV6_MTU : { struct dst_entry * dst ; val = 0 ; rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; if ( dst ) val = dst_mtu ( dst ) ; rcu_read_unlock ( ) ; if ( ! val ) return - ENOTCONN ; break ; } case IPV6_V6ONLY : val = sk -> sk_ipv6only ; break ; case IPV6_RECVPKTINFO : val = np -> rxopt . bits . rxinfo ; break ; case IPV6_2292PKTINFO : val = np -> rxopt . bits . rxoinfo ; break ; case IPV6_RECVHOPLIMIT : val = np -> rxopt . bits . rxhlim ; break ; case IPV6_2292HOPLIMIT : val = np -> rxopt . bits . rxohlim ; break ; case IPV6_RECVRTHDR : val = np -> rxopt . bits . srcrt ; break ; case IPV6_2292RTHDR : val = np -> rxopt . bits . osrcrt ; break ; case IPV6_HOPOPTS : case IPV6_RTHDRDSTOPTS : case IPV6_RTHDR : case IPV6_DSTOPTS : { <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> len = ipv6_getsockopt_sticky ( sk , np -> opt , <S2SV_EndBug> optname , optval , len ) ; release_sock ( sk ) ; if ( len < 0 ) return len ; return put_user ( len , optlen ) ; } case IPV6_RECVHOPOPTS : val = np -> rxopt . bits . hopopts ; break ; case IPV6_2292HOPOPTS : val = np -> rxopt . bits . ohopopts ; break ; case IPV6_RECVDSTOPTS : val = np -> rxopt . bits . dstopts ; break ; case IPV6_2292DSTOPTS : val = np -> rxopt . bits . odstopts ; break ; case IPV6_TCLASS : val = np -> tclass ; break ; case IPV6_RECVTCLASS : val = np -> rxopt . bits . rxtclass ; break ; case IPV6_FLOWINFO : val = np -> rxopt . bits . rxflow ; break ; case IPV6_RECVPATHMTU : val = np -> rxopt . bits . rxpmtu ; break ; case IPV6_PATHMTU : { struct dst_entry * dst ; struct ip6_mtuinfo mtuinfo ; if ( len < sizeof ( mtuinfo ) ) return - EINVAL ; len = sizeof ( mtuinfo ) ; memset ( & mtuinfo , 0 , sizeof ( mtuinfo ) ) ; rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; if ( dst ) mtuinfo . ip6m_mtu = dst_mtu ( dst ) ; rcu_read_unlock ( ) ; if ( ! mtuinfo . ip6m_mtu ) return - ENOTCONN ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & mtuinfo , len ) ) return - EFAULT ; return 0 ; } case IPV6_TRANSPARENT : val = inet_sk ( sk ) -> transparent ; break ; case IPV6_RECVORIGDSTADDR : val = np -> rxopt . bits . rxorigdstaddr ; break ; case IPV6_UNICAST_HOPS : case IPV6_MULTICAST_HOPS : { struct dst_entry * dst ; if ( optname == IPV6_UNICAST_HOPS ) val = np -> hop_limit ; else val = np -> mcast_hops ; if ( val < 0 ) { rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; if ( dst ) val = ip6_dst_hoplimit ( dst ) ; rcu_read_unlock ( ) ; } if ( val < 0 ) val = sock_net ( sk ) -> ipv6 . devconf_all -> hop_limit ; break ; } case IPV6_MULTICAST_LOOP : val = np -> mc_loop ; break ; case IPV6_MULTICAST_IF : val = np -> mcast_oif ; break ; case IPV6_UNICAST_IF : val = ( __force int ) htonl ( ( __u32 ) np -> ucast_oif ) ; break ; case IPV6_MTU_DISCOVER : val = np -> pmtudisc ; break ; case IPV6_RECVERR : val = np -> recverr ; break ; case IPV6_FLOWINFO_SEND : val = np -> sndflow ; break ; case IPV6_FLOWLABEL_MGR : { struct in6_flowlabel_req freq ; int flags ; if ( len < sizeof ( freq ) ) return - EINVAL ; if ( copy_from_user ( & freq , optval , sizeof ( freq ) ) ) return - EFAULT ; if ( freq . flr_action != IPV6_FL_A_GET ) return - EINVAL ; len = sizeof ( freq ) ; flags = freq . flr_flags ; memset ( & freq , 0 , sizeof ( freq ) ) ; val = ipv6_flowlabel_opt_get ( sk , & freq , flags ) ; if ( val < 0 ) return val ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & freq , len ) ) return - EFAULT ; return 0 ; } case IPV6_ADDR_PREFERENCES : val = 0 ; if ( np -> srcprefs & IPV6_PREFER_SRC_TMP ) val |= IPV6_PREFER_SRC_TMP ; else if ( np -> srcprefs & IPV6_PREFER_SRC_PUBLIC ) val |= IPV6_PREFER_SRC_PUBLIC ; else { val |= IPV6_PREFER_SRC_PUBTMP_DEFAULT ; } if ( np -> srcprefs & IPV6_PREFER_SRC_COA ) val |= IPV6_PREFER_SRC_COA ; else val |= IPV6_PREFER_SRC_HOME ; break ; case IPV6_MINHOPCOUNT : val = np -> min_hopcount ; break ; case IPV6_DONTFRAG : val = np -> dontfrag ; break ; case IPV6_AUTOFLOWLABEL : val = np -> autoflowlabel ; break ; default : return - ENOPROTOOPT ; } len = min_t ( unsigned int , sizeof ( int ) , len ) ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & val , len ) ) return - EFAULT ; return 0 ; }
","<S2SV_ModStart> IPV6_DSTOPTS : { struct ipv6_txoptions * opt ; <S2SV_ModStart> sk ) ; opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> ( sk , <S2SV_ModEnd> opt , optname
"
794,"CWE-119 static __exit void sctp_exit ( void ) { sctp_v6_del_protocol ( ) ; sctp_v4_del_protocol ( ) ; <S2SV_StartBug> unregister_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> sctp_v6_protosw_exit ( ) ; <S2SV_StartBug> sctp_v4_protosw_exit ( ) ; <S2SV_EndBug> sctp_v6_pf_exit ( ) ; sctp_v4_pf_exit ( ) ; sctp_sysctl_unregister ( ) ; free_pages ( ( unsigned long ) sctp_assoc_hashtable , get_order ( sctp_assoc_hashsize * sizeof ( struct sctp_hashbucket ) ) ) ; kfree ( sctp_ep_hashtable ) ; free_pages ( ( unsigned long ) sctp_port_hashtable , get_order ( sctp_port_hashsize * sizeof ( struct sctp_bind_hashbucket ) ) ) ; percpu_counter_destroy ( & sctp_sockets_allocated ) ; rcu_barrier ( ) ; kmem_cache_destroy ( sctp_chunk_cachep ) ; kmem_cache_destroy ( sctp_bucket_cachep ) ; }
","<S2SV_ModStart> unregister_pernet_subsys ( & sctp_ctrlsock_ops <S2SV_ModEnd> ) ; sctp_v6_protosw_exit <S2SV_ModStart> ; sctp_v4_protosw_exit ( ) ; unregister_pernet_subsys ( & sctp_defaults_ops
"
795,"CWE-284 void _modinit ( module_t * m ) { service_named_bind_command ( ""chanserv"" , & cs_flags ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> cs_flags ) ; add_bool_conf_item ( ""ANOPE_FLAGS_COMPAT"" , & chansvs . me -> conf_table , 0 , & anope_flags_compat , true ) ; hook_add_event ( ""nick_can_register"" ) ; hook_add_nick_can_register ( check_registration_keywords ) ; hook_add_event ( ""user_can_register"" ) ; hook_add_user_can_register ( check_registration_keywords ) ;
"
796,"CWE-399 static int masq_inet_event ( struct notifier_block * this , unsigned long event , void * ptr ) { <S2SV_StartBug> struct net_device * dev = ( ( struct in_ifaddr * ) ptr ) -> ifa_dev -> dev ; <S2SV_EndBug> struct netdev_notifier_info info ; <S2SV_StartBug> netdev_notifier_info_init ( & info , dev ) ; <S2SV_EndBug> return masq_device_event ( this , event , & info ) ; }
","<S2SV_ModStart> ) { struct in_device * idev <S2SV_ModEnd> = ( ( <S2SV_ModStart> ) -> ifa_dev <S2SV_ModEnd> ; struct netdev_notifier_info <S2SV_ModStart> netdev_notifier_info info ; if ( idev -> dead ) return NOTIFY_DONE ; <S2SV_ModStart> & info , idev ->
"
797,"CWE-362 void flush_tlb_mm_range ( struct mm_struct * mm , unsigned long start , unsigned long end , unsigned long vmflag ) { unsigned long addr ; unsigned long base_pages_to_flush = TLB_FLUSH_ALL ; preempt_disable ( ) ; <S2SV_StartBug> if ( current -> active_mm != mm ) <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( ! current -> mm ) { leave_mm ( smp_processor_id ( ) ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } if ( ( end != TLB_FLUSH_ALL ) && ! ( vmflag & VM_HUGETLB ) ) base_pages_to_flush = ( end - start ) >> PAGE_SHIFT ; if ( base_pages_to_flush > tlb_single_page_flush_ceiling ) { base_pages_to_flush = TLB_FLUSH_ALL ; count_vm_tlb_event ( NR_TLB_LOCAL_FLUSH_ALL ) ; local_flush_tlb ( ) ; } else { for ( addr = start ; addr < end ; addr += PAGE_SIZE ) { count_vm_tlb_event ( NR_TLB_LOCAL_FLUSH_ONE ) ; __flush_tlb_single ( addr ) ; } } trace_tlb_flush ( TLB_LOCAL_MM_SHOOTDOWN , base_pages_to_flush ) ; out : if ( base_pages_to_flush == TLB_FLUSH_ALL ) { start = 0UL ; end = TLB_FLUSH_ALL ; } if ( cpumask_any_but ( mm_cpumask ( mm ) , smp_processor_id ( ) ) < nr_cpu_ids ) flush_tlb_others ( mm_cpumask ( mm ) , mm , start , end ) ; preempt_enable ( ) ; }
","<S2SV_ModStart> != mm ) { smp_mb ( ) ; <S2SV_ModStart> goto out ; } <S2SV_ModStart> ) ) ; smp_mb ( ) ;
"
798,"CWE-119 <S2SV_StartBug> static void show_psnr ( struct stream_state * stream ) { <S2SV_EndBug> int i ; double ovpsnr ; if ( ! stream -> psnr_count ) return ; fprintf ( stderr , ""Stream<S2SV_blank>%d<S2SV_blank>PSNR<S2SV_blank>(Overall/Avg/Y/U/V)"" , stream -> index ) ; <S2SV_StartBug> ovpsnr = sse_to_psnr ( ( double ) stream -> psnr_samples_total , 255.0 , <S2SV_EndBug> ( double ) stream -> psnr_sse_total ) ; fprintf ( stderr , ""<S2SV_blank>%.3f"" , ovpsnr ) ; for ( i = 0 ; i < 4 ; i ++ ) { fprintf ( stderr , ""<S2SV_blank>%.3f"" , stream -> psnr_totals [ i ] / stream -> psnr_count ) ; } fprintf ( stderr , ""\\n"" ) ; }
","<S2SV_ModStart> stream_state * stream , double peak <S2SV_ModStart> -> psnr_samples_total , peak <S2SV_ModEnd> , ( double
"
799,"CWE-119 static char * get_pid_environ_val ( pid_t pid , char * val ) { <S2SV_StartBug> char temp [ 500 ] ; <S2SV_EndBug> int i = 0 ; int foundit = 0 ; FILE * fp ; sprintf ( temp , ""/proc/%d/environ"" , pid ) ; fp = fopen ( temp , ""r"" ) ; if ( fp == NULL ) return NULL ; for ( ; ; ) { <S2SV_StartBug> temp [ i ] = fgetc ( fp ) ; <S2SV_EndBug> if ( foundit == 1 && ( temp [ i ] == 0 || temp [ i ] == '\\0' || temp [ i ] == EOF ) ) { char * ret ; temp [ i ] = 0 ; ret = malloc ( strlen ( temp ) + 10 ) ; sprintf ( ret , ""%s"" , temp ) ; fclose ( fp ) ; return ret ; } switch ( temp [ i ] ) { case EOF : fclose ( fp ) ; return NULL ; case '=' : temp [ i ] = 0 ; if ( ! strcmp ( temp , val ) ) { foundit = 1 ; } i = 0 ; break ; case '\\0' : i = 0 ; break ; default : i ++ ; } } }
","<S2SV_ModStart> val ) { int temp_size = 500 ; char * temp = malloc ( temp_size ) <S2SV_ModEnd> ; int i <S2SV_ModStart> ; ) { if ( i >= temp_size ) { temp_size *= 2 ; temp = realloc ( temp , temp_size ) ; }
"
800,"CWE-362 static void smp_task_done ( struct sas_task * task ) { <S2SV_StartBug> if ( ! del_timer ( & task -> slow_task -> timer ) ) <S2SV_EndBug> return ; complete ( & task -> slow_task -> completion ) ; }
","<S2SV_ModStart> task ) { <S2SV_ModEnd> del_timer ( & <S2SV_ModStart> -> timer ) <S2SV_ModEnd> ; complete (
"
801,"CWE-787 void pdf_summarize ( FILE * fp , const pdf_t * pdf , const char * name , pdf_flag_t flags ) { int i , j , page , n_versions , n_entries ; FILE * dst , * out ; char * dst_name , * c ; dst = NULL ; dst_name = NULL ; if ( name ) { <S2SV_StartBug> dst_name = malloc ( strlen ( name ) * 2 + 16 ) ; <S2SV_EndBug> sprintf ( dst_name , ""%s/%s"" , name , name ) ; if ( ( c = strrchr ( dst_name , '.' ) ) && ( strncmp ( c , "".pdf"" , 4 ) == 0 ) ) * c = '\\0' ; strcat ( dst_name , "".summary"" ) ; if ( ! ( dst = fopen ( dst_name , ""w"" ) ) ) { ERR ( ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>writing\\n"" , dst_name ) ; return ; } } out = ( dst ) ? dst : stdout ; n_versions = pdf -> n_xrefs ; if ( n_versions && pdf -> xrefs [ 0 ] . is_linear ) -- n_versions ; for ( i = 1 ; i < pdf -> n_xrefs ; ++ i ) if ( pdf -> xrefs [ i ] . end == 0 ) -- n_versions ; if ( ! pdf -> n_xrefs || ( ! n_versions && pdf -> xrefs [ 0 ] . is_linear ) ) n_versions = 1 ; n_entries = 0 ; for ( i = 0 ; ! ( const int ) pdf -> has_xref_streams && i < pdf -> n_xrefs ; i ++ ) { if ( flags & PDF_FLAG_QUIET ) continue ; for ( j = 0 ; j < pdf -> xrefs [ i ] . n_entries ; j ++ ) { ++ n_entries ; fprintf ( out , ""%s:<S2SV_blank>--%c--<S2SV_blank>Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>Object<S2SV_blank>%d<S2SV_blank>(%s)"" , pdf -> name , pdf_get_object_status ( pdf , i , j ) , pdf -> xrefs [ i ] . version , pdf -> xrefs [ i ] . entries [ j ] . obj_id , get_type ( fp , pdf -> xrefs [ i ] . entries [ j ] . obj_id , & pdf -> xrefs [ i ] ) ) ; if ( 0 ) fprintf ( out , ""<S2SV_blank>Page(%d)\\n"" , page ) ; else fprintf ( out , ""\\n"" ) ; } } if ( ! ( flags & PDF_FLAG_QUIET ) ) { if ( pdf -> has_xref_streams || ! n_entries ) fprintf ( out , ""%s:<S2SV_blank>This<S2SV_blank>PDF<S2SV_blank>contains<S2SV_blank>potential<S2SV_blank>cross<S2SV_blank>reference<S2SV_blank>streams.\\n"" ""%s:<S2SV_blank>An<S2SV_blank>object<S2SV_blank>summary<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available.\\n"" , pdf -> name , pdf -> name ) ; fprintf ( out , ""----------<S2SV_blank>%s<S2SV_blank>----------\\n"" ""Versions:<S2SV_blank>%d\\n"" , pdf -> name , n_versions ) ; if ( ! pdf -> has_xref_streams ) for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( pdf -> xrefs [ i ] . is_linear ) continue ; n_entries = pdf -> xrefs [ i ] . n_entries ; if ( pdf -> xrefs [ 0 ] . is_linear ) n_entries += pdf -> xrefs [ 0 ] . n_entries ; if ( pdf -> xrefs [ i ] . version && n_entries ) fprintf ( out , ""Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>%d<S2SV_blank>objects\\n"" , pdf -> xrefs [ i ] . version , n_entries ) ; } } else fprintf ( out , ""%s:<S2SV_blank>%d\\n"" , pdf -> name , n_versions ) ; if ( dst ) { fclose ( dst ) ; free ( dst_name ) ; } }
","<S2SV_ModStart> { dst_name = safe_calloc <S2SV_ModEnd> ( strlen (
"
802,"CWE-617 int lldp_decode ( struct lldpd * cfg , char * frame , int s , struct lldpd_hardware * hardware , struct lldpd_chassis * * newchassis , struct lldpd_port * * newport ) { struct lldpd_chassis * chassis ; struct lldpd_port * port ; const char lldpaddr [ ] = LLDP_MULTICAST_ADDR ; const char dot1 [ ] = LLDP_TLV_ORG_DOT1 ; const char dot3 [ ] = LLDP_TLV_ORG_DOT3 ; const char med [ ] = LLDP_TLV_ORG_MED ; const char dcbx [ ] = LLDP_TLV_ORG_DCBX ; unsigned char orgid [ 3 ] ; int length , gotend = 0 , ttl_received = 0 ; int tlv_size , tlv_type , tlv_subtype ; u_int8_t * pos , * tlv ; char * b ; # ifdef ENABLE_DOT1 struct lldpd_vlan * vlan = NULL ; int vlan_len ; struct lldpd_ppvid * ppvid ; struct lldpd_pi * pi = NULL ; # endif struct lldpd_mgmt * mgmt ; int af ; u_int8_t addr_str_length , addr_str_buffer [ 32 ] ; u_int8_t addr_family , addr_length , * addr_ptr , iface_subtype ; u_int32_t iface_number , iface ; # ifdef ENABLE_CUSTOM struct lldpd_custom * custom = NULL ; # endif log_debug ( ""lldp"" , ""receive<S2SV_blank>LLDP<S2SV_blank>PDU<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; if ( ( chassis = calloc ( 1 , sizeof ( struct lldpd_chassis ) ) ) == NULL ) { log_warn ( ""lldp"" , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>remote<S2SV_blank>chassis"" ) ; return - 1 ; } TAILQ_INIT ( & chassis -> c_mgmt ) ; if ( ( port = calloc ( 1 , sizeof ( struct lldpd_port ) ) ) == NULL ) { log_warn ( ""lldp"" , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>remote<S2SV_blank>port"" ) ; free ( chassis ) ; return - 1 ; } # ifdef ENABLE_DOT1 TAILQ_INIT ( & port -> p_vlans ) ; TAILQ_INIT ( & port -> p_ppvids ) ; TAILQ_INIT ( & port -> p_pids ) ; # endif # ifdef ENABLE_CUSTOM TAILQ_INIT ( & port -> p_custom_list ) ; # endif length = s ; pos = ( u_int8_t * ) frame ; if ( length < 2 * ETHER_ADDR_LEN + sizeof ( u_int16_t ) ) { log_warnx ( ""lldp"" , ""too<S2SV_blank>short<S2SV_blank>frame<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } if ( PEEK_CMP ( lldpaddr , ETHER_ADDR_LEN ) != 0 ) { log_info ( ""lldp"" , ""frame<S2SV_blank>not<S2SV_blank>targeted<S2SV_blank>at<S2SV_blank>LLDP<S2SV_blank>multicast<S2SV_blank>address<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_DISCARD ( ETHER_ADDR_LEN ) ; if ( PEEK_UINT16 != ETHERTYPE_LLDP ) { log_info ( ""lldp"" , ""non<S2SV_blank>LLDP<S2SV_blank>frame<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } while ( length && ( ! gotend ) ) { if ( length < 2 ) { log_warnx ( ""lldp"" , ""tlv<S2SV_blank>header<S2SV_blank>too<S2SV_blank>short<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } tlv_size = PEEK_UINT16 ; tlv_type = tlv_size >> 9 ; tlv_size = tlv_size & 0x1ff ; ( void ) PEEK_SAVE ( tlv ) ; if ( length < tlv_size ) { log_warnx ( ""lldp"" , ""frame<S2SV_blank>too<S2SV_blank>short<S2SV_blank>for<S2SV_blank>tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } switch ( tlv_type ) { case LLDP_TLV_END : if ( tlv_size != 0 ) { log_warnx ( ""lldp"" , ""lldp<S2SV_blank>end<S2SV_blank>received<S2SV_blank>with<S2SV_blank>size<S2SV_blank>not<S2SV_blank>null<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } if ( length ) log_debug ( ""lldp"" , ""extra<S2SV_blank>data<S2SV_blank>after<S2SV_blank>lldp<S2SV_blank>end<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; gotend = 1 ; break ; case LLDP_TLV_CHASSIS_ID : case LLDP_TLV_PORT_ID : CHECK_TLV_SIZE ( 2 , ""Port<S2SV_blank>Id"" ) ; tlv_subtype = PEEK_UINT8 ; if ( ( tlv_subtype == 0 ) || ( tlv_subtype > 7 ) ) { log_warnx ( ""lldp"" , ""unknown<S2SV_blank>subtype<S2SV_blank>for<S2SV_blank>tlv<S2SV_blank>id<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } if ( ( b = ( char * ) calloc ( 1 , tlv_size - 1 ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>id<S2SV_blank>tlv<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_BYTES ( b , tlv_size - 1 ) ; if ( tlv_type == LLDP_TLV_PORT_ID ) { port -> p_id_subtype = tlv_subtype ; port -> p_id = b ; port -> p_id_len = tlv_size - 1 ; } else { chassis -> c_id_subtype = tlv_subtype ; chassis -> c_id = b ; chassis -> c_id_len = tlv_size - 1 ; } break ; case LLDP_TLV_TTL : CHECK_TLV_SIZE ( 2 , ""TTL"" ) ; chassis -> c_ttl = PEEK_UINT16 ; ttl_received = 1 ; break ; case LLDP_TLV_PORT_DESCR : case LLDP_TLV_SYSTEM_NAME : case LLDP_TLV_SYSTEM_DESCR : if ( tlv_size < 1 ) { log_debug ( ""lldp"" , ""empty<S2SV_blank>tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; break ; } if ( ( b = ( char * ) calloc ( 1 , tlv_size + 1 ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>string<S2SV_blank>tlv<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_BYTES ( b , tlv_size ) ; if ( tlv_type == LLDP_TLV_PORT_DESCR ) port -> p_descr = b ; else if ( tlv_type == LLDP_TLV_SYSTEM_NAME ) chassis -> c_name = b ; else chassis -> c_descr = b ; break ; case LLDP_TLV_SYSTEM_CAP : CHECK_TLV_SIZE ( 4 , ""System<S2SV_blank>capabilities"" ) ; chassis -> c_cap_available = PEEK_UINT16 ; chassis -> c_cap_enabled = PEEK_UINT16 ; break ; case LLDP_TLV_MGMT_ADDR : CHECK_TLV_SIZE ( 1 , ""Management<S2SV_blank>address"" ) ; addr_str_length = PEEK_UINT8 ; if ( addr_str_length > sizeof ( addr_str_buffer ) ) { log_warnx ( ""lldp"" , ""too<S2SV_blank>large<S2SV_blank>management<S2SV_blank>address<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } CHECK_TLV_SIZE ( 1 + addr_str_length , ""Management<S2SV_blank>address"" ) ; PEEK_BYTES ( addr_str_buffer , addr_str_length ) ; addr_length = addr_str_length - 1 ; addr_family = addr_str_buffer [ 0 ] ; addr_ptr = & addr_str_buffer [ 1 ] ; CHECK_TLV_SIZE ( 1 + addr_str_length + 5 , ""Management<S2SV_blank>address"" ) ; iface_subtype = PEEK_UINT8 ; iface_number = PEEK_UINT32 ; af = lldpd_af_from_lldp_proto ( addr_family ) ; if ( af == LLDPD_AF_UNSPEC ) break ; if ( iface_subtype == LLDP_MGMT_IFACE_IFINDEX ) iface = iface_number ; else iface = 0 ; mgmt = lldpd_alloc_mgmt ( af , addr_ptr , addr_length , iface ) ; if ( mgmt == NULL ) { <S2SV_StartBug> assert ( errno == ENOMEM ) ; <S2SV_EndBug> log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>"" <S2SV_StartBug> ""for<S2SV_blank>management<S2SV_blank>address"" ) ; <S2SV_EndBug> goto malformed ; } TAILQ_INSERT_TAIL ( & chassis -> c_mgmt , mgmt , m_entries ) ; break ; case LLDP_TLV_ORG : CHECK_TLV_SIZE ( 1 + ( int ) sizeof ( orgid ) , ""Organisational"" ) ; PEEK_BYTES ( orgid , sizeof ( orgid ) ) ; tlv_subtype = PEEK_UINT8 ; if ( memcmp ( dot1 , orgid , sizeof ( orgid ) ) == 0 ) { # ifndef ENABLE_DOT1 hardware -> h_rx_unrecognized_cnt ++ ; # else switch ( tlv_subtype ) { case LLDP_TLV_DOT1_VLANNAME : CHECK_TLV_SIZE ( 7 , ""VLAN"" ) ; if ( ( vlan = ( struct lldpd_vlan * ) calloc ( 1 , sizeof ( struct lldpd_vlan ) ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>vlan<S2SV_blank>"" ""structure<S2SV_blank>for<S2SV_blank>"" ""tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } vlan -> v_vid = PEEK_UINT16 ; vlan_len = PEEK_UINT8 ; CHECK_TLV_SIZE ( 7 + vlan_len , ""VLAN"" ) ; if ( ( vlan -> v_name = ( char * ) calloc ( 1 , vlan_len + 1 ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>vlan<S2SV_blank>name<S2SV_blank>for<S2SV_blank>"" ""tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_BYTES ( vlan -> v_name , vlan_len ) ; TAILQ_INSERT_TAIL ( & port -> p_vlans , vlan , v_entries ) ; vlan = NULL ; break ; case LLDP_TLV_DOT1_PVID : CHECK_TLV_SIZE ( 6 , ""PVID"" ) ; port -> p_pvid = PEEK_UINT16 ; break ; case LLDP_TLV_DOT1_PPVID : CHECK_TLV_SIZE ( 7 , ""PPVID"" ) ; if ( ( ppvid = ( struct lldpd_ppvid * ) calloc ( 1 , sizeof ( struct lldpd_ppvid ) ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>ppvid<S2SV_blank>"" ""structure<S2SV_blank>for<S2SV_blank>"" ""tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } ppvid -> p_cap_status = PEEK_UINT8 ; ppvid -> p_ppvid = PEEK_UINT16 ; TAILQ_INSERT_TAIL ( & port -> p_ppvids , ppvid , p_entries ) ; break ; case LLDP_TLV_DOT1_PI : CHECK_TLV_SIZE ( 5 , ""PI"" ) ; if ( ( pi = ( struct lldpd_pi * ) calloc ( 1 , sizeof ( struct lldpd_pi ) ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>PI<S2SV_blank>"" ""structure<S2SV_blank>for<S2SV_blank>"" ""tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } pi -> p_pi_len = PEEK_UINT8 ; CHECK_TLV_SIZE ( 5 + pi -> p_pi_len , ""PI"" ) ; if ( ( pi -> p_pi = ( char * ) calloc ( 1 , pi -> p_pi_len ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>pid<S2SV_blank>name<S2SV_blank>for<S2SV_blank>"" ""tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_BYTES ( pi -> p_pi , pi -> p_pi_len ) ; TAILQ_INSERT_TAIL ( & port -> p_pids , pi , p_entries ) ; pi = NULL ; break ; default : hardware -> h_rx_unrecognized_cnt ++ ; } # endif } else if ( memcmp ( dot3 , orgid , sizeof ( orgid ) ) == 0 ) { # ifndef ENABLE_DOT3 hardware -> h_rx_unrecognized_cnt ++ ; # else switch ( tlv_subtype ) { case LLDP_TLV_DOT3_MAC : CHECK_TLV_SIZE ( 9 , ""MAC/PHY"" ) ; port -> p_macphy . autoneg_support = PEEK_UINT8 ; port -> p_macphy . autoneg_enabled = ( port -> p_macphy . autoneg_support & 0x2 ) >> 1 ; port -> p_macphy . autoneg_support = port -> p_macphy . autoneg_support & 0x1 ; port -> p_macphy . autoneg_advertised = PEEK_UINT16 ; port -> p_macphy . mau_type = PEEK_UINT16 ; break ; case LLDP_TLV_DOT3_LA : CHECK_TLV_SIZE ( 9 , ""Link<S2SV_blank>aggregation"" ) ; PEEK_DISCARD_UINT8 ; port -> p_aggregid = PEEK_UINT32 ; break ; case LLDP_TLV_DOT3_MFS : CHECK_TLV_SIZE ( 6 , ""MFS"" ) ; port -> p_mfs = PEEK_UINT16 ; break ; case LLDP_TLV_DOT3_POWER : CHECK_TLV_SIZE ( 7 , ""Power"" ) ; port -> p_power . devicetype = PEEK_UINT8 ; port -> p_power . supported = ( port -> p_power . devicetype & 0x2 ) >> 1 ; port -> p_power . enabled = ( port -> p_power . devicetype & 0x4 ) >> 2 ; port -> p_power . paircontrol = ( port -> p_power . devicetype & 0x8 ) >> 3 ; port -> p_power . devicetype = ( port -> p_power . devicetype & 0x1 ) ? LLDP_DOT3_POWER_PSE : LLDP_DOT3_POWER_PD ; port -> p_power . pairs = PEEK_UINT8 ; port -> p_power . class = PEEK_UINT8 ; if ( tlv_size >= 12 ) { port -> p_power . powertype = PEEK_UINT8 ; port -> p_power . source = ( port -> p_power . powertype & ( 1 << 5 | 1 << 4 ) ) >> 4 ; port -> p_power . priority = ( port -> p_power . powertype & ( 1 << 1 | 1 << 0 ) ) ; port -> p_power . powertype = ( port -> p_power . powertype & ( 1 << 7 ) ) ? LLDP_DOT3_POWER_8023AT_TYPE1 : LLDP_DOT3_POWER_8023AT_TYPE2 ; port -> p_power . requested = PEEK_UINT16 ; port -> p_power . allocated = PEEK_UINT16 ; } else port -> p_power . powertype = LLDP_DOT3_POWER_8023AT_OFF ; break ; default : hardware -> h_rx_unrecognized_cnt ++ ; } # endif } else if ( memcmp ( med , orgid , sizeof ( orgid ) ) == 0 ) { # ifndef ENABLE_LLDPMED hardware -> h_rx_unrecognized_cnt ++ ; # else u_int32_t policy ; unsigned loctype ; unsigned power ; switch ( tlv_subtype ) { case LLDP_TLV_MED_CAP : CHECK_TLV_SIZE ( 7 , ""LLDP-MED<S2SV_blank>capabilities"" ) ; chassis -> c_med_cap_available = PEEK_UINT16 ; chassis -> c_med_type = PEEK_UINT8 ; port -> p_med_cap_enabled |= LLDP_MED_CAP_CAP ; break ; case LLDP_TLV_MED_POLICY : CHECK_TLV_SIZE ( 8 , ""LLDP-MED<S2SV_blank>policy"" ) ; policy = PEEK_UINT32 ; if ( ( ( policy >> 24 ) < 1 ) || ( ( policy >> 24 ) > LLDP_MED_APPTYPE_LAST ) ) { log_info ( ""lldp"" , ""unknown<S2SV_blank>policy<S2SV_blank>field<S2SV_blank>%d<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , policy , hardware -> h_ifname ) ; break ; } port -> p_med_policy [ ( policy >> 24 ) - 1 ] . type = ( policy >> 24 ) ; port -> p_med_policy [ ( policy >> 24 ) - 1 ] . unknown = ( ( policy & 0x800000 ) != 0 ) ; port -> p_med_policy [ ( policy >> 24 ) - 1 ] . tagged = ( ( policy & 0x400000 ) != 0 ) ; port -> p_med_policy [ ( policy >> 24 ) - 1 ] . vid = ( policy & 0x001FFE00 ) >> 9 ; port -> p_med_policy [ ( policy >> 24 ) - 1 ] . priority = ( policy & 0x1C0 ) >> 6 ; port -> p_med_policy [ ( policy >> 24 ) - 1 ] . dscp = policy & 0x3F ; port -> p_med_cap_enabled |= LLDP_MED_CAP_POLICY ; break ; case LLDP_TLV_MED_LOCATION : CHECK_TLV_SIZE ( 5 , ""LLDP-MED<S2SV_blank>Location"" ) ; loctype = PEEK_UINT8 ; if ( ( loctype < 1 ) || ( loctype > LLDP_MED_LOCFORMAT_LAST ) ) { log_info ( ""lldp"" , ""unknown<S2SV_blank>location<S2SV_blank>type<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; break ; } if ( ( port -> p_med_location [ loctype - 1 ] . data = ( char * ) malloc ( tlv_size - 5 ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>LLDP-MED<S2SV_blank>location<S2SV_blank>for<S2SV_blank>"" ""frame<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_BYTES ( port -> p_med_location [ loctype - 1 ] . data , tlv_size - 5 ) ; port -> p_med_location [ loctype - 1 ] . data_len = tlv_size - 5 ; port -> p_med_location [ loctype - 1 ] . format = loctype ; port -> p_med_cap_enabled |= LLDP_MED_CAP_LOCATION ; break ; case LLDP_TLV_MED_MDI : CHECK_TLV_SIZE ( 7 , ""LLDP-MED<S2SV_blank>PoE-MDI"" ) ; power = PEEK_UINT8 ; switch ( power & 0xC0 ) { case 0x0 : port -> p_med_power . devicetype = LLDP_MED_POW_TYPE_PSE ; port -> p_med_cap_enabled |= LLDP_MED_CAP_MDI_PSE ; switch ( power & 0x30 ) { case 0x0 : port -> p_med_power . source = LLDP_MED_POW_SOURCE_UNKNOWN ; break ; case 0x10 : port -> p_med_power . source = LLDP_MED_POW_SOURCE_PRIMARY ; break ; case 0x20 : port -> p_med_power . source = LLDP_MED_POW_SOURCE_BACKUP ; break ; default : port -> p_med_power . source = LLDP_MED_POW_SOURCE_RESERVED ; } break ; case 0x40 : port -> p_med_power . devicetype = LLDP_MED_POW_TYPE_PD ; port -> p_med_cap_enabled |= LLDP_MED_CAP_MDI_PD ; switch ( power & 0x30 ) { case 0x0 : port -> p_med_power . source = LLDP_MED_POW_SOURCE_UNKNOWN ; break ; case 0x10 : port -> p_med_power . source = LLDP_MED_POW_SOURCE_PSE ; break ; case 0x20 : port -> p_med_power . source = LLDP_MED_POW_SOURCE_LOCAL ; break ; default : port -> p_med_power . source = LLDP_MED_POW_SOURCE_BOTH ; } break ; default : port -> p_med_power . devicetype = LLDP_MED_POW_TYPE_RESERVED ; } if ( ( power & 0x0F ) > LLDP_MED_POW_PRIO_LOW ) port -> p_med_power . priority = LLDP_MED_POW_PRIO_UNKNOWN ; else port -> p_med_power . priority = power & 0x0F ; port -> p_med_power . val = PEEK_UINT16 ; break ; case LLDP_TLV_MED_IV_HW : case LLDP_TLV_MED_IV_SW : case LLDP_TLV_MED_IV_FW : case LLDP_TLV_MED_IV_SN : case LLDP_TLV_MED_IV_MANUF : case LLDP_TLV_MED_IV_MODEL : case LLDP_TLV_MED_IV_ASSET : if ( tlv_size <= 4 ) b = NULL ; else { if ( ( b = ( char * ) malloc ( tlv_size - 3 ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>"" ""memory<S2SV_blank>for<S2SV_blank>LLDP-MED<S2SV_blank>"" ""inventory<S2SV_blank>for<S2SV_blank>frame<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_BYTES ( b , tlv_size - 4 ) ; b [ tlv_size - 4 ] = '\\0' ; } switch ( tlv_subtype ) { case LLDP_TLV_MED_IV_HW : chassis -> c_med_hw = b ; break ; case LLDP_TLV_MED_IV_FW : chassis -> c_med_fw = b ; break ; case LLDP_TLV_MED_IV_SW : chassis -> c_med_sw = b ; break ; case LLDP_TLV_MED_IV_SN : chassis -> c_med_sn = b ; break ; case LLDP_TLV_MED_IV_MANUF : chassis -> c_med_manuf = b ; break ; case LLDP_TLV_MED_IV_MODEL : chassis -> c_med_model = b ; break ; case LLDP_TLV_MED_IV_ASSET : chassis -> c_med_asset = b ; break ; } port -> p_med_cap_enabled |= LLDP_MED_CAP_IV ; break ; default : hardware -> h_rx_unrecognized_cnt ++ ; } # endif } else if ( memcmp ( dcbx , orgid , sizeof ( orgid ) ) == 0 ) { log_debug ( ""lldp"" , ""unsupported<S2SV_blank>DCBX<S2SV_blank>tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>ignore"" , hardware -> h_ifname ) ; hardware -> h_rx_unrecognized_cnt ++ ; } else { log_debug ( ""lldp"" , ""unknown<S2SV_blank>org<S2SV_blank>tlv<S2SV_blank>[%02x:%02x:%02x]<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , orgid [ 0 ] , orgid [ 1 ] , orgid [ 2 ] , hardware -> h_ifname ) ; hardware -> h_rx_unrecognized_cnt ++ ; # ifdef ENABLE_CUSTOM custom = ( struct lldpd_custom * ) calloc ( 1 , sizeof ( struct lldpd_custom ) ) ; if ( ! custom ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>custom<S2SV_blank>TLV"" ) ; goto malformed ; } custom -> oui_info_len = tlv_size > 4 ? tlv_size - 4 : 0 ; memcpy ( custom -> oui , orgid , sizeof ( custom -> oui ) ) ; custom -> subtype = tlv_subtype ; if ( custom -> oui_info_len > 0 ) { custom -> oui_info = malloc ( custom -> oui_info_len ) ; if ( ! custom -> oui_info ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>custom<S2SV_blank>TLV<S2SV_blank>data"" ) ; goto malformed ; } PEEK_BYTES ( custom -> oui_info , custom -> oui_info_len ) ; } TAILQ_INSERT_TAIL ( & port -> p_custom_list , custom , next ) ; custom = NULL ; # endif } break ; default : log_warnx ( ""lldp"" , ""unknown<S2SV_blank>tlv<S2SV_blank>(%d)<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , tlv_type , hardware -> h_ifname ) ; goto malformed ; } if ( pos > tlv + tlv_size ) { log_warnx ( ""lldp"" , ""BUG:<S2SV_blank>already<S2SV_blank>past<S2SV_blank>TLV!"" ) ; goto malformed ; } PEEK_DISCARD ( tlv + tlv_size - pos ) ; } if ( ( chassis -> c_id == NULL ) || ( port -> p_id == NULL ) || ( ! ttl_received ) || ( gotend == 0 ) ) { log_warnx ( ""lldp"" , ""some<S2SV_blank>mandatory<S2SV_blank>tlv<S2SV_blank>are<S2SV_blank>missing<S2SV_blank>for<S2SV_blank>frame<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } * newchassis = chassis ; * newport = port ; return 1 ; malformed : # ifdef ENABLE_CUSTOM free ( custom ) ; # endif # ifdef ENABLE_DOT1 free ( vlan ) ; free ( pi ) ; # endif lldpd_chassis_cleanup ( chassis , 1 ) ; lldpd_port_cleanup ( port , 1 ) ; free ( port ) ; return - 1 ; }
","<S2SV_ModStart> NULL ) { if <S2SV_ModEnd> ( errno == <S2SV_ModStart> == ENOMEM ) <S2SV_ModEnd> log_warn ( ""lldp"" <S2SV_ModStart> , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>management<S2SV_blank>address"" ) ; else log_warn ( ""lldp"" , ""too<S2SV_blank>large<S2SV_blank>management<S2SV_blank>address<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname
"
803,"CWE-787 static plist_t parse_bin_node ( struct bplist_data * bplist , const char * * object ) { uint16_t type = 0 ; uint64_t size = 0 ; if ( ! object ) return NULL ; type = ( * * object ) & BPLIST_MASK ; size = ( * * object ) & BPLIST_FILL ; ( * object ) ++ ; if ( size == BPLIST_FILL ) { switch ( type ) { case BPLIST_DATA : case BPLIST_STRING : case BPLIST_UNICODE : case BPLIST_ARRAY : case BPLIST_SET : case BPLIST_DICT : { uint16_t next_size = * * object & BPLIST_FILL ; if ( ( * * object & BPLIST_MASK ) != BPLIST_UINT ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>invalid<S2SV_blank>size<S2SV_blank>node<S2SV_blank>type<S2SV_blank>for<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x:<S2SV_blank>found<S2SV_blank>0x%02x,<S2SV_blank>expected<S2SV_blank>0x%02x\\n"" , __func__ , type , * * object & BPLIST_MASK , BPLIST_UINT ) ; return NULL ; } ( * object ) ++ ; next_size = 1 << next_size ; if ( * object + next_size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>size<S2SV_blank>node<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>for<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ , type ) ; return NULL ; } size = UINT_TO_HOST ( * object , next_size ) ; ( * object ) += next_size ; break ; } default : break ; } } switch ( type ) { case BPLIST_NULL : switch ( size ) { case BPLIST_TRUE : { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_BOOLEAN ; data -> boolval = TRUE ; data -> length = 1 ; return node_create ( NULL , data ) ; } case BPLIST_FALSE : { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_BOOLEAN ; data -> boolval = FALSE ; data -> length = 1 ; return node_create ( NULL , data ) ; } case BPLIST_NULL : default : return NULL ; } case BPLIST_UINT : if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UINT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_uint_node ( object , size ) ; case BPLIST_REAL : if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_real_node ( object , size ) ; case BPLIST_DATE : if ( 3 != size ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>size<S2SV_blank>for<S2SV_blank>BPLIST_DATE<S2SV_blank>node\\n"" , __func__ ) ; return NULL ; } if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DATE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_date_node ( object , size ) ; case BPLIST_DATA : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DATA<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_data_node ( object , size ) ; case BPLIST_STRING : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_STRING<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_string_node ( object , size ) ; case BPLIST_UNICODE : if ( size * 2 < size ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>size.\\n"" , __func__ ) ; return NULL ; } <S2SV_StartBug> if ( * object + size * 2 > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_unicode_node ( object , size ) ; case BPLIST_SET : case BPLIST_ARRAY : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_ARRAY<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_array_node ( bplist , object , size ) ; case BPLIST_UID : if ( * object + size + 1 > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UID<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_uid_node ( object , size ) ; case BPLIST_DICT : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_dict_node ( bplist , object , size ) ; default : PLIST_BIN_ERR ( ""%s:<S2SV_blank>unexpected<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x\\n"" , __func__ , type ) ; return NULL ; } return NULL ; }
","<S2SV_ModStart> object + size < * object || * object + size <S2SV_ModStart> : if ( * object + size < * object || <S2SV_ModStart> size * 2 < * object || * object + size * 2 <S2SV_ModStart> object + size < * object || * object + size <S2SV_ModStart> object + size < * object || * object + size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DICT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" <S2SV_ModEnd> , __func__ )
"
804,"CWE-20 error_t ksz8851Init ( NetInterface * interface ) { Ksz8851Context * context ; context = ( Ksz8851Context * ) interface -> nicContext ; TRACE_INFO ( ""Initializing<S2SV_blank>KSZ8851<S2SV_blank>Ethernet<S2SV_blank>controller...\\r\\n"" ) ; # if ( KSZ8851_SPI_SUPPORT == ENABLED ) interface -> spiDriver -> init ( ) ; # endif interface -> extIntDriver -> init ( ) ; <S2SV_StartBug> TRACE_DEBUG ( ""CIDER=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_CIDER ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""PHY1ILR=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_PHY1ILR ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""PHY1IHR=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_PHY1IHR ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ksz8851ReadReg ( interface , KSZ8851_REG_CIDER ) != KSZ8851_REV_A3_ID ) <S2SV_EndBug> { return ERROR_WRONG_IDENTIFIER ; } ksz8851DumpReg ( interface ) ; context -> frameId = 0 ; context -> txBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; context -> rxBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; if ( context -> txBuffer == NULL || context -> rxBuffer == NULL ) { memPoolFree ( context -> txBuffer ) ; memPoolFree ( context -> rxBuffer ) ; return ERROR_OUT_OF_MEMORY ; } <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MARH , htons ( interface -> macAddr . w [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MARM , htons ( interface -> macAddr . w [ 1 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MARL , htons ( interface -> macAddr . w [ 2 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_TXCR , TXCR_TXFCE | TXCR_TXPE | TXCR_TXCE ) ; <S2SV_EndBug> ksz8851WriteReg ( interface , KSZ8851_REG_TXFDPR , TXFDPR_TXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_REG_RXCR1 , RXCR1_RXPAFMA | RXCR1_RXFCE | RXCR1_RXBE | RXCR1_RXME | RXCR1_RXUE ) ; ksz8851WriteReg ( interface , KSZ8851_REG_RXCR2 , RXCR2_SRDBL2 | RXCR2_IUFFP | RXCR2_RXIUFCEZ ) ; ksz8851WriteReg ( interface , KSZ8851_REG_RXQCR , RXQCR_RXFCTE | RXQCR_ADRFE ) ; ksz8851WriteReg ( interface , KSZ8851_REG_RXFDPR , RXFDPR_RXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_REG_RXFCTR , 1 ) ; <S2SV_StartBug> ksz8851ClearBit ( interface , KSZ8851_REG_P1CR , P1CR_FORCE_DUPLEX ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_P1CR , P1CR_RESTART_AN ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_ISR , ISR_LCIS | ISR_TXIS | <S2SV_EndBug> ISR_RXIS | ISR_RXOIS | ISR_TXPSIS | ISR_RXPSIS | ISR_TXSAIS | ISR_RXWFDIS | ISR_RXMPDIS | ISR_LDIS | ISR_EDIS | ISR_SPIBEIS ) ; <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_IER , IER_LCIE | IER_TXIE | IER_RXIE ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_TXCR , TXCR_TXE ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXCR1 , RXCR1_RXE ) ; <S2SV_EndBug> osSetEvent ( & interface -> nicTxEvent ) ; interface -> nicEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }
","<S2SV_ModStart> ( interface , KSZ8851_CIDER <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_PHY1ILR <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_PHY1IHR <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_CIDER ) != ( KSZ8851_CIDER_FAMILY_ID_DEFAULT | KSZ8851_CIDER_CHIP_ID_DEFAULT | KSZ8851_CIDER_REV_ID_A3 ) <S2SV_ModEnd> ) { return <S2SV_ModStart> ( interface , KSZ8851_MARH <S2SV_ModEnd> , htons ( <S2SV_ModStart> ( interface , KSZ8851_MARM <S2SV_ModEnd> , htons ( <S2SV_ModStart> ( interface , KSZ8851_MARL <S2SV_ModEnd> , htons ( <S2SV_ModStart> ( interface , KSZ8851_TXCR , KSZ8851_TXCR_TXFCE | KSZ8851_TXCR_TXPE | KSZ8851_TXCR_TXCE ) ; ksz8851WriteReg ( interface , KSZ8851_TXFDPR , KSZ8851_TXFDPR_TXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_RXCR1 , KSZ8851_RXCR1_RXPAFMA | KSZ8851_RXCR1_RXFCE | KSZ8851_RXCR1_RXBE | KSZ8851_RXCR1_RXME | KSZ8851_RXCR1_RXUE ) ; ksz8851WriteReg ( interface , KSZ8851_RXCR2 , KSZ8851_RXCR2_SRDBL_SINGLE_FRAME | KSZ8851_RXCR2_IUFFP | KSZ8851_RXCR2_RXIUFCEZ ) ; ksz8851WriteReg ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_RXFCTE | KSZ8851_RXQCR_ADRFE ) ; ksz8851WriteReg ( interface , KSZ8851_RXFDPR , KSZ8851_RXFDPR_RXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_RXFCTR <S2SV_ModEnd> , 1 ) <S2SV_ModStart> ( interface , KSZ8851_P1CR , KSZ8851_P1CR_FORCE_DUPLEX <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_P1CR , KSZ8851_P1CR_RESTART_AN <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_ISR , KSZ8851_ISR_LCIS | KSZ8851_ISR_TXIS | KSZ8851_ISR_RXIS | KSZ8851_ISR_RXOIS | KSZ8851_ISR_TXPSIS | KSZ8851_ISR_RXPSIS | KSZ8851_ISR_TXSAIS | KSZ8851_ISR_RXWFDIS | KSZ8851_ISR_RXMPDIS | KSZ8851_ISR_LDIS | KSZ8851_ISR_EDIS | KSZ8851_ISR_SPIBEIS <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_IER , KSZ8851_IER_LCIE | KSZ8851_IER_TXIE | KSZ8851_IER_RXIE <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_TXCR , KSZ8851_TXCR_TXE <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_RXCR1 , KSZ8851_RXCR1_RXE <S2SV_ModEnd> ) ; osSetEvent
"
805,"CWE-416 void ppp_unregister_channel ( struct ppp_channel * chan ) { struct channel * pch = chan -> ppp ; struct ppp_net * pn ; if ( ! pch ) return ; chan -> ppp = NULL ; down_write ( & pch -> chan_sem ) ; spin_lock_bh ( & pch -> downl ) ; pch -> chan = NULL ; spin_unlock_bh ( & pch -> downl ) ; up_write ( & pch -> chan_sem ) ; ppp_disconnect_channel ( pch ) ; pn = ppp_pernet ( pch -> chan_net ) ; spin_lock_bh ( & pn -> all_channels_lock ) ; list_del ( & pch -> list ) ; spin_unlock_bh ( & pn -> all_channels_lock ) ; <S2SV_StartBug> pch -> file . dead = 1 ; <S2SV_EndBug> wake_up_interruptible ( & pch -> file . rwait ) ; if ( atomic_dec_and_test ( & pch -> file . refcnt ) ) ppp_destroy_channel ( pch ) ; }
","<S2SV_ModStart> all_channels_lock ) ; put_net ( pch -> chan_net ) ; pch -> chan_net = NULL ;
"
806,"CWE-362 static int do_setxattr ( struct btrfs_trans_handle * trans , struct inode * inode , const char * name , const void * value , size_t size , int flags ) { <S2SV_StartBug> struct btrfs_dir_item * di ; <S2SV_EndBug> struct btrfs_root * root = BTRFS_I ( inode ) -> root ; struct btrfs_path * path ; size_t name_len = strlen ( name ) ; int ret = 0 ; if ( name_len + size > BTRFS_MAX_XATTR_SIZE ( root ) ) return - ENOSPC ; path = btrfs_alloc_path ( ) ; if ( ! path ) return - ENOMEM ; <S2SV_StartBug> if ( flags & XATTR_REPLACE ) { <S2SV_EndBug> <S2SV_StartBug> di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , <S2SV_EndBug> name_len , - 1 ) ; if ( IS_ERR ( di ) ) { ret = PTR_ERR ( di ) ; goto out ; <S2SV_StartBug> } else if ( ! di ) { <S2SV_EndBug> ret = - ENODATA ; goto out ; } <S2SV_StartBug> ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ; <S2SV_EndBug> if ( ret ) goto out ; <S2SV_StartBug> btrfs_release_path ( path ) ; <S2SV_EndBug> if ( ! value ) goto out ; <S2SV_StartBug> } else { <S2SV_EndBug> di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ; if ( IS_ERR ( di ) ) { ret = PTR_ERR ( di ) ; goto out ; } if ( ! di && ! value ) goto out ; btrfs_release_path ( path ) ; } again : ret = btrfs_insert_xattr_item ( trans , root , path , btrfs_ino ( inode ) , name , name_len , value , size ) ; if ( ret == - EOVERFLOW ) ret = - EEXIST ; if ( ret == - EEXIST ) { <S2SV_StartBug> if ( flags & XATTR_CREATE ) <S2SV_EndBug> goto out ; <S2SV_StartBug> btrfs_release_path ( path ) ; <S2SV_EndBug> di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ; if ( IS_ERR ( di ) ) { ret = PTR_ERR ( di ) ; goto out ; <S2SV_StartBug> } else if ( ! di ) { <S2SV_EndBug> btrfs_release_path ( path ) ; goto again ; } ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ; if ( ret ) goto out ; <S2SV_StartBug> if ( value ) { <S2SV_EndBug> btrfs_release_path ( path ) ; goto again ; } } out : btrfs_free_path ( path ) ; return ret ; }
","<S2SV_ModStart> btrfs_dir_item * di = NULL <S2SV_ModStart> - ENOMEM ; path -> skip_release_on_error = 1 ; if ( ! value ) { di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ; if ( ! di && <S2SV_ModEnd> ( flags & <S2SV_ModStart> & XATTR_REPLACE ) ) ret = - ENODATA ; else if ( di ) ret = btrfs_delete_one_dir_name <S2SV_ModEnd> ( trans , <S2SV_ModStart> , path , <S2SV_ModEnd> di ) ; <S2SV_ModStart> out ; } if ( flags & XATTR_REPLACE ) { ASSERT ( mutex_is_locked ( & inode -> i_mutex ) ) ; di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> out ; } btrfs_release_path ( path ) ; di = NULL ; } ret = btrfs_insert_xattr_item <S2SV_ModEnd> ( trans , <S2SV_ModStart> , path , btrfs_ino ( inode ) , name , name_len , value , size ) ; if ( ret == - EOVERFLOW ) { ret = 0 ; btrfs_assert_tree_locked ( path -> nodes [ 0 ] ) ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; if ( ! di && ! ( flags & XATTR_REPLACE ) ) { ret = - ENOSPC ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> goto out ; } } else if ( ret == - EEXIST ) { ret = 0 ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; ASSERT ( di ) ; } else if ( ret ) { <S2SV_ModEnd> goto out ; <S2SV_ModStart> out ; } if ( di && <S2SV_ModEnd> ( flags & <S2SV_ModStart> & XATTR_CREATE ) ) { ret = - EEXIST ; <S2SV_ModStart> goto out ; } if ( di ) { const int slot = path -> slots [ 0 ] ; struct extent_buffer * leaf = path -> nodes [ 0 ] ; const u16 old_data_len = btrfs_dir_data_len ( leaf , di ) ; const u32 item_size = btrfs_item_size_nr ( leaf , slot ) ; const u32 data_size = sizeof ( * di ) + name_len + size ; struct btrfs_item * item ; unsigned long data_ptr ; char * ptr ; if ( size > old_data_len ) { if ( btrfs_leaf_free_space ( root , leaf ) < ( size - old_data_len ) ) { ret = - ENOSPC <S2SV_ModEnd> ; goto out <S2SV_ModStart> out ; } } if ( old_data_len + name_len + sizeof ( * di ) == item_size ) { if ( size > old_data_len ) btrfs_extend_item ( root , path , size - old_data_len ) ; <S2SV_ModStart> else if ( size < old_data_len ) btrfs_truncate_item ( root , path , data_size , 1 ) ; } else { <S2SV_ModEnd> ret = btrfs_delete_one_dir_name <S2SV_ModStart> goto out ; btrfs_extend_item ( root , path , data_size ) ; } item = btrfs_item_nr ( slot ) ; ptr = btrfs_item_ptr ( leaf , slot , char ) ; ptr += btrfs_item_size ( leaf , item ) - data_size ; di = ( struct btrfs_dir_item * ) ptr ; btrfs_set_dir_data_len ( leaf , di , size ) ; data_ptr = ( ( unsigned long ) ( di + 1 ) ) + name_len ; write_extent_buffer ( leaf , value , data_ptr , size ) ; btrfs_mark_buffer_dirty ( leaf ) ; } else { <S2SV_ModEnd> } out :
"
807,"CWE-125 int wasm_dis ( WasmOp * op , const unsigned char * buf , int buf_len ) { op -> len = 1 ; op -> op = buf [ 0 ] ; <S2SV_StartBug> if ( op -> op > 0xbf ) return 1 ; <S2SV_EndBug> WasmOpDef * opdef = & opcodes [ op -> op ] ; switch ( op -> op ) { case WASM_OP_TRAP : case WASM_OP_NOP : case WASM_OP_ELSE : case WASM_OP_RETURN : case WASM_OP_DROP : case WASM_OP_SELECT : case WASM_OP_I32EQZ : case WASM_OP_I32EQ : case WASM_OP_I32NE : case WASM_OP_I32LTS : case WASM_OP_I32LTU : case WASM_OP_I32GTS : case WASM_OP_I32GTU : case WASM_OP_I32LES : case WASM_OP_I32LEU : case WASM_OP_I32GES : case WASM_OP_I32GEU : case WASM_OP_I64EQZ : case WASM_OP_I64EQ : case WASM_OP_I64NE : case WASM_OP_I64LTS : case WASM_OP_I64LTU : case WASM_OP_I64GTS : case WASM_OP_I64GTU : case WASM_OP_I64LES : case WASM_OP_I64LEU : case WASM_OP_I64GES : case WASM_OP_I64GEU : case WASM_OP_F32EQ : case WASM_OP_F32NE : case WASM_OP_F32LT : case WASM_OP_F32GT : case WASM_OP_F32LE : case WASM_OP_F32GE : case WASM_OP_F64EQ : case WASM_OP_F64NE : case WASM_OP_F64LT : case WASM_OP_F64GT : case WASM_OP_F64LE : case WASM_OP_F64GE : case WASM_OP_I32CLZ : case WASM_OP_I32CTZ : case WASM_OP_I32POPCNT : case WASM_OP_I32ADD : case WASM_OP_I32SUB : case WASM_OP_I32MUL : case WASM_OP_I32DIVS : case WASM_OP_I32DIVU : case WASM_OP_I32REMS : case WASM_OP_I32REMU : case WASM_OP_I32AND : case WASM_OP_I32OR : case WASM_OP_I32XOR : case WASM_OP_I32SHL : case WASM_OP_I32SHRS : case WASM_OP_I32SHRU : case WASM_OP_I32ROTL : case WASM_OP_I32ROTR : case WASM_OP_I64CLZ : case WASM_OP_I64CTZ : case WASM_OP_I64POPCNT : case WASM_OP_I64ADD : case WASM_OP_I64SUB : case WASM_OP_I64MUL : case WASM_OP_I64DIVS : case WASM_OP_I64DIVU : case WASM_OP_I64REMS : case WASM_OP_I64REMU : case WASM_OP_I64AND : case WASM_OP_I64OR : case WASM_OP_I64XOR : case WASM_OP_I64SHL : case WASM_OP_I64SHRS : case WASM_OP_I64SHRU : case WASM_OP_I64ROTL : case WASM_OP_I64ROTR : case WASM_OP_F32ABS : case WASM_OP_F32NEG : case WASM_OP_F32CEIL : case WASM_OP_F32FLOOR : case WASM_OP_F32TRUNC : case WASM_OP_F32NEAREST : case WASM_OP_F32SQRT : case WASM_OP_F32ADD : case WASM_OP_F32SUB : case WASM_OP_F32MUL : case WASM_OP_F32DIV : case WASM_OP_F32MIN : case WASM_OP_F32MAX : case WASM_OP_F32COPYSIGN : case WASM_OP_F64ABS : case WASM_OP_F64NEG : case WASM_OP_F64CEIL : case WASM_OP_F64FLOOR : case WASM_OP_F64TRUNC : case WASM_OP_F64NEAREST : case WASM_OP_F64SQRT : case WASM_OP_F64ADD : case WASM_OP_F64SUB : case WASM_OP_F64MUL : case WASM_OP_F64DIV : case WASM_OP_F64MIN : case WASM_OP_F64MAX : case WASM_OP_F64COPYSIGN : case WASM_OP_I32WRAPI64 : case WASM_OP_I32TRUNCSF32 : case WASM_OP_I32TRUNCUF32 : case WASM_OP_I32TRUNCSF64 : case WASM_OP_I32TRUNCUF64 : case WASM_OP_I64EXTENDSI32 : case WASM_OP_I64EXTENDUI32 : case WASM_OP_I64TRUNCSF32 : case WASM_OP_I64TRUNCUF32 : case WASM_OP_I64TRUNCSF64 : case WASM_OP_I64TRUNCUF64 : case WASM_OP_F32CONVERTSI32 : case WASM_OP_F32CONVERTUI32 : case WASM_OP_F32CONVERTSI64 : case WASM_OP_F32CONVERTUI64 : case WASM_OP_F32DEMOTEF64 : case WASM_OP_F64CONVERTSI32 : case WASM_OP_F64CONVERTUI32 : case WASM_OP_F64CONVERTSI64 : case WASM_OP_F64CONVERTUI64 : case WASM_OP_F64PROMOTEF32 : case WASM_OP_I32REINTERPRETF32 : case WASM_OP_I64REINTERPRETF64 : case WASM_OP_F32REINTERPRETI32 : case WASM_OP_F64REINTERPRETI64 : case WASM_OP_END : { snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s"" , opdef -> txt ) ; } break ; case WASM_OP_BLOCK : case WASM_OP_LOOP : case WASM_OP_IF : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; switch ( 0x80 - val ) { case R_BIN_WASM_VALUETYPE_EMPTY : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i32 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>i32)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i64 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>i64)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f32 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>f32)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f64 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>f64)"" , opdef -> txt ) ; break ; default : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>?)"" , opdef -> txt ) ; break ; } op -> len += n ; } break ; case WASM_OP_BR : case WASM_OP_BRIF : case WASM_OP_CALL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_BRTABLE : { ut32 count = 0 , * table = NULL , def = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & count ) ; <S2SV_StartBug> if ( ! ( n > 0 && n < buf_len ) ) goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) ) goto err ; <S2SV_EndBug> int i = 0 ; op -> len += n ; for ( i = 0 ; i < count ; i ++ ) { n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & table [ i ] ) ; <S2SV_StartBug> if ( ! ( op -> len + n <= buf_len ) ) goto beach ; <S2SV_EndBug> <S2SV_StartBug> op -> len += n ; <S2SV_EndBug> } n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & def ) ; <S2SV_StartBug> if ( ! ( n > 0 && n + op -> len < buf_len ) ) goto beach ; <S2SV_EndBug> op -> len += n ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>"" , opdef -> txt , count ) ; <S2SV_StartBug> for ( i = 0 ; i < count && strlen ( op -> txt ) < R_ASM_BUFSIZE ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d<S2SV_blank>"" , table [ i ] ) ; <S2SV_EndBug> } snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d"" , def ) ; free ( table ) ; break ; beach : free ( table ) ; goto err ; } break ; case WASM_OP_CALLINDIRECT : { ut32 val = 0 , reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && op -> len + n <= buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>%d"" , opdef -> txt , val , reserved ) ; op -> len += n ; } break ; case WASM_OP_GETLOCAL : case WASM_OP_SETLOCAL : case WASM_OP_TEELOCAL : case WASM_OP_GETGLOBAL : case WASM_OP_SETGLOBAL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I32LOAD : case WASM_OP_I64LOAD : case WASM_OP_F32LOAD : case WASM_OP_F64LOAD : case WASM_OP_I32LOAD8S : case WASM_OP_I32LOAD8U : case WASM_OP_I32LOAD16S : case WASM_OP_I32LOAD16U : case WASM_OP_I64LOAD8S : case WASM_OP_I64LOAD8U : case WASM_OP_I64LOAD16S : case WASM_OP_I64LOAD16U : case WASM_OP_I64LOAD32S : case WASM_OP_I64LOAD32U : case WASM_OP_I32STORE : case WASM_OP_I64STORE : case WASM_OP_F32STORE : case WASM_OP_F64STORE : case WASM_OP_I32STORE8 : case WASM_OP_I32STORE16 : case WASM_OP_I64STORE8 : case WASM_OP_I64STORE16 : case WASM_OP_I64STORE32 : { ut32 flag = 0 , offset = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & flag ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & offset ) ; if ( ! ( n > 0 && op -> len + n <= buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>%d"" , opdef -> txt , flag , offset ) ; op -> len += n ; } break ; case WASM_OP_CURRENTMEMORY : case WASM_OP_GROWMEMORY : { ut32 reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && n < buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , reserved ) ; op -> len += n ; } break ; case WASM_OP_I32CONST : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" PFMT32d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I64CONST : { st64 val = 0 ; size_t n = read_i64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" PFMT64d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_F32CONST : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; case WASM_OP_F64CONST : { ut64 val = 0 ; size_t n = read_u64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; default : goto err ; } return op -> len ; err : op -> len = 1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""invalid"" ) ; return op -> len ; }
","<S2SV_ModStart> > 0xbf ) { <S2SV_ModStart> return 1 ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto err ; } <S2SV_ModStart> ) ) ) { <S2SV_ModStart> goto err ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> -> txt ) + 10 <S2SV_ModStart> ++ ) { int optxtlen = strlen ( op -> txt ) ; <S2SV_ModStart> -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen <S2SV_ModEnd> , ""%d<S2SV_blank>"" ,
"
808,"CWE-436 static void flatpak_proxy_client_finalize ( GObject * object ) { FlatpakProxyClient * client = FLATPAK_PROXY_CLIENT ( object ) ; client -> proxy -> clients = g_list_remove ( client -> proxy -> clients , client ) ; <S2SV_StartBug> g_clear_object ( & client -> proxy ) ; <S2SV_EndBug> g_hash_table_destroy ( client -> rewrite_reply ) ; g_hash_table_destroy ( client -> get_owner_reply ) ; g_hash_table_destroy ( client -> unique_id_policy ) ; free_side ( & client -> client_side ) ; free_side ( & client -> bus_side ) ; G_OBJECT_CLASS ( flatpak_proxy_client_parent_class ) -> finalize ( object ) ; }
","<S2SV_ModStart> client -> proxy ) ; g_byte_array_free ( client -> auth_buffer , TRUE
"
809,"CWE-119 void vp9_encode_intra_block_plane ( MACROBLOCK * x , BLOCK_SIZE bsize , int plane ) { const MACROBLOCKD * const xd = & x -> e_mbd ; struct encode_b_args arg = { x , NULL , & xd -> mi [ 0 ] -> mbmi . skip } ; <S2SV_StartBug> vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , encode_block_intra , <S2SV_EndBug> & arg ) ; }
","<S2SV_ModStart> , plane , vp9_encode_block_intra <S2SV_ModEnd> , & arg
"
810,"CWE-20 static int trusted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct trusted_key_payload * p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> return - ENOKEY ; p = key -> payload . data [ 0 ] ; if ( ! p -> migratable ) return - EPERM ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; datablob = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! datablob ) return - ENOMEM ; new_o = trusted_options_alloc ( ) ; if ( ! new_o ) { ret = - ENOMEM ; goto out ; } new_p = trusted_payload_alloc ( key ) ; if ( ! new_p ) { ret = - ENOMEM ; goto out ; } memcpy ( datablob , prep -> data , datalen ) ; datablob [ datalen ] = '\\0' ; ret = datablob_parse ( datablob , new_p , new_o ) ; if ( ret != Opt_update ) { ret = - EINVAL ; kzfree ( new_p ) ; goto out ; } if ( ! new_o -> keyhandle ) { ret = - EINVAL ; kzfree ( new_p ) ; goto out ; } new_p -> migratable = p -> migratable ; new_p -> key_len = p -> key_len ; memcpy ( new_p -> key , p -> key , p -> key_len ) ; dump_payload ( p ) ; dump_payload ( new_p ) ; ret = key_seal ( new_p , new_o ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:<S2SV_blank>key_seal<S2SV_blank>failed<S2SV_blank>(%d)\\n"" , ret ) ; kzfree ( new_p ) ; goto out ; } if ( new_o -> pcrlock ) { ret = pcrlock ( new_o -> pcrlock ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:<S2SV_blank>pcrlock<S2SV_blank>failed<S2SV_blank>(%d)\\n"" , ret ) ; kzfree ( new_p ) ; goto out ; } } rcu_assign_keypointer ( key , new_p ) ; call_rcu ( & p -> rcu , trusted_rcu_free ) ; out : kzfree ( datablob ) ; kzfree ( new_o ) ; return ret ; }
","<S2SV_ModStart> ; if ( key_is_negative ( key <S2SV_ModEnd> ) ) return
"
811,"CWE-190 int lzo1x_decompress_safe ( const unsigned char * in , size_t in_len , unsigned char * out , size_t * out_len ) { unsigned char * op ; const unsigned char * ip ; size_t t , next ; size_t state = 0 ; const unsigned char * m_pos ; const unsigned char * const ip_end = in + in_len ; unsigned char * const op_end = out + * out_len ; op = out ; ip = in ; if ( unlikely ( in_len < 3 ) ) goto input_overrun ; if ( * ip > 17 ) { t = * ip ++ - 17 ; if ( t < 4 ) { next = t ; goto match_next ; } goto copy_literal_run ; } for ( ; ; ) { t = * ip ++ ; if ( t < 16 ) { if ( likely ( state == 0 ) ) { if ( unlikely ( t == 0 ) ) { while ( unlikely ( * ip == 0 ) ) { t += 255 ; ip ++ ; <S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> } t += 15 + * ip ++ ; } t += 3 ; copy_literal_run : # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) <S2SV_StartBug> if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) ) { <S2SV_EndBug> const unsigned char * ie = ip + t ; unsigned char * oe = op + t ; do { COPY8 ( op , ip ) ; op += 8 ; ip += 8 ; COPY8 ( op , ip ) ; op += 8 ; ip += 8 ; } while ( ip < ie ) ; ip = ie ; op = oe ; } else # endif { <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( t + 3 ) ; <S2SV_EndBug> do { * op ++ = * ip ++ ; } while ( -- t > 0 ) ; } state = 4 ; continue ; } else if ( state != 4 ) { next = t & 3 ; m_pos = op - 1 ; m_pos -= t >> 2 ; m_pos -= * ip ++ << 2 ; TEST_LB ( m_pos ) ; <S2SV_StartBug> NEED_OP ( 2 ) ; <S2SV_EndBug> op [ 0 ] = m_pos [ 0 ] ; op [ 1 ] = m_pos [ 1 ] ; op += 2 ; goto match_next ; } else { next = t & 3 ; m_pos = op - ( 1 + M2_MAX_OFFSET ) ; m_pos -= t >> 2 ; m_pos -= * ip ++ << 2 ; t = 3 ; } } else if ( t >= 64 ) { next = t & 3 ; m_pos = op - 1 ; m_pos -= ( t >> 2 ) & 7 ; m_pos -= * ip ++ << 3 ; t = ( t >> 5 ) - 1 + ( 3 - 1 ) ; } else if ( t >= 32 ) { t = ( t & 31 ) + ( 3 - 1 ) ; if ( unlikely ( t == 2 ) ) { while ( unlikely ( * ip == 0 ) ) { t += 255 ; ip ++ ; <S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> } t += 31 + * ip ++ ; <S2SV_StartBug> NEED_IP ( 2 ) ; <S2SV_EndBug> } m_pos = op - 1 ; next = get_unaligned_le16 ( ip ) ; ip += 2 ; m_pos -= next >> 2 ; next &= 3 ; } else { m_pos = op ; m_pos -= ( t & 8 ) << 11 ; t = ( t & 7 ) + ( 3 - 1 ) ; if ( unlikely ( t == 2 ) ) { while ( unlikely ( * ip == 0 ) ) { t += 255 ; ip ++ ; <S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> } t += 7 + * ip ++ ; <S2SV_StartBug> NEED_IP ( 2 ) ; <S2SV_EndBug> } next = get_unaligned_le16 ( ip ) ; ip += 2 ; m_pos -= next >> 2 ; next &= 3 ; if ( m_pos == op ) goto eof_found ; m_pos -= 0x4000 ; } TEST_LB ( m_pos ) ; # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) if ( op - m_pos >= 8 ) { unsigned char * oe = op + t ; <S2SV_StartBug> if ( likely ( HAVE_OP ( t + 15 ) ) ) { <S2SV_EndBug> do { COPY8 ( op , m_pos ) ; op += 8 ; m_pos += 8 ; COPY8 ( op , m_pos ) ; op += 8 ; m_pos += 8 ; } while ( op < oe ) ; op = oe ; <S2SV_StartBug> if ( HAVE_IP ( 6 ) ) { <S2SV_EndBug> state = next ; COPY4 ( op , ip ) ; op += next ; ip += next ; continue ; } } else { <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> do { * op ++ = * m_pos ++ ; } while ( op < oe ) ; } } else # endif { unsigned char * oe = op + t ; <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> op [ 0 ] = m_pos [ 0 ] ; op [ 1 ] = m_pos [ 1 ] ; op += 2 ; m_pos += 2 ; do { * op ++ = * m_pos ++ ; } while ( op < oe ) ; } match_next : state = next ; t = next ; # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) <S2SV_StartBug> if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) ) { <S2SV_EndBug> COPY4 ( op , ip ) ; op += t ; ip += t ; } else # endif { <S2SV_StartBug> NEED_IP ( t + 3 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> while ( t > 0 ) { * op ++ = * ip ++ ; t -- ; } } } eof_found : * out_len = op - out ; return ( t != 3 ? LZO_E_ERROR : ip == ip_end ? LZO_E_OK : ip < ip_end ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN ) ; input_overrun : * out_len = op - out ; return LZO_E_INPUT_OVERRUN ; output_overrun : * out_len = op - out ; return LZO_E_OUTPUT_OVERRUN ; lookbehind_overrun : * out_len = op - out ; return LZO_E_LOOKBEHIND_OVERRUN ; }
","<S2SV_ModStart> NEED_IP ( 1 , 0 <S2SV_ModStart> HAVE_IP ( t , <S2SV_ModEnd> 15 ) && <S2SV_ModStart> HAVE_OP ( t , <S2SV_ModEnd> 15 ) ) <S2SV_ModStart> NEED_OP ( t , 0 <S2SV_ModStart> NEED_IP ( t , <S2SV_ModEnd> 3 ) ; <S2SV_ModStart> NEED_OP ( 2 , 0 <S2SV_ModStart> NEED_IP ( 1 , 0 <S2SV_ModStart> NEED_IP ( 2 , 0 <S2SV_ModStart> NEED_IP ( 1 , 0 <S2SV_ModStart> NEED_IP ( 2 , 0 <S2SV_ModStart> HAVE_OP ( t , <S2SV_ModEnd> 15 ) ) <S2SV_ModStart> HAVE_IP ( 6 , 0 <S2SV_ModStart> NEED_OP ( t , 0 <S2SV_ModStart> NEED_OP ( t , 0 <S2SV_ModStart> HAVE_IP ( 6 , 0 <S2SV_ModStart> HAVE_OP ( 4 , 0 <S2SV_ModStart> NEED_IP ( t , <S2SV_ModEnd> 3 ) ; <S2SV_ModStart> NEED_OP ( t , 0
"
812,"CWE-000 int fit_image_load ( bootm_headers_t * images , ulong addr , const char * * fit_unamep , const char * * fit_uname_configp , int arch , int image_type , int bootstage_id , enum fit_load_op load_op , ulong * datap , ulong * lenp ) { int cfg_noffset , noffset ; const char * fit_uname ; const char * fit_uname_config ; const char * fit_base_uname_config ; const void * fit ; void * buf ; void * loadbuf ; size_t size ; int type_ok , os_ok ; ulong load , load_end , data , len ; uint8_t os , comp ; # ifndef USE_HOSTCC uint8_t os_arch ; # endif const char * prop_name ; int ret ; fit = map_sysmem ( addr , 0 ) ; fit_uname = fit_unamep ? * fit_unamep : NULL ; fit_uname_config = fit_uname_configp ? * fit_uname_configp : NULL ; fit_base_uname_config = NULL ; prop_name = fit_get_image_type_property ( image_type ) ; printf ( ""##<S2SV_blank>Loading<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>FIT<S2SV_blank>Image<S2SV_blank>at<S2SV_blank>%08lx<S2SV_blank>...\\n"" , prop_name , addr ) ; bootstage_mark ( bootstage_id + BOOTSTAGE_SUB_FORMAT ) ; <S2SV_StartBug> if ( fit_check_format ( fit , IMAGE_SIZE_INVAL ) ) { <S2SV_EndBug> <S2SV_StartBug> printf ( ""Bad<S2SV_blank>FIT<S2SV_blank>%s<S2SV_blank>image<S2SV_blank>format!\\n"" , prop_name ) ; <S2SV_EndBug> bootstage_error ( bootstage_id + BOOTSTAGE_SUB_FORMAT ) ; <S2SV_StartBug> return - ENOEXEC ; <S2SV_EndBug> } bootstage_mark ( bootstage_id + BOOTSTAGE_SUB_FORMAT_OK ) ; if ( fit_uname ) { bootstage_mark ( bootstage_id + BOOTSTAGE_SUB_UNIT_NAME ) ; noffset = fit_image_get_node ( fit , fit_uname ) ; } else { bootstage_mark ( bootstage_id + BOOTSTAGE_SUB_NO_UNIT_NAME ) ; if ( IMAGE_ENABLE_BEST_MATCH && ! fit_uname_config ) { cfg_noffset = fit_conf_find_compat ( fit , gd_fdt_blob ( ) ) ; } else { cfg_noffset = fit_conf_get_node ( fit , fit_uname_config ) ; } if ( cfg_noffset < 0 ) { puts ( ""Could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>configuration<S2SV_blank>node\\n"" ) ; bootstage_error ( bootstage_id + BOOTSTAGE_SUB_NO_UNIT_NAME ) ; return - ENOENT ; } fit_base_uname_config = fdt_get_name ( fit , cfg_noffset , NULL ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank>Using<S2SV_blank>\'%s\'<S2SV_blank>configuration\\n"" , fit_base_uname_config ) ; if ( image_type == IH_TYPE_KERNEL ) images -> fit_uname_cfg = fit_base_uname_config ; if ( FIT_IMAGE_ENABLE_VERIFY && images -> verify ) { puts ( ""<S2SV_blank><S2SV_blank><S2SV_blank>Verifying<S2SV_blank>Hash<S2SV_blank>Integrity<S2SV_blank>...<S2SV_blank>"" ) ; if ( fit_config_verify ( fit , cfg_noffset ) ) { puts ( ""Bad<S2SV_blank>Data<S2SV_blank>Hash\\n"" ) ; bootstage_error ( bootstage_id + BOOTSTAGE_SUB_HASH ) ; return - EACCES ; } puts ( ""OK\\n"" ) ; } bootstage_mark ( BOOTSTAGE_ID_FIT_CONFIG ) ; noffset = fit_conf_get_prop_node ( fit , cfg_noffset , prop_name ) ; fit_uname = fit_get_name ( fit , noffset , NULL ) ; } if ( noffset < 0 ) { printf ( ""Could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>subimage<S2SV_blank>node<S2SV_blank>type<S2SV_blank>\'%s\'\\n"" , prop_name ) ; bootstage_error ( bootstage_id + BOOTSTAGE_SUB_SUBNODE ) ; return - ENOENT ; } printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank>Trying<S2SV_blank>\'%s\'<S2SV_blank>%s<S2SV_blank>subimage\\n"" , fit_uname , prop_name ) ; ret = fit_image_select ( fit , noffset , images -> verify ) ; if ( ret ) { bootstage_error ( bootstage_id + BOOTSTAGE_SUB_HASH ) ; return ret ; } bootstage_mark ( bootstage_id + BOOTSTAGE_SUB_CHECK_ARCH ) ; if ( ! host_build ( ) && IS_ENABLED ( CONFIG_SANDBOX ) ) { if ( ! fit_image_check_target_arch ( fit , noffset ) ) { puts ( ""Unsupported<S2SV_blank>Architecture\\n"" ) ; bootstage_error ( bootstage_id + BOOTSTAGE_SUB_CHECK_ARCH ) ; return - ENOEXEC ; } } # ifndef USE_HOSTCC fit_image_get_arch ( fit , noffset , & os_arch ) ; images -> os . arch = os_arch ; # endif bootstage_mark ( bootstage_id + BOOTSTAGE_SUB_CHECK_ALL ) ; type_ok = fit_image_check_type ( fit , noffset , image_type ) || fit_image_check_type ( fit , noffset , IH_TYPE_FIRMWARE ) || ( image_type == IH_TYPE_KERNEL && fit_image_check_type ( fit , noffset , IH_TYPE_KERNEL_NOLOAD ) ) ; os_ok = image_type == IH_TYPE_FLATDT || image_type == IH_TYPE_FPGA || fit_image_check_os ( fit , noffset , IH_OS_LINUX ) || fit_image_check_os ( fit , noffset , IH_OS_U_BOOT ) || fit_image_check_os ( fit , noffset , IH_OS_OPENRTOS ) || fit_image_check_os ( fit , noffset , IH_OS_EFI ) || fit_image_check_os ( fit , noffset , IH_OS_VXWORKS ) ; if ( ( ! type_ok || ! os_ok ) && image_type != IH_TYPE_LOADABLE ) { fit_image_get_os ( fit , noffset , & os ) ; printf ( ""No<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>Image\\n"" , genimg_get_os_name ( os ) , genimg_get_arch_name ( arch ) , genimg_get_type_name ( image_type ) ) ; bootstage_error ( bootstage_id + BOOTSTAGE_SUB_CHECK_ALL ) ; return - EIO ; } bootstage_mark ( bootstage_id + BOOTSTAGE_SUB_CHECK_ALL_OK ) ; if ( fit_image_get_data_and_size ( fit , noffset , ( const void * * ) & buf , & size ) ) { printf ( ""Could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>%s<S2SV_blank>subimage<S2SV_blank>data!\\n"" , prop_name ) ; bootstage_error ( bootstage_id + BOOTSTAGE_SUB_GET_DATA ) ; return - ENOENT ; } if ( IS_ENABLED ( CONFIG_FIT_CIPHER ) && IMAGE_ENABLE_DECRYPT ) { puts ( ""<S2SV_blank><S2SV_blank><S2SV_blank>Decrypting<S2SV_blank>Data<S2SV_blank>...<S2SV_blank>"" ) ; if ( fit_image_uncipher ( fit , noffset , & buf , & size ) ) { puts ( ""Error\\n"" ) ; return - EACCES ; } puts ( ""OK\\n"" ) ; } if ( ! host_build ( ) && IS_ENABLED ( CONFIG_FIT_IMAGE_POST_PROCESS ) ) board_fit_image_post_process ( & buf , & size ) ; len = ( ulong ) size ; bootstage_mark ( bootstage_id + BOOTSTAGE_SUB_GET_DATA_OK ) ; data = map_to_sysmem ( buf ) ; load = data ; if ( load_op == FIT_LOAD_IGNORED ) { } else if ( fit_image_get_load ( fit , noffset , & load ) ) { if ( load_op == FIT_LOAD_REQUIRED ) { printf ( ""Can\'t<S2SV_blank>get<S2SV_blank>%s<S2SV_blank>subimage<S2SV_blank>load<S2SV_blank>address!\\n"" , prop_name ) ; bootstage_error ( bootstage_id + BOOTSTAGE_SUB_LOAD ) ; return - EBADF ; } } else if ( load_op != FIT_LOAD_OPTIONAL_NON_ZERO || load ) { ulong image_start , image_end ; image_start = addr ; image_end = addr + fit_get_size ( fit ) ; load_end = load + len ; if ( image_type != IH_TYPE_KERNEL && load < image_end && load_end > image_start ) { printf ( ""Error:<S2SV_blank>%s<S2SV_blank>overwritten\\n"" , prop_name ) ; return - EXDEV ; } printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank>Loading<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>0x%08lx<S2SV_blank>to<S2SV_blank>0x%08lx\\n"" , prop_name , data , load ) ; } else { load = data ; } comp = IH_COMP_NONE ; loadbuf = buf ; if ( ! fit_image_get_comp ( fit , noffset , & comp ) && comp != IH_COMP_NONE && ! ( image_type == IH_TYPE_KERNEL || image_type == IH_TYPE_KERNEL_NOLOAD || image_type == IH_TYPE_RAMDISK ) ) { ulong max_decomp_len = len * 20 ; if ( load == data ) { loadbuf = malloc ( max_decomp_len ) ; load = map_to_sysmem ( loadbuf ) ; } else { loadbuf = map_sysmem ( load , max_decomp_len ) ; } if ( image_decomp ( comp , load , data , image_type , loadbuf , buf , len , max_decomp_len , & load_end ) ) { printf ( ""Error<S2SV_blank>decompressing<S2SV_blank>%s\\n"" , prop_name ) ; return - ENOEXEC ; } len = load_end - load ; } else if ( load != data ) { loadbuf = map_sysmem ( load , len ) ; memcpy ( loadbuf , buf , len ) ; } if ( image_type == IH_TYPE_RAMDISK && comp != IH_COMP_NONE ) puts ( ""WARNING:<S2SV_blank>\'compression\'<S2SV_blank>nodes<S2SV_blank>for<S2SV_blank>ramdisks<S2SV_blank>are<S2SV_blank>deprecated,"" ""<S2SV_blank>please<S2SV_blank>fix<S2SV_blank>your<S2SV_blank>.its<S2SV_blank>file!\\n"" ) ; if ( image_type == IH_TYPE_FLATDT && fdt_check_header ( loadbuf ) ) { puts ( ""Subimage<S2SV_blank>data<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>FDT"" ) ; return - ENOEXEC ; } bootstage_mark ( bootstage_id + BOOTSTAGE_SUB_LOAD ) ; * datap = load ; * lenp = len ; if ( fit_unamep ) * fit_unamep = ( char * ) fit_uname ; if ( fit_uname_configp ) * fit_uname_configp = ( char * ) ( fit_uname_config ? : fit_base_uname_config ) ; return noffset ; }
","<S2SV_ModStart> BOOTSTAGE_SUB_FORMAT ) ; ret = <S2SV_ModEnd> fit_check_format ( fit <S2SV_ModStart> , IMAGE_SIZE_INVAL ) ; if ( ret <S2SV_ModStart> { printf ( ""Bad<S2SV_blank>FIT<S2SV_blank>%s<S2SV_blank>image<S2SV_blank>format!<S2SV_blank>(err=%d)\\n"" , prop_name , ret ) ; if ( CONFIG_IS_ENABLED ( FIT_SIGNATURE ) && ret == - EADDRNOTAVAIL ) printf ( ""Signature<S2SV_blank>checking<S2SV_blank>prevents<S2SV_blank>use<S2SV_blank>of<S2SV_blank>unit<S2SV_blank>addresses<S2SV_blank>(@)<S2SV_blank>in<S2SV_blank>nodes\\n"" <S2SV_ModEnd> ) ; bootstage_error <S2SV_ModStart> ) ; return ret <S2SV_ModEnd> ; } bootstage_mark
"
813,"CWE-119 void receive_tcppacket ( connection_t * c , const char * buffer , int len ) { <S2SV_StartBug> vpn_packet_t outpkt ; <S2SV_EndBug> outpkt . len = len ; if ( c -> options & OPTION_TCPONLY ) outpkt . priority = 0 ; else outpkt . priority = - 1 ; memcpy ( outpkt . data , buffer , len ) ; receive_packet ( c -> node , & outpkt ) ; }
","<S2SV_ModStart> { vpn_packet_t outpkt ; if ( len > sizeof outpkt . data ) return
"
814,"CWE-264 static __init int hardware_setup ( void ) { int r = - ENOMEM , i , msr ; rdmsrl_safe ( MSR_EFER , & host_efer ) ; for ( i = 0 ; i < ARRAY_SIZE ( vmx_msr_index ) ; ++ i ) kvm_define_shared_msr ( i , vmx_msr_index [ i ] ) ; vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_io_bitmap_a ) return r ; vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_io_bitmap_b ) goto out ; vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_legacy ) goto out1 ; vmx_msr_bitmap_legacy_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_legacy_x2apic ) goto out2 ; vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_longmode ) goto out3 ; vmx_msr_bitmap_longmode_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_longmode_x2apic ) goto out4 ; if ( nested ) { vmx_msr_bitmap_nested = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_nested ) goto out5 ; } vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_vmread_bitmap ) goto out6 ; vmx_vmwrite_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_vmwrite_bitmap ) goto out7 ; memset ( vmx_vmread_bitmap , 0xff , PAGE_SIZE ) ; memset ( vmx_vmwrite_bitmap , 0xff , PAGE_SIZE ) ; memset ( vmx_io_bitmap_a , 0xff , PAGE_SIZE ) ; clear_bit ( 0x80 , vmx_io_bitmap_a ) ; memset ( vmx_io_bitmap_b , 0xff , PAGE_SIZE ) ; memset ( vmx_msr_bitmap_legacy , 0xff , PAGE_SIZE ) ; memset ( vmx_msr_bitmap_longmode , 0xff , PAGE_SIZE ) ; if ( nested ) memset ( vmx_msr_bitmap_nested , 0xff , PAGE_SIZE ) ; if ( setup_vmcs_config ( & vmcs_config ) < 0 ) { r = - EIO ; goto out8 ; } if ( boot_cpu_has ( X86_FEATURE_NX ) ) kvm_enable_efer_bits ( EFER_NX ) ; if ( ! cpu_has_vmx_vpid ( ) ) enable_vpid = 0 ; if ( ! cpu_has_vmx_shadow_vmcs ( ) ) enable_shadow_vmcs = 0 ; if ( enable_shadow_vmcs ) init_vmcs_shadow_fields ( ) ; if ( ! cpu_has_vmx_ept ( ) || ! cpu_has_vmx_ept_4levels ( ) ) { enable_ept = 0 ; enable_unrestricted_guest = 0 ; enable_ept_ad_bits = 0 ; } if ( ! cpu_has_vmx_ept_ad_bits ( ) ) enable_ept_ad_bits = 0 ; if ( ! cpu_has_vmx_unrestricted_guest ( ) ) enable_unrestricted_guest = 0 ; if ( ! cpu_has_vmx_flexpriority ( ) ) flexpriority_enabled = 0 ; if ( ! flexpriority_enabled ) kvm_x86_ops -> set_apic_access_page_addr = NULL ; if ( ! cpu_has_vmx_tpr_shadow ( ) ) kvm_x86_ops -> update_cr8_intercept = NULL ; if ( enable_ept && ! cpu_has_vmx_ept_2m_page ( ) ) kvm_disable_largepages ( ) ; if ( ! cpu_has_vmx_ple ( ) ) ple_gap = 0 ; if ( ! cpu_has_vmx_apicv ( ) ) enable_apicv = 0 ; if ( cpu_has_vmx_tsc_scaling ( ) ) { kvm_has_tsc_control = true ; kvm_max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX ; kvm_tsc_scaling_ratio_frac_bits = 48 ; } vmx_disable_intercept_for_msr ( MSR_FS_BASE , false ) ; vmx_disable_intercept_for_msr ( MSR_GS_BASE , false ) ; vmx_disable_intercept_for_msr ( MSR_KERNEL_GS_BASE , true ) ; vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_CS , false ) ; vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_ESP , false ) ; vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_EIP , false ) ; vmx_disable_intercept_for_msr ( MSR_IA32_BNDCFGS , true ) ; memcpy ( vmx_msr_bitmap_legacy_x2apic , vmx_msr_bitmap_legacy , PAGE_SIZE ) ; memcpy ( vmx_msr_bitmap_longmode_x2apic , vmx_msr_bitmap_longmode , PAGE_SIZE ) ; set_bit ( 0 , vmx_vpid_bitmap ) ; <S2SV_StartBug> if ( enable_apicv ) { <S2SV_EndBug> for ( msr = 0x800 ; msr <= 0x8ff ; msr ++ ) vmx_disable_intercept_msr_read_x2apic ( msr ) ; vmx_enable_intercept_msr_read_x2apic ( 0x802 ) ; vmx_enable_intercept_msr_read_x2apic ( 0x839 ) ; vmx_disable_intercept_msr_write_x2apic ( 0x808 ) ; vmx_disable_intercept_msr_write_x2apic ( 0x80b ) ; vmx_disable_intercept_msr_write_x2apic ( 0x83f ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( enable_ept ) { kvm_mmu_set_mask_ptes ( 0ull , ( enable_ept_ad_bits ) ? VMX_EPT_ACCESS_BIT : 0ull , ( enable_ept_ad_bits ) ? VMX_EPT_DIRTY_BIT : 0ull , 0ull , VMX_EPT_EXECUTABLE_MASK ) ; ept_set_mmio_spte_mask ( ) ; kvm_enable_tdp ( ) ; } else kvm_disable_tdp ( ) ; update_ple_window_actual_max ( ) ; if ( ! enable_ept || ! enable_ept_ad_bits || ! cpu_has_vmx_pml ( ) ) enable_pml = 0 ; if ( ! enable_pml ) { kvm_x86_ops -> slot_enable_log_dirty = NULL ; kvm_x86_ops -> slot_disable_log_dirty = NULL ; kvm_x86_ops -> flush_log_dirty = NULL ; kvm_x86_ops -> enable_log_dirty_pt_masked = NULL ; } kvm_set_posted_intr_wakeup_handler ( wakeup_handler ) ; return alloc_kvm_area ( ) ; out8 : free_page ( ( unsigned long ) vmx_vmwrite_bitmap ) ; out7 : free_page ( ( unsigned long ) vmx_vmread_bitmap ) ; out6 : if ( nested ) free_page ( ( unsigned long ) vmx_msr_bitmap_nested ) ; out5 : free_page ( ( unsigned long ) vmx_msr_bitmap_longmode_x2apic ) ; out4 : free_page ( ( unsigned long ) vmx_msr_bitmap_longmode ) ; out3 : free_page ( ( unsigned long ) vmx_msr_bitmap_legacy_x2apic ) ; out2 : free_page ( ( unsigned long ) vmx_msr_bitmap_legacy ) ; out1 : free_page ( ( unsigned long ) vmx_io_bitmap_b ) ; out : free_page ( ( unsigned long ) vmx_io_bitmap_a ) ; return r ; }
","<S2SV_ModStart> vmx_vpid_bitmap ) ; <S2SV_ModEnd> for ( msr <S2SV_ModStart> 0x83f ) ; <S2SV_ModEnd> if ( enable_ept
"
815,"CWE-476 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = """" ; const char * link_section_name = """" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n"" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ; <S2SV_StartBug> for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) int vdaux = verdef -> vd_aux ; <S2SV_StartBug> if ( vdaux < 1 ) { <S2SV_EndBug> sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux ; <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , ""idx"" , i , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_version"" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_ndx"" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_cnt"" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , ""flags"" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , ""idx"" , isum , 0 ) ; sdb_num_set ( sdb_parent , ""parent"" , j , 0 ) ; sdb_set ( sdb_parent , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , ""parent%d"" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , ""verdef%d"" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( ""Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n"" ) ; break ; } i += verdef -> vd_next ; } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }
","<S2SV_ModStart> sh_info && ( end - <S2SV_ModStart> * ) defs > i <S2SV_ModEnd> ) ; ++ <S2SV_ModStart> vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux <S2SV_ModStart> > end || end - vstart < <S2SV_ModEnd> sizeof ( Elf_ <S2SV_ModStart> Verdaux ) ) <S2SV_ModEnd> ) { sdb_free <S2SV_ModStart> > end || end - vstart < <S2SV_ModEnd> sizeof ( Elf_ <S2SV_ModStart> Verdaux ) ) <S2SV_ModEnd> ) { sdb_free
"
816,"CWE-284 void close_uinput ( void ) { BTIF_TRACE_DEBUG ( ""%s"" , __FUNCTION__ ) ; if ( uinput_fd > 0 ) { <S2SV_StartBug> ioctl ( uinput_fd , UI_DEV_DESTROY ) ; <S2SV_EndBug> close ( uinput_fd ) ; uinput_fd = - 1 ; } }
","<S2SV_ModStart> 0 ) { TEMP_FAILURE_RETRY ( <S2SV_ModStart> uinput_fd , UI_DEV_DESTROY )
"
817,"CWE-119 static int calc_pframe_target_size_one_pass_vbr ( const VP9_COMP * const cpi ) { static const int af_ratio = 10 ; const RATE_CONTROL * const rc = & cpi -> rc ; int target ; # if USE_ALTREF_FOR_ONE_PASS target = ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) ? <S2SV_StartBug> ( rc -> av_per_frame_bandwidth * rc -> baseline_gf_interval * af_ratio ) / <S2SV_EndBug> ( rc -> baseline_gf_interval + af_ratio - 1 ) : <S2SV_StartBug> ( rc -> av_per_frame_bandwidth * rc -> baseline_gf_interval ) / <S2SV_EndBug> ( rc -> baseline_gf_interval + af_ratio - 1 ) ; # else <S2SV_StartBug> target = rc -> av_per_frame_bandwidth ; <S2SV_EndBug> # endif return vp9_rc_clamp_pframe_target_size ( cpi , target ) ; }
","<S2SV_ModStart> ( rc -> avg_frame_bandwidth <S2SV_ModEnd> * rc -> <S2SV_ModStart> ( rc -> avg_frame_bandwidth <S2SV_ModEnd> * rc -> <S2SV_ModStart> = rc -> avg_frame_bandwidth <S2SV_ModEnd> ; # endif
"
818,"CWE-668 int main ( int argc , const char * argv [ ] ) { struct group * grent ; const char * cmd ; const char * path ; int i ; struct passwd * pw ; grent = getgrnam ( ABUILD_GROUP ) ; if ( grent == NULL ) errx ( 1 , ""%s:<S2SV_blank>Group<S2SV_blank>not<S2SV_blank>found"" , ABUILD_GROUP ) ; char * name = NULL ; pw = getpwuid ( getuid ( ) ) ; if ( pw ) name = pw -> pw_name ; if ( ! is_in_group ( grent -> gr_gid ) ) { errx ( 1 , ""User<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>member<S2SV_blank>of<S2SV_blank>group<S2SV_blank>%s\\n"" , name ? name : ""(unknown)"" , ABUILD_GROUP ) ; } if ( name == NULL ) warnx ( ""Could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>username<S2SV_blank>for<S2SV_blank>uid<S2SV_blank>%d\\n"" , getuid ( ) ) ; setenv ( ""USER"" , name ? : """" , 1 ) ; cmd = strrchr ( argv [ 0 ] , '/' ) ; if ( cmd ) cmd ++ ; else cmd = argv [ 0 ] ; cmd = strchr ( cmd , '-' ) ; if ( cmd == NULL ) errx ( 1 , ""Calling<S2SV_blank>command<S2SV_blank>has<S2SV_blank>no<S2SV_blank>\'-\'"" ) ; cmd ++ ; path = get_command_path ( cmd ) ; if ( path == NULL ) errx ( 1 , ""%s:<S2SV_blank>Not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>subcommand"" , cmd ) ; for ( i = 1 ; i < argc ; i ++ ) <S2SV_StartBug> if ( strcmp ( argv [ i ] , ""--allow-untrusted"" ) == 0 ) <S2SV_EndBug> errx ( 1 , ""%s:<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>option"" , ""--allow-untrusted"" ) ; argv [ 0 ] = path ; setuid ( 0 ) ; setgid ( 0 ) ; execv ( path , ( char * const * ) argv ) ; perror ( path ) ; return 1 ; }
","<S2SV_ModStart> i ++ ) check_option ( argv [ i ] <S2SV_ModEnd> ) ; argv
"
819,"CWE-125 PyObject * ast2obj_mod ( void * _o ) { mod_ty o = ( mod_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } switch ( o -> kind ) { case Module_kind : result = PyType_GenericNew ( Module_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Module . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Module . type_ignores , ast2obj_type_ignore ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_ignores , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Interactive_kind : result = PyType_GenericNew ( Interactive_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Interactive . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Expression_kind : result = PyType_GenericNew ( Expression_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Expression . body ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case FunctionType_kind : result = PyType_GenericNew ( FunctionType_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . FunctionType . argtypes , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_argtypes , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . FunctionType . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Suite_kind : result = PyType_GenericNew ( Suite_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Suite . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; } return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
","<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
"
820,"CWE-835 static void feed_table_block_tag ( struct table * tbl , char * line , struct table_mode * mode , int indent , int cmd ) { int offset ; if ( mode -> indent_level <= 0 && indent == - 1 ) return ; if ( mode -> indent_level >= CHAR_MAX && indent == 1 ) return ; setwidth ( tbl , mode ) ; feed_table_inline_tag ( tbl , line , mode , - 1 ) ; clearcontentssize ( tbl , mode ) ; if ( indent == 1 ) { mode -> indent_level ++ ; if ( mode -> indent_level <= MAX_INDENT_LEVEL ) tbl -> indent += INDENT_INCR ; } else if ( indent == - 1 ) { mode -> indent_level -- ; if ( mode -> indent_level < MAX_INDENT_LEVEL ) tbl -> indent -= INDENT_INCR ; } <S2SV_StartBug> offset = tbl -> indent ; <S2SV_EndBug> if ( cmd == HTML_DT ) { if ( mode -> indent_level > 0 && mode -> indent_level <= MAX_INDENT_LEVEL ) offset -= INDENT_INCR ; <S2SV_StartBug> } <S2SV_EndBug> if ( tbl -> indent > 0 ) { check_minimum0 ( tbl , 0 ) ; addcontentssize ( tbl , offset ) ; } }
","<S2SV_ModStart> INDENT_INCR ; } if ( tbl -> indent < 0 ) tbl -> indent = 0 ; <S2SV_ModStart> -= INDENT_INCR ; if ( offset < 0 ) offset = 0 ;
"
821,"CWE-189 static int cdf_check_stream_offset ( const cdf_stream_t * sst , const cdf_header_t * h , const void * p , size_t tail , int line ) { const char * b = ( const char * ) sst -> sst_tab ; const char * e = ( ( const char * ) p ) + tail ; <S2SV_StartBug> ( void ) & line ; <S2SV_EndBug> <S2SV_StartBug> if ( e >= b && ( size_t ) ( e - b ) <= CDF_SEC_SIZE ( h ) * sst -> sst_len ) <S2SV_EndBug> return 0 ; DPRINTF ( ( ""%d:<S2SV_blank>offset<S2SV_blank>begin<S2SV_blank>%p<S2SV_blank><<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>||<S2SV_blank>%"" SIZE_T_FORMAT ""u"" ""<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>[%"" SIZE_T_FORMAT ""u<S2SV_blank>%"" SIZE_T_FORMAT ""u]\\n"" , line , b , e , ( size_t ) ( e - b ) , <S2SV_StartBug> CDF_SEC_SIZE ( h ) * sst -> sst_len , CDF_SEC_SIZE ( h ) , sst -> sst_len ) ) ; <S2SV_EndBug> errno = EFTYPE ; return - 1 ; }
","<S2SV_ModStart> + tail ; size_t ss = sst -> sst_dirlen < h -> h_min_size_standard_stream ? CDF_SHORT_SEC_SIZE ( h ) : CDF_SEC_SIZE ( h ) ; <S2SV_ModStart> b ) <= ss <S2SV_ModEnd> * sst -> <S2SV_ModStart> b ) , ss <S2SV_ModEnd> * sst -> <S2SV_ModStart> -> sst_len , ss <S2SV_ModEnd> , sst ->
"
822,"CWE-674 int yyparse ( void * yyscanner , HEX_LEX_ENVIRONMENT * lex_env ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Starting<S2SV_blank>parse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memory<S2SV_blank>exhausted"" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , ""Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n"" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , ""Entering<S2SV_blank>state<S2SV_blank>%d\\n"" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , ""Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>"" ) ) ; yychar = yylex ( & yylval , yyscanner , lex_env ) ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , ""Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n"" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( ""Next<S2SV_blank>token<S2SV_blank>is"" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( ""Shifting"" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 2 : <S2SV_StartBug> # line 106 ""hex_grammar.y"" <S2SV_EndBug> { RE_AST * re_ast = yyget_extra ( yyscanner ) ; re_ast -> root_node = ( yyvsp [ - 1 ] . re_node ) ; } <S2SV_StartBug> # line 1330 ""hex_grammar.c"" <S2SV_EndBug> break ; case 3 : <S2SV_StartBug> # line 115 ""hex_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1338 ""hex_grammar.c"" <S2SV_EndBug> break ; case 4 : <S2SV_StartBug> # line 119 ""hex_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1351 ""hex_grammar.c"" <S2SV_EndBug> break ; case 5 : <S2SV_StartBug> # line 128 ""hex_grammar.y"" <S2SV_EndBug> { RE_NODE * new_concat ; RE_NODE * leftmost_concat = NULL ; <S2SV_StartBug> RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ; <S2SV_EndBug> ( yyval . re_node ) = NULL ; while ( leftmost_node -> type == RE_NODE_CONCAT ) { leftmost_concat = leftmost_node ; leftmost_node = leftmost_node -> left ; } new_concat = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 2 ] . re_node ) , leftmost_node ) ; if ( new_concat != NULL ) { if ( leftmost_concat != NULL ) { leftmost_concat -> left = new_concat ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , new_concat , ( yyvsp [ 0 ] . re_node ) ) ; } } DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1413 ""hex_grammar.c"" <S2SV_EndBug> break ; case 6 : <S2SV_StartBug> # line 190 ""hex_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1421 ""hex_grammar.c"" <S2SV_EndBug> break ; case 7 : <S2SV_StartBug> # line 194 ""hex_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1434 ""hex_grammar.c"" <S2SV_EndBug> break ; case 8 : <S2SV_StartBug> # line 207 ""hex_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1442 ""hex_grammar.c"" <S2SV_EndBug> break ; case 9 : <S2SV_StartBug> # line 211 ""hex_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; ( yyval . re_node ) -> greedy = FALSE ; } <S2SV_StartBug> # line 1451 ""hex_grammar.c"" <S2SV_EndBug> break ; case 10 : <S2SV_StartBug> # line 220 ""hex_grammar.y"" <S2SV_EndBug> { lex_env -> token_count ++ ; if ( lex_env -> token_count > MAX_HEX_STRING_TOKENS ) { yr_re_node_destroy ( ( yyvsp [ 0 ] . re_node ) ) ; yyerror ( yyscanner , lex_env , ""string<S2SV_blank>too<S2SV_blank>long"" ) ; YYABORT ; } ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1468 ""hex_grammar.c"" <S2SV_EndBug> break ; case 11 : <S2SV_StartBug> # line 233 ""hex_grammar.y"" <S2SV_EndBug> { lex_env -> inside_or ++ ; } <S2SV_StartBug> # line 1476 ""hex_grammar.c"" <S2SV_EndBug> break ; case 12 : <S2SV_StartBug> # line 237 ""hex_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ - 1 ] . re_node ) ; lex_env -> inside_or -- ; } <S2SV_StartBug> # line 1485 ""hex_grammar.c"" <S2SV_EndBug> break ; case 13 : <S2SV_StartBug> # line 246 ""hex_grammar.y"" <S2SV_EndBug> { if ( ( yyvsp [ - 1 ] . integer ) <= 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } if ( lex_env -> inside_or && ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) { yyerror ( yyscanner , lex_env , ""jumps<S2SV_blank>over<S2SV_blank>"" STR ( STRING_CHAINING_THRESHOLD ) ""<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 1 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; } <S2SV_StartBug> # line 1512 ""hex_grammar.c"" <S2SV_EndBug> break ; case 14 : <S2SV_StartBug> # line 269 ""hex_grammar.y"" <S2SV_EndBug> { if ( lex_env -> inside_or && ( ( yyvsp [ - 3 ] . integer ) > STRING_CHAINING_THRESHOLD || ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) ) { yyerror ( yyscanner , lex_env , ""jumps<S2SV_blank>over<S2SV_blank>"" STR ( STRING_CHAINING_THRESHOLD ) ""<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) < 0 || ( yyvsp [ - 1 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) > ( yyvsp [ - 1 ] . integer ) ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>jump<S2SV_blank>range"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 3 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; } <S2SV_StartBug> # line 1548 ""hex_grammar.c"" <S2SV_EndBug> break ; case 15 : <S2SV_StartBug> # line 301 ""hex_grammar.y"" <S2SV_EndBug> { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , ""unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } if ( ( yyvsp [ - 2 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 2 ] . integer ) ; ( yyval . re_node ) -> end = INT_MAX ; } <S2SV_StartBug> # line 1574 ""hex_grammar.c"" <S2SV_EndBug> break ; case 16 : <S2SV_StartBug> # line 323 ""hex_grammar.y"" <S2SV_EndBug> { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , ""unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = 0 ; ( yyval . re_node ) -> end = INT_MAX ; } <S2SV_StartBug> # line 1594 ""hex_grammar.c"" <S2SV_EndBug> break ; case 17 : <S2SV_StartBug> # line 343 ""hex_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1602 ""hex_grammar.c"" <S2SV_EndBug> break ; case 18 : <S2SV_StartBug> # line 347 ""hex_grammar.y"" <S2SV_EndBug> { mark_as_not_fast_regexp ( ) ; <S2SV_StartBug> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; <S2SV_EndBug> DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1617 ""hex_grammar.c"" <S2SV_EndBug> break ; case 19 : <S2SV_StartBug> # line 361 ""hex_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( int ) ( yyvsp [ 0 ] . integer ) ; } <S2SV_StartBug> # line 1629 ""hex_grammar.c"" <S2SV_EndBug> break ; case 20 : <S2SV_StartBug> # line 369 ""hex_grammar.y"" <S2SV_EndBug> { uint8_t mask = ( uint8_t ) ( ( yyvsp [ 0 ] . integer ) >> 8 ) ; if ( mask == 0x00 ) { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_MASKED_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( yyvsp [ 0 ] . integer ) & 0xFF ; ( yyval . re_node ) -> mask = mask ; } } <S2SV_StartBug> # line 1653 ""hex_grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> # line 1657 ""hex_grammar.c"" <S2SV_EndBug> default : break ; } YY_SYMBOL_PRINT ( ""-><S2SV_blank>$$<S2SV_blank>="" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( yyscanner , lex_env , YY_ ( ""syntax<S2SV_blank>error"" ) ) ; # else # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) { char const * yymsgp = YY_ ( ""syntax<S2SV_blank>error"" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) yymsgp = yymsg ; else if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yyscanner , lex_env , yymsgp ) ; if ( yysyntax_error_status == 2 ) goto yyexhaustedlab ; } # undef YYSYNTAX_ERROR # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( ""Error:<S2SV_blank>discarding"" , yytoken , & yylval , yyscanner , lex_env ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( ""Error:<S2SV_blank>popping"" , yystos [ yystate ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END YY_SYMBOL_PRINT ( ""Shifting"" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab : yyerror ( yyscanner , lex_env , YY_ ( ""memory<S2SV_blank>exhausted"" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( ""Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead"" , yytoken , & yylval , yyscanner , lex_env ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( ""Cleanup:<S2SV_blank>popping"" , yystos [ * yyssp ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return yyresult ; }
","<S2SV_ModStart> : # line 113 <S2SV_ModEnd> ""hex_grammar.y"" { RE_AST <S2SV_ModStart> } # line 1337 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 122 <S2SV_ModEnd> ""hex_grammar.y"" { ( <S2SV_ModStart> } # line 1345 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 126 ""hex_grammar.y"" { incr_ast_levels ( ) ; <S2SV_ModEnd> ( yyval . <S2SV_ModStart> } # line 1360 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 137 <S2SV_ModEnd> ""hex_grammar.y"" { RE_NODE <S2SV_ModStart> ] . re_node ) ; incr_ast_levels ( <S2SV_ModStart> } # line 1424 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 201 <S2SV_ModEnd> ""hex_grammar.y"" { ( <S2SV_ModStart> } # line 1432 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 205 ""hex_grammar.y"" { incr_ast_levels ( ) ; <S2SV_ModEnd> ( yyval . <S2SV_ModStart> } # line 1447 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 220 <S2SV_ModEnd> ""hex_grammar.y"" { ( <S2SV_ModStart> } # line 1455 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 224 <S2SV_ModEnd> ""hex_grammar.y"" { ( <S2SV_ModStart> } # line 1464 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 233 <S2SV_ModEnd> ""hex_grammar.y"" { lex_env <S2SV_ModStart> } # line 1481 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 246 <S2SV_ModEnd> ""hex_grammar.y"" { lex_env <S2SV_ModStart> } # line 1489 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 250 <S2SV_ModEnd> ""hex_grammar.y"" { ( <S2SV_ModStart> } # line 1498 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 259 <S2SV_ModEnd> ""hex_grammar.y"" { if <S2SV_ModStart> } # line 1525 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 282 <S2SV_ModEnd> ""hex_grammar.y"" { if <S2SV_ModStart> } # line 1561 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 314 <S2SV_ModEnd> ""hex_grammar.y"" { if <S2SV_ModStart> } # line 1587 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 336 <S2SV_ModEnd> ""hex_grammar.y"" { if <S2SV_ModStart> } # line 1607 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 356 <S2SV_ModEnd> ""hex_grammar.y"" { ( <S2SV_ModStart> } # line 1615 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 360 <S2SV_ModEnd> ""hex_grammar.y"" { mark_as_not_fast_regexp <S2SV_ModStart> ( ) ; incr_ast_levels ( ) ; <S2SV_ModStart> } # line 1631 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 375 <S2SV_ModEnd> ""hex_grammar.y"" { ( <S2SV_ModStart> } # line 1643 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 383 <S2SV_ModEnd> ""hex_grammar.y"" { uint8_t <S2SV_ModStart> } # line 1667 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> ; # line 1671 <S2SV_ModEnd> ""hex_grammar.c"" default :
"
823,"CWE-119 static void optimize_b ( MACROBLOCK * mb , int ib , int type , ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l ) { BLOCK * b ; BLOCKD * d ; vp8_token_state tokens [ 17 ] [ 2 ] ; unsigned best_mask [ 2 ] ; const short * dequant_ptr ; const short * coeff_ptr ; short * qcoeff_ptr ; short * dqcoeff_ptr ; int eob ; int i0 ; int rc ; int x ; int sz = 0 ; int next ; int rdmult ; int rddiv ; int final_eob ; int rd_cost0 ; int rd_cost1 ; int rate0 ; int rate1 ; int error0 ; int error1 ; int t0 ; int t1 ; int best ; int band ; int pt ; int i ; int err_mult = plane_rd_mult [ type ] ; b = & mb -> block [ ib ] ; d = & mb -> e_mbd . block [ ib ] ; <S2SV_StartBug> # if 0 <S2SV_EndBug> vp8_strict_quantize_b ( b , d ) ; # endif dequant_ptr = d -> dequant ; coeff_ptr = b -> coeff ; qcoeff_ptr = d -> qcoeff ; dqcoeff_ptr = d -> dqcoeff ; i0 = ! type ; eob = * d -> eob ; rdmult = mb -> rdmult * err_mult ; if ( mb -> e_mbd . mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) rdmult = ( rdmult * 9 ) >> 4 ; rddiv = mb -> rddiv ; best_mask [ 0 ] = best_mask [ 1 ] = 0 ; tokens [ eob ] [ 0 ] . rate = 0 ; tokens [ eob ] [ 0 ] . error = 0 ; tokens [ eob ] [ 0 ] . next = 16 ; tokens [ eob ] [ 0 ] . token = DCT_EOB_TOKEN ; tokens [ eob ] [ 0 ] . qc = 0 ; * ( tokens [ eob ] + 1 ) = * ( tokens [ eob ] + 0 ) ; next = eob ; for ( i = eob ; i -- > i0 ; ) { int base_bits ; int d2 ; int dx ; rc = vp8_default_zig_zag1d [ i ] ; x = qcoeff_ptr [ rc ] ; if ( x ) { int shortcut = 0 ; error0 = tokens [ next ] [ 0 ] . error ; error1 = tokens [ next ] [ 1 ] . error ; rate0 = tokens [ next ] [ 0 ] . rate ; rate1 = tokens [ next ] [ 1 ] . rate ; t0 = ( vp8_dct_value_tokens_ptr + x ) -> Token ; if ( next < 16 ) { band = vp8_coef_bands [ i + 1 ] ; pt = vp8_prev_token_class [ t0 ] ; rate0 += mb -> token_costs [ type ] [ band ] [ pt ] [ tokens [ next ] [ 0 ] . token ] ; rate1 += mb -> token_costs [ type ] [ band ] [ pt ] [ tokens [ next ] [ 1 ] . token ] ; } rd_cost0 = RDCOST ( rdmult , rddiv , rate0 , error0 ) ; rd_cost1 = RDCOST ( rdmult , rddiv , rate1 , error1 ) ; if ( rd_cost0 == rd_cost1 ) { rd_cost0 = RDTRUNC ( rdmult , rddiv , rate0 , error0 ) ; rd_cost1 = RDTRUNC ( rdmult , rddiv , rate1 , error1 ) ; } best = rd_cost1 < rd_cost0 ; base_bits = * ( vp8_dct_value_cost_ptr + x ) ; dx = dqcoeff_ptr [ rc ] - coeff_ptr [ rc ] ; d2 = dx * dx ; tokens [ i ] [ 0 ] . rate = base_bits + ( best ? rate1 : rate0 ) ; tokens [ i ] [ 0 ] . error = d2 + ( best ? error1 : error0 ) ; tokens [ i ] [ 0 ] . next = next ; tokens [ i ] [ 0 ] . token = t0 ; tokens [ i ] [ 0 ] . qc = x ; best_mask [ 0 ] |= best << i ; rate0 = tokens [ next ] [ 0 ] . rate ; rate1 = tokens [ next ] [ 1 ] . rate ; if ( ( abs ( x ) * dequant_ptr [ rc ] > abs ( coeff_ptr [ rc ] ) ) && ( abs ( x ) * dequant_ptr [ rc ] < abs ( coeff_ptr [ rc ] ) + dequant_ptr [ rc ] ) ) shortcut = 1 ; else shortcut = 0 ; if ( shortcut ) { sz = - ( x < 0 ) ; x -= 2 * sz + 1 ; } if ( ! x ) { t0 = tokens [ next ] [ 0 ] . token == DCT_EOB_TOKEN ? DCT_EOB_TOKEN : ZERO_TOKEN ; t1 = tokens [ next ] [ 1 ] . token == DCT_EOB_TOKEN ? DCT_EOB_TOKEN : ZERO_TOKEN ; } else { t0 = t1 = ( vp8_dct_value_tokens_ptr + x ) -> Token ; } if ( next < 16 ) { band = vp8_coef_bands [ i + 1 ] ; if ( t0 != DCT_EOB_TOKEN ) { pt = vp8_prev_token_class [ t0 ] ; rate0 += mb -> token_costs [ type ] [ band ] [ pt ] [ tokens [ next ] [ 0 ] . token ] ; } if ( t1 != DCT_EOB_TOKEN ) { pt = vp8_prev_token_class [ t1 ] ; rate1 += mb -> token_costs [ type ] [ band ] [ pt ] [ tokens [ next ] [ 1 ] . token ] ; } } rd_cost0 = RDCOST ( rdmult , rddiv , rate0 , error0 ) ; rd_cost1 = RDCOST ( rdmult , rddiv , rate1 , error1 ) ; if ( rd_cost0 == rd_cost1 ) { rd_cost0 = RDTRUNC ( rdmult , rddiv , rate0 , error0 ) ; rd_cost1 = RDTRUNC ( rdmult , rddiv , rate1 , error1 ) ; } best = rd_cost1 < rd_cost0 ; base_bits = * ( vp8_dct_value_cost_ptr + x ) ; if ( shortcut ) { dx -= ( dequant_ptr [ rc ] + sz ) ^ sz ; d2 = dx * dx ; } tokens [ i ] [ 1 ] . rate = base_bits + ( best ? rate1 : rate0 ) ; tokens [ i ] [ 1 ] . error = d2 + ( best ? error1 : error0 ) ; tokens [ i ] [ 1 ] . next = next ; tokens [ i ] [ 1 ] . token = best ? t1 : t0 ; tokens [ i ] [ 1 ] . qc = x ; best_mask [ 1 ] |= best << i ; next = i ; } else { band = vp8_coef_bands [ i + 1 ] ; t0 = tokens [ next ] [ 0 ] . token ; t1 = tokens [ next ] [ 1 ] . token ; if ( t0 != DCT_EOB_TOKEN ) { tokens [ next ] [ 0 ] . rate += mb -> token_costs [ type ] [ band ] [ 0 ] [ t0 ] ; tokens [ next ] [ 0 ] . token = ZERO_TOKEN ; } if ( t1 != DCT_EOB_TOKEN ) { tokens [ next ] [ 1 ] . rate += mb -> token_costs [ type ] [ band ] [ 0 ] [ t1 ] ; tokens [ next ] [ 1 ] . token = ZERO_TOKEN ; } } } band = vp8_coef_bands [ i + 1 ] ; VP8_COMBINEENTROPYCONTEXTS ( pt , * a , * l ) ; rate0 = tokens [ next ] [ 0 ] . rate ; rate1 = tokens [ next ] [ 1 ] . rate ; error0 = tokens [ next ] [ 0 ] . error ; error1 = tokens [ next ] [ 1 ] . error ; t0 = tokens [ next ] [ 0 ] . token ; t1 = tokens [ next ] [ 1 ] . token ; rate0 += mb -> token_costs [ type ] [ band ] [ pt ] [ t0 ] ; rate1 += mb -> token_costs [ type ] [ band ] [ pt ] [ t1 ] ; rd_cost0 = RDCOST ( rdmult , rddiv , rate0 , error0 ) ; rd_cost1 = RDCOST ( rdmult , rddiv , rate1 , error1 ) ; if ( rd_cost0 == rd_cost1 ) { rd_cost0 = RDTRUNC ( rdmult , rddiv , rate0 , error0 ) ; rd_cost1 = RDTRUNC ( rdmult , rddiv , rate1 , error1 ) ; } best = rd_cost1 < rd_cost0 ; final_eob = i0 - 1 ; for ( i = next ; i < eob ; i = next ) { x = tokens [ i ] [ best ] . qc ; if ( x ) final_eob = i ; rc = vp8_default_zig_zag1d [ i ] ; qcoeff_ptr [ rc ] = x ; dqcoeff_ptr [ rc ] = x * dequant_ptr [ rc ] ; next = tokens [ i ] [ best ] . next ; best = ( best_mask [ best ] >> i ) & 1 ; } final_eob ++ ; * a = * l = ( final_eob != ! type ) ; * d -> eob = ( char ) final_eob ; }
","<S2SV_ModStart> ib ] ; <S2SV_ModEnd> dequant_ptr = d
"
824,"CWE-000 static int process_options ( int argc , char * argv [ ] , char * operation ) { int error = 0 ; int i = 0 ; if ( ( error = handle_options ( & argc , & argv , my_long_options , get_one_option ) ) ) goto exit ; if ( opt_print_defaults ) { error = - 1 ; goto exit ; } if ( opt_basedir ) { i = ( int ) strlength ( opt_basedir ) ; if ( opt_basedir [ i - 1 ] != FN_LIBCHAR || opt_basedir [ i - 1 ] != FN_LIBCHAR2 ) { char buff [ FN_REFLEN ] ; <S2SV_StartBug> strncpy ( buff , opt_basedir , sizeof ( buff ) - 1 ) ; <S2SV_EndBug> # ifdef __WIN__ strncat ( buff , ""/"" , sizeof ( buff ) - strlen ( buff ) - 1 ) ; # else strncat ( buff , FN_DIRSEP , sizeof ( buff ) - strlen ( buff ) - 1 ) ; # endif buff [ sizeof ( buff ) - 1 ] = 0 ; my_free ( opt_basedir ) ; opt_basedir = my_strdup ( buff , MYF ( MY_FAE ) ) ; } } if ( ! opt_no_defaults && ( ( error = get_default_values ( ) ) ) ) { error = - 1 ; goto exit ; } strcpy ( operation , """" ) ; if ( ( error = check_options ( argc , argv , operation ) ) ) { goto exit ; } if ( opt_verbose ) { printf ( ""#<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>basedir<S2SV_blank>=<S2SV_blank>%s\\n"" , opt_basedir ) ; printf ( ""#<S2SV_blank>plugin_dir<S2SV_blank>=<S2SV_blank>%s\\n"" , opt_plugin_dir ) ; printf ( ""#<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>datadir<S2SV_blank>=<S2SV_blank>%s\\n"" , opt_datadir ) ; printf ( ""#<S2SV_blank>plugin_ini<S2SV_blank>=<S2SV_blank>%s\\n"" , opt_plugin_ini ) ; } exit : return error ; }
","<S2SV_ModStart> FN_REFLEN ] ; memset ( buff , 0 , sizeof ( buff ) ) ;
"
825,"CWE-20 int user_update ( struct key * key , struct key_preparsed_payload * prep ) { struct user_key_payload * zap = NULL ; int ret ; ret = key_payload_reserve ( key , prep -> datalen ) ; if ( ret < 0 ) return ret ; key -> expiry = prep -> expiry ; <S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> zap = dereference_key_locked ( key ) ; rcu_assign_keypointer ( key , prep -> payload . data [ 0 ] ) ; prep -> payload . data [ 0 ] = NULL ; if ( zap ) call_rcu ( & zap -> rcu , user_free_payload_rcu ) ; return ret ; }
","<S2SV_ModStart> ; if ( key_is_positive ( key <S2SV_ModEnd> ) ) zap
"
826,"CWE-200 static int hci_sock_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct hci_ufilter uf ; struct sock * sk = sock -> sk ; int len , opt , err = 0 ; BT_DBG ( ""sk<S2SV_blank>%p,<S2SV_blank>opt<S2SV_blank>%d"" , sk , optname ) ; if ( get_user ( len , optlen ) ) return - EFAULT ; lock_sock ( sk ) ; if ( hci_pi ( sk ) -> channel != HCI_CHANNEL_RAW ) { err = - EINVAL ; goto done ; } switch ( optname ) { case HCI_DATA_DIR : if ( hci_pi ( sk ) -> cmsg_mask & HCI_CMSG_DIR ) opt = 1 ; else opt = 0 ; if ( put_user ( opt , optval ) ) err = - EFAULT ; break ; case HCI_TIME_STAMP : if ( hci_pi ( sk ) -> cmsg_mask & HCI_CMSG_TSTAMP ) opt = 1 ; else opt = 0 ; if ( put_user ( opt , optval ) ) err = - EFAULT ; break ; case HCI_FILTER : { <S2SV_StartBug> struct hci_filter * f = & hci_pi ( sk ) -> filter ; <S2SV_EndBug> uf . type_mask = f -> type_mask ; uf . opcode = f -> opcode ; uf . event_mask [ 0 ] = * ( ( u32 * ) f -> event_mask + 0 ) ; uf . event_mask [ 1 ] = * ( ( u32 * ) f -> event_mask + 1 ) ; } len = min_t ( unsigned int , len , sizeof ( uf ) ) ; if ( copy_to_user ( optval , & uf , len ) ) err = - EFAULT ; break ; default : err = - ENOPROTOOPT ; break ; } done : release_sock ( sk ) ; return err ; }
","<S2SV_ModStart> ) -> filter ; memset ( & uf , 0 , sizeof ( uf ) )
"
827,"CWE-119 int vp8_decode_frame ( VP8D_COMP * pbi ) { vp8_reader * const bc = & pbi -> mbc [ 8 ] ; VP8_COMMON * const pc = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; const unsigned char * data = pbi -> fragments . ptrs [ 0 ] ; const unsigned char * data_end = data + pbi -> fragments . sizes [ 0 ] ; ptrdiff_t first_partition_length_in_bytes ; int i , j , k , l ; const int * const mb_feature_data_bits = vp8_mb_feature_data_bits ; int corrupt_tokens = 0 ; int prev_independent_partitions = pbi -> independent_partitions ; YV12_BUFFER_CONFIG * yv12_fb_new = pbi -> dec_fb_ref [ INTRA_FRAME ] ; xd -> corrupted = 0 ; yv12_fb_new -> corrupted = 0 ; if ( data_end - data < 3 ) { if ( ! pbi -> ec_active ) { vpx_internal_error ( & pc -> error , VPX_CODEC_CORRUPT_FRAME , ""Truncated<S2SV_blank>packet"" ) ; } pc -> frame_type = INTER_FRAME ; pc -> version = 0 ; pc -> show_frame = 1 ; first_partition_length_in_bytes = 0 ; } else { unsigned char clear_buffer [ 10 ] ; const unsigned char * clear = data ; if ( pbi -> decrypt_cb ) { <S2SV_StartBug> int n = ( int ) ( data_end - data ) ; <S2SV_EndBug> if ( n > 10 ) n = 10 ; pbi -> decrypt_cb ( pbi -> decrypt_state , data , clear_buffer , n ) ; clear = clear_buffer ; } pc -> frame_type = ( FRAME_TYPE ) ( clear [ 0 ] & 1 ) ; pc -> version = ( clear [ 0 ] >> 1 ) & 7 ; pc -> show_frame = ( clear [ 0 ] >> 4 ) & 1 ; first_partition_length_in_bytes = ( clear [ 0 ] | ( clear [ 1 ] << 8 ) | ( clear [ 2 ] << 16 ) ) >> 5 ; if ( ! pbi -> ec_active && ( data + first_partition_length_in_bytes > data_end || data + first_partition_length_in_bytes < data ) ) vpx_internal_error ( & pc -> error , VPX_CODEC_CORRUPT_FRAME , ""Truncated<S2SV_blank>packet<S2SV_blank>or<S2SV_blank>corrupt<S2SV_blank>partition<S2SV_blank>0<S2SV_blank>length"" ) ; data += 3 ; clear += 3 ; vp8_setup_version ( pc ) ; if ( pc -> frame_type == KEY_FRAME ) { if ( ! pbi -> ec_active || data + 3 < data_end ) { if ( clear [ 0 ] != 0x9d || clear [ 1 ] != 0x01 || clear [ 2 ] != 0x2a ) vpx_internal_error ( & pc -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Invalid<S2SV_blank>frame<S2SV_blank>sync<S2SV_blank>code"" ) ; } if ( ! pbi -> ec_active || data + 6 < data_end ) { pc -> Width = ( clear [ 3 ] | ( clear [ 4 ] << 8 ) ) & 0x3fff ; pc -> horiz_scale = clear [ 4 ] >> 6 ; pc -> Height = ( clear [ 5 ] | ( clear [ 6 ] << 8 ) ) & 0x3fff ; pc -> vert_scale = clear [ 6 ] >> 6 ; } data += 7 ; <S2SV_StartBug> clear += 7 ; <S2SV_EndBug> } else { <S2SV_StartBug> vpx_memcpy ( & xd -> pre , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & xd -> dst , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ; <S2SV_EndBug> } } if ( ( ! pbi -> decoded_key_frame && pc -> frame_type != KEY_FRAME ) ) { return - 1 ; } init_frame ( pbi ) ; if ( vp8dx_start_decode ( bc , data , ( unsigned int ) ( data_end - data ) , pbi -> decrypt_cb , pbi -> decrypt_state ) ) vpx_internal_error ( & pc -> error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>bool<S2SV_blank>decoder<S2SV_blank>0"" ) ; if ( pc -> frame_type == KEY_FRAME ) { ( void ) vp8_read_bit ( bc ) ; pc -> clamp_type = ( CLAMP_TYPE ) vp8_read_bit ( bc ) ; } xd -> segmentation_enabled = ( unsigned char ) vp8_read_bit ( bc ) ; if ( xd -> segmentation_enabled ) { xd -> update_mb_segmentation_map = ( unsigned char ) vp8_read_bit ( bc ) ; xd -> update_mb_segmentation_data = ( unsigned char ) vp8_read_bit ( bc ) ; if ( xd -> update_mb_segmentation_data ) { xd -> mb_segement_abs_delta = ( unsigned char ) vp8_read_bit ( bc ) ; <S2SV_StartBug> vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ; <S2SV_EndBug> for ( i = 0 ; i < MB_LVL_MAX ; i ++ ) { for ( j = 0 ; j < MAX_MB_SEGMENTS ; j ++ ) { if ( vp8_read_bit ( bc ) ) { xd -> segment_feature_data [ i ] [ j ] = ( signed char ) vp8_read_literal ( bc , mb_feature_data_bits [ i ] ) ; if ( vp8_read_bit ( bc ) ) xd -> segment_feature_data [ i ] [ j ] = - xd -> segment_feature_data [ i ] [ j ] ; } else xd -> segment_feature_data [ i ] [ j ] = 0 ; } } } if ( xd -> update_mb_segmentation_map ) { <S2SV_StartBug> vpx_memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ; <S2SV_EndBug> for ( i = 0 ; i < MB_FEATURE_TREE_PROBS ; i ++ ) { if ( vp8_read_bit ( bc ) ) xd -> mb_segment_tree_probs [ i ] = ( vp8_prob ) vp8_read_literal ( bc , 8 ) ; } } } else { xd -> update_mb_segmentation_map = 0 ; xd -> update_mb_segmentation_data = 0 ; } pc -> filter_type = ( LOOPFILTERTYPE ) vp8_read_bit ( bc ) ; pc -> filter_level = vp8_read_literal ( bc , 6 ) ; pc -> sharpness_level = vp8_read_literal ( bc , 3 ) ; xd -> mode_ref_lf_delta_update = 0 ; xd -> mode_ref_lf_delta_enabled = ( unsigned char ) vp8_read_bit ( bc ) ; if ( xd -> mode_ref_lf_delta_enabled ) { xd -> mode_ref_lf_delta_update = ( unsigned char ) vp8_read_bit ( bc ) ; if ( xd -> mode_ref_lf_delta_update ) { for ( i = 0 ; i < MAX_REF_LF_DELTAS ; i ++ ) { if ( vp8_read_bit ( bc ) ) { xd -> ref_lf_deltas [ i ] = ( signed char ) vp8_read_literal ( bc , 6 ) ; if ( vp8_read_bit ( bc ) ) xd -> ref_lf_deltas [ i ] = xd -> ref_lf_deltas [ i ] * - 1 ; } } for ( i = 0 ; i < MAX_MODE_LF_DELTAS ; i ++ ) { if ( vp8_read_bit ( bc ) ) { xd -> mode_lf_deltas [ i ] = ( signed char ) vp8_read_literal ( bc , 6 ) ; if ( vp8_read_bit ( bc ) ) xd -> mode_lf_deltas [ i ] = xd -> mode_lf_deltas [ i ] * - 1 ; } } } } setup_token_decoder ( pbi , data + first_partition_length_in_bytes ) ; xd -> current_bc = & pbi -> mbc [ 0 ] ; { int Q , q_update ; Q = vp8_read_literal ( bc , 7 ) ; pc -> base_qindex = Q ; q_update = 0 ; pc -> y1dc_delta_q = get_delta_q ( bc , pc -> y1dc_delta_q , & q_update ) ; pc -> y2dc_delta_q = get_delta_q ( bc , pc -> y2dc_delta_q , & q_update ) ; pc -> y2ac_delta_q = get_delta_q ( bc , pc -> y2ac_delta_q , & q_update ) ; pc -> uvdc_delta_q = get_delta_q ( bc , pc -> uvdc_delta_q , & q_update ) ; pc -> uvac_delta_q = get_delta_q ( bc , pc -> uvac_delta_q , & q_update ) ; if ( q_update ) vp8cx_init_de_quantizer ( pbi ) ; vp8_mb_init_dequantizer ( pbi , & pbi -> mb ) ; } if ( pc -> frame_type != KEY_FRAME ) { pc -> refresh_golden_frame = vp8_read_bit ( bc ) ; # if CONFIG_ERROR_CONCEALMENT xd -> corrupted |= vp8dx_bool_error ( bc ) ; if ( pbi -> ec_active && xd -> corrupted ) pc -> refresh_golden_frame = 0 ; # endif pc -> refresh_alt_ref_frame = vp8_read_bit ( bc ) ; # if CONFIG_ERROR_CONCEALMENT xd -> corrupted |= vp8dx_bool_error ( bc ) ; if ( pbi -> ec_active && xd -> corrupted ) pc -> refresh_alt_ref_frame = 0 ; # endif pc -> copy_buffer_to_gf = 0 ; if ( ! pc -> refresh_golden_frame ) pc -> copy_buffer_to_gf = vp8_read_literal ( bc , 2 ) ; # if CONFIG_ERROR_CONCEALMENT xd -> corrupted |= vp8dx_bool_error ( bc ) ; if ( pbi -> ec_active && xd -> corrupted ) pc -> copy_buffer_to_gf = 0 ; # endif pc -> copy_buffer_to_arf = 0 ; if ( ! pc -> refresh_alt_ref_frame ) pc -> copy_buffer_to_arf = vp8_read_literal ( bc , 2 ) ; # if CONFIG_ERROR_CONCEALMENT xd -> corrupted |= vp8dx_bool_error ( bc ) ; if ( pbi -> ec_active && xd -> corrupted ) pc -> copy_buffer_to_arf = 0 ; # endif pc -> ref_frame_sign_bias [ GOLDEN_FRAME ] = vp8_read_bit ( bc ) ; pc -> ref_frame_sign_bias [ ALTREF_FRAME ] = vp8_read_bit ( bc ) ; } pc -> refresh_entropy_probs = vp8_read_bit ( bc ) ; # if CONFIG_ERROR_CONCEALMENT xd -> corrupted |= vp8dx_bool_error ( bc ) ; if ( pbi -> ec_active && xd -> corrupted ) pc -> refresh_entropy_probs = 0 ; # endif if ( pc -> refresh_entropy_probs == 0 ) { <S2SV_StartBug> vpx_memcpy ( & pc -> lfc , & pc -> fc , sizeof ( pc -> fc ) ) ; <S2SV_EndBug> } pc -> refresh_last_frame = pc -> frame_type == KEY_FRAME || vp8_read_bit ( bc ) ; # if CONFIG_ERROR_CONCEALMENT xd -> corrupted |= vp8dx_bool_error ( bc ) ; if ( pbi -> ec_active && xd -> corrupted ) pc -> refresh_last_frame = 1 ; # endif if ( 0 ) { FILE * z = fopen ( ""decodestats.stt"" , ""a"" ) ; fprintf ( z , ""%6d<S2SV_blank>F:%d,G:%d,A:%d,L:%d,Q:%d\\n"" , pc -> current_video_frame , pc -> frame_type , pc -> refresh_golden_frame , pc -> refresh_alt_ref_frame , pc -> refresh_last_frame , pc -> base_qindex ) ; fclose ( z ) ; } { pbi -> independent_partitions = 1 ; for ( i = 0 ; i < BLOCK_TYPES ; i ++ ) for ( j = 0 ; j < COEF_BANDS ; j ++ ) for ( k = 0 ; k < PREV_COEF_CONTEXTS ; k ++ ) for ( l = 0 ; l < ENTROPY_NODES ; l ++ ) { vp8_prob * const p = pc -> fc . coef_probs [ i ] [ j ] [ k ] + l ; if ( vp8_read ( bc , vp8_coef_update_probs [ i ] [ j ] [ k ] [ l ] ) ) { * p = ( vp8_prob ) vp8_read_literal ( bc , 8 ) ; } if ( k > 0 && * p != pc -> fc . coef_probs [ i ] [ j ] [ k - 1 ] [ l ] ) pbi -> independent_partitions = 0 ; } } <S2SV_StartBug> vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ; <S2SV_EndBug> vp8_decode_mode_mvs ( pbi ) ; # if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_active && pbi -> mvs_corrupt_from_mb < ( unsigned int ) pc -> mb_cols * pc -> mb_rows ) { vp8_estimate_missing_mvs ( pbi ) ; } # endif <S2SV_StartBug> vpx_memset ( pc -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) * pc -> mb_cols ) ; <S2SV_EndBug> pbi -> frame_corrupt_residual = 0 ; # if CONFIG_MULTITHREAD if ( pbi -> b_multithreaded_rd && pc -> multi_token_partition != ONE_PARTITION ) { unsigned int thread ; vp8mt_decode_mb_rows ( pbi , xd ) ; vp8_yv12_extend_frame_borders ( yv12_fb_new ) ; for ( thread = 0 ; thread < pbi -> decoding_thread_count ; ++ thread ) corrupt_tokens |= pbi -> mb_row_di [ thread ] . mbd . corrupted ; } else # endif { decode_mb_rows ( pbi ) ; corrupt_tokens |= xd -> corrupted ; } yv12_fb_new -> corrupted = vp8dx_bool_error ( bc ) ; yv12_fb_new -> corrupted |= corrupt_tokens ; if ( ! pbi -> decoded_key_frame ) { if ( pc -> frame_type == KEY_FRAME && ! yv12_fb_new -> corrupted ) pbi -> decoded_key_frame = 1 ; else vpx_internal_error ( & pbi -> common . error , VPX_CODEC_CORRUPT_FRAME , ""A<S2SV_blank>stream<S2SV_blank>must<S2SV_blank>start<S2SV_blank>with<S2SV_blank>a<S2SV_blank>complete<S2SV_blank>key<S2SV_blank>frame"" ) ; } if ( pc -> refresh_entropy_probs == 0 ) { <S2SV_StartBug> vpx_memcpy ( & pc -> fc , & pc -> lfc , sizeof ( pc -> fc ) ) ; <S2SV_EndBug> pbi -> independent_partitions = prev_independent_partitions ; } # ifdef PACKET_TESTING { FILE * f = fopen ( ""decompressor.VP8"" , ""ab"" ) ; unsigned int size = pbi -> bc2 . pos + pbi -> bc . pos + 8 ; fwrite ( ( void * ) & size , 4 , 1 , f ) ; fwrite ( ( void * ) pbi -> Source , size , 1 , f ) ; fclose ( f ) ; } # endif return 0 ; }
","<S2SV_ModStart> ( int ) MIN ( sizeof ( clear_buffer ) , <S2SV_ModEnd> data_end - data <S2SV_ModStart> - data ) <S2SV_ModEnd> ; pbi -> <S2SV_ModStart> += 7 ; <S2SV_ModEnd> } else { <S2SV_ModStart> } else { memcpy <S2SV_ModEnd> ( & xd <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & xd <S2SV_ModStart> bc ) ; memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> update_mb_segmentation_map ) { memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> 0 ) { memcpy <S2SV_ModEnd> ( & pc <S2SV_ModStart> ; } } memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> } # endif memset <S2SV_ModEnd> ( pc -> <S2SV_ModStart> 0 ) { memcpy <S2SV_ModEnd> ( & pc
"
828,"CWE-772 getprivs_ret * get_privs_2_svc ( krb5_ui_4 * arg , struct svc_req * rqstp ) { static getprivs_ret ret ; <S2SV_StartBug> gss_buffer_desc client_name , service_name ; <S2SV_EndBug> OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_getprivs_ret , & ret ) ; if ( ( ret . code = new_server_handle ( * arg , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } ret . code = kadm5_get_privs ( ( void * ) handle , & ret . privs ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_get_privs"" , client_name . value , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_StartBug> exit_func : <S2SV_EndBug> free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> errmsg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
"
829,"CWE-000 void sctp_assoc_update ( struct sctp_association * asoc , struct sctp_association * new ) { struct sctp_transport * trans ; struct list_head * pos , * temp ; asoc -> c = new -> c ; asoc -> peer . rwnd = new -> peer . rwnd ; asoc -> peer . sack_needed = new -> peer . sack_needed ; <S2SV_StartBug> asoc -> peer . i = new -> peer . i ; <S2SV_EndBug> sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ; list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { trans = list_entry ( pos , struct sctp_transport , transports ) ; if ( ! sctp_assoc_lookup_paddr ( new , & trans -> ipaddr ) ) { sctp_assoc_rm_peer ( asoc , trans ) ; continue ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) sctp_transport_reset ( trans ) ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) { asoc -> next_tsn = new -> next_tsn ; asoc -> ctsn_ack_point = new -> ctsn_ack_point ; asoc -> adv_peer_ack_point = new -> adv_peer_ack_point ; sctp_ssnmap_clear ( asoc -> ssnmap ) ; sctp_ulpq_flush ( & asoc -> ulpq ) ; asoc -> overall_error_count = 0 ; } else { list_for_each_entry ( trans , & new -> peer . transport_addr_list , transports ) { if ( ! sctp_assoc_lookup_paddr ( asoc , & trans -> ipaddr ) ) sctp_assoc_add_peer ( asoc , & trans -> ipaddr , GFP_ATOMIC , trans -> state ) ; } asoc -> ctsn_ack_point = asoc -> next_tsn - 1 ; asoc -> adv_peer_ack_point = asoc -> ctsn_ack_point ; if ( ! asoc -> ssnmap ) { asoc -> ssnmap = new -> ssnmap ; new -> ssnmap = NULL ; } if ( ! asoc -> assoc_id ) { sctp_assoc_set_id ( asoc , GFP_ATOMIC ) ; } } kfree ( asoc -> peer . peer_random ) ; asoc -> peer . peer_random = new -> peer . peer_random ; new -> peer . peer_random = NULL ; kfree ( asoc -> peer . peer_chunks ) ; asoc -> peer . peer_chunks = new -> peer . peer_chunks ; new -> peer . peer_chunks = NULL ; kfree ( asoc -> peer . peer_hmacs ) ; asoc -> peer . peer_hmacs = new -> peer . peer_hmacs ; new -> peer . peer_hmacs = NULL ; sctp_auth_key_put ( asoc -> asoc_shared_key ) ; sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ; }
","<S2SV_ModStart> -> peer . auth_capable = new -> peer . auth_capable ; asoc -> peer .
"
830,"CWE-20 static int aac_send_raw_srb ( struct aac_dev * dev , void __user * arg ) { struct fib * srbfib ; int status ; struct aac_srb * srbcmd = NULL ; struct user_aac_srb * user_srbcmd = NULL ; struct user_aac_srb __user * user_srb = arg ; struct aac_srb_reply __user * user_reply ; struct aac_srb_reply * reply ; u32 fibsize = 0 ; u32 flags = 0 ; s32 rcode = 0 ; u32 data_dir ; void __user * sg_user [ 32 ] ; void * sg_list [ 32 ] ; u32 sg_indx = 0 ; u32 byte_count = 0 ; u32 actual_fibsize64 , actual_fibsize = 0 ; int i ; if ( dev -> in_reset ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>send<S2SV_blank>raw<S2SV_blank>srb<S2SV_blank>-EBUSY\\n"" ) ) ; return - EBUSY ; } if ( ! capable ( CAP_SYS_ADMIN ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>No<S2SV_blank>permission<S2SV_blank>to<S2SV_blank>send<S2SV_blank>raw<S2SV_blank>srb\\n"" ) ) ; return - EPERM ; } if ( ! ( srbfib = aac_fib_alloc ( dev ) ) ) { return - ENOMEM ; } aac_fib_init ( srbfib ) ; srbfib -> hw_fib_va -> header . XferState &= ~ cpu_to_le32 ( FastResponseCapable ) ; srbcmd = ( struct aac_srb * ) fib_data ( srbfib ) ; memset ( sg_list , 0 , sizeof ( sg_list ) ) ; if ( copy_from_user ( & fibsize , & user_srb -> count , sizeof ( u32 ) ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>data<S2SV_blank>size<S2SV_blank>from<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } <S2SV_StartBug> if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) ) { <S2SV_EndBug> rcode = - EINVAL ; goto cleanup ; } user_srbcmd = kmalloc ( fibsize , GFP_KERNEL ) ; if ( ! user_srbcmd ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>make<S2SV_blank>a<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>the<S2SV_blank>srb\\n"" ) ) ; rcode = - ENOMEM ; goto cleanup ; } if ( copy_from_user ( user_srbcmd , user_srb , fibsize ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>srb<S2SV_blank>from<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } user_reply = arg + fibsize ; flags = user_srbcmd -> flags ; srbcmd -> function = cpu_to_le32 ( SRBF_ExecuteScsi ) ; srbcmd -> channel = cpu_to_le32 ( user_srbcmd -> channel ) ; srbcmd -> id = cpu_to_le32 ( user_srbcmd -> id ) ; srbcmd -> lun = cpu_to_le32 ( user_srbcmd -> lun ) ; srbcmd -> timeout = cpu_to_le32 ( user_srbcmd -> timeout ) ; srbcmd -> flags = cpu_to_le32 ( flags ) ; srbcmd -> retry_limit = 0 ; srbcmd -> cdb_size = cpu_to_le32 ( user_srbcmd -> cdb_size ) ; memcpy ( srbcmd -> cdb , user_srbcmd -> cdb , sizeof ( srbcmd -> cdb ) ) ; switch ( flags & ( SRB_DataIn | SRB_DataOut ) ) { case SRB_DataOut : data_dir = DMA_TO_DEVICE ; break ; case ( SRB_DataIn | SRB_DataOut ) : data_dir = DMA_BIDIRECTIONAL ; break ; case SRB_DataIn : data_dir = DMA_FROM_DEVICE ; break ; default : data_dir = DMA_NONE ; } if ( user_srbcmd -> sg . count > ARRAY_SIZE ( sg_list ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>sg<S2SV_blank>entries<S2SV_blank>%d\\n"" , le32_to_cpu ( srbcmd -> sg . count ) ) ) ; rcode = - EINVAL ; goto cleanup ; } actual_fibsize = sizeof ( struct aac_srb ) - sizeof ( struct sgentry ) + ( ( user_srbcmd -> sg . count & 0xff ) * sizeof ( struct sgentry ) ) ; actual_fibsize64 = actual_fibsize + ( user_srbcmd -> sg . count & 0xff ) * ( sizeof ( struct sgentry64 ) - sizeof ( struct sgentry ) ) ; if ( ( actual_fibsize != fibsize ) && ( actual_fibsize64 != fibsize ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Bad<S2SV_blank>Size<S2SV_blank>specified<S2SV_blank>in<S2SV_blank>"" ""Raw<S2SV_blank>SRB<S2SV_blank>command<S2SV_blank>calculated<S2SV_blank>fibsize=%lu;%lu<S2SV_blank>"" ""user_srbcmd->sg.count=%d<S2SV_blank>aac_srb=%lu<S2SV_blank>sgentry=%lu;%lu<S2SV_blank>"" ""issued<S2SV_blank>fibsize=%d\\n"" , actual_fibsize , actual_fibsize64 , user_srbcmd -> sg . count , sizeof ( struct aac_srb ) , sizeof ( struct sgentry ) , sizeof ( struct sgentry64 ) , fibsize ) ) ; rcode = - EINVAL ; goto cleanup ; } if ( ( data_dir == DMA_NONE ) && user_srbcmd -> sg . count ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>SG<S2SV_blank>with<S2SV_blank>no<S2SV_blank>direction<S2SV_blank>specified<S2SV_blank>in<S2SV_blank>Raw<S2SV_blank>SRB<S2SV_blank>command\\n"" ) ) ; rcode = - EINVAL ; goto cleanup ; } byte_count = 0 ; if ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) { struct user_sgmap64 * upsg = ( struct user_sgmap64 * ) & user_srbcmd -> sg ; struct sgmap64 * psg = ( struct sgmap64 * ) & srbcmd -> sg ; if ( actual_fibsize64 == fibsize ) { actual_fibsize = actual_fibsize64 ; for ( i = 0 ; i < upsg -> count ; i ++ ) { u64 addr ; void * p ; if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) ) { rcode = - EINVAL ; goto cleanup ; } p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ) ; if ( ! p ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>SG<S2SV_blank>buffer<S2SV_blank>-<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>buffer<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>of<S2SV_blank>%d\\n"" , upsg -> sg [ i ] . count , i , upsg -> count ) ) ; rcode = - ENOMEM ; goto cleanup ; } addr = ( u64 ) upsg -> sg [ i ] . addr [ 0 ] ; addr += ( ( u64 ) upsg -> sg [ i ] . addr [ 1 ] ) << 32 ; sg_user [ i ] = ( void __user * ) ( uintptr_t ) addr ; sg_list [ i ] = p ; sg_indx = i ; if ( flags & SRB_DataOut ) { if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>sg<S2SV_blank>data<S2SV_blank>from<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } } addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ) ; psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ) ; psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ) ; byte_count += upsg -> sg [ i ] . count ; psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ) ; } } else { struct user_sgmap * usg ; usg = kmalloc ( actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) , GFP_KERNEL ) ; if ( ! usg ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Allocation<S2SV_blank>error<S2SV_blank>in<S2SV_blank>Raw<S2SV_blank>SRB<S2SV_blank>command\\n"" ) ) ; rcode = - ENOMEM ; goto cleanup ; } memcpy ( usg , upsg , actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) ) ; actual_fibsize = actual_fibsize64 ; for ( i = 0 ; i < usg -> count ; i ++ ) { u64 addr ; void * p ; if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) ) { kfree ( usg ) ; rcode = - EINVAL ; goto cleanup ; } p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ) ; if ( ! p ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>SG<S2SV_blank>buffer<S2SV_blank>-<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>buffer<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>of<S2SV_blank>%d\\n"" , usg -> sg [ i ] . count , i , usg -> count ) ) ; kfree ( usg ) ; rcode = - ENOMEM ; goto cleanup ; } sg_user [ i ] = ( void __user * ) ( uintptr_t ) usg -> sg [ i ] . addr ; sg_list [ i ] = p ; sg_indx = i ; if ( flags & SRB_DataOut ) { if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) ) { kfree ( usg ) ; dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>sg<S2SV_blank>data<S2SV_blank>from<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } } addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ) ; psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ) ; psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ) ; byte_count += usg -> sg [ i ] . count ; psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ) ; } kfree ( usg ) ; } srbcmd -> count = cpu_to_le32 ( byte_count ) ; psg -> count = cpu_to_le32 ( sg_indx + 1 ) ; status = aac_fib_send ( ScsiPortCommand64 , srbfib , actual_fibsize , FsaNormal , 1 , 1 , NULL , NULL ) ; } else { struct user_sgmap * upsg = & user_srbcmd -> sg ; struct sgmap * psg = & srbcmd -> sg ; if ( actual_fibsize64 == fibsize ) { struct user_sgmap64 * usg = ( struct user_sgmap64 * ) upsg ; for ( i = 0 ; i < upsg -> count ; i ++ ) { uintptr_t addr ; void * p ; if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) ) { rcode = - EINVAL ; goto cleanup ; } p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ) ; if ( ! p ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>SG<S2SV_blank>buffer<S2SV_blank>-<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>buffer<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>of<S2SV_blank>%d\\n"" , usg -> sg [ i ] . count , i , usg -> count ) ) ; rcode = - ENOMEM ; goto cleanup ; } addr = ( u64 ) usg -> sg [ i ] . addr [ 0 ] ; addr += ( ( u64 ) usg -> sg [ i ] . addr [ 1 ] ) << 32 ; sg_user [ i ] = ( void __user * ) addr ; sg_list [ i ] = p ; sg_indx = i ; if ( flags & SRB_DataOut ) { if ( copy_from_user ( p , sg_user [ i ] , usg -> sg [ i ] . count ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>sg<S2SV_blank>data<S2SV_blank>from<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } } addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ) ; psg -> sg [ i ] . addr = cpu_to_le32 ( addr & 0xffffffff ) ; byte_count += usg -> sg [ i ] . count ; psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ) ; } } else { for ( i = 0 ; i < upsg -> count ; i ++ ) { dma_addr_t addr ; void * p ; if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) ) { rcode = - EINVAL ; goto cleanup ; } p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL ) ; if ( ! p ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>SG<S2SV_blank>buffer<S2SV_blank>-<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>buffer<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>of<S2SV_blank>%d\\n"" , upsg -> sg [ i ] . count , i , upsg -> count ) ) ; rcode = - ENOMEM ; goto cleanup ; } sg_user [ i ] = ( void __user * ) ( uintptr_t ) upsg -> sg [ i ] . addr ; sg_list [ i ] = p ; sg_indx = i ; if ( flags & SRB_DataOut ) { if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>sg<S2SV_blank>data<S2SV_blank>from<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } } addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ) ; psg -> sg [ i ] . addr = cpu_to_le32 ( addr ) ; byte_count += upsg -> sg [ i ] . count ; psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ) ; } } srbcmd -> count = cpu_to_le32 ( byte_count ) ; psg -> count = cpu_to_le32 ( sg_indx + 1 ) ; status = aac_fib_send ( ScsiPortCommand , srbfib , actual_fibsize , FsaNormal , 1 , 1 , NULL , NULL ) ; } if ( status == - ERESTARTSYS ) { rcode = - ERESTARTSYS ; goto cleanup ; } if ( status != 0 ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>send<S2SV_blank>raw<S2SV_blank>srb<S2SV_blank>fib<S2SV_blank>to<S2SV_blank>hba\\n"" ) ) ; rcode = - ENXIO ; goto cleanup ; } if ( flags & SRB_DataIn ) { for ( i = 0 ; i <= sg_indx ; i ++ ) { byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ) ; if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>sg<S2SV_blank>data<S2SV_blank>to<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } } } reply = ( struct aac_srb_reply * ) fib_data ( srbfib ) ; if ( copy_to_user ( user_reply , reply , sizeof ( struct aac_srb_reply ) ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>reply<S2SV_blank>to<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } cleanup : kfree ( user_srbcmd ) ; for ( i = 0 ; i <= sg_indx ; i ++ ) { kfree ( sg_list [ i ] ) ; } if ( rcode != - ERESTARTSYS ) { aac_fib_complete ( srbfib ) ; aac_fib_free ( srbfib ) ; } return rcode ; }
","<S2SV_ModStart> } if ( ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( <S2SV_ModStart> ( struct aac_fibhdr )
"
831,"CWE-119 static int PredictorEncodeTile ( TIFF * tif , uint8 * bp0 , tmsize_t cc0 , uint16 s ) { static const char module [ ] = ""PredictorEncodeTile"" ; TIFFPredictorState * sp = PredictorState ( tif ) ; uint8 * working_copy ; tmsize_t cc = cc0 , rowsize ; unsigned char * bp ; int result_code ; assert ( sp != NULL ) ; assert ( sp -> encodepfunc != NULL ) ; assert ( sp -> encodetile != NULL ) ; working_copy = ( uint8 * ) _TIFFmalloc ( cc0 ) ; if ( working_copy == NULL ) { TIFFErrorExt ( tif -> tif_clientdata , module , ""Out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>allocating<S2SV_blank>"" TIFF_SSIZE_FORMAT ""<S2SV_blank>byte<S2SV_blank>temp<S2SV_blank>buffer."" , cc0 ) ; return 0 ; } memcpy ( working_copy , bp0 , cc0 ) ; bp = working_copy ; rowsize = sp -> rowsize ; assert ( rowsize > 0 ) ; <S2SV_StartBug> assert ( ( cc0 % rowsize ) == 0 ) ; <S2SV_EndBug> while ( cc > 0 ) { ( * sp -> encodepfunc ) ( tif , bp , rowsize ) ; cc -= rowsize ; bp += rowsize ; } result_code = ( * sp -> encodetile ) ( tif , working_copy , cc0 , s ) ; _TIFFfree ( working_copy ) ; return result_code ; }
","<S2SV_ModStart> 0 ) ; if <S2SV_ModEnd> ( ( cc0 <S2SV_ModStart> % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""PredictorEncodeTile"" , ""%s"" , ""(cc0%rowsize)!=0"" ) ; return 0 ; } <S2SV_ModEnd> while ( cc
"
832,"CWE-362 void sctp_generate_proto_unreach_event ( unsigned long data ) { struct sctp_transport * transport = ( struct sctp_transport * ) data ; struct sctp_association * asoc = transport -> asoc ; <S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\n"" , __func__ ) ; if ( ! mod_timer ( & transport -> proto_unreach_timer , jiffies + ( HZ / 20 ) ) ) sctp_association_hold ( asoc ) ; goto out_unlock ; } if ( asoc -> base . dead ) goto out_unlock ; sctp_do_sm ( net , SCTP_EVENT_T_OTHER , SCTP_ST_OTHER ( SCTP_EVENT_ICMP_PROTO_UNREACH ) , asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; out_unlock : <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> sctp_association_put ( asoc ) ; }
","<S2SV_ModStart> asoc ; struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;
"
833,"CWE-125 int yr_re_exec ( uint8_t * re_code , uint8_t * input_data , <S2SV_StartBug> size_t input_size , <S2SV_EndBug> int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) { uint8_t * ip ; uint8_t * input ; uint8_t mask ; uint8_t value ; RE_FIBER_LIST fibers ; RE_THREAD_STORAGE * storage ; RE_FIBER * fiber ; RE_FIBER * next_fiber ; int error ; int bytes_matched ; int max_bytes_matched ; int match ; int character_size ; int input_incr ; int kill ; int action ; int result = - 1 ; # define ACTION_NONE 0 # define ACTION_CONTINUE 1 # define ACTION_KILL 2 # define ACTION_KILL_TAIL 3 <S2SV_StartBug> # define prolog if ( bytes_matched >= max_bytes_matched ) { action = ACTION_KILL ; break ; } <S2SV_EndBug> <S2SV_StartBug> # define fail_if_error ( e ) switch ( e ) { case ERROR_INSUFFICIENT_MEMORY : return - 2 ; case ERROR_TOO_MANY_RE_FIBERS : return - 4 ; } <S2SV_EndBug> if ( _yr_re_alloc_storage ( & storage ) != ERROR_SUCCESS ) return - 2 ; if ( flags & RE_FLAGS_WIDE ) character_size = 2 ; else character_size = 1 ; input = input_data ; input_incr = character_size ; if ( flags & RE_FLAGS_BACKWARDS ) { <S2SV_StartBug> input -= character_size ; <S2SV_EndBug> input_incr = - input_incr ; } <S2SV_StartBug> max_bytes_matched = ( int ) yr_min ( input_size , RE_SCAN_LIMIT ) ; <S2SV_EndBug> max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size ; bytes_matched = 0 ; error = _yr_re_fiber_create ( & storage -> fiber_pool , & fiber ) ; fail_if_error ( error ) ; fiber -> ip = re_code ; fibers . head = fiber ; fibers . tail = fiber ; error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool , fiber ) ; fail_if_error ( error ) ; while ( fibers . head != NULL ) { fiber = fibers . head ; while ( fiber != NULL ) { ip = fiber -> ip ; action = ACTION_NONE ; switch ( * ip ) { case RE_OPCODE_ANY : prolog ; match = ( flags & RE_FLAGS_DOT_ALL ) || ( * input != 0x0A ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_GREEDY : case RE_OPCODE_REPEAT_ANY_UNGREEDY : prolog ; match = ( flags & RE_FLAGS_DOT_ALL ) || ( * input != 0x0A ) ; action = match ? ACTION_NONE : ACTION_KILL ; break ; case RE_OPCODE_LITERAL : prolog ; if ( flags & RE_FLAGS_NO_CASE ) match = yr_lowercase [ * input ] == yr_lowercase [ * ( ip + 1 ) ] ; else match = ( * input == * ( ip + 1 ) ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 2 ; break ; case RE_OPCODE_MASKED_LITERAL : prolog ; value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; match = ( ( * input & mask ) == value ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 3 ; break ; case RE_OPCODE_CLASS : prolog ; match = CHAR_IN_CLASS ( * input , ip + 1 ) ; if ( ! match && ( flags & RE_FLAGS_NO_CASE ) ) match = CHAR_IN_CLASS ( yr_altercase [ * input ] , ip + 1 ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 33 ; break ; case RE_OPCODE_WORD_CHAR : prolog ; <S2SV_StartBug> match = IS_WORD_CHAR ( * input ) ; <S2SV_EndBug> action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_NON_WORD_CHAR : prolog ; <S2SV_StartBug> match = ! IS_WORD_CHAR ( * input ) ; <S2SV_EndBug> action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_SPACE : case RE_OPCODE_NON_SPACE : prolog ; switch ( * input ) { case '<S2SV_blank>' : case '\\t' : case '\\r' : case '\\n' : case '\\v' : case '\\f' : match = TRUE ; break ; default : match = FALSE ; } if ( * ip == RE_OPCODE_NON_SPACE ) match = ! match ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_DIGIT : prolog ; match = isdigit ( * input ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_NON_DIGIT : prolog ; match = ! isdigit ( * input ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_WORD_BOUNDARY : case RE_OPCODE_NON_WORD_BOUNDARY : if ( bytes_matched == 0 && <S2SV_StartBug> ! ( flags & RE_FLAGS_NOT_AT_START ) && <S2SV_EndBug> ! ( flags & RE_FLAGS_BACKWARDS ) ) <S2SV_StartBug> match = TRUE ; <S2SV_EndBug> else if ( bytes_matched >= max_bytes_matched ) <S2SV_StartBug> match = TRUE ; <S2SV_EndBug> <S2SV_StartBug> else if ( IS_WORD_CHAR ( * ( input - input_incr ) ) != IS_WORD_CHAR ( * input ) ) <S2SV_EndBug> match = TRUE ; else match = FALSE ; if ( * ip == RE_OPCODE_NON_WORD_BOUNDARY ) match = ! match ; action = match ? ACTION_CONTINUE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_MATCH_AT_START : if ( flags & RE_FLAGS_BACKWARDS ) <S2SV_StartBug> kill = input_size > ( size_t ) bytes_matched ; <S2SV_EndBug> else <S2SV_StartBug> kill = ( flags & RE_FLAGS_NOT_AT_START ) || ( bytes_matched != 0 ) ; <S2SV_EndBug> action = kill ? ACTION_KILL : ACTION_CONTINUE ; fiber -> ip += 1 ; break ; case RE_OPCODE_MATCH_AT_END : kill = flags & RE_FLAGS_BACKWARDS || <S2SV_StartBug> input_size > ( size_t ) bytes_matched ; <S2SV_EndBug> action = kill ? ACTION_KILL : ACTION_CONTINUE ; fiber -> ip += 1 ; break ; case RE_OPCODE_MATCH : result = bytes_matched ; if ( flags & RE_FLAGS_EXHAUSTIVE ) { if ( callback != NULL ) { int cb_result ; if ( flags & RE_FLAGS_BACKWARDS ) cb_result = callback ( input + character_size , bytes_matched , flags , callback_args ) ; else cb_result = callback ( input_data , bytes_matched , flags , callback_args ) ; switch ( cb_result ) { case ERROR_INSUFFICIENT_MEMORY : return - 2 ; case ERROR_TOO_MANY_MATCHES : return - 3 ; default : if ( cb_result != ERROR_SUCCESS ) return - 4 ; } } action = ACTION_KILL ; } else { action = ACTION_KILL_TAIL ; } break ; default : assert ( FALSE ) ; } switch ( action ) { case ACTION_KILL : fiber = _yr_re_fiber_kill ( & fibers , & storage -> fiber_pool , fiber ) ; break ; case ACTION_KILL_TAIL : _yr_re_fiber_kill_tail ( & fibers , & storage -> fiber_pool , fiber ) ; fiber = NULL ; break ; case ACTION_CONTINUE : error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool , fiber ) ; fail_if_error ( error ) ; break ; default : next_fiber = fiber -> next ; error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool , fiber ) ; fail_if_error ( error ) ; fiber = next_fiber ; } <S2SV_StartBug> } <S2SV_EndBug> if ( flags & RE_FLAGS_WIDE && bytes_matched < max_bytes_matched && * ( input + 1 ) != 0 ) { _yr_re_fiber_kill_all ( & fibers , & storage -> fiber_pool ) ; } input += input_incr ; bytes_matched += character_size ; if ( flags & RE_FLAGS_SCAN && bytes_matched < max_bytes_matched ) { error = _yr_re_fiber_create ( & storage -> fiber_pool , & fiber ) ; fail_if_error ( error ) ; fiber -> ip = re_code ; _yr_re_fiber_append ( & fibers , fiber ) ; error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool , fiber ) ; fail_if_error ( error ) ; } } return result ; }
","<S2SV_ModStart> input_data , size_t input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> , int flags <S2SV_ModStart> # define prolog { if ( <S2SV_ModEnd> ( bytes_matched >= <S2SV_ModStart> >= max_bytes_matched ) || ( character_size == 2 && * ( input + 1 ) != 0 ) ) { action = ACTION_KILL ; break ; } <S2SV_ModEnd> } # define <S2SV_ModStart> ( e ) { <S2SV_ModStart> 4 ; } } <S2SV_ModStart> RE_FLAGS_BACKWARDS ) { max_bytes_matched = ( int ) yr_min ( input_backwards_size , RE_SCAN_LIMIT ) ; <S2SV_ModStart> input_incr ; } else { <S2SV_ModStart> ) yr_min ( input_forwards_size <S2SV_ModEnd> , RE_SCAN_LIMIT ) <S2SV_ModStart> RE_SCAN_LIMIT ) ; } <S2SV_ModStart> ; match = _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> ) ; action <S2SV_ModStart> match = ! _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> ) ; action <S2SV_ModStart> == 0 && input_backwards_size < character_size ) { <S2SV_ModEnd> match = TRUE <S2SV_ModStart> = TRUE ; } <S2SV_ModStart> >= max_bytes_matched ) { <S2SV_ModStart> = TRUE ; } else { assert ( input < input_data + input_forwards_size ) ; assert ( input >= input_data - input_backwards_size ) ; assert <S2SV_ModEnd> ( input - <S2SV_ModStart> input - input_incr < input_data + input_forwards_size ) ; assert ( input - input_incr >= input_data - input_backwards_size ) ; match = _yr_re_is_word_char ( input , character_size ) != _yr_re_is_word_char ( input - input_incr , character_size ) ; } <S2SV_ModEnd> if ( * <S2SV_ModStart> ) kill = input_backwards_size <S2SV_ModEnd> > ( size_t <S2SV_ModStart> else kill = input_backwards_size > 0 <S2SV_ModEnd> || ( bytes_matched <S2SV_ModStart> & RE_FLAGS_BACKWARDS || input_forwards_size <S2SV_ModEnd> > ( size_t <S2SV_ModStart> next_fiber ; } <S2SV_ModEnd> } input +=
"
834,"CWE-119 void vp8_rd_pick_inter_mode ( VP8_COMP * cpi , MACROBLOCK * x , int recon_yoffset , int recon_uvoffset , int * returnrate , <S2SV_StartBug> int * returndistortion , int * returnintra ) <S2SV_EndBug> { BLOCK * b = & x -> block [ 0 ] ; BLOCKD * d = & x -> e_mbd . block [ 0 ] ; MACROBLOCKD * xd = & x -> e_mbd ; int_mv best_ref_mv_sb [ 2 ] ; int_mv mode_mv_sb [ 2 ] [ MB_MODE_COUNT ] ; int_mv best_ref_mv ; int_mv * mode_mv ; MB_PREDICTION_MODE this_mode ; int num00 ; int best_mode_index = 0 ; BEST_MODE best_mode ; int i ; int mode_index ; int mdcounts [ 4 ] ; int rate ; RATE_DISTORTION rd ; int uv_intra_rate , uv_intra_distortion , uv_intra_rate_tokenonly ; int uv_intra_tteob = 0 ; int uv_intra_done = 0 ; MB_PREDICTION_MODE uv_intra_mode = 0 ; int_mv mvp ; int near_sadidx [ 8 ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int saddone = 0 ; int sr = 0 ; unsigned char * plane [ 4 ] [ 3 ] ; int ref_frame_map [ 4 ] ; int sign_bias = 0 ; int intra_rd_penalty = 10 * vp8_dc_quant ( cpi -> common . base_qindex , cpi -> common . y1dc_delta_q ) ; # if CONFIG_TEMPORAL_DENOISING <S2SV_StartBug> unsigned int zero_mv_sse = INT_MAX , best_sse = INT_MAX , <S2SV_EndBug> <S2SV_StartBug> best_rd_sse = INT_MAX ; <S2SV_EndBug> # endif mode_mv = mode_mv_sb [ sign_bias ] ; best_ref_mv . as_int = 0 ; best_mode . rd = INT_MAX ; best_mode . yrd = INT_MAX ; best_mode . intra_rd = INT_MAX ; <S2SV_StartBug> vpx_memset ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( & best_mode . mbmode , 0 , sizeof ( best_mode . mbmode ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( & best_mode . bmodes , 0 , sizeof ( best_mode . bmodes ) ) ; <S2SV_EndBug> get_reference_search_order ( cpi , ref_frame_map ) ; if ( ref_frame_map [ 1 ] > 0 ) { sign_bias = vp8_find_near_mvs_bias ( & x -> e_mbd , x -> e_mbd . mode_info_context , mode_mv_sb , best_ref_mv_sb , mdcounts , ref_frame_map [ 1 ] , cpi -> common . ref_frame_sign_bias ) ; mode_mv = mode_mv_sb [ sign_bias ] ; best_ref_mv . as_int = best_ref_mv_sb [ sign_bias ] . as_int ; } get_predictor_pointers ( cpi , plane , recon_yoffset , recon_uvoffset ) ; * returnintra = INT_MAX ; x -> mbs_tested_so_far ++ ; x -> skip = 0 ; for ( mode_index = 0 ; mode_index < MAX_MODES ; mode_index ++ ) { int this_rd = INT_MAX ; int disable_skip = 0 ; int other_cost = 0 ; int this_ref_frame = ref_frame_map [ vp8_ref_frame_order [ mode_index ] ] ; if ( best_mode . rd <= x -> rd_threshes [ mode_index ] ) continue ; if ( this_ref_frame < 0 ) continue ; rd . rate2 = 0 ; rd . distortion2 = 0 ; this_mode = vp8_mode_order [ mode_index ] ; x -> e_mbd . mode_info_context -> mbmi . mode = this_mode ; x -> e_mbd . mode_info_context -> mbmi . ref_frame = this_ref_frame ; if ( cpi -> is_src_frame_alt_ref && ( cpi -> oxcf . arnr_max_frames == 0 ) ) { if ( this_mode != ZEROMV || x -> e_mbd . mode_info_context -> mbmi . ref_frame != ALTREF_FRAME ) continue ; } if ( x -> e_mbd . mode_info_context -> mbmi . ref_frame ) { x -> e_mbd . pre . y_buffer = plane [ this_ref_frame ] [ 0 ] ; x -> e_mbd . pre . u_buffer = plane [ this_ref_frame ] [ 1 ] ; x -> e_mbd . pre . v_buffer = plane [ this_ref_frame ] [ 2 ] ; if ( sign_bias != cpi -> common . ref_frame_sign_bias [ this_ref_frame ] ) { sign_bias = cpi -> common . ref_frame_sign_bias [ this_ref_frame ] ; mode_mv = mode_mv_sb [ sign_bias ] ; best_ref_mv . as_int = best_ref_mv_sb [ sign_bias ] . as_int ; } } if ( x -> mode_test_hit_counts [ mode_index ] && ( cpi -> mode_check_freq [ mode_index ] > 1 ) ) { if ( x -> mbs_tested_so_far <= cpi -> mode_check_freq [ mode_index ] * x -> mode_test_hit_counts [ mode_index ] ) { x -> rd_thresh_mult [ mode_index ] += 4 ; if ( x -> rd_thresh_mult [ mode_index ] > MAX_THRESHMULT ) x -> rd_thresh_mult [ mode_index ] = MAX_THRESHMULT ; x -> rd_threshes [ mode_index ] = ( cpi -> rd_baseline_thresh [ mode_index ] >> 7 ) * x -> rd_thresh_mult [ mode_index ] ; continue ; } } x -> mode_test_hit_counts [ mode_index ] ++ ; if ( x -> zbin_mode_boost_enabled ) { if ( this_ref_frame == INTRA_FRAME ) x -> zbin_mode_boost = 0 ; else { if ( vp8_mode_order [ mode_index ] == ZEROMV ) { if ( this_ref_frame != LAST_FRAME ) x -> zbin_mode_boost = GF_ZEROMV_ZBIN_BOOST ; else x -> zbin_mode_boost = LF_ZEROMV_ZBIN_BOOST ; } else if ( vp8_mode_order [ mode_index ] == SPLITMV ) x -> zbin_mode_boost = 0 ; else x -> zbin_mode_boost = MV_ZBIN_BOOST ; } vp8_update_zbin_extra ( cpi , x ) ; } if ( ! uv_intra_done && this_ref_frame == INTRA_FRAME ) { rd_pick_intra_mbuv_mode ( x , & uv_intra_rate , & uv_intra_rate_tokenonly , & uv_intra_distortion ) ; uv_intra_mode = x -> e_mbd . mode_info_context -> mbmi . uv_mode ; for ( i = 16 ; i < 24 ; i ++ ) uv_intra_tteob += x -> e_mbd . eobs [ i ] ; uv_intra_done = 1 ; } switch ( this_mode ) { case B_PRED : { int tmp_rd ; int distortion ; tmp_rd = rd_pick_intra4x4mby_modes ( x , & rate , & rd . rate_y , & distortion , best_mode . yrd ) ; rd . rate2 += rate ; rd . distortion2 += distortion ; if ( tmp_rd < best_mode . yrd ) { rd . rate2 += uv_intra_rate ; rd . rate_uv = uv_intra_rate_tokenonly ; rd . distortion2 += uv_intra_distortion ; rd . distortion_uv = uv_intra_distortion ; } else { this_rd = INT_MAX ; disable_skip = 1 ; } } break ; case SPLITMV : { int tmp_rd ; int this_rd_thresh ; int distortion ; this_rd_thresh = ( vp8_ref_frame_order [ mode_index ] == 1 ) ? x -> rd_threshes [ THR_NEW1 ] : x -> rd_threshes [ THR_NEW3 ] ; this_rd_thresh = ( vp8_ref_frame_order [ mode_index ] == 2 ) ? x -> rd_threshes [ THR_NEW2 ] : this_rd_thresh ; tmp_rd = vp8_rd_pick_best_mbsegmentation ( cpi , x , & best_ref_mv , best_mode . yrd , mdcounts , & rate , & rd . rate_y , & distortion , this_rd_thresh ) ; rd . rate2 += rate ; rd . distortion2 += distortion ; if ( tmp_rd < best_mode . yrd ) { rd_inter4x4_uv ( cpi , x , & rd . rate_uv , & rd . distortion_uv , cpi -> common . full_pixel ) ; rd . rate2 += rd . rate_uv ; rd . distortion2 += rd . distortion_uv ; } else { this_rd = INT_MAX ; disable_skip = 1 ; } } break ; case DC_PRED : case V_PRED : case H_PRED : case TM_PRED : { int distortion ; x -> e_mbd . mode_info_context -> mbmi . ref_frame = INTRA_FRAME ; vp8_build_intra_predictors_mby_s ( xd , xd -> dst . y_buffer - xd -> dst . y_stride , xd -> dst . y_buffer - 1 , xd -> dst . y_stride , xd -> predictor , 16 ) ; macro_block_yrd ( x , & rd . rate_y , & distortion ) ; rd . rate2 += rd . rate_y ; rd . distortion2 += distortion ; rd . rate2 += x -> mbmode_cost [ x -> e_mbd . frame_type ] [ x -> e_mbd . mode_info_context -> mbmi . mode ] ; rd . rate2 += uv_intra_rate ; rd . rate_uv = uv_intra_rate_tokenonly ; rd . distortion2 += uv_intra_distortion ; rd . distortion_uv = uv_intra_distortion ; } break ; case NEWMV : { int thissme ; int bestsme = INT_MAX ; int step_param = cpi -> sf . first_step ; int further_steps ; int n ; int do_refine = 1 ; int sadpb = x -> sadperbit16 ; int_mv mvp_full ; int col_min = ( ( best_ref_mv . as_mv . col + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ; int row_min = ( ( best_ref_mv . as_mv . row + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ; int col_max = ( best_ref_mv . as_mv . col >> 3 ) + MAX_FULL_PEL_VAL ; int row_max = ( best_ref_mv . as_mv . row >> 3 ) + MAX_FULL_PEL_VAL ; int tmp_col_min = x -> mv_col_min ; int tmp_col_max = x -> mv_col_max ; int tmp_row_min = x -> mv_row_min ; int tmp_row_max = x -> mv_row_max ; if ( ! saddone ) { vp8_cal_sad ( cpi , xd , x , recon_yoffset , & near_sadidx [ 0 ] ) ; saddone = 1 ; } vp8_mv_pred ( cpi , & x -> e_mbd , x -> e_mbd . mode_info_context , & mvp , x -> e_mbd . mode_info_context -> mbmi . ref_frame , cpi -> common . ref_frame_sign_bias , & sr , & near_sadidx [ 0 ] ) ; mvp_full . as_mv . col = mvp . as_mv . col >> 3 ; mvp_full . as_mv . row = mvp . as_mv . row >> 3 ; if ( x -> mv_col_min < col_min ) x -> mv_col_min = col_min ; if ( x -> mv_col_max > col_max ) x -> mv_col_max = col_max ; if ( x -> mv_row_min < row_min ) x -> mv_row_min = row_min ; if ( x -> mv_row_max > row_max ) x -> mv_row_max = row_max ; if ( sr > step_param ) step_param = sr ; { bestsme = cpi -> diamond_search_sad ( x , b , d , & mvp_full , & d -> bmi . mv , step_param , sadpb , & num00 , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , & best_ref_mv ) ; <S2SV_StartBug> mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; <S2SV_EndBug> n = 0 ; further_steps = ( cpi -> sf . max_step_search_steps - 1 ) - step_param ; n = num00 ; num00 = 0 ; if ( n > further_steps ) do_refine = 0 ; while ( n < further_steps ) { n ++ ; if ( num00 ) num00 -- ; else { thissme = cpi -> diamond_search_sad ( x , b , d , & mvp_full , & d -> bmi . mv , step_param + n , sadpb , & num00 , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , & best_ref_mv ) ; if ( num00 > ( further_steps - n ) ) do_refine = 0 ; if ( thissme < bestsme ) { bestsme = thissme ; mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; } else { d -> bmi . mv . as_int = mode_mv [ NEWMV ] . as_int ; } } } } if ( do_refine == 1 ) { int search_range ; search_range = 8 ; thissme = cpi -> refining_search_sad ( x , b , d , & d -> bmi . mv , sadpb , search_range , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , & best_ref_mv ) ; if ( thissme < bestsme ) { bestsme = thissme ; mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; } else { d -> bmi . mv . as_int = mode_mv [ NEWMV ] . as_int ; } } x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max ; if ( bestsme < INT_MAX ) { int dis ; unsigned int sse ; cpi -> find_fractional_mv_step ( x , b , d , & d -> bmi . mv , & best_ref_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , & dis , & sse ) ; } mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; rd . rate2 += vp8_mv_bit_cost ( & mode_mv [ NEWMV ] , & best_ref_mv , x -> mvcost , 96 ) ; } case NEARESTMV : case NEARMV : vp8_clamp_mv2 ( & mode_mv [ this_mode ] , xd ) ; if ( ( ( this_mode == NEARMV ) || ( this_mode == NEARESTMV ) ) && ( mode_mv [ this_mode ] . as_int == 0 ) ) continue ; case ZEROMV : if ( ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) < x -> mv_row_min ) || ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) > x -> mv_row_max ) || ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) < x -> mv_col_min ) || ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) > x -> mv_col_max ) ) continue ; vp8_set_mbmode_and_mvs ( x , this_mode , & mode_mv [ this_mode ] ) ; this_rd = evaluate_inter_mode_rd ( mdcounts , & rd , & disable_skip , cpi , x ) ; break ; default : break ; } this_rd = calculate_final_rd_costs ( this_rd , & rd , & other_cost , disable_skip , uv_intra_tteob , intra_rd_penalty , cpi , x ) ; if ( ( x -> e_mbd . mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) && ( this_rd < best_mode . intra_rd ) ) { best_mode . intra_rd = this_rd ; * returnintra = rd . distortion2 ; } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { unsigned int sse ; vp8_get_inter_mbpred_error ( x , & cpi -> fn_ptr [ BLOCK_16X16 ] , & sse , mode_mv [ this_mode ] ) ; if ( sse < best_rd_sse ) best_rd_sse = sse ; if ( this_mode == ZEROMV && sse < zero_mv_sse ) { zero_mv_sse = sse ; x -> best_zeromv_reference_frame = x -> e_mbd . mode_info_context -> mbmi . ref_frame ; } if ( x -> e_mbd . mode_info_context -> mbmi . mode == NEWMV && sse < best_sse ) { best_sse = sse ; vp8_get_inter_mbpred_error ( x , & cpi -> fn_ptr [ BLOCK_16X16 ] , & best_sse , mode_mv [ this_mode ] ) ; x -> best_sse_inter_mode = NEWMV ; x -> best_sse_mv = x -> e_mbd . mode_info_context -> mbmi . mv ; x -> need_to_clamp_best_mvs = x -> e_mbd . mode_info_context -> mbmi . need_to_clamp_mvs ; x -> best_reference_frame = x -> e_mbd . mode_info_context -> mbmi . ref_frame ; } } # endif if ( this_rd < best_mode . rd || x -> skip ) { best_mode_index = mode_index ; * returnrate = rd . rate2 ; * returndistortion = rd . distortion2 ; if ( this_mode <= B_PRED ) { x -> e_mbd . mode_info_context -> mbmi . uv_mode = uv_intra_mode ; x -> e_mbd . mode_info_context -> mbmi . mv . as_int = 0 ; } update_best_mode ( & best_mode , this_rd , & rd , other_cost , x ) ; x -> rd_thresh_mult [ mode_index ] = ( x -> rd_thresh_mult [ mode_index ] >= ( MIN_THRESHMULT + 2 ) ) ? x -> rd_thresh_mult [ mode_index ] - 2 : MIN_THRESHMULT ; } else { x -> rd_thresh_mult [ mode_index ] += 4 ; if ( x -> rd_thresh_mult [ mode_index ] > MAX_THRESHMULT ) x -> rd_thresh_mult [ mode_index ] = MAX_THRESHMULT ; } x -> rd_threshes [ mode_index ] = ( cpi -> rd_baseline_thresh [ mode_index ] >> 7 ) * x -> rd_thresh_mult [ mode_index ] ; if ( x -> skip ) break ; } if ( ( cpi -> rd_baseline_thresh [ best_mode_index ] > 0 ) && ( cpi -> rd_baseline_thresh [ best_mode_index ] < ( INT_MAX >> 2 ) ) ) { int best_adjustment = ( x -> rd_thresh_mult [ best_mode_index ] >> 2 ) ; x -> rd_thresh_mult [ best_mode_index ] = ( x -> rd_thresh_mult [ best_mode_index ] >= ( MIN_THRESHMULT + best_adjustment ) ) ? x -> rd_thresh_mult [ best_mode_index ] - best_adjustment : MIN_THRESHMULT ; x -> rd_threshes [ best_mode_index ] = ( cpi -> rd_baseline_thresh [ best_mode_index ] >> 7 ) * x -> rd_thresh_mult [ best_mode_index ] ; } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { <S2SV_StartBug> if ( x -> best_sse_inter_mode == DC_PRED ) <S2SV_EndBug> { x -> best_sse_inter_mode = best_mode . mbmode . mode ; x -> best_sse_mv = best_mode . mbmode . mv ; x -> need_to_clamp_best_mvs = best_mode . mbmode . need_to_clamp_mvs ; x -> best_reference_frame = best_mode . mbmode . ref_frame ; best_sse = best_rd_sse ; } vp8_denoiser_denoise_mb ( & cpi -> denoiser , x , best_sse , zero_mv_sse , <S2SV_StartBug> recon_yoffset , recon_uvoffset ) ; <S2SV_EndBug> if ( best_mode . mbmode . ref_frame == INTRA_FRAME && x -> best_zeromv_reference_frame != INTRA_FRAME ) { int this_rd = INT_MAX ; int disable_skip = 0 ; int other_cost = 0 ; int this_ref_frame = x -> best_zeromv_reference_frame ; rd . rate2 = x -> ref_frame_cost [ this_ref_frame ] + vp8_cost_mv_ref ( ZEROMV , mdcounts ) ; rd . distortion2 = 0 ; x -> e_mbd . mode_info_context -> mbmi . ref_frame = this_ref_frame ; x -> e_mbd . pre . y_buffer = plane [ this_ref_frame ] [ 0 ] ; x -> e_mbd . pre . u_buffer = plane [ this_ref_frame ] [ 1 ] ; x -> e_mbd . pre . v_buffer = plane [ this_ref_frame ] [ 2 ] ; x -> e_mbd . mode_info_context -> mbmi . mode = ZEROMV ; x -> e_mbd . mode_info_context -> mbmi . uv_mode = DC_PRED ; x -> e_mbd . mode_info_context -> mbmi . mv . as_int = 0 ; this_rd = evaluate_inter_mode_rd ( mdcounts , & rd , & disable_skip , cpi , x ) ; this_rd = calculate_final_rd_costs ( this_rd , & rd , & other_cost , disable_skip , uv_intra_tteob , intra_rd_penalty , cpi , x ) ; if ( this_rd < best_mode . rd || x -> skip ) { <S2SV_StartBug> best_mode_index = mode_index ; <S2SV_EndBug> * returnrate = rd . rate2 ; * returndistortion = rd . distortion2 ; update_best_mode ( & best_mode , this_rd , & rd , other_cost , x ) ; } } } # endif if ( cpi -> is_src_frame_alt_ref && ( best_mode . mbmode . mode != ZEROMV || best_mode . mbmode . ref_frame != ALTREF_FRAME ) ) { x -> e_mbd . mode_info_context -> mbmi . mode = ZEROMV ; x -> e_mbd . mode_info_context -> mbmi . ref_frame = ALTREF_FRAME ; x -> e_mbd . mode_info_context -> mbmi . mv . as_int = 0 ; x -> e_mbd . mode_info_context -> mbmi . uv_mode = DC_PRED ; x -> e_mbd . mode_info_context -> mbmi . mb_skip_coeff = ( cpi -> common . mb_no_coeff_skip ) ; x -> e_mbd . mode_info_context -> mbmi . partitioning = 0 ; return ; } <S2SV_StartBug> vpx_memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mode . mbmode , sizeof ( MB_MODE_INFO ) ) ; <S2SV_EndBug> if ( best_mode . mbmode . mode == B_PRED ) { for ( i = 0 ; i < 16 ; i ++ ) xd -> mode_info_context -> bmi [ i ] . as_mode = best_mode . bmodes [ i ] . as_mode ; } if ( best_mode . mbmode . mode == SPLITMV ) { for ( i = 0 ; i < 16 ; i ++ ) xd -> mode_info_context -> bmi [ i ] . mv . as_int = best_mode . bmodes [ i ] . mv . as_int ; <S2SV_StartBug> vpx_memcpy ( x -> partition_info , & best_mode . partition , sizeof ( PARTITION_INFO ) ) ; <S2SV_EndBug> x -> e_mbd . mode_info_context -> mbmi . mv . as_int = x -> partition_info -> bmi [ 15 ] . mv . as_int ; } if ( sign_bias != cpi -> common . ref_frame_sign_bias [ xd -> mode_info_context -> mbmi . ref_frame ] ) best_ref_mv . as_int = best_ref_mv_sb [ ! sign_bias ] . as_int ; rd_update_mvcount ( x , & best_ref_mv ) ; }
","<S2SV_ModStart> int * returnintra , int mb_row , int mb_col <S2SV_ModStart> int zero_mv_sse = UINT_MAX <S2SV_ModEnd> , best_sse = <S2SV_ModStart> , best_sse = UINT_MAX <S2SV_ModEnd> , best_rd_sse = <S2SV_ModStart> , best_rd_sse = UINT_MAX <S2SV_ModEnd> ; # endif <S2SV_ModStart> = INT_MAX ; memset <S2SV_ModEnd> ( mode_mv_sb , <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( & best_mode <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( & best_mode <S2SV_ModStart> mv . as_int <S2SV_ModEnd> ; further_steps = <S2SV_ModStart> noise_sensitivity ) { int block_index = mb_row * cpi -> common . mb_cols + mb_col ; <S2SV_ModStart> recon_yoffset , recon_uvoffset , & cpi -> common . lf_info , mb_row , mb_col , block_index <S2SV_ModStart> skip ) { <S2SV_ModEnd> * returnrate = <S2SV_ModStart> return ; } memcpy <S2SV_ModEnd> ( & x <S2SV_ModStart> . as_int ; memcpy <S2SV_ModEnd> ( x ->
"
835,"CWE-399 static void init_vmcb ( struct vcpu_svm * svm ) { struct vmcb_control_area * control = & svm -> vmcb -> control ; struct vmcb_save_area * save = & svm -> vmcb -> save ; svm -> vcpu . fpu_active = 1 ; svm -> vcpu . arch . hflags = 0 ; set_cr_intercept ( svm , INTERCEPT_CR0_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR4_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR0_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR4_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR8_WRITE ) ; set_dr_intercepts ( svm ) ; set_exception_intercept ( svm , PF_VECTOR ) ; set_exception_intercept ( svm , UD_VECTOR ) ; <S2SV_StartBug> set_exception_intercept ( svm , MC_VECTOR ) ; <S2SV_EndBug> set_intercept ( svm , INTERCEPT_INTR ) ; set_intercept ( svm , INTERCEPT_NMI ) ; set_intercept ( svm , INTERCEPT_SMI ) ; set_intercept ( svm , INTERCEPT_SELECTIVE_CR0 ) ; set_intercept ( svm , INTERCEPT_RDPMC ) ; set_intercept ( svm , INTERCEPT_CPUID ) ; set_intercept ( svm , INTERCEPT_INVD ) ; set_intercept ( svm , INTERCEPT_HLT ) ; set_intercept ( svm , INTERCEPT_INVLPG ) ; set_intercept ( svm , INTERCEPT_INVLPGA ) ; set_intercept ( svm , INTERCEPT_IOIO_PROT ) ; set_intercept ( svm , INTERCEPT_MSR_PROT ) ; set_intercept ( svm , INTERCEPT_TASK_SWITCH ) ; set_intercept ( svm , INTERCEPT_SHUTDOWN ) ; set_intercept ( svm , INTERCEPT_VMRUN ) ; set_intercept ( svm , INTERCEPT_VMMCALL ) ; set_intercept ( svm , INTERCEPT_VMLOAD ) ; set_intercept ( svm , INTERCEPT_VMSAVE ) ; set_intercept ( svm , INTERCEPT_STGI ) ; set_intercept ( svm , INTERCEPT_CLGI ) ; set_intercept ( svm , INTERCEPT_SKINIT ) ; set_intercept ( svm , INTERCEPT_WBINVD ) ; set_intercept ( svm , INTERCEPT_MONITOR ) ; set_intercept ( svm , INTERCEPT_MWAIT ) ; set_intercept ( svm , INTERCEPT_XSETBV ) ; control -> iopm_base_pa = iopm_base ; control -> msrpm_base_pa = __pa ( svm -> msrpm ) ; control -> int_ctl = V_INTR_MASKING_MASK ; init_seg ( & save -> es ) ; init_seg ( & save -> ss ) ; init_seg ( & save -> ds ) ; init_seg ( & save -> fs ) ; init_seg ( & save -> gs ) ; save -> cs . selector = 0xf000 ; save -> cs . base = 0xffff0000 ; save -> cs . attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK | SVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK ; save -> cs . limit = 0xffff ; save -> gdtr . limit = 0xffff ; save -> idtr . limit = 0xffff ; init_sys_seg ( & save -> ldtr , SEG_TYPE_LDT ) ; init_sys_seg ( & save -> tr , SEG_TYPE_BUSY_TSS16 ) ; svm_set_efer ( & svm -> vcpu , 0 ) ; save -> dr6 = 0xffff0ff0 ; kvm_set_rflags ( & svm -> vcpu , 2 ) ; save -> rip = 0x0000fff0 ; svm -> vcpu . arch . regs [ VCPU_REGS_RIP ] = save -> rip ; svm_set_cr0 ( & svm -> vcpu , X86_CR0_NW | X86_CR0_CD | X86_CR0_ET ) ; kvm_mmu_reset_context ( & svm -> vcpu ) ; save -> cr4 = X86_CR4_PAE ; if ( npt_enabled ) { control -> nested_ctl = 1 ; clr_intercept ( svm , INTERCEPT_INVLPG ) ; clr_exception_intercept ( svm , PF_VECTOR ) ; clr_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; clr_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; save -> g_pat = svm -> vcpu . arch . pat ; save -> cr3 = 0 ; save -> cr4 = 0 ; } svm -> asid_generation = 0 ; svm -> nested . vmcb = 0 ; svm -> vcpu . arch . hflags = 0 ; if ( boot_cpu_has ( X86_FEATURE_PAUSEFILTER ) ) { control -> pause_filter_count = 3000 ; set_intercept ( svm , INTERCEPT_PAUSE ) ; } mark_all_dirty ( svm -> vmcb ) ; enable_gif ( svm ) ; }
","<S2SV_ModStart> svm , MC_VECTOR ) ; set_exception_intercept ( svm , AC_VECTOR
"
836,"CWE-119 hive_h * hivex_open ( const char * filename , int flags ) { hive_h * h = NULL ; assert ( sizeof ( struct ntreg_header ) == 0x1000 ) ; assert ( offsetof ( struct ntreg_header , csum ) == 0x1fc ) ; h = calloc ( 1 , sizeof * h ) ; if ( h == NULL ) goto error ; h -> msglvl = flags & HIVEX_OPEN_MSGLVL_MASK ; const char * debug = getenv ( ""HIVEX_DEBUG"" ) ; if ( debug && STREQ ( debug , ""1"" ) ) h -> msglvl = 2 ; DEBUG ( 2 , ""created<S2SV_blank>handle<S2SV_blank>%p"" , h ) ; h -> writable = ! ! ( flags & HIVEX_OPEN_WRITE ) ; h -> filename = strdup ( filename ) ; if ( h -> filename == NULL ) goto error ; # ifdef O_CLOEXEC h -> fd = open ( filename , O_RDONLY | O_CLOEXEC | O_BINARY ) ; # else h -> fd = open ( filename , O_RDONLY | O_BINARY ) ; # endif if ( h -> fd == - 1 ) goto error ; # ifndef O_CLOEXEC fcntl ( h -> fd , F_SETFD , FD_CLOEXEC ) ; # endif struct stat statbuf ; if ( fstat ( h -> fd , & statbuf ) == - 1 ) goto error ; <S2SV_StartBug> h -> size = statbuf . st_size ; <S2SV_EndBug> if ( ! h -> writable ) { h -> addr = mmap ( NULL , h -> size , PROT_READ , MAP_SHARED , h -> fd , 0 ) ; if ( h -> addr == MAP_FAILED ) goto error ; DEBUG ( 2 , ""mapped<S2SV_blank>file<S2SV_blank>at<S2SV_blank>%p"" , h -> addr ) ; } else { h -> addr = malloc ( h -> size ) ; if ( h -> addr == NULL ) goto error ; if ( full_read ( h -> fd , h -> addr , h -> size ) < h -> size ) goto error ; if ( close ( h -> fd ) == - 1 ) goto error ; h -> fd = - 1 ; } if ( h -> hdr -> magic [ 0 ] != 'r' || h -> hdr -> magic [ 1 ] != 'e' || h -> hdr -> magic [ 2 ] != 'g' || h -> hdr -> magic [ 3 ] != 'f' ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file"" , filename ) ; goto error ; } uint32_t major_ver = le32toh ( h -> hdr -> major_ver ) ; if ( major_ver != 1 ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>hive<S2SV_blank>file<S2SV_blank>major<S2SV_blank>version<S2SV_blank>%"" PRIu32 ""<S2SV_blank>(expected<S2SV_blank>1)"" , filename , major_ver ) ; goto error ; } h -> bitmap = calloc ( 1 + h -> size / 32 , 1 ) ; if ( h -> bitmap == NULL ) goto error ; uint32_t sum = header_checksum ( h ) ; if ( sum != le32toh ( h -> hdr -> csum ) ) { SET_ERRNO ( EINVAL , ""%s:<S2SV_blank>bad<S2SV_blank>checksum<S2SV_blank>in<S2SV_blank>hive<S2SV_blank>header"" , filename ) ; goto error ; } h -> last_modified = le64toh ( ( int64_t ) h -> hdr -> last_modified ) ; if ( h -> msglvl >= 2 ) { char * name = _hivex_windows_utf16_to_utf8 ( h -> hdr -> name , 64 ) ; fprintf ( stderr , ""hivex_open:<S2SV_blank>header<S2SV_blank>fields:\\n"" ""<S2SV_blank><S2SV_blank>file<S2SV_blank>version<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu32 "".%"" PRIu32 ""\\n"" ""<S2SV_blank><S2SV_blank>sequence<S2SV_blank>nos<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu32 ""<S2SV_blank>%"" PRIu32 ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(sequences<S2SV_blank>nos<S2SV_blank>should<S2SV_blank>match<S2SV_blank>if<S2SV_blank>hive<S2SV_blank>was<S2SV_blank>synched<S2SV_blank>at<S2SV_blank>shutdown)\\n"" ""<S2SV_blank><S2SV_blank>last<S2SV_blank>modified<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu64 ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Windows<S2SV_blank>filetime,<S2SV_blank>x<S2SV_blank>100<S2SV_blank>ns<S2SV_blank>since<S2SV_blank>1601-01-01)\\n"" ""<S2SV_blank><S2SV_blank>original<S2SV_blank>file<S2SV_blank>name<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(only<S2SV_blank>32<S2SV_blank>chars<S2SV_blank>are<S2SV_blank>stored,<S2SV_blank>name<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>truncated)\\n"" ""<S2SV_blank><S2SV_blank>root<S2SV_blank>offset<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>+<S2SV_blank>0x1000\\n"" ""<S2SV_blank><S2SV_blank>end<S2SV_blank>of<S2SV_blank>last<S2SV_blank>page<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>+<S2SV_blank>0x1000<S2SV_blank>(total<S2SV_blank>file<S2SV_blank>size<S2SV_blank>0x%zx)\\n"" ""<S2SV_blank><S2SV_blank>checksum<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>(calculated<S2SV_blank>0x%x)\\n"" , major_ver , le32toh ( h -> hdr -> minor_ver ) , le32toh ( h -> hdr -> sequence1 ) , le32toh ( h -> hdr -> sequence2 ) , h -> last_modified , name ? name : ""(conversion<S2SV_blank>failed)"" , le32toh ( h -> hdr -> offset ) , le32toh ( h -> hdr -> blocks ) , h -> size , le32toh ( h -> hdr -> csum ) , sum ) ; free ( name ) ; } h -> rootoffs = le32toh ( h -> hdr -> offset ) + 0x1000 ; h -> endpages = le32toh ( h -> hdr -> blocks ) + 0x1000 ; DEBUG ( 2 , ""root<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>0x%zx"" , h -> rootoffs ) ; int seen_root_block = 0 , bad_root_block = 0 ; size_t pages = 0 ; size_t smallest_page = SIZE_MAX , largest_page = 0 ; size_t blocks = 0 ; size_t smallest_block = SIZE_MAX , largest_block = 0 , blocks_bytes = 0 ; size_t used_blocks = 0 ; size_t used_size = 0 ; size_t off ; struct ntreg_hbin_page * page ; for ( off = 0x1000 ; off < h -> size ; off += le32toh ( page -> page_size ) ) { if ( off >= h -> endpages ) break ; page = ( struct ntreg_hbin_page * ) ( ( char * ) h -> addr + off ) ; if ( page -> magic [ 0 ] != 'h' || page -> magic [ 1 ] != 'b' || page -> magic [ 2 ] != 'i' || page -> magic [ 3 ] != 'n' ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>trailing<S2SV_blank>garbage<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>"" ""(at<S2SV_blank>0x%zx,<S2SV_blank>after<S2SV_blank>%zu<S2SV_blank>pages)"" , filename , off , pages ) ; goto error ; } size_t page_size = le32toh ( page -> page_size ) ; DEBUG ( 2 , ""page<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>size<S2SV_blank>%zu"" , off , page_size ) ; pages ++ ; if ( page_size < smallest_page ) smallest_page = page_size ; if ( page_size > largest_page ) largest_page = page_size ; if ( page_size <= sizeof ( struct ntreg_hbin_page ) || ( page_size & 0x0fff ) != 0 ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , filename , page_size , off ) ; goto error ; } size_t blkoff ; struct ntreg_hbin_block * block ; size_t seg_len ; for ( blkoff = off + 0x20 ; blkoff < off + page_size ; blkoff += seg_len ) { blocks ++ ; int is_root = blkoff == h -> rootoffs ; if ( is_root ) seen_root_block = 1 ; block = ( struct ntreg_hbin_block * ) ( ( char * ) h -> addr + blkoff ) ; int used ; seg_len = block_len ( h , blkoff , & used ) ; if ( seg_len <= 4 || ( seg_len & 3 ) != 0 ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>block<S2SV_blank>size<S2SV_blank>%"" PRIu32 ""<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , filename , le32toh ( block -> seg_len ) , blkoff ) ; goto error ; } if ( h -> msglvl >= 2 ) { unsigned char * id = ( unsigned char * ) block -> id ; int id0 = id [ 0 ] , id1 = id [ 1 ] ; fprintf ( stderr , ""%s:<S2SV_blank>%s:<S2SV_blank>"" ""%s<S2SV_blank>block<S2SV_blank>id<S2SV_blank>%d,%d<S2SV_blank>(%c%c)<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>size<S2SV_blank>%zu%s\\n"" , ""hivex"" , __func__ , used ? ""used"" : ""free"" , id0 , id1 , c_isprint ( id0 ) ? id0 : '.' , c_isprint ( id1 ) ? id1 : '.' , blkoff , seg_len , is_root ? ""<S2SV_blank>(root)"" : """" ) ; } blocks_bytes += seg_len ; if ( seg_len < smallest_block ) smallest_block = seg_len ; if ( seg_len > largest_block ) largest_block = seg_len ; if ( is_root && ! used ) bad_root_block = 1 ; if ( used ) { used_blocks ++ ; used_size += seg_len ; if ( is_root && ( block -> id [ 0 ] != 'n' || block -> id [ 1 ] != 'k' ) ) bad_root_block = 1 ; BITMAP_SET ( h -> bitmap , blkoff ) ; } } } if ( ! seen_root_block ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>no<S2SV_blank>root<S2SV_blank>block<S2SV_blank>found"" , filename ) ; goto error ; } if ( bad_root_block ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>bad<S2SV_blank>root<S2SV_blank>block<S2SV_blank>(free<S2SV_blank>or<S2SV_blank>not<S2SV_blank>nk)"" , filename ) ; goto error ; } DEBUG ( 1 , ""successfully<S2SV_blank>read<S2SV_blank>Windows<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file:\\n"" ""<S2SV_blank><S2SV_blank>pages:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu<S2SV_blank>[sml:<S2SV_blank>%zu,<S2SV_blank>lge:<S2SV_blank>%zu]\\n"" ""<S2SV_blank><S2SV_blank>blocks:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu<S2SV_blank>[sml:<S2SV_blank>%zu,<S2SV_blank>avg:<S2SV_blank>%zu,<S2SV_blank>lge:<S2SV_blank>%zu]\\n"" ""<S2SV_blank><S2SV_blank>blocks<S2SV_blank>used:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu\\n"" ""<S2SV_blank><S2SV_blank>bytes<S2SV_blank>used:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu"" , pages , smallest_page , largest_page , blocks , smallest_block , blocks_bytes / blocks , largest_block , used_blocks , used_size ) ; return h ; error : ; int err = errno ; if ( h ) { free ( h -> bitmap ) ; if ( h -> addr && h -> size && h -> addr != MAP_FAILED ) { if ( ! h -> writable ) munmap ( h -> addr , h -> size ) ; else free ( h -> addr ) ; } if ( h -> fd >= 0 ) close ( h -> fd ) ; free ( h -> filename ) ; free ( h ) ; } errno = err ; return NULL ; }
","<S2SV_ModStart> . st_size ; if ( h -> size < 0x2000 ) { SET_ERRNO ( EINVAL , ""%s:<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file"" , filename ) ; goto error ; }
"
837,"CWE-119 private int cdf_file_summary_info ( struct magic_set * ms , const cdf_header_t * h , <S2SV_StartBug> const cdf_stream_t * sst , const uint64_t clsid [ 2 ] ) <S2SV_EndBug> { cdf_summary_info_header_t si ; cdf_property_info_t * info ; size_t count ; int m ; if ( cdf_unpack_summary_info ( sst , h , & si , & info , & count ) == - 1 ) return - 1 ; if ( NOTMIME ( ms ) ) { const char * str ; if ( file_printf ( ms , ""Composite<S2SV_blank>Document<S2SV_blank>File<S2SV_blank>V2<S2SV_blank>Document"" ) == - 1 ) return - 1 ; if ( file_printf ( ms , "",<S2SV_blank>%s<S2SV_blank>Endian"" , si . si_byte_order == 0xfffe ? ""Little"" : ""Big"" ) == - 1 ) return - 2 ; switch ( si . si_os ) { case 2 : if ( file_printf ( ms , "",<S2SV_blank>Os:<S2SV_blank>Windows,<S2SV_blank>Version<S2SV_blank>%d.%d"" , si . si_os_version & 0xff , ( uint32_t ) si . si_os_version >> 8 ) == - 1 ) return - 2 ; break ; case 1 : if ( file_printf ( ms , "",<S2SV_blank>Os:<S2SV_blank>MacOS,<S2SV_blank>Version<S2SV_blank>%d.%d"" , ( uint32_t ) si . si_os_version >> 8 , si . si_os_version & 0xff ) == - 1 ) return - 2 ; break ; default : if ( file_printf ( ms , "",<S2SV_blank>Os<S2SV_blank>%d,<S2SV_blank>Version:<S2SV_blank>%d.%d"" , si . si_os , si . si_os_version & 0xff , ( uint32_t ) si . si_os_version >> 8 ) == - 1 ) return - 2 ; break ; } <S2SV_StartBug> str = cdf_clsid_to_mime ( clsid , clsid2desc ) ; <S2SV_EndBug> if ( str ) if ( file_printf ( ms , "",<S2SV_blank>%s"" , str ) == - 1 ) <S2SV_StartBug> return - 2 ; <S2SV_EndBug> } <S2SV_StartBug> m = cdf_file_property_info ( ms , info , count , clsid ) ; <S2SV_EndBug> free ( info ) ; return m == - 1 ? - 2 : m ; }
","<S2SV_ModStart> sst , const cdf_directory_t * root_storage <S2SV_ModEnd> ) { cdf_summary_info_header_t <S2SV_ModStart> break ; } if ( root_storage ) { <S2SV_ModStart> = cdf_clsid_to_mime ( root_storage -> d_storage_uuid <S2SV_ModEnd> , clsid2desc ) <S2SV_ModStart> - 2 ; } <S2SV_ModStart> , count , root_storage <S2SV_ModEnd> ) ; free
"
838,"CWE-200 WORD32 ih264d_parse_sps ( dec_struct_t * ps_dec , dec_bit_stream_t * ps_bitstrm ) { UWORD8 i ; dec_seq_params_t * ps_seq = NULL ; <S2SV_StartBug> UWORD8 u1_profile_idc , u1_level_idc , u1_seq_parameter_set_id ; <S2SV_EndBug> UWORD16 i2_max_frm_num ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD8 u1_frm , uc_constraint_set0_flag , uc_constraint_set1_flag ; WORD32 i4_cropped_ht , i4_cropped_wd ; UWORD32 u4_temp ; WORD32 pic_height_in_map_units_minus1 = 0 ; UWORD32 u2_pic_wd = 0 ; UWORD32 u2_pic_ht = 0 ; UWORD32 u2_frm_wd_y = 0 ; UWORD32 u2_frm_ht_y = 0 ; UWORD32 u2_frm_wd_uv = 0 ; UWORD32 u2_frm_ht_uv = 0 ; UWORD32 u2_crop_offset_y = 0 ; UWORD32 u2_crop_offset_uv = 0 ; WORD32 ret ; UWORD32 u4_num_reorder_frames ; WORD32 i4_i ; UWORD8 u1_frame_cropping_flag , u1_frame_cropping_rect_left_ofst , u1_frame_cropping_rect_right_ofst , u1_frame_cropping_rect_top_ofst , u1_frame_cropping_rect_bottom_ofst ; SWITCHONTRACE ; u1_profile_idc = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>profile_idc"" , u1_profile_idc ) ; uc_constraint_set0_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; uc_constraint_set1_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; ih264d_get_bit_h264 ( ps_bitstrm ) ; ih264d_get_bits_h264 ( ps_bitstrm , 5 ) ; if ( ( u1_profile_idc != MAIN_PROFILE_IDC ) && ( u1_profile_idc != BASE_PROFILE_IDC ) && ( u1_profile_idc != HIGH_PROFILE_IDC ) ) { if ( ( u1_profile_idc != EXTENDED_PROFILE_IDC ) || ( ( uc_constraint_set1_flag != 1 ) && ( uc_constraint_set0_flag != 1 ) ) ) { return ( ERROR_FEATURE_UNAVAIL ) ; } } u1_level_idc = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>u4_level_idc"" , u1_level_idc ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_SEQ_SET_ID ) return ERROR_INV_SPS_PPS_T ; u1_seq_parameter_set_id = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>seq_parameter_set_id"" , u1_seq_parameter_set_id ) ; ps_seq = ps_dec -> pv_scratch_sps_pps ; if ( ps_dec -> i4_header_decoded & 1 ) { * ps_seq = * ps_dec -> ps_cur_sps ; } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_profile_idc != u1_profile_idc ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_level_idc != u1_level_idc ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } ps_seq -> u1_profile_idc = u1_profile_idc ; ps_seq -> u1_level_idc = u1_level_idc ; ps_seq -> u1_seq_parameter_set_id = u1_seq_parameter_set_id ; ps_seq -> i4_chroma_format_idc = 1 ; ps_seq -> i4_bit_depth_luma_minus8 = 0 ; ps_seq -> i4_bit_depth_chroma_minus8 = 0 ; ps_seq -> i4_qpprime_y_zero_transform_bypass_flag = 0 ; ps_seq -> i4_seq_scaling_matrix_present_flag = 0 ; if ( u1_profile_idc == HIGH_PROFILE_IDC ) { ps_seq -> i4_chroma_format_idc = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_chroma_format_idc != 1 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_bit_depth_luma_minus8 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_bit_depth_luma_minus8 != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_bit_depth_chroma_minus8 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_bit_depth_chroma_minus8 != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_qpprime_y_zero_transform_bypass_flag = ( WORD32 ) ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ps_seq -> i4_qpprime_y_zero_transform_bypass_flag != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_seq_scaling_matrix_present_flag = ( WORD32 ) ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ps_seq -> i4_seq_scaling_matrix_present_flag ) { for ( i4_i = 0 ; i4_i < 8 ; i4_i ++ ) { ps_seq -> u1_seq_scaling_list_present_flag [ i4_i ] = ih264d_get_bit_h264 ( ps_bitstrm ) ; ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] = 0 ; if ( ps_seq -> u1_seq_scaling_list_present_flag [ i4_i ] ) { if ( i4_i < 6 ) { ih264d_scaling_list ( ps_seq -> i2_scalinglist4x4 [ i4_i ] , 16 , & ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] , ps_bitstrm ) ; } else { ih264d_scaling_list ( ps_seq -> i2_scalinglist8x8 [ i4_i - 6 ] , 64 , & ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] , ps_bitstrm ) ; } } } } } u4_temp = 4 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_BITS_IN_FRAME_NUM ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> u1_bits_in_frm_num = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>log2_max_frame_num_minus4"" , ( ps_seq -> u1_bits_in_frm_num - 4 ) ) ; i2_max_frm_num = ( 1 << ( ps_seq -> u1_bits_in_frm_num ) ) ; ps_seq -> u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1 ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_PIC_ORDER_CNT_TYPE ) { return ERROR_INV_POC_TYPE_T ; } ps_seq -> u1_pic_order_cnt_type = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>pic_order_cnt_type"" , ps_seq -> u1_pic_order_cnt_type ) ; ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle = 1 ; if ( ps_seq -> u1_pic_order_cnt_type == 0 ) { u4_temp = 4 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_BITS_IN_POC_LSB ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus = u4_temp ; ps_seq -> i4_max_pic_order_cntLsb = ( 1 << u4_temp ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>log2_max_pic_order_cnt_lsb_minus4"" , ( u4_temp - 4 ) ) ; } else if ( ps_seq -> u1_pic_order_cnt_type == 1 ) { ps_seq -> u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>delta_pic_order_always_zero_flag"" , ps_seq -> u1_delta_pic_order_always_zero_flag ) ; ps_seq -> i4_ofst_for_non_ref_pic = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>offset_for_non_ref_pic"" , ps_seq -> i4_ofst_for_non_ref_pic ) ; ps_seq -> i4_ofst_for_top_to_bottom_field = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>offset_for_top_to_bottom_field"" , ps_seq -> i4_ofst_for_top_to_bottom_field ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 255 ) return ERROR_INV_SPS_PPS_T ; ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>num_ref_frames_in_pic_order_cnt_cycle"" , ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle ) ; for ( i = 0 ; i < ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle ; i ++ ) { ps_seq -> i4_ofst_for_ref_frame [ i ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>offset_for_ref_frame"" , ps_seq -> i4_ofst_for_ref_frame [ i ] ) ; } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ( u4_temp > H264_MAX_REF_PICS ) ) { return ERROR_NUM_REF ; } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_num_ref_frames != u4_temp ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } ps_seq -> u1_num_ref_frames = u4_temp ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>num_ref_frames"" , ps_seq -> u1_num_ref_frames ) ; ps_seq -> u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>gaps_in_frame_num_value_allowed_flag"" , ps_seq -> u1_gaps_in_frame_num_value_allowed_flag ) ; ps_seq -> u2_frm_wd_in_mbs = 1 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>pic_width_in_mbs_minus1"" , ps_seq -> u2_frm_wd_in_mbs - 1 ) ; u2_pic_wd = ( ps_seq -> u2_frm_wd_in_mbs << 4 ) ; pic_height_in_map_units_minus1 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_seq -> u2_frm_ht_in_mbs = 1 + pic_height_in_map_units_minus1 ; u2_pic_ht = ( ps_seq -> u2_frm_ht_in_mbs << 4 ) ; ps_seq -> u2_max_mb_addr = ( ps_seq -> u2_frm_wd_in_mbs * ps_seq -> u2_frm_ht_in_mbs ) - 1 ; ps_seq -> u2_total_num_of_mbs = ps_seq -> u2_max_mb_addr + 1 ; ps_seq -> u1_level_idc = ih264d_correct_level_idc ( u1_level_idc , ps_seq -> u2_total_num_of_mbs ) ; u1_frm = ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_frame_mbs_only_flag != u1_frm ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } ps_seq -> u1_frame_mbs_only_flag = u1_frm ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_mbs_only_flag"" , u1_frm ) ; if ( ! u1_frm ) <S2SV_StartBug> { <S2SV_EndBug> u2_pic_ht <<= 1 ; <S2SV_StartBug> ps_seq -> u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; <S2SV_EndBug> COPYTHECONTEXT ( ""SPS:<S2SV_blank>mb_adaptive_frame_field_flag"" , ps_seq -> u1_mb_aff_flag ) ; } else ps_seq -> u1_mb_aff_flag = 0 ; ps_seq -> u1_direct_8x8_inference_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>direct_8x8_inference_flag"" , ps_seq -> u1_direct_8x8_inference_flag ) ; u1_frame_cropping_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_flag"" , u1_frame_cropping_flag ) ; if ( u1_frame_cropping_flag ) { u1_frame_cropping_rect_left_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_rect_left_offset"" , u1_frame_cropping_rect_left_ofst ) ; u1_frame_cropping_rect_right_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_rect_right_offset"" , u1_frame_cropping_rect_right_ofst ) ; u1_frame_cropping_rect_top_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_rect_top_offset"" , u1_frame_cropping_rect_top_ofst ) ; u1_frame_cropping_rect_bottom_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>frame_cropping_rect_bottom_offset"" , u1_frame_cropping_rect_bottom_ofst ) ; } ps_seq -> u1_vui_parameters_present_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SPS:<S2SV_blank>vui_parameters_present_flag"" , ps_seq -> u1_vui_parameters_present_flag ) ; u2_frm_wd_y = u2_pic_wd + ( UWORD8 ) ( PAD_LEN_Y_H << 1 ) ; if ( 1 == ps_dec -> u4_share_disp_buf ) { if ( ps_dec -> u4_app_disp_width > u2_frm_wd_y ) u2_frm_wd_y = ps_dec -> u4_app_disp_width ; } u2_frm_ht_y = u2_pic_ht + ( UWORD8 ) ( PAD_LEN_Y_V << 2 ) ; u2_frm_wd_uv = u2_pic_wd + ( UWORD8 ) ( PAD_LEN_UV_H << 2 ) ; u2_frm_wd_uv = MAX ( u2_frm_wd_uv , u2_frm_wd_y ) ; u2_frm_ht_uv = ( u2_pic_ht >> 1 ) + ( UWORD8 ) ( PAD_LEN_UV_V << 2 ) ; u2_frm_ht_uv = MAX ( u2_frm_ht_uv , ( u2_frm_ht_y >> 1 ) ) ; { UWORD16 u2_rgt_ofst = 0 ; UWORD16 u2_lft_ofst = 0 ; UWORD16 u2_top_ofst = 0 ; UWORD16 u2_btm_ofst = 0 ; UWORD8 u1_frm_mbs_flag ; UWORD8 u1_vert_mult_factor ; if ( u1_frame_cropping_flag ) { u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1 ; u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1 ; u1_frm_mbs_flag = ( 1 == ps_seq -> u1_frame_mbs_only_flag ) ; u1_vert_mult_factor = ( 2 - u1_frm_mbs_flag ) ; u2_btm_ofst = ( u1_frame_cropping_rect_bottom_ofst << u1_vert_mult_factor ) ; u2_top_ofst = ( u1_frame_cropping_rect_top_ofst << u1_vert_mult_factor ) ; } u2_crop_offset_y = ( u2_frm_wd_y * u2_top_ofst ) + ( u2_lft_ofst ) ; u2_crop_offset_uv = ( u2_frm_wd_uv * ( u2_top_ofst >> 1 ) ) + ( u2_lft_ofst >> 1 ) * YUV420SP_FACTOR ; i4_cropped_ht = u2_pic_ht - ( u2_btm_ofst + u2_top_ofst ) ; i4_cropped_wd = u2_pic_wd - ( u2_rgt_ofst + u2_lft_ofst ) ; if ( ( i4_cropped_ht < MB_SIZE ) || ( i4_cropped_wd < MB_SIZE ) ) { return ERROR_INV_SPS_PPS_T ; } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_dec -> u2_pic_wd != u2_pic_wd ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_dec -> u2_pic_ht != u2_pic_ht ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ( u2_pic_wd > H264_MAX_FRAME_WIDTH ) || ( u2_pic_ht > H264_MAX_FRAME_HEIGHT ) || ( u2_pic_wd < H264_MIN_FRAME_WIDTH ) || ( u2_pic_ht < H264_MIN_FRAME_HEIGHT ) || ( u2_pic_wd * ( UWORD32 ) u2_pic_ht > H264_MAX_FRAME_SIZE ) ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; } if ( ( u2_pic_wd << ps_seq -> u1_mb_aff_flag ) > H264_MAX_FRAME_WIDTH ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; } } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( 1 == ps_seq -> u1_vui_parameters_present_flag ) && ( 1 == ps_seq -> s_vui . u1_bitstream_restriction_flag ) ) { u4_num_reorder_frames = ps_seq -> s_vui . u4_num_reorder_frames ; } else { u4_num_reorder_frames = - 1 ; } if ( 1 == ps_seq -> u1_vui_parameters_present_flag ) { ret = ih264d_parse_vui_parametres ( & ps_seq -> s_vui , ps_bitstrm ) ; if ( ret != OK ) return ret ; } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( - 1 != ( WORD32 ) u4_num_reorder_frames ) && ( 1 == ps_seq -> u1_vui_parameters_present_flag ) && ( 1 == ps_seq -> s_vui . u1_bitstream_restriction_flag ) && ( ps_seq -> s_vui . u4_num_reorder_frames != u4_num_reorder_frames ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ps_bitstrm -> u4_ofst > ps_bitstrm -> u4_max_ofst ) { return ERROR_INV_SPS_PPS_T ; } ps_dec -> u2_disp_height = i4_cropped_ht ; ps_dec -> u2_disp_width = i4_cropped_wd ; ps_dec -> u2_pic_wd = u2_pic_wd ; ps_dec -> u2_pic_ht = u2_pic_ht ; ps_dec -> u2_frm_wd_y = u2_frm_wd_y ; ps_dec -> u2_frm_ht_y = u2_frm_ht_y ; ps_dec -> u2_frm_wd_uv = u2_frm_wd_uv ; ps_dec -> u2_frm_ht_uv = u2_frm_ht_uv ; ps_dec -> s_pad_mgr . u1_pad_len_y_v = ( UWORD8 ) ( PAD_LEN_Y_V << ( 1 - u1_frm ) ) ; ps_dec -> s_pad_mgr . u1_pad_len_cr_v = ( UWORD8 ) ( PAD_LEN_UV_V << ( 1 - u1_frm ) ) ; ps_dec -> u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; ps_dec -> u2_frm_ht_in_mbs = ps_seq -> u2_frm_ht_in_mbs ; ps_dec -> u2_crop_offset_y = u2_crop_offset_y ; ps_dec -> u2_crop_offset_uv = u2_crop_offset_uv ; ps_seq -> u1_is_valid = TRUE ; ps_dec -> ps_sps [ u1_seq_parameter_set_id ] = * ps_seq ; ps_dec -> ps_cur_sps = & ps_dec -> ps_sps [ u1_seq_parameter_set_id ] ; return OK ; }
","<S2SV_ModStart> u1_level_idc , u1_seq_parameter_set_id , u1_mb_aff_flag = 0 <S2SV_ModStart> ! u1_frm ) u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_mb_aff_flag != u1_mb_aff_flag ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ! u1_frm ) <S2SV_ModStart> -> u1_mb_aff_flag = u1_mb_aff_flag <S2SV_ModEnd> ; COPYTHECONTEXT (
"
839,"CWE-200 static int do_video_set_spu_palette ( unsigned int fd , unsigned int cmd , struct compat_video_spu_palette __user * up ) { struct video_spu_palette __user * up_native ; compat_uptr_t palp ; int length , err ; err = get_user ( palp , & up -> palette ) ; <S2SV_StartBug> err |= get_user ( length , & up -> length ) ; <S2SV_EndBug> up_native = compat_alloc_user_space ( sizeof ( struct video_spu_palette ) ) ; err = put_user ( compat_ptr ( palp ) , & up_native -> palette ) ; err |= put_user ( length , & up_native -> length ) ; if ( err ) return - EFAULT ; err = sys_ioctl ( fd , cmd , ( unsigned long ) up_native ) ; return err ; }
","<S2SV_ModStart> -> length ) ; if ( err ) return - EFAULT
"
840,"CWE-119 static vpx_codec_err_t ctrl_set_svc_parameters ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> VP9_COMP * const cpi = ctx -> cpi ; <S2SV_StartBug> vpx_svc_parameters_t * const params = va_arg ( args , vpx_svc_parameters_t * ) ; <S2SV_EndBug> <S2SV_StartBug> if ( params == NULL ) <S2SV_EndBug> return VPX_CODEC_INVALID_PARAM ; <S2SV_StartBug> cpi -> svc . spatial_layer_id = params -> spatial_layer ; <S2SV_EndBug> <S2SV_StartBug> cpi -> svc . temporal_layer_id = params -> temporal_layer ; <S2SV_EndBug> <S2SV_StartBug> cpi -> lst_fb_idx = params -> lst_fb_idx ; <S2SV_EndBug> <S2SV_StartBug> cpi -> gld_fb_idx = params -> gld_fb_idx ; <S2SV_EndBug> <S2SV_StartBug> cpi -> alt_fb_idx = params -> alt_fb_idx ; <S2SV_EndBug> if ( vp9_set_size_literal ( ctx -> cpi , params -> width , params -> height ) != 0 ) return VPX_CODEC_INVALID_PARAM ; ctx -> cfg . rc_max_quantizer = params -> max_quantizer ; ctx -> cfg . rc_min_quantizer = params -> min_quantizer ; set_encoder_config ( & ctx -> oxcf , & ctx -> cfg , & ctx -> extra_cfg ) ; vp9_change_config ( ctx -> cpi , & ctx -> oxcf ) ; return VPX_CODEC_OK ; }
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> -> cpi ; vpx_svc_extra_cfg_t <S2SV_ModEnd> * const params <S2SV_ModStart> ( args , vpx_svc_extra_cfg_t <S2SV_ModEnd> * ) ; <S2SV_ModStart> * ) ; int sl , tl ; for ( sl = 0 ; sl < <S2SV_ModEnd> cpi -> svc <S2SV_ModStart> -> svc . number_spatial_layers ; ++ sl ) { for ( tl = 0 ; tl < <S2SV_ModEnd> cpi -> svc <S2SV_ModStart> -> svc . number_temporal_layers ; ++ tl ) { const int layer = LAYER_IDS_TO_IDX ( sl , tl , cpi -> svc . number_temporal_layers ) ; LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ; lc -> max_q <S2SV_ModEnd> = params -> <S2SV_ModStart> = params -> max_quantizers [ sl ] ; lc -> min_q <S2SV_ModEnd> = params -> <S2SV_ModStart> = params -> min_quantizers [ sl ] ; lc -> scaling_factor_num <S2SV_ModEnd> = params -> <S2SV_ModStart> = params -> scaling_factor_num [ sl ] ; lc -> scaling_factor_den <S2SV_ModEnd> = params -> <S2SV_ModStart> = params -> scaling_factor_den [ sl ] ; } } <S2SV_ModEnd> return VPX_CODEC_OK ;
"
841,"CWE-000 static int ip6_frag_queue ( struct frag_queue * fq , struct sk_buff * skb , struct frag_hdr * fhdr , int nhoff ) { struct sk_buff * prev , * next ; struct net_device * dev ; int offset , end ; struct net * net = dev_net ( skb_dst ( skb ) -> dev ) ; if ( fq -> q . last_in & INET_FRAG_COMPLETE ) goto err ; offset = ntohs ( fhdr -> frag_off ) & ~ 0x7 ; end = offset + ( ntohs ( ipv6_hdr ( skb ) -> payload_len ) - ( ( u8 * ) ( fhdr + 1 ) - ( u8 * ) ( ipv6_hdr ( skb ) + 1 ) ) ) ; if ( ( unsigned int ) end > IPV6_MAXPLEN ) { IP6_INC_STATS_BH ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_INHDRERRORS ) ; icmpv6_param_prob ( skb , ICMPV6_HDR_FIELD , ( ( u8 * ) & fhdr -> frag_off - skb_network_header ( skb ) ) ) ; return - 1 ; } if ( skb -> ip_summed == CHECKSUM_COMPLETE ) { const unsigned char * nh = skb_network_header ( skb ) ; skb -> csum = csum_sub ( skb -> csum , csum_partial ( nh , ( u8 * ) ( fhdr + 1 ) - nh , 0 ) ) ; } if ( ! ( fhdr -> frag_off & htons ( IP6_MF ) ) ) { if ( end < fq -> q . len || ( ( fq -> q . last_in & INET_FRAG_LAST_IN ) && end != fq -> q . len ) ) goto err ; fq -> q . last_in |= INET_FRAG_LAST_IN ; fq -> q . len = end ; } else { if ( end & 0x7 ) { IP6_INC_STATS_BH ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_INHDRERRORS ) ; icmpv6_param_prob ( skb , ICMPV6_HDR_FIELD , offsetof ( struct ipv6hdr , payload_len ) ) ; return - 1 ; } if ( end > fq -> q . len ) { if ( fq -> q . last_in & INET_FRAG_LAST_IN ) goto err ; fq -> q . len = end ; } } if ( end == offset ) goto err ; if ( ! pskb_pull ( skb , ( u8 * ) ( fhdr + 1 ) - skb -> data ) ) goto err ; if ( pskb_trim_rcsum ( skb , end - offset ) ) goto err ; prev = fq -> q . fragments_tail ; if ( ! prev || FRAG6_CB ( prev ) -> offset < offset ) { next = NULL ; goto found ; } prev = NULL ; for ( next = fq -> q . fragments ; next != NULL ; next = next -> next ) { if ( FRAG6_CB ( next ) -> offset >= offset ) break ; prev = next ; } found : <S2SV_StartBug> if ( prev ) { <S2SV_EndBug> <S2SV_StartBug> int i = ( FRAG6_CB ( prev ) -> offset + prev -> len ) - offset ; <S2SV_EndBug> <S2SV_StartBug> if ( i > 0 ) { <S2SV_EndBug> offset += i ; if ( end <= offset ) goto err ; if ( ! pskb_pull ( skb , i ) ) goto err ; if ( skb -> ip_summed != CHECKSUM_UNNECESSARY ) skb -> ip_summed = CHECKSUM_NONE ; } } <S2SV_StartBug> while ( next && FRAG6_CB ( next ) -> offset < end ) { <S2SV_EndBug> int i = end - FRAG6_CB ( next ) -> offset ; if ( i < next -> len ) { if ( ! pskb_pull ( next , i ) ) goto err ; FRAG6_CB ( next ) -> offset += i ; fq -> q . meat -= i ; if ( next -> ip_summed != CHECKSUM_UNNECESSARY ) next -> ip_summed = CHECKSUM_NONE ; break ; } else { struct sk_buff * free_it = next ; next = next -> next ; if ( prev ) prev -> next = next ; else fq -> q . fragments = next ; fq -> q . meat -= free_it -> len ; frag_kfree_skb ( fq -> q . net , free_it ) ; } } FRAG6_CB ( skb ) -> offset = offset ; skb -> next = next ; if ( ! next ) fq -> q . fragments_tail = skb ; if ( prev ) prev -> next = skb ; else fq -> q . fragments = skb ; dev = skb -> dev ; if ( dev ) { fq -> iif = dev -> ifindex ; skb -> dev = NULL ; } fq -> q . stamp = skb -> tstamp ; fq -> q . meat += skb -> len ; atomic_add ( skb -> truesize , & fq -> q . net -> mem ) ; if ( offset == 0 ) { fq -> nhoffset = nhoff ; fq -> q . last_in |= INET_FRAG_FIRST_IN ; } if ( fq -> q . last_in == ( INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN ) && fq -> q . meat == fq -> q . len ) return ip6_frag_reasm ( fq , prev , dev ) ; write_lock ( & ip6_frags . lock ) ; list_move_tail ( & fq -> q . lru_list , & fq -> q . net -> lru_list ) ; write_unlock ( & ip6_frags . lock ) ; return - 1 ; <S2SV_StartBug> err : <S2SV_EndBug> IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_REASMFAILS ) ; kfree_skb ( skb ) ; return - 1 ; }
","<S2SV_ModStart> if ( prev && <S2SV_ModEnd> ( FRAG6_CB ( <S2SV_ModStart> ) - offset <S2SV_ModEnd> > 0 ) <S2SV_ModStart> > 0 ) goto discard_fq ; if <S2SV_ModEnd> ( next && <S2SV_ModStart> < end ) goto discard_fq ; <S2SV_ModEnd> FRAG6_CB ( skb <S2SV_ModStart> - 1 ; discard_fq : fq_kill ( fq ) ;
"
842,"CWE-190 static int tiffcp ( TIFF * in , TIFF * out ) { <S2SV_StartBug> uint16 bitspersample , samplesperpixel ; <S2SV_EndBug> <S2SV_StartBug> uint16 input_compression , input_photometric ; <S2SV_EndBug> copyFunc cf ; uint32 width , length ; struct cpTag * p ; CopyField ( TIFFTAG_IMAGEWIDTH , width ) ; CopyField ( TIFFTAG_IMAGELENGTH , length ) ; CopyField ( TIFFTAG_BITSPERSAMPLE , bitspersample ) ; CopyField ( TIFFTAG_SAMPLESPERPIXEL , samplesperpixel ) ; if ( compression != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_COMPRESSION , compression ) ; else CopyField ( TIFFTAG_COMPRESSION , compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_COMPRESSION , & input_compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PHOTOMETRIC , & input_photometric ) ; if ( input_compression == COMPRESSION_JPEG ) { TIFFSetField ( in , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else if ( input_photometric == PHOTOMETRIC_YCBCR ) { uint16 subsamplinghor , subsamplingver ; TIFFGetFieldDefaulted ( in , TIFFTAG_YCBCRSUBSAMPLING , & subsamplinghor , & subsamplingver ) ; if ( subsamplinghor != 1 || subsamplingver != 1 ) { fprintf ( stderr , ""tiffcp:<S2SV_blank>%s:<S2SV_blank>Can\'t<S2SV_blank>copy/convert<S2SV_blank>subsampled<S2SV_blank>image.\\n"" , TIFFFileName ( in ) ) ; return FALSE ; } } if ( compression == COMPRESSION_JPEG ) { if ( input_photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; else TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , input_photometric ) ; } else if ( compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24 ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , samplesperpixel == 1 ? PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV ) ; else if ( input_compression == COMPRESSION_JPEG && samplesperpixel == 3 ) { TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_RGB ) ; } else CopyTag ( TIFFTAG_PHOTOMETRIC , 1 , TIFF_SHORT ) ; if ( fillorder != 0 ) TIFFSetField ( out , TIFFTAG_FILLORDER , fillorder ) ; else CopyTag ( TIFFTAG_FILLORDER , 1 , TIFF_SHORT ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_ORIENTATION , & orientation ) ; switch ( orientation ) { case ORIENTATION_BOTRIGHT : case ORIENTATION_RIGHTBOT : TIFFWarning ( TIFFFileName ( in ) , ""using<S2SV_blank>bottom-left<S2SV_blank>orientation"" ) ; orientation = ORIENTATION_BOTLEFT ; case ORIENTATION_LEFTBOT : case ORIENTATION_BOTLEFT : break ; case ORIENTATION_TOPRIGHT : case ORIENTATION_RIGHTTOP : default : TIFFWarning ( TIFFFileName ( in ) , ""using<S2SV_blank>top-left<S2SV_blank>orientation"" ) ; orientation = ORIENTATION_TOPLEFT ; case ORIENTATION_LEFTTOP : case ORIENTATION_TOPLEFT : break ; } TIFFSetField ( out , TIFFTAG_ORIENTATION , orientation ) ; if ( outtiled == - 1 ) outtiled = TIFFIsTiled ( in ) ; if ( outtiled ) { if ( tilewidth == ( uint32 ) - 1 ) TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tilewidth ) ; if ( tilelength == ( uint32 ) - 1 ) TIFFGetField ( in , TIFFTAG_TILELENGTH , & tilelength ) ; TIFFDefaultTileSize ( out , & tilewidth , & tilelength ) ; TIFFSetField ( out , TIFFTAG_TILEWIDTH , tilewidth ) ; TIFFSetField ( out , TIFFTAG_TILELENGTH , tilelength ) ; } else { if ( rowsperstrip == ( uint32 ) 0 ) { if ( ! TIFFGetField ( in , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ) { rowsperstrip = TIFFDefaultStripSize ( out , rowsperstrip ) ; } if ( rowsperstrip > length && rowsperstrip != ( uint32 ) - 1 ) rowsperstrip = length ; } else if ( rowsperstrip == ( uint32 ) - 1 ) rowsperstrip = length ; TIFFSetField ( out , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ; } if ( config != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_PLANARCONFIG , config ) ; else CopyField ( TIFFTAG_PLANARCONFIG , config ) ; if ( samplesperpixel <= 4 ) CopyTag ( TIFFTAG_TRANSFERFUNCTION , 4 , TIFF_SHORT ) ; CopyTag ( TIFFTAG_COLORMAP , 4 , TIFF_SHORT ) ; switch ( compression ) { case COMPRESSION_JPEG : TIFFSetField ( out , TIFFTAG_JPEGQUALITY , quality ) ; TIFFSetField ( out , TIFFTAG_JPEGCOLORMODE , jpegcolormode ) ; break ; case COMPRESSION_JBIG : CopyTag ( TIFFTAG_FAXRECVPARAMS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVTIME , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXSUBADDRESS , 1 , TIFF_ASCII ) ; CopyTag ( TIFFTAG_FAXDCS , 1 , TIFF_ASCII ) ; break ; case COMPRESSION_LZW : case COMPRESSION_ADOBE_DEFLATE : case COMPRESSION_DEFLATE : case COMPRESSION_LZMA : if ( predictor != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_PREDICTOR , predictor ) ; else CopyField ( TIFFTAG_PREDICTOR , predictor ) ; if ( preset != - 1 ) { if ( compression == COMPRESSION_ADOBE_DEFLATE || compression == COMPRESSION_DEFLATE ) TIFFSetField ( out , TIFFTAG_ZIPQUALITY , preset ) ; else if ( compression == COMPRESSION_LZMA ) TIFFSetField ( out , TIFFTAG_LZMAPRESET , preset ) ; } break ; case COMPRESSION_CCITTFAX3 : case COMPRESSION_CCITTFAX4 : if ( compression == COMPRESSION_CCITTFAX3 ) { if ( g3opts != ( uint32 ) - 1 ) TIFFSetField ( out , TIFFTAG_GROUP3OPTIONS , g3opts ) ; else CopyField ( TIFFTAG_GROUP3OPTIONS , g3opts ) ; } else CopyTag ( TIFFTAG_GROUP4OPTIONS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_BADFAXLINES , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_CLEANFAXDATA , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_CONSECUTIVEBADFAXLINES , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVPARAMS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVTIME , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXSUBADDRESS , 1 , TIFF_ASCII ) ; break ; } { uint32 len32 ; void * * data ; if ( TIFFGetField ( in , TIFFTAG_ICCPROFILE , & len32 , & data ) ) TIFFSetField ( out , TIFFTAG_ICCPROFILE , len32 , data ) ; } { uint16 ninks ; const char * inknames ; if ( TIFFGetField ( in , TIFFTAG_NUMBEROFINKS , & ninks ) ) { TIFFSetField ( out , TIFFTAG_NUMBEROFINKS , ninks ) ; if ( TIFFGetField ( in , TIFFTAG_INKNAMES , & inknames ) ) { int inknameslen = strlen ( inknames ) + 1 ; const char * cp = inknames ; while ( ninks > 1 ) { cp = strchr ( cp , '\\0' ) ; cp ++ ; inknameslen += ( strlen ( cp ) + 1 ) ; ninks -- ; } TIFFSetField ( out , TIFFTAG_INKNAMES , inknameslen , inknames ) ; } } } { unsigned short pg0 , pg1 ; if ( pageInSeq == 1 ) { if ( pageNum < 0 ) { if ( TIFFGetField ( in , TIFFTAG_PAGENUMBER , & pg0 , & pg1 ) ) TIFFSetField ( out , TIFFTAG_PAGENUMBER , pg0 , pg1 ) ; } else TIFFSetField ( out , TIFFTAG_PAGENUMBER , pageNum ++ , 0 ) ; } else { if ( TIFFGetField ( in , TIFFTAG_PAGENUMBER , & pg0 , & pg1 ) ) { if ( pageNum < 0 ) TIFFSetField ( out , TIFFTAG_PAGENUMBER , pg0 , pg1 ) ; else TIFFSetField ( out , TIFFTAG_PAGENUMBER , pageNum ++ , 0 ) ; } } } for ( p = tags ; p < & tags [ NTAGS ] ; p ++ ) CopyTag ( p -> tag , p -> count , p -> type ) ; cf = pickCopyFunc ( in , out , bitspersample , samplesperpixel ) ; return ( cf ? ( * cf ) ( in , out , length , width , samplesperpixel ) : FALSE ) ; }
","<S2SV_ModStart> bitspersample , samplesperpixel = 1 <S2SV_ModStart> input_compression , input_photometric = PHOTOMETRIC_MINISBLACK
"
843,"CWE-20 static int check_symlinks ( struct archive_write_disk * a ) { <S2SV_StartBug> # if ! defined ( HAVE_LSTAT ) <S2SV_EndBug> ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; <S2SV_StartBug> r = lstat ( a -> name , & st ) ; <S2SV_EndBug> <S2SV_StartBug> if ( r != 0 ) { <S2SV_EndBug> if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { <S2SV_StartBug> archive_set_error ( & a -> archive , errno , <S2SV_EndBug> ""Could<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; <S2SV_StartBug> } <S2SV_EndBug> a -> pst = NULL ; <S2SV_StartBug> if ( ! S_ISLNK ( a -> mode ) ) { <S2SV_EndBug> archive_set_error ( & a -> archive , 0 , ""Removing<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannot<S2SV_blank>remove<S2SV_blank>intervening<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } a -> pst = NULL ; } else { archive_set_error ( & a -> archive , 0 , ""Cannot<S2SV_blank>extract<S2SV_blank>through<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } pn [ 0 ] = c ; if ( pn [ 0 ] != '\\0' ) pn ++ ; } pn [ 0 ] = c ; archive_strcpy ( & a -> path_safe , a -> name ) ; return ( ARCHIVE_OK ) ; # endif }
","<S2SV_ModStart> a ) { struct archive_string error_string ; int error_number ; int rc ; archive_string_init ( & error_string ) ; rc = check_symlinks_fsobj <S2SV_ModEnd> ( a -> <S2SV_ModStart> name , & error_number , & error_string , a -> flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( rc != ARCHIVE_OK <S2SV_ModEnd> ) { archive_set_error <S2SV_ModStart> -> archive , error_number , ""%s"" , error_string . s <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } archive_string_free ( & error_string ) ; <S2SV_ModStart> = NULL ; return rc ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
"
844,"CWE-59 static int fill_autodev ( const struct lxc_rootfs * rootfs ) { int ret ; char path [ MAXPATHLEN ] ; int i ; mode_t cmask ; INFO ( ""Creating<S2SV_blank>initial<S2SV_blank>consoles<S2SV_blank>under<S2SV_blank>container<S2SV_blank>/dev"" ) ; ret = snprintf ( path , MAXPATHLEN , ""%s/dev"" , rootfs -> path ? rootfs -> mount : """" ) ; if ( ret < 0 || ret >= MAXPATHLEN ) { ERROR ( ""Error<S2SV_blank>calculating<S2SV_blank>container<S2SV_blank>/dev<S2SV_blank>location"" ) ; return - 1 ; } if ( ! dir_exists ( path ) ) return 0 ; INFO ( ""Populating<S2SV_blank>container<S2SV_blank>/dev"" ) ; cmask = umask ( S_IXUSR | S_IXGRP | S_IXOTH ) ; for ( i = 0 ; i < sizeof ( lxc_devs ) / sizeof ( lxc_devs [ 0 ] ) ; i ++ ) { const struct lxc_devs * d = & lxc_devs [ i ] ; ret = snprintf ( path , MAXPATHLEN , ""%s/dev/%s"" , rootfs -> path ? rootfs -> mount : """" , d -> name ) ; if ( ret < 0 || ret >= MAXPATHLEN ) return - 1 ; ret = mknod ( path , d -> mode , makedev ( d -> maj , d -> min ) ) ; if ( ret && errno != EEXIST ) { char hostpath [ MAXPATHLEN ] ; FILE * pathfile ; ret = snprintf ( hostpath , MAXPATHLEN , ""/dev/%s"" , d -> name ) ; if ( ret < 0 || ret >= MAXPATHLEN ) return - 1 ; pathfile = fopen ( path , ""wb"" ) ; if ( ! pathfile ) { SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>device<S2SV_blank>mount<S2SV_blank>target<S2SV_blank>\'%s\'"" , path ) ; return - 1 ; } fclose ( pathfile ) ; <S2SV_StartBug> if ( mount ( hostpath , path , 0 , MS_BIND , NULL ) != 0 ) { <S2SV_EndBug> SYSERROR ( ""Failed<S2SV_blank>bind<S2SV_blank>mounting<S2SV_blank>device<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>host<S2SV_blank>into<S2SV_blank>container"" , d -> name ) ; return - 1 ; } } } umask ( cmask ) ; INFO ( ""Populated<S2SV_blank>container<S2SV_blank>/dev"" ) ; return 0 ; }
","<S2SV_ModStart> ; if ( safe_mount ( hostpath , path , 0 , MS_BIND , NULL , rootfs -> path ? rootfs -> mount : <S2SV_ModEnd> NULL ) !=
"
845,"CWE-399 static void __udf_read_inode ( struct inode * inode ) { struct buffer_head * bh = NULL ; struct fileEntry * fe ; struct extendedFileEntry * efe ; uint16_t ident ; struct udf_inode_info * iinfo = UDF_I ( inode ) ; struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ; <S2SV_StartBug> unsigned int link_count ; <S2SV_EndBug> bh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 0 , & ident ) ; if ( ! bh ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>!bh\\n"" , inode -> i_ino ) ; make_bad_inode ( inode ) ; return ; } if ( ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE && ident != TAG_IDENT_USE ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>ident=%d\\n"" , inode -> i_ino , ident ) ; brelse ( bh ) ; make_bad_inode ( inode ) ; return ; } fe = ( struct fileEntry * ) bh -> b_data ; efe = ( struct extendedFileEntry * ) bh -> b_data ; if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4096 ) ) { struct buffer_head * ibh ; ibh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 1 , & ident ) ; if ( ident == TAG_IDENT_IE && ibh ) { <S2SV_StartBug> struct buffer_head * nbh = NULL ; <S2SV_EndBug> struct kernel_lb_addr loc ; struct indirectEntry * ie ; ie = ( struct indirectEntry * ) ibh -> b_data ; loc = lelb_to_cpu ( ie -> indirectICB . extLocation ) ; <S2SV_StartBug> if ( ie -> indirectICB . extLength && <S2SV_EndBug> <S2SV_StartBug> ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 , <S2SV_EndBug> & ident ) ) ) { if ( ident == TAG_IDENT_FE || ident == TAG_IDENT_EFE ) { memcpy ( & iinfo -> i_location , & loc , sizeof ( struct kernel_lb_addr ) ) ; brelse ( bh ) ; brelse ( ibh ) ; brelse ( nbh ) ; __udf_read_inode ( inode ) ; return ; } <S2SV_StartBug> brelse ( nbh ) ; <S2SV_EndBug> } } brelse ( ibh ) ; } else if ( fe -> icbTag . strategyType != cpu_to_le16 ( 4 ) ) { udf_err ( inode -> i_sb , ""unsupported<S2SV_blank>strategy<S2SV_blank>type:<S2SV_blank>%d\\n"" , le16_to_cpu ( fe -> icbTag . strategyType ) ) ; brelse ( bh ) ; make_bad_inode ( inode ) ; return ; } if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4 ) ) iinfo -> i_strat4096 = 0 ; else iinfo -> i_strat4096 = 1 ; iinfo -> i_alloc_type = le16_to_cpu ( fe -> icbTag . flags ) & ICBTAG_FLAG_AD_MASK ; iinfo -> i_unique = 0 ; iinfo -> i_lenEAttr = 0 ; iinfo -> i_lenExtents = 0 ; iinfo -> i_lenAlloc = 0 ; iinfo -> i_next_alloc_block = 0 ; iinfo -> i_next_alloc_goal = 0 ; if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_EFE ) ) { iinfo -> i_efe = 1 ; iinfo -> i_use = 0 ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct extendedFileEntry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct extendedFileEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct extendedFileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_FE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 0 ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct fileEntry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct fileEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct fileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_USE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 1 ; iinfo -> i_lenAlloc = le32_to_cpu ( ( ( struct unallocSpaceEntry * ) bh -> b_data ) -> lengthAllocDescs ) ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct unallocSpaceEntry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct unallocSpaceEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct unallocSpaceEntry ) ) ; return ; } read_lock ( & sbi -> s_cred_lock ) ; i_uid_write ( inode , le32_to_cpu ( fe -> uid ) ) ; if ( ! uid_valid ( inode -> i_uid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_SET ) ) inode -> i_uid = UDF_SB ( inode -> i_sb ) -> s_uid ; i_gid_write ( inode , le32_to_cpu ( fe -> gid ) ) ; if ( ! gid_valid ( inode -> i_gid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_SET ) ) inode -> i_gid = UDF_SB ( inode -> i_sb ) -> s_gid ; if ( fe -> icbTag . fileType != ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_fmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_fmode ; else if ( fe -> icbTag . fileType == ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_dmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_dmode ; else inode -> i_mode = udf_convert_permissions ( fe ) ; inode -> i_mode &= ~ sbi -> s_umask ; read_unlock ( & sbi -> s_cred_lock ) ; link_count = le16_to_cpu ( fe -> fileLinkCount ) ; if ( ! link_count ) link_count = 1 ; set_nlink ( inode , link_count ) ; inode -> i_size = le64_to_cpu ( fe -> informationLength ) ; iinfo -> i_lenExtents = inode -> i_size ; if ( iinfo -> i_efe == 0 ) { inode -> i_blocks = le64_to_cpu ( fe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , fe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , fe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , fe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( fe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( fe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( fe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( fe -> checkpoint ) ; } else { inode -> i_blocks = le64_to_cpu ( efe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , efe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , efe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & iinfo -> i_crtime , efe -> createTime ) ) iinfo -> i_crtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , efe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( efe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( efe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( efe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( efe -> checkpoint ) ; } switch ( fe -> icbTag . fileType ) { case ICBTAG_FILE_TYPE_DIRECTORY : inode -> i_op = & udf_dir_inode_operations ; inode -> i_fop = & udf_dir_operations ; inode -> i_mode |= S_IFDIR ; inc_nlink ( inode ) ; break ; case ICBTAG_FILE_TYPE_REALTIME : case ICBTAG_FILE_TYPE_REGULAR : case ICBTAG_FILE_TYPE_UNDEF : case ICBTAG_FILE_TYPE_VAT20 : if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) inode -> i_data . a_ops = & udf_adinicb_aops ; else inode -> i_data . a_ops = & udf_aops ; inode -> i_op = & udf_file_inode_operations ; inode -> i_fop = & udf_file_operations ; inode -> i_mode |= S_IFREG ; break ; case ICBTAG_FILE_TYPE_BLOCK : inode -> i_mode |= S_IFBLK ; break ; case ICBTAG_FILE_TYPE_CHAR : inode -> i_mode |= S_IFCHR ; break ; case ICBTAG_FILE_TYPE_FIFO : init_special_inode ( inode , inode -> i_mode | S_IFIFO , 0 ) ; break ; case ICBTAG_FILE_TYPE_SOCKET : init_special_inode ( inode , inode -> i_mode | S_IFSOCK , 0 ) ; break ; case ICBTAG_FILE_TYPE_SYMLINK : inode -> i_data . a_ops = & udf_symlink_aops ; inode -> i_op = & udf_symlink_inode_operations ; inode -> i_mode = S_IFLNK | S_IRWXUGO ; break ; case ICBTAG_FILE_TYPE_MAIN : udf_debug ( ""METADATA<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_MIRROR : udf_debug ( ""METADATA<S2SV_blank>MIRROR<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_BITMAP : udf_debug ( ""METADATA<S2SV_blank>BITMAP<S2SV_blank>FILE-----\\n"" ) ; break ; default : udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>unknown<S2SV_blank>file<S2SV_blank>type=%d\\n"" , inode -> i_ino , fe -> icbTag . fileType ) ; make_bad_inode ( inode ) ; return ; } if ( S_ISCHR ( inode -> i_mode ) || S_ISBLK ( inode -> i_mode ) ) { struct deviceSpec * dsea = ( struct deviceSpec * ) udf_get_extendedattr ( inode , 12 , 1 ) ; if ( dsea ) { init_special_inode ( inode , inode -> i_mode , MKDEV ( le32_to_cpu ( dsea -> majorDeviceIdent ) , le32_to_cpu ( dsea -> minorDeviceIdent ) ) ) ; } else make_bad_inode ( inode ) ; } brelse ( bh ) ; }
","<S2SV_ModStart> int link_count ; unsigned int indirections = 0 ; reread : <S2SV_ModStart> ) { struct <S2SV_ModEnd> kernel_lb_addr loc ; <S2SV_ModStart> indirectICB . extLength ) { brelse ( bh ) ; brelse ( ibh ) ; memcpy ( & iinfo -> i_location <S2SV_ModEnd> , & loc <S2SV_ModStart> & loc , sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > UDF_MAX_ICB_NESTING ) { udf_err ( inode -> i_sb , ""too<S2SV_blank>many<S2SV_blank>ICBs<S2SV_blank>in<S2SV_blank>ICB<S2SV_blank>hierarchy"" ""<S2SV_blank>(max<S2SV_blank>%d<S2SV_blank>supported)\\n"" , UDF_MAX_ICB_NESTING ) ; make_bad_inode <S2SV_ModEnd> ( inode ) <S2SV_ModStart> return ; } goto reread <S2SV_ModEnd> ; } }
"
846,"CWE-119 static void build_masks ( const loop_filter_info_n * const lfi_n , const MODE_INFO * mi , const int shift_y , const int shift_uv , LOOP_FILTER_MASK * lfm ) { const MB_MODE_INFO * mbmi = & mi -> mbmi ; const BLOCK_SIZE block_size = mbmi -> sb_type ; const TX_SIZE tx_size_y = mbmi -> tx_size ; <S2SV_StartBug> const TX_SIZE tx_size_uv = get_uv_tx_size ( mbmi ) ; <S2SV_EndBug> const int filter_level = get_filter_level ( lfi_n , mbmi ) ; uint64_t * const left_y = & lfm -> left_y [ tx_size_y ] ; uint64_t * const above_y = & lfm -> above_y [ tx_size_y ] ; uint64_t * const int_4x4_y = & lfm -> int_4x4_y ; uint16_t * const left_uv = & lfm -> left_uv [ tx_size_uv ] ; uint16_t * const above_uv = & lfm -> above_uv [ tx_size_uv ] ; uint16_t * const int_4x4_uv = & lfm -> int_4x4_uv ; int i ; if ( ! filter_level ) { return ; } else { const int w = num_8x8_blocks_wide_lookup [ block_size ] ; const int h = num_8x8_blocks_high_lookup [ block_size ] ; int index = shift_y ; for ( i = 0 ; i < h ; i ++ ) { <S2SV_StartBug> vpx_memset ( & lfm -> lfl_y [ index ] , filter_level , w ) ; <S2SV_EndBug> index += 8 ; } } * above_y |= above_prediction_mask [ block_size ] << shift_y ; * above_uv |= above_prediction_mask_uv [ block_size ] << shift_uv ; * left_y |= left_prediction_mask [ block_size ] << shift_y ; * left_uv |= left_prediction_mask_uv [ block_size ] << shift_uv ; if ( mbmi -> skip && is_inter_block ( mbmi ) ) return ; * above_y |= ( size_mask [ block_size ] & above_64x64_txform_mask [ tx_size_y ] ) << shift_y ; * above_uv |= ( size_mask_uv [ block_size ] & above_64x64_txform_mask_uv [ tx_size_uv ] ) << shift_uv ; * left_y |= ( size_mask [ block_size ] & left_64x64_txform_mask [ tx_size_y ] ) << shift_y ; * left_uv |= ( size_mask_uv [ block_size ] & left_64x64_txform_mask_uv [ tx_size_uv ] ) << shift_uv ; if ( tx_size_y == TX_4X4 ) <S2SV_StartBug> * int_4x4_y |= ( size_mask [ block_size ] & 0xffffffffffffffff ) << shift_y ; <S2SV_EndBug> if ( tx_size_uv == TX_4X4 ) * int_4x4_uv |= ( size_mask_uv [ block_size ] & 0xffff ) << shift_uv ; }
","<S2SV_ModStart> TX_SIZE tx_size_uv = get_uv_tx_size_impl ( tx_size_y , block_size , 1 , 1 <S2SV_ModEnd> ) ; const <S2SV_ModStart> ++ ) { memset <S2SV_ModEnd> ( & lfm <S2SV_ModStart> block_size ] & 0xffffffffffffffffULL <S2SV_ModEnd> ) << shift_y
"
847,"CWE-20 int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { <S2SV_StartBug> int namelen = strlen ( name ) ; <S2SV_EndBug> int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; <S2SV_StartBug> data ++ ; <S2SV_EndBug> for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; <S2SV_StartBug> if ( ! size ) <S2SV_EndBug> break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; <S2SV_StartBug> if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { <S2SV_EndBug> switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : <S2SV_StartBug> snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; <S2SV_EndBug> break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
","<S2SV_ModStart> dst_size ) { GetByteContext gb <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( data >= data_end <S2SV_ModEnd> ) return - <S2SV_ModStart> - 1 ; bytestream2_init ( & gb , data , data_end - <S2SV_ModEnd> data ) ; <S2SV_ModStart> data ) ; return amf_get_field_value2 ( & gb <S2SV_ModEnd> , name , <S2SV_ModStart> , name , <S2SV_ModEnd> dst , dst_size <S2SV_ModStart> dst , dst_size ) <S2SV_ModEnd> ; } <S2SV_null>
"
848,"CWE-119 static void t1_check_unusual_charstring ( void ) { char * p = strstr ( t1_line_array , charstringname ) + strlen ( charstringname ) ; int i ; if ( sscanf ( p , ""%i"" , & i ) != 1 ) { strcpy ( t1_buf_array , t1_line_array ) ; t1_getline ( ) ; <S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> strcpy ( t1_line_array , t1_buf_array ) ; t1_line_ptr = eol ( t1_line_array ) ; } }
","<S2SV_ModStart> ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE
"
849,"CWE-362 static void flush_end_io ( struct request * flush_rq , int error ) { struct request_queue * q = flush_rq -> q ; struct list_head * running ; bool queued = false ; struct request * rq , * n ; unsigned long flags = 0 ; struct blk_flush_queue * fq = blk_get_flush_queue ( q , flush_rq -> mq_ctx ) ; if ( q -> mq_ops ) { <S2SV_StartBug> spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ; <S2SV_EndBug> flush_rq -> tag = - 1 ; } running = & fq -> flush_queue [ fq -> flush_running_idx ] ; BUG_ON ( fq -> flush_pending_idx == fq -> flush_running_idx ) ; fq -> flush_running_idx ^= 1 ; if ( ! q -> mq_ops ) elv_completed_request ( q , flush_rq ) ; list_for_each_entry_safe ( rq , n , running , flush . list ) { unsigned int seq = blk_flush_cur_seq ( rq ) ; BUG_ON ( seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH ) ; queued |= blk_flush_complete_seq ( rq , fq , seq , error ) ; } if ( queued || fq -> flush_queue_delayed ) { WARN_ON ( q -> mq_ops ) ; blk_run_queue_async ( q ) ; } fq -> flush_queue_delayed = 0 ; if ( q -> mq_ops ) spin_unlock_irqrestore ( & fq -> mq_flush_lock , flags ) ; }
","<S2SV_ModStart> mq_ops ) { struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> mq_flush_lock , flags ) ; hctx = q -> mq_ops -> map_queue ( q , flush_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , flush_rq -> tag , fq -> orig_rq
"
850,"CWE-269 uint32_t virtio_config_readb ( VirtIODevice * vdev , uint32_t addr ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint8_t val ; <S2SV_StartBug> k -> get_config ( vdev , vdev -> config ) ; <S2SV_EndBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) return ( uint32_t ) - 1 ; val = ldub_p ( vdev -> config + addr ) ; return val ; }
","<S2SV_ModStart> uint8_t val ; if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; } <S2SV_ModStart> -> config ) <S2SV_ModEnd> ; val =
"
851,"CWE-400 int regexec ( Reprog * prog , const char * sp , Resub * sub , int eflags ) { Resub scratch ; int i ; if ( ! sub ) sub = & scratch ; sub -> nsub = prog -> nsub ; for ( i = 0 ; i < MAXSUB ; ++ i ) sub -> sub [ i ] . sp = sub -> sub [ i ] . ep = NULL ; <S2SV_StartBug> return ! match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ; <S2SV_EndBug> }
","<S2SV_ModStart> NULL ; return <S2SV_ModEnd> match ( prog <S2SV_ModStart> eflags , sub , 0
"
852,"CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> swabHorDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; <S2SV_StartBug> horDiff16 ( tif , cp0 , cc ) ; <S2SV_EndBug> TIFFSwabArrayOfShort ( wp , wc ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> swabHorDiff16 ( TIFF <S2SV_ModStart> / 2 ; if ( ! <S2SV_ModStart> , cc ) ) return 0 <S2SV_ModStart> wc ) ; return 1 ;
"
